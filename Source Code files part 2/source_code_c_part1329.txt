,0};
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzCC = NULL;
    DWORD dwSizeRequired;

    *ppGroups = NULL;

    if(!AuthzInitializeContextFromSid(
            0,
            pSid,
            AuthzRM,
            NULL,
            luid, //ignored
            NULL,
            &AuthzCC))
    {
        hr = myHError(GetLastError()); 
        _JumpError(hr, error, "AuthzInitializeContextFromSid");
    }

    if(!AuthzGetInformationFromContext(
            AuthzCC,
            AuthzContextInfoGroupsSids,
            0,
            &dwSizeRequired,
            NULL))
    {
        if(ERROR_INSUFFICIENT_BUFFER!=GetLastError())
        {
            hr = myHError(GetLastError()); 
            _JumpError(hr, error, "AuthzGetContextInformation");
        }
    }

    *ppGroups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, dwSizeRequired);
    if(!*ppGroups)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!AuthzGetInformationFromContext(
            AuthzCC,
            AuthzContextInfoGroupsSids,
            dwSizeRequired,
            &dwSizeRequired,
            *ppGroups))
    {
        hr = myHError(GetLastError()); 
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

error:
    if(AuthzCC)
    {
        AuthzFreeContext(AuthzCC);
    }
    if(S_OK!=hr && *ppGroups)
    {
        LocalFree(*ppGroups);
    }
    return hr;
}

HRESULT GetRequesterName(DWORD dwRequestId, LPWSTR *ppwszName)
{
    HRESULT hr = S_OK;
    ICertDBRow *prow = NULL;

    hr = g_pCertDB->OpenRow(
                        PROPOPEN_READONLY | PROPTABLE_REQCERT,
                        dwRequestId,
                        NULL,
                        &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PKCSGetProperty(
                prow,
                g_wszPropRequesterName,
                PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                NULL,
                (BYTE **) ppwszName);
    _JumpIfError(hr, error, "PKCSGetProperty");

error:
    if(prow)
    {
        prow->Release();
    }
    return hr;
}

HRESULT CheckOfficerRights(DWORD dwRequestID, CAuditEvent& event)
{
    HRESULT hr = S_OK;
    LPWSTR pwszRequesterName = NULL;

    // officer rights disabled means every officer is allowed to manage requests
    // for everyone, so return ok
    if(!g_OfficerRightsSD.IsEnabled())
        return S_OK;

    hr = GetRequesterName(dwRequestID, &pwszRequesterName);
    if(CERTSRV_E_PROPERTY_EMPTY!=hr &&
       S_OK != hr)
    {
        _JumpError(hr, error, "GetRequesterName");
    }

    hr = CheckOfficerRights(pwszRequesterName, event);

error:
    if(pwszRequesterName)
    {
        LocalFree(pwszRequesterName);
    }
    return hr;
}

// Verify if impersonated user has the rights over the specified request,
// based on the officer rights defined in the global officer SD and the
// requester name stored in the request
// Return S_OK if allowed or if the officer rights feature is disabled
//        E_ACCESSDENIED if not allowed
//        E_* if failed to check the rights
HRESULT CheckOfficerRights(LPCWSTR pwszRequesterName, CAuditEvent& event)
{
    HRESULT hr = S_OK;
    IServerSecurity *pISS = NULL;
    HANDLE hThread = NULL;
    HANDLE hToken = NULL;
    PSECURITY_DESCRIPTOR pOfficerSD = NULL;
    static LUID luid = {0,0};
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzCC = NULL;
    AUTHZ_ACCESS_REQUEST AuthzRequest;
    AUTHZ_ACCESS_REPLY AuthzReply;
    ACCESS_MASK GrantedMask;
    DWORD dwError = 0;
    DWORD dwSaclEval = 0;
    bool fImpersonating = false;

    // officer rights disabled means every officer is allowed to manage requests
    // for everyone, so return ok
    if(!g_OfficerRightsSD.IsEnabled())
        return S_OK;

    hr = CoGetCallContext(IID_IServerSecurity, (void**)&pISS);
    _JumpIfError(hr, error, "CoGetCallContext");

    if (!pISS->IsImpersonating())
    {
        hr = pISS->ImpersonateClient();
        _JumpIfError(hr, error, "ImpersonateClient");
    }
    else
    {
        pISS->Release();
        pISS = NULL;
    }

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }
    if (!OpenThreadToken(hThread,
                         TOKEN_QUERY,
                         FALSE,  // client impersonation
                         &hToken))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "OpenThreadToken");
    }

    if(!AuthzInitializeContextFromToken(
        0,
        hToken,
        g_AuthzCertSrvRM,
        NULL,
        luid,
        NULL,
        &AuthzCC))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitializeContextFromToken");
    }

    CloseHandle(hToken);
    hToken = NULL;

    if(pISS) // impersonating
    {
        pISS->RevertToSelf();
        pISS->Release();
        pISS = NULL;        
    }

    AuthzRequest.DesiredAccess = DELETE;
    AuthzRequest.PrincipalSelfSid = NULL;
    AuthzRequest.ObjectTypeList = NULL;
    AuthzRequest.ObjectTypeListLength = 0;
    
    AuthzRequest.OptionalArguments = (void*)pwszRequesterName;

    AuthzReply.ResultListLength = 1;
    AuthzReply.GrantedAccessMask  = &GrantedMask;
    AuthzReply.Error = &dwError;
    AuthzReply.SaclEvaluationResults = &dwSaclEval;
    

    hr = g_OfficerRightsSD.LockGet(&pOfficerSD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    CSASSERT(IsValidSecurityDescriptor(pOfficerSD));

    if(!AuthzAccessCheck(
        0,
        AuthzCC,
        &AuthzRequest,
        NULL, //no audit
        pOfficerSD,
        NULL,
        0,
        &AuthzReply,
        NULL))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzAccessCheck");
    }

    hr = AuthzReply.Error[0]==ERROR_SUCCESS?S_OK:CERTSRV_E_RESTRICTEDOFFICER;

error:

    if(AuthzCC)
    {
        AuthzFreeContext(AuthzCC);
    }
    if(pOfficerSD)
    {
        g_OfficerRightsSD.Unlock();
    }
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }

    if (NULL != hToken)
    {
        CloseHandle(hToken);
    }
    if (NULL != pISS)
    {
        pISS->RevertToSelf();
        pISS->Release();
    }    

    // generate a failure audit event if restricted officer
    if(CERTSRV_E_RESTRICTEDOFFICER==hr)
    {
        HRESULT hrtemp = event.AccessCheck(
            CA_ACCESS_DENIED,
            event.m_gcNoAuditSuccess);

        if(S_OK!=hrtemp && E_ACCESSDENIED!=hrtemp)
            hr = hrtemp;
    }

    return hr;
}

} // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\certsrvd.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certsrvd.cpp
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define SECURITY_WIN32
#include <security.h>

#include <lmcons.h>
#include <accctrl.h>

#include "certsrvd.h"
#include "admin.h"
#include "request.h"
#include "certacl.h"

//temporary
#include <msaudite.h>


using namespace CertSrv;

// Global Access List
CCertificateAuthoritySD g_CASD;
AUTHZ_RESOURCE_MANAGER_HANDLE g_AuthzCertSrvRM;
DWORD g_dwAuditFilter;
COfficerRightsSD g_OfficerRightsSD;
CConfigStorage g_ConfigStorage;

GENERIC_MAPPING g_CertGenericMapping = {
    READ_CONTROL | ACTRL_DS_READ_PROP,     
    WRITE_DAC | WRITE_OWNER | ACTRL_DS_WRITE_PROP,     
    0, 
    ACTRL_DS_READ_PROP | 
        ACTRL_DS_WRITE_PROP | 
        READ_CONTROL | 
        WRITE_DAC | 
        WRITE_OWNER 
};


// GetClientUserName() impersonates the client

HRESULT
GetClientUserName(
    IN handle_t hRpc,
    OPTIONAL OUT WCHAR **ppwszUserSamName,
    OPTIONAL OUT WCHAR **ppwszUserDN)
{
    HRESULT hr;
    IServerSecurity *pISS = NULL;
    bool fImpersonating = false;
    WCHAR *pwszUserSamName = NULL;

    if (NULL != ppwszUserSamName)
    {
	*ppwszUserSamName = NULL;
    }
    if (NULL != ppwszUserDN)
    {
	*ppwszUserDN = NULL;
    }
    if (NULL == hRpc)
    {
        // dcom impersonate
        // get client info and impersonate client

        hr = CoGetCallContext(IID_IServerSecurity, (void**)&pISS);
        _JumpIfError(hr, error, "CoGetCallContext");

        hr = pISS->ImpersonateClient();
        _JumpIfError(hr, error, "ImpersonateClient");
    }
    else
    {
        // rpc impersonate

        hr = RpcImpersonateClient((RPC_BINDING_HANDLE) hRpc);
	_JumpIfError(hr, error, "RpcImpersonateClient");
    }
    fImpersonating = true;
    
    if (NULL != ppwszUserSamName)
    {
	hr = myGetUserNameEx(NameSamCompatible, &pwszUserSamName);
	_JumpIfError(hr, error, "myGetUserNameEx");
    }
    if (NULL != ppwszUserDN)
    {
	hr = myGetUserNameEx(NameFullyQualifiedDN, ppwszUserDN);
	_JumpIfError(hr, error, "myGetUserNameEx");
    }
    if (NULL != ppwszUserSamName)
    {
	*ppwszUserSamName = pwszUserSamName;
	pwszUserSamName = NULL;
    }
    hr = S_OK;

error:
    if (fImpersonating)
    {
        if (NULL != hRpc)
        {
            RpcRevertToSelf();
        }
        else  // dcom
        {
            pISS->RevertToSelf();
        }
    }
    if (NULL != pISS)
    {
        pISS->Release();
    }
    if (NULL != pwszUserSamName)
    {
	LocalFree(pwszUserSamName);
    }
    return(hr);
}

STDMETHODIMP
CheckCertSrvAccess(
    OPTIONAL IN LPCWSTR pwszAuthority,
    IN handle_t hRpc,
    IN ACCESS_MASK Mask,
    OUT BOOL *pfAccessAllowed,
    OPTIONAL OUT HANDLE *phToken)
{
    HRESULT            hr = S_OK;
    DWORD              dwErr = ERROR_SUCCESS;    
    HANDLE             hClientToken = NULL;
    HANDLE             hThread = NULL;
    IServerSecurity   *pISS = NULL;
    PRIVILEGE_SET      ps;
    DWORD              dwPSSize = sizeof(PRIVILEGE_SET);
    DWORD              grantAccess;
    DWORD              dwType;
    WCHAR            **ppwszGroup;
    PSECURITY_DESCRIPTOR pCASD = NULL;

    *pfAccessAllowed = FALSE;

    // If, for some reason, a certsrv call is made after we've shut down
    // security, we need to fail.

    if (!g_CASD.IsInitialized())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        _JumpError(hr, error, "Security not enabled");
    }

    if (NULL != pwszAuthority)
    {
	if (0 != lstrcmpi(pwszAuthority, g_wszCommonName))
        {   
            if (0 != lstrcmpi(pwszAuthority, g_wszSanitizedName) &&
   	        0 != lstrcmpi(pwszAuthority, g_pwszSanitizedDSName))
	    {
		hr = E_INVALIDARG;
		_PrintErrorStr(
			    hr,
			    "CheckCertSrvAccess: invalid authority name",
			    pwszAuthority);
		_JumpErrorStr(hr, error, "expected CA name", g_wszCommonName);
	    }
#ifdef DBG_CERTSRV_DEBUG_PRINT
	    if (0 == lstrcmpi(pwszAuthority, g_wszSanitizedName))
	    {
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "'%ws' called with Sanitized Name: '%ws'\n",
		    g_wszCommonName,
		    pwszAuthority));
	    }
	    else
	    if (0 == lstrcmpi(pwszAuthority, g_pwszSanitizedDSName))
	    {
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "'%ws' called with Sanitized DS Name: '%ws'\n",
		    g_wszCommonName,
		    pwszAuthority));
	    }
#endif
        }
    }

    if(NULL == hRpc)
    {
        // dcom impersonate
        // get client info and impersonate client
        hr = CoGetCallContext(IID_IServerSecurity, (void**)&pISS);
        _JumpIfError(hr, error, "CoGetCallContext");

        //if (!pISS->IsImpersonating())
        {
            hr = pISS->ImpersonateClient();
            _JumpIfError(hr, error, "ImpersonateClient");
        }
    }
    else
    {
        // rpc impersonate
        hr = RpcImpersonateClient((RPC_BINDING_HANDLE) hRpc);
        if (S_OK != hr)
        {
	    hr = myHError(hr);
	    _JumpError(hr, error, "RpcImpersonateClient");
        }
    }

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
	_JumpIfError(hr, error, "GetCurrentThread");
    }

    if (!OpenThreadToken(hThread,
                         TOKEN_QUERY | TOKEN_DUPLICATE,
                         FALSE,  // client impersonation
                         &hClientToken))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "OpenThreadToken");
    }

    hr = g_CASD.LockGet(&pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    
    if (!AccessCheck(
		    pCASD,		// security descriptor
		    hClientToken,	// handle to client access token
		    Mask,		// requested access rights 
		    &g_CertGenericMapping, // map generic to specific rights
		    &ps,		// receives privileges used
		    &dwPSSize,		// size of privilege-set buffer
		    &grantAccess,	// retrieves mask of granted rights
		    pfAccessAllowed))	// retrieves results of access check
    {
        hr = myHLastError();
        _JumpError(hr, error, "AccessCheckByType");
    }
    hr = S_OK;

    if(phToken)
    {
        *phToken = hClientToken;
        hClientToken = NULL;
    }

error:
    if(pCASD)
    {
        HRESULT hr1 = g_CASD.Unlock();
        hr = S_OK!=hr?hr:hr1;
    }

    if (NULL != hRpc) // rpc
    {
        RpcRevertToSelf();
    }
    else  // dcom
    {
        if (NULL != pISS)
        {
            pISS->RevertToSelf();
            pISS->Release();
        }
    }
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    if (NULL != hClientToken)
    {
        CloseHandle(hClientToken);
    }
    return(hr);
}

HRESULT
CertStartClassFactories()
{
    HRESULT hr;
    BOOL fRequestStarted = FALSE;

    hr = CRequestFactory::StartFactory();
    _JumpIfError(hr, error, "CRequestFactory::StartFactory");

    hr = CAdminFactory::StartFactory();
    _JumpIfError(hr, error, "CAdminFactory::StartFactory");

error:
    if (S_OK != hr)
    {
	CRequestFactory::StopFactory();
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
CertStopClassFactories()
{
    CRequestFactory::StopFactory();
    CAdminFactory::StopFactory();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\certsrv.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certsrv.cpp
//
// Contents:    Cert Server main & debug support
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <locale.h>
#include <io.h>
#include <fcntl.h>
#include <safeboot.h>
#include <authzi.h>

#include "elog.h"
#include "certlog.h"
#include "certsrvd.h"
#include "resource.h"
#include "csresstr.h"

#define __dwFILE__	__dwFILE_CERTSRV_CERTSRV_CPP__

HKEY g_hkeyCABase = 0;


BOOL g_fCreateDB = FALSE;
BOOL g_fStartAsService = TRUE;
BOOL g_fStarted;
BOOL g_fStartInProgress;
DWORD g_ServiceThreadId;
HWND g_hwndMain;
WCHAR g_wszAppName[] = L"CertSrv";
HINSTANCE g_hInstApp;
DWORD g_dwDelay0;
DWORD g_dwDelay1;
DWORD g_dwDelay2;
BOOL g_fCryptSilent = FALSE;

HANDLE g_hServiceThread = NULL;
HANDLE g_hShutdownEvent = NULL;

CRITICAL_SECTION g_ShutdownCriticalSection;
BOOL g_fShutdownCritSec = FALSE;

BOOL g_fRefuseIncoming = FALSE;
LONG g_cCalls = 0;
LONG g_cCallsActive = 0;
BOOL g_fAdvancedServer = FALSE;

CAutoLPWSTR g_pwszDBFileHash;

SERVICE_TABLE_ENTRY steDispatchTable[] =
{
    { const_cast<WCHAR *>(g_wszCertSrvServiceName), ServiceMain },
    { NULL, NULL }
};


WCHAR const g_wszRegKeyClassesCLSID[] = L"SOFTWARE\\Classes\\CLSID";
WCHAR const g_wszRegKeyInprocServer32[] = L"InprocServer32";
WCHAR const g_wszRegValueThreadingModel[] = L"ThreadingModel";
WCHAR const g_wszRegKeyAppId[] = L"SOFTWARE\\Classes\\AppId";
WCHAR const g_wszRegRunAs[] = L"RunAs";
WCHAR const g_wszRegValueInteractiveUser[] = L"Interactive User";
WCHAR const g_wszRegLocalService[] = L"LocalService";

// do not change the order, add new audit resources at the end
//    g_pwszAllow,
//    g_pwszDeny,
//    g_pwszCAAdmin,
//    g_pwszOfficer,
//    g_pwszRead,
//    g_pwszEnroll,

LPCWSTR g_pwszAuditResources[6];

using namespace CertSrv;

HRESULT
OpenRegistryComKey(
    IN HKEY hKeyParent,
    IN CLSID const *pclsid,
    IN BOOL fWrite,
    OUT HKEY *phKey)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;

    *phKey = NULL;
    hr = StringFromCLSID(*pclsid, &pwsz);
    _JumpIfError(hr, error, "StringFromCLSID");

    hr = RegOpenKeyEx(
		hKeyParent,
		pwsz,
		0,
		fWrite? KEY_ALL_ACCESS : KEY_READ,
		phKey);
    _JumpIfError(hr, error, "RegOpenKeyEx");

error:
    if (NULL != pwsz)
    {
	CoTaskMemFree(pwsz);
    }
    return(hr);
}


BOOL
IsMissingRegistryValue(
    IN HKEY hKey,
    IN WCHAR const *pwszRegValueName)
{
    HRESULT hr;
    DWORD dwLen;
    DWORD dwType;

    hr = RegQueryValueEx(hKey, pwszRegValueName, NULL, &dwType, NULL, &dwLen);
    if (S_OK != hr)
    {
	hr = myHError(hr);
    }
    _JumpIfError2(
	    hr,
	    error,
	    "RegQueryValueEx",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

error:
    return(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
}


BOOL
IsMatchingRegistryValue(
    IN HKEY hKey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszRegValueString)
{
    HRESULT hr;
    DWORD dwLen;
    DWORD dwType;
    BOOL fMatch = FALSE;
    WCHAR buf[MAX_PATH];

    dwLen = sizeof(buf);
    hr = RegQueryValueEx(
		    hKey,
		    pwszRegValueName,
		    NULL,
		    &dwType,
		    (BYTE *) buf,
		    &dwLen);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", pwszRegValueName);

    if (REG_SZ == dwType && 0 == lstrcmpi(buf, pwszRegValueString))
    {
	fMatch = TRUE;
    }

error:
    return(fMatch);
}


HRESULT
SetRegistryStringValue(
    IN HKEY hKey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszRegValueString)
{
    HRESULT hr;

    hr = RegSetValueEx(
		    hKey,
		    pwszRegValueName,
		    0,
		    REG_SZ,
		    (const BYTE *) pwszRegValueString,
		    (wcslen(pwszRegValueString) + 1) * sizeof(WCHAR));
    return(hr);
}


HRESULT
CertSrvSetRegistryFileTimeValue(
    IN BOOL fConfigLevel,
    IN WCHAR const *pwszRegValueName,
    IN DWORD cpwszDelete,
    OPTIONAL IN WCHAR const * const *papwszRegValueNameDelete)
{
    HRESULT hr;
    HKEY hKey = NULL;
    HKEY hKey1 = NULL;
    WCHAR *pwszKey;
    FILETIME ftCurrent;
    DWORD i;

    GetSystemTimeAsFileTime(&ftCurrent);

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    wszREGKEYCONFIGPATH,
		    0,
		    KEY_ALL_ACCESS,
		    &hKey);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    if (!fConfigLevel)
    {
	hKey1 = hKey;
	hKey = NULL;
	hr = RegOpenKeyEx(
			hKey1,
			g_wszSanitizedName,
			0,
			KEY_ALL_ACCESS,
			&hKey);
	_JumpIfError(hr, error, "RegOpenKeyEx");
    }

    hr = RegSetValueEx(
		    hKey,
		    pwszRegValueName,
		    0,
		    REG_BINARY,
		    (BYTE const *) &ftCurrent,
		    sizeof(ftCurrent));
    _JumpIfError(hr, error, "RegSetValueEx");

    for (i = 0; i < cpwszDelete; i++)
    {
	hr = RegDeleteValue(hKey, papwszRegValueNameDelete[i]);
	_PrintIfError2(hr, "RegDeleteValue", ERROR_FILE_NOT_FOUND);
    }
    hr = S_OK;

error:
    if (NULL != hKey1)
    {
	RegCloseKey(hKey1);
    }
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    return(myHError(hr));
}


HRESULT
SetRegistryDcomConfig(
    IN BOOL fConsoleActive)
{
    HRESULT hr;
    HKEY hKeyAppId = NULL;
    HKEY hKeyAdmin = NULL;
    HKEY hKeyRequest = NULL;
    DWORD cChanged = 0;

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    g_wszRegKeyAppId,
		    0,
		    KEY_ALL_ACCESS,
		    &hKeyAppId);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    hr = OpenRegistryComKey(hKeyAppId, &CLSID_CCertAdminD, TRUE, &hKeyAdmin);
    _JumpIfError(hr, error, "OpenRegistryComKey");

    hr = OpenRegistryComKey(hKeyAppId, &CLSID_CCertRequestD, TRUE, &hKeyRequest);
    _JumpIfError(hr, error, "OpenRegistryComKey");

    if (fConsoleActive)
    {
	// Running in console mode:
	// Delete both LocalService registry values
	// Create both RunAs = InteractiveUser registry values
	
	if (!IsMissingRegistryValue(hKeyAdmin, g_wszRegLocalService))
	{
	    cChanged++;
	    hr = RegDeleteValue(hKeyAdmin, g_wszRegLocalService);
	    _JumpIfError(hr, error, "RegDeleteValue");
	}
	if (!IsMissingRegistryValue(hKeyRequest, g_wszRegLocalService))
	{
	    cChanged++;
	    hr = RegDeleteValue(hKeyRequest, g_wszRegLocalService);
	    _JumpIfError(hr, error, "RegDeleteValue");
	}

	if (!IsMatchingRegistryValue(
				hKeyAdmin,
				g_wszRegRunAs,
				g_wszRegValueInteractiveUser))
	{
	    cChanged++;
	    hr = SetRegistryStringValue(
			    hKeyAdmin,
			    g_wszRegRunAs,
			    g_wszRegValueInteractiveUser);
	    _JumpIfError(hr, error, "SetRegistryStringValue");
	}
	if (!IsMatchingRegistryValue(
				hKeyRequest,
				g_wszRegRunAs,
				g_wszRegValueInteractiveUser))
	{
	    cChanged++;
	    hr = SetRegistryStringValue(
			    hKeyRequest,
			    g_wszRegRunAs,
			    g_wszRegValueInteractiveUser);
	    _JumpIfError(hr, error, "SetRegistryStringValue");
	}
	if (0 != cChanged)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"SetRegistryDcomConfig(%u): setting %ws=%ws\n",
		cChanged,
		g_wszRegRunAs,
		g_wszRegValueInteractiveUser));
	}
    }
    else
    {
	// Running as a service:
	// Delete both RunAs registry values
	// Create both LocalService = CertSvc registry values
	
	if (!IsMissingRegistryValue(hKeyAdmin, g_wszRegRunAs))
	{
	    cChanged++;
	    hr = RegDeleteValue(hKeyAdmin, g_wszRegRunAs);
	    _JumpIfError(hr, error, "RegDeleteValue");
	}
	if (!IsMissingRegistryValue(hKeyRequest, g_wszRegRunAs))
	{
	    cChanged++;
	    hr = RegDeleteValue(hKeyRequest, g_wszRegRunAs);
	    _JumpIfError(hr, error, "RegDeleteValue");
	}

	if (!IsMatchingRegistryValue(
				hKeyAdmin,
				g_wszRegLocalService,
				g_wszCertSrvServiceName))
	{
	    cChanged++;
	    hr = SetRegistryStringValue(
			    hKeyAdmin,
			    g_wszRegLocalService,
			    g_wszCertSrvServiceName);
	    _JumpIfError(hr, error, "SetRegistryStringValue");
	}
	if (!IsMatchingRegistryValue(
				hKeyRequest,
				g_wszRegLocalService,
				g_wszCertSrvServiceName))
	{
	    cChanged++;
	    hr = SetRegistryStringValue(
			    hKeyRequest,
			    g_wszRegLocalService,
			    g_wszCertSrvServiceName);
	    _JumpIfError(hr, error, "SetRegistryStringValue");
	}
	if (0 != cChanged)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"SetRegistryDcomConfig(%u): setting %ws=%ws\n",
		cChanged,
		g_wszRegLocalService,
		g_wszCertSrvServiceName));
	}
    }

error:
    if (NULL != hKeyRequest)
    {
	RegCloseKey(hKeyRequest);
    }
    if (NULL != hKeyAdmin)
    {
	RegCloseKey(hKeyAdmin);
    }
    if (NULL != hKeyAppId)
    {
	RegCloseKey(hKeyAppId);
    }
    return(myHError(hr));
}


DWORD
GetRegistryDwordValue(
    IN WCHAR const *pwszRegValueName)
{
    HRESULT hr;
    HKEY hKeyConfig = NULL;
    DWORD dwVal;
    DWORD dwType;
    DWORD dwLen;

    dwVal = 0;

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    g_wszRegKeyConfigPath,
		    0,
		    KEY_READ,
		    &hKeyConfig);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    dwLen = sizeof(dwVal);
    hr = RegQueryValueEx(
			hKeyConfig,
			pwszRegValueName,
			NULL,
			&dwType,
			(BYTE *) &dwVal,
			&dwLen);

    if (S_OK != hr || REG_DWORD != dwType || sizeof(dwVal) != dwLen)
    {
	dwVal = 0;
	goto error;
    }

error:
    if (NULL != hKeyConfig)
    {
	RegCloseKey(hKeyConfig);
    }
    return(dwVal);
}

HRESULT 
CertSrvResetRegistryWatch(
    IN OUT HANDLE *phRegistryModified)
{
    HRESULT hr;
    
    CSASSERT(NULL != phRegistryModified);

    //////////////////////////////////////
    // Initialization of registry events

    if (NULL == g_hkeyCABase)
    {
        DWORD dwDisposition;
        LPWSTR pszCAPath;
        
        pszCAPath = (LPWSTR) LocalAlloc(
            LMEM_FIXED,
            (WSZARRAYSIZE(wszREGKEYCONFIGPATH_BS) +
            wcslen(g_wszSanitizedName) +
            1) * sizeof(WCHAR));
	if (NULL == pszCAPath)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
        
        wcscpy(pszCAPath, wszREGKEYCONFIGPATH_BS);
        wcscat(pszCAPath, g_wszSanitizedName);
        
        hr = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            pszCAPath,
            0,                  // reserved
            NULL,               // class
            0,                  // options
            KEY_ALL_ACCESS,     // sec desired
            NULL,               // sec attr
            &g_hkeyCABase,      // phk
            &dwDisposition);
        LocalFree(pszCAPath); pszCAPath = NULL;
        _JumpIfError(hr, error, "RegCreateKeyEx base key");
    }
    if (NULL == *phRegistryModified)
    {
        *phRegistryModified = CreateEvent(
				    NULL,
				    TRUE,	// manual reset
				    FALSE,	// initial state
				    L"Registry Modification Event");
        if (NULL == *phRegistryModified)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateEvent registry watch");
        }
    }
    else
    {
        // reset registry event
        ResetEvent( *phRegistryModified ); 
    }

    // register our registry lookout trigger
    hr = RegNotifyChangeKeyValue(
            g_hkeyCABase,
            FALSE,
            REG_NOTIFY_CHANGE_LAST_SET,
            *phRegistryModified,
            TRUE);
    _JumpIfError(hr, error, "RegNotifyChangeKeyValue on base key");

error:
    return(myHError(hr));
}


HRESULT 
CertSrvRegistryModificationEvent(
    IN FILETIME const *pftWait,
    IN OUT DWORD *pdwTimeOut)
{
    HRESULT hr;
    DWORD dwVal;
    BOOL fDisabledNew;
    FILETIME ftCurrent;
    BOOL fSetEvent = FALSE;
    DWORD dwMSTimeOut;

    // see if Base CRL publish enabled state has changed

    hr = myGetCertRegDWValue(
			g_wszSanitizedName,
			NULL,
			NULL,
			wszREGCRLPERIODCOUNT,
			&dwVal);
    if (S_OK == hr)
    {
	fDisabledNew = 0 == dwVal;      
	if (fDisabledNew != g_fCRLPublishDisabled)
	{
            fSetEvent = TRUE;
	}
    }

    // see if Delta CRL publish enabled state has changed

    hr = myGetCertRegDWValue(
			g_wszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAPERIODCOUNT,
			&dwVal);
    if (S_OK == hr)
    {
	fDisabledNew = 0 == dwVal;      
	if (fDisabledNew != g_fDeltaCRLPublishDisabled)
	{
            fSetEvent = TRUE;
        }
    }

    GetSystemTimeAsFileTime(&ftCurrent);

    CRLComputeTimeOut(pftWait, &ftCurrent, &dwMSTimeOut);
    if (dwMSTimeOut >= *pdwTimeOut)
    {
	dwMSTimeOut = *pdwTimeOut;
	fSetEvent = TRUE;
    }
    *pdwTimeOut -= dwMSTimeOut;

    if (fSetEvent)
    {
	SetEvent(g_hCRLManualPublishEvent);	// pulse to get up-to-date
    }
    return(hr);
}


#if DBG_CERTSRV
WCHAR const *
certsrvGetCurrentTimeWsz()
{
    HRESULT hr;
    FILETIME ft;
    WCHAR *pwszTime = NULL;
    static WCHAR s_wszTime[128];
    
    GetSystemTimeAsFileTime(&ft);
    hr = myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszTime);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    s_wszTime[0] = L'\0';
    if (NULL != pwszTime)
    {
	wcsncpy(s_wszTime, pwszTime, ARRAYSIZE(s_wszTime));
	s_wszTime[ARRAYSIZE(s_wszTime) - 1] = L'\0';
	LocalFree(pwszTime);
    }
    return(s_wszTime);
}
#endif


HRESULT
CertSrvBlockThreadUntilStop()
{
    HRESULT hr;
    HANDLE hRegistryModified = NULL;
    DWORD dwTimeOut;

    // check CRL publish, get next timeout interval

    hr = CRLPubWakeupEvent(&dwTimeOut);
    _PrintIfError(hr, "CRLPubWakeupEvent");

    hr = CertSrvResetRegistryWatch(&hRegistryModified);
    _PrintIfError(hr, "CertSrvResetRegistryWatch");

    while (TRUE)
    {
	FILETIME ftWait;
        DWORD dw;
        HANDLE hmultiObjects[] = {
	    hRegistryModified,
	    g_hServiceStoppingEvent,
	    g_hCRLManualPublishEvent
	};

#if DBG_CERTSRV
	{
	    LLFILETIME llft;
	    WCHAR *pwszTimePeriod = NULL;

	    llft.ll = dwTimeOut;
	    llft.ll *= (CVT_BASE / 1000);	// convert msecs to 100ns
	    llft.ll = -llft.ll;
	    
	    hr = myFileTimePeriodToWszTimePeriod(
				    &llft.ft,
				    TRUE,	// fExact
				    &pwszTimePeriod);
	    _PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");

	    DBGPRINT((
		DBG_SS_CERTSRV,
		"WaitForMultipleObjects(%u ms) %ws @%ws\n",
		dwTimeOut,
		pwszTimePeriod,
		certsrvGetCurrentTimeWsz()));
	    if (NULL != pwszTimePeriod)
	    {
		LocalFree(pwszTimePeriod);
	    }
	}
#endif

	GetSystemTimeAsFileTime(&ftWait);
        dw = WaitForMultipleObjects(
			    ARRAYSIZE(hmultiObjects),
			    hmultiObjects,
			    FALSE,      // any object will cause bailout
			    dwTimeOut);

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "WaitForMultipleObjects(%u ms)->%x, %ws\n",
	    dwTimeOut,
	    dw,
	    certsrvGetCurrentTimeWsz()));

        if (WAIT_FAILED == dw)
        {
            hr = GetLastError();
            _JumpError(hr, error, "WaitForMultipleObjects worker");
        }

        if (dw == WAIT_TIMEOUT)     // CRL
        {
            hr = CRLPubWakeupEvent(&dwTimeOut);
            _PrintIfError(hr, "Error during CRLPubWakeupEvent");

            DBGPRINT((DBG_SS_CERTSRVI, "CRLPub: TimeOut %u ms\n", dwTimeOut));
        }
        else if (dw == WAIT_OBJECT_0)   // Registry modification
        {
            // In either case, determine if CRL needs to be published

            hr = CertSrvRegistryModificationEvent(&ftWait, &dwTimeOut);
            _PrintIfError(hr, "Error during CertSrvRegistryModificationEvent");

            // in registry case, reset registry trigger

            DBGPRINT((
		DBG_SS_CERTSRVI,
		"CRLPub: Registry change trigger, TimeOut=%u ms\n",
		dwTimeOut));

            hr = CertSrvResetRegistryWatch(&hRegistryModified);
            _PrintIfError(hr, "Error during CertSrvResetRegistryWatch");
        }
        else if (dw == WAIT_OBJECT_0 + 1)
        {
            // found "service done" event

            DBGPRINT((DBG_SS_CERTSRV, "Service is pending stop request\n"));
            break;  // exit wait loop
        }
        else if (dw == WAIT_OBJECT_0 + 2)
        {
            // found "g_hCRLManualPublishEvent" event: recalc timeout

            hr = CRLPubWakeupEvent(&dwTimeOut);
            _PrintIfError(hr, "Error during CRLPubWakeupEvent");

            DBGPRINT((
		DBG_SS_CERTSRVI,
		"CRLPub: Manual publish recalc, TimeOut=%u ms\n",
		dwTimeOut));
        }
        else
        {
            CSASSERT(!"unexpected wait return");
            hr = E_UNEXPECTED;
            _JumpError(hr, error, "WaitForMultipleObjects");
        }
    }
    hr = S_OK;

error:
    CloseHandle(hRegistryModified);
    return hr;
}


// returns TRUE if we shutdown correctly

BOOL
CertSrvStopServer(
    IN BOOL fConsoleActive)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    BOOL fShutDown = FALSE;

    if (!g_fStartInProgress)		// ignore while starting the server
    {
	fShutDown = TRUE;

        DBGPRINT((
            DBG_SS_CERTSRV,
            "CertSrvStopServer(fConsoleActive=%u, tid=%d)\n",
            fConsoleActive,
            GetCurrentThreadId()));

        SetEvent(g_hServiceStoppingEvent);

        if (g_hkeyCABase)
        {
            RegCloseKey(g_hkeyCABase);
            g_hkeyCABase = NULL;
        }

        hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "CoInitializeEx");
        }
        fCoInit = TRUE;

        // don't allow new callers in

        hr = RPCTeardown();
        _PrintIfError(hr, "RPCTeardown");
        CertStopClassFactories();

        CoreTerminate();

        if (g_fStarted)
        {
            if (CERTLOG_TERSE <= g_dwLogLevel)
            {
                LogEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    MSG_I_SERVER_STOPPED,
                    g_wszCommonName);
            }
            CONSOLEPRINT0((
                DBG_SS_CERTSRV,
                "Certification Authority Service Stopped\n"));

        {
            //only perform Hash if the auditing is enabled
            if(AUDIT_FILTER_STARTSTOP & g_dwAuditFilter)
            {
                CertSrv::CAuditEvent event(
                    SE_AUDITID_CERTSRV_SERVICESTOP, 
                    g_dwAuditFilter);

                hr = ComputeMAC(g_wszDatabase, &g_pwszDBFileHash);
                _JumpIfErrorStr(hr, error, "ComputeMAC", g_wszDatabase);

                hr = event.AddData(g_pwszDBFileHash); // %1 database hash
                g_pwszDBFileHash.Cleanup();
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                //
                // ... add code for retrieving key usage count from CSP
                //
                hr = event.AddData((DWORD)0); // %2 key usage count
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                hr = event.Report();
                _JumpIfError(hr, error, "CAuditEvent::Report");
            }
        }
        }
        g_fStarted = FALSE;

        AuthzFreeResourceManager(g_AuthzCertSrvRM);
        g_AuthzCertSrvRM = NULL;
        g_CASD.Uninitialize();
        g_OfficerRightsSD.Uninitialize();

        // set "completely stopped" event
        if (!fConsoleActive)
	{
            SetEvent(g_hServiceStoppedEvent);
	}
    }

error:
    if (fCoInit)
    {
	CoUninitialize();
    }
    return(fShutDown);
}


// Control-C handler

BOOL
StopServer(
    IN DWORD dwCtrlType)
{
    HRESULT hr;

    // if successful shutdown
    if (SendMessage(g_hwndMain, WM_STOPSERVER, 0, 0))
    {
        if (!PostMessage(g_hwndMain, WM_SYNC_CLOSING_THREADS, S_OK, 0))
	{
	    hr = myHLastError();
	    _PrintError(hr, "PostMessage");
	}
    	SetConsoleCtrlHandler(StopServer, FALSE);
    }
    return(TRUE);
}


HRESULT
CertSrvEnterServer(
    OUT DWORD *pState)
{
    HRESULT hr;
    BOOL fEntered = FALSE;
    
    *pState = 0;	// Caller need not exit server
    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    hr = CertSrvTestServerState();
    _JumpIfError(hr, error, "CertSrvTestServerState");

    g_cCalls++;
    g_cCallsActive++;
    *pState = 1;	// Caller must exit server
    hr = S_OK;

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
    return(hr);
}


HRESULT
CertSrvTestServerState()
{
    HRESULT hr;
    
    if (g_fRefuseIncoming)
    {
	hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
	_JumpError(hr, error, "g_fRefuseIncoming");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CertSrvLockServer(
    IN OUT DWORD *pState)
{
    HRESULT hr;
    BOOL fEntered = FALSE;

    // Eliminate this thread from the active thread count
    
    CertSrvExitServer(*pState);
    *pState = 0;	// Caller no longer needs to exit server

    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    g_fRefuseIncoming = TRUE;
    DBShutDown(TRUE);
    DBGPRINT((DBG_SS_CERTSRV, "LockServer(thread count = %u)\n", g_cCallsActive));
    while (0 < g_cCallsActive)
    {
	LeaveCriticalSection(&g_ShutdownCriticalSection);

	// Wait 15 seconds plus 2 seconds for each active call.

        hr = WaitForSingleObject(
			    g_hShutdownEvent,
			    (15 + 2 * g_cCallsActive) * 1000);
	EnterCriticalSection(&g_ShutdownCriticalSection);

	_PrintIfError(hr, "WaitForSingleObject");
	if ((HRESULT) WAIT_OBJECT_0 == hr)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "LockServer(last thread exit event)\n"));
	}
	else if ((HRESULT) WAIT_TIMEOUT == hr)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "LockServer(timeout)\n"));
	    break;
        }
	else if ((HRESULT) WAIT_ABANDONED == hr)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "LockServer(wait abandoned)\n"));
        }
	DBGPRINT((DBG_SS_CERTSRV, "LockServer(thread count = %u)\n", g_cCallsActive));
    }
    DBGPRINT((DBG_SS_CERTSRV, "LockServer(done: thread count = %u)\n", g_cCallsActive));
    hr = S_OK;

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
    return(hr);
}


VOID
CertSrvExitServer(
    IN DWORD State)
{
    HRESULT hr;
    BOOL fEntered = FALSE;

    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    if (State)
    {
	CSASSERT(0 < g_cCallsActive);
	if (0 == --g_cCallsActive && g_fRefuseIncoming)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "ExitServer(set last thread exit event)\n"));
            SetEvent(g_hShutdownEvent);
	}
    }

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
}


// Test for alignment faults in the C runtimes.
// If the bug hasn't been fixed yet, log an event during cert server startup.

VOID
certsrvLogAlignmentFaultStatus()
{
    HRESULT hr;
    HRESULT hr2;
    ULONG_PTR ExceptionAddress;
    WCHAR awcAddress[2 + 2 * cwcDWORDSPRINTF];
    WCHAR const *apwsz[2];
    WORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszStringErr = NULL;
    
    apwsz[1] = NULL;
    __try
    {
	fwprintf(stdout, L".");	  // may fault if I/O buffer is odd aligned
	fprintf(stdout, ".");
	fwprintf(stdout, L".\n"); // may fault if I/O buffer is odd aligned
	hr = S_OK;
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "certsrvLogAlignmentFaultStatus: Exception");
    }
    if (S_OK != hr)
    {
	ALIGNIOB(stdout);	// align the stdio buffer
	wprintf(L"STDIO exception: 0x%x\n", hr);

	wsprintf(awcAddress, L"0x%p", ExceptionAddress);
	CSASSERT(wcslen(awcAddress) < ARRAYSIZE(awcAddress));

	apwsz[0] = awcAddress;
	pwszStringErr = myGetErrorMessageText(hr, TRUE);
	apwsz[1] = pwszStringErr;
	if (NULL == pwszStringErr)
	{
	    apwsz[1] = myHResultToString(awchr, hr);
	}
	cpwsz = ARRAYSIZE(apwsz);

	hr2 = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_STARTUP_EXCEPTION,
		    cpwsz,
		    apwsz);
	_JumpIfError(hr2, error, "LogEvent");
    }

error:
    if (NULL != pwszStringErr)
    {
	LocalFree(const_cast<WCHAR *>(pwszStringErr));
    }
}


#define MSTOSEC(ms)	(((ms) + 1000 - 1)/1000)
FNLOGEXCEPTION certsrvLogException;

HRESULT
certsrvStartServer(
    IN BOOL fConsoleActive)
{
    HRESULT hr;
    DWORD TimeStart;
    WCHAR awc[ARRAYSIZE(SAFEBOOT_DSREPAIR_STR_W)];
    DWORD cwc;
    DWORD dwEventType = EVENTLOG_ERROR_TYPE;
    DWORD dwIdEvent = 0;

    g_fStartInProgress = TRUE;
    DBGPRINT((
        DBG_SS_CERTSRV,
        "StartServer(tid=%d, fConsoleActive=%u)\n",
        GetCurrentThreadId(),
        fConsoleActive));
    TimeStart = GetTickCount();

    if (fConsoleActive)
    {
        g_fStartAsService = FALSE;
        SetConsoleCtrlHandler(StopServer, TRUE);
    }

    if (!FIsServer())
    {
        // don't allow startup on non-server SKU

        hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
        _JumpError(hr, error, "FIsServer"); 
    }

    cwc = GetEnvironmentVariable(L"SAFEBOOT_OPTION", awc, ARRAYSIZE(awc));
    if (0 != cwc &&
	ARRAYSIZE(awc) > cwc &&
	0 == lstrcmpi(awc, SAFEBOOT_DSREPAIR_STR_W))
    {
        // log an error to the event log and stop immediately
	dwEventType = EVENTLOG_INFORMATION_TYPE;
	dwIdEvent = MSG_SAFEBOOT_DETECTED;

	hr = HRESULT_FROM_WIN32(ERROR_RETRY);
	_JumpError(hr, error, "Not starting service: booted in DSRepair mode");
    }
    
    g_fAdvancedServer = FIsAdvancedServer();

    if (!AuthzInitializeResourceManager(
            0,
            CallbackAccessCheck,
            NULL,
            NULL,
            L"CertSrv",
            &g_AuthzCertSrvRM))
    {
        hr = myHLastError();
        _PrintError(hr, "AuthzInitializeResourceManager");
        if (E_INVALIDARG != hr || (2 > g_fAdvancedServer && IsWhistler()))
        {
            goto error;
        }
    }

    hr = CoreInit();
    if (S_OK != hr)
    {
	dwIdEvent = MAXDWORD;	// Error event already logged
	_JumpError(hr, error, "CoreInit");
    }
    certsrvLogAlignmentFaultStatus();
    myLogExceptionInit(certsrvLogException);

    hr = RPCInit();
    if (S_OK != hr)
    {
	dwIdEvent = MSG_E_RPC_INIT;
        _JumpError(hr, error, "RPCInit");
    }

    hr = SetRegistryDcomConfig(fConsoleActive);
    if (S_OK != hr)
    {
	dwIdEvent = MSG_E_REGISTRY_DCOM;
        _JumpError(hr, error, "SetRegistryDcomConfig");
    }

    hr = CertStartClassFactories();
    if (S_OK != hr)
    {
	dwIdEvent = CO_E_WRONG_SERVER_IDENTITY == hr?
		    MSG_E_SERVER_IDENTITY : MSG_E_CLASS_FACTORIES;
        _JumpError(hr, error, "CertStartClassFactories");
    }

    {
        //only perform Hash if the auditing is enabled
        if(AUDIT_FILTER_STARTSTOP & g_dwAuditFilter)
        {
            CertSrv::CAuditEvent event(
			            SE_AUDITID_CERTSRV_SERVICESTART,
			            g_dwAuditFilter);

            hr = event.AddData(g_pwszDBFileHash); // %1 database hash
            g_pwszDBFileHash.Cleanup();
            _JumpIfError(hr, error, "CAuditEvent::AddData");
    
            //
            // ... add code for retrieving key usage count from CSP
            //
            hr = event.AddData((DWORD)0); // %2 key usage count
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = event.Report();
            _JumpIfError(hr, error, "CAuditEvent::Report");
        }
    }

    {
        CertSrv::CAuditEvent event(
			        SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE,
			        g_dwAuditFilter);

        hr = event.AddData(CAuditEvent::RoleSeparationIsEnabled()); // %1 is role separation enabled?
        _JumpIfError(hr, error, "CAuditEvent::AddData");
    
        hr = event.Report();
        _JumpIfError(hr, error, "CAuditEvent::Report");
    }


    if (CERTLOG_TERSE <= g_dwLogLevel)
    {
        LogEventString(
		EVENTLOG_INFORMATION_TYPE,
		MSG_I_SERVER_STARTED,
		g_wszCommonName);
    }
    
    CONSOLEPRINT1((
        DBG_SS_CERTSRV,
        "Certification Authority Service Ready (%us) ...\n",
        MSTOSEC(GetTickCount() - TimeStart)));
    g_fStarted = TRUE;
    CSASSERT(S_OK == hr);

error:
    if (S_OK != hr)
    {
	if (MAXDWORD != dwIdEvent)
	{
	    if (0 == dwIdEvent)
	    {
		dwIdEvent = MSG_E_GENERIC_STARTUP_FAILRE;
	    }
	    LogEventStringHResult(
			dwEventType,
			dwIdEvent,
			g_wszCommonName,
			EVENTLOG_INFORMATION_TYPE == dwEventType? S_OK : hr);
	}

        CertSrvStopServer(fConsoleActive);
        
        // returning error here results in repost to scm
    }

    g_fStartInProgress = FALSE;
    return(hr);
}


VOID
certsrvLogException(
    IN HRESULT hrEvent,
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *pszFileName,
    IN DWORD dwFile,
    IN DWORD dwLine)
{
    HRESULT hr;
    WCHAR awcFile[2 + 3 * cwcDWORDSPRINTF];
    WCHAR awcFlags[3 + cwcDWORDSPRINTF];
    WCHAR awcAddress[2 + 2 * cwcDWORDSPRINTF];
    WCHAR const *apwsz[4];
    WORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszStringErr = NULL;

    wsprintf(awcFile, L"%u.%u.%u", dwFile, dwLine, MSG_E_EXCEPTION);
    CSASSERT(wcslen(awcFile) < ARRAYSIZE(awcFile));

    wsprintf(awcFlags, L"0x%08x", pep->ExceptionRecord->ExceptionFlags);
    CSASSERT(wcslen(awcFlags) < ARRAYSIZE(awcFlags));

    wsprintf(awcAddress, L"0x%p", pep->ExceptionRecord->ExceptionAddress);
    CSASSERT(wcslen(awcAddress) < ARRAYSIZE(awcAddress));

    apwsz[0] = awcFile;
    apwsz[1] = awcAddress;
    apwsz[2] = awcFlags;
    pwszStringErr = myGetErrorMessageText(hrEvent, TRUE);
    apwsz[3] = pwszStringErr;
    if (NULL == pwszStringErr)
    {
	apwsz[3] = myHResultToString(awchr, hrEvent);
    }
    cpwsz = ARRAYSIZE(apwsz);

    hr = LogEvent(EVENTLOG_ERROR_TYPE, MSG_E_EXCEPTION, cpwsz, apwsz);
    _JumpIfError(hr, error, "LogEvent");

error:
    if (NULL != pwszStringErr)
    {
	LocalFree(const_cast<WCHAR *>(pwszStringErr));
    }
}


DWORD
CertSrvStartServerThread(
    IN VOID *pvArg)
{
    HRESULT hr = S_OK;
    DWORD Flags = (DWORD) (ULONG_PTR) pvArg;
    BOOL b;
    ULONG_PTR ulp;

    // Anatomy of startup code
    // if g_fStartAsService, just registers this new thread as the main
    // thread and blocks until the ServiceMain fxn returns.
                        
    // We're in a non-rpc thread; check if we need to create VRoots.  I would
    // have liked to have moved this into CoreInit, but we're limited in where
    // we can do this (can't be calling into RPC during RPC call).
    //
    // If the SetupStatus SETUP_ATTEMPT_VROOT_CREATE registry flag is clear,
    // this call is a nop.  A separate thread is created to access the IIS
    // metabase.  If it hangs, it will be nuked -- after the specified timeout.
    // This call returns immediately, so the only detectable error is likely
    // to be a thread creation problem.

    // if we're doing anything other than starting the service controller,
    // check to see if the vroots need to be created.

    if (0 == (Flags & CSST_STARTSERVICECONTROLLER))
    {
	WCHAR *pwszPath = NULL;
	DWORD cb = sizeof(ENUM_CATYPES);
	DWORD dwType;
	ENUM_CATYPES CAType = ENUM_UNKNOWN_CA;
	HKEY hkey = NULL;

	hr = myRegOpenRelativeKey(
				NULL,
				L"ca",
				RORKF_CREATESUBKEYS,
				&pwszPath,
				NULL,           // ppwszName
				&hkey);
	_PrintIfError(hr, "myRegOpenRelativeKey");
	if (S_OK == hr)
	{
	    DBGPRINT((DBG_SS_CERTLIBI, "%ws\n", pwszPath));
	    cb = sizeof(CAType);
	    hr = RegQueryValueEx(
		 hkey,
		 wszREGCATYPE,
		 NULL,
		 &dwType,
		 (BYTE *) &CAType,
		 &cb);
	    _PrintIfErrorStr(hr, "RegQueryValueEx", wszREGCATYPE);
	}
	if (pwszPath)
	    LocalFree(pwszPath);
	if (hkey)
	   RegCloseKey(hkey);

	hr = myModifyVirtualRootsAndFileShares(
		    VFF_CREATEVROOTS |		// Create VRoots
			VFF_CREATEFILESHARES |	// Create File Shares
			VFF_CHECKREGFLAGFIRST |	// Skip if reg flag clear
			VFF_CLEARREGFLAGFIRST,	// Clear flag before attempt
		    CAType,
		    TRUE,           // asynch call -- don't block
		    VFCSEC_TIMEOUT, // wait this long before giving up
		    NULL,
		    NULL);
	if (S_OK != hr)
	{
	    LogEventHResult(
		    EVENTLOG_INFORMATION_TYPE,
		    MSG_E_IIS_INTEGRATION_ERROR,
		    hr);
	}
    }

    // StartServiceCtrlDispatcher should hang until certsrv terminates

    if ((CSST_STARTSERVICECONTROLLER & Flags) &&
        !StartServiceCtrlDispatcher(steDispatchTable))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT) != hr)
        {
            _JumpError(hr, error, "StartServiceCtrlDispatcher");
        }
        CONSOLEPRINT0((
            DBG_SS_CERTSRV,
            "CertSrv: Failed to connect to service controller -- running in standalone mode\n"));

        Flags &= ~CSST_STARTSERVICECONTROLLER;
        Flags |= CSST_CONSOLE;
    }

   
    if (0 == (CSST_STARTSERVICECONTROLLER & Flags))
    {
        DBGPRINT((
            DBG_SS_CERTSRVI,
            "SendMessageTimeout(tid=%d, hwnd=0x%x, msg=0x%x)\n",
            GetCurrentThreadId(),
            g_hwndMain,
            WM_STARTSERVER));

        b = SendMessageTimeout(
			g_hwndMain,
			WM_STARTSERVER,
			(CSST_CONSOLE & Flags)? TRUE : FALSE, // fConsoleActive
			0,
			SMTO_BLOCK,
			MAXLONG,
			&ulp) != 0;
        if (!b)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SendMessageTimeout");
        }
        else if (ulp != S_OK)
        {
            hr = (HRESULT) ulp;
            _JumpError(hr, error, "SendMessageTimeout");
        }
    }

    if (Flags & CSST_CONSOLE)
    {   
        // we're running as console, and so don't have a CRL publishing thread. 
        // Use this one since no one cares if it returns

        // if svc, we do this in the caller of this function
        CertSrvBlockThreadUntilStop();
    }

error:

    // on return, this thread dies
    return(hr);
}


VOID
Usage(
    IN BOOL fUsageInternal)
{
    WCHAR awcUsage[2048];

    if (LoadString(NULL, IDS_USAGE, awcUsage, ARRAYSIZE(awcUsage)))
    {
	CONSOLEPRINT1((MAXDWORD, "%ws", awcUsage));
    }
    if (fUsageInternal)
    {
	if (LoadString(NULL, IDS_USAGE_FULL, awcUsage, ARRAYSIZE(awcUsage)))
	{
	    CONSOLEPRINT1((MAXDWORD, "%ws", awcUsage));
	}
#if DBG_COMTEST
	if (LoadString(NULL, IDS_USAGE_COMTEST, awcUsage, ARRAYSIZE(awcUsage)))
	{
	    CONSOLEPRINT1((MAXDWORD, "%ws", awcUsage));
	}
#endif
    }
}


int
ArgvParseCommandLine(
    IN int argc,
    IN WCHAR *argv[])
{
    HRESULT hr;

    myVerifyResourceStrings(g_hInstApp);

    hr = E_INVALIDARG;
    while (1 < argc && (L'-' == argv[1][0] || L'/' == argv[1][0]))
    {
	WCHAR *pwsz = argv[1];
	BOOL fUsage = FALSE;
	BOOL fUsageInternal = FALSE;

	while (*++pwsz != L'\0')
	{
	    switch (*pwsz)
	    {
#if DBG_COMTEST
		case L'C':
		case L'c':
		    fComTest = TRUE;
		    break;
#endif

		case L'N':
		case L'n':
		    g_fCreateDB = TRUE;
		    break;

		case L'Z':
		case L'z':
		    g_fStartAsService = FALSE;
		    break;

		case L'S':
		case L's':
		    g_fCryptSilent = TRUE;
		    break;

		case L'?':
		case L'u':
		    fUsage = TRUE;
		    if (0 == lstrcmp(pwsz, L"uSAGE"))
		    {
			fUsageInternal = TRUE;
		    }
		    // FALLTHROUGH

		default:
		    Usage(fUsageInternal);
		    if (fUsage)
		    {
			goto error;
		    }
		    _JumpError(hr, error, "bad command line option");
	    }
	}
	argc--;
	argv++;
    }
    if (argc != 1)
    {
	Usage(FALSE);
	_JumpError(hr, error, "extra args");
    }
    hr = S_OK;

error:
    return(hr);
}


typedef int (FNARGVMAIN)(
    IN int argc,
    IN WCHAR *argv[]);


//+------------------------------------------------------------------------
// FUNCTION:	CertArgvMainDispatch
//
// NOTES:	Takes a WCHAR * command line and chews it up into argc/argv
//		form so it can be passed on to a traditional C-style main.
//-------------------------------------------------------------------------

int
CertArgvMainDispatch(
    IN FNARGVMAIN *pfnMain,
    IN WCHAR *pwszAppName,
    IN WCHAR const *pwszCmdLine)
{
    WCHAR buf[MAX_PATH];
    WCHAR *apwszArg[20];
    int cArg = 0;
    LPWSTR p = buf;
    WCHAR wcEnd;

    apwszArg[cArg++] = pwszAppName;
    while (*pwszCmdLine != L'\0')
    {
        while (*pwszCmdLine == L' ')
        {
            pwszCmdLine++;
        }
        if (*pwszCmdLine != L'\0')
        {
            wcEnd = L' ';
            if (*pwszCmdLine == L'"')
            {
                wcEnd = *pwszCmdLine++;
            }
            apwszArg[cArg++] = p;
            while (*pwszCmdLine != L'\0' && *pwszCmdLine != wcEnd)
            {
                *p++ = *pwszCmdLine++;
            }
            *p++ = L'\0';
            if (*pwszCmdLine != L'\0')
            {
                pwszCmdLine++;	// skip blank or quote character
            }
        }
    }
    apwszArg[cArg] = NULL;

    return((*pfnMain)(cArg, apwszArg));
}


//+------------------------------------------------------------------------
// FUNCTION:	MainWndProc(...)
//-------------------------------------------------------------------------

LRESULT APIENTRY
MainWndProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    WCHAR *pwszCmdLine;
    HRESULT hr;
    LPARAM lRet = 0;
    
    DBGPRINT((
        DBG_SS_CERTSRVI,
        "MainWndProc(tid=%d) msg=0x%x, wp=0x%x, lp=0x%x\n",
        GetCurrentThreadId(),
        msg,
        wParam,
        lParam));
    
    switch (msg)
    {
    case WM_CREATE:
    case WM_SIZE:
        break;
        
    case WM_DESTROY:
        if (!g_fStartAsService)
            PostQuitMessage(S_OK);
        break;
        

    case WM_ENDSESSION:
        // only stop on a real shutdown,
        // never look at this msg if running as svc
        if (g_fStartAsService || (0 == wParam) || (0 != lParam))
        {
            break;
        }
        // fall through

    case WM_STOPSERVER:
        lRet = CertSrvStopServer(!g_fStartAsService);

        break;
        
    case WM_SYNC_CLOSING_THREADS:
        hr = (HRESULT) lParam;
        
        // sync: wait for SCM to return control to exiting CertSrvStartServerThread
        if (WAIT_OBJECT_0 != WaitForSingleObject(g_hServiceThread, 10 * 1000))
        {
            hr = WAIT_TIMEOUT;
        }
        PostQuitMessage(hr);
        break;
        
    case WM_STARTSERVER:
        hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
        if (S_OK != hr)
        {
            LogEventString(
                EVENTLOG_ERROR_TYPE,
                MSG_E_OLE_INIT_FAILED,
                NULL);
            _PrintError(hr, "CoInitializeEx");
        }
        else
        {
            hr = certsrvStartServer((BOOL) wParam);
            _PrintIfError(hr, "certsrvStartServer");
        }

        if (S_OK != hr)
        {
            if ((BOOL) wParam)	// fConsoleActive
	    {
                 PostQuitMessage(hr);
	    }
            lRet = hr;		// set this so caller knows we failed
        }
        break;
        
    case WM_SUSPENDSERVER:
        break;
        
    case WM_RESTARTSERVER:
        break;

    default:
        lRet = DefWindowProc(hWnd, msg, wParam, lParam);
    }
    return(lRet);
}

/*

Complete anatomy of certificate server startup/shutdown

WinMain():
|
|g_hSvcThread = CreateThread(CertSrvStartServerThread(SVC_CONTROLLER))
|                     |
|[MessageLoop         \
| processing           CertSrvStartServerThread(SVC_CONTROLLER):
| until                |StartSvcCtrlDispatcher(ServiceMain)
| WM_QUIT]             ||ServiceMain:
|                      ||RegisterSvcCtrlHandler(ServiceControlHandler())
|                      ||hStartThread = CreateThread(CertSrvStartServerThread(0))
|                      ||                    |
|                      ||                    \ 
|                      ||                     CertSrvStartServerThread(0):
|                      ||                     |SendMessage(WM_STARTSERVER)
|                      ||                     \return   // CertSrvStartServerThread(0)
|                      ||                      (Thread Terminates)
|                      ||WaitForSingleObject(hStartThread), pinging SCM
|                      ||CertSrvBlockThreadUntilStop()
|                      |||WaitForSingleObject(g_hSvcStoppingEvent) ***steady state***
|                      ||\return   // CertSrvBlockThreadUntilStop()
|                      ||WaitForSingleObject(g_hSvcStoppedEvent), pinging SCM
|                      ||PostMessage(WM_SYNC_CLOSING_THREADS)
|                      |\return    // StartSvcCtrlDispatcher(ServiceMain)
|                      \return     // CertSrvStartServerThread(SVC_CONTROLLER)
|                       (Thread Terminates)
| WM_QUIT:
\ return
  (Process Terminates)

ServiceControlHandler special functions:
SERVICE_CONTROL_STOP:
|PostMessage(WM_STOPSERVER)
\break

MessageLoop special functions: 

WM_SYNC_CLOSING_THREADS:
|WaitForSingleObject(g_hSvcThread)
|PostQuitMessage()  // WM_QUIT to msgloop
\break

WM_STOPSERVER:
|CertSrvStopServer():
|| Signal(g_hServiceStoppingEvent)
|| Signal(g_hServiceStoppedEvent)
|\ return // CertSrvStopServer()
\break

*/


//+------------------------------------------------------------------------
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	-- Instance handle
//		[hPrevInstance] -- Obsolete
//		[lpCmdLine]	-- App command line
//		[nCmdShow]	-- Starting show state
//-------------------------------------------------------------------------
extern "C" int APIENTRY
wWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPWSTR lpCmdLine,
    IN int nCmdShow)
{
    MSG msg;
    WNDCLASSEX wcApp;
    ATOM atomClass;
    HRESULT hr;
    BOOL fCoInit = FALSE;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszMsgAlloc;
    WCHAR const *pwszMsg;
#if DBG_CERTSRV
    WCHAR *pwszThreadModel = NULL;
#endif

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");

    DBGPRINTINIT("+certsrv.log");
    DBGPRINT((DBG_SS_CERTSRVI, "Main Thread = %x\n", GetCurrentThreadId()));

    g_dwDelay0 = GetRegistryDwordValue(L"Delay0");
    g_dwDelay1 = GetRegistryDwordValue(L"Delay1");
    g_dwDelay2 = GetRegistryDwordValue(L"Delay2");

    if (0 != g_dwDelay0)
    {
	DBGPRINT((
		DBG_SS_CERTSRV,
		"wWinMain(0): sleeping %u seconds\n",
		g_dwDelay0));
	Sleep(1000 * g_dwDelay0);
    }

    // Save the current instance
    g_hInstApp = hInstance;
    ZeroMemory(&wcApp, sizeof(wcApp));

    // Set up the application's window class
    wcApp.cbSize	= sizeof(wcApp);
    wcApp.lpfnWndProc	= MainWndProc;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL, IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL, IDC_ARROW);
    wcApp.hbrBackground	= NULL; // try to not pull in GDI32

    wcApp.lpszClassName	= g_wszAppName;

    atomClass = RegisterClassEx(&wcApp);
    if (!atomClass)
    {
	hr = myHLastError();
	_JumpError(hr, error, "RegisterClassEx");
    }

    // Create Main Window

    g_hwndMain = CreateWindowEx(
			0,			   // dwExStyle
			(WCHAR const *) atomClass, // lpClassName
			L"Certification Authority",// lpWindowName
			WS_OVERLAPPEDWINDOW,	   // dwStyle
			//0,		           // dwStyle
			CW_USEDEFAULT,		   // x
			CW_USEDEFAULT,		   // y
			CW_USEDEFAULT,		   // nWidth
			CW_USEDEFAULT,		   // nHeight
			NULL,			   // hWndParent
			NULL,			   // hMenu
			hInstance,		   // hInstance
			NULL);			   // lpParam

    if (NULL == g_hwndMain)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateWindowEx");
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Main Window = %x\n", g_hwndMain));

    // Make window visible
    // ShowWindow(g_hwndMain,nCmdShow);

    hr = CertArgvMainDispatch(ArgvParseCommandLine, g_wszAppName, lpCmdLine);
    _JumpIfError2(hr, error, "CertArgvMainDispatch", E_INVALIDARG);

    // Update window client area
    // UpdateWindow(g_hwndMain);

    if (0 != g_dwDelay1)
    {
	DBGPRINT((
		DBG_SS_CERTSRV,
		"wWinMain(1): sleeping %u seconds\n",
		g_dwDelay1));
	Sleep(1000 * g_dwDelay1);
    }

    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
    if (S_OK != hr && S_FALSE != hr)
    {
	LogEventStringHResult(
			EVENTLOG_ERROR_TYPE,
			MSG_E_CO_INITIALIZE,
			g_wszCommonName,
			hr);
	_JumpError(hr, error, "CoInitializeEx");
    }
    fCoInit = TRUE;

    g_hServiceStoppingEvent = CreateEvent(NULL, TRUE, FALSE, NULL);  
    if (NULL == g_hServiceStoppingEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    g_hServiceStoppedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_hServiceStoppedEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    g_hCRLManualPublishEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_hCRLManualPublishEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    g_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_hShutdownEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    __try
    {
	InitializeCriticalSection(&g_ShutdownCriticalSection);
	g_fShutdownCritSec = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    g_hServiceThread = CreateThread(
			    NULL,	// lpThreadAttributes (Security Attr)
			    0,		// dwStackSize
			    CertSrvStartServerThread,
			    (VOID *) UlongToPtr((g_fStartAsService ? CSST_STARTSERVICECONTROLLER : CSST_CONSOLE)), // lpParameter
			    0,		// dwCreationFlags
			    &g_ServiceThreadId);
    if (NULL == g_hServiceThread)
    {
	hr = myHLastError();
	LogEventStringHResult(
			EVENTLOG_ERROR_TYPE,
			MSG_E_SERVICE_THREAD,
			g_wszCommonName,
			hr);
	_JumpError(hr, error, "CreateThread");
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Service Thread = %x\n", g_ServiceThreadId));

    // Message Loop
    while (TRUE)
    {
	BOOL b;

	b = GetMessage(&msg, NULL, 0, 0);
	if (!b)
	{
	    hr = (HRESULT)msg.wParam;
	    _JumpIfError(hr, error, "WM_QUIT");
	    break;
	}
	if (-1 == (LONG) b)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetMessage");
	}
	DBGPRINT((
		DBG_SS_CERTSRVI,
		"DispatchMessage(tid=%d) msg=0x%x, wp=0x%x, lp=0x%x\n",
		GetCurrentThreadId(),
		msg.message,
		msg.wParam,
		msg.lParam));
	DispatchMessage(&msg);
    }

error:
    if (fCoInit)
    {
	CoUninitialize();
    }
    if (g_fShutdownCritSec)
    {
	DeleteCriticalSection(&g_ShutdownCriticalSection);
	g_fShutdownCritSec = FALSE;
    }
    if (NULL != g_hShutdownEvent)
    {
        CloseHandle(g_hShutdownEvent);
    }
    if (NULL != g_hServiceThread)
    {
        CloseHandle(g_hServiceThread);
    }
    if (NULL != g_hServiceStoppingEvent)
    {
	CloseHandle(g_hServiceStoppingEvent);
    }
    if (NULL != g_hServiceStoppedEvent)
    {
        CloseHandle(g_hServiceStoppedEvent);
    }
    if (NULL != g_hCRLManualPublishEvent)
    {
        CloseHandle(g_hCRLManualPublishEvent);
    }
    CAuditEvent::CleanupAuditEventTypeHandles();

    pwszMsgAlloc = NULL;
    pwszMsg = L"S_OK";
    if (S_OK != hr)
    {
	pwszMsgAlloc = myGetErrorMessageText(hr, TRUE);
	if (NULL != pwszMsgAlloc)
	{
	    pwszMsg = pwszMsgAlloc;
	}
	else
	{
	    pwszMsg = myHResultToString(awchr, hr);
	}
    }
    CONSOLEPRINT1((DBG_SS_CERTSRV, "Exit Status = %ws\n", pwszMsg));
    if (NULL != pwszMsgAlloc)
    {
	LocalFree(const_cast<WCHAR *>(pwszMsgAlloc));
    }
    myFreeResourceStrings("certsrv.exe");
    myFreeColumnDisplayNames();
    myRegisterMemDump();
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\cienum.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cienum.cpp
//
// Contents:    Extension and Attribute enumerator
//
// History:     12-Mar-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"


HRESULT
CIENUM::EnumSetup(
    IN DWORD RequestId,
    IN LONG Context,
    IN DWORD Flags)
{
    HRESULT hr;

    EnumClose();

    ICertDBRow *prow = NULL;

    hr = g_pCertDB->OpenRow(PROPOPEN_READONLY | PROPTABLE_REQCERT, RequestId, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = prow->EnumCertDBName(~CIE_CALLER_MASK & Flags, &m_penum);
    _JumpIfError(hr, error, "EnumCertDBName");

    m_Context = Context;
    m_Flags = Flags;

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
CIENUM::EnumNext(OUT BSTR *pstrPropertyName)
{
    HRESULT hr = E_UNEXPECTED;
    CERTDBNAME cdbn;

    cdbn.pwszName = NULL;

    if (NULL == pstrPropertyName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrPropertyName NULL");
    }
    if (NULL != *pstrPropertyName)
    {
	SysFreeString(*pstrPropertyName);
	*pstrPropertyName = NULL;
    }
    if (NULL != m_penum)
    {
	ULONG celtFetched;

	hr = m_penum->Next(1, &cdbn, &celtFetched);
	_JumpIfError2(hr, error, "Next", S_FALSE);

	CSASSERT(1 == celtFetched);
	CSASSERT(NULL != cdbn.pwszName);

	if (!ConvertWszToBstr(pstrPropertyName, cdbn.pwszName, -1))
	{
	    hr = E_OUTOFMEMORY;
	    goto error;
	}
    }
error:
    if (NULL != cdbn.pwszName)
    {
	CoTaskMemFree(cdbn.pwszName);
    }
    return(hr);
}


HRESULT
CIENUM::EnumClose()
{
    if (NULL != m_penum)
    {
        m_penum->Release();
	m_penum = NULL;
    }
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\admin.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.h
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

// Admin Interface
class CCertAdminD : public ICertAdminD2
{
public:
    // IUnknown

    virtual STDMETHODIMP QueryInterface(const IID& iid, void**ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // ICertAdminD

    virtual STDMETHODIMP SetExtension(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId,
	IN wchar_t const *pwszExtensionName,
	IN DWORD          dwType,
	IN DWORD          dwFlags,
	IN CERTTRANSBLOB *ptbValue);

    virtual STDMETHODIMP SetAttributes(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId,
	IN wchar_t const *pwszAttributes);

    virtual STDMETHODIMP ResubmitRequest(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId,
	OUT DWORD        *pdwDisposition);

    virtual STDMETHODIMP DenyRequest(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId);

    virtual STDMETHODIMP IsValidCertificate(
	IN wchar_t const *pwszAuthority,
	IN wchar_t const *pwszSerialNumber,
	OUT LONG         *pRevocationReason,
	OUT LONG         *pDisposition);

    virtual STDMETHODIMP PublishCRL(
	IN wchar_t const *pwszAuthority,
	IN FILETIME       FileTime);

    virtual STDMETHODIMP GetCRL(
	IN  wchar_t const *pwszAuthority,
	OUT CERTTRANSBLOB *ptbCRL);

    virtual STDMETHODIMP RevokeCertificate(
	IN wchar_t const *pwszAuthority,
	IN wchar_t const *pwszSerialNumber,
	IN DWORD          Reason,
	IN FILETIME       FileTime);

    virtual STDMETHODIMP EnumViewColumn(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          iColumn,
	IN  DWORD          cColumn,
	OUT DWORD         *pcColumn,
	OUT CERTTRANSBLOB *ptbColumnInfo);

    virtual STDMETHODIMP GetViewDefaultColumnSet(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          iColumnSetDefault,
	OUT DWORD         *pcColumn,
	OUT CERTTRANSBLOB *ptbColumnInfo);

    virtual STDMETHODIMP EnumAttributesOrExtensions(
	IN          wchar_t const *pwszAuthority,
	IN          DWORD          RowId,
	IN          DWORD          Flags,
	OPTIONAL IN wchar_t const *pwszLast,
	IN          DWORD          celt,
	OUT         DWORD         *pceltFetched,
	OUT         CERTTRANSBLOB *pctbOut);

    virtual STDMETHODIMP OpenView(
	IN wchar_t const             *pwszAuthority,
	IN DWORD                      ccvr,
	IN CERTVIEWRESTRICTION const *acvr,
	IN DWORD                      ccolOut,
	IN DWORD const               *acolOut,
	IN DWORD                      ielt,
	IN DWORD                      celt,
	OUT DWORD                    *pceltFetched,
	OUT CERTTRANSBLOB            *pctbResultRows);

    virtual STDMETHODIMP EnumView(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          ielt,
	IN  DWORD          celt,
	OUT DWORD         *pceltFetched,
	OUT CERTTRANSBLOB *pctbResultRows);

    virtual STDMETHODIMP CloseView(
	IN wchar_t const *pwszAuthority);

    virtual STDMETHODIMP ServerControl(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          dwControlFlags,
	OUT CERTTRANSBLOB *pctbOut);

    virtual STDMETHODIMP Ping(	// test function
	IN wchar_t const *pwszAuthority);

    virtual STDMETHODIMP GetServerState(
	IN  WCHAR const *pwszAuthority,
	OUT DWORD       *pdwState);

    virtual STDMETHODIMP BackupPrepare(
	IN WCHAR const  *pwszAuthority,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	IN WCHAR const  *pwszBackupAnnotation,
	IN DWORD         dwClientIdentifier);

    virtual STDMETHODIMP BackupEnd();

    virtual STDMETHODIMP BackupGetAttachmentInformation(
	OUT WCHAR **ppwszzDBFiles,
	OUT LONG   *pcwcDBFiles);

    virtual STDMETHODIMP BackupGetBackupLogs(
	OUT WCHAR **ppwszzLogFiles,
	OUT LONG   *pcwcLogFiles);

    virtual STDMETHODIMP BackupOpenFile(
	IN  WCHAR const    *pwszPath,
	OUT unsigned hyper *pliLength);

    virtual STDMETHODIMP BackupReadFile(
	OUT BYTE *pbBuffer,
	IN  LONG  cbBuffer,
	OUT LONG *pcbRead);

    virtual STDMETHODIMP BackupCloseFile();

    virtual STDMETHODIMP BackupTruncateLogs();

    virtual STDMETHODIMP ImportCertificate( 
        IN wchar_t const *pwszAuthority,
        IN CERTTRANSBLOB *pctbCertificate,
        IN LONG dwFlags,
        OUT LONG *pdwRequestId);

    virtual STDMETHODIMP BackupGetDynamicFiles(
	OUT WCHAR **ppwszzFiles,
	OUT LONG   *pcwcFiles);

    virtual STDMETHODIMP RestoreGetDatabaseLocations(
	OUT WCHAR **ppwszDatabaseLocations,
	OUT LONG   *pcwcPaths);

    // ICertAdminD2

    virtual STDMETHODIMP PublishCRLs(
        IN wchar_t const *pwszAuthority,
	IN FILETIME       FileTime,
	IN DWORD          Flags);		// CA_CRL_*

    virtual STDMETHODIMP GetCAProperty(
	IN  wchar_t const *pwszAuthority,
	IN  LONG           PropId,		// CR_PROP_*
	IN  LONG           PropIndex,
	IN  LONG           PropType,		// PROPTYPE_*
	OUT CERTTRANSBLOB *pctbPropertyValue);

    virtual STDMETHODIMP SetCAProperty(
	IN  wchar_t const *pwszAuthority,
	IN  LONG           PropId,		// CR_PROP_*
	IN  LONG           PropIndex,
	IN  LONG           PropType,		// PROPTYPE_*
	OUT CERTTRANSBLOB *pctbPropertyValue);

    virtual STDMETHODIMP GetCAPropertyInfo(
	IN  wchar_t const *pwszAuthority,
	OUT LONG          *pcProperty,
	OUT CERTTRANSBLOB *pctbPropInfo);

    virtual STDMETHODIMP EnumViewColumnTable(
        IN  wchar_t const *pwszAuthority,
        IN  DWORD          iTable,
        IN  DWORD          iColumn,
        IN  DWORD          cColumn,
        OUT DWORD         *pcColumn,
	OUT CERTTRANSBLOB *pctbColumnInfo);

    virtual STDMETHODIMP GetCASecurity(
        IN  wchar_t const *pwszAuthority,
        OUT CERTTRANSBLOB *pctbSD);

    virtual STDMETHODIMP SetCASecurity(
        IN wchar_t const *pwszAuthority,
        IN CERTTRANSBLOB *pctbSD);

    // this is a test function
    virtual STDMETHODIMP Ping2(
        IN wchar_t const *pwszAuthority);

    virtual STDMETHODIMP GetArchivedKey(
        IN  wchar_t const *pwszAuthority,
	IN  DWORD	   dwRequestId,
	OUT CERTTRANSBLOB *pctbArchivedKey);

    virtual STDMETHODIMP GetAuditFilter(
	IN wchar_t const *pwszAuthority,
	OUT DWORD        *pdwFilter);

    virtual STDMETHODIMP SetAuditFilter(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwFilter);

    virtual STDMETHODIMP GetOfficerRights(
        IN  wchar_t const *pwszAuthority,
        OUT BOOL          *pfEnabled,
        OUT CERTTRANSBLOB *pctbSD);

    virtual STDMETHODIMP SetOfficerRights(
        IN wchar_t const *pwszAuthority,
        IN BOOL           fEnable,
        IN CERTTRANSBLOB *pctbSD);

    virtual STDMETHODIMP GetConfigEntry(
        IN wchar_t const *pwszAuthority,
        IN wchar_t const *pwszNodePath,
        IN wchar_t const *pwszEntry,
        OUT VARIANT      *pVariant);

    virtual STDMETHODIMP SetConfigEntry(
        IN wchar_t const *pwszAuthority,
        IN wchar_t const *pwszNodePath,
        IN wchar_t const *pwszEntry,
        IN VARIANT       *pVariant);

    virtual STDMETHODIMP ImportKey(
	IN wchar_t const *pwszAuthority,
	IN DWORD          RequestId,
	IN wchar_t const *pwszCertHash,
	IN DWORD          Flags,
	IN CERTTRANSBLOB *pctbKey);

    virtual STDMETHODIMP GetMyRoles(
	IN wchar_t const *pwszAuthority,
	OUT LONG         *pdwRoles);

    virtual STDMETHODIMP DeleteRow(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwFlags,		// CDR_*
	IN FILETIME       FileTime,
	IN DWORD          dwTable,		// CVRC_TABLE_*
	IN DWORD          dwRowId,
	OUT LONG         *pcDeleted);


    // CCertAdminD

    // Constructor
    CCertAdminD();

    // Destructor
    ~CCertAdminD();

private:
    HRESULT _EnumAttributes(
	IN ICertDBRow     *prow,
	IN CERTDBNAME     *adbn,
	IN DWORD           celt,
	OUT CERTTRANSBLOB *pctbOut);

    HRESULT _EnumExtensions(
	IN ICertDBRow     *prow,
	IN CERTDBNAME     *adbn,
	IN DWORD           celt,
	OUT CERTTRANSBLOB *pctbOut);

    HRESULT _EnumViewNext(
	IN  IEnumCERTDBRESULTROW *pview,
	IN  DWORD                 ielt,
	IN  DWORD                 celt,
	OUT DWORD                *pceltFetched,
	OUT CERTTRANSBLOB        *pctbResultRows);

    HRESULT _BackupGetFileList(
	IN  DWORD   dwFileType,
	OUT WCHAR **ppwszzFiles,
	OUT LONG   *pcwcFiles);

    HRESULT _GetDynamicFileList(
	IN OUT DWORD *pcwcList,
	OUT WCHAR    *pwszzList);

    HRESULT _GetDatabaseLocations(
	IN OUT DWORD *pcwcList,
	OUT WCHAR    *pwszzList);

    // this is a test function
    HRESULT _Ping(
        IN wchar_t const *pwszAuthority);

private:
    IEnumCERTDBCOLUMN    *m_pEnumCol;
    DWORD		  m_iTableEnum;

    IEnumCERTDBRESULTROW *m_pView;
    ICertDBBackup        *m_pBackup;
    JET_GRBIT		  m_grbitBackup;

    // Reference count
    long                  m_cRef;
    long                  m_cNext;
};


// Class of Admin factory
class CAdminFactory : public IClassFactory
{
public:
	// IUnknown
	virtual STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// Interface IClassFactory
	virtual STDMETHODIMP CreateInstance(
					IUnknown *pUnknownOuter,
					const IID& iid,
					void **ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock);

	// Constructor
	CAdminFactory() : m_cRef(1) { }

	// Destructor
	~CAdminFactory();

public:
    static STDMETHODIMP  CanUnloadNow();
    static STDMETHODIMP  StartFactory();
    static void     StopFactory();

private:
    long           m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certreq\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_USAGE_DESCRIPTION),
    RESSTR(IDS_REQUEST_FILTER2),
    RESSTR(IDS_FORMATSTR_CERTRETRIEVED),
    RESSTR(IDS_REQUEST_OUTFILE_TITLE),
    RESSTR(IDS_REQUEST_CERT_ERROR),
    RESSTR(IDS_APP_NAME),
    RESSTR(IDS_WINDOW_NAME),
    RESSTR(IDS_ERROR_NO_REQUESTID),
    RESSTR(IDS_USAGE_GENERAL),
    RESSTR(IDS_ERROR_STRCONVERSION),
    RESSTR(IDS_DISPOSITION_INCOMPLETE),
    RESSTR(IDS_DISPOSITION_ERROR),
    RESSTR(IDS_DISPOSITION_DENIED),
    RESSTR(IDS_DISPOSITION_ISSUED),
    RESSTR(IDS_DISPOSITION_ISSUED_OOB),
    RESSTR(IDS_DISPOSITION_UNDER_SUBMISSION),
    RESSTR(IDS_DISPOSITION_REVOKED),
    RESSTR(IDS_DISPOSITION_UNKNOWN),
    RESSTR(IDS_FORMATSTR_CERTNOTISSUED),
    RESSTR(IDS_FORMATSTR_CERTPENDING),
    RESSTR(IDS_CERTREQ_TITLE),
    RESSTR(IDS_FORMATSTR_DECODE_ERR),
    RESSTR(IDS_FORMATSTR_ERRCONFIG),
    RESSTR(IDS_USAGE_OPTIONS_DESCRIPTION),
    RESSTR(IDS_ERROR_NO_FILENAME),
    RESSTR(IDS_NOMORE_CAS),
    RESSTR(IDS_GETERACERT_TITLE),
    RESSTR(IDS_GETERACERT_SUBTITLE),
    RESSTR(IDS_INF_OPEN_TITLE),
    RESSTR(IDS_INF_FILE_FILTER),
    RESSTR(IDS_INF_FILE_DEFEXT),
    RESSTR(IDS_OVERWRITE_FILE),
    RESSTR(IDS_RESPONSE_FILE_FILTER),
    RESSTR(IDS_RESPONSE_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OR_CERT_FILE_FILTER),
    RESSTR(IDS_FORMATSTR_REQUESTID),
    RESSTR(IDS_GETRENEWALCERT_TITLE),
    RESSTR(IDS_GETRENEWALCERT_SUBTITLE),
    RESSTR(IDS_GETSIGNINGCERT_TITLE),
    RESSTR(IDS_GETSIGNINGCERT_SUBTITLE),
    RESSTR(IDS_USAGE_VERB_DEFAULT),
    RESSTR(IDS_USAGE_OPTIONS_DEFAULT),
    RESSTR(IDS_USAGE_VERB_RETRIEVE),
    RESSTR(IDS_USAGE_OPTIONS_RETRIEVE),
    RESSTR(IDS_USAGE_VERB_POLICY),
    RESSTR(IDS_USAGE_OPTIONS_POLICY),
    RESSTR(IDS_USAGE_VERB_SIGN),
    RESSTR(IDS_USAGE_OPTIONS_SIGN),
    RESSTR(IDS_USAGE_VERB_NEW),
    RESSTR(IDS_USAGE_OPTIONS_NEW),
    RESSTR(IDS_USAGE_VERB_ACCEPT),
    RESSTR(IDS_USAGE_OPTIONS_ACCEPT),
    RESSTR(IDS_USAGE_OPTION_ANY),
    RESSTR(IDS_USAGE_OPTION_ATTRIB),
    RESSTR(IDS_USAGE_OPTION_BINARY),
    RESSTR(IDS_USAGE_OPTION_CERT),
    RESSTR(IDS_USAGE_OPTION_CONFIG),
    RESSTR(IDS_USAGE_OPTION_CRL),
    RESSTR(IDS_USAGE_OPTION_F),
    RESSTR(IDS_USAGE_OPTION_Q),
    RESSTR(IDS_USAGE_OPTION_RPC),
    RESSTR(IDS_USAGE_OPTION_VERBOSE),
    RESSTR(IDS_USAGE_OPTION_QUESTION),
    RESSTR(IDS_USAGE_OPTION_V1),
    RESSTR(IDS_USAGE_OPTION_IDISPATCH),
    RESSTR(IDS_CERTTYPE_USER),
    RESSTR(IDS_CERTTYPE_USER_AS),
    RESSTR(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
    RESSTR(IDS_CERTTYPE_EFS),
    RESSTR(IDS_CERTTYPE_ADMIN),
    RESSTR(IDS_CERTTYPE_EFS_RECOVERY),
    RESSTR(IDS_CERTTYPE_CODE_SIGNING),
    RESSTR(IDS_CERTTYPE_CTL_SIGNING),
    RESSTR(IDS_CERTTYPE_MACHINE),
    RESSTR(IDS_CERTTYPE_DC),
    RESSTR(IDS_CERTTYPE_WEBSERVER),
    RESSTR(IDS_CERTTYPE_KDC),
    RESSTR(IDS_CERTTYPE_ROOT_CA),
    RESSTR(IDS_CERTTYPE_SUBORDINATE_CA),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT),
    RESSTR(IDS_CERTTYPE_SMARTCARD_USER),
    RESSTR(IDS_CERTTYPE_USER_SIGNATURE),
    RESSTR(IDS_ILOG_BAD_NUMERICFIELD),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_COUNT),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING),
    RESSTR(IDS_CERTTYPE_ROUTER_OFFLINE),
    RESSTR(IDS_REQUEST_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OPEN_TITLE),
    RESSTR(IDS_REQUEST_FILE_FILTER),
    RESSTR(IDS_WRN_COMPUTERNAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_NOT_MATCH),
    RESSTR(IDS_WRN_PINGCA_FAIL),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
    RESSTR(IDS_WRN_CALIST_EMPTY),
    RESSTR(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
    RESSTR(IDS_REQUEST_SAVE_TITLE),
    RESSTR(IDS_CERTTYPE_CEP_ENCRYPTION),
    RESSTR(IDS_ILOG_CAPOLICY_BUILD),
    RESSTR(IDS_ILOG_CAPOLICY_ELEMENT),
    RESSTR(IDS_ILOG_CAPOLICY_EXTENSION),
    RESSTR(IDS_ILOG_CAPOLICY_NOKEY),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN_FAILED),
    RESSTR(IDS_ILOG_BEGIN),
    RESSTR(IDS_ILOG_END),
    RESSTR(IDS_ACTRL_CAADMIN),
    RESSTR(IDS_ACTRL_OFFICER),
    RESSTR(IDS_ACTRL_AUDITOR),
    RESSTR(IDS_ACTRL_OPERATOR),
    RESSTR(IDS_ACTRL_CAREAD),
    RESSTR(IDS_ACTRL_ENROLL),
    RESSTR(IDS_ILOG_CAPOLICY_CLOSE),
    RESSTR(IDS_ILOG_MESSAGEBOX),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
    RESSTR(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
    RESSTR(IDS_CERTTYPE_CA_EXCHANGE),
    RESSTR(IDS_EMPTY_FRIENDLY_NAME),
    RESSTR(IDS_CERTTYPE_CROSS_CA),
    RESSTR(IDS_CERTTYPE_DC_AUTH),
    RESSTR(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
    RESSTR(IDS_WARN_ENTERPRISE_REQUIREMENTS),
    RESSTR(IDS_WRN_OLD_CA),
    RESSTR(IDS_KRA_DESCRIPTION),
    RESSTR(IDS_EMAIL_REPLICATION_DESCRIPTION),
    RESSTR(IDS_CROSS_CA_DESCRIPTION),
    RESSTR(IDS_CA_DESCRIPTION),
    RESSTR(IDS_MACHINE_DESCRIPTION),
    RESSTR(IDS_END_USER_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_DESCRIPTION),
    RESSTR(IDS_STORENAME_DS_KRA),
    RESSTR(IDS_STORENAME_DS_AIA),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\com.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        com.cpp
//
// Contents:    Cert Server Policy & Exit module callouts
//
// History:     7-Feb-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>

#include "csdisp.h"
#include "elog.h"
#include "certlog.h"
#include "cscom.h"
#include "csprop.h"

#include "com.h"

#define __dwFILE__	__dwFILE_CERTSRV_COM_CPP__


BSTR g_strPolicyDescription = NULL;
BOOL g_fEnablePolicy = FALSE;
MarshalInterface g_miPolicy;

typedef struct _CERTSRV_COM_CONTEXT_ENTRY
{
    USHORT               usFlags;
    CERTSRV_COM_CONTEXT *pComContext;
} CERTSRV_COM_CONTEXT_ENTRY;


// data structure to pass handles between server and policy/exit modules
CERTSRV_COM_CONTEXT_ENTRY *g_pComContextTable = NULL;
DWORD                      g_dwComContextCount = 0;
USHORT                     g_usComContextId = 0; // id increament
CRITICAL_SECTION           g_ComCriticalSection;
BOOL g_fComCritSec = FALSE;
CERTSRV_COM_CONTEXT       *g_pExitComContext = NULL;

// NOTE: GlobalInterfaceTable better to use than CoMarshalInterface


static IGlobalInterfaceTable*   g_pGIT = NULL;

// Clear out any error info
VOID
comClearError(VOID)
{
    IErrorInfo *pErrorInfo = NULL;

    if (S_OK == GetErrorInfo(0, &pErrorInfo))
    {
        if (NULL != pErrorInfo)
        {
            pErrorInfo->Release();
        }
    }
}

HRESULT
MarshalInterface::SetConfig(
    IN LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;
    if (NULL == pwszSanitizedName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "SetConfig");
    }

    m_szConfig = (LPWSTR) LocalAlloc(
				LMEM_FIXED,
				(wcslen(g_pwszServerName) + 1 + wcslen(pwszSanitizedName) + 1) * sizeof(WCHAR));
    if (NULL == m_szConfig)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // config comes to us without server name: add it
    wcscpy((LPWSTR)m_szConfig, g_pwszServerName);
    wcscat((LPWSTR)m_szConfig, L"\\");
    wcscat((LPWSTR)m_szConfig, pwszSanitizedName);

error:
    return hr;
}


VOID
MarshalInterface::Initialize(
    IN WCHAR const *pwszProgID,
    IN CLSID const *pclsid,
    IN DWORD cver,
    IN IID const * const *ppiid,	// cver elements
    IN DWORD const *pcDispatch,		// cver elements
    IN DISPATCHTABLE *adt)
{
    if (NULL != pwszProgID)
    {
        m_pwszProgID = (LPWSTR) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszProgID) + 1) * sizeof(WCHAR));
        if (NULL != m_pwszProgID)
	{
            wcscpy(m_pwszProgID, pwszProgID);
	}
    }

    m_pclsid = pclsid;
    m_cver = cver;
    m_ppiid = ppiid;
    m_pcDispatch = pcDispatch;
    m_adt = adt;
    m_fIDispatch = FALSE;
    m_dwIFCookie = 0;
    m_fInitialized = TRUE;
}


HRESULT
MarshalInterface::Setup(
    OUT DISPATCHINTERFACE **ppDispatchInterface)
{
    HRESULT hr;

    CSASSERT(m_fInitialized);
    *ppDispatchInterface = NULL;

    hr = DispatchSetup2(
		DISPSETUP_COMFIRST,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
		m_pwszProgID,
		m_pclsid,
		m_cver,
		m_ppiid,
		m_pcDispatch,
		m_adt,
		&m_DispatchInterface);

    // Don't complain if no class is registered.

    _JumpIfError2(
		hr,
		error,
		"DispatchSetup",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    m_fIDispatch = NULL != m_DispatchInterface.m_adispid;

    CSASSERT(
	0 < m_DispatchInterface.m_dwVersion &&
	m_cver >= m_DispatchInterface.m_dwVersion);
    m_iiid = m_cver - m_DispatchInterface.m_dwVersion;

    // create GIT if it doesn't yet exist
    if (NULL == g_pGIT)
    {
        hr = CoCreateInstance(
			    CLSID_StdGlobalInterfaceTable,
			    NULL,
			    CLSCTX_INPROC_SERVER,
			    IID_IGlobalInterfaceTable,
			    (void **) &g_pGIT);
        _JumpIfError(hr, error, "CoCreateInstance(GIT)");
    }

    hr = Marshal(&m_DispatchInterface);
    _JumpIfError(hr, error, "Marshal");

    *ppDispatchInterface = &m_DispatchInterface;

error:
    if (S_OK != hr)
    {
    	TearDown();
    }
    return(hr);
}


VOID
MarshalInterface::TearDown(VOID)
{
    if (m_fInitialized)
    {
        if (NULL != g_pGIT && 0 != m_dwIFCookie)
	{
	    g_pGIT->RevokeInterfaceFromGlobal(m_dwIFCookie);
	    m_dwIFCookie = 0;
	}
        DispatchRelease(&m_DispatchInterface);
	m_fInitialized = 0;
    }
    if (NULL != m_pwszProgID)
    {
        LocalFree(m_pwszProgID);
        m_pwszProgID = NULL;
    }
    
    if (NULL != m_szConfig)
    {
        LocalFree((LPWSTR)m_szConfig);
        m_szConfig = NULL;
    }
}


HRESULT
MarshalInterface::Marshal(
    IN DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr;

    CSASSERT(g_pGIT);
    if (g_pGIT == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpIfError(hr, error, "GlobalInterfaceTable not initialized");
    }

    hr = g_pGIT->RegisterInterfaceInGlobal(
			m_fIDispatch?
			    pDispatchInterface->pDispatch :
			    pDispatchInterface->pUnknown,
			m_fIDispatch? IID_IDispatch : *m_ppiid[m_iiid],
			&m_dwIFCookie);
    _JumpIfError(hr, error, "RegisterInterfaceInGlobal");

error:
    return(hr);
}


HRESULT
MarshalInterface::Remarshal(
    OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr;
    BOOL fRetrying = FALSE;

    DBGPRINT((DBG_SS_CERTSRVI, "Remarshal(tid=%d)\n", GetCurrentThreadId()));
    CSASSERT(m_fInitialized);

    pDispatchInterface->pDispatch = NULL;
    pDispatchInterface->pUnknown = NULL;

    CSASSERT(g_pGIT);
    if (g_pGIT == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpIfError(hr, error, "GlobalInterfaceTable not initialized");
    }

    hr = g_pGIT->GetInterfaceFromGlobal(
			m_dwIFCookie,
			m_fIDispatch? IID_IDispatch : *m_ppiid[m_iiid],
			m_fIDispatch?
			    (VOID **) &pDispatchInterface->pDispatch :
			    (VOID **) &pDispatchInterface->pUnknown);

    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "Remarshal(tid=%d) --> 0x%x\n",
	    GetCurrentThreadId(),
	    hr));

    _JumpIfError(hr, error, "GetInterfaceFromGlobal");

    // Copy invariants to the marshaled interface:
    
    pDispatchInterface->SetIID(m_ppiid[m_iiid]);
    pDispatchInterface->pDispatchTable = m_DispatchInterface.pDispatchTable;
    pDispatchInterface->m_cDispatchTable = m_DispatchInterface.m_cDispatchTable;
    pDispatchInterface->m_cdispid = m_DispatchInterface.m_cdispid;
    pDispatchInterface->m_adispid = m_DispatchInterface.m_adispid;

error:
    return(hr);
}


VOID
MarshalInterface::Unmarshal(
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    // Don't free global DISPID table from marshaled interface:

    pDispatchInterface->m_adispid = NULL;
    DispatchRelease(pDispatchInterface);
}


// forwards
VOID PolicyRelease(VOID);
VOID ExitRelease(VOID);


#define COMCONTEXTCOUNTMIN         4
#define COMCONTEXTCOUNTMAX      1024  // must less than 64K
#define COMCONTEXTCOUNTDEFAULT    20

HRESULT
ComInit(VOID)
{
    HRESULT  hr;
    HKEY  hKey = NULL;
    DWORD dwSize;

    CSASSERT(NULL == g_pComContextTable);

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, g_wszRegKeyConfigPath, &hKey);
    _JumpIfError(hr, error, "RegOpenKey(Config)");

    dwSize = sizeof(g_dwComContextCount);
    hr = RegQueryValueEx(
		    hKey,
		    wszREGDBSESSIONCOUNT, // just use db session count
                                          // bug, may not be logic related
		    NULL,
		    NULL,
		    (BYTE *) &g_dwComContextCount,
		    &dwSize);
    if (S_OK != hr)
    {
        _PrintErrorStr(hr, "RegQueryValueEx", wszREGDBSESSIONCOUNT);
        g_dwComContextCount = COMCONTEXTCOUNTDEFAULT;
    }
    if (COMCONTEXTCOUNTMIN > g_dwComContextCount)
    {
        g_dwComContextCount = COMCONTEXTCOUNTMIN;
    }
    if (COMCONTEXTCOUNTMAX < g_dwComContextCount)
    {
        g_dwComContextCount = COMCONTEXTCOUNTMAX;
    }

    g_pComContextTable = (CERTSRV_COM_CONTEXT_ENTRY *) LocalAlloc(
				     LMEM_FIXED | LMEM_ZEROINIT,
				     g_dwComContextCount *
					 sizeof(g_pComContextTable[0]));
    if (NULL == g_pComContextTable)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    __try
    {
	InitializeCriticalSection(&g_ComCriticalSection);
	g_fComCritSec = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return hr;
}


VOID
ComShutDown(VOID)
{
    if (NULL != g_pComContextTable)
    {
	PolicyRelease();
	ExitRelease();
	if (NULL != g_pGIT)
	{
	    g_pGIT->Release();
	    g_pGIT = NULL;
	}
	if (g_fComCritSec)
	{
	    DeleteCriticalSection(&g_ComCriticalSection);
	    g_fComCritSec = FALSE;
	}
        LocalFree(g_pComContextTable);
        g_pComContextTable = NULL;
        g_dwComContextCount = 0;
    }
}


HRESULT
RegisterComContext(
    IN CERTSRV_COM_CONTEXT *pComContext,
    IN OUT DWORD *pdwIndex)
{
    HRESULT  hr = S_OK;
    BOOL     fCS = FALSE;
    DWORD    i;

    CSASSERT(NULL != pComContext);
    CSASSERT(NULL != g_pComContextTable);

    if (NULL == pComContext)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "null com context pointer");
    }
    if (!g_fComCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ComCriticalSection);
    fCS = TRUE;

    for (i = 0; NULL != g_pComContextTable[i].pComContext; ++i)
    {
        if (i + 1 == g_dwComContextCount)
        {
            //hr = HRESULT_FROM_WIN32(ERROR_BUSY);
            hr = HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY);
            _JumpError(hr, error, "com context table full");
        }
    }
    // pick an id
    if (0 == g_usComContextId)
    {
        // it could make module context to be 0 which is a special flag
        // avoid 0
        ++g_usComContextId;
    }
    g_pComContextTable[i].usFlags = g_usComContextId++;
    // point to com context
    g_pComContextTable[i].pComContext = pComContext;

    *pdwIndex = i;

error:
    if (fCS)
    {
        LeaveCriticalSection(&g_ComCriticalSection);
    }
    return hr;
}


VOID
UnregisterComContext(
    IN CERTSRV_COM_CONTEXT *pComContext,
    IN DWORD dwIndex)
{
    HRESULT hr = S_OK;
    BOOL fCS = FALSE;

    // if shutdown in progress after wait timeout
    
    if (NULL == g_pComContextTable)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "NULL g_pComContextTable");
    }
    CSASSERT(dwIndex < g_dwComContextCount);

    if (!g_fComCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ComCriticalSection);
    fCS = TRUE;

    if (dwIndex < g_dwComContextCount)
    {
	CSASSERT(0 != g_pComContextTable[dwIndex].usFlags);
	CSASSERT(NULL != g_pComContextTable[dwIndex].pComContext);
	CSASSERT(pComContext == g_pComContextTable[dwIndex].pComContext);

	g_pComContextTable[dwIndex].usFlags = 0;
	g_pComContextTable[dwIndex].pComContext = NULL;
    }
error:
    if (fCS)
    {
        LeaveCriticalSection(&g_ComCriticalSection);
    }
}


CERTSRV_COM_CONTEXT *
GetComContextFromIndex(
    IN DWORD  dwIndex)
{
    CERTSRV_COM_CONTEXT *pComContext = NULL;

    CSASSERT(NULL != g_pComContextTable);
    CSASSERT(dwIndex < g_dwComContextCount);

    if (dwIndex < g_dwComContextCount)
    {
	CSASSERT(0 != g_pComContextTable[dwIndex].usFlags);
	CSASSERT(NULL != g_pComContextTable[dwIndex].pComContext);
	pComContext = g_pComContextTable[dwIndex].pComContext;
    }

    return(pComContext);
}


DWORD
ComContextToModuleContext(
    IN DWORD dwComContextIndex)
{
    CSASSERT(NULL != g_pComContextTable);
    CSASSERT(dwComContextIndex < g_dwComContextCount);
    CSASSERT(0 != g_pComContextTable[dwComContextIndex].usFlags);
    CSASSERT(NULL != g_pComContextTable[dwComContextIndex].pComContext);

    DWORD dwHigh =
        (dwComContextIndex << 16) & 0xFFFF0000; // move index to high 16 bits
    DWORD dwLow =
        ((DWORD)g_pComContextTable[dwComContextIndex].usFlags) & 0x0000FFFF;

    return(dwHigh | dwLow);
}


HRESULT
ModuleContextToComContextIndex(
    IN DWORD dwModuleContext,
    OUT DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    USHORT  usFlags = (USHORT)(dwModuleContext & 0x0000FFFF);
    DWORD   dwIndex = (dwModuleContext >> 16) & 0x0000FFFF;

    CSASSERT(NULL != pdwIndex);

    *pdwIndex = MAXDWORD;
    if (dwIndex >= g_dwComContextCount ||
	0 == usFlags ||
	g_pComContextTable[dwIndex].usFlags != usFlags)
    {
        // module passed a bogus handle
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid context from policy/exit");
    }
    CSASSERT(NULL != g_pComContextTable[dwIndex].pComContext);
    // for return
    *pdwIndex = dwIndex;

error:
    return hr;
}


HRESULT
ModuleContextToRequestId(
    IN DWORD dwModuleContext,
    OUT DWORD *pdwRequestId)
{
    DWORD   dwIndex;
    HRESULT hr = ModuleContextToComContextIndex(dwModuleContext, &dwIndex);
    _JumpIfError(hr, error, "ModuleContextToComContextIndex");

    // for return
    *pdwRequestId = g_pComContextTable[dwIndex].pComContext->RequestId;
error:
    return hr;
}


HRESULT
ComVerifyRequestContext(
    IN BOOL fAllowZero,
    IN DWORD Flags,
    IN LONG Context,
    OUT DWORD *pRequestId)
{
    HRESULT hr;
    
    *pRequestId = 0;
    if (0 == Context)
    {
	hr = S_OK;
	if (!fAllowZero)
	{
	    hr = E_HANDLE;
	}
    }
    else
    {
	switch (PROPCALLER_MASK & Flags)
	{
	    case PROPCALLER_EXIT:
		hr = ModuleContextToRequestId(Context, pRequestId);
                _JumpIfError(hr, error, "ModuleContextToRequestId");
		break;

	    case PROPCALLER_POLICY:
		hr = ModuleContextToRequestId(Context, pRequestId);
                _JumpIfError(hr, error, "ModuleContextToRequestId");
		break;

            default:
                CSASSERT(FALSE);
                hr = E_HANDLE;
                _JumpError(hr, error, "unexpected policy/exit flags");
                break;
	}
    }

error:
    return(hr);
}


VOID
LogComError(
    OPTIONAL IN WCHAR const *pwszModuleDescription,
    IN WCHAR const *pwszMethod,
    IN HRESULT ErrCode,
    IN BOOL fException,
    IN ULONG_PTR ExceptionAddress,
    IN IID const *piid,
    IN DWORD dwIdEvent)
{
    BSTR bstrErrorMessage = NULL;
    WCHAR const *pwszStringErr = NULL;

    if (CERTLOG_ERROR <= g_dwLogLevel)
    {
        HRESULT hr;
        WCHAR const *apwsz[5];
        WCHAR awchr[cwcHRESULTSTRING];
        WCHAR awcAddress[2 + 2 * cwcDWORDSPRINTF];

        if (fException)
        {
            apwsz[3] = awcAddress;
	    wsprintf(awcAddress, L"0x%p", ExceptionAddress);
        }
        else
        {
            IErrorInfo *pErrorInfo = NULL;

            // Get the error info

            hr = GetErrorInfo(0, &pErrorInfo);
            if (S_OK == hr && NULL != pErrorInfo)
	    {
		GUID ErrorGuid;

		hr = pErrorInfo->GetGUID(&ErrorGuid);
		if (S_OK == hr && InlineIsEqualGUID(ErrorGuid, *piid))
		{
		    hr = pErrorInfo->GetDescription(&bstrErrorMessage);
		    if (S_OK == hr && NULL != bstrErrorMessage)
		    {
			myRegisterMemAlloc(bstrErrorMessage, -1, CSM_SYSALLOC);
		    }
		}
		SetErrorInfo(0, pErrorInfo);
		pErrorInfo->Release();
            }
            apwsz[3] = NULL != bstrErrorMessage? bstrErrorMessage : L"";
        }

	if (S_OK == ErrCode)
	{
	    if (!fException && NULL == bstrErrorMessage)
	    {
		goto error; // skip if no error, no exception & no com error
	    }

	    // This is the best generic fit for policy module initialization.
	    // Hopefully it's generic enough to not be too confusing.

	    ErrCode = CRYPT_E_NOT_FOUND;
	    _PrintError(hr, "Invented ErrCode");
	}

        apwsz[0] = NULL != pwszModuleDescription? pwszModuleDescription : L"";
        apwsz[1] = pwszMethod;

        // some errors like textual conversions.  no HRESULT pasted on here

	pwszStringErr = myGetErrorMessageText(ErrCode, FALSE);
        apwsz[2] = myHResultToStringRaw(awchr, ErrCode);
	apwsz[4] = pwszStringErr == NULL? L"" : pwszStringErr;

        hr = LogEvent(EVENTLOG_ERROR_TYPE, dwIdEvent, ARRAYSIZE(apwsz), apwsz);
        _PrintIfError(hr, "LogEvent");
    }

error:
    if (NULL != bstrErrorMessage)
    {
	SysFreeString(bstrErrorMessage);
    }
    if (NULL != pwszStringErr)
    {
	LocalFree(const_cast<WCHAR *>(pwszStringErr));
    }
}


VOID
LogPolicyError(
    IN HRESULT ErrCode,
    IN WCHAR const *pwszMethod,
    IN BOOL fException,
    IN ULONG_PTR ExceptionAddress)
{
    LogComError(
	    g_strPolicyDescription,
	    pwszMethod,
	    ErrCode,
	    fException,
	    ExceptionAddress,
	    &IID_ICertPolicy,
	    fException? MSG_E_POLICY_EXCEPTION : MSG_E_POLICY_ERROR);
}


VOID
LogExitError(
    IN HRESULT ErrCode,
    IN WCHAR const *pwszDescription,
    IN WCHAR const *pwszMethod,
    IN BOOL fException,
    IN ULONG_PTR ExceptionAddress)
{
    LogComError(
	    pwszDescription,
	    pwszMethod,
	    ErrCode,
	    fException,
	    ExceptionAddress,
	    &IID_ICertExit,
	    fException? MSG_E_EXIT_EXCEPTION : MSG_E_EXIT_ERROR);
}




HRESULT
PolicyInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    DISPATCHINTERFACE *pdiPolicy;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;


    // support installable modules
    CLSID clsidPolicy;
    LPOLESTR lpszProgID = NULL;

    DBGPRINT((DBG_SS_CERTSRVI, "PolicyInit: tid=%d\n", GetCurrentThreadId()));

    comClearError();
    __try
    {
    // get active module
    hr = myGetActiveModule(
                    NULL,
		    pwszSanitizedName,
		    TRUE,
		    0,
		    &lpszProgID,
		    &clsidPolicy);
    _LeaveIfError(hr, "myGetActiveModule");
    
    g_miPolicy.Initialize(
		lpszProgID, 
		&clsidPolicy, 
		ARRAYSIZE(s_acPolicyDispatch),
		s_apPolicyiid,
		s_acPolicyDispatch,
		g_adtPolicy);

    // free olestr
    CoTaskMemFree(lpszProgID);

    hr = g_miPolicy.SetConfig(pwszConfig);
    _LeaveIfError(hr, "SetConfig");

    hr = g_miPolicy.Setup(&pdiPolicy);

    // Don't complain if no class is registered.
    _LeaveIfError2(hr, "Setup", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = Policy_GetDescription(pdiPolicy, &g_strPolicyDescription);
    _PrintIfError(hr, "Policy_GetDescription");

    hr = Policy_Initialize(pdiPolicy, pwszConfig);
    _LeaveIfError(hr, "Policy_Initialize");

    g_fEnablePolicy = TRUE;	// we have a policy module loaded now

    hr = S_OK;

    CONSOLEPRINT1((
	DBG_SS_CERTSRV,
	"Policy Module Enabled (%ws)\n",
	g_strPolicyDescription));
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Initialize: Exception");
	fException = TRUE;
    }

//error:

    LogPolicyError(hr, L"PolicyInit", fException, ExceptionAddress);
    return(hr);
}



VOID
PolicyRelease(VOID)
{
    HRESULT hr;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;

    DBGPRINT((DBG_SS_CERTSRV, "PolicyRelease: tid=%d\n", GetCurrentThreadId()));

    comClearError();
    __try
    {
        // if we loaded a policy module
        if (g_fEnablePolicy)
        {
            DISPATCHINTERFACE diPolicy;
            
            hr = g_miPolicy.Remarshal(&diPolicy);
            _PrintIfError(hr, "Remarshal");
            
            if (hr == S_OK)
            {
                Policy_ShutDown(&diPolicy);
		g_miPolicy.Unmarshal(&diPolicy);
            }
            g_fEnablePolicy = FALSE;
        }

        if (NULL != g_strPolicyDescription)
        {
            SysFreeString(g_strPolicyDescription);
            g_strPolicyDescription = NULL;
        }
        
        g_miPolicy.TearDown();
        
    } 
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "ShutDown: Exception");
	fException = TRUE;
    }

    LogPolicyError(hr, L"PolicyRelease", fException, ExceptionAddress);
}


HRESULT
PolicyVerifyRequest(
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,
    IN BOOL fNewRequest,
    IN DWORD dwComContextIndex,
    OUT LPWSTR *ppwszDispositionMessage, // LocalAlloced.
    OUT DWORD *pVerifyStatus) // VR_PENDING || VR_INSTANT_OK || VR_INSTANT_BAD
{
    HRESULT hr;
    ULONG_PTR ExceptionAddress = NULL;
    DWORD rc;
    LONG Result;
    DISPATCHINTERFACE diPolicy;
    BOOL fMustRelease = FALSE;
    BSTR bstrDispositionDetail = NULL;
    CERTSRV_COM_CONTEXT *pComContext;

    comClearError();

    if (!g_fEnablePolicy)
    {
	hr = S_OK;
	rc = VR_INSTANT_OK;
	goto error;
    }
    rc = VR_INSTANT_BAD;

    hr = g_miPolicy.Remarshal(&diPolicy);
    _JumpIfError(hr, error, "Remarshal");

    fMustRelease = TRUE;

    pComContext = GetComContextFromIndex(dwComContextIndex);
    if (NULL == pComContext)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL com context");
    }
    pComContext->RequestId = RequestId;

    __try
    {
	hr = Policy_VerifyRequest(
			    &diPolicy,
			    pwszConfig,
			    ComContextToModuleContext(dwComContextIndex),
			    fNewRequest,
			    Flags,
			    &Result);
	_LeaveIfError(hr, "Policy_VerifyRequest");

	switch (Result)
	{
	    default:
		if (SUCCEEDED(Result))
		{
		    hr = E_INVALIDARG;
		    _LeaveError(Result, "Result");
		}
		// FALLTHROUGH

	    case VR_PENDING:
	    case VR_INSTANT_OK:
	    case VR_INSTANT_BAD:
		rc = Result;
		break;
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "VerifyRequest: Exception");
	LogPolicyError(hr, L"VerifyRequest", TRUE, ExceptionAddress);
    }
    pComContext->RequestId = 0;

error:

    // Errors will be logged at the coreVerifyRequest level

    if (NULL != ppwszDispositionMessage)
    {
        HRESULT hr2;
	IErrorInfo *pErrorInfo = NULL;

        *ppwszDispositionMessage = NULL;
        hr2 = GetErrorInfo(0, &pErrorInfo);
        if (S_OK == hr2 && NULL != pErrorInfo)
	{
	    GUID ErrorGuid;

	    hr2 = pErrorInfo->GetGUID(&ErrorGuid);
	    if (S_OK == hr2 && InlineIsEqualGUID(ErrorGuid, IID_ICertPolicy))
	    {
		hr2 = pErrorInfo->GetDescription(&bstrDispositionDetail);
		if (S_OK == hr2 && NULL != bstrDispositionDetail)
		{
		    myRegisterMemAlloc(bstrDispositionDetail, -1, CSM_SYSALLOC);
		    *ppwszDispositionMessage = (LPWSTR) LocalAlloc(
			LMEM_FIXED,
			SysStringByteLen(bstrDispositionDetail) + sizeof(WCHAR));

		    if (NULL != *ppwszDispositionMessage)
		    {
			wcscpy(*ppwszDispositionMessage, bstrDispositionDetail);
		    }
		    SysFreeString(bstrDispositionDetail);
		}
	    }
	    SetErrorInfo(0, pErrorInfo);
	    pErrorInfo->Release();
        }
    }

    if (fMustRelease)
    {
	g_miPolicy.Unmarshal(&diPolicy);
    }
    *pVerifyStatus = rc;
    return(hr);
}

typedef struct _EXITMOD
{
    MarshalInterface *pmi;
    BOOL              fEnabled;
    BSTR              strDescription;
    LONG	      EventMask;
} EXITMOD;

BOOL g_fEnableExit = FALSE;
EXITMOD *g_aExitMod = NULL;
DWORD g_cExitMod;
LONG g_ExitEventMask;
TCHAR g_wszRegKeyExitClsid[] = wszCLASS_CERTEXIT TEXT("\\Clsid");

VOID
ExitModRelease(
    OPTIONAL IN OUT EXITMOD *pExitMod)
{
    HRESULT hr;
    
    if (NULL != pExitMod)
    {
	MarshalInterface *pmiExit = pExitMod->pmi;

	if (NULL != pmiExit)
	{
	    __try
	    {
		pmiExit->TearDown();
	    }
	    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	    {
		_PrintIfError(hr, "TearDown");
	    }
	    delete pmiExit;
	    pExitMod->pmi = NULL;
	} 
	if (NULL != pExitMod->strDescription)
	{
	    SysFreeString(pExitMod->strDescription);
	    pExitMod->strDescription = NULL;
	}
    }
}

HRESULT
ExitModInit(
    IN WCHAR const *pwszProgId,
    IN CLSID const *pclsid,
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    EXITMOD *pExitMod = NULL;
    DISPATCHINTERFACE *pdiExit;
    MarshalInterface *pmiExit;
    CERTSRV_COM_CONTEXT ComContext;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;

    comClearError();
    __try
    {
    
    if (0 == g_cExitMod)
    {
	pExitMod = (EXITMOD *) LocalAlloc(LMEM_FIXED, sizeof(*g_aExitMod));
    }
    else
    {
	pExitMod = (EXITMOD *) LocalReAlloc(
				    g_aExitMod,
				    (g_cExitMod + 1) * sizeof(*g_aExitMod),
				    LMEM_MOVEABLE);
    }
    if (NULL == pExitMod)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, 0 == g_cExitMod? "LocalAlloc" : "LocalReAlloc");
    }
    g_aExitMod = pExitMod;
    pExitMod += g_cExitMod++;

    // Zero structure here because a previous failed Exit Module load may leave
    // garbage in leftover structure, causing LocalReAlloc to do nothing.

    ZeroMemory(pExitMod, sizeof(*pExitMod));

    pmiExit = new MarshalInterface;
    if (NULL == pmiExit)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new");
    }
    pExitMod->pmi = pmiExit;

    pmiExit->Initialize(
		    pwszProgId, 
		    pclsid, 
		    ARRAYSIZE(s_acExitDispatch),
		    s_apExitiid,
		    s_acExitDispatch,
		    g_adtExit);

    hr = pmiExit->SetConfig(pwszConfig);
    _JumpIfError(hr, error, "SetConfig");

    hr = pmiExit->Setup(&pdiExit);

    // Don't complain if no class is registered.
    _JumpIfError2(hr, error, "Setup", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    ComContext.iExitModActive = g_cExitMod - 1;
    g_pExitComContext = &ComContext;

    hr = Exit_Initialize(
		    pdiExit,
		    pExitMod->strDescription,
		    pwszConfig,
		    &pExitMod->EventMask);
    _JumpIfError(hr, error, "Exit_Initialize");

    pExitMod->fEnabled = TRUE;
    g_fEnableExit = TRUE;	// we have at least one exit module loaded now

    g_ExitEventMask |= pExitMod->EventMask;

    hr = Exit_GetDescription(pdiExit, &pExitMod->strDescription);
    _PrintIfError(hr, "Exit_GetDescription");

    hr = S_OK;

    CONSOLEPRINT3((
	DBG_SS_CERTSRV,
	"Exit Module[%d] Enabled: %x (%ws)\n",
	g_cExitMod,
	pExitMod->EventMask,
	pExitMod->strDescription));

    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Initialize: Exception");
	fException = TRUE;
    }

error:

    LogExitError(
	    hr,
	    pExitMod->strDescription,
	    L"ExitModeInit",
	    fException,
	    ExceptionAddress);

    if (S_OK != hr && NULL != pExitMod)
    {
	ExitModRelease(pExitMod);
	CSASSERT(0 != g_cExitMod);
	g_cExitMod--;
    }
    // reset
    g_pExitComContext = NULL;
    return(hr);
}


HRESULT
ExitModNotify(
    IN EXITMOD *pExitMod,
    IN LONG Event,
    IN LONG RequestId,
    IN DWORD dwComContextIndex)
{
    HRESULT hr;
    DISPATCHINTERFACE diExit;
    BOOL fMustRelease = FALSE;
    CERTSRV_COM_CONTEXT *pComContext;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;

    comClearError();
    __try
    {
    if (!pExitMod->fEnabled || 0 == (Event & pExitMod->EventMask))
    {
	hr = S_OK;
	goto error;
    }
    hr = pExitMod->pmi->Remarshal(&diExit);
    _JumpIfError(hr, error, "Remarshal");

    fMustRelease = TRUE;

    pComContext = GetComContextFromIndex(dwComContextIndex);
    if (NULL == pComContext)
    {
        hr = E_HANDLE;
        _JumpError(hr, error, "null com context");
    }
    pComContext->RequestId = RequestId;

    hr = Exit_Notify(
		&diExit,
		pExitMod->strDescription,
		Event,
		ComContextToModuleContext(dwComContextIndex));

    pComContext->RequestId = 0;

    if (S_OK != hr)
    {
	//_PrintError(hr, "Exit_Notify");
	goto error;
    }
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Notify: Exception");
	fException = TRUE;
    }

error:
    LogExitError(
	    hr,
	    pExitMod->strDescription,
	    L"Notify",
	    fException,
	    ExceptionAddress);

    if (fMustRelease)
    {
	pExitMod->pmi->Unmarshal(&diExit);
    }
    return(hr);
}


HRESULT
ExitInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    LPOLESTR pwszProgId = NULL;
    CLSID clsid;
    DWORD i;

    CSASSERT(NULL == g_aExitMod);
    CSASSERT(0 == g_cExitMod);
    CSASSERT(0 == g_ExitEventMask);
    CSASSERT(!g_fEnableExit);

    for (i = 0; ; i++)
    {
	if (NULL != pwszProgId)
	{
	    CoTaskMemFree(pwszProgId);
	    pwszProgId = NULL;
	}

	// get active module
	hr = myGetActiveModule(
                        NULL,
			pwszSanitizedName,
			FALSE,
			i,
			&pwszProgId,
			&clsid);
	_JumpIfError(hr, error, "myGetActiveModule");

	hr = ExitModInit(pwszProgId, &clsid, pwszConfig);
	_PrintIfError(hr, "ExitModInit");
    }
    hr = S_OK;
	
error:
    if (NULL != pwszProgId)
    {
	CoTaskMemFree(pwszProgId);
    }
    return(hr);
}


VOID
ExitRelease(VOID)
{
    HRESULT hr;

    ExitNotify(EXITEVENT_SHUTDOWN, 0, MAXDWORD);
    for ( ; 0 != g_cExitMod; g_cExitMod--)
    {
	ExitModRelease(&g_aExitMod[g_cExitMod - 1]);
    }
    
    if (g_aExitMod)
    {
        LocalFree(g_aExitMod);
        g_aExitMod = NULL;
    }
}


HRESULT
ExitNotify(
    IN LONG Event,
    IN LONG RequestId,
    IN DWORD dwComContextIndex)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    CERTSRV_COM_CONTEXT ComContext;
    CERTSRV_COM_CONTEXT *pComContext;
    BOOL fRegComContext = FALSE;

    if (MAXDWORD == dwComContextIndex)
    {
	ZeroMemory(&ComContext, sizeof(ComContext));
	pComContext = &ComContext;
        hr = RegisterComContext(pComContext, &dwComContextIndex);
        _JumpIfError(hr, error, "RegisterComContext");

        fRegComContext = TRUE;
    }
    else
    {
        pComContext = GetComContextFromIndex(dwComContextIndex);
        if (NULL == pComContext)
        {
            hr = E_HANDLE;
            _JumpError(hr, error, "null com context");
        }
    }

    CSASSERT(0 == (Event & (Event >> 1)));	// must be a single bit!
    if (!g_fEnableExit || 0 == (Event & g_ExitEventMask))
    {
	goto error;
    }
    for (
	pComContext->iExitModActive = 0;
	pComContext->iExitModActive < g_cExitMod;
	pComContext->iExitModActive++)
    {
	hr2 = ExitModNotify(
			&g_aExitMod[pComContext->iExitModActive],
			Event,
			RequestId,
			dwComContextIndex);
	if (S_OK == hr)
	{
	    hr = hr2;
	}
        _PrintIfError(hr2, "ExitModNotify");
    }

error:
    if (fRegComContext)
    {
        // context is used in local
        UnregisterComContext(&ComContext, dwComContextIndex);
    }
    else if (NULL != pComContext)
    {
        // return index
        pComContext->iExitModActive = 0;
    }
    return(hr);
}


HRESULT
ExitGetActiveModule(
    IN LONG Context,
    OUT MarshalInterface **ppmi)
{
    HRESULT hr;

    // This is for exit module only, it expects Context
    // to be 0. It will use g_pExitComContext instead of table

    // init
    *ppmi = NULL;

#if 0
    DWORD    dwIndex;
    hr = ModuleContextToComContextIndex(Context, &dwIndex);
    _JumpIfError(hr, error, "ModuleContextToComContextIndex");
    // return
    *ppmi = 
    g_aExitMod[g_pComContextTable[dwIndex].pComContext->iExitModActive].pmi;
#endif

    CSASSERT(0 == Context);
    CSASSERT(NULL != g_pExitComContext);
    if (0 != Context || NULL == g_pExitComContext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "unexpected exit context");
    }

    // return
    *ppmi = g_aExitMod[g_pExitComContext->iExitModActive].pmi;
    hr = S_OK;

error:
    return (hr);
}


HRESULT
ComGetClientInfo(
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OUT CERTSRV_COM_CONTEXT **ppComContext)
{
    HRESULT hr;

    *ppComContext = NULL;

    if (MAXDWORD == dwComContextIndex)
    {
	hr = ModuleContextToComContextIndex(Context, &dwComContextIndex);
	_JumpIfError(hr, error, "ModuleContextToComContextIndex");
    }
    *ppComContext = g_pComContextTable[dwComContextIndex].pComContext;
    hr = S_OK;

error:
    return(hr);
}


BSTR
ExitGetDescription(
    IN DWORD iExitMod)
{
    BSTR str = NULL;

    if (iExitMod < g_cExitMod)
    {
	str = g_aExitMod[iExitMod].strDescription;
    }
    return(str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\com.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       com.h
//
//--------------------------------------------------------------------------


class MarshalInterface
{
public:
    MarshalInterface(VOID) { m_pwszProgID = NULL; m_szConfig = NULL;}
    ~MarshalInterface(VOID) {}

    VOID Initialize(
	    IN WCHAR const *pwszProgID,
	    IN CLSID const *pclsid,
	    IN DWORD cver,
	    IN IID const * const *ppiid,	// cver elements
	    IN DWORD const *pcDispatch,		// cver elements
	    IN DISPATCHTABLE *adt);

    HRESULT Setup(
	    OUT DISPATCHINTERFACE **ppDispatchInterface);

    VOID TearDown(VOID);

    HRESULT Marshal(
	IN DISPATCHINTERFACE *pDispatchInterface);

    HRESULT Remarshal(
	OUT DISPATCHINTERFACE *pDispatchInterface);

    VOID Unmarshal(
	IN OUT DISPATCHINTERFACE *pDispatchInterface);

    HRESULT SetConfig(
        IN LPCWSTR pwszSanitizedName);

    LPCWSTR GetConfig() {return m_szConfig;}
    LPCWSTR GetProgID() {return m_pwszProgID;}

private:
    BOOL               m_fInitialized;
    LPWSTR             m_pwszProgID; 
    CLSID const       *m_pclsid;
    DWORD              m_cver;
    IID const * const *m_ppiid;		// cver elements
    DWORD const       *m_pcDispatch;	// cver elements
    DISPATCHTABLE     *m_adt;
    DWORD	       m_iiid;

    LPCWSTR            m_szConfig;

    BOOL               m_fIDispatch;
    DISPATCHINTERFACE  m_DispatchInterface;

    // GIT cookie
    DWORD              m_dwIFCookie;
};

extern MarshalInterface g_miPolicy;

HRESULT
ExitGetActiveModule(
    IN LONG                Context,
    OUT MarshalInterface **ppmi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\comtest.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        comtest.cpp
//
// Contents:    Cert Server COM interface test driver
//
// History:     20-Jan-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>

#include "csdisp.h"
#include "csprop.h"


#if DBG_COMTEST
BOOL
comTestCIPolicy(
    IN LONG Context,
    IN DWORD Flags)
{
    HRESULT hr;
    DISPATCHINTERFACE diCIPolicy;
    BSTR bstrReq = NULL;
    BSTR bstrCert = NULL;
    BOOL fMustRelease = FALSE;
    DATE Date;
    
    wprintf(L"\n");

    hr = CIPolicy_Init(Flags, &diCIPolicy);
    _JumpIfError(hr, error, "CIPolicy_Init");
    fMustRelease = TRUE;

    hr = CIPolicy_SetContext(&diCIPolicy, Context);
    _JumpIfError(hr, error, "CIPolicy_SetContext");

    hr = CIPolicy_GetRequestProperty(
			    &diCIPolicy,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrReq);
    _JumpIfError(hr, error, "CIPolicy_GetRequestProperty");

    wprintf(
	L"%d:CIPolicy_GetRequestProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrReq);


    hr = CIPolicy_GetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrCert);
    _JumpIfError(hr, error, "CIPolicy_GetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_GetCertificateProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrCert);

    hr = CIPolicy_SetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropSubjectLocality,
			    PROPTYPE_STRING,
			    L"coreSetPropPolicy_Locality");
    _JumpIfError(hr, error, "CIPolicy_SetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_SetCertificateProperty(%u, %ws, %ws) == %x\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	L"CIPolicy_SetCertificateProperty_Locality",
	hr);

    hr = CIPolicy_GetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropCertificateNotBeforeDate,
			    PROPTYPE_DATE,
			    (BSTR *) &Date);
    _JumpIfError(hr, error, "CIPolicy_GetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_GetCertificateProperty(%u, %ws) == %x (%f)\n",
	Flags,
	Context,
	g_wszPropCertificateNotBeforeDate,
	hr,
	Date);

    hr = CIPolicy_SetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropCertificateNotBeforeDate,
			    PROPTYPE_DATE,
			    (BSTR) &Date);
    _JumpIfError(hr, error, "CIPolicy_SetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_SetCertificateProperty(%u, %ws) == %x (%f)\n",
	Flags,
	Context,
	g_wszPropCertificateNotBeforeDate,
	hr,
	Date);

    Date += 1.5;	// Set validity period to 1.5 days.
    hr = CIPolicy_SetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropCertificateNotAfterDate,
			    PROPTYPE_DATE,
			    (BSTR) &Date);
    _JumpIfError(hr, error, "CIPolicy_SetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_SetCertificateProperty(%u, %ws) == %x (%f)\n",
	Flags,
	Context,
	g_wszPropCertificateNotAfterDate,
	hr,
	Date);

error:
    if (NULL != bstrReq)
    {
	SysFreeString(bstrReq);
    }
    if (NULL != bstrCert)
    {
	SysFreeString(bstrCert);
    }
    if (fMustRelease)
    {
	CIPolicy_Release(&diCIPolicy);
    }
    return(S_OK == hr);
}


BOOL
comTestCIExit(
    IN LONG Context,
    IN DWORD Flags)
{
    HRESULT hr;
    DISPATCHINTERFACE diCIExit;
    BSTR bstrReq = NULL;
    BSTR bstrCert = NULL;
    BOOL fMustRelease = FALSE;
    
    wprintf(L"\n");

    hr = CIExit_Init(Flags, &diCIExit);
    _JumpIfError(hr, error, "CIExit_Init");
    fMustRelease = TRUE;

    hr = CIExit_SetContext(&diCIExit, Context);
    _JumpIfError(hr, error, "CIExit_SetContext");

    hr = CIExit_GetRequestProperty(
			    &diCIExit,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrReq);
    _JumpIfError(hr, error, "CIExit_GetRequestProperty");

    wprintf(
	L"%d:CIExit_GetRequestProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrReq);


    hr = CIExit_GetCertificateProperty(
			    &diCIExit,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrCert);
    _JumpIfError(hr, error, "CIExit_GetCertificateProperty");

    wprintf(
	L"%d:CIExit_GetCertificateProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrCert);

error:
    if (NULL != bstrReq)
    {
	SysFreeString(bstrReq);
    }
    if (NULL != bstrCert)
    {
	SysFreeString(bstrCert);
    }
    if (fMustRelease)
    {
	CIExit_Release(&diCIExit);
    }
    return(S_OK == hr);
}


BOOL
ComTest(
    IN LONG Context)
{
    return(
	comTestCIPolicy(Context, DISPSETUP_COMFIRST) &&
	comTestCIPolicy(Context, DISPSETUP_COM) &&
	comTestCIPolicy(Context, DISPSETUP_IDISPATCH) &&
	comTestCIExit(Context, DISPSETUP_COMFIRST) &&
	comTestCIExit(Context, DISPSETUP_COM) &&
	comTestCIExit(Context, DISPSETUP_IDISPATCH));
}
#endif // DBG_COMTEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\db3.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db3.cpp
//
// Contents:    Cert Server Database interface implementation
//
// History:     13-June-97       larrys created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>

#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTSRV_DB3_CPP__


ICertDB *g_pCertDB = NULL;
BOOL g_fDBRecovered = FALSE;

WCHAR g_wszDatabase[MAX_PATH];
WCHAR g_wszLogDir[MAX_PATH];
WCHAR g_wszSystemDir[MAX_PATH];

const WCHAR g_wszCertSrvDotExe[] = L"certsrv.exe";
const int MAXDWORD_STRLEN = 11;

HRESULT
dbCheckRecoveryState(
    IN HKEY hkeyConfig,
    IN DWORD cSession,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir);

typedef struct _REGDBDIR
{
    WCHAR const *pwszRegName;
    BOOL	 fMustExist;
    WCHAR       *pwszBuf;
} REGDBDIR;

HRESULT dbGetRestoreDataDWORD(
    LPCWSTR pwszRestoreFile,
    LPCWSTR pwszName,
    DWORD* pdwData)
{
    WCHAR buffer[MAXDWORD_STRLEN]; // large enough to fit MAXDWORD decimal (4294967295)

    GetPrivateProfileString(
        wszRESTORE_SECTION,
        pwszName,
        L"",
        buffer,
        ARRAYSIZE(buffer),
        pwszRestoreFile);

    if(0==wcscmp(buffer, L""))
    {
        return S_FALSE;
    }

    *pdwData = _wtoi(buffer);

    return S_OK;
}

HRESULT dbGetRestoreDataLPWSZ(
    LPCWSTR pwszRestoreFile,
    LPCWSTR pwszName,
    LPWSTR* ppwszData)
{
    HRESULT hr = S_OK;
    WCHAR buffer[MAX_PATH+1];

    GetPrivateProfileString(
        wszRESTORE_SECTION,
        pwszName,
        L"",
        buffer,
        ARRAYSIZE(buffer),
        pwszRestoreFile);

    if(0==wcscmp(buffer, L""))
    {
        return S_FALSE;
    }

    *ppwszData = (LPWSTR)LocalAlloc(LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(buffer)+1));
    _JumpIfAllocFailed(*ppwszData, error);

    wcscpy(*ppwszData, buffer);

error:
    return hr;
}

HRESULT dbGetRestoreDataMULTISZ(
    LPCWSTR pwszRestoreFile,
    LPCWSTR pwszName,
    LPWSTR *ppwszData,
    DWORD *pcbData)
{
   HRESULT hr = S_OK;
   WCHAR buffer[MAX_PATH+1];
   int cData;
   LPWSTR pwszFullName = NULL;
   DWORD cbData = 0;
   LPWSTR pwszData = NULL;
   WCHAR *pwszCrt = NULL; // no free

   pwszFullName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
       sizeof(WCHAR)* 
              (wcslen(pwszName)+
               wcslen(wszRESTORE_NEWLOGSUFFIX)+
               MAXDWORD_STRLEN+1));
   _JumpIfAllocFailed(pwszFullName, error);

   wcscpy(pwszFullName, L"");

   for(cbData=0, cData = 0;; cData++)
   {
       wsprintf(pwszFullName, L"%s%d", pwszName, cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

        if(0==wcscmp(buffer, L""))
        {
            if(0==cData)
            {
                hr = S_FALSE;
                _JumpErrorStr(hr, error, "no restore data", pwszRestoreFile);
            }
            else
            {
                break;
            }
        }

        cbData += wcslen(buffer)+1;

       wsprintf(pwszFullName, L"%s%s%d", pwszName, wszRESTORE_NEWLOGSUFFIX, 
           cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

        if(0==wcscmp(buffer, L""))
        {
            hr = ERROR_INVALID_DATA;
            _JumpErrorStr(hr, error, 
                "restore file contains inconsistent data", pwszRestoreFile);
        }

        cbData += wcslen(buffer)+1;
   }

   cbData++; // trailing zero
   cbData *= sizeof(WCHAR);

   pwszData = (LPWSTR)LocalAlloc(LMEM_FIXED, cbData);
   _JumpIfAllocFailed(pwszData, error);

   for(pwszCrt=pwszData, cData = 0;; cData++)
   {
       wsprintf(pwszFullName, L"%s%d", pwszName, cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

       if(0==wcscmp(buffer, L""))
       {
           break;
       }

       wcscpy(pwszCrt, buffer);
       pwszCrt += wcslen(buffer)+1;

       wsprintf(pwszFullName, L"%s%s%d", pwszName, wszRESTORE_NEWLOGSUFFIX, 
           cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

       wcscpy(pwszCrt, buffer);
       pwszCrt += wcslen(buffer)+1;
   }

   *pwszCrt = L'\0';

   *ppwszData = pwszData;
   *pcbData = cbData;

error:
   LOCAL_FREE(pwszFullName);
   if(S_OK!=hr)
   {
       LOCAL_FREE(pwszData);
   }
   return hr;
}

HRESULT dbRestoreRecoveryStateFromFile(LPCWSTR pwszLogDir)
{
    HRESULT hr = S_OK;
    LPWSTR pwszRestoreFile = NULL;
    WCHAR buffer[256];
    DWORD dwRestoreMapCount, 
        dwRegLowLogNumber,
        dwRegHighLogNumber, 
        dwDatabaseRecovered;
    LPWSTR pwszRestoreMap = NULL;
    DWORD cbRestoreMap = 0;
    LPWSTR pwszPath = NULL;
    HKEY hkey = NULL;
    DWORD dwDisposition;
    HKEY hkeyRestore = NULL;
    BOOL fDatabaseRecovered;

    LPWSTR pwszBackupLogDir = NULL;
    LPWSTR pwszCheckpointFile = NULL;
    LPWSTR pwszLogPath = NULL;

    CSASSERT(pwszLogDir);

    pwszRestoreFile = (LPWSTR)LocalAlloc(LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(pwszLogDir)+wcslen(wszRESTORE_FILENAME)+2));
    _JumpIfAllocFailed(pwszRestoreFile, error);

    wcscpy(pwszRestoreFile, pwszLogDir);
    wcscat(pwszRestoreFile, L"\\");
    wcscat(pwszRestoreFile, wszRESTORE_FILENAME);

    // is there a restore state file?
    if(-1 != GetFileAttributes(pwszRestoreFile))
    {
        // check first if a restore is in progress
        GetPrivateProfileString(
            wszRESTORE_SECTION,
            wszREGRESTORESTATUS,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

        if(wcscmp(buffer, L""))
        {
            // restore in progress, bail
            hr = _wtoi(buffer);
            _JumpError(hr, error, "A restore is in progress");
        }

        hr = myRegOpenRelativeKey(
                            NULL,
                            L"",
                            RORKF_CREATESUBKEYS,
                            &pwszPath,
                            NULL,           // ppwszName
                            &hkey);
        _JumpIfError(hr, error, "myRegOpenRelativeKey");


        hr = RegCreateKeyEx(
                        hkey,
                        wszREGKEYRESTOREINPROGRESS,
                        0,                  // Reserved
                        NULL,               // lpClass
                        0,                  // dwOptions
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkeyRestore,
                        &dwDisposition);
        _JumpIfErrorStr(hr, error, "RegCreateKeyEx", wszREGKEYRESTOREINPROGRESS);

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGRESTOREMAPCOUNT,
            &dwRestoreMapCount);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGRESTOREMAPCOUNT not found" );

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGLOWLOGNUMBER,
            &dwRegLowLogNumber);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGLOWLOGNUMBER not found" );

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGHIGHLOGNUMBER,
            &dwRegHighLogNumber);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGHIGHLOGNUMBER not found" );

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGDATABASERECOVERED,
            &dwDatabaseRecovered);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGDATABASERECOVERED not found" );

        fDatabaseRecovered = dwDatabaseRecovered?TRUE:FALSE;

        hr = dbGetRestoreDataLPWSZ(
            pwszRestoreFile,
            wszREGBACKUPLOGDIRECTORY,
            &pwszBackupLogDir);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataLPWSZ", wszREGBACKUPLOGDIRECTORY );


        hr = dbGetRestoreDataLPWSZ(
            pwszRestoreFile,
            wszREGCHECKPOINTFILE,
            &pwszCheckpointFile);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataLPWSZ", wszREGCHECKPOINTFILE );


        hr = dbGetRestoreDataLPWSZ(
            pwszRestoreFile,
            wszREGLOGPATH,
            &pwszLogPath);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataLPWSZ", wszREGLOGPATH );


        hr = dbGetRestoreDataMULTISZ(
            pwszRestoreFile,
            wszREGRESTOREMAP,
            &pwszRestoreMap,
            &cbRestoreMap);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataDWORD", L"wszRESTOREMAP");

       hr = RegSetValueEx(
                       hkeyRestore,
                       wszREGRESTOREMAPCOUNT,
                       0,
                       REG_DWORD,
                       (BYTE *) &dwRestoreMapCount,
                       sizeof(DWORD));
       _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGRESTOREMAPCOUNT);

       hr = RegSetValueEx(
                       hkeyRestore,
                       wszREGLOWLOGNUMBER,
                       0,
                       REG_DWORD,
                       (BYTE *) &dwRegLowLogNumber,
                       sizeof(DWORD));
       _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGLOWLOGNUMBER);

       hr = RegSetValueEx(
                       hkeyRestore,
                       wszREGHIGHLOGNUMBER,
                       0,
                       REG_DWORD,
                       (BYTE *) &dwRegHighLogNumber,
                       sizeof(DWORD));
       _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGHIGHLOGNUMBER);

        hr = RegSetValueEx(
                        hkeyRestore,
                        wszREGDATABASERECOVERED,
                        0,
                        REG_BINARY,
                        (BYTE *) &fDatabaseRecovered,
                        sizeof(BOOLEAN));
        _JumpIfError(hr, error, "RegSetValueEx");

        if(pwszBackupLogDir)
        {
            hr = SetRegistryLocalPathString(
                                        hkeyRestore,
                                        wszREGBACKUPLOGDIRECTORY,
                                        pwszBackupLogDir);
            _JumpIfErrorStr(hr, error, "SetRegistryLocalPathString", 
                wszREGBACKUPLOGDIRECTORY);
        }

        if(pwszCheckpointFile)
        {
            hr = SetRegistryLocalPathString(
                                        hkeyRestore,
                                        wszREGCHECKPOINTFILE,
                                        pwszCheckpointFile);
            _JumpIfErrorStr(hr, error, "SetRegistryLocalPathString", 
                wszREGCHECKPOINTFILE);
        }

        if(pwszLogPath)
        {
            hr = SetRegistryLocalPathString(
                                        hkeyRestore,
                                        wszREGLOGPATH,
                                        pwszLogPath);
            _JumpIfErrorStr(hr, error, "SetRegistryLocalPathString", 
               wszREGCHECKPOINTFILE);
        }

        if(pwszRestoreMap)
        {
            hr = RegSetValueEx(
                hkeyRestore,
                wszREGRESTOREMAP,
                0,
                REG_MULTI_SZ,
                (BYTE *) pwszRestoreMap,
                cbRestoreMap);
            _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGRESTOREMAP);
        }

        if(!DeleteFile(pwszRestoreFile))
        {
            _PrintError(myHLastError(), "DeleteFile restore file");
        }
    }
    else
    {
        hr = myHLastError();
        // no restore state file OK
        if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            hr = S_OK;
        _JumpIfErrorStr(hr, error, "GetFileAttributes", pwszRestoreFile);
    }

error:
    
    LOCAL_FREE(pwszRestoreFile);
    LOCAL_FREE(pwszRestoreMap);
    LOCAL_FREE(pwszPath);
    LOCAL_FREE(pwszBackupLogDir);
    LOCAL_FREE(pwszCheckpointFile);
    LOCAL_FREE(pwszLogPath);
    if(hkey)
    {
        RegCloseKey(hkey);
    }
    if(hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    return hr;
}


//+--------------------------------------------------------------------------
// DB file storage locations:
//
//   wszREGDBDIRECTORY:
//	Your Name.EDB		from csregstr.h: wszDBFILENAMEEXT .edb
//
//   wszREGDBLOGDIRECTORY:
//	EDB.log			from csregstr.h: wszDBBASENAMEPARM edb
//	EDB00001.log		from csregstr.h: wszDBBASENAMEPARM edb
//	EDB00002.log		from csregstr.h: wszDBBASENAMEPARM edb
//	res1.log
//	res2.log
//
//   wszREGDBSYSDIRECTORY:
//	EDB.chk			from csregstr.h: wszDBBASENAMEPARM edb
//
//   wszREGDBTEMPDIRECTORY:
//	tmp.edb			fixed name
//
//
//   wszREGDBOPTIONALFLAGS:
//      wszFlags                CDBOPEN_CIRCULARLOGGING
//      
// Backed up files:
//   DB files (Attachments):
//	wszREGDBDIRECTORY:	Your Name.EDB -- CSBFT_CERTSERVER_DATABASE
//
//   Log files:
//	wszREGDBLOGDIRECTORY:	EDB00001.log -- CSBFT_LOG
//	wszREGDBLOGDIRECTORY:	EDB00002.log -- CSBFT_LOG
//	wszREGDBDIRECTORY:	Your Name.pat -- CSBFT_PATCH_FILE
//
//+--------------------------------------------------------------------------


///// initialize database access

#define DBSESSIONCOUNTMIN	4
#define DBSESSIONCOUNTMAX	1024

HRESULT
DBOpen(
    WCHAR const *pwszSanitizedName)
{
    HRESULT hr = S_OK;
    DWORD cb;
    DWORD i;
    DWORD dwState;
    DWORD SessionCount;
    HKEY hkey = NULL;
    WCHAR wszTempDir[MAX_PATH];
    DWORD dwOptionalFlags;
    BOOL fRestarted;

    REGDBDIR adbdir[] =
    {
	{ wszREGDBDIRECTORY,        TRUE,  g_wszDatabase, },
	{ wszREGDBLOGDIRECTORY,     TRUE,  g_wszLogDir, },
	{ wszREGDBSYSDIRECTORY,     TRUE,  g_wszSystemDir, },
	{ wszREGDBTEMPDIRECTORY,    TRUE,  wszTempDir, },
    };

    // check machine setup status

    hr = GetSetupStatus(NULL, &dwState);
    _JumpIfError(hr, error, "GetSetupStatus");

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, g_wszRegKeyConfigPath, &hkey);
    _JumpIfError(hr, error, "RegOpenKey(CAName)");

    // get info from registry

    for (i = 0; i < ARRAYSIZE(adbdir); i++)
    {
	cb = sizeof(WCHAR) * MAX_PATH;
	hr = RegQueryValueEx(
			hkey,
			adbdir[i].pwszRegName,
			NULL,
			NULL,
			(BYTE *) adbdir[i].pwszBuf,
			&cb);
	if ((HRESULT) ERROR_FILE_NOT_FOUND == hr && !adbdir[i].fMustExist)
	{
	    adbdir[i].pwszBuf[0] = L'\0';
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "RegQueryValueEx(DB*Dir)");
    }
    wcscat(g_wszDatabase, L"\\");
    wcscat(g_wszDatabase, pwszSanitizedName);
    wcscat(g_wszDatabase, wszDBFILENAMEEXT);

    cb = sizeof(SessionCount);
    hr = RegQueryValueEx(
		    hkey,
		    wszREGDBSESSIONCOUNT,
		    NULL,
		    NULL,
		    (BYTE *) &SessionCount,
		    &cb);
    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "RegQueryValueEx", wszREGDBSESSIONCOUNT);
	SessionCount = DBSESSIONCOUNTDEFAULT;
    }
    if (DBSESSIONCOUNTMIN > SessionCount)
    {
	SessionCount = DBSESSIONCOUNTMIN;
    }
    if (DBSESSIONCOUNTMAX < SessionCount)
    {
	SessionCount = DBSESSIONCOUNTMAX;
    }

    cb = sizeof(dwOptionalFlags);
    hr = RegQueryValueEx(
		    hkey,
		    wszREGDBOPTIONALFLAGS,
		    NULL,
		    NULL,
		    (BYTE *) &dwOptionalFlags,
		    &cb);
    if (S_OK != hr)
    {
	//_PrintErrorStr(hr, "RegQueryValueEx", wszREGDBOPTIONALFLAGS);
	dwOptionalFlags = 0;
    }


    hr = dbCheckRecoveryState(
			hkey,
			2,			// cSession
			g_wszCertSrvDotExe,	// pwszEventSource
			g_wszLogDir,		// pwszLogDir
			g_wszSystemDir,		// pwszSystemDir
			wszTempDir);		// pwszTempDir
    _JumpIfError(hr, error, "dbCheckRecoveryState");


    CONSOLEPRINT1((DBG_SS_CERTSRV, "Opening Database %ws\n", g_wszDatabase));

    __try
    {
	DWORD dwFlags = 0;

	hr = CoCreateInstance(
			   CLSID_CCertDB,
			   NULL,               // pUnkOuter
			   CLSCTX_INPROC_SERVER,
			   IID_ICertDB,
			   (VOID **) &g_pCertDB);
	_LeaveIfError(hr, "CoCreateInstance(ICertDB)");

	if (g_fCreateDB || (SETUP_CREATEDB_FLAG & dwState))
	{
	    dwFlags |= CDBOPEN_CREATEIFNEEDED;
	}
	if (dwOptionalFlags & CDBOPEN_CIRCULARLOGGING)
	{
	    dwFlags |= CDBOPEN_CIRCULARLOGGING;
	}

	//only perform Hash if the auditing is enabled

	if (AUDIT_FILTER_STARTSTOP & g_dwAuditFilter)
	{
	    hr = ComputeMAC(g_wszDatabase, &g_pwszDBFileHash);
	
	    // db file does not exist when starting the CA first time

	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
	    {
		_PrintErrorStr(hr, "Database file not found, can't calculate hash", g_wszDatabase);
		hr = S_OK;
	    }
	    _LeaveIfErrorStr(hr, "ComputeMAC", g_wszDatabase);
	}

	// S_FALSE means a DB schema change was made that requires a restart
	// to take effect.  Open the DB a second time if S_FALSE is returned.

	fRestarted = FALSE;
	while (TRUE)
	{
	    hr = g_pCertDB->Open(
			    dwFlags,		// Flags
			    SessionCount,	// cSession
			    g_wszCertSrvDotExe,	// pwszEventSource
			    g_wszDatabase,	// pwszDBFile
			    g_wszLogDir,	// pwszLogDir
			    g_wszSystemDir,	// pwszSystemDir
			    wszTempDir);	// pwszTempDir
	    if (S_OK == hr)
	    {
		break;
	    }
	    if (S_FALSE == hr && fRestarted)
	    {
		_PrintError(hr, "Open");
		break;
	    }
	    if (S_FALSE != hr)
	    {
		_LeaveError(hr, "Open");
	    }
	    hr = g_pCertDB->ShutDown(0);
            _PrintIfError(hr, "DB ShutDown");

	    fRestarted = TRUE;
	}
	if (SETUP_CREATEDB_FLAG & dwState)
	{
	    hr = SetSetupStatus(NULL, SETUP_CREATEDB_FLAG, FALSE);
	    _LeaveIfError(hr, "SetSetupStatus");
	}
	hr = S_OK;
	CONSOLEPRINT0((DBG_SS_CERTSRV, "Database open\n"));
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (S_OK != hr)
    {
        if (NULL != g_pCertDB)
        {
            g_pCertDB->Release();
            g_pCertDB = NULL;
        }
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(hr);
}


HRESULT
DBShutDown(
    IN BOOL fPendingNotify)
{
    HRESULT hr = S_OK;

    if (NULL != g_pCertDB)
    {
	hr = g_pCertDB->ShutDown(fPendingNotify? CDBSHUTDOWN_PENDING : 0);
	if (!fPendingNotify)
	{
	    g_pCertDB->Release();
	    g_pCertDB = NULL;
	}
    }
    return(hr);
}


HRESULT
dbRecoverAfterRestore(
    IN DWORD cSession,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir,
    IN WCHAR const *pwszCheckPointFile,
    IN WCHAR const *pwszLogPath,
    IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    IN WCHAR const *pwszBackupLogPath,
    IN DWORD genLow,
    IN DWORD genHigh)
{
    HRESULT hr;
    ICertDBRestore *pCertDBRestore = NULL;

    __try
    {
	WCHAR *apwsz[2];

	hr = CoCreateInstance(
			   CLSID_CCertDBRestore,
			   NULL,               // pUnkOuter
			   CLSCTX_INPROC_SERVER,
			   IID_ICertDBRestore,
			   (VOID **) &pCertDBRestore);
	_LeaveIfError(hr, "CoCreateInstance(ICertDBRestore)");

	hr = pCertDBRestore->RecoverAfterRestore(
					    cSession,
					    pwszEventSource,
					    pwszLogDir,
					    pwszSystemDir,
					    pwszTempDir,
					    pwszCheckPointFile,
					    pwszLogPath,
					    rgrstmap,
					    crstmap,
					    pwszBackupLogPath,
					    genLow,
					    genHigh);
	_LeaveIfError(hr, "RecoverAfterRestore");

	apwsz[0] = wszREGDBLASTFULLBACKUP;
	apwsz[1] = wszREGDBLASTINCREMENTALBACKUP;
	hr = CertSrvSetRegistryFileTimeValue(
					TRUE,
					wszREGDBLASTRECOVERY,
					ARRAYSIZE(apwsz),
					apwsz);
	_PrintIfError(hr, "CertSrvSetRegistryFileTimeValue");
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (NULL != pCertDBRestore)
    {
	pCertDBRestore->Release();
    }
    return(hr);
}


HRESULT
dbPerformRecovery(
    IN DWORD cSession,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir,
    IN WCHAR const *pwszCheckPointFile,
    IN WCHAR const *pwszLogPath,
    IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    IN WCHAR const *pwszBackupLogPath,
    IN unsigned long genLow,
    IN unsigned long genHigh,
    IN OUT BOOLEAN *pfRecoverJetDatabase)
{
    HRESULT hr = S_OK;

    // Call into JET to let it munge the databases.
    // Note that the JET interpretation of LogPath and BackupLogPath is
    // totally wierd, and we want to pass in LogPath to both parameters.

    if (!*pfRecoverJetDatabase)
    {
	hr = dbRecoverAfterRestore(
				cSession,
				pwszEventSource,
				pwszLogDir,
				pwszSystemDir,
				pwszTempDir,
				pwszCheckPointFile,
				pwszLogPath,
				rgrstmap,
				crstmap,
				pwszBackupLogPath,
				genLow,
				genHigh);
	_JumpIfError(hr, error, "dbRecoverAfterRestore");
    }

    // Ok, we were able to recover the database.  Let the other side of the
    // API know about it so it can do something "reasonable".

    *pfRecoverJetDatabase = TRUE;

    // Mark the DB as a restored version - Add any external notification here

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// dbCheckRecoveryState -- recover a database after a restore if necessary.
//
// Parameters:
// pwszParametersRoot - the root of the parameters section for the service in
//     the registry.
//
// Returns: HRESULT - S_OK if successful; error code if not.
//
// The NTBACKUP program will place a key at the location:
// $(pwszParametersRoot)\Restore in Progress
//
// This key contains the following values:
// BackupLogPath - The full path for the logs after a backup
// CheckPointFilePath - The full path for the path that contains the checkpoint
// *HighLogNumber - The maximum log file number found.
// *LowLogNumber - The minimum log file number found.
// LogPath - The current path for the logs.
// JET_RstMap - Restore map for database - this is a REG_MULTISZ, where odd
//    entries go into the pwszDatabase field, and the even entries go into the
//    pwszNewDatabase field of a JET_RstMap
// *JET_RstMap Size - The number of entries in the restoremap.
//
// * - These entries are REG_DWORD's.  All others are REG_SZ's (except where
//     mentioned).
//---------------------------------------------------------------------------

HRESULT
dbCheckRecoveryState(
    IN HKEY hkeyConfig,
    IN DWORD cSession,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir)
{
    HRESULT hr;
    HKEY hkeyRestore = NULL;
    DWORD cb;
    WCHAR wszCheckPointFilePath[MAX_PATH];
    WCHAR wszBackupLogPath[MAX_PATH];
    WCHAR wszLogPath[MAX_PATH];
    WCHAR *pwszCheckPointFilePath;
    WCHAR *pwszBackupLogPath;
    WCHAR *pwszLogPath;
    WCHAR *pwszRestoreMap = NULL;
    CSEDB_RSTMAPW *pRstMap = NULL;
    LONG cRstMap;
    LONG i;
    DWORD genLow;
    DWORD genHigh;
    WCHAR *pwsz;
    DWORD dwType;
    HRESULT hrRestoreError;
    BOOLEAN fDatabaseRecovered = FALSE;
    WCHAR wszActiveLogPath[MAX_PATH];

    hr = dbRestoreRecoveryStateFromFile(pwszLogDir);
    _JumpIfError(hr, error, "dbRestoreRecoveryStateFromFile");

    
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, wszREGKEYCONFIGRESTORE, &hkeyRestore);
    if (S_OK != hr)
    {
	// We want to ignore file_not_found - it is ok.

	if (hr == ERROR_FILE_NOT_FOUND)
	{
	    hr = S_OK;
	}
	_PrintIfError(hr, "RegOpenKey");
	goto error;
    }

    CONSOLEPRINT0((DBG_SS_CERTSRV, "Started Database Recovery\n"));

    // If there's a restore in progress, then fail to perform any other
    // restore operations.

    dwType = REG_DWORD;
    cb = sizeof(DWORD);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTORESTATUS,
		    0,
		    &dwType,
		    (BYTE *) &hrRestoreError,
		    &cb);
    if (S_OK == hr)
    {
	hr = hrRestoreError;
	_JumpError(hr, error, "hrRestoreError");
    }

    cb = sizeof(wszActiveLogPath);
    hr = RegQueryValueEx(
		    hkeyConfig,
		    wszREGDBLOGDIRECTORY,
		    NULL,
		    NULL,
		    (BYTE *) wszActiveLogPath,
		    &cb);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGDBLOGDIRECTORY);

    // We have now opened the restore-in-progress key.  This means that we have
    // something to do now.  Find out what it is.  First, let's get the backup
    // log file path.

    dwType = REG_SZ;

    cb = sizeof(wszBackupLogPath);
    pwszBackupLogPath = wszBackupLogPath;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGBACKUPLOGDIRECTORY,
		    0,
		    &dwType,
		    (BYTE *) wszBackupLogPath,
		    &cb);
    if (S_OK != hr)
    {
	if (hr != ERROR_FILE_NOT_FOUND)
	{
	    _JumpError(hr, error, "RegQueryValueEx");
	}
	pwszBackupLogPath = NULL;
    }

    // Then, the checkpoint file path.

    cb = sizeof(wszCheckPointFilePath);
    pwszCheckPointFilePath = wszCheckPointFilePath;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGCHECKPOINTFILE,
		    0,
		    &dwType,
		    (BYTE *) wszCheckPointFilePath,
		    &cb);
    if (S_OK != hr)
    {
	if (hr != ERROR_FILE_NOT_FOUND)
	{
	    _JumpError(hr, error, "RegQueryValueEx");
	}
	pwszCheckPointFilePath = NULL;
    }

    // Then, the Log path.

    cb = sizeof(wszLogPath);
    pwszLogPath = wszLogPath;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGLOGPATH,
		    0,
		    &dwType,
		    (BYTE *) wszLogPath,
		    &cb);
    if (S_OK != hr)
    {
	if ((HRESULT) ERROR_FILE_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "RegQueryValueEx");
	}
	pwszLogPath = NULL;
    }

    // Then, the low log number.

    dwType = REG_DWORD;
    cb = sizeof(genLow);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGLOWLOGNUMBER,
		    0,
		    &dwType,
		    (BYTE *) &genLow,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");

    // And, the high log number.

    cb = sizeof(genHigh);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGHIGHLOGNUMBER,
		    0,
		    &dwType,
		    (BYTE *) &genHigh,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");

    // Now determine if we had previously recovered the database.

    dwType = REG_BINARY;
    cb = sizeof(fDatabaseRecovered);

    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGDATABASERECOVERED,
		    0,
		    &dwType,
		    &fDatabaseRecovered,
		    &cb);
    if (S_OK != hr && (HRESULT) ERROR_FILE_NOT_FOUND != hr)
    {
	// If there was an error other than "value doesn't exist", bail.

	_JumpError(hr, error, "RegQueryValueEx");
    }

    // Now the tricky one.  We want to get the restore map.
    // First we figure out how big it is.

    dwType = REG_DWORD;
    cb = sizeof(cRstMap);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTOREMAPCOUNT,
		    0,
		    &dwType,
		    (BYTE *) &cRstMap,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");

    pRstMap = (CSEDB_RSTMAPW *) LocalAlloc(
					LMEM_FIXED,
					sizeof(CSEDB_RSTMAPW) * cRstMap);
    if (NULL == pRstMap)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // First find out how much memory is needed to hold the restore map.

    dwType = REG_MULTI_SZ;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTOREMAP,
		    0,
		    &dwType,
		    NULL,
		    &cb);
    if (S_OK != hr && (HRESULT) ERROR_MORE_DATA != hr)
    {
	_JumpError(hr, error, "RegQueryValueEx");
    }

    pwszRestoreMap = (WCHAR *) LocalAlloc(LMEM_FIXED, cb + 2 * sizeof(WCHAR));
    if (NULL == pwszRestoreMap)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTOREMAP,
		    0,
		    &dwType,
		    (BYTE *) pwszRestoreMap,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");
    
    pwszRestoreMap[cb / sizeof(WCHAR)] = L'\0';
    pwszRestoreMap[cb / sizeof(WCHAR) + 1] = L'\0';

    pwsz = pwszRestoreMap;
    for (i = 0; i < cRstMap; i++)
    {
	if (L'\0' == *pwsz)
	{
	    break;
	}
	pRstMap[i].pwszDatabaseName = pwsz;
	pwsz += wcslen(pwsz) + 1;

	if (L'\0' == *pwsz)
	{
	    break;
	}
	pRstMap[i].pwszNewDatabaseName = pwsz;
	pwsz += wcslen(pwsz) + 1;
    }
    if (i < cRstMap || L'\0' != *pwsz)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Restore Map");
    }

    {
        CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_RESTORESTART, g_dwAuditFilter);
        hr = event.Report();
        _JumpIfError(hr, error, "CAuditEvent::Report");
    }

    hr = dbPerformRecovery(
		cSession,
		pwszEventSource,
		pwszLogDir,
		pwszSystemDir,
		pwszTempDir,
		pwszCheckPointFilePath,
		NULL != pwszLogPath? pwszLogPath : wszActiveLogPath,
		pRstMap,
		cRstMap,
		NULL != pwszBackupLogPath? pwszBackupLogPath : wszActiveLogPath,
		genLow,
		genHigh,
		&fDatabaseRecovered);
    if (S_OK != hr)
    {
	// The recovery failed.  If recovering the database succeeded, flag it
	// in the registry so we don't try again.  Ignore RegSetValueEx errors,
	// because the recovery error is more important.

	RegSetValueEx(
		    hkeyRestore,
		    wszREGDATABASERECOVERED,
		    0,
		    REG_BINARY,
		    (BYTE *) &fDatabaseRecovered,
		    sizeof(fDatabaseRecovered));
	_JumpError(hr, error, "dbPerformRecovery");
    }

    {
        CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_RESTOREEND, g_dwAuditFilter);
        hr = event.Report();
        _JumpIfError(hr, error, "CAuditEvent::Report");
    }

    CONSOLEPRINT0((DBG_SS_CERTSRV, "Completed Database Recovery\n"));

    g_fDBRecovered = TRUE;

    // Ok, we're all done.  We can now delete the key, since we're done
    // with it.

    RegCloseKey(hkeyRestore);
    hkeyRestore = NULL;

    hr = RegDeleteKey(HKEY_LOCAL_MACHINE, wszREGKEYCONFIGRESTORE);
    _JumpIfError(hr, error, "RegDeleteKey");

error:
    if (NULL != pwszRestoreMap)
    {
	LocalFree(pwszRestoreMap);
    }
    if (NULL != pRstMap)
    {
	LocalFree(pRstMap);
    }
    if (NULL != hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\csext.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csext.h
//
// Contents:    Cert Server globals
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CSEXT_H__
#define __CSEXT_H__

#include "certacl.h"

#ifndef SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE

// Temporary define audit events here

#define SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE   ((ULONG)0x00000321L)
#define SE_AUDITID_CERTSRV_PUBLISHCACERT         ((ULONG)0x0000031fL)

#endif // SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE

// privately used access bit to check for local administrator rights
#define CA_ACCESS_LOCALADMIN 0x00008000
// privately used access bit to trigger a denied audit event
#define CA_ACCESS_DENIED     0x00004000

// Each certificate handler must export the following functions.

#define CMS_CRLPUB_PERIOD	(60*1000)	// 60 seconds (in milliseconds)
//#define CMS_CRLPUB_PERIOD	(60*60*1000)	// 60 minutes (in milliseconds)

typedef struct _CERTSRV_COM_CONTEXT
{
    BOOL	 fInRequestGroup;
    HANDLE	 hAccessToken;
    DWORD	 RequestId;
    DWORD	 iExitModActive;
    WCHAR	*pwszUserDN;
} CERTSRV_COM_CONTEXT;


typedef struct _CERTSRV_RESULT_CONTEXT
{
    DWORD		*pdwRequestId;
    DWORD		 dwFlagsTop;
    BOOL		 fTransactionId;
    DWORD		 dwTransactionId;
    BYTE		*pbSenderNonce;
    DWORD		 cbSenderNonce;
    BOOL		 fKeyArchived;
    BOOL		 fRenewal;
    BOOL		 fEnrollOnBehalfOf;
    BYTE		*pbKeyHashIn;
    DWORD		 cbKeyHashIn;
    BYTE		*pbKeyHashOut;
    DWORD		 cbKeyHashOut;
    DWORD		*pdwDisposition;
    CERTTRANSBLOB	*pctbDispositionMessage;
    CERTTRANSBLOB	*pctbCert;
    CERTTRANSBLOB	*pctbCertChain;
    CERTTRANSBLOB	*pctbFullResponse;
} CERTSRV_RESULT_CONTEXT;

VOID ReleaseResult(IN OUT CERTSRV_RESULT_CONTEXT *pResult);


// Certification Authority Cert Context/Chain/Key information:

#define CTXF_SKIPCRL		0x00000001
#define CTXF_CERTMISSING	0x00000002
#define CTXF_CRLZOMBIE		0x00000004
#define CTXF_EXPIRED		0x00000010
#define CTXF_REVOKED		0x00000020

typedef struct _CACTX
{
    DWORD		 Flags;
    DWORD		 iCert;
    DWORD		 iKey;
    DWORD		 NameId;	// MAKECANAMEID(iCert, iKey)
    HRESULT		 hrVerifyStatus;
    CERT_CONTEXT const **apCACertChain;
    DWORD                cCACertChain;
    CERT_CONTEXT const  *pccCA;
    CRYPT_OBJID_BLOB     IssuerKeyId;
    HCRYPTPROV           hProvCA;
    CRYPT_OBJID_BLOB     KeyAuthority2Cert;
    CRYPT_OBJID_BLOB     KeyAuthority2CRL;
    CRYPT_OBJID_BLOB     CDPCert;
    CRYPT_OBJID_BLOB     CDPCRLFreshest;
    CRYPT_OBJID_BLOB     CDPCRLBase;
    CRYPT_OBJID_BLOB     CDPCRLDelta;
    CRYPT_OBJID_BLOB     AIACert;
    char                *pszObjIdSignatureAlgorithm;
    WCHAR		*pwszKeyContainerName;
    WCHAR	       **papwszCRLFiles;
    WCHAR	       **papwszDeltaCRLFiles;
} CACTX;


typedef struct _CAXCHGCTX
{
    DWORD		 Flags;
    DWORD		 ReqId;
    CERT_CONTEXT const  *pccCA;
    HCRYPTPROV           hProvCA;
    WCHAR		*pwszKeyContainerName;
    DWORD		 iCertSig;
} CAXCHGCTX;


//+****************************************************
// Core Module:

HRESULT
CoreInit(VOID);

VOID
CoreTerminate(VOID);

HRESULT
CoreValidateRequestId(
    IN ICertDBRow *prow,
    IN DWORD ExpectedDisposition);


// Internal CoreProcessRequest Flags:

#define CR_IN_NEW		0x00000000
#define CR_IN_DENY		0x10000000
#define CR_IN_RESUBMIT		0x20000000
#define CR_IN_RETRIEVE		0x30000000
#define CR_IN_COREMASK		0x30000000

HRESULT
CoreProcessRequest(
    IN DWORD dwType,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwComContextIndex,
    IN DWORD dwRequestId,
    OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
CoreDenyRequest(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN DWORD ExpectedStatus);

VOID
CoreLogRequestStatus(
    IN ICertDBRow *prow,
    IN DWORD LogMsg,
    IN DWORD ErrCode,
    IN WCHAR const *pwszDisposition);

WCHAR *
CoreBuildDispositionString(
    OPTIONAL IN WCHAR const *pwszDispositionBase,
    OPTIONAL IN WCHAR const *pwszUserName,
    OPTIONAL IN WCHAR const *pwszDispositionDetail,
    OPTIONAL IN WCHAR const *pwszDispositionBy,
    IN HRESULT hrFail,
    IN BOOL fPublishError);

HRESULT
CoreSetDisposition(
    IN ICertDBRow *prow,
    IN DWORD Disposition);

HRESULT
CoreSetRequestDispositionFields(
    IN ICertDBRow *prow,
    IN DWORD ErrCode,
    IN DWORD Disposition,
    IN WCHAR const *pwszDisposition);

HRESULT
CoreSetComContextUserDN(
    IN DWORD dwRequestId,
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OPTIONAL OUT WCHAR const **ppwszDN);	// do NOT free!

#ifndef DBG_COMTEST
# define DBG_COMTEST DBG_CERTSRV
#endif


#if DBG_COMTEST

extern BOOL fComTest;

BOOL ComTest(LONG Context);

#endif


#ifdef DBG_CERTSRV_DEBUG_PRINT
# define CERTSRVDBGPRINTTIME(pszDesc, pftGMT) \
    CertSrvDbgPrintTime((pszDesc), (pftGMT))
VOID
CertSrvDbgPrintTime(
    IN char const *pszDesc,
    IN FILETIME const *pftGMT);

#else // DBG_CERTSRV_DEBUG_PRINT
# define CERTSRVDBGPRINTTIME(pszDesc, pftGMT)
#endif // DBG_CERTSRV_DEBUG_PRINT


HRESULT
CertSrvBlockThreadUntilStop();

/////////////////////////////////////
// CRL Publication logic

HRESULT
CRLInit(
    IN WCHAR const *pwszSanitizedName);

VOID
CRLTerminate();

HRESULT
CRLPubWakeupEvent(
    OUT DWORD *pdwMSTimeOut);

VOID
CRLComputeTimeOut(
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut);

HRESULT
CRLPublishCRLs(
    IN BOOL fRebuildCRL,
    IN BOOL fForceRepublish,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN BOOL fDelta,
    IN BOOL fShadowDelta,
    IN FILETIME ftNextUpdate,
    OUT BOOL *pfNeedRetry,
    OUT HRESULT *phrPublish);

HRESULT
CRLGetCRL(
    IN DWORD iCert,
    IN BOOL fDelta,
    OPTIONAL OUT CRL_CONTEXT const **ppCRL,
    OPTIONAL OUT DWORD *pdwCRLPublishFlags);

/////////////////////////////////////


HRESULT
PKCSSetup(
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszSanitizedName);

VOID
PKCSTerminate();

WCHAR const *
PKCSMapAttributeName(
    OPTIONAL IN WCHAR const *pwszAttributeName,
    OPTIONAL IN CHAR const *pszObjId,
    OUT DWORD *pdwIndex,
    OUT DWORD *pcchMax);

HRESULT
PKCSGetProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    OPTIONAL OUT DWORD *pcbData,
    OUT BYTE **ppbData);

VOID
PKCSVerifyCAState(
    IN OUT CACTX *pCAContext);

HRESULT
PKCSMapCertIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,
    OUT DWORD *pState);

HRESULT
PKCSMapCRLIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,	// returns newest iCert for passed iCert
    OUT DWORD *piCRL,
    OUT DWORD *pState);

HRESULT
PKCSGetCACertStatusCode(
    IN DWORD iCert,
    OUT HRESULT *phrCAStatusCode);

HRESULT
PKCSGetCAState(
    IN BOOL fCertState,
    OUT BYTE *pb);

HRESULT
PKCSGetKRAState(
    IN DWORD cKRA,
    OUT BYTE *pb);

HRESULT
PKCSSetSubjectTemplate(
    IN WCHAR const *pwszTemplate);

HRESULT
PKCSGetCACert(
    IN DWORD iCert,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert);

HRESULT
PKCSGetCAChain(
    IN DWORD iCert,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain);

HRESULT
PKCSGetCAXchgCert(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    OUT DWORD *piCertSig,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert);

HRESULT
PKCSGetCAXchgChain(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain);

HRESULT
PKCSArchivePrivateKey(
    IN ICertDBRow *prow,
    IN BOOL fV1Cert,
    IN BOOL fOverwrite,
    IN CRYPT_ATTR_BLOB const *pBlobEncrypted,
    OPTIONAL IN OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
PKCSGetArchivedKey(
    IN DWORD dwRequestId,
    OUT BYTE **ppbArchivedKey,
    OUT DWORD *pcbArchivedKey);

HRESULT
PKCSGetCRLList(
    IN BOOL fDelta,
    IN DWORD iCert,
    OUT WCHAR const * const **ppapwszCRLList);

HRESULT
PKCSSetServerProperties(
    IN ICertDBRow *prow,
    IN LONG lValidityPeriodCount,
    IN enum ENUM_PERIOD enumValidityPeriod);

HRESULT
PKCSSetRequestFlags(
    IN ICertDBRow *prow,
    IN BOOL fSet,
    IN DWORD dwChange);

HRESULT
PKCSCreateCertificate(
    IN ICertDBRow *prow,
    IN DWORD Disposition,
    IN BOOL fIncludeCRLs,
    OUT BOOL *pfErrorLogged,
    OPTIONAL OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
PKCSEncodeFullResponse(
    OPTIONAL IN ICertDBRow *prow,
    IN CERTSRV_RESULT_CONTEXT const *pResult,
    IN HRESULT hrRequest,
    IN WCHAR *pwszDispositionString,
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbResponse,    // CoTaskMem*
    OUT DWORD *pcbResponse);

HRESULT
PKCSVerifyIssuedCertificate(
    IN CERT_CONTEXT const *pCert,
    OUT CACTX **ppCAContext);

HRESULT
PKCSIsRevoked(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT LONG *pRevocationReason,
    OUT LONG *pDisposition);

HRESULT
PKCSParseImportedCertificate(
    IN DWORD Disposition,
    IN ICertDBRow *prow,
    OPTIONAL IN CACTX const *pCAContext,
    IN CERT_CONTEXT const *pCert);

HRESULT
PKCSParseRequest(
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN CERT_CONTEXT const *pSigningAuthority,
    OUT BOOL *pfRenewal,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
PKCSParseAttributes(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszAttributes,
    IN BOOL fRegInfo,
    IN DWORD dwRDNTable,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf);

HRESULT
PKCSVerifyChallengeString(
    IN ICertDBRow *prow);

HRESULT
PKCSVerifySubjectRDN(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropertyName,
    OPTIONAL IN WCHAR const *pwszPropertyValue,
    OUT BOOL *pfSubjectDot);

HRESULT
PKCSDeleteAllSubjectRDNs(
    IN ICertDBRow *prow,
    IN DWORD Flags);

WCHAR *
PKCSSplitToken(
    IN OUT WCHAR **ppwszIn,
    IN WCHAR *pwcSeparator,
    OUT BOOL *pfSplit);

HRESULT
PropAddSuffix(
    IN WCHAR const *pwszValue,
    IN WCHAR const *pwszSuffix,
    IN DWORD cwcNameMax,
    OUT WCHAR **ppwszOut);

HRESULT
PropParseRequest(
    IN ICertDBRow *prow,
    IN DWORD dwFlags,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
PropSetRequestTimeProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszProp);

HRESULT
PropGetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue);

HRESULT
PropSetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue);

HRESULT
PropSetAttributeProperty(
    IN ICertDBRow *prow,
    IN BOOL fConcatenateRDNs,
    IN DWORD dwTable,
    IN DWORD cchNameMax,
    OPTIONAL IN WCHAR const *pwszSuffix,
    IN WCHAR const *wszName,
    IN WCHAR const *wszValue);

HRESULT
RequestInitCAPropertyInfo(VOID);

HRESULT
RequestGetCAPropertyInfo(
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo);

HRESULT
RequestGetCAProperty(
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue);

HRESULT
RequestSetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue);

DWORD
CertSrvStartServerThread(
    IN VOID *pvArg);

HRESULT
CertSrvEnterServer(
    OUT DWORD *pState);

HRESULT
CertSrvTestServerState();

HRESULT
CertSrvLockServer(
    IN OUT DWORD *pState);

VOID
CertSrvExitServer(
    IN DWORD State);

HRESULT RPCInit(VOID);

HRESULT RPCTeardown(VOID);

VOID
ServiceMain(
    IN DWORD dwArgc,
    IN LPWSTR *lpszArgv);

BOOL
ServiceReportStatusToSCMgr(
    IN DWORD dwCurrentState,
    IN DWORD dwWin32ExitCode,
    IN DWORD dwCheckPoint,
    IN DWORD dwWaitHint);

#define INCREMENT_EXTENSIONS            16

HRESULT
DBOpen(				// initialize database
    WCHAR const *pwszSanitizedName);

HRESULT
DBShutDown(			// terminate database access
    IN BOOL fPendingNotify);

STDMETHODIMP
CheckCertSrvAccess(
    IN LPCWSTR wszCA,
    IN handle_t hRpc,
    IN ACCESS_MASK Mask,
    OUT BOOL *pfAccessAllowed,
    OPTIONAL OUT HANDLE *phToken);

HRESULT
CertSrvSetRegistryFileTimeValue(
    IN BOOL fConfigLevel,
    IN WCHAR const *pwszRegValueName,
    IN DWORD cpwszDelete,
    OPTIONAL IN WCHAR const * const *papwszRegValueNameDelete);

HRESULT
GetClientUserName(
    OPTIONAL IN RPC_BINDING_HANDLE hRpc,
    OPTIONAL OUT WCHAR **ppwszUserSamName,
    OPTIONAL OUT WCHAR **ppwszUserDN);

HRESULT CertStartClassFactories(VOID);
VOID CertStopClassFactories(VOID);

HRESULT
SetCAObjectFlags(DWORD dwFlags);

namespace CertSrv
{
HRESULT 
GetMembership(
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzRM,
    IN PSID pSid,
    PTOKEN_GROUPS *ppGroups);

HRESULT 
CheckOfficerRights(DWORD dwRequestID, CertSrv::CAuditEvent &event);
HRESULT 
CheckOfficerRights(LPCWSTR pwszRequesterName, CertSrv::CAuditEvent &event);

BOOL
CallbackAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable);
}


HRESULT
PKCSGetKRACert(
    IN DWORD iCert,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert);

#define CSST_STARTSERVICECONTROLLER	0x00000001
#define CSST_CONSOLE			0x00000002

extern enum ENUM_PERIOD g_enumValidityPeriod;
extern LONG g_lValidityPeriodCount;

extern enum ENUM_PERIOD g_enumCAXchgValidityPeriod;
extern LONG g_lCAXchgValidityPeriodCount;

extern enum ENUM_PERIOD g_enumCAXchgOverlapPeriod;
extern LONG g_lCAXchgOverlapPeriodCount;

extern DWORD g_dwDelay2;

extern DWORD g_dwClockSkewMinutes;
extern DWORD g_dwLogLevel;
extern DWORD g_dwCRLFlags;
extern DWORD g_dwHighSerial;

extern ICertDB *g_pCertDB;
extern BOOL g_fDBRecovered;

extern HCERTSTORE g_hStoreCA;
extern HCRYPTPROV g_hProvCA;

extern BSTR g_strPolicyDescription;
extern BSTR g_strExitDescription;

extern BOOL g_fCertEnrollCompatible;
extern BOOL g_fEnforceRDNNameLengths;
extern BOOL g_fCreateDB;
extern BOOL g_fStartAsService;
extern DWORD g_CRLEditFlags;
extern DWORD g_KRAFlags;
extern DWORD g_cKRACertsRoundRobin;
extern DWORD g_cKRACerts;
extern ENUM_FORCETELETEX g_fForceTeletex;
extern ENUM_CATYPES g_CAType;
extern BOOL g_fUseDS;
extern BOOL g_fServerUpgraded;
extern long g_cTemplateUpdateSequenceNum;
extern BOOL g_fLockICertRequest;

extern BOOL  g_fCryptSilent;

extern WCHAR g_wszCAStore[];
extern WCHAR const g_wszCertSrvServiceName[];
extern WCHAR const g_wszRegKeyConfigPath[];

extern WCHAR const g_wszRegDBA[];

extern WCHAR g_wszSanitizedName[];
extern WCHAR *g_pwszSanitizedDSName;
extern WCHAR g_wszCommonName[];
extern WCHAR g_wszParentConfig[];

extern WCHAR g_wszDatabase[];
extern WCHAR g_wszLogDir[];
extern WCHAR g_wszSystemDir[];

extern WCHAR *g_pwszServerName;
extern BSTR g_strDomainDN;
extern BSTR g_strConfigDN;
extern WCHAR *g_pwszKRAPublishURL;
extern WCHAR *g_pwszAIACrossCertPublishURL;
extern WCHAR *g_pwszRootTrustCrossCertPublishURL;

extern WCHAR const g_wszRegValidityPeriodString[];
extern WCHAR const g_wszRegValidityPeriodCount[];
extern WCHAR const g_wszRegCAXchgCertHash[];

// renewal-friendly properties

extern DWORD g_cCAKeys;    // Total number of CA keys managed by this CA
extern DWORD g_cCACerts;   // Total number of CA certs managed by this CA

extern DWORD g_cExitMod;   // Total number of exit modules loaded by this CA

extern CertSrv::CCertificateAuthoritySD g_CASD;
extern AUTHZ_RESOURCE_MANAGER_HANDLE g_AuthzCertSrvRM;
extern DWORD g_dwAuditFilter;
extern CertSrv::COfficerRightsSD g_OfficerRightsSD;
extern CertSrv::CConfigStorage g_ConfigStorage;
extern CertSrv::CAutoLPWSTR g_pwszDBFileHash;

//+--------------------------------------------------------------------------
// Name properties:

extern WCHAR const g_wszPropDistinguishedName[];
extern WCHAR const g_wszPropRawName[];
extern WCHAR const g_wszPropCountry[];
extern WCHAR const g_wszPropOrganization[];
extern WCHAR const g_wszPropOrgUnit[];
extern WCHAR const g_wszPropCommonName[];
extern WCHAR const g_wszPropLocality[];
extern WCHAR const g_wszPropState[];
extern WCHAR const g_wszPropTitle[];
extern WCHAR const g_wszPropGivenName[];
extern WCHAR const g_wszPropInitials[];
extern WCHAR const g_wszPropSurName[];
extern WCHAR const g_wszPropDomainComponent[];
extern WCHAR const g_wszPropEMail[];
extern WCHAR const g_wszPropStreetAddress[];
extern WCHAR const g_wszPropUnstructuredAddress[];
extern WCHAR const g_wszPropUnstructuredName[];
extern WCHAR const g_wszPropDeviceSerialNumber[];
extern WCHAR const g_wszPropCertificateIssuerNameID[];


//+--------------------------------------------------------------------------
// Subject Name properties:

extern WCHAR const g_wszPropSubjectDot[];
extern WCHAR const g_wszPropSubjectDistinguishedName[];
extern WCHAR const g_wszPropSubjectRawName[];
extern WCHAR const g_wszPropSubjectCountry[];
extern WCHAR const g_wszPropSubjectOrganization[];
extern WCHAR const g_wszPropSubjectOrgUnit[];
extern WCHAR const g_wszPropSubjectCommonName[];
extern WCHAR const g_wszPropSubjectLocality[];
extern WCHAR const g_wszPropSubjectState[];
extern WCHAR const g_wszPropSubjectTitle[];
extern WCHAR const g_wszPropSubjectGivenName[];
extern WCHAR const g_wszPropSubjectInitials[];
extern WCHAR const g_wszPropSubjectSurName[];
extern WCHAR const g_wszPropSubjectDomainComponent[];
extern WCHAR const g_wszPropSubjectEMail[];
extern WCHAR const g_wszPropSubjectStreetAddress[];
extern WCHAR const g_wszPropSubjectUnstructuredAddress[];
extern WCHAR const g_wszPropSubjectUnstructuredName[];
extern WCHAR const g_wszPropSubjectDeviceSerialNumber[];


//+--------------------------------------------------------------------------
// Issuer Name properties:

extern WCHAR const g_wszPropIssuerDot[];
extern WCHAR const g_wszPropIssuerDistinguishedName[];
extern WCHAR const g_wszPropIssuerRawName[];
extern WCHAR const g_wszPropIssuerCountry[];
extern WCHAR const g_wszPropIssuerOrganization[];
extern WCHAR const g_wszPropIssuerOrgUnit[];
extern WCHAR const g_wszPropIssuerCommonName[];
extern WCHAR const g_wszPropIssuerLocality[];
extern WCHAR const g_wszPropIssuerState[];
extern WCHAR const g_wszPropIssuerTitle[];
extern WCHAR const g_wszPropIssuerGivenName[];
extern WCHAR const g_wszPropIssuerInitials[];
extern WCHAR const g_wszPropIssuerSurName[];
extern WCHAR const g_wszPropIssuerDomainComponent[];
extern WCHAR const g_wszPropIssuerEMail[];
extern WCHAR const g_wszPropIssuerStreetAddress[];
extern WCHAR const g_wszPropIssuerUnstructuredAddress[];
extern WCHAR const g_wszPropIssuerUnstructuredName[];
extern WCHAR const g_wszPropIssuerDeviceSerialNumber[];


//+--------------------------------------------------------------------------
// Request properties:

extern WCHAR const g_wszPropRequestRequestID[];
extern WCHAR const g_wszPropRequestRawRequest[];
extern WCHAR const g_wszPropRequestRawArchivedKey[];
extern WCHAR const g_wszPropRequestKeyRecoveryHashes[];
extern WCHAR const g_wszPropRequestRawOldCertificate[];
extern WCHAR const g_wszPropRequestAttributes[];
extern WCHAR const g_wszPropRequestType[];
extern WCHAR const g_wszPropRequestFlags[];
extern WCHAR const g_wszPropRequestStatusCode[];
extern WCHAR const g_wszPropRequestDisposition[];
extern WCHAR const g_wszPropRequestDispositionMessage[];
extern WCHAR const g_wszPropRequestSubmittedWhen[];
extern WCHAR const g_wszPropRequestResolvedWhen[];
extern WCHAR const g_wszPropRequestRevokedWhen[];
extern WCHAR const g_wszPropRequestRevokedEffectiveWhen[];
extern WCHAR const g_wszPropRequestRevokedReason[];
extern WCHAR const g_wszPropRequesterName[];
extern WCHAR const g_wszPropCallerName[];
extern WCHAR const g_wszPropRequestOSVersion[];
extern WCHAR const g_wszPropRequestCSPProvider[];

//+--------------------------------------------------------------------------
// Request attribute properties:

extern WCHAR const g_wszPropChallenge[];
extern WCHAR const g_wszPropExpectedChallenge[];


//+--------------------------------------------------------------------------
// Certificate properties:

extern WCHAR const g_wszPropCertificateRequestID[];
extern WCHAR const g_wszPropRawCertificate[];
extern WCHAR const g_wszPropCertificateHash[];
extern WCHAR const g_wszPropCertificateSerialNumber[];
extern WCHAR const g_wszPropCertificateNotBeforeDate[];
extern WCHAR const g_wszPropCertificateNotAfterDate[];
extern WCHAR const g_wszPropCertificateSubjectKeyIdentifier[];
extern WCHAR const g_wszPropCertificateRawPublicKey[];
extern WCHAR const g_wszPropCertificatePublicKeyLength[];
extern WCHAR const g_wszPropCertificatePublicKeyAlgorithm[];
extern WCHAR const g_wszPropCertificateRawPublicKeyAlgorithmParameters[];


//+--------------------------------------------------------------------------
// Disposition messages:

extern WCHAR const *g_pwszRequestedBy;
extern WCHAR const *g_pwszRevokedBy;
extern WCHAR const *g_pwszUnrevokedBy;
extern WCHAR const *g_pwszPublishedBy;

extern WCHAR const *g_pwszIntermediateCAStore;

//+--------------------------------------------------------------------------
// Localizable audit strings
extern WCHAR const *g_pwszYes;
extern WCHAR const *g_pwszNo;
extern LPCWSTR g_pwszAuditResources[];

//+--------------------------------------------------------------------------
// Secured attributes:
extern LPWSTR  g_wszzSecuredAttributes;

extern HANDLE g_hServiceStoppingEvent;
extern HANDLE g_hServiceStoppedEvent;

extern HANDLE g_hCRLManualPublishEvent;
extern BOOL g_fCRLPublishDisabled;
extern BOOL g_fDeltaCRLPublishDisabled;

extern HKEY g_hkeyCABase;
extern HWND g_hwndMain;

extern BOOL g_fAdvancedServer;

__inline DWORD GetCertsrvComThreadingModel() { return(COINIT_MULTITHREADED); }

extern CACTX *g_aCAContext;
extern CACTX *g_pCAContextCurrent;


inline HRESULT CheckAuthorityName(PCWSTR pwszAuthority, bool fAllowEmptyName = false)
{
    HRESULT hr;
    if (NULL != pwszAuthority && L'\0' != *pwszAuthority)
    {
    	if (0 != lstrcmpi(pwszAuthority, g_wszCommonName))
        {   
            if (0 != lstrcmpi(pwszAuthority, g_wszSanitizedName) &&
            0 != lstrcmpi(pwszAuthority, g_pwszSanitizedDSName))
	        {
		        hr = E_INVALIDARG;
		        goto error;
	        }
#ifdef DBG_CERTSRV_DEBUG_PRINT
	        if (0 == lstrcmpi(pwszAuthority, g_wszSanitizedName))
	        {
		        DBGPRINT((
		            DBG_SS_CERTSRV,
		            "'%ws' called with Sanitized Name: '%ws'\n",
		            g_wszCommonName,
		            pwszAuthority));
	        }
	        else if (0 == lstrcmpi(pwszAuthority, g_pwszSanitizedDSName))
	        {
		        DBGPRINT((
		            DBG_SS_CERTSRV,
		            "'%ws' called with Sanitized DS Name: '%ws'\n",
		            g_wszCommonName,
		            pwszAuthority));
	        }
#endif
        }
    }
    else if(!fAllowEmptyName)
    {
        return hr = E_INVALIDARG;
    }

    hr = S_OK;

error:
    return hr;
}

#endif // __CSEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\crl.cpp ===
//+-------------------------------------------------------------------------n-
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crl.cpp
//
// Contents:    Cert Server CRL processing
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <esent.h>

#include "cscom.h"
#include "csprop.h"

#include "dbtable.h"
#include "resource.h"

#include "elog.h"
#include "certlog.h"

#include <winldap.h>
#include "csldap.h"
#include "cainfop.h"

#define __dwFILE__	__dwFILE_CERTSRV_CRL_CPP__

HANDLE g_hCRLManualPublishEvent = NULL;

FILETIME g_ftCRLNextPublish;
FILETIME g_ftDeltaCRLNextPublish;

BOOL g_fCRLPublishDisabled = FALSE;	 // manual publishing always allowed
BOOL g_fDeltaCRLPublishDisabled = FALSE; // controls manual publishing, too

DWORD g_dwCRLFlags = CRLF_DELETE_EXPIRED_CRLS;
LDAP *g_pld = NULL;

typedef struct _CSMEMBLOCK
{
    struct _CSMEMBLOCK *pNext;
    BYTE               *pbFree;
    DWORD               cbFree;
} CSMEMBLOCK;

#define CBMEMBLOCK	4096


typedef struct _CSCRLELEMENT
{
    USHORT   usRevocationReason;
    USHORT   uscbSerialNumber;
    BYTE    *pbSerialNumber;
    FILETIME ftRevocationDate;
} CSCRLELEMENT;


// size the structure just under CBMEMBLOCK to keep it from being just over
// a page size.

#define CCRLELEMENT  ((CBMEMBLOCK - 2 * sizeof(DWORD)) / sizeof(CSCRLELEMENT))

typedef struct _CSCRLBLOCK
{
    struct _CSCRLBLOCK *pNext;
    DWORD	        cCRLElement;
    CSCRLELEMENT        aCRLElement[CCRLELEMENT];
} CSCRLBLOCK;


typedef struct _CSCRLREASON
{
    struct _CSCRLREASON *pNext;
    DWORD                RevocationReason;
    CERT_EXTENSION       ExtReason;
} CSCRLREASON;


typedef struct _CSCRLPERIOD
{
    LONG lCRLPeriodCount;
    ENUM_PERIOD enumCRLPeriod;
    DWORD dwCRLOverlapMinutes;
} CSCRLPERIOD;


#ifdef DBG_CERTSRV_DEBUG_PRINT
# define DPT_DATE	1
# define DPT_DELTA	2
# define DPT_DELTASEC	3
# define DPT_DELTAMS	4

# define DBGPRINTTIME(pfDelta, pszName, Type, ft) \
    DbgPrintTime((pfDelta), (pszName), __LINE__, (Type), (ft))

VOID
DbgPrintTime(
    OPTIONAL IN BOOL const *pfDelta,
    IN char const *pszName,
    IN DWORD Line,
    IN DWORD Type,
    IN FILETIME ft)
{
    HRESULT hr;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];
    LLFILETIME llft;
    
    llft.ft = ft;
    if (Type == DPT_DATE)
    {
	if (0 != llft.ll)
	{
	    hr = myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszTime);
	    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
	}
    }
    else
    {
	if (DPT_DELTAMS == Type)
	{
	    llft.ll /= 1000;		// milliseconds to seconds
	    Type = DPT_DELTASEC;
	}
	if (DPT_DELTASEC == Type)
	{
	    llft.ll *= CVT_BASE;	// seconds to FILETIME period
	}
	llft.ll = -llft.ll;		// FILETIME Period must be negative

	if (0 != llft.ll)
	{
	    hr = myFileTimePeriodToWszTimePeriod(
			    &llft.ft,
			    TRUE,	// fExact
			    &pwszTime);
	    _PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
	}
    }
    if (NULL == pwszTime)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }

    DBGPRINT((
	DBG_SS_CERTSRVI,
	"%hs(%d):%hs time(%hs): %lx:%08lx %ws\n",
	"crl.cpp",
	Line,
	NULL == pfDelta? "" : (*pfDelta? " Delta CRL" : " Base CRL"),
	pszName,
	ft.dwHighDateTime,
	ft.dwLowDateTime,
	pwszTime));

//error:
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}


VOID
CertSrvDbgPrintTime(
    IN char const *pszDesc,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];

    hr = myGMTFileTimeToWszLocalTime(pftGMT, TRUE, &pwszTime);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    if (S_OK != hr)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }
    DBGPRINT((DBG_SS_CERTSRV, "%hs: %ws\n", pszDesc, pwszTime));

//error:
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}
#else // DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINTTIME(pfDelta, pszName, Type, ft)
#endif // DBG_CERTSRV_DEBUG_PRINT


HRESULT
crlMemBlockAlloc(
    IN OUT CSMEMBLOCK **ppBlock,
    IN DWORD cb,
    OUT BYTE **ppb)
{
    HRESULT hr;
    CSMEMBLOCK *pBlock = *ppBlock;

    *ppb = NULL;
    cb = POINTERROUND(cb);
    if (NULL == pBlock || cb > pBlock->cbFree)
    {
	pBlock = (CSMEMBLOCK *) LocalAlloc(LMEM_FIXED, CBMEMBLOCK);
        if (NULL == pBlock)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
	pBlock->pNext = *ppBlock;
	pBlock->pbFree = (BYTE *) Add2Ptr(pBlock, sizeof(CSMEMBLOCK));
	pBlock->cbFree = CBMEMBLOCK - sizeof(CSMEMBLOCK);
	*ppBlock = pBlock;
    }
    CSASSERT(cb <= pBlock->cbFree);
    *ppb = pBlock->pbFree;
    pBlock->pbFree += cb;
    pBlock->cbFree -= cb;
    hr = S_OK;

error:
    return(hr);
}


VOID
crlBlockListFree(
    IN OUT CSMEMBLOCK *pBlock)
{
    CSMEMBLOCK *pBlockNext;

    while (NULL != pBlock)
    {
	pBlockNext = pBlock->pNext;
	LocalFree(pBlock);
	pBlock = pBlockNext;
    }
}


HRESULT
crlElementAlloc(
    IN OUT CSCRLBLOCK **ppBlock,
    OUT CSCRLELEMENT **ppCRLElement)
{
    HRESULT hr;
    CSCRLBLOCK *pBlock = *ppBlock;

    *ppCRLElement = NULL;
    if (NULL == pBlock ||
	ARRAYSIZE(pBlock->aCRLElement) <= pBlock->cCRLElement)
    {
	pBlock = (CSCRLBLOCK *) LocalAlloc(LMEM_FIXED, sizeof(*pBlock));
        if (NULL == pBlock)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
	pBlock->pNext = *ppBlock;
	pBlock->cCRLElement = 0;
	*ppBlock = pBlock;
    }
    CSASSERT(ARRAYSIZE(pBlock->aCRLElement) > pBlock->cCRLElement);
    *ppCRLElement = &pBlock->aCRLElement[pBlock->cCRLElement++];
    hr = S_OK;

error:
    return(hr);
}


VOID
crlFreeCRLArray(
    IN OUT VOID *pvBlockSerial,
    IN OUT CRL_ENTRY *paCRL)
{
    crlBlockListFree((CSMEMBLOCK *) pvBlockSerial);
    if (NULL != paCRL)
    {
        LocalFree(paCRL);
    }
}


HRESULT
crlCreateCRLReason(
    IN OUT CSMEMBLOCK **ppBlock,
    IN OUT CSCRLREASON **ppReason,
    IN DWORD RevocationReason,
    OUT DWORD *pcExtension,
    OUT CERT_EXTENSION **ppExtension)
{
    HRESULT hr;
    CSCRLREASON *pReason = *ppReason;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    for (pReason = *ppReason; NULL != pReason; pReason = pReason->pNext)
    {
	if (RevocationReason == pReason->RevocationReason)
	{
	    break;
	}
    }

    if (NULL == pReason)
    {
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_ENUMERATED,
			(const void *) &RevocationReason,
			0,
			CERTLIB_USE_LOCALALLOC,
			&pbEncoded,
			&cbEncoded))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}

	hr = crlMemBlockAlloc(
		    ppBlock,
		    sizeof(CSCRLREASON) + cbEncoded,
		    (BYTE **) &pReason);
	_JumpIfError(hr, error, "crlMemBlockAlloc");

	pReason->pNext = *ppReason;
	pReason->RevocationReason = RevocationReason;
	pReason->ExtReason.pszObjId = szOID_CRL_REASON_CODE;
	pReason->ExtReason.fCritical = FALSE;
	pReason->ExtReason.Value.pbData =
	    (BYTE *) Add2Ptr(pReason, sizeof(*pReason));
	pReason->ExtReason.Value.cbData = cbEncoded;
	CopyMemory(pReason->ExtReason.Value.pbData, pbEncoded, cbEncoded);

	*ppReason = pReason;

	//printf("crlCreateCRLReason: new %x  cb %x\n", RevocationReason, cbEncoded);
    }
    //printf("crlCreateCRLReason: %x\n", RevocationReason);
    CSASSERT(NULL != pReason && RevocationReason == pReason->RevocationReason);

    *pcExtension = 1;
    *ppExtension = &pReason->ExtReason;
    hr = S_OK;

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}


// Convert linked list of CRL blocks to an array.
// If the output array pointer is NULL, just free the list.

HRESULT
ConvertOrFreeCRLList(
    IN OUT CSCRLBLOCK **ppBlockCRL,	// Freed
    IN OUT CSMEMBLOCK **ppBlockReason,	// Used to allocate reason extensions
    IN DWORD cCRL,
    OPTIONAL OUT CRL_ENTRY **paCRL)
{
    HRESULT hr;
    CSCRLREASON *pReasonList = NULL;	// linked list of reason extensions
    CSCRLBLOCK *pBlockCRL = *ppBlockCRL;
    CRL_ENTRY *aCRL = NULL;
    CRL_ENTRY *pCRL;
    DWORD i;

    if (NULL != paCRL)
    {
        aCRL = (CRL_ENTRY *) LocalAlloc(LMEM_FIXED, sizeof(aCRL[0]) * cCRL);
        if (NULL == aCRL)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }

    pCRL = aCRL;
    while (NULL != pBlockCRL)
    {
	CSCRLBLOCK *pBlockCRLNext;

	if (NULL != pCRL)
	{
	    for (i = 0; i < pBlockCRL->cCRLElement; i++)
	    {
		CSCRLELEMENT *pCRLElement = &pBlockCRL->aCRLElement[i];

		pCRL->SerialNumber.pbData = pCRLElement->pbSerialNumber;
		pCRL->SerialNumber.cbData = pCRLElement->uscbSerialNumber;
		pCRL->RevocationDate = pCRLElement->ftRevocationDate;
		pCRL->cExtension = 0;
		pCRL->rgExtension = NULL;

		if (CRL_REASON_UNSPECIFIED != pCRLElement->usRevocationReason)
		{
		    hr = crlCreateCRLReason(
				    ppBlockReason,
				    &pReasonList,
				    pCRLElement->usRevocationReason,
				    &pCRL->cExtension,
				    &pCRL->rgExtension);
		    _JumpIfError(hr, error, "crlCreateCRLReason");
		}
		pCRL++;
	    }
	}
	pBlockCRLNext = pBlockCRL->pNext;
	LocalFree(pBlockCRL);
	pBlockCRL = pBlockCRLNext;
    }

    if (NULL != paCRL)
    {
	CSASSERT(pCRL == &aCRL[cCRL]);
        *paCRL = aCRL;
        aCRL = NULL;
    }
    CSASSERT(NULL == pBlockCRL);
    hr = S_OK;

error:
    *ppBlockCRL = pBlockCRL;
    if (NULL != aCRL)
    {
        LocalFree(aCRL);
    }
    return(hr);
}


HRESULT
AddCRLElement(
    IN OUT CSMEMBLOCK **ppBlockSerial,
    IN OUT CSCRLBLOCK **ppBlockCRL,
    IN WCHAR const *pwszSerialNumber,
    IN FILETIME const *pftRevokedEffectiveWhen,
    IN DWORD RevocationReason)
{
    HRESULT hr;
    CSCRLELEMENT *pCRLElement;
    DWORD cbSerial;
    BYTE *pbSerial = NULL;

    hr = crlElementAlloc(ppBlockCRL, &pCRLElement);
    _JumpIfError(hr, error, "crlElementAlloc");

    hr = WszToMultiByteInteger(
			    FALSE,
			    pwszSerialNumber,
			    &cbSerial,
			    &pbSerial);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    hr = crlMemBlockAlloc(ppBlockSerial, cbSerial, &pCRLElement->pbSerialNumber);
    _JumpIfError(hr, error, "crlMemBlockAlloc");

    CopyMemory(pCRLElement->pbSerialNumber, pbSerial, cbSerial);

    pCRLElement->ftRevocationDate = *pftRevokedEffectiveWhen;
    pCRLElement->usRevocationReason = (USHORT) RevocationReason;
    pCRLElement->uscbSerialNumber = (USHORT) cbSerial;

    CSASSERT(pCRLElement->usRevocationReason == RevocationReason);
    CSASSERT(pCRLElement->uscbSerialNumber == cbSerial);

error:
    if (NULL != pbSerial)
    {
	LocalFree(pbSerial);
    }
    return(hr);
}


DWORD g_aColCRL[] = {

#define ICOL_DISPOSITION	0
    DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,

#define ICOL_SERIAL		1
    DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,

#define ICOL_EFFECTIVEWHEN	2
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,

#define ICOL_REASON		3
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
};


HRESULT
BuildCRLList(
    IN BOOL fDelta,
    IN DWORD iKey,
    OPTIONAL IN FILETIME const *pftQueryMinimum,
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftLastPublishBase,
    IN OUT DWORD *pcCRL,
    IN OUT CSCRLBLOCK **ppBlockCRL,
    IN OUT CSMEMBLOCK **ppBlockSerial)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[5];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD celtFetched;
    DWORD NameIdMin;
    DWORD NameIdMax;
    DWORD i;
    BOOL fEnd;
    CERTDBRESULTROW aResult[10];
    BOOL fResultActive = FALSE;
    DWORD cCRL = *pcCRL;
    CSCRLBLOCK *pBlockCRL = *ppBlockCRL;
    CSMEMBLOCK *pBlockSerial = *ppBlockSerial;

    DBGPRINTTIME(NULL, "*pftThisPublish", DPT_DATE, *pftThisPublish);

    // Set up restrictions as follows:

    pcvr = acvr;

    // Request.RevokedEffectiveWhen <= *pftThisPublish (indexed column)

    pcvr->ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN;
    pcvr->SeekOperator = CVR_SEEK_LE;
    pcvr->SortOrder = CVR_SORT_DESCEND;
    pcvr->pbValue = (BYTE *) pftThisPublish;
    pcvr->cbValue = sizeof(*pftThisPublish);
    pcvr++;

    // Cert.NotAfter >= *pftLastPublishBase

    if (0 == (CRLF_PUBLISH_EXPIRED_CERT_CRLS & g_dwCRLFlags))
    {
	pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE;
	pcvr->SeekOperator = CVR_SEEK_GE;
	pcvr->SortOrder = CVR_SORT_NONE;
	pcvr->pbValue = (BYTE *) pftLastPublishBase;
	pcvr->cbValue = sizeof(*pftLastPublishBase);
	pcvr++;
    }

    // NameId >= MAKECANAMEID(iCert == 0, iKey)

    NameIdMin = MAKECANAMEID(0, iKey);
    pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID;
    pcvr->SeekOperator = CVR_SEEK_GE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMin;
    pcvr->cbValue = sizeof(NameIdMin);
    pcvr++;

    // NameId <= MAKECANAMEID(iCert == _16BITMASK, iKey)

    NameIdMax = MAKECANAMEID(_16BITMASK, iKey);
    pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID;
    pcvr->SeekOperator = CVR_SEEK_LE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMax;
    pcvr->cbValue = sizeof(NameIdMax);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) > SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    if (NULL != pftQueryMinimum)
    {
	// Request.RevokedWhen >= *pftQueryMinimum

	pcvr->ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN;
	pcvr->SeekOperator = CVR_SEEK_GE;
	pcvr->SortOrder = CVR_SORT_NONE;
	pcvr->pbValue = (BYTE *) pftQueryMinimum;
	pcvr->cbValue = sizeof(*pftQueryMinimum);
	pcvr++;

	CSASSERT(ARRAYSIZE(acvr) >= SAFE_SUBTRACT_POINTERS(pcvr, acvr));
    }

    hr = g_pCertDB->OpenView(
			SAFE_SUBTRACT_POINTERS(pcvr, acvr),
			acvr,
			ARRAYSIZE(g_aColCRL),
			g_aColCRL,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    fEnd = FALSE;
    while (!fEnd)
    {
	hr = pView->Next(ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    fEnd = TRUE;
	    if (0 == celtFetched)
	    {
		break;
	    }
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "Next");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) >= celtFetched);

	for (i = 0; i < celtFetched; i++)
	{
	    DWORD Disposition;
	    DWORD Reason;
	
	    CERTDBRESULTROW *pResult = &aResult[i];

	    CSASSERT(ARRAYSIZE(g_aColCRL) == pResult->ccol);

	    CSASSERT(NULL != pResult->acol[ICOL_DISPOSITION].pbValue);
	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOL_DISPOSITION].Type));
	    CSASSERT(sizeof(Disposition) == pResult->acol[ICOL_DISPOSITION].cbValue);
	    Disposition = *(DWORD *) pResult->acol[ICOL_DISPOSITION].pbValue;

	    CSASSERT(NULL != pResult->acol[ICOL_SERIAL].pbValue);
	    CSASSERT(PROPTYPE_STRING == (PROPTYPE_MASK & pResult->acol[ICOL_SERIAL].Type));
	    CSASSERT(0 < pResult->acol[ICOL_SERIAL].cbValue);

	    if (NULL == pResult->acol[ICOL_EFFECTIVEWHEN].pbValue)
	    {
		continue;
	    }
	    CSASSERT(sizeof(FILETIME) == pResult->acol[ICOL_EFFECTIVEWHEN].cbValue);
	    CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOL_EFFECTIVEWHEN].Type));

	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOL_REASON].Type));
	    Reason = CRL_REASON_UNSPECIFIED;
	    if (NULL != pResult->acol[ICOL_REASON].pbValue)
	    {
		CSASSERT(sizeof(Reason) == pResult->acol[ICOL_REASON].cbValue);
		Reason = *(DWORD *) pResult->acol[ICOL_REASON].pbValue;
	    }

	    if (NULL == pResult->acol[ICOL_SERIAL].pbValue ||
		CRL_REASON_REMOVE_FROM_CRL == Reason)
	    {
		continue;
	    }

	    // Add to CRL unless it's:
	    //    not a revoked issued cert &&
	    //    not a root CA cert &&
	    //    not an unrevoked issued cert

	    if (DB_DISP_REVOKED != Disposition &&
		!(DB_DISP_CA_CERT == Disposition && IsRootCA(g_CAType)) &&
		!(DB_DISP_ISSUED == Disposition && MAXDWORD == Reason))
	    {
		continue;
	    }
	    if (MAXDWORD == Reason)
	    {
		if (!fDelta)
		{
		    continue;
		}
		Reason = CRL_REASON_REMOVE_FROM_CRL;
	    }
	    hr = AddCRLElement(
		    &pBlockSerial,
		    &pBlockCRL,
		    (WCHAR const *) pResult->acol[ICOL_SERIAL].pbValue,
		    (FILETIME const *) pResult->acol[ICOL_EFFECTIVEWHEN].pbValue,
		    Reason);
	    _JumpIfError(hr, error, "AddCRLElement");

	    CONSOLEPRINT3((
			DBG_SS_CERTSRV,
			"Cert is %ws: %ws: %d\n",
			CRL_REASON_REMOVE_FROM_CRL == Reason?
			    L"UNREVOKED" : L"Revoked",
			pResult->acol[ICOL_SERIAL].pbValue,
			Reason));
	    cCRL++;
	}
	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }
    *pcCRL = cCRL;
    hr = S_OK;

error:
    *ppBlockSerial = pBlockSerial;
    *ppBlockCRL = pBlockCRL;
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    return(hr);
}
#undef ICOL_DISPOSITION
#undef ICOL_SERIAL
#undef ICOL_EFFECTIVEWHEN
#undef ICOL_REASON


HRESULT
crlBuildCRLArray(
    IN BOOL fDelta,
    OPTIONAL IN FILETIME const *pftQueryMinimum,
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftLastPublishBase,
    IN DWORD iKey,
    OUT DWORD *pcCRL,
    OUT CRL_ENTRY **paCRL,
    OUT VOID **ppvBlock)
{
    HRESULT hr;
    BOOL fCoInitialized = FALSE;
    CSCRLBLOCK *pBlockCRL = NULL;
    CSMEMBLOCK *pBlockSerial = NULL;

    *pcCRL = 0;
    *paCRL = NULL;
    *ppvBlock = NULL;

    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitializeEx");
    }
    fCoInitialized = TRUE;

    hr = BuildCRLList(
		fDelta,
		iKey,
		pftQueryMinimum,
		pftThisPublish,
		pftLastPublishBase,
		pcCRL,
		&pBlockCRL,
		&pBlockSerial);
    _JumpIfError(hr, error, "BuildCRLList");

    hr = ConvertOrFreeCRLList(&pBlockCRL, &pBlockSerial, *pcCRL, paCRL);
    _JumpIfError(hr, error, "ConvertOrFreeCRLList");

    *ppvBlock = pBlockSerial;
    pBlockSerial = NULL;

error:
    if (NULL != pBlockCRL)
    {
	ConvertOrFreeCRLList(&pBlockCRL, NULL, 0, NULL);
    }
    if (NULL != pBlockSerial)
    {
	crlBlockListFree(pBlockSerial);
    }
    if (fCoInitialized)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
crlGetRegCRLNextPublish(
    IN BOOL fDelta,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszRegName,
    OUT FILETIME *pftNextPublish)
{
    HRESULT hr;
    BYTE *pbData = NULL;
    DWORD cbData;
    DWORD dwType;

    hr = myGetCertRegValue(
                        NULL,
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegName,
			&pbData,		// free using LocalFree
			&cbData,
			&dwType);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
	goto error;
    }
    _JumpIfErrorStr(hr, error, "myGetCertRegValue", pwszRegName);

    if (REG_BINARY != dwType || sizeof(*pftNextPublish) != cbData)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto error;
    }
    *pftNextPublish = *(FILETIME *) pbData;
    DBGPRINTTIME(&fDelta, "*pftNextPublish", DPT_DATE, *pftNextPublish);
error:
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return(hr);
}


HRESULT
crlSetRegCRLNextPublish(
    IN BOOL fDelta,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszRegName,
    IN FILETIME const *pftNextPublish)
{
    HRESULT hr;

    hr = mySetCertRegValue(
                        NULL,
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegName,
			REG_BINARY,
			(BYTE const *) pftNextPublish,
			sizeof(*pftNextPublish),
			FALSE);
    _JumpIfErrorStr(hr, error, "mySetCertRegValue", pwszRegName);

    DBGPRINTTIME(&fDelta, "*pftNextPublish", DPT_DATE, *pftNextPublish);

error:
    return(hr);
}


// called from CoreInit
// inits process-static data: g_ftCRLNextPublish, etc.

HRESULT
CRLInit(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    DWORD dw;

    ZeroMemory(&g_ftCRLNextPublish, sizeof(g_ftCRLNextPublish));
    ZeroMemory(&g_ftDeltaCRLNextPublish, sizeof(g_ftDeltaCRLNextPublish));

    hr = crlGetRegCRLNextPublish(
		    FALSE,
		    pwszSanitizedName,
		    wszREGCRLNEXTPUBLISH,
		    &g_ftCRLNextPublish);
    _JumpIfError(hr, error, "crlGetRegCRLNextPublish");

    hr = crlGetRegCRLNextPublish(
		    TRUE,
		    pwszSanitizedName,
		    wszREGCRLDELTANEXTPUBLISH,
		    &g_ftDeltaCRLNextPublish);
    _JumpIfError(hr, error, "crlGetRegCRLNextPublish");

    hr = myGetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLFLAGS,
			(DWORD *) &dw);
    _PrintIfErrorStr(hr, "myGetCertRegDWValue", wszREGCRLFLAGS);
    if (S_OK == hr)
    {
	g_dwCRLFlags = dw;
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
CRLTerminate()
{
    if (NULL != g_pld)
    {
        ldap_unbind(g_pld);
        g_pld = NULL;
    }
}


HRESULT
crlGetRegPublishParams(
    IN BOOL fDelta,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszRegCRLPeriodCount,
    IN WCHAR const *pwszRegCRLPeriodString,
    IN WCHAR const *pwszRegCRLOverlapPeriodCount,
    IN WCHAR const *pwszRegCRLOverlapPeriodString,
    IN LONG lPeriodCountDefault,
    IN WCHAR const *pwszPeriodStringDefault,
    OPTIONAL OUT CSCRLPERIOD *pccp,
    OUT BOOL *pfCRLPublishDisabled)
{
    HRESULT hr;
    WCHAR *pwszCRLPeriodString = NULL;
    WCHAR *pwszCRLOverlapPeriodString = NULL;
    DWORD cbData;
    DWORD dwPeriod;
    DWORD dwType;
    CSCRLPERIOD ccp;

    if (NULL == pccp)
    {
	pccp = &ccp;
    }
    ZeroMemory(pccp, sizeof(*pccp));

    CSASSERT(NULL != pfCRLPublishDisabled);

    // get if need lCRLPeriodCount OR enumCRLPeriod
    // if any of these fail, skip to error handling below

    hr = myGetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodCount,
			(DWORD *) &pccp->lCRLPeriodCount);
    _PrintIfErrorStr(hr, "myGetCertRegDWValue", pwszRegCRLPeriodCount);

    if (hr == S_OK)
    {
        hr = myGetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodString,
			&pwszCRLPeriodString);
	_PrintIfErrorStr(hr, "myGetCertRegDWValue", pwszRegCRLPeriodString);
	if (hr == S_OK)
	{
	    hr = myTranslatePeriodUnits(
			    pwszCRLPeriodString,
			    pccp->lCRLPeriodCount,
			    &pccp->enumCRLPeriod,
			    &pccp->lCRLPeriodCount);
	    _PrintIfError(hr, "myTranslatePeriodUnits");
	}
       
        // don't allow base to be disabled anymore: force defaults to be loaded
        if (!fDelta &&
	    (0 == pccp->lCRLPeriodCount || -1 == pccp->lCRLPeriodCount))
	{
            hr = E_INVALIDARG;
	}
    }

    if (hr != S_OK)
    {
        _PrintError(hr, "Error reading CRLPub params. Overwriting with defaults.");

	if (CERTLOG_WARNING <= g_dwLogLevel)
	{
	    hr = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_INVALID_CRL_SETTINGS,
		    0,
		    NULL);
	    _PrintIfError(hr, "LogEvent");
	}

        // slam default publishing to whatever the caller said
	hr = myTranslatePeriodUnits(
			    pwszPeriodStringDefault,
			    lPeriodCountDefault,
			    &pccp->enumCRLPeriod,
			    &pccp->lCRLPeriodCount);
	_JumpIfError(hr, error, "myTranslatePeriodUnits");

        // blindly reset defaults
        mySetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodCount,
			pccp->lCRLPeriodCount);

        mySetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodString,
			pwszPeriodStringDefault);
    }
    *pfCRLPublishDisabled = 0 == pccp->lCRLPeriodCount;

    if (&ccp != pccp)			// If caller wants the data
    {
        BOOL fRegistryOverlap = FALSE;
        DWORD dwCRLOverlapCount;
        ENUM_PERIOD enumCRLOverlap;
        LLFILETIME llftDeltaPeriod;

        // try and gather overlap values from registry - bail on any failure

        hr = myGetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLOverlapPeriodCount,
			&dwCRLOverlapCount);
        if (hr == S_OK && 0 != dwCRLOverlapCount)	// if not disabled
        {
            hr = myGetCertRegStrValue(
			    pwszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegCRLOverlapPeriodString,
			    &pwszCRLOverlapPeriodString);// free w/ LocalFree
            if (hr == S_OK)
            {
                hr = myTranslatePeriodUnits(
				    pwszCRLOverlapPeriodString,
				    dwCRLOverlapCount,
				    &enumCRLOverlap,
				    (LONG *) &dwCRLOverlapCount);

                // we have enough info to override overlap calculation

                if (hr == S_OK)
                {
                    fRegistryOverlap = TRUE;
                    DBGPRINT((
			DBG_SS_CERTSRVI,
                        "Loaded CRL Overlap values. Overriding overlap calculation with specified values.\n"));
                }
            }
        }

        // always possible to revert to calculated value
        if (fRegistryOverlap)
        {
	    LLFILETIME llftOverlap;

            // convert registry-specified CRL overlap to FILETIME

	    llftOverlap.ll = 0;
	    myMakeExprDateTime(
			&llftOverlap.ft,
			dwCRLOverlapCount,
			enumCRLOverlap);
	    DBGPRINTTIME(&fDelta, "ftdelta1", DPT_DELTA, llftOverlap.ft);

	    llftOverlap.ll /= CVT_BASE;  // now in seconds

            // (DELTA sec / 60 secpermin)
            pccp->dwCRLOverlapMinutes = (DWORD) (llftOverlap.ll / CVT_MINUTES);
        }

	// convert CRL period to FILETIME

        llftDeltaPeriod.ll = 0;
	myMakeExprDateTime(
		    &llftDeltaPeriod.ft,
		    pccp->lCRLPeriodCount,
		    pccp->enumCRLPeriod);
	DBGPRINTTIME(&fDelta, "ftdelta2", DPT_DELTA, llftDeltaPeriod.ft);

	llftDeltaPeriod.ll /= CVT_BASE;		// now in seconds
	llftDeltaPeriod.ll /= CVT_MINUTES;	// now in minutes

        if (!fRegistryOverlap)
        {
	    if (fDelta)
	    {
		// default CRLOverlap for delta CRLs: same as period

		pccp->dwCRLOverlapMinutes = llftDeltaPeriod.ft.dwLowDateTime;
	    }
	    else
	    {
		// default CRLOverlap for base CRLs: 10% of period

		pccp->dwCRLOverlapMinutes = (DWORD) (llftDeltaPeriod.ll / 10);
	    }

            // Clamp computed overlap to less than 12 hours

	    if (pccp->dwCRLOverlapMinutes > 12 * 60)
	    {
		pccp->dwCRLOverlapMinutes = 12 * 60;
	    }
        }

        // Always clamp lower bound: (1.5 * skew) < g_dwCRLOverlapMinutes
        // must be at least 1.5x skew

	dwCRLOverlapCount = (3 * g_dwClockSkewMinutes) >> 1;
	if (pccp->dwCRLOverlapMinutes < dwCRLOverlapCount)
	{
	    pccp->dwCRLOverlapMinutes = dwCRLOverlapCount;
	}

        // Always clamp upper bound: must be no more than CRL period

	if (pccp->dwCRLOverlapMinutes > llftDeltaPeriod.ft.dwLowDateTime)
	{
	    pccp->dwCRLOverlapMinutes = llftDeltaPeriod.ft.dwLowDateTime;
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszCRLPeriodString)
    {
        LocalFree(pwszCRLPeriodString);
    }
    if (NULL != pwszCRLOverlapPeriodString)
    {
        LocalFree(pwszCRLOverlapPeriodString);
    }
    return(hr);
}


// Reload publication params during each CRL publication

HRESULT
crlGetRegCRLPublishParams(
    IN WCHAR const *pwszSanitizedName,
    OPTIONAL OUT CSCRLPERIOD *pccpBase,
    OPTIONAL OUT CSCRLPERIOD *pccpDelta)
{
    HRESULT hr;

    hr = crlGetRegPublishParams(
			FALSE,
			pwszSanitizedName,
			wszREGCRLPERIODCOUNT,
			wszREGCRLPERIODSTRING,
			wszREGCRLOVERLAPPERIODCOUNT,
			wszREGCRLOVERLAPPERIODSTRING,
			dwCRLPERIODCOUNTDEFAULT,	// default period
			wszCRLPERIODSTRINGDEFAULT,	// default period
			pccpBase,
			&g_fCRLPublishDisabled);
    _JumpIfError(hr, error, "crlGetRegPublishParams");

    hr = crlGetRegPublishParams(
			TRUE,
			pwszSanitizedName,
			wszREGCRLDELTAPERIODCOUNT,
			wszREGCRLDELTAPERIODSTRING,
			wszREGCRLDELTAOVERLAPPERIODCOUNT,
			wszREGCRLDELTAOVERLAPPERIODSTRING,
			dwCRLDELTAPERIODCOUNTDEFAULT,	// default period
			wszCRLDELTAPERIODSTRINGDEFAULT,	// default period
			pccpDelta,
			&g_fDeltaCRLPublishDisabled);
    _JumpIfError(hr, error, "crlGetRegPublishParams");

error:
    return(hr);
}


#define CERTSRV_CRLPUB_RETRY_COUNT_DEFAULT	10
#define CERTSRV_CRLPUB_RETRY_SECONDS		(10 * CVT_MINUTES)

	    
VOID
crlComputeTimeOutSub(
    OPTIONAL IN BOOL *pfDelta,
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut)
{
    LLFILETIME llft;

    // llft.ll = *pftLast - *pftFirst;

    llft.ll = mySubtractFileTimes(pftLast, pftFirst);
    
    DBGPRINTTIME(pfDelta, "*pftFirst", DPT_DATE, *pftFirst);
    DBGPRINTTIME(pfDelta, "*pftLast", DPT_DATE, *pftLast);

    llft.ll /= (CVT_BASE / 1000);	// convert 100ns to msecs

    DBGPRINTTIME(pfDelta, "llft", DPT_DELTAMS, llft.ft);

    if (0 > llft.ll || MAXLONG < llft.ll)
    {
	// wait as long as we can without going infinite

	llft.ll = MAXLONG;
    }
    *pdwMSTimeOut = llft.ft.dwLowDateTime;
}


VOID
crlComputeTimeOutEx(
    IN BOOL fDelta,
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut)
{
    crlComputeTimeOutSub(&fDelta, pftFirst, pftLast, pdwMSTimeOut);
}


VOID
CRLComputeTimeOut(
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut)
{
    crlComputeTimeOutSub(NULL, pftFirst, pftLast, pdwMSTimeOut);
}


#ifdef DBG_CERTSRV_DEBUG_PRINT
VOID
DbgPrintRemainTime(
    IN BOOL fDelta,
    IN FILETIME const *pftCurrent,
    IN FILETIME const *pftCRLNextPublish)
{
    HRESULT hr;
    LLFILETIME llftDelta;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];

    llftDelta.ll = mySubtractFileTimes(pftCRLNextPublish, pftCurrent);

    DBGPRINTTIME(&fDelta, "delta", DPT_DELTA, llftDelta.ft);

    llftDelta.ll = -llftDelta.ll;
    hr = myFileTimePeriodToWszTimePeriod(
			    &llftDelta.ft,
			    TRUE,	// fExact
			    &pwszTime);
    _PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
    if (S_OK != hr)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }

    DBGPRINT((
	DBG_SS_CERTSRV,
	"CRLPubWakeupEvent(tid=%d): Next %hs CRL: %ws\n",
	GetCurrentThreadId(),
	fDelta? "Delta" : "Base",
	pwszTime));
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}
#endif // DBG_CERTSRV_DEBUG_PRINT


DWORD g_aColExpiredCRL[] = {

#define ICOLEXP_ROWID		0
    DTI_CRLTABLE | DTL_ROWID,

#define ICOLEXP_MINBASE		1
    DTI_CRLTABLE | DTL_MINBASE,

#define ICOLEXP_CRLNEXTUPDATE	2
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,
};

HRESULT
crlDeleteExpiredCRLs(
    IN FILETIME const *pftCurrent,
    IN FILETIME const *pftQueryDeltaDelete,
    IN DWORD RowIdBase)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[1];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    BOOL fResultActive = FALSE;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;

    if (CRLF_DELETE_EXPIRED_CRLS & g_dwCRLFlags)
    {
	DBGPRINTTIME(NULL, "DeleteCRL:*pftCurrent", DPT_DATE, *pftCurrent);
	DBGPRINTTIME(NULL, "DeleteCRL:*pftQueryDeltaDelete", DPT_DATE, *pftQueryDeltaDelete);

	// Set up restrictions as follows:

	pcvr = acvr;

	// CRL Expiration < ftCurrent (indexed column)

	pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NEXTPUBLISHDATE;
	pcvr->SeekOperator = CVR_SEEK_LT;
	pcvr->SortOrder = CVR_SORT_ASCEND;	// Oldest propagated CRL first
	pcvr->pbValue = (BYTE *) pftCurrent;
	pcvr->cbValue = sizeof(*pftCurrent);
	pcvr++;

	CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

	hr = g_pCertDB->OpenView(
			    ARRAYSIZE(acvr),
			    acvr,
			    ARRAYSIZE(g_aColExpiredCRL),
			    g_aColExpiredCRL,
			    0,		// no worker thread
			    &pView);
	_JumpIfError(hr, error, "OpenView");

	while (TRUE)
	{
	    DWORD RowId;
	    DWORD MinBase;
	    FILETIME ftNextUpdate;
	    BOOL fDelete;
	    
	    hr = pView->Next(ARRAYSIZE(aResult), aResult, &celtFetched);
	    if (S_FALSE == hr)
	    {
		if (0 == celtFetched)
		{
		    break;
		}
	    }
	    _JumpIfError(hr, error, "Next");

	    fResultActive = TRUE;

	    CSASSERT(ARRAYSIZE(aResult) == celtFetched);

	    pResult = &aResult[0];

	    CSASSERT(ARRAYSIZE(g_aColExpiredCRL) == pResult->ccol);
	    CSASSERT(NULL != pResult->acol[ICOLEXP_ROWID].pbValue);
	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLEXP_ROWID].Type));
	    CSASSERT(sizeof(RowId) == pResult->acol[ICOLEXP_ROWID].cbValue);
	    RowId = *(DWORD *) pResult->acol[ICOLEXP_ROWID].pbValue;

	    CSASSERT(NULL != pResult->acol[ICOLEXP_MINBASE].pbValue);
	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLEXP_MINBASE].Type));
	    CSASSERT(sizeof(MinBase) == pResult->acol[ICOLEXP_MINBASE].cbValue);
	    MinBase = *(DWORD *) pResult->acol[ICOLEXP_MINBASE].pbValue;

	    CSASSERT(NULL != pResult->acol[ICOLEXP_CRLNEXTUPDATE].pbValue);
	    CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLEXP_CRLNEXTUPDATE].Type));
	    CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLEXP_CRLNEXTUPDATE].cbValue);
	    ftNextUpdate = *(FILETIME *) pResult->acol[ICOLEXP_CRLNEXTUPDATE].pbValue;

	    pView->ReleaseResultRow(celtFetched, aResult);
	    fResultActive = FALSE;

	    CSASSERT(0 != RowId);

	    // Delete the CRL row if it is not the current Base CRL and the
	    // row represents a CRL that expired prior to the current Base CRL.

	    fDelete = FALSE;
	    if (RowIdBase != RowId &&
		0 < CompareFileTime(pftQueryDeltaDelete, &ftNextUpdate))
	    {
		fDelete = TRUE;
	    }

	    DBGPRINTTIME(NULL, "DeleteCRL:ftNextUpdate", DPT_DATE, ftNextUpdate);
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"crlDeleteExpiredCRLs(RowId=%x) %ws\n",
		RowId,
		fDelete? L"DELETE" : L"SKIP"));

	    if (fDelete)
	    {
		ICertDBRow *prow;

		hr = g_pCertDB->OpenRow(
				    PROPOPEN_DELETE | PROPTABLE_CRL,
				    RowId,
				    NULL,
				    &prow);
		_JumpIfError(hr, error, "OpenRow");

		hr = prow->Delete();
		_PrintIfError(hr, "Delete");

		if (S_OK == hr)
		{
		    hr = prow->CommitTransaction(TRUE);
		    _PrintIfError(hr, "CommitTransaction");
		}
		if (S_OK != hr)
		{
		    HRESULT hr2 = prow->CommitTransaction(FALSE);
		    _PrintIfError(hr2, "CommitTransaction");
		}
		prow->Release();
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    return(hr);
}
#undef ICOLEXP_ROWID
#undef ICOLEXP_MINBASE
#undef ICOLEXP_CRLNEXTUPDATE


///////////////////////////////////////////////////
// CRLPubWakeupEvent is the handler for wakeup notifications.
//
// This function is called at miscellaneous times and
// determines whether or not it is time to rebuild the
// CRL to be published.
//
// It then calls CRLPublishCRLs and advises it as to whether to
// rebuild or not.
//
// Its final task is to recalculate the next wakeup time, which
// depends on current time, if the exit module needs to be retried,
// or whether CRL publishing is disabled.

HRESULT
CRLPubWakeupEvent(
    OUT DWORD *pdwMSTimeOut)
{
    HRESULT hr;
    HRESULT hrPublish;
    FILETIME ftZero;
    FILETIME ftCurrent;
    BOOL fBaseTrigger = TRUE;
    BOOL fRebuildCRL = FALSE;
    BOOL fForceRepublish = FALSE;
    BOOL fShadowDelta = FALSE;
    BOOL fSetRetryTimer = FALSE;
    DWORD dwMSTimeOut = CERTSRV_CRLPUB_RETRY_SECONDS * 1000;
    DWORD State = 0;
    static BOOL s_fFirstWakeup = TRUE;

    CSASSERT(NULL != pdwMSTimeOut);

    // if anything goes wrong, call us again after a pause

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	BOOL fCRLPublishDisabledOld = g_fCRLPublishDisabled;
	BOOL fDeltaCRLPublishDisabledOld = g_fDeltaCRLPublishDisabled;

        // Recalc Timeout
        GetSystemTimeAsFileTime(&ftCurrent);

#ifdef DBG_CERTSRV_DEBUG_PRINT
	{
	    WCHAR *pwszNow = NULL;

	    myGMTFileTimeToWszLocalTime(&ftCurrent, TRUE, &pwszNow);

	    DBGPRINT((DBG_SS_CERTSRV, "CRLPubWakeupEvent(%ws)\n", pwszNow));

	    if (NULL != pwszNow)
	    {
		LocalFree(pwszNow);
	    }
	}
#endif // DBG_CERTSRV_DEBUG_PRINT

	// get current publish params

	hr = crlGetRegCRLPublishParams(g_wszSanitizedName, NULL, NULL);
	_LeaveIfError(hr, "crlGetRegCRLPublishParams");

	if (s_fFirstWakeup)
	{
	    s_fFirstWakeup = FALSE;
	    if (g_fDBRecovered)
	    {
		fForceRepublish = TRUE;
	    }
	}
	else
	{
	    if (!g_fCRLPublishDisabled &&
		(fCRLPublishDisabledOld ||
		 g_fDeltaCRLPublishDisabled != fDeltaCRLPublishDisabledOld))
	    {
		fRebuildCRL = TRUE;	// state change: force new CRLs

		// If delta CRLs were just now disabled, make one attempt to
		// publish shadow deltas; force clients to fetch a new base CRL.

		if (!fDeltaCRLPublishDisabledOld && g_fDeltaCRLPublishDisabled)
		{
		    fShadowDelta = TRUE;	// force shadow delta
		}
	    }
	}

        // if "not yet ready"

	if (0 < CompareFileTime(&g_ftCRLNextPublish, &ftCurrent))
	{
	    fBaseTrigger = FALSE;
#ifdef DBG_CERTSRV_DEBUG_PRINT
	    // give next pub status
	    DbgPrintRemainTime(FALSE, &ftCurrent, &g_ftCRLNextPublish);
#endif // DBG_CERTSRV_DEBUG_PRINT
	}

        // if "not yet ready"

	if (!fBaseTrigger &&
	    (g_fDeltaCRLPublishDisabled ||
	     0 < CompareFileTime(&g_ftDeltaCRLNextPublish, &ftCurrent)))
	{
#ifdef DBG_CERTSRV_DEBUG_PRINT
	    // give next pub status
	    if (!g_fDeltaCRLPublishDisabled)
	    {
		DbgPrintRemainTime(TRUE, &ftCurrent, &g_ftDeltaCRLNextPublish);
	    }
#endif // DBG_CERTSRV_DEBUG_PRINT
	}
	else    // "ready to publish" trigger
	{
            if (!g_fCRLPublishDisabled)		// is publishing enabled?
	    {
                fRebuildCRL = TRUE;		// ENABLED, ready to go!
	    }
	    else
            {
                DBGPRINT((
                    DBG_SS_CERTSRV,
                    "CRLPubWakeupEvent(tid=%d): Publishing disabled\n",
                    GetCurrentThreadId() ));
            }
        }

	ftZero.dwLowDateTime = 0;
	ftZero.dwHighDateTime = 0;

	while (TRUE)
	{
	    hr = CRLPublishCRLs(
		    fRebuildCRL,
		    fForceRepublish,
		    NULL,				// pwszUserName
		    !fForceRepublish &&			// fDeltaOnly
			!fBaseTrigger &&
			!g_fDeltaCRLPublishDisabled &&
			!fDeltaCRLPublishDisabledOld,
		    fShadowDelta,
		    ftZero,
		    &fSetRetryTimer,
		    &hrPublish);
	    if (S_OK == hr)
	    {
		break;
	    }
	    _PrintError(hr, "CRLPublishCRLs");

	    if (!fForceRepublish || fRebuildCRL)
	    {
		_leave;		// give up
	    }

	    // We failed to republish existing CRLs after a database restore
	    // and recovery; generate new base and delta CRLs and publish them.

	    fRebuildCRL = TRUE;
	}
	_PrintIfError(hrPublish, "CRLPublishCRLs(hrPublish)");

        // if we called CRLPublishCRLs, clear the manual event it'll trigger

        ResetEvent(g_hCRLManualPublishEvent);

        // how many ms until next publish?  set dwMSTimeOut

        if (g_fCRLPublishDisabled)
        {
            // if disabled, don't set timeout
            dwMSTimeOut = INFINITE;
            CONSOLEPRINT1((
			DBG_SS_CERTSRV,
			"CRL Publishing Disabled, TimeOut=INFINITE (%d ms)\n",
			dwMSTimeOut));
        }
        else
        {
            DWORD dwMSTimeOutDelta;
	    WCHAR *pwszCRLType = NULL;

	    crlComputeTimeOutEx(
			FALSE,
			&ftCurrent,
			&g_ftCRLNextPublish,
			&dwMSTimeOut);

	    if (g_fDeltaCRLPublishDisabled)
	    {
		pwszCRLType = L"Base";
	    }
	    else
	    {
		crlComputeTimeOutEx(
			    TRUE,
			    &ftCurrent,
			    &g_ftDeltaCRLNextPublish,
			    &dwMSTimeOutDelta);
		if (dwMSTimeOut > dwMSTimeOutDelta)
		{
		    dwMSTimeOut = dwMSTimeOutDelta;
		}
		pwszCRLType = L"Base + Delta";
	    }
	    if (NULL != pwszCRLType)
	    {
		LONGLONG ll;
		WCHAR *pwszTimePeriod = NULL;
		WCHAR awc[1];

		ll = dwMSTimeOut;
		ll *= CVT_BASE / 1000;	// milliseconds to FILETIME Period
		ll = -ll;		// FILETIME Period must be negative

		hr = myFileTimePeriodToWszTimePeriod(
				    (FILETIME const *) &ll,
				    TRUE,	// fExact
				    &pwszTimePeriod);
		_PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
		if (S_OK != hr)
		{
		    awc[0] = L'\0';
		    pwszTimePeriod = awc;
		}
		CONSOLEPRINT3((
			DBG_SS_CERTSRV,
			"%ws CRL Publishing Enabled, TimeOut=%ds, %ws\n",
			pwszCRLType,
			dwMSTimeOut/1000,
			pwszTimePeriod));
		if (NULL != pwszTimePeriod && awc != pwszTimePeriod)
		{
		    LocalFree(pwszTimePeriod);
		}
	    }
        }

        // if we need to retry, wait no longer than the retry period

        if (fSetRetryTimer)
        {
            if (dwMSTimeOut > CERTSRV_CRLPUB_RETRY_SECONDS * 1000)
            {
                dwMSTimeOut = CERTSRV_CRLPUB_RETRY_SECONDS * 1000;
                CONSOLEPRINT1((
			DBG_SS_CERTSRV,
			"CRL Publishing periodic retry, TimeOut=%ds\n",
			dwMSTimeOut/1000));
            }
        }
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    *pdwMSTimeOut = dwMSTimeOut;
    CertSrvExitServer(State);
    return(hr);
}


HRESULT
WriteToLockedFile(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN LPCWSTR szFileDir,
    IN LPCWSTR szFile)
{
    HRESULT hr;
    WCHAR wszTmpPrepFile[MAX_PATH];
    WCHAR wszTmpInUseFile[MAX_PATH];
    BYTE *pbData = NULL;
    DWORD cbData;

    // According to JohnL, the best way to do this is to gen a temp
    // file name, rename the existing file to that, then delete it.
    //
    // Logic:
    // create unique preparation filename
    // write new data to prep file
    // create unique destination filename for old file (possibly locked)
    // move old file to destination filename
    // move prep file to (vacated) file name
    // delete old file from destination filename

    hr = DecodeFileW(szFile, &pbData, &cbData, CRYPT_STRING_BINARY);
    if (S_OK == hr &&
	cbEncoded == cbData &&
	0 == memcmp(pbData, pbEncoded, cbData))
    {
	CSASSERT(S_OK == hr);
	goto error;		// already written, do nothing
    }

    // create a prep file

    if (0 == GetTempFileName(szFileDir, L"pre", 0, wszTmpPrepFile))
    {
        hr = myHLastError();
	_JumpError(hr, error, "GetTempFileName");
    }

    // write file to prep area

    hr = EncodeToFileW(
		wszTmpPrepFile,
		pbEncoded,
		cbEncoded,
		DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
    _JumpIfError(hr, error, "EncodeToFileW");

    if (0 == GetTempFileName(szFileDir, L"crl", 0, wszTmpInUseFile))
    {
        hr = myHLastError();
	_JumpError(hr, error, "GetTempFileName");
    }

    // move old to "in use" file (empty file already exists from
    // GetTempFileName call) may not exist, so don't bother checking status

    MoveFileEx(
	    szFile,
	    wszTmpInUseFile,
	    MOVEFILE_WRITE_THROUGH | MOVEFILE_REPLACE_EXISTING);

    // move prepared file to current file

    if (!MoveFileEx(wszTmpPrepFile, szFile, MOVEFILE_WRITE_THROUGH))
    {
        hr = myHLastError();
	_JumpError(hr, error, "MoveFileEx");
    }

    // The "in use" file may not exist, so don't bother checking status.
    DeleteFile(wszTmpInUseFile);
    hr = S_OK;

error:
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    return(hr);
}


WCHAR const g_wszPropCRLNumber[] = wszPROPCRLNUMBER;
WCHAR const g_wszPropCRLMinBase[] = wszPROPCRLMINBASE;
WCHAR const g_wszPropCRLNameId[] = wszPROPCRLNAMEID;
WCHAR const g_wszPropCRLCount[] = wszPROPCRLCOUNT;
WCHAR const g_wszPropCRLThisUpdateDate[] = wszPROPCRLTHISUPDATE;
WCHAR const g_wszPropCRLNextUpdateDate[] = wszPROPCRLNEXTUPDATE;
WCHAR const g_wszPropCRLThisPublishDate[] = wszPROPCRLTHISPUBLISH;
WCHAR const g_wszPropCRLNextPublishDate[] = wszPROPCRLNEXTPUBLISH;
WCHAR const g_wszPropCRLEffectiveDate[] = wszPROPCRLEFFECTIVE;
WCHAR const g_wszPropCRLPropagationCompleteDate[] = wszPROPCRLPROPAGATIONCOMPLETE;
WCHAR const g_wszPropCRLLastPublished[] = wszPROPCRLLASTPUBLISHED;
WCHAR const g_wszPropCRLPublishAttempts[] = wszPROPCRLPUBLISHATTEMPTS;
WCHAR const g_wszPropCRLPublishFlags[] = wszPROPCRLPUBLISHFLAGS;
WCHAR const g_wszPropCRLPublishStatusCode[] = wszPROPCRLPUBLISHSTATUSCODE;
WCHAR const g_wszPropCRLPublishError[] = wszPROPCRLPUBLISHERROR;
WCHAR const g_wszPropCRLRawCRL[] = wszPROPCRLRAWCRL;

HRESULT
crlWriteCRLToDB(
    IN DWORD CRLNumber,
    IN DWORD CRLMinBase,		// 0 implies base CRL
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN DWORD CRLNameId,
    IN DWORD CRLCount,
    IN FILETIME const *pftThisUpdate,
    IN FILETIME const *pftNextUpdate,
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftNextPublish,
    OPTIONAL IN FILETIME const *pftQuery,
    IN FILETIME const *pftPropagationComplete,
    OPTIONAL IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    OUT DWORD *pdwRowId)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD CRLPublishFlags;
    BOOL fCommitted = FALSE;

    *pdwRowId = 0;

    // Create a new CRL table entry

    hr = g_pCertDB->OpenRow(
			PROPTABLE_CRL,
			0,
			NULL,
			&prow);
    _JumpIfError(hr, error, "OpenRow");

    prow->GetRowId(pdwRowId);

    hr = prow->SetProperty(
		    g_wszPropCRLNumber,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLNumber),
		    (BYTE const *) &CRLNumber);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLMinBase,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLMinBase),
		    (BYTE const *) &CRLMinBase);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLNameId,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLNameId),
		    (BYTE const *) &CRLNameId);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLCount,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLCount),
		    (BYTE const *) &CRLCount);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLThisUpdateDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftThisUpdate),
                    (BYTE const *) pftThisUpdate);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLNextUpdateDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftNextUpdate),
                    (BYTE const *) pftNextUpdate);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLThisPublishDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftThisPublish),
                    (BYTE const *) pftThisPublish);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLNextPublishDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftNextPublish),
                    (BYTE const *) pftNextPublish);
    _JumpIfError(hr, error, "SetProperty");

    if (NULL != pftQuery)
    {
	hr = prow->SetProperty(
			g_wszPropCRLEffectiveDate,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
			sizeof(*pftQuery),
			(BYTE const *) pftQuery);
	_JumpIfError(hr, error, "SetProperty");
    }

    hr = prow->SetProperty(
		    g_wszPropCRLPropagationCompleteDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftPropagationComplete),
                    (BYTE const *) pftPropagationComplete);
    _JumpIfError(hr, error, "SetProperty");

    CRLPublishFlags = 0 == CRLMinBase? CPF_BASE : CPF_DELTA;
    if (fShadowDelta)
    {
	CRLPublishFlags |= CPF_SHADOW;
    }
    if (NULL != pwszUserName)
    {
	CRLPublishFlags |= CPF_MANUAL;
    }
    hr = prow->SetProperty(
		    g_wszPropCRLPublishFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLPublishFlags),
		    (BYTE const *) &CRLPublishFlags);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLRawCRL,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CRL,
		    cbCRL,
		    pbCRL);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    return(hr);
}


HRESULT
crlCombineCRLError(
    IN ICertDBRow *prow,
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    OPTIONAL IN WCHAR const *pwszCRLError,
    OUT WCHAR **ppwszCRLErrorNew)
{
    HRESULT hr;
    WCHAR *pwszCRLErrorOld = NULL;
    WCHAR *pwszCRLErrorNew = NULL;
    WCHAR *pwsz;
    DWORD cwc;
    DWORD cwc2;

    *ppwszCRLErrorNew = NULL;

    hr = PKCSGetProperty(
		    prow,
		    g_wszPropCRLPublishError,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CRL,
		    NULL,
		    (BYTE **) &pwszCRLErrorOld);
    _PrintIfError2(hr, "PKCSGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    cwc = 0;
    if (NULL != pwszCRLErrorOld)
    {
	pwsz = wcsstr(pwszCRLErrorOld, L"\n\n");
	if (NULL == pwsz)
	{
	    pwsz = pwszCRLErrorOld;
	}
	*pwsz = L'\0';
	cwc = wcslen(pwszCRLErrorOld);
	if (0 != cwc)
	{
	    cwc++;			// newline separator
	}
    }
    if (NULL != pwszUserName)
    {
	cwc2 = wcslen(g_pwszPublishedBy) + wcslen(pwszUserName);
	cwc += cwc2;
    }
    else
    {
	cwc++;
    }
    cwc += 2;				// double newline separator
    if (NULL != pwszCRLError)
    {
	cwc += wcslen(pwszCRLError);
    }
    pwszCRLErrorNew = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszCRLErrorNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    *pwszCRLErrorNew = L'\0';
    if (NULL != pwszCRLErrorOld && L'\0' != *pwszCRLErrorOld)
    {
	wcscpy(pwszCRLErrorNew, pwszCRLErrorOld);
	wcscat(pwszCRLErrorNew, L"\n");
    }
    if (NULL != pwszUserName)
    {
	pwsz = &pwszCRLErrorNew[wcslen(pwszCRLErrorNew)];
	_snwprintf(pwsz, cwc2, g_pwszPublishedBy, pwszUserName);
    }
    else
    {
	wcscat(pwszCRLErrorNew, L"-");
    }
    wcscat(pwszCRLErrorNew, L"\n\n");	// double newline separator
    if (NULL != pwszCRLError)
    {
	wcscat(pwszCRLErrorNew, pwszCRLError);
    }
    CSASSERT(wcslen(pwszCRLErrorNew) <= cwc);
    CSASSERT(
	wcslen(pwszCRLErrorNew) +
	(NULL != pwszUserName? wcslen(L"%ws") : 0) == cwc);
    *ppwszCRLErrorNew = pwszCRLErrorNew;
    pwszCRLErrorNew = NULL;
    hr = S_OK;

error:
    if (NULL != pwszCRLErrorOld)
    {
	LocalFree(pwszCRLErrorOld);
    }
    if (NULL != pwszCRLErrorNew)
    {
	LocalFree(pwszCRLErrorNew);
    }
    return(hr);
}


HRESULT
crlUpdateCRLPublishStateInDB(
    IN DWORD RowId,
    IN FILETIME const *pftCurrent,
    IN HRESULT hrCRLPublish,
    IN DWORD CRLPublishFlags,
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    OPTIONAL IN WCHAR const *pwszCRLError)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    WCHAR *pwszCRLErrorNew = NULL;
    DWORD cb;
    DWORD dw;
    BOOL fCommitted = FALSE;

    hr = g_pCertDB->OpenRow(
			PROPTABLE_CRL,
			RowId,
			NULL,
			&prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = prow->SetProperty(
		    g_wszPropCRLLastPublished,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftCurrent),
                    (BYTE const *) pftCurrent);
    _JumpIfError(hr, error, "SetProperty");

    cb = sizeof(dw);
    hr = prow->GetProperty(
		    g_wszPropCRLPublishAttempts,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    &cb,
		    (BYTE *) &dw);
    if (S_OK != hr)
    {
	dw = 0;
    }
    dw++;

    hr = prow->SetProperty(
		    g_wszPropCRLPublishAttempts,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(dw),
		    (BYTE const *) &dw);
    _JumpIfError(hr, error, "SetProperty");

    cb = sizeof(dw);
    hr = prow->GetProperty(
		    g_wszPropCRLPublishFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    &cb,
		    (BYTE *) &dw);
    if (S_OK != hr)
    {
	dw = 0;
    }
    CRLPublishFlags |= (CPF_BASE | CPF_DELTA | CPF_SHADOW | CPF_MANUAL) & dw;
    if (S_OK == hrCRLPublish)
    {
	CRLPublishFlags |= CPF_COMPLETE;
    }
    hr = prow->SetProperty(
		    g_wszPropCRLPublishFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLPublishFlags),
		    (BYTE const *) &CRLPublishFlags);
    _JumpIfError(hr, error, "SetProperty");

    // Always set error string property to clear out previous errors.

    hr = prow->SetProperty(
		    g_wszPropCRLPublishStatusCode,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(hrCRLPublish),
		    (BYTE const *) &hrCRLPublish);
    _JumpIfError(hr, error, "SetProperty");

    hr = crlCombineCRLError(prow, pwszUserName, pwszCRLError, &pwszCRLErrorNew);
    _JumpIfError(hr, error, "crlCombineCRLError");

    hr = prow->SetProperty(
		    g_wszPropCRLPublishError,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CRL,
		    NULL == pwszCRLErrorNew? 0 : MAXDWORD,
		    (BYTE const *) pwszCRLErrorNew);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pwszCRLErrorNew)
    {
	LocalFree(pwszCRLErrorNew);
    }
    return(hr);
}


HRESULT
WriteCRLToDSAttribute(
    IN WCHAR const *pwszCRLDN,
    IN BOOL fDelta,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD ldaperr;
    BOOL fRebind = FALSE;

    LDAPMod crlmod;
    struct berval crlberval;
    struct berval *crlVals[2];
    LDAPMod *mods[2];

    while (TRUE)
    {
	if (NULL == g_pld)
	{
	    hr = myRobustLdapBind(&g_pld, FALSE);
	    _JumpIfError(hr, error, "myRobustLdapBind");
	}

	mods[0] = &crlmod;
	mods[1] = NULL;

	crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
	crlmod.mod_type = fDelta? wszDSDELTACRLATTRIBUTE : wszDSBASECRLATTRIBUTE;
	crlmod.mod_bvalues = crlVals;

	crlVals[0] = &crlberval;
	crlVals[1] = NULL;

	crlberval.bv_len = cbCRL;
	crlberval.bv_val = (char *) pbCRL;

	ldaperr = ldap_modify_ext_s(
			    g_pld,
			    const_cast<WCHAR *>(pwszCRLDN),
			    mods,
			    NULL,
			    NULL);
	hr = myHLdapError(g_pld, ldaperr, ppwszError);
	_PrintIfErrorStr(hr, "ldap_modify_ext_s", pwszCRLDN);
	if (fRebind || S_OK == hr)
	{
	    break;
	}
	if (!myLdapRebindRequired(ldaperr, g_pld))
	{
	    _JumpErrorStr(hr, error, "ldap_modify_ext_s", pwszCRLDN);
	}
	fRebind = TRUE;
	if (NULL != g_pld)
	{
	    ldap_unbind(g_pld);
	    g_pld = NULL;
	}
    }

error:
    return(hr);
}


HRESULT
crlParseURLPrefix(
    IN WCHAR const *pwszIn,
    IN DWORD cwcPrefix,
    OUT WCHAR *pwcPrefix,
    OUT WCHAR const **ppwszOut)
{
    HRESULT hr;
    WCHAR const *pwsz;

    CSASSERT(6 <= cwcPrefix);
    wcscpy(pwcPrefix, L"file:");
    *ppwszOut = pwszIn;

    if (L'\\' != pwszIn[0] || L'\\' != pwszIn[1])
    {
	pwsz = wcschr(pwszIn, L':');
	if (NULL != pwsz)
	{
	    DWORD cwc;

	    pwsz++;
	    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszIn);
	    if (2 < cwc && cwc < cwcPrefix)
	    {
		CopyMemory(pwcPrefix, pwszIn, cwc * sizeof(WCHAR));
		pwcPrefix[cwc] = L'\0';
		if (0 == lstrcmpi(pwcPrefix, L"file:") &&
		    L'/' == pwsz[0] &&
		    L'/' == pwsz[1])
		{
		    pwsz += 2;
		}
		*ppwszOut = pwsz;
	    }
	}
    }
    hr = S_OK;

//error:
    return(hr);
}


VOID
crlLogError(
    IN BOOL fDelta,
    IN BOOL fLdapURL,
    IN DWORD iKey,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszError,
    IN HRESULT hrPublish)
{
    HRESULT hr;
    WCHAR const *apwsz[6];
    WORD cpwsz;
    WCHAR wszKey[11 + 1];
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszMessageText = NULL;
    WCHAR *pwszHostName = NULL;
    DWORD LogMsg;

    if (fLdapURL && NULL != g_pld)
    {
	myLdapGetDSHostName(g_pld, &pwszHostName);
    }

    wsprintf(wszKey, L"%u", iKey);
    pwszMessageText = myGetErrorMessageText(hrPublish, TRUE);
    if (NULL == pwszMessageText)
    {
	pwszMessageText = myHResultToStringRaw(awchr, hrPublish);
    }
    cpwsz = 0;
    apwsz[cpwsz++] = wszKey;
    apwsz[cpwsz++] = pwszURL;
    apwsz[cpwsz++] = pwszMessageText;

    LogMsg = fDelta?
	MSG_E_DELTA_CRL_PUBLICATION : MSG_E_BASE_CRL_PUBLICATION;
    if (NULL != pwszHostName)
    {
	LogMsg = fDelta?
	    MSG_E_DELTA_CRL_PUBLICATION_HOST_NAME :
	    MSG_E_BASE_CRL_PUBLICATION_HOST_NAME;
    }
    else
    {
	pwszHostName = L"";
    }
    apwsz[cpwsz++] = pwszHostName;
    apwsz[cpwsz++] = NULL != pwszError? L"\n" : L"";
    apwsz[cpwsz++] = NULL != pwszError? pwszError : L"";
    CSASSERT(ARRAYSIZE(apwsz) >= cpwsz);

    if (CERTLOG_ERROR <= g_dwLogLevel)
    {
	hr = LogEvent(EVENTLOG_ERROR_TYPE, LogMsg, cpwsz, apwsz);
	_PrintIfError(hr, "LogEvent");
    }

//error:
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
}


HRESULT
crlWriteCRLToURL(
    IN BOOL fDelta,
    IN BOOL iKey,
    IN WCHAR const *pwszURL,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    OUT DWORD *pPublishFlags)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR const *pwsz2;
    WCHAR *pwszT;
    WCHAR awcPrefix[6];		// file:/ftp:/http:/ldap: and trailing '\0'
    DWORD ErrorFlags;
    WCHAR *pwszError = NULL;

    *pPublishFlags = 0;

    ErrorFlags = CPF_BADURL_ERROR;
    hr = crlParseURLPrefix(
		    pwszURL,
		    ARRAYSIZE(awcPrefix),
		    awcPrefix,
		    &pwsz2);
    _JumpIfError(hr, error, "crlParseURLPrefix");

    DBGPRINT((
	DBG_SS_CERTSRV,
	"crlWriteCRLToURL: \"%ws\" %ws\n",
	awcPrefix,
	pwsz2));
    if (0 == lstrcmpi(awcPrefix, L"file:"))
    {
	ErrorFlags = CPF_FILE_ERROR;
	hr = myDupString(pwsz2, &pwszDup);
	_JumpIfError(hr, error, "myDupString");

	pwszT = wcsrchr(pwszDup, L'\\');
	if (NULL != pwszT)
	{
	    *pwszT = L'\0';	// for dir path, remove "\filename.crl"
	}

	// tricky
	hr = WriteToLockedFile(pbCRL, cbCRL, pwszDup, pwsz2);
	_JumpIfError(hr, error, "WriteToLockedFile");
    }
    else if (0 == lstrcmpi(awcPrefix, L"ftp:"))
    {
	ErrorFlags = CPF_FTP_ERROR;
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpError(hr, error, "Publish to ftp:");
    }
    else if (0 == lstrcmpi(awcPrefix, L"http:"))
    {
	ErrorFlags = CPF_HTTP_ERROR;
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpError(hr, error, "Publish to http:");
    }
    else if (0 == lstrcmpi(awcPrefix, L"ldap:"))
    {
	ErrorFlags = CPF_LDAP_ERROR;
	while (L'/' == *pwsz2)
	{
	    pwsz2++;
	}
	hr = myDupString(pwsz2, &pwszDup);
	_JumpIfError(hr, error, "myDupString");

	pwszT = wcschr(pwszDup, L'?');
	if (NULL != pwszT)
	{
	    *pwszT = L'\0';
	}
	hr = WriteCRLToDSAttribute(pwszDup, fDelta, pbCRL, cbCRL, &pwszError);
	_JumpIfError(hr, error, "WriteCRLToDSAttribute");
    }
    else
    {
	ErrorFlags = CPF_BADURL_ERROR;
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpError(hr, error, "Publish to unknown URL type");
    }
    CSASSERT(S_OK == hr);

error:
    if (S_OK != hr)
    {
	*pPublishFlags = ErrorFlags;
	crlLogError(
		fDelta,
		CPF_LDAP_ERROR == ErrorFlags,
		iKey,
		pwszURL,
		pwszError,
		hr);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
crlWriteCRLToURLList(
    IN BOOL fDelta,
    IN DWORD iKey,
    IN WCHAR const * const *papwszURLs,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    IN OUT DWORD *pCRLPublishFlags,
    OUT WCHAR **ppwszCRLError)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    WCHAR *pwszCRLError = NULL;
    DWORD PublishFlags;

    *ppwszCRLError = NULL;

    // publish this CRL in multiple places

    if (NULL != papwszURLs)
    {
	WCHAR const * const *ppwsz;

	for (ppwsz = papwszURLs; NULL != *ppwsz; ppwsz++)
	{
	    PublishFlags = 0;

	    hr2 = crlWriteCRLToURL(
			    fDelta,
			    iKey,
			    *ppwsz,
			    pbCRL,
			    cbCRL,
			    &PublishFlags);
	    *pCRLPublishFlags |= PublishFlags;
	    if (S_OK != hr2)
	    {
		DWORD cwc;
		WCHAR *pwsz;

		if (S_OK == hr)
		{
		    hr = hr2;		// Save first error
		}
		_PrintError(hr2, "crlWriteCRLToURL");

		cwc = wcslen(*ppwsz) + 1;
		if (NULL != pwszCRLError)
		{
		    cwc += wcslen(pwszCRLError) + 1;
		}
		pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
		if (NULL == pwsz)
		{
		    hr2 = E_OUTOFMEMORY;
		    _PrintError(hr2, "LocalAlloc");
		    if (S_OK == hr)
		    {
			hr = hr2;		// Save first error
		    }
		}
		else
		{
		    pwsz[0] = L'\0';
		    if (NULL != pwszCRLError)
		    {
			wcscpy(pwsz, pwszCRLError);
			wcscat(pwsz, L"\n");
			LocalFree(pwszCRLError);
		    }
		    wcscat(pwsz, *ppwsz);
		    pwszCRLError = pwsz;
		}
	    }
	}
    }
    *ppwszCRLError = pwszCRLError;
    pwszCRLError = NULL;

//error:
    if (NULL != pwszCRLError)
    {
	LocalFree(pwszCRLError);
    }
    return(hr);
}


HRESULT
crlIsDeltaCRL(
    IN CRL_CONTEXT const *pCRL,
    OUT BOOL *pfIsDeltaCRL)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;

    *pfIsDeltaCRL = FALSE;
    pExt = CertFindExtension(
		    szOID_DELTA_CRL_INDICATOR,
		    pCRL->pCrlInfo->cExtension,
		    pCRL->pCrlInfo->rgExtension);
    if (NULL != pExt)
    {
	*pfIsDeltaCRL = TRUE;
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
crlWriteCRLToCAStore(
    IN BOOL fDelta,
    IN DWORD iKey,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    IN CERT_CONTEXT const *pccCA)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CRL_CONTEXT const *pCRLStore = NULL;
    CRL_CONTEXT const *pCRLNew = NULL;
    BOOL fFound = FALSE;

    hStore = CertOpenStore(
                       CERT_STORE_PROV_SYSTEM_W,
                       X509_ASN_ENCODING,
                       NULL,			// hProv
                       CERT_SYSTEM_STORE_LOCAL_MACHINE,
		       wszCA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    while (TRUE)
    {
	DWORD dwCryptFlags;
	BOOL fIsDeltaCRL;
	CRL_CONTEXT const *pCRL;

	dwCryptFlags = CERT_STORE_SIGNATURE_FLAG;
	pCRLStore = CertGetCRLFromStore(
				    hStore,
				    pccCA,
				    pCRLStore,
				    &dwCryptFlags);
	if (NULL == pCRLStore)
	{
	    break;
	}

	// delete this CRL from the store ONLY if the CRL signature matches
	// this CA context's public key

	if (0 != dwCryptFlags)
	{
	    continue;		// no match -- skip
	}

	hr = crlIsDeltaCRL(pCRLStore, &fIsDeltaCRL);
	_JumpIfError(hr, error, "crlIsDeltaCRL");

	if (fIsDeltaCRL)
	{
	    if (!fDelta)
	    {
		continue;	// no match -- skip Delta CRLs
	    }
	}
	else
	{
	    if (fDelta)
	    {
		continue;	// no match -- skip Base CRLs
	    }
	}

	// See if it has already been published

	if (cbCRL == pCRLStore->cbCrlEncoded &&
	    0 == memcmp(pbCRL, pCRLStore->pbCrlEncoded, cbCRL))
	{
	    fFound = TRUE;
	    continue;		// exact match -- already published
	}

	pCRL = CertDuplicateCRLContext(pCRLStore);
	if (!CertDeleteCRLFromStore(pCRL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDeleteCRLFromStore");
	}
    }

    if (!fFound)
    {
	pCRLNew = CertCreateCRLContext(X509_ASN_ENCODING, pbCRL, cbCRL);
	if (NULL == pCRLNew)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCRLContext");
	}

	if (!CertAddCRLContextToStore(
				  hStore,
				  pCRLNew,
				  CERT_STORE_ADD_ALWAYS,
				  NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCRLContextToStore");
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	crlLogError(fDelta, FALSE, iKey, g_pwszIntermediateCAStore, NULL, hr);
    }
    if (NULL != pCRLNew)
    {
        CertFreeCRLContext(pCRLNew);
    }
    if (NULL != pCRLStore)
    {
        CertFreeCRLContext(pCRLStore);
    }
    if (NULL != hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
crlPublishGeneratedCRL(
    IN DWORD RowId,
    IN FILETIME const *pftCurrent,
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDelta,
    IN DWORD iKey,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    IN CACTX const *pCAContext,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrCRLPublish)
{
    HRESULT hr;
    HRESULT hrCRLPublish;
    DWORD CRLPublishFlags;
    WCHAR *pwszCRLError = NULL;

    *pfRetryNeeded = FALSE;
    hrCRLPublish = S_OK;
    CRLPublishFlags = 0;

    hr = crlWriteCRLToCAStore(fDelta, iKey, pbCRL, cbCRL, pCAContext->pccCA);
    if (S_OK != hr)
    {
	_PrintError(hr, "crlWriteCRLToCAStore");
	hrCRLPublish = hr;
	CRLPublishFlags |= CPF_CASTORE_ERROR;
    }

    hr = crlWriteCRLToURLList(
			fDelta,
			iKey,
			fDelta?
			    pCAContext->papwszDeltaCRLFiles :
			    pCAContext->papwszCRLFiles,
			pbCRL,
			cbCRL,
			&CRLPublishFlags,
			&pwszCRLError);
    if (S_OK != hr)
    {
	_PrintError(hr, "crlWriteCRLToURLList");
	if (S_OK == hrCRLPublish)
	{
	    hrCRLPublish = hr;		// save first error
	}
    }
    if (S_OK != hrCRLPublish)
    {
	*pfRetryNeeded = TRUE;
    }
    hr = crlUpdateCRLPublishStateInDB(
				RowId,
				pftCurrent,
				hrCRLPublish,
				CRLPublishFlags,
				pwszUserName,
				pwszCRLError);
    _JumpIfError(hr, error, "crlUpdateCRLPublishStateInDB");

error:
    *phrCRLPublish = hrCRLPublish;
    if (NULL != pwszCRLError)
    {
        LocalFree(pwszCRLError);
    }
    return(hr);
}


HRESULT
crlSignAndSaveCRL(
    IN DWORD CRLNumber,
    IN DWORD CRLNumberBaseMin,		// 0 implies Base CRL; else Delta CRL
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN CACTX const *pCAContext,
    IN DWORD cCRL,
    IN CRL_ENTRY *aCRL,
    IN FILETIME const *pftCurrent,
    IN FILETIME const *pftThisUpdate,	// includes skew
    IN FILETIME const *pftNextUpdate,	// includes skew & overlap
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftNextPublish,
    OPTIONAL IN FILETIME const *pftQuery,
    IN FILETIME const *pftPropagationComplete,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrCRLPublish)
{
    HRESULT hr;
    CRL_INFO CRLInfo;
    DWORD i;
    DWORD cb;
    DWORD cbCRL;
    BYTE *pbCrlEncoded = NULL;
    BYTE *pbCRL = NULL;
#define CCRLEXT	6
    CERT_EXTENSION aext[CCRLEXT];
    BYTE *apbFree[CCRLEXT];
    DWORD cpbFree = 0;
    DWORD RowId;

    *pfRetryNeeded = FALSE;
    *phrCRLPublish = S_OK;

    ZeroMemory(&CRLInfo, sizeof(CRLInfo));
    CRLInfo.dwVersion = CRL_V2;
    CRLInfo.SignatureAlgorithm.pszObjId = pCAContext->pszObjIdSignatureAlgorithm;
    CRLInfo.Issuer.pbData = pCAContext->pccCA->pCertInfo->Subject.pbData;
    CRLInfo.Issuer.cbData = pCAContext->pccCA->pCertInfo->Subject.cbData;
    CRLInfo.ThisUpdate = *pftThisUpdate;
    CRLInfo.NextUpdate = *pftNextUpdate;
    CRLInfo.cCRLEntry = cCRL;
    CRLInfo.rgCRLEntry = aCRL;

    CRLInfo.cExtension = 0;
    CRLInfo.rgExtension = aext;
    ZeroMemory(aext, sizeof(aext));

    if (NULL != pCAContext->KeyAuthority2CRL.pbData)
    {
	aext[CRLInfo.cExtension].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER2;
	if (EDITF_ENABLEAKICRITICAL & g_CRLEditFlags)
	{
	    aext[CRLInfo.cExtension].fCritical = TRUE;
	}
	aext[CRLInfo.cExtension].Value = pCAContext->KeyAuthority2CRL;
	CRLInfo.cExtension++;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &pCAContext->NameId,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aext[CRLInfo.cExtension].Value.pbData,
		    &aext[CRLInfo.cExtension].Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    aext[CRLInfo.cExtension].pszObjId = szOID_CERTSRV_CA_VERSION;
    apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData,
    CRLInfo.cExtension++;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &CRLNumber,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aext[CRLInfo.cExtension].Value.pbData,
		    &aext[CRLInfo.cExtension].Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    aext[CRLInfo.cExtension].pszObjId = szOID_CRL_NUMBER;
    apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData;
    if ((CRLF_CRLNUMBER_CRITICAL & g_dwCRLFlags) && 0 == CRLNumberBaseMin)
    {
	aext[CRLInfo.cExtension].fCritical = TRUE;
    }
    CRLInfo.cExtension++;

    // NextPublish is the earliest the client should look for a newer CRL.

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CHOICE_OF_TIME,
		    pftNextPublish,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aext[CRLInfo.cExtension].Value.pbData,
		    &aext[CRLInfo.cExtension].Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    aext[CRLInfo.cExtension].pszObjId = szOID_CRL_NEXT_PUBLISH;
    apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData,
    CRLInfo.cExtension++;

    if (0 != CRLNumberBaseMin)		// if Delta CRL
    {
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			&CRLNumberBaseMin,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aext[CRLInfo.cExtension].Value.pbData,
			&aext[CRLInfo.cExtension].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aext[CRLInfo.cExtension].pszObjId = szOID_DELTA_CRL_INDICATOR;
	aext[CRLInfo.cExtension].fCritical = TRUE;
	apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData,
	CRLInfo.cExtension++;

	// Add a CDP to base and delta CRLs to make it easier to manually
	// publish an off-line CA's CRLs to the correct DS location.

	if (NULL != pCAContext->CDPCRLDelta.pbData)
	{
	    aext[CRLInfo.cExtension].pszObjId = szOID_CRL_SELF_CDP;
	    aext[CRLInfo.cExtension].Value = pCAContext->CDPCRLDelta;
	    CRLInfo.cExtension++;
	}
    }
    else
    {
	// else if Base CRL (and if delta CRLs are enabled)

	if (!g_fDeltaCRLPublishDisabled &&
	    NULL != pCAContext->CDPCRLFreshest.pbData)
	{
	    aext[CRLInfo.cExtension].pszObjId = szOID_FRESHEST_CRL;
	    aext[CRLInfo.cExtension].Value = pCAContext->CDPCRLFreshest;
	    CRLInfo.cExtension++;
	}

	// Add a CDP to base and delta CRLs to make it easier to manually
	// publish an off-line CA's CRLs to the correct DS location.

	if (NULL != pCAContext->CDPCRLBase.pbData)
	{
	    aext[CRLInfo.cExtension].pszObjId = szOID_CRL_SELF_CDP;
	    aext[CRLInfo.cExtension].Value = pCAContext->CDPCRLBase;
	    CRLInfo.cExtension++;
	}
    }
    CSASSERT(ARRAYSIZE(aext) >= CRLInfo.cExtension);

    if (!myEncodeObject(
                    X509_ASN_ENCODING,
                    X509_CERT_CRL_TO_BE_SIGNED,
                    &CRLInfo,
                    0,
                    CERTLIB_USE_LOCALALLOC,
                    &pbCrlEncoded,               // pbEncoded
                    &cb))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    hr = myEncodeSignedContent(
			pCAContext->hProvCA,
			X509_ASN_ENCODING,
			pCAContext->pszObjIdSignatureAlgorithm,
			pbCrlEncoded,
			cb,
			CERTLIB_USE_LOCALALLOC,
			&pbCRL,
			&cbCRL); // use LocalAlloc*
    _JumpIfError(hr, error, "myEncodeSignedContent");

    hr = crlWriteCRLToDB(
		    CRLNumber,		 // CRLNumber
		    CRLNumberBaseMin,	 // CRLMinBase: 0 implies Base CRL
		    pwszUserName,
		    fShadowDelta,
		    pCAContext->NameId,  // CRLNameId
		    cCRL,		 // CRLCount
		    &CRLInfo.ThisUpdate, // pftThisUpdate
		    &CRLInfo.NextUpdate, // pftNextUpdate
		    pftThisPublish,	 // pftThisPublish
		    pftNextPublish,	 // pftNextPublish
		    pftQuery,
		    pftPropagationComplete,
		    pbCRL,		 // pbCRL
		    cbCRL,		 // cbCRL
		    &RowId);
    _JumpIfError(hr, error, "crlWriteCRLToDB");

    hr = crlPublishGeneratedCRL(
		    RowId,
		    pftCurrent,
		    pwszUserName,
		    0 != CRLNumberBaseMin,	// fDelta
		    pCAContext->iKey,
		    pbCRL,		 	// pbCRL
		    cbCRL,		 	// cbCRL
		    pCAContext,
		    pfRetryNeeded,
		    phrCRLPublish);
    _JumpIfError(hr, error, "crlPublishGeneratedCRL");

error:
    CSASSERT(ARRAYSIZE(aext) >= CRLInfo.cExtension);
    CSASSERT(ARRAYSIZE(apbFree) >= cpbFree);
    for (i = 0; i < cpbFree; i++)
    {
	CSASSERT(NULL != apbFree[i]);
	LocalFree(apbFree[i]);
    }
    if (NULL != pbCrlEncoded)
    {
        LocalFree(pbCrlEncoded);
    }
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    return(myHError(hr));
}


///////////////////////////////////////////////////
// crlPublishCRLFromCAContext is called to build and save one CRL.
//

HRESULT
crlPublishCRLFromCAContext(
    IN DWORD CRLNumber,
    IN DWORD CRLNumberBaseMin,		// 0 implies Base CRL; else Delta CRL
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN CACTX const *pCAContext,
    IN FILETIME const *pftCurrent,
    IN FILETIME ftThisUpdate,		// clamped by CA cert
    IN OUT FILETIME *pftNextUpdate,	// clamped by CA cert
    OPTIONAL OUT BOOL *pfClamped,
    OPTIONAL IN FILETIME const *pftQuery,
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftNextPublish,
    IN FILETIME const *pftLastPublishBase,
    IN FILETIME const *pftPropagationComplete,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    DWORD cCRL = 0;
    CRL_ENTRY *aCRL = NULL;
    VOID *pvBlockSerial = NULL;
    CERT_INFO const *pCertInfo = pCAContext->pccCA->pCertInfo;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;
    __try
    {
	if (!fShadowDelta)
	{
	    hr = crlBuildCRLArray(
			0 != CRLNumberBaseMin,	// fDelta
			pftQuery,
			pftThisPublish,
			pftLastPublishBase,
			pCAContext->iKey,
			&cCRL,
			&aCRL,
			&pvBlockSerial);
	    _JumpIfError(hr, error, "crlBuildCRLArray");
	}

	// Ensure it is not before the CA certificate's start date.

	if (0 > CompareFileTime(&ftThisUpdate, &pCertInfo->NotBefore))
	{
	    // clamp
	    ftThisUpdate = pCertInfo->NotBefore;
	}

	// Ensure it is not after the CA certificate's end date.

        if (NULL != pfClamped)
        {
            //init to FALSE
            *pfClamped = FALSE;
        }

	if (0 == (CRLF_PUBLISH_EXPIRED_CERT_CRLS & g_dwCRLFlags) &&
	    0 < CompareFileTime(pftNextUpdate, &pCertInfo->NotAfter))
	{
	    // clamp
	    *pftNextUpdate = pCertInfo->NotAfter;
            if (NULL != pfClamped)
            {
                *pfClamped = TRUE;
            }
	}
#ifdef DBG_CERTSRV_DEBUG_PRINT
	{
	    WCHAR *pwszNow = NULL;
	    WCHAR *pwszQuery = NULL;
	    WCHAR *pwszThisUpdate = NULL;
	    WCHAR *pwszNextUpdate = NULL;
	    WCHAR const *pwszCRLType = 0 == CRLNumberBaseMin? L"Base" : L"Delta";

	    myGMTFileTimeToWszLocalTime(pftThisPublish, TRUE, &pwszNow);
	    if (NULL != pftQuery)
	    {
		myGMTFileTimeToWszLocalTime(pftQuery, TRUE, &pwszQuery);
	    }
	    myGMTFileTimeToWszLocalTime(&ftThisUpdate, TRUE, &pwszThisUpdate);
	    myGMTFileTimeToWszLocalTime(pftNextUpdate, TRUE, &pwszNextUpdate);

	    DBGPRINT((
		DBG_SS_ERROR | DBG_SS_CERTSRV,
		"crlPublishCRLFromCAContext(tid=%d, CA Version=%u.%u): %ws CRL %u,%hs %u\n"
		    "        %ws CRL Publishing now(%ws)\n"
		    "        %ws CRL Query(%ws)\n"
		    "        %ws CRL ThisUpdate(%ws)\n"
		    "        %ws CRL NextUpdate(%ws)\n",
		GetCurrentThreadId(),
		pCAContext->iCert,
		pCAContext->iKey,
		pwszCRLType,
		CRLNumber,
		0 == CRLNumberBaseMin? "" : " Min Base",
		CRLNumberBaseMin,

		pwszCRLType,
		pwszNow,

		pwszCRLType,
		NULL != pftQuery? pwszQuery : L"None",

		pwszCRLType,
		pwszThisUpdate,

		pwszCRLType,
		pwszNextUpdate));
	    if (NULL != pwszNow)
	    {
		LocalFree(pwszNow);
	    }
	    if (NULL != pwszQuery)
	    {
		LocalFree(pwszQuery);
	    }
	    if (NULL != pwszThisUpdate)
	    {
		LocalFree(pwszThisUpdate);
	    }
	    if (NULL != pwszNextUpdate)
	    {
		LocalFree(pwszNextUpdate);
	    }
	}
#endif //DBG_CERTSRV_DEBUG_PRINT

	hr = CertSrvTestServerState();
	_JumpIfError(hr, error, "CertSrvTestServerState");

	hr = crlSignAndSaveCRL(
		    CRLNumber,
		    CRLNumberBaseMin,
		    pwszUserName,
		    fShadowDelta,
		    pCAContext,
		    cCRL,
		    aCRL,
		    pftCurrent,
		    &ftThisUpdate,
		    pftNextUpdate,
		    pftThisPublish,	// - no skew or overlap
		    pftNextPublish,	// no skew
		    pftQuery,
		    pftPropagationComplete,
		    pfRetryNeeded,
		    phrPublish);
	_JumpIfError(hr, error, "crlSignAndSaveCRL");

	CONSOLEPRINT4((
		DBG_SS_CERTSRV,
		"Published %hs CRL #%u for key %u.%u\n",
		0 == CRLNumberBaseMin? "Base" : "Delta",
		CRLNumber,
		pCAContext->iCert,
		pCAContext->iKey));

	CSASSERT(S_OK == hr);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    crlFreeCRLArray(pvBlockSerial, aCRL);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


DWORD g_aColCRLNumber[] = {

#define ICOL_CRLNUMBER		0
    DTI_CRLTABLE | DTL_NUMBER,
};


HRESULT
crlGetNextCRLNumber(
    OUT DWORD *pdwCRLNumber)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[1];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD Zero = 0;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;
    BOOL fResultActive = FALSE;

    *pdwCRLNumber = 1;

    // Set up restrictions as follows:

    pcvr = acvr;

    // CRLNumber > 0 (indexed column)

    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NUMBER;
    pcvr->SeekOperator = CVR_SEEK_GT;
    pcvr->SortOrder = CVR_SORT_DESCEND;		// highest CRL Number first
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			ARRAYSIZE(g_aColCRLNumber),
			g_aColCRLNumber,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    hr = pView->Next(ARRAYSIZE(aResult), aResult, &celtFetched);
    if (S_FALSE == hr)
    {
	if (0 == celtFetched)
	{
	    hr = S_OK;
	    goto error;
	}
    }
    _JumpIfError(hr, error, "Next");

    fResultActive = TRUE;

    CSASSERT(ARRAYSIZE(aResult) == celtFetched);

    pResult = &aResult[0];

    CSASSERT(ARRAYSIZE(g_aColCRLNumber) == pResult->ccol);
    CSASSERT(NULL != pResult->acol[ICOL_CRLNUMBER].pbValue);
    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOL_CRLNUMBER].Type));
    CSASSERT(sizeof(*pdwCRLNumber) == pResult->acol[ICOL_CRLNUMBER].cbValue);

    *pdwCRLNumber = 1 + *(DWORD *) pResult->acol[ICOL_CRLNUMBER].pbValue;
    hr = S_OK;

error:
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    DBGPRINT((
	DBG_SS_CERTSRVI,
	"crlGetNextCRLNumber -> %u\n",
	*pdwCRLNumber));
    return(hr);
}
#undef ICOL_CRLNUMBER


//+--------------------------------------------------------------------------
// crlGetBaseCRLInfo -- get database column data for the most recent Base CRL
//
//---------------------------------------------------------------------------

DWORD g_aColBaseCRLInfo[] = {

#define ICOLBI_CRLNUMBER		0
    DTI_CRLTABLE | DTL_NUMBER,

#define ICOLBI_CRLTHISUPDATE		1
    DTI_CRLTABLE | DTL_THISUPDATEDATE,

#define ICOLBI_CRLNEXTUPDATE		2
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,

#define ICOLBI_CRLNAMEID		3
    DTI_CRLTABLE | DTL_NAMEID,
};

HRESULT
crlGetBaseCRLInfo(
    IN FILETIME const *pftCurrent,
    IN BOOL fOldestUnexpiredBase,	// else newest propagated CRL
    OUT DWORD *pdwRowId,
    OUT DWORD *pdwCRLNumber,
    OUT FILETIME *pftThisUpdate)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[2];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD Zero = 0;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;
    BOOL fResultActive = FALSE;
    BOOL fSaveCRLInfo;

    DWORD RowId = 0;
    DWORD CRLNumber;
    FILETIME ftThisUpdate;
    FILETIME ftNextUpdate;

    *pdwRowId = 0;
    *pdwCRLNumber = 0;
    pftThisUpdate->dwHighDateTime = 0;
    pftThisUpdate->dwLowDateTime = 0;

    if (CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE & g_dwCRLFlags)
    {
	fOldestUnexpiredBase = TRUE;
    }

    // Set up restrictions as follows:

    pcvr = acvr;
    if (fOldestUnexpiredBase)
    {
	// NextUpdate >= now

	pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NEXTUPDATEDATE;
	pcvr->SeekOperator = CVR_SEEK_GE;
    }
    else	// else newest propagated CRL
    {
	// PropagationComplete < now

	pcvr->ColumnIndex = DTI_CRLTABLE | DTL_PROPAGATIONCOMPLETEDATE;
	pcvr->SeekOperator = CVR_SEEK_LT;
    }
    pcvr->SortOrder = CVR_SORT_DESCEND;		// Newest CRL first
    pcvr->pbValue = (BYTE *) pftCurrent;
    pcvr->cbValue = sizeof(*pftCurrent);
    pcvr++;

    // CRL Minimum Base == 0 (to eliminate delta CRLs)

    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_MINBASE;
    pcvr->SeekOperator = CVR_SEEK_EQ;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			ARRAYSIZE(g_aColBaseCRLInfo),
			g_aColBaseCRLInfo,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    while (0 == RowId || fOldestUnexpiredBase)
    {
	hr = pView->Next(ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    CSASSERT(0 == celtFetched);
	    if (0 != RowId)
	    {
		break;
	    }
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpIfError(hr, error, "Next: no matching base CRL");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) == celtFetched);

	pResult = &aResult[0];

	CSASSERT(ARRAYSIZE(g_aColBaseCRLInfo) == pResult->ccol);

	CSASSERT(NULL != pResult->acol[ICOLBI_CRLNUMBER].pbValue);
	CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLBI_CRLNUMBER].Type));
	CSASSERT(sizeof(DWORD) == pResult->acol[ICOLBI_CRLNUMBER].cbValue);

	CSASSERT(NULL != pResult->acol[ICOLBI_CRLTHISUPDATE].pbValue);
	CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLBI_CRLTHISUPDATE].Type));
	CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLBI_CRLTHISUPDATE].cbValue);

	CSASSERT(NULL != pResult->acol[ICOLBI_CRLNEXTUPDATE].pbValue);
	CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLBI_CRLNEXTUPDATE].Type));
	CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLBI_CRLNEXTUPDATE].cbValue);

	DBGPRINT((DBG_SS_CERTSRVI, "Query:RowId: %u\n", pResult->rowid));
	DBGPRINT((DBG_SS_CERTSRVI, "Query:CRLNumber: %u\n", *(DWORD *) pResult->acol[ICOLBI_CRLNUMBER].pbValue));
	DBGPRINT((DBG_SS_CERTSRVI, "Query:NameId: 0x%x\n", *(DWORD *) pResult->acol[ICOLBI_CRLNAMEID].pbValue));
	DBGPRINTTIME(NULL, "Query:ThisUpdate", DPT_DATE, *(FILETIME *) pResult->acol[ICOLBI_CRLNEXTUPDATE].pbValue);
	DBGPRINTTIME(NULL, "Query:NextUpdate", DPT_DATE, *(FILETIME *) pResult->acol[ICOLBI_CRLTHISUPDATE].pbValue);

	if (0 == RowId)
	{
	    // save first matching row info
	    
	    fSaveCRLInfo = TRUE;
	}
	else
	{
	    // save row info, if looking for
	    // oldest unexpired base & this CRL expires before the saved CRL
	    //     +1 if first > second -- saved > this
	    
	    CSASSERT(fOldestUnexpiredBase);

	    fSaveCRLInfo = 0 < CompareFileTime(
		    &ftNextUpdate,
		    (FILETIME *) pResult->acol[ICOLBI_CRLNEXTUPDATE].pbValue);
	}
	if (fSaveCRLInfo)
	{
	    CRLNumber = *(DWORD *) pResult->acol[ICOLBI_CRLNUMBER].pbValue;
	    ftThisUpdate = *(FILETIME *) pResult->acol[ICOLBI_CRLTHISUPDATE].pbValue;
	    ftNextUpdate = *(FILETIME *) pResult->acol[ICOLBI_CRLNEXTUPDATE].pbValue;
	    RowId = pResult->rowid;
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"Query: SAVED RowId=%u CRLNumber=%u\n",
		pResult->rowid,
		CRLNumber));
	    DBGPRINTTIME(NULL, "ftThisUpdate", DPT_DATE, ftThisUpdate);
	}
	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }

    *pdwRowId = RowId;
    *pdwCRLNumber = CRLNumber;
    *pftThisUpdate = ftThisUpdate;
    DBGPRINTTIME(NULL, "*pftThisUpdate", DPT_DATE, *pftThisUpdate);
    DBGPRINTTIME(NULL, "ftNextUpdate", DPT_DATE, ftNextUpdate);
    hr = S_OK;

error:
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    DBGPRINT((
	DBG_SS_CERTSRV,
	"crlGetBaseCRLInfo -> RowId=%u, CRL=%u\n",
	*pdwRowId,
	*pdwCRLNumber));
    return(hr);
}
#undef ICOLBI_CRLNUMBER
#undef ICOLBI_CRLTHISUPDATE
#undef ICOLBI_CRLNEXTUPDATE
#undef ICOLBI_CRLNAMEID


DWORD g_aColRepublishCRLInfo[] = {

#define ICOLRI_CRLNUMBER		0
    DTI_CRLTABLE | DTL_NUMBER,

#define ICOLRI_CRLNAMEID		1
    DTI_CRLTABLE | DTL_NAMEID,

#define ICOLRI_CRLPUBLISHFLAGS		2
    DTI_CRLTABLE | DTL_PUBLISHFLAGS,

#define ICOLRI_CRLTHISUPDATE		3
    DTI_CRLTABLE | DTL_THISUPDATEDATE,

#define ICOLRI_CRLNEXTUPDATE		4
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,

#define ICOLRI_CRLRAWCRL		5
    DTI_CRLTABLE | DTL_RAWCRL,
};

HRESULT
crlGetRowIdAndCRL(
    IN BOOL fDelta,
    IN CACTX *pCAContext,
    OUT DWORD *pdwRowId,
    OUT DWORD *pcbCRL,
    OPTIONAL OUT BYTE **ppbCRL,
    OPTIONAL OUT DWORD *pdwCRLPublishFlags)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[4];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD Zero = 0;
    DWORD NameIdMin;
    DWORD NameIdMax;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;
    BOOL fResultActive = FALSE;
    FILETIME ftCurrent;
    DWORD RowId = 0;
    BYTE *pbCRL = NULL;
    DWORD cbCRL;

    *pdwRowId = 0;
    *pcbCRL = 0;
    if (NULL != ppbCRL)
    {
	*ppbCRL = NULL;
    }

    if (NULL != pdwCRLPublishFlags)
    {
	*pdwCRLPublishFlags = 0;
    }
    GetSystemTimeAsFileTime(&ftCurrent);

    DBGPRINT((
	DBG_SS_CERTSRVI,
	"crlGetRowIdAndCRL(%ws, NameId=%x)\n",
	fDelta? L"Delta" : L"Base",
	pCAContext->NameId));

    // Set up restrictions as follows:

    pcvr = acvr;

    // RowId > 0

    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_ROWID;
    pcvr->SeekOperator = CVR_SEEK_GE;
    pcvr->SortOrder = CVR_SORT_DESCEND;		// Newest CRL first
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    if (fDelta)
    {
	// CRL Minimum Base > 0 (to eliminate base CRLs)

	pcvr->SeekOperator = CVR_SEEK_GT;
    }
    else
    {
	// CRL Minimum Base == 0 (to eliminate delta CRLs)

	pcvr->SeekOperator = CVR_SEEK_EQ;
    }
    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_MINBASE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    // NameId >= MAKECANAMEID(iCert == 0, pCAContext->iKey)

    NameIdMin = MAKECANAMEID(0, pCAContext->iKey);
    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NAMEID;
    pcvr->SeekOperator = CVR_SEEK_GE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMin;
    pcvr->cbValue = sizeof(NameIdMin);
    pcvr++;

    // NameId <= MAKECANAMEID(iCert == _16BITMASK, pCAContext->iKey)

    NameIdMax = MAKECANAMEID(_16BITMASK, pCAContext->iKey);
    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NAMEID;
    pcvr->SeekOperator = CVR_SEEK_LE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMax;
    pcvr->cbValue = sizeof(NameIdMax);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			((NULL != ppbCRL) ? 
				(DWORD) ARRAYSIZE(g_aColRepublishCRLInfo) : 
				(DWORD) ARRAYSIZE(g_aColRepublishCRLInfo) - 1 ),	// explicitly describe expected return value
			g_aColRepublishCRLInfo,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    while (0 == RowId)
    {
	hr = pView->Next(ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    CSASSERT(0 == celtFetched);
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpIfErrorStr(
		hr,
		error,
		"Next: no matching CRL",
		fDelta? L"delta" : L"base");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) == celtFetched);

	pResult = &aResult[0];

	CSASSERT(ARRAYSIZE(g_aColRepublishCRLInfo) == pResult->ccol);

	// verify CRLNumber data & schema

	CSASSERT(NULL != pResult->acol[ICOLRI_CRLNUMBER].pbValue);
	CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLRI_CRLNUMBER].Type));
	CSASSERT(sizeof(DWORD) == pResult->acol[ICOLRI_CRLNUMBER].cbValue);

	// verify ThisUpdate data & schema

	CSASSERT(NULL != pResult->acol[ICOLRI_CRLTHISUPDATE].pbValue);
	CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLRI_CRLTHISUPDATE].Type));
	CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLRI_CRLTHISUPDATE].cbValue);

	// verify NextUpdate data & schema

	CSASSERT(NULL != pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue);
	CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLRI_CRLNEXTUPDATE].Type));
	CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLRI_CRLNEXTUPDATE].cbValue);

	// verify RawCRL data & schema

	if (NULL != ppbCRL)
	{
	    CSASSERT(NULL != pResult->acol[ICOLRI_CRLRAWCRL].pbValue);
	    CSASSERT(PROPTYPE_BINARY == (PROPTYPE_MASK & pResult->acol[ICOLRI_CRLRAWCRL].Type));
	}

	// DBGPRINT query results

	DBGPRINT((DBG_SS_CERTSRVI, "Query:RowId: %u\n", pResult->rowid));
	DBGPRINT((DBG_SS_CERTSRVI, "Query:CRLNumber: %u\n", *(DWORD *) pResult->acol[ICOLRI_CRLNUMBER].pbValue));
	DBGPRINT((DBG_SS_CERTSRVI, "Query:NameId: 0x%x\n", *(DWORD *) pResult->acol[ICOLRI_CRLNAMEID].pbValue));
	DBGPRINTTIME(NULL, "Query:ThisUpdate", DPT_DATE, *(FILETIME *) pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue);
	DBGPRINTTIME(NULL, "Query:NextUpdate", DPT_DATE, *(FILETIME *) pResult->acol[ICOLRI_CRLTHISUPDATE].pbValue);
	if (NULL != ppbCRL)
	{
	    DBGPRINT((DBG_SS_CERTSRVI, "Query:RawCRL: cb=%x\n", pResult->acol[ICOLRI_CRLRAWCRL].cbValue));
	}
	if (NULL != pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue)
	{
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"Query:PublishFlags: f=%x\n",
		*(DWORD *) pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue));
	}
	if (0 < CompareFileTime(
		    (FILETIME *) pResult->acol[ICOLRI_CRLTHISUPDATE].pbValue,
		    &ftCurrent))
	{
	    _PrintError(E_INVALIDARG, "ThisUpdate in future");
	}
	if (0 > CompareFileTime(
		    (FILETIME *) pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue,
		    &ftCurrent))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "NextUpdate in past");
	}

	CSASSERT(0 != pResult->rowid);
	CSASSERT(NULL == pbCRL);
	
	RowId = pResult->rowid;
	if (NULL != ppbCRL)
	{
	    cbCRL = pResult->acol[ICOLRI_CRLRAWCRL].cbValue;
	    pbCRL = (BYTE *) LocalAlloc(LMEM_FIXED, cbCRL);
	    if (NULL == pbCRL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(
		    pbCRL,
		    pResult->acol[ICOLRI_CRLRAWCRL].pbValue,
		    cbCRL);
	}
	if (NULL != pdwCRLPublishFlags &&
	    NULL != pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue)
	{
	    *pdwCRLPublishFlags = *(DWORD *) pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue;
	}
	DBGPRINT((DBG_SS_CERTSRVI, "Query:RowId: SAVED %u\n", pResult->rowid));

	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }
    *pdwRowId = RowId;
    if (NULL != ppbCRL)
    {
	*pcbCRL = cbCRL;
	*ppbCRL = pbCRL;
	pbCRL = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    DBGPRINT((
	DBG_SS_CERTSRVI,
	"crlGetRowIdAndCRL(%ws) -> RowId=%u, cbCRL=%x, hr=%x\n",
	fDelta? L"Delta" : L"Base",
	*pdwRowId,
	*pcbCRL,
	hr));
    return(hr);
}
#undef ICOLRI_CRLNUMBER
#undef ICOLRI_CRLNAMEID
#undef ICOLRI_CRLRAWCRL
#undef ICOLRI_CRLPUBLISHFLAGS
#undef ICOLRI_CRLTHISUPDATEDATE
#undef ICOLRI_CRLNEXTUPDATEDATE


HRESULT
crlRepublishCRLFromCAContext(
    IN FILETIME const *pftCurrent,
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDelta,
    IN CACTX *pCAContext,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    DWORD cbCRL;
    BYTE *pbCRL = NULL;
    DWORD RowId;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;

    hr = crlGetRowIdAndCRL(fDelta, pCAContext, &RowId, &cbCRL, &pbCRL, NULL);
    _JumpIfError(hr, error, "crlGetRowIdAndCRL");

    hr = crlPublishGeneratedCRL(
		    RowId,
		    pftCurrent,
		    pwszUserName,
		    fDelta,
		    pCAContext->iKey,
		    pbCRL,
		    cbCRL,
		    pCAContext,
		    pfRetryNeeded,
		    phrPublish);
    _JumpIfError(hr, error, "crlPublishGeneratedCRL");

error:
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    return(hr);
}


HRESULT
crlRepublishExistingCRLs(
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDeltaOnly,
    IN BOOL fShadowDelta,
    IN FILETIME const *pftCurrent,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    HRESULT hrPublish;
    BOOL fRetryNeeded;
    DWORD i;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;

    // Walk global CA Context array from the back, and republish CRLs for
    // each unique CA key.  This causes the most current CRL to be published
    // first, and the most current CA Cert context to be used to publish a CRL
    // that covers multiple CA Certs due to key reuse.

    for (i = g_cCACerts; i > 0; i--)
    {
	CACTX *pCAContext = &g_aCAContext[i - 1];

	PKCSVerifyCAState(pCAContext);
	if (CTXF_SKIPCRL & pCAContext->Flags)
	{
	    continue;
	}
	if (!fDeltaOnly)
	{
	    // Publish the most recent existing Base CRL

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlRepublishCRLFromCAContext(
				    pftCurrent,
				    pwszUserName,
				    FALSE,	// fDelta
				    pCAContext,
				    &fRetryNeeded,
				    &hrPublish);
	    _JumpIfError(hr, error, "crlRepublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }
	}

	if (!g_fDeltaCRLPublishDisabled || fShadowDelta)
	{
	    // Publish the most recent existing Delta CRL

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlRepublishCRLFromCAContext(
				    pftCurrent,
				    pwszUserName,
				    TRUE,	// fDelta
				    pCAContext,
				    &fRetryNeeded,
				    &hrPublish);
	    _JumpIfError(hr, error, "crlRepublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
crlComputeCRLTimes(
    IN BOOL fDelta,
    IN CSCRLPERIOD const *pccp,
    IN FILETIME const *pftCurrent,
    OUT FILETIME *pftThisUpdate,	 // ftCurrent - clock skew
    IN OUT FILETIME *pftNextUpdate,	 // ftCurrent + period + overlap + skew
    OUT FILETIME *pftNextPublish,	 // ftCurrent + CRL period
    OUT FILETIME *pftPropagationComplete) // ftCurrent + overlap
{
    HRESULT hr;
    LONGLONG lldelta;

    if (0 == pftNextUpdate->dwHighDateTime &&
	0 == pftNextUpdate->dwLowDateTime)
    {
	// Calculate expiration date for this CRL:
	// ftCurrent + CRL period

	DBGPRINTTIME(&fDelta, "*pftCurrent", DPT_DATE, *pftCurrent);
	*pftNextUpdate = *pftCurrent;
	DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "+ count=%d, enum=%d\n",
	    pccp->lCRLPeriodCount,
	    pccp->enumCRLPeriod));

	myMakeExprDateTime(
		    pftNextUpdate,
		    pccp->lCRLPeriodCount,
		    pccp->enumCRLPeriod);
	DBGPRINTTIME(&fDelta, "*pftNextUpdate", DPT_DATE, *pftNextUpdate);
    }
    if (0 > CompareFileTime(pftNextUpdate, pftCurrent))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "*pftNextUpdate in past");
    }

    *pftThisUpdate = *pftCurrent;
    *pftNextPublish = *pftNextUpdate;	// unmodified expiration time

    // Subtract clock skew from the current time for ftThisUpdate time.

    lldelta = g_dwClockSkewMinutes * CVT_MINUTES;
    myAddToFileTime(pftThisUpdate, -lldelta * CVT_BASE);

    // Add clock skew to ftNextUpdate,
    // Add propogation overlap to ftNextUpdate.

    lldelta += pccp->dwCRLOverlapMinutes * CVT_MINUTES;
    myAddToFileTime(pftNextUpdate, lldelta * CVT_BASE);

    *pftPropagationComplete = *pftCurrent;
    lldelta = pccp->dwCRLOverlapMinutes * CVT_MINUTES;
    myAddToFileTime(pftPropagationComplete, lldelta * CVT_BASE);

    DBGPRINTTIME(&fDelta, "*pftCurrent", DPT_DATE, *pftCurrent);
    DBGPRINTTIME(&fDelta, "*pftThisUpdate", DPT_DATE, *pftThisUpdate);
    DBGPRINTTIME(&fDelta, "*pftNextUpdate", DPT_DATE, *pftNextUpdate);
    DBGPRINTTIME(&fDelta, "*pftNextPublish", DPT_DATE, *pftNextPublish);
    DBGPRINTTIME(&fDelta, "*pftPropagationComplete", DPT_DATE, *pftPropagationComplete);

    hr = S_OK;

error:
    return(hr);
}


HRESULT
crlGenerateAndPublishCRLs(
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDeltaOnly,			// else base (and delta, if enabled)
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN FILETIME const *pftCurrent,
    IN FILETIME ftNextUpdateBase,
    OUT DWORD *pdwRowIdBase,
    OUT FILETIME *pftQueryDeltaDelete,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    HRESULT hrPublish;
    HKEY hkeyBase = NULL;
    HKEY hkeyCA = NULL;
    BOOL fClamped = FALSE;
    DWORD CRLNumber;
    DWORD CRLNumberBaseMin = 0;
    DWORD i;
    BOOL fRetryNeeded;
    FILETIME ftNextUpdateDelta;
    FILETIME ftThisUpdate;
    FILETIME ftQueryDelta;
    FILETIME *pftQueryDelta = &ftQueryDelta;
    FILETIME ftLastPublishBase;
    FILETIME ftNextPublishBase;
    FILETIME ftNextUpdateBaseClamped = ftNextUpdateBase; // if clamped
    FILETIME ftNextPublishDelta;
    FILETIME ftPropagationCompleteBase;
    FILETIME ftPropagationCompleteDelta;
    CSCRLPERIOD ccpBase;
    CSCRLPERIOD ccpDelta;

    *pfRetryNeeded = FALSE;
    pftQueryDeltaDelete->dwHighDateTime = 0;
    pftQueryDeltaDelete->dwLowDateTime = 0;
    *phrPublish = S_OK;

    hr = crlGetNextCRLNumber(&CRLNumber);
    _JumpIfError(hr, error, "crlGetNextCRLNumber");

    hr = crlGetRegCRLPublishParams(
			    g_wszSanitizedName,
			    &ccpBase,
			    &ccpDelta);
    _JumpIfError(hr, error, "crlGetRegCRLPublishParams");

    // in manual publish case, 0 implies use default publish period

    if (fDeltaOnly)
    {
	ftNextUpdateDelta = ftNextUpdateBase;
	ZeroMemory(&ftNextUpdateBase, sizeof(ftNextUpdateBase));
    }
    else
    {
	ZeroMemory(&ftNextUpdateDelta, sizeof(ftNextUpdateDelta));
    }

    hr = crlComputeCRLTimes(
		FALSE,				// fDelta
		&ccpBase,			// IN
		pftCurrent,			// IN
		&ftThisUpdate,			// OUT includes skew
		&ftNextUpdateBase,		// INOUT includes overlap, skew
		&ftNextPublishBase,		// OUT unmodified expire time
		&ftPropagationCompleteBase);	// OUT includes overlap
    _JumpIfError(hr, error, "crlComputeCRLTimes");

    hr = crlComputeCRLTimes(
		TRUE,				// fDelta
		fShadowDelta? &ccpBase : &ccpDelta, // IN
		pftCurrent,			// IN
		&ftThisUpdate,			// OUT includes skew
		&ftNextUpdateDelta,		// INOUT includes overlap, skew
		&ftNextPublishDelta,		// OUT unmodified expire time
		&ftPropagationCompleteDelta);	// OUT includes overlap
    _JumpIfError(hr, error, "crlComputeCRLTimes");

    // Set ftLastPublishBase to *pftCurrent minus lifetime of this base CRL,
    // which is an educated guess for the ftThisPublish value for the last
    // CRL issued.

    ftLastPublishBase = *pftCurrent;
    myAddToFileTime(
	    &ftLastPublishBase,
	    -mySubtractFileTimes(&ftNextPublishBase, pftCurrent));

    // Clamp delta CRL to not end after base CRL.

    if (0 < CompareFileTime(&ftNextPublishDelta, &ftNextPublishBase))
    {
	ftNextPublishDelta = ftNextPublishBase;
	DBGPRINTTIME(NULL, "ftNextPublishDelta", DPT_DATE, ftNextPublishDelta);
    }
    if (0 < CompareFileTime(&ftNextUpdateDelta, &ftNextUpdateBase))
    {
	ftNextUpdateDelta = ftNextUpdateBase;
	DBGPRINTTIME(NULL, "ftNextUpdateDelta", DPT_DATE, ftNextUpdateDelta);
    }
    if (0 < CompareFileTime(&ftPropagationCompleteDelta, &ftPropagationCompleteBase))
    {
	ftPropagationCompleteDelta = ftPropagationCompleteBase;
	DBGPRINTTIME(NULL, "ftPropagationCompleteDelta", DPT_DATE, ftPropagationCompleteDelta);
    }
    if (!g_fDeltaCRLPublishDisabled || fShadowDelta)
    {
	hr = crlGetBaseCRLInfo(
			    pftCurrent,
			    FALSE,		// try newest propagated CRL
			    pdwRowIdBase,
			    &CRLNumberBaseMin,
			    &ftQueryDelta);
	_PrintIfError(hr, "crlGetBaseCRLInfo");
	if (S_OK != hr)
	{
	    hr = crlGetBaseCRLInfo(
				pftCurrent,
				TRUE,		// try oldest unexpired CRL
				pdwRowIdBase,
				&CRLNumberBaseMin,
				&ftQueryDelta);
	    _PrintIfError(hr, "crlGetBaseCRLInfo");
	    if (S_OK != hr)
	    {
		CRLNumberBaseMin = 1;
		if (!fDeltaOnly && 1 == CRLNumber)
		{
		    ftQueryDelta = *pftCurrent;		// empty CRL
		}
		else
		{
		    pftQueryDelta = NULL;		// full CRL
		}
	    }
	}
	if (S_OK == hr)
	{
	    // Delete old CRLs that expired at least one base CRL period prior
	    // to the "minimum" base crl ThisUpdate date found in the database.
	    
	    *pftQueryDeltaDelete = ftQueryDelta;
	    myAddToFileTime(
		    pftQueryDeltaDelete,
		    -mySubtractFileTimes(&ftNextUpdateBase, &ftThisUpdate));
	}
	if (fShadowDelta)
	{
	    CRLNumberBaseMin = CRLNumber;
	}
	CSASSERT(0 != CRLNumberBaseMin);
    }

    // Walk global CA Context array from the back, and generate a CRL for
    // each unique CA key.  This causes the most current CRL to be built
    // first, and the most current CA Cert to be used to build a CRL that
    // covers multiple CA Certs due to key reuse.

    for (i = g_cCACerts; i > 0; i--)
    {
	CACTX *pCAContext = &g_aCAContext[i - 1];

	PKCSVerifyCAState(pCAContext);
	if (CTXF_SKIPCRL & pCAContext->Flags)
	{
	    continue;
	}
	if (!fDeltaOnly)
	{
	    // Publish a new Base CRL

	    // make a local copy in case clamped
	    FILETIME ftNextUpdateBaseTemp = ftNextUpdateBase;
	    fClamped = FALSE;

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlPublishCRLFromCAContext(
				    CRLNumber,
				    0,		// CRLNumberBaseMin
				    pwszUserName,
				    FALSE,	// fShadowDelta
				    pCAContext,
				    pftCurrent,
				    ftThisUpdate,
				    &ftNextUpdateBaseTemp,
				    &fClamped,
				    NULL,
				    pftCurrent,
				    &ftNextPublishBase,
				    &ftLastPublishBase,
				    &ftPropagationCompleteBase,
				    &fRetryNeeded,
				    &hrPublish);
	    _JumpIfError(hr, error, "crlPublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }

	    {
		CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_AUTOPUBLISHCRL, g_dwAuditFilter);

		hr = event.AddData(true); // %1 base crl?
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(CRLNumber); // %2 CRL#
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(pCAContext->pwszKeyContainerName); // %3 key container
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(ftNextPublishBase); // %4 next publish
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData((LPCWSTR*)pCAContext->papwszCRLFiles); //%5 URLs
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.Report();
		_JumpIfError(hr, error, "CAuditEvent::Report");
	    }
	    if (i == g_cCACerts && fClamped)
	    {
		// new next publish clamps with CA expiration, only update
		// the current crl with new one for later reg save

		ftNextUpdateBaseClamped = ftNextUpdateBaseTemp;
	    }
	}

	if (!g_fDeltaCRLPublishDisabled || fShadowDelta)
	{
	    // Publish a new Delta CRL

	    FILETIME ftNextUpdateDeltaTemp = ftNextUpdateDelta;

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlPublishCRLFromCAContext(
					CRLNumber,
					CRLNumberBaseMin,
					pwszUserName,
					fShadowDelta,
					pCAContext,
					pftCurrent,
					ftThisUpdate,
					&ftNextUpdateDeltaTemp,
					NULL,
					pftQueryDelta,
					pftCurrent,
					&ftNextPublishDelta,
					&ftLastPublishBase,	// Base!
					&ftPropagationCompleteDelta,
					&fRetryNeeded,
					&hrPublish);
	    _JumpIfError(hr, error, "crlPublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }

	    {
		CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_AUTOPUBLISHCRL, g_dwAuditFilter);

		hr = event.AddData(false); // %1 base crl?
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(CRLNumber); // %2 CRL#
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(pCAContext->pwszKeyContainerName); // %3 key container
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(ftNextPublishDelta); // %4 next publish
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData((LPCWSTR*)pCAContext->papwszDeltaCRLFiles); // %5 URLs
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.Report();
		_JumpIfError(hr, error, "CAuditEvent::Report");
	    }
	}
    }

    // update the registry and global variables

    if (!fDeltaOnly)
    {
	if (!fClamped)
	{
	    g_ftCRLNextPublish = ftNextPublishBase;
	}
	else
	{
	    g_ftCRLNextPublish = ftNextUpdateBaseClamped;
	}
	hr = crlSetRegCRLNextPublish(
			FALSE,
			g_wszSanitizedName,
			wszREGCRLNEXTPUBLISH,
			&g_ftCRLNextPublish);
	_JumpIfError(hr, error, "crlSetRegCRLNextPublish");
    }

    g_ftDeltaCRLNextPublish = ftNextPublishDelta;

    if (!g_fDeltaCRLPublishDisabled)
    {
	hr = crlSetRegCRLNextPublish(
			TRUE,
			g_wszSanitizedName,
			wszREGCRLDELTANEXTPUBLISH,
			&g_ftDeltaCRLNextPublish);
	_JumpIfError(hr, error, "crlSetRegCRLNextPublish");
    }
    hr = S_OK;

error:
    if (NULL != hkeyCA)
    {
	RegCloseKey(hkeyCA);
    }
    if (NULL != hkeyBase)
    {
	RegCloseKey(hkeyBase);
    }
    return(hr);
}


///////////////////////////////////////////////////
// CRLPublishCRLs is called to publish a set of CRLs.
//
// if fRebuildCRL is TRUE, the CRLs are rebuilt from the database.
// otherwise, the exit module is re-notified of the CRLs.
// For consistency, if the exit module returns ERROR_RETRY, this
// function will write the retry bit into the registry which will
// trigger the Wakeup function, which then recalculates when the
// next publish should happen.
//
// pfRetryNeeded is an OUT param that notifies the autopublish routine if
// a retry is immediately necessary following a rebuilt CRL. In this
// case the registry would not be changed and the registry trigger
// would not fire.
//
// (Current_time - skew) is used as ThisUpdate
// (ftNextUpdate+skew+Overlap) is used as NextUpdate
// (ftNextUpdate) is next wakeup/publish time
//
// There are registry values to specify the overlap.
// HLKLM\SYSTEM\CurrentControlSet\Services\CertSvc\Configuration\<CA Name>:
// CRLOverlapPeriod         REG_SZ = Hours (or Minutes)
// CRLOverlapUnits          REG_DWORD = 0 (0) -- DISABLED
//
// If the above registry values are set and valid, the registry overlap period
// is calculated as:
//   max(Registry CRL Overlap Period, 1.5 * Registry clock skew minutes)
//
// If they are not present or invalid, the overlap period is calculated as:
//   max(
//	min(Registry CRL Period / 10, 12 hours),
//	1.5 * Registry clock skew minutes) +
//   Registry clock skew minutes
//
// ThisUpdate is calculated as:
// max(Current Time - Registry clock skew minutes, CA cert NotBefore date)
//
// NextUpdate is calculated as:
//   min(
//	Current Time +
//	    Registry CRL period +
//	    calculated overlap period +
//	    Registry clock skew minutes,
//	CA cert NotAfter date)
//
// The Next CRL publication time is calculated as:
//   Current Time + Registry CRL period
//
// This function sets g_hCRLManualPublishEvent. Automatic publishing
// is personally responsible for clearing this event if it calls us.

HRESULT
CRLPublishCRLs(
    IN BOOL fRebuildCRL,		// else republish only
    IN BOOL fForceRepublish,		// else check registry retry count
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDeltaOnly,			// else base (and delta, if enabled)
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN FILETIME ftNextUpdateBase,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    BOOL fRetryNeeded = FALSE;
    BOOL fExitNotify = FALSE;
    BOOL fCoInitialized = FALSE;
    DWORD RowIdBase = 0;
    FILETIME ftQueryDeltaDelete = { 0, 0 };
    DWORD dwPreviousAttempts;
    DWORD dwCurrentAttempts;
    static BOOL s_fSkipRetry = FALSE;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;

    if (fDeltaOnly && g_fDeltaCRLPublishDisabled && !fShadowDelta)
    {
	hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_DISABLED);
	_JumpError(hr, error, "g_fDeltaCRLPublishDisabled");
    }

    // retrieve initial retry value (optional registry value)

    hr = myGetCertRegDWValue(
			g_wszSanitizedName,
			NULL,
			NULL,
			wszREGCRLATTEMPTREPUBLISH,
			&dwPreviousAttempts);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
	dwPreviousAttempts = 0;	// assume no previous failed publish attempts
	hr = S_OK;
    }
    _JumpIfErrorStr(
		hr,
		error,
		"myGetCertRegDWValue",
		wszREGCRLATTEMPTREPUBLISH);

    dwCurrentAttempts = dwPreviousAttempts;
    DBGPRINT((
	DBG_SS_CERTSRV,
	"CRLPublishCRLs(fRebuildCRL=%u, fForceRepublish=%u, User=%ws)\n",
	fRebuildCRL,
	fForceRepublish,
	pwszUserName));
    DBGPRINT((
	DBG_SS_CERTSRV,
	"CRLPublishCRLs(fDeltaOnly=%u, fShadowDelta=%u, dwPreviousAttempts=%u)\n",
	fDeltaOnly,
	fShadowDelta,
	dwPreviousAttempts));

    if (0 != dwPreviousAttempts && NULL == pwszUserName && s_fSkipRetry)
    {
	fRetryNeeded = TRUE;
    }
    else
    {
	FILETIME ftCurrent;

	GetSystemTimeAsFileTime(&ftCurrent);

	// generate CRLs if necessary

	if (fRebuildCRL)
	{
	    hr = crlGenerateAndPublishCRLs(
				    pwszUserName,
				    fDeltaOnly,
				    fShadowDelta,
				    &ftCurrent,
				    ftNextUpdateBase,
				    &RowIdBase,
				    &ftQueryDeltaDelete,
				    &fRetryNeeded,
				    phrPublish);
	    _JumpIfError(hr, error, "crlGenerateAndPublishCRLs");

	    fExitNotify = TRUE;
	    dwCurrentAttempts = 1;
	}
	else
	if (fForceRepublish ||
	    (0 < dwPreviousAttempts &&
	     CERTSRV_CRLPUB_RETRY_COUNT_DEFAULT > dwPreviousAttempts))
	{
	    // If the timer thread is auto-republishing due to previously
	    // failed publish attempts, retry base CRLs, too, because we
	    // can't tell if the retry is due to a base or delta CRL error.

	    if (NULL == pwszUserName)
	    {
		fDeltaOnly = FALSE;
	    }

	    hr = crlRepublishExistingCRLs(
			    pwszUserName,
			    fDeltaOnly,
			    fShadowDelta,
			    &ftCurrent,
			    &fRetryNeeded,
			    phrPublish);
	    _JumpIfError(hr, error, "crlRepublishCRLs");

	    fExitNotify = TRUE;
	    dwCurrentAttempts++;
	}

	if (fExitNotify && g_fEnableExit)
	{
	    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
	    if (S_OK != hr && S_FALSE != hr)
	    {
		_JumpError(hr, error, "CoInitializeEx");
	    }
	    fCoInitialized = TRUE;

	    // make sure exit module(s) get notified for publish and republish
	    // in case of earlier exit module publish failure.

	    hr = ExitNotify(EXITEVENT_CRLISSUED, 0, MAXDWORD);
	    _PrintIfError(hr, "ExitNotify");
	    if ((HRESULT) ERROR_RETRY == hr ||
		HRESULT_FROM_WIN32(ERROR_RETRY) == hr)
	    {
		fRetryNeeded = TRUE;
		if (S_OK == *phrPublish)
		{
		    *phrPublish = HRESULT_FROM_WIN32(ERROR_RETRY);
		}
	    }
	    CONSOLEPRINT0((DBG_SS_CERTSRV, "Issued CRL Exit Event\n"));
	}

	// If new or existing CRLs successfully published, reset count to 0

	if (fExitNotify && !fRetryNeeded)
	{
	    dwCurrentAttempts = 0;
	    if (CERTLOG_VERBOSE <= g_dwLogLevel)
	    {
		WCHAR *pwszHostName = NULL;
		DWORD LogMsg;
		WORD cpwsz = 0;

		if (NULL != g_pld)
		{
		    myLdapGetDSHostName(g_pld, &pwszHostName);
		}
		LogMsg = fDeltaOnly?
			    MSG_DELTA_CRLS_PUBLISHED :
			    (g_fDeltaCRLPublishDisabled?
				MSG_BASE_CRLS_PUBLISHED :
				MSG_BASE_AND_DELTA_CRLS_PUBLISHED);
		if (NULL != pwszHostName)
		{
		    LogMsg = fDeltaOnly?
			MSG_DELTA_CRLS_PUBLISHED_HOST_NAME :
			(g_fDeltaCRLPublishDisabled?
			    MSG_BASE_CRLS_PUBLISHED_HOST_NAME :
			    MSG_BASE_AND_DELTA_CRLS_PUBLISHED_HOST_NAME);
		}
		hr = LogEvent(
			EVENTLOG_INFORMATION_TYPE,
			LogMsg,
			NULL == pwszHostName? 0 : 1,	// cStrings
			(WCHAR const **) &pwszHostName);	// apwszStrings
		_PrintIfError(hr, "LogEvent");
	    }
	}

	// If the retry count has changed, update the registry.

	if (dwCurrentAttempts != dwPreviousAttempts)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"CRLPublishCRLs(Attempts: %u --> %u)\n",
		dwPreviousAttempts,
		dwCurrentAttempts));

	    hr = mySetCertRegDWValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    wszREGCRLATTEMPTREPUBLISH,
			    dwCurrentAttempts);
	    _JumpIfErrorStr(
			hr,
			error,
			"mySetCertRegDWValue",
			wszREGCRLATTEMPTREPUBLISH);

	    // If we tried unsuccessfully too many times to publish these CRLs,
	    // and we're about to give up until a new set is generated, log an
	    // event saying so.

	    if (fExitNotify &&
		CERTSRV_CRLPUB_RETRY_COUNT_DEFAULT == dwCurrentAttempts &&
		CERTLOG_ERROR <= g_dwLogLevel)
	    {
		WCHAR wszAttempts[11 + 1];
		WCHAR const *pwsz = wszAttempts;

		wsprintf(wszAttempts, L"%u", dwCurrentAttempts);
		
		hr = LogEvent(
			EVENTLOG_ERROR_TYPE,
			MSG_E_CRL_PUBLICATION_TOO_MANY_RETRIES,
			1,		// cStrings
			&pwsz);	// apwszStrings
		_PrintIfError(hr, "LogEvent");
	    }
	}
	if (fRebuildCRL)
	{
	    // Delete old CRLs only if new CRLs built & published successfully.

	    if (!fRetryNeeded)
	    {
		hr = CertSrvTestServerState();
		_JumpIfError(hr, error, "CertSrvTestServerState");

		hr = crlDeleteExpiredCRLs(
				    &ftCurrent,
				    &ftQueryDeltaDelete,
				    RowIdBase);
		_PrintIfError(hr, "crlDeleteExpiredCRLs");
	    }

	    // Clear force CRL flag only when we build new CRLs.

	    hr = SetSetupStatus(g_wszSanitizedName, SETUP_FORCECRL_FLAG, FALSE);
	    _PrintIfError(hr, "SetSetupStatus");
	}
    }
    s_fSkipRetry = NULL != pwszUserName;

    if (fRebuildCRL || fRetryNeeded)
    {
	// If we are doing ANYTHING that will affect automatic wakeup, trigger
	// our publish event.
	// NOTE: do this last or else state might not be updated

	SetEvent(g_hCRLManualPublishEvent);
    }
    hr = S_OK;

error:
    *pfRetryNeeded = fRetryNeeded;
    if (fCoInitialized)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
CRLGetCRL(
    IN DWORD iCertArg,
    IN BOOL fDelta,
    OPTIONAL OUT CRL_CONTEXT const **ppCRL,
    OPTIONAL OUT DWORD *pdwCRLPublishFlags)
{
    HRESULT hr;
    DWORD State;
    DWORD iCert;
    DWORD iCRL;
    CACTX *pCAContext;
    DWORD dwRowId;
    BYTE *pbCRL = NULL;
    DWORD cbCRL;

    if (NULL != ppCRL)
    {
	*ppCRL = NULL;
    }

    hr = PKCSMapCRLIndex(iCertArg, &iCert, &iCRL, &State);
    _JumpIfError(hr, error, "PKCSMapCRLIndex");

    if (MAXDWORD != iCertArg && CA_DISP_VALID != State)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "No CRL for this Cert");
    }

    // Now we know iCert is a valid Cert Index:

    hr = crlGetRowIdAndCRL(
		    fDelta,
		    &g_aCAContext[iCert],
		    &dwRowId,
		    &cbCRL,
		    &pbCRL,
		    pdwCRLPublishFlags);
    _JumpIfError(hr, error, "crlGetRowIdAndCRL");

    if (NULL != ppCRL)
    {
	*ppCRL = CertCreateCRLContext(X509_ASN_ENCODING, pbCRL, cbCRL);
        if (NULL == *ppCRL)
        {
	    hr = myHLastError();
            _JumpError(hr, error, "CertCreateCRLContext");
        }
    }
    hr = S_OK;

error:
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\core.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        core.cpp
//
// Contents:    Cert Server Core implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lm.h>

#include "cscom.h"
#include "csprop.h"
#include "cspolicy.h"
#include "ciinit.h"
#include "csdisp.h"
#include "csldap.h"
#include "cainfop.h"
#include "elog.h"
#include "certlog.h"
#include "resource.h"

#define __dwFILE__	__dwFILE_CERTSRV_CORE_CPP__


#if DBG_COMTEST
#define DBG_COMTEST_CONST
#else
#define DBG_COMTEST_CONST	const
#endif


DBG_COMTEST_CONST BOOL fComTest = FALSE;

SERVERCALLBACKS ServerCallBacks = {
    PropCIGetProperty,
    PropCISetProperty,
    PropCIGetExtension,
    PropCISetExtension,
    PropCIEnumSetup,
    PropCIEnumNext,
    PropCIEnumClose,
};


HINSTANCE g_hInstance;
WCHAR g_wszSharedFolder[MAX_PATH];
WCHAR g_wszSanitizedName[MAX_PATH];
WCHAR *g_pwszSanitizedDSName;
WCHAR g_wszCommonName[MAX_PATH];
WCHAR g_wszParentConfig[MAX_PATH];

WCHAR *g_pwszzSubjectTemplate = NULL;
WCHAR *g_pwszServerName = NULL;

DWORD g_dwClockSkewMinutes = CCLOCKSKEWMINUTESDEFAULT;
DWORD g_dwLogLevel = CERTLOG_WARNING;
DWORD g_dwHighSerial = 0;
DWORD g_cbMaxIncomingMessageSize = MAXINCOMINGMESSAGESIZEDEFAULT;

WCHAR const g_wszRegValidityPeriodString[] = wszREGVALIDITYPERIODSTRING;
WCHAR const g_wszRegValidityPeriodCount[] = wszREGVALIDITYPERIODCOUNT;

WCHAR const g_wszRegCAXchgValidityPeriodString[] = wszREGCAXCHGVALIDITYPERIODSTRING;
WCHAR const g_wszRegCAXchgValidityPeriodCount[] = wszREGCAXCHGVALIDITYPERIODCOUNT;
WCHAR const g_wszRegCAXchgOverlapPeriodString[] = wszREGCAXCHGOVERLAPPERIODSTRING;
WCHAR const g_wszRegCAXchgOverlapPeriodCount[] = wszREGCAXCHGOVERLAPPERIODCOUNT;
WCHAR const g_wszRegCAXchgCertHash[] = wszREGCAXCHGCERTHASH;

WCHAR const g_wszRegSubjectTemplate[] = wszREGSUBJECTTEMPLATE;
WCHAR const g_wszRegKeyConfigPath[] = wszREGKEYCONFIGPATH;
WCHAR const g_wszRegDirectory[] = wszREGDIRECTORY;
WCHAR const g_wszRegActive[] = wszREGACTIVE;
WCHAR const g_wszRegEnabled[] = wszREGENABLED;
WCHAR const g_wszRegPolicyFlags[] = wszREGPOLICYFLAGS;
WCHAR const g_wszCertSrvServiceName[] = wszSERVICE_NAME;
WCHAR const g_wszRegCertEnrollCompatible[] = wszREGCERTENROLLCOMPATIBLE;
WCHAR const g_wszRegEnforceX500NameLengths[] = wszREGENFORCEX500NAMELENGTHS;
WCHAR const g_wszRegForceTeletex[] = wszREGFORCETELETEX;
WCHAR const g_wszRegClockSkewMinutes[] = wszREGCLOCKSKEWMINUTES;
WCHAR const g_wszRegLogLevel[] = wszREGLOGLEVEL;
WCHAR const g_wszRegHighSerial[] = wszREGHIGHSERIAL;
WCHAR const g_wszRegMaxIncomingMessageSize[] = wszREGMAXINCOMINGMESSAGESIZE;

BOOL g_fCertEnrollCompatible = TRUE;
BOOL g_fEnforceRDNNameLengths = TRUE;
DWORD g_KRAFlags = 0;
DWORD g_CRLEditFlags = EDITF_ENABLEAKIKEYID |
			EDITF_ENABLEAKIISSUERNAME |
			EDITF_ENABLEAKIISSUERSERIAL |
			EDITF_ENABLEAKICRITICAL;
ENUM_FORCETELETEX g_fForceTeletex = ENUM_TELETEX_AUTO;
ENUM_CATYPES g_CAType = ENUM_UNKNOWN_CA;

BOOL g_fUseDS = FALSE;
BOOL g_fcritsecDSCache = FALSE;
BOOL g_fServerUpgraded = FALSE;
CRITICAL_SECTION g_critsecDSCache;
BOOL g_fLockICertRequest = FALSE;

//+--------------------------------------------------------------------------
// Name properties:

WCHAR const g_wszPropDistinguishedName[] = wszPROPDISTINGUISHEDNAME;
WCHAR const g_wszPropRawName[] = wszPROPRAWNAME;

WCHAR const g_wszPropCountry[] = wszPROPCOUNTRY;
WCHAR const g_wszPropOrganization[] = wszPROPORGANIZATION;
WCHAR const g_wszPropOrgUnit[] = wszPROPORGUNIT;
WCHAR const g_wszPropCommonName[] = wszPROPCOMMONNAME;
WCHAR const g_wszPropLocality[] = wszPROPLOCALITY;
WCHAR const g_wszPropState[] = wszPROPSTATE;
WCHAR const g_wszPropTitle[] = wszPROPTITLE;
WCHAR const g_wszPropGivenName[] = wszPROPGIVENNAME;
WCHAR const g_wszPropInitials[] = wszPROPINITIALS;
WCHAR const g_wszPropSurName[] = wszPROPSURNAME;
WCHAR const g_wszPropDomainComponent[] = wszPROPDOMAINCOMPONENT;
WCHAR const g_wszPropEMail[] = wszPROPEMAIL;
WCHAR const g_wszPropStreetAddress[] = wszPROPSTREETADDRESS;
WCHAR const g_wszPropUnstructuredAddress[] = wszPROPUNSTRUCTUREDADDRESS;
WCHAR const g_wszPropUnstructuredName[] = wszPROPUNSTRUCTUREDNAME;
WCHAR const g_wszPropDeviceSerialNumber[] = wszPROPDEVICESERIALNUMBER;


//+--------------------------------------------------------------------------
// Subject Name properties:

WCHAR const g_wszPropSubjectDot[] = wszPROPSUBJECTDOT;
WCHAR const g_wszPropSubjectDistinguishedName[] = wszPROPSUBJECTDISTINGUISHEDNAME;
WCHAR const g_wszPropSubjectRawName[] = wszPROPSUBJECTRAWNAME;

WCHAR const g_wszPropSubjectCountry[] = wszPROPSUBJECTCOUNTRY;
WCHAR const g_wszPropSubjectOrganization[] = wszPROPSUBJECTORGANIZATION;
WCHAR const g_wszPropSubjectOrgUnit[] = wszPROPSUBJECTORGUNIT;
WCHAR const g_wszPropSubjectCommonName[] = wszPROPSUBJECTCOMMONNAME;
WCHAR const g_wszPropSubjectLocality[] = wszPROPSUBJECTLOCALITY;
WCHAR const g_wszPropSubjectState[] = wszPROPSUBJECTSTATE;
WCHAR const g_wszPropSubjectTitle[] = wszPROPSUBJECTTITLE;
WCHAR const g_wszPropSubjectGivenName[] = wszPROPSUBJECTGIVENNAME;
WCHAR const g_wszPropSubjectInitials[] = wszPROPSUBJECTINITIALS;
WCHAR const g_wszPropSubjectSurName[] = wszPROPSUBJECTSURNAME;
WCHAR const g_wszPropSubjectDomainComponent[] = wszPROPSUBJECTDOMAINCOMPONENT;
WCHAR const g_wszPropSubjectEMail[] = wszPROPSUBJECTEMAIL;
WCHAR const g_wszPropSubjectStreetAddress[] = wszPROPSUBJECTSTREETADDRESS;
WCHAR const g_wszPropSubjectUnstructuredAddress[] = wszPROPSUBJECTUNSTRUCTUREDADDRESS;
WCHAR const g_wszPropSubjectUnstructuredName[] = wszPROPSUBJECTUNSTRUCTUREDNAME;
WCHAR const g_wszPropSubjectDeviceSerialNumber[] = wszPROPSUBJECTDEVICESERIALNUMBER;


//+--------------------------------------------------------------------------
// Issuer Name properties:

WCHAR const g_wszPropIssuerDot[] = wszPROPISSUERDOT;
WCHAR const g_wszPropIssuerDistinguishedName[] = wszPROPISSUERDISTINGUISHEDNAME;
WCHAR const g_wszPropIssuerRawName[] = wszPROPISSUERRAWNAME;

WCHAR const g_wszPropIssuerCountry[] = wszPROPISSUERCOUNTRY;
WCHAR const g_wszPropIssuerOrganization[] = wszPROPISSUERORGANIZATION;
WCHAR const g_wszPropIssuerOrgUnit[] = wszPROPISSUERORGUNIT;
WCHAR const g_wszPropIssuerCommonName[] = wszPROPISSUERCOMMONNAME;
WCHAR const g_wszPropIssuerLocality[] = wszPROPISSUERLOCALITY;
WCHAR const g_wszPropIssuerState[] = wszPROPISSUERSTATE;
WCHAR const g_wszPropIssuerTitle[] = wszPROPISSUERTITLE;
WCHAR const g_wszPropIssuerGivenName[] = wszPROPISSUERGIVENNAME;
WCHAR const g_wszPropIssuerInitials[] = wszPROPISSUERINITIALS;
WCHAR const g_wszPropIssuerSurName[] = wszPROPISSUERSURNAME;
WCHAR const g_wszPropIssuerDomainComponent[] = wszPROPISSUERDOMAINCOMPONENT;
WCHAR const g_wszPropIssuerEMail[] = wszPROPISSUEREMAIL;
WCHAR const g_wszPropIssuerStreetAddress[] = wszPROPISSUERSTREETADDRESS;
WCHAR const g_wszPropIssuerUnstructuredAddress[] = wszPROPISSUERUNSTRUCTUREDADDRESS;
WCHAR const g_wszPropIssuerUnstructuredName[] = wszPROPISSUERUNSTRUCTUREDNAME;
WCHAR const g_wszPropIssuerDeviceSerialNumber[] = wszPROPISSUERDEVICESERIALNUMBER;


//+--------------------------------------------------------------------------
// Request properties:

WCHAR const g_wszPropRequestRequestID[] = wszPROPREQUESTREQUESTID;
WCHAR const g_wszPropRequestRawRequest[] = wszPROPREQUESTRAWREQUEST;
WCHAR const g_wszPropRequestRawArchivedKey[] = wszPROPREQUESTRAWARCHIVEDKEY;
WCHAR const g_wszPropRequestKeyRecoveryHashes[] = wszPROPREQUESTKEYRECOVERYHASHES;
WCHAR const g_wszPropRequestRawOldCertificate[] = wszPROPREQUESTRAWOLDCERTIFICATE;
WCHAR const g_wszPropRequestAttributes[] = wszPROPREQUESTATTRIBUTES;
WCHAR const g_wszPropRequestType[] = wszPROPREQUESTTYPE;
WCHAR const g_wszPropRequestFlags[] = wszPROPREQUESTFLAGS;
WCHAR const g_wszPropRequestStatusCode[] = wszPROPREQUESTSTATUSCODE;
WCHAR const g_wszPropRequestDisposition[] = wszPROPREQUESTDISPOSITION;
WCHAR const g_wszPropRequestDispositionMessage[] = wszPROPREQUESTDISPOSITIONMESSAGE;
WCHAR const g_wszPropRequestSubmittedWhen[] = wszPROPREQUESTSUBMITTEDWHEN;
WCHAR const g_wszPropRequestResolvedWhen[] = wszPROPREQUESTRESOLVEDWHEN;
WCHAR const g_wszPropRequestRevokedWhen[] = wszPROPREQUESTREVOKEDWHEN;
WCHAR const g_wszPropRequestRevokedEffectiveWhen[] = wszPROPREQUESTREVOKEDEFFECTIVEWHEN;
WCHAR const g_wszPropRequestRevokedReason[] = wszPROPREQUESTREVOKEDREASON;
WCHAR const g_wszPropRequesterName[] = wszPROPREQUESTERNAME;
WCHAR const g_wszPropCallerName[] = wszPROPCALLERNAME;
WCHAR const g_wszPropRequestOSVersion[] = wszPROPREQUESTOSVERSION;
WCHAR const g_wszPropRequestCSPProvider[] = wszPROPREQUESTCSPPROVIDER;
//+--------------------------------------------------------------------------
// Request attribute properties:

WCHAR const g_wszPropChallenge[] = wszPROPCHALLENGE;
WCHAR const g_wszPropExpectedChallenge[] = wszPROPEXPECTEDCHALLENGE;


//+--------------------------------------------------------------------------
// Certificate properties:

WCHAR const g_wszPropCertificateRequestID[] = wszPROPCERTIFICATEREQUESTID;
WCHAR const g_wszPropRawCertificate[] = wszPROPRAWCERTIFICATE;
WCHAR const g_wszPropCertificateHash[] = wszPROPCERTIFICATEHASH;
WCHAR const g_wszPropCertificateSerialNumber[] = wszPROPCERTIFICATESERIALNUMBER;
WCHAR const g_wszPropCertificateIssuerNameID[] = wszPROPCERTIFICATEISSUERNAMEID;
WCHAR const g_wszPropCertificateNotBeforeDate[] = wszPROPCERTIFICATENOTBEFOREDATE;
WCHAR const g_wszPropCertificateNotAfterDate[] = wszPROPCERTIFICATENOTAFTERDATE;
WCHAR const g_wszPropCertificateSubjectKeyIdentifier[] = wszPROPCERTIFICATESUBJECTKEYIDENTIFIER;
WCHAR const g_wszPropCertificateRawPublicKey[] = wszPROPCERTIFICATERAWPUBLICKEY;
WCHAR const g_wszPropCertificatePublicKeyLength[] = wszPROPCERTIFICATEPUBLICKEYLENGTH;
WCHAR const g_wszPropCertificatePublicKeyAlgorithm[] = wszPROPCERTIFICATEPUBLICKEYALGORITHM;
WCHAR const g_wszPropCertificateRawPublicKeyAlgorithmParameters[] = wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS;


// Strings loaded from the resource file:

WCHAR const *g_pwszRequestedBy;
WCHAR const *g_pwszDeniedBy;
WCHAR const *g_pwszPublishedBy;
WCHAR const *g_pwszPolicyDeniedRequest;
WCHAR const *g_pwszIssued;
WCHAR const *g_pwszUnderSubmission;
WCHAR const *g_pwszRequestProcessingError;
WCHAR const *g_pwszRequestParsingError;

WCHAR const *g_pwszRevokedBy;
WCHAR const *g_pwszUnrevokedBy;
WCHAR const *g_pwszResubmittedBy;
WCHAR const *g_pwszPrintfCertRequestDisposition;
WCHAR const *g_pwszUnknownSubject;
WCHAR const *g_pwszIntermediateCAStore;
WCHAR const *g_pwszPublishError;
WCHAR const *g_pwszYes;
WCHAR const *g_pwszNo;

LPWSTR g_wszzSecuredAttributes = NULL;

LPCWSTR g_wszzSecuredAttributesDefault = wszzDEFAULTSIGNEDATTRIBUTES; 


typedef struct _STRINGINITMAP
{
    int		  idResource;
    WCHAR const **ppwszResource;
} STRINGINITMAP;

STRINGINITMAP g_aStringInitStrings[] = {
    { IDS_REVOKEDBY,			&g_pwszRevokedBy },
    { IDS_UNREVOKEDBY,			&g_pwszUnrevokedBy },
    { IDS_RESUBMITTEDBY,		&g_pwszResubmittedBy },
    { IDS_REQUESTEDBY,			&g_pwszRequestedBy },
    { IDS_DENIEDBY,			&g_pwszDeniedBy },
    { IDS_PUBLISHEDBY,			&g_pwszPublishedBy },
    { IDS_POLICYDENIED,			&g_pwszPolicyDeniedRequest },
    { IDS_ISSUED,			&g_pwszIssued },
    { IDS_REQUESTPROCESSERROR,		&g_pwszRequestProcessingError },
    { IDS_REQUESTPARSEERROR,		&g_pwszRequestParsingError },
    { IDS_UNDERSUBMISSION,		&g_pwszUnderSubmission },
    { IDS_PRINTFCERTREQUESTDISPOSITION, &g_pwszPrintfCertRequestDisposition },
    { IDS_UNKNOWNSUBJECT, 		&g_pwszUnknownSubject },
    { IDS_INTERMEDIATECASTORE,		&g_pwszIntermediateCAStore },
    { IDS_PUBLISHERROR,			&g_pwszPublishError },
    { IDS_YES,  &g_pwszYes},
    { IDS_NO,   &g_pwszNo},
    { IDS_ALLOW,&g_pwszAuditResources[0]}, 
    { IDS_DENY, &g_pwszAuditResources[1]},
    { IDS_CAADMIN, &g_pwszAuditResources[2]},
    { IDS_OFFICER, &g_pwszAuditResources[3]},
    { IDS_READ, &g_pwszAuditResources[4]},
    { IDS_ENROLL, &g_pwszAuditResources[5]},
};


typedef struct _DSCACHE
{
    _DSCACHE *pdscNext;
    WCHAR    *pwszDomain;
    LDAP     *pld;
} DSCACHE;

DSCACHE *g_DSCache = NULL;
HANDLE g_hDS = NULL;


DWORD
coreDSUnbindWorker(
    OPTIONAL IN OUT VOID *pvparms)
{
    HANDLE hDS = (HANDLE) pvparms;

    DsUnBind(&hDS);
    return(0);
}


VOID
coreDSUnBind(
    IN BOOL fSynchronous)
{
    HRESULT hr;
    HANDLE hDS = g_hDS;
    HANDLE hThread = NULL;
    DWORD ThreadId;

    if (NULL != hDS)
    {
	g_hDS = NULL;
	if (fSynchronous)
	{
	    coreDSUnbindWorker(hDS);
	}
	else
	{
	    hThread = CreateThread(
			    NULL,	// lpThreadAttributes (Security Attr)
			    0,		// dwStackSize
			    coreDSUnbindWorker,
			    hDS,	// lpParameter
			    0,          // dwCreationFlags
			    &ThreadId);
	    if (NULL == hThread)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CreateThread");
	    }
	}
    }

error:
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
}


HRESULT
myAddDomainName(
    IN WCHAR const *pwszSamName,
    OUT WCHAR **ppwszSamName,		// *ppwszSamName is NULL if unchanged
    OUT WCHAR const **ppwszUserName)
{
    HRESULT hr;
    WCHAR const *pwszUserName;
    WCHAR wszDomain[MAX_PATH];

    *ppwszSamName = NULL;
    *ppwszUserName = NULL;

    if (L'\0' == *pwszSamName)
    {
	hr = E_ACCESSDENIED;	// can't have a zero length name
	_JumpError(hr, error, "zero length name");
    }

    // See if it includes a domain name.

    pwszUserName = wcschr(pwszSamName, L'\\');
    if (NULL == pwszUserName)
    {
	DWORD cwc = ARRAYSIZE(wszDomain);
	WCHAR *pwsz;

        // There was no domain portion, so assume part of the current domain.

        if (GetUserNameEx(NameSamCompatible, wszDomain, &cwc))
        {
            // Fix NULL termination bug

            if (0 != cwc)
            {
		cwc--;
            }
	    wszDomain[cwc] = L'\0';
            pwsz = wcschr(wszDomain, L'\\');
            if (NULL != pwsz)
            {
                pwsz++;
                wcsncpy(pwsz, pwszSamName, ARRAYSIZE(wszDomain) - cwc);

		hr = myDupString(wszDomain, ppwszSamName);
		_JumpIfError(hr, error, "myDupString");

		pwszSamName = *ppwszSamName;
            }          
        }
    }
    pwszUserName = wcschr(pwszSamName, L'\\');
    if (NULL == pwszUserName)
    {
        pwszUserName = pwszSamName;
    }
    else
    {
        pwszUserName++;
    }
    *ppwszUserName = pwszUserName;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
coreGetDNFromSamName(
    IN WCHAR const *pwszSamName,
    OUT WCHAR **ppwszDN)
{
    HRESULT hr;
    BOOL fRediscover = FALSE;
    DS_NAME_RESULTW *pNameResults = NULL;

    CSASSERT(NULL != ppwszDN);
    *ppwszDN = NULL;

    while (TRUE)
    {
	if (fRediscover)
	{
	    coreDSUnBind(FALSE);
	}
	if (NULL == g_hDS)
	{
	    hr = DsBind(NULL, NULL, &g_hDS);
	    if (S_OK != hr)
	    {
		hr = myHError(hr);
		_JumpError(hr, error, "DsBind");
	    }
	}

	// Got a connection.  Crack the name:

	hr = DsCrackNames(
		    g_hDS,
		    DS_NAME_NO_FLAGS,
		    DS_NT4_ACCOUNT_NAME,
		    DS_FQDN_1779_NAME,
		    1,			// one name
		    &pwszSamName,		// one name (IN)
		    &pNameResults);		// OUT
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    if (!fRediscover)
	    {
		_PrintError(hr, "DsCrackNames");
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "DsCrackNames");
	}
	if (1 > pNameResults->cItems ||
	    DS_NAME_NO_ERROR != pNameResults->rItems[0].status)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	    if (!fRediscover)
	    {
		_PrintError(hr, "DsCrackNames result");
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "DsCrackNames result");
	}
	break;
    }
    hr = myDupString(pNameResults->rItems[0].pName, ppwszDN);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pNameResults)
    {
	DsFreeNameResult(pNameResults);
    }
    return(hr);
}



HRESULT
coreGetComContextUserDNFromSamName(
    IN BOOL fDeleteUserDNOnly,
    OPTIONAL IN WCHAR const *pwszSamName,
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OPTIONAL OUT WCHAR const **ppwszDN)		// do NOT free!
{
    HRESULT hr;
    CERTSRV_COM_CONTEXT *pComContext;

    hr = ComGetClientInfo(Context, dwComContextIndex, &pComContext);
    _JumpIfError(hr, error, "ComGetClientInfo");

    if (fDeleteUserDNOnly)
    {
	if (NULL != pComContext->pwszUserDN)
	{
	    LocalFree(pComContext->pwszUserDN);
	    pComContext->pwszUserDN = NULL;
	}
    }
    else
    {
	if (NULL == pComContext->pwszUserDN)
	{
	    hr = coreGetDNFromSamName(pwszSamName, &pComContext->pwszUserDN);
	    _JumpIfError(hr, error, "coreGetDNFromSamName");
	}
    }
    if (NULL != ppwszDN)
    {
	*ppwszDN = pComContext->pwszUserDN;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CoreSetComContextUserDN(
    IN DWORD dwRequestId,
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OPTIONAL OUT WCHAR const **ppwszDN)		// do NOT free!
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    WCHAR *pwszSamName = NULL;
    WCHAR *pwszSamNamePatched = NULL;
    WCHAR const *pwszUserName;

    hr = g_pCertDB->OpenRow(
		    PROPOPEN_READONLY | PROPTABLE_REQCERT,
		    dwRequestId,
		    NULL,
		    &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		(BYTE **) &pwszSamName);
    _JumpIfError(hr, error, "PKCSGetProperty");

    hr = myAddDomainName(pwszSamName, &pwszSamNamePatched, &pwszUserName);
    _JumpIfError(hr, error, "myAddDomainName");

    hr = coreGetComContextUserDNFromSamName(
		FALSE,		// fDeleteUserDNOnly
		NULL != pwszSamNamePatched? pwszSamNamePatched : pwszSamName,
		Context,
		dwComContextIndex,
		ppwszDN);
    _JumpIfError(hr, error, "coreGetComContextUserDNFromSamName");

error:
    if (NULL != pwszSamName)
    {
	LocalFree(pwszSamName);
    }
    if (NULL != pwszSamNamePatched)
    {
	LocalFree(pwszSamNamePatched);
    }
    if (NULL != prow)
    {
        prow->Release();
    }
    return(hr);
}


VOID
CoreTerminate(VOID)
{
    VOID coreFreeDSCache();

    coreFreeDSCache();
    DBShutDown(FALSE);
    ComShutDown();
    PKCSTerminate();
    CRLTerminate();
    if (NULL != g_pwszServerName)
    {
	LocalFree(g_pwszServerName);
	g_pwszServerName = NULL;
    }
    if (NULL != g_pwszzSubjectTemplate)
    {
	LocalFree(g_pwszzSubjectTemplate);
	g_pwszzSubjectTemplate = NULL;
    }
    if (NULL != g_pwszSanitizedDSName)
    {
	LocalFree(g_pwszSanitizedDSName);
	g_pwszSanitizedDSName = NULL;
    }

    // free only if it points to memory that isn't the default static buffer

    if (NULL != g_wszzSecuredAttributes &&
	g_wszzSecuredAttributes != g_wszzSecuredAttributesDefault)
    {
        LocalFree(g_wszzSecuredAttributes);
        g_wszzSecuredAttributes = NULL;
    }
    if (g_fcritsecDSCache)
    {
	DeleteCriticalSection(&g_critsecDSCache);
	g_fcritsecDSCache = FALSE;
    }
}


DWORD g_PolicyFlags;


HRESULT
CoreSetDisposition(
    IN ICertDBRow *prow,
    IN DWORD Disposition)
{
    HRESULT hr;

    hr = prow->SetProperty(
		    g_wszPropRequestDisposition,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(Disposition),
		    (BYTE const *) &Disposition);
    _JumpIfError(hr, error, "SetProperty(disposition)");

error:
    return(hr);
}


DWORD
coreRegGetTimePeriod(
    IN HKEY hkeyCN,
    IN WCHAR const *pwszRegPeriodCount,
    IN WCHAR const *pwszRegPeriodString,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount)
{
    HRESULT hr;
    LONG lCount;
    DWORD dwType;
    DWORD cbValue;
    
    cbValue = sizeof(lCount);
    hr = RegQueryValueEx(
		hkeyCN,
		pwszRegPeriodCount,
		NULL,		// lpdwReserved
		&dwType,
		(BYTE *) &lCount,
		&cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(lCount) == cbValue)
    {
        WCHAR awcPeriod[10];
        
        cbValue = sizeof(awcPeriod);
        hr = RegQueryValueEx(
		    hkeyCN,
		    pwszRegPeriodString,
		    NULL,		// lpdwReserved
		    &dwType,
		    (BYTE *) &awcPeriod,
		    &cbValue);
        if (S_OK != hr)
        {
            hr = myHError(hr);
            if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
            _JumpIfError(hr, error, "RegQueryValueEx");
        }
        else
        {
            
            if (REG_SZ != dwType || sizeof(awcPeriod) <= cbValue)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpIfErrorStr(hr, error, "time period string", pwszRegPeriodString);
            }
            hr = myTranslatePeriodUnits(
				awcPeriod,
				lCount,
				penumPeriod,
				plCount);
            _JumpIfError(hr, error, "myTranslatePeriodUnits");
        }
    }
error:
    return(hr);
}


// Converts a REG_SZ Subject template into a double null terminated REG_MULTI_SZ type string

DWORD
coreConvertSubjectTemplate(
    OUT WCHAR* pwszz,
    IN WCHAR* pwszTemplate,
    IN DWORD cwc)
{
    HRESULT hr;
    WCHAR *pwszToken;
    WCHAR *pwszRemain = pwszTemplate;
    WCHAR *pwszzNew = pwszz;
    DWORD cwszzNew = 0;
    BOOL fSplit;

    while (TRUE)
    {
        pwszToken = PKCSSplitToken(&pwszRemain, wszNAMESEPARATORDEFAULT, &fSplit);
        if (NULL == pwszToken)
        {
            *pwszzNew = L'\0';
            break;
        }
        cwszzNew += (1 + wcslen(pwszToken)) * sizeof(WCHAR);
        if (cwszzNew > cwc)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "overflow");
        }
        wcscpy(pwszzNew, pwszToken);
        pwszzNew = wcschr(pwszzNew, L'\0');
        pwszzNew++;
    }
    hr = S_OK;

error:
    return(hr);
}
			
			

HRESULT
CoreInit(VOID)
{
    HRESULT hr;
    HKEY hkeyConfig = NULL;
    HKEY hkeyCN = NULL;
    BYTE abbuf[MAX_PATH * sizeof(TCHAR)];
    WCHAR awcTemplate[MAX_PATH];
    DWORD cbbuf;
    DWORD cchbuf;
    DWORD dwType;
    WCHAR *pwsz;
    DWORD dw;
    BOOL fLogError = TRUE;
    DWORD LogMsg = MSG_BAD_REGISTRY;
    WCHAR const *pwszLog = NULL;
    int i;
    DWORD cbValue;
    DWORD dwEnabled;
    CAuditEvent AuditSettings;
    
    __try
    {
	InitializeCriticalSection(&g_critsecDSCache);
	g_fcritsecDSCache = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    hr = myGetMachineDnsName(&g_pwszServerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");
    
    for (i = 0; i < ARRAYSIZE(g_aStringInitStrings); i++)
    {
        WCHAR const *pwszT;
        
        pwszT = myLoadResourceString(g_aStringInitStrings[i].idResource);
        if (NULL == pwszT)
        {
            hr = myHLastError();
            _JumpError(hr, error, "myLoadResourceString");
        }
        *g_aStringInitStrings[i].ppwszResource = pwszT;
    }
    
    hr = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        g_wszRegKeyConfigPath,
        0,		// dwReserved
        KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
        &hkeyConfig);
    _JumpIfError(hr, error, "RegOpenKeyEx(Config)");
    
    cbbuf = sizeof(abbuf);
    hr = RegQueryValueEx(
        hkeyConfig,
        g_wszRegDirectory,
        NULL,		// lpdwReserved
        &dwType,
        abbuf,
        &cbbuf);
    if (S_OK != hr)
    {
        hr = myHError(hr);
    }
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpIfError(hr, error, "RegQueryValueEx(Base)");
        
        if (REG_SZ != dwType)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "RegQueryValueEx(Base)");
        }
        if (sizeof(abbuf) < cbbuf)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            _JumpError(hr, error, "RegQueryValueEx(Base)");
        }
        CopyMemory(g_wszSharedFolder, abbuf, cbbuf);
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Shared Folder = '%ws'\n", g_wszSharedFolder));
    
    // Find out the name of the active CA(s)
    
    g_wszSanitizedName[0] = L'\0';
    cbbuf = sizeof(g_wszSanitizedName);
    hr = RegQueryValueEx(
        hkeyConfig,
        g_wszRegActive,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) g_wszSanitizedName,
        &cbbuf);
    if ((HRESULT) ERROR_FILE_NOT_FOUND == hr)
    {
#define szForgotSetup "\n\nDid you forget to setup the Cert Server?\n\n\n"

	CONSOLEPRINT0((MAXDWORD, szForgotSetup));
    }
    _JumpIfError(hr, error, "RegQueryValueEx(Base)");
    
    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "RegQueryValueEx: value type");
    }
    g_wszSanitizedName[cbbuf / sizeof(WCHAR)] = L'\0';
    if (REG_MULTI_SZ == dwType)
    {
        i = wcslen(g_wszSanitizedName);
        if (L'\0' != g_wszSanitizedName[i + 1])
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "RegQueryValueEx: multiple Active CAs");
        }
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Active CA (Sanitized Name) = '%ws'\n", g_wszSanitizedName));
    
    pwszLog = g_wszSanitizedName;

    hr = mySanitizedNameToDSName(g_wszSanitizedName, &g_pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");
    
    hr = RegOpenKeyEx(
        hkeyConfig,
        g_wszSanitizedName,
        0,		// dwReserved
        KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
        &hkeyCN);
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "RegOpenKeyEx");
    }
    
    cbValue = sizeof(g_wszCommonName) - 2 * sizeof(WCHAR);
    hr = RegQueryValueEx(
        hkeyCN,
        wszREGCOMMONNAME,
        NULL,
        &dwType,
        (BYTE *)g_wszCommonName,
        &cbValue);
    
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "RegOpenKeyEx");
    }
    if (REG_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "Couldn't find CA common name");
    }
    g_wszCommonName[cbValue / sizeof(WCHAR)] = L'\0';

    pwszLog = g_wszCommonName;
    
    cbValue = sizeof(dwEnabled);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegEnabled,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dwEnabled,
        &cbValue);
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "RegQueryValueEx");
    }
    if (REG_DWORD == dwType &&
        sizeof(dwEnabled) == cbValue &&
        0 == dwEnabled)
    {
        DBGPRINT((DBG_SS_CERTSRVI, "CN = '%ws' DISABLED!\n", g_wszSanitizedName));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "RegQueryValueEx: Active CA DISABLED!");
    }
    DBGPRINT((DBG_SS_CERTSRVI, "CN = '%ws': Enabled\n", g_wszSanitizedName));
    
    // to check machine setup status
    hr = GetSetupStatus(NULL, &dw);
    _JumpIfError(hr, error, "GetSetupStatus");
    
    if (!(SETUP_SERVER_FLAG & dw))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        _JumpError(hr, error, "Server installation was not complete");
    }
    if (SETUP_SERVER_UPGRADED_FLAG & dw)
    {
	g_fServerUpgraded = TRUE;
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CoreInit: read SETUP_SERVER_UPGRADED_FLAG\n"));
    }
    
    // check per ca
    hr = GetSetupStatus(g_wszSanitizedName, &dw);
    _JumpIfError(hr, error, "GetSetupStatus");
    
    if (SETUP_SUSPEND_FLAG & dw)
    {
        LogMsg = MSG_E_INCOMPLETE_HIERARCHY;
        hr = HRESULT_FROM_WIN32(ERROR_INSTALL_SUSPEND);
        _JumpError(hr, error, "Hierarchy setup incomplete");
    }
    if (!(SETUP_SERVER_FLAG & dw))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        _JumpError(hr, error, "Server installation was not complete");
    }
    if (SETUP_FORCECRL_FLAG & dw)
    {
	// Don't clear SETUP_FORCECRL_FLAG until CRLs successfully generated

	hr = myDeleteCertRegValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    wszREGCRLNEXTPUBLISH);
	_PrintIfErrorStr2(
		    hr,
		    "myDeleteCertRegValue",
		    wszREGCRLNEXTPUBLISH,
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

    // update the CA DS object with the server type flags

    if (SETUP_UPDATE_CAOBJECT_SVRTYPE & dw)
    {
        hr = SetCAObjectFlags(
			g_fAdvancedServer? CA_FLAG_CA_SERVERTYPE_ADVANCED : 0);
        _PrintIfError(hr, "SetCAObjectFlags");
        if (S_OK == hr)
        {
            hr = SetSetupStatus(
			g_wszSanitizedName, 
			SETUP_UPDATE_CAOBJECT_SVRTYPE, 
			FALSE);
            _PrintIfError(hr, "SetSetupStatus");
        }
    }
    
    cbValue = sizeof(g_PolicyFlags);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegPolicyFlags,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &g_PolicyFlags,
        &cbValue);
    if (S_OK != hr ||
        REG_DWORD != dwType ||
        sizeof(g_PolicyFlags) != cbValue)
    {
        g_PolicyFlags = 0;
    }
    
    cbValue = sizeof(awcTemplate);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegSubjectTemplate,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) awcTemplate,
        &cbValue);
    if (S_OK == hr &&
        (REG_SZ == dwType || REG_MULTI_SZ == dwType) &&
        sizeof(WCHAR) < cbValue &&
        L'\0' != awcTemplate[0])
    {
        if (L'\0' != awcTemplate[cbValue/sizeof(WCHAR) - 1] ||
            (REG_MULTI_SZ == dwType &&
            L'\0' != awcTemplate[cbValue/sizeof(WCHAR) - 2]) ||
            sizeof(awcTemplate) < cbValue)
        {
            LogMsg = MSG_E_REG_BAD_SUBJECT_TEMPLATE;
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "Bad Subject Template length/termination");
        }
        
        pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
        if (NULL != pwsz)
        {
            if (dwType == REG_MULTI_SZ)
            {
                CopyMemory(pwsz, awcTemplate, cbValue);
            }
            else
            {
                hr = coreConvertSubjectTemplate(pwsz, awcTemplate, cbValue);
                if (S_OK != hr)
                {
                    LocalFree(pwsz);
                }
                _JumpIfError(hr, error, "coreConvertSubjectTemplate");
            }
            g_pwszzSubjectTemplate = pwsz;
        }
    }
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegCertEnrollCompatible,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
        g_fCertEnrollCompatible = dw? TRUE : FALSE;
    }
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegEnforceX500NameLengths,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
        g_fEnforceRDNNameLengths = dw? TRUE : FALSE;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        wszREGCRLEDITFLAGS,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
	g_CRLEditFlags = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
	wszREGKRAFLAGS,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
	g_KRAFlags = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
	wszREGKRACERTCOUNT,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
	g_cKRACertsRoundRobin = dw;
    }
    
    hr = coreRegGetTimePeriod(
        hkeyCN,
        g_wszRegValidityPeriodCount,
        g_wszRegValidityPeriodString,
        &g_enumValidityPeriod,
        &g_lValidityPeriodCount);
    if (S_OK != hr)
    {
        LogMsg = MSG_E_REG_BAD_CERT_PERIOD;
        _JumpError(hr, error, "Bad Registry ValidityPeriod");
    }

    hr = coreRegGetTimePeriod(
        hkeyCN,
        g_wszRegCAXchgValidityPeriodCount,
        g_wszRegCAXchgValidityPeriodString,
        &g_enumCAXchgValidityPeriod,
        &g_lCAXchgValidityPeriodCount);
    _PrintIfError(hr, "Bad Registry CA Xchg Validity Period");

    hr = coreRegGetTimePeriod(
        hkeyCN,
        g_wszRegCAXchgOverlapPeriodCount,
        g_wszRegCAXchgOverlapPeriodString,
        &g_enumCAXchgOverlapPeriod,
        &g_lCAXchgOverlapPeriodCount);
    _PrintIfError(hr, "Bad Registry CA Xchg Overlap Period");
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegForceTeletex,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
	switch (ENUM_TELETEX_MASK & dw)
        {
	    case ENUM_TELETEX_OFF:
	    case ENUM_TELETEX_ON:
		g_fForceTeletex =
		    (enum ENUM_FORCETELETEX) (ENUM_TELETEX_MASK & dw);
		break;
            
	    default:
		g_fForceTeletex = ENUM_TELETEX_AUTO;
		break;
        }
        if (ENUM_TELETEX_UTF8 & dw)
	{
	    *(DWORD *) &g_fForceTeletex |= ENUM_TELETEX_UTF8;
	}
    }
    
    cbValue = sizeof(g_CAType);
    hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGCATYPE,
		    NULL,
		    &dwType,
		    (BYTE *) &g_CAType,
		    &cbValue);
    _JumpIfError(hr, error, "RegQueryValueEx");

    cbValue = sizeof(g_fUseDS);
    hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGCAUSEDS,
		    NULL,
		    &dwType,
		    (BYTE *) &g_fUseDS,
		    &cbValue);
    _JumpIfError(hr, error, "RegQueryValueEx");


    cbValue = sizeof(g_wszParentConfig) - 2 * sizeof(WCHAR);
    hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGPARENTCAMACHINE,
		    NULL,
		    &dwType,
		    (BYTE *) g_wszParentConfig,
		    &cbValue);
    if (S_OK == hr && REG_SZ == dwType)
    {
	g_wszParentConfig[cbValue / sizeof(WCHAR)] = L'\0';
	pwsz = &g_wszParentConfig[wcslen(g_wszParentConfig)];

	*pwsz++ = L'\\';
	*pwsz = L'\0';

	cbValue =
	    sizeof(g_wszParentConfig) - 
	    (SAFE_SUBTRACT_POINTERS(pwsz, g_wszParentConfig) + 1) *
		sizeof(WCHAR);
	hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGPARENTCANAME,
		    NULL,
		    &dwType,
		    (BYTE *) pwsz,
		    &cbValue);
	if (S_OK == hr && REG_SZ == dwType)
	{
	    pwsz[cbValue / sizeof(WCHAR)] = L'\0';
	}
	else
	{
	    g_wszParentConfig[0] = L'\0';
	}
    }
    else
    {
	g_wszParentConfig[0] = L'\0';
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegClockSkewMinutes,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_dwClockSkewMinutes = dw;
    }
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegMaxIncomingMessageSize,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_cbMaxIncomingMessageSize = dw;
    }

    // load CRL globals
    hr = CRLInit(g_wszSanitizedName);
    _JumpIfError(hr, error, "CRLInitializeGlobals");
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegLogLevel,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_dwLogLevel = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegHighSerial,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_dwHighSerial = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        wszLOCKICERTREQUEST,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_fLockICertRequest = dw;
    }


    hr = g_CASD.Initialize(g_wszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Initialize");

    g_CASD.ImportResourceStrings(g_pwszAuditResources);

    // Functionality available only on advanced server:
    // - auditing
    // - restricted officers
    // - enforce role separation

    if (g_fAdvancedServer)
    {
        hr = g_OfficerRightsSD.Initialize(g_wszSanitizedName);
        _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Initialize");

        g_OfficerRightsSD.ImportResourceStrings(g_pwszAuditResources);

        hr = AuditSettings.LoadFilter(g_wszSanitizedName);
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpIfError(hr, error, "CAuditEvent::LoadFilter");
        }

        hr = AuditSettings.RoleSeparationFlagLoad(g_wszSanitizedName);
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpIfError(hr, error, "CAuditEvent::RoleSeparationFlagLoad");
        }

    }
    g_dwAuditFilter = AuditSettings.GetFilter();

    
    hr = PKCSSetup(g_wszCommonName, g_wszSanitizedName);
    if (S_OK != hr)
    {
        fLogError = FALSE;		// PKCSSetup logs a specific error
        _JumpError(hr, error, "PKCSSetup");
    }
    
    hr = CertificateInterfaceInit(
        &ServerCallBacks,
        sizeof(ServerCallBacks));
    if (S_OK != hr)
    {
        LogMsg = MSG_CERTIF_MISMATCH;
        _JumpError(hr, error, "CertificateInterfaceInit");
    }

    hr = ComInit();
    _JumpIfError(hr, error, "ComInit");

    hr = RequestInitCAPropertyInfo();
    _JumpIfError(hr, error, "RequestInitCAPropertyInfo");

    // We must have a policy module to continue.
    hr = PolicyInit(g_wszCommonName, g_wszSanitizedName);
    if (S_OK != hr)
    {
        LogMsg = MSG_NO_POLICY;
        _JumpError(hr, error, "PolicyInit");
    }
    CSASSERT(g_fEnablePolicy);
    
    // On error, silently leave exit module(s) disabled.
    hr = ExitInit(g_wszCommonName, g_wszSanitizedName);
    _PrintIfError(hr, "ExitInit");
    
    if (NULL != g_pwszzSubjectTemplate)
    {
        hr = PKCSSetSubjectTemplate(g_pwszzSubjectTemplate);
        if (S_OK != hr)
        {
            LogMsg = MSG_E_REG_BAD_SUBJECT_TEMPLATE;
	    pwszLog = g_wszSanitizedName;
            _JumpError(hr, error, "PKCSSetSubjectTemplate");
        }
    }
    
    hr = myGetCertRegMultiStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    wszSECUREDATTRIBUTES,
			    &g_wszzSecuredAttributes);
    if (S_OK != hr)
    {
        // Force defaults
        g_wszzSecuredAttributes = (LPWSTR)g_wszzSecuredAttributesDefault;
    }

    if (g_fServerUpgraded)
    {
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CoreInit: clearing SETUP_SERVER_UPGRADED_FLAG\n"));

	hr = SetSetupStatus(NULL, SETUP_SERVER_UPGRADED_FLAG, FALSE);
	_PrintIfError(hr, "SetSetupStatus");
    }
    fLogError = FALSE;
    
error:
    if (fLogError)
    {
        LogEventString(EVENTLOG_ERROR_TYPE, LogMsg, pwszLog);
    }
    if (NULL != hkeyCN)
    {
        RegCloseKey(hkeyCN);
    }
    if (NULL != hkeyConfig)
    {
        RegCloseKey(hkeyConfig);
    }
    if (S_OK != hr)
    {
        CoreTerminate();
    }
    return(hr);
}


HRESULT
CoreSetRequestDispositionFields(
    IN ICertDBRow *prow,
    IN DWORD ErrCode,
    IN DWORD Disposition,
    IN WCHAR const *pwszDisposition)
{
    HRESULT hr;

    hr = CoreSetDisposition(prow, Disposition);
    _JumpIfError(hr, error, "CoreSetDisposition");

    hr = prow->SetProperty(
		    g_wszPropRequestStatusCode,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(ErrCode),
		    (BYTE const *) &ErrCode);
    _JumpIfError(hr, error, "SetProperty(status code)");

    if (NULL != pwszDisposition)
    {
	hr = prow->SetProperty(
		    g_wszPropRequestDispositionMessage,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszDisposition);
	_JumpIfError(hr, error, "SetProperty(disposition message)");
    }

error:
    return(hr);
}


HRESULT
coreCreateRequest(
    IN DWORD dwFlags,
    IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN WCHAR const *pwszAttributes,
    IN DWORD dwComContextIndex,
    OUT ICertDBRow **pprow,		// may return non-NULL on error
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD dwRequestFlags;
    DWORD cb;
    
    ICertDBRow *prow = NULL;
    
    hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, pprow);
    _JumpIfError(hr, error, "OpenRow");
    
    prow = *pprow;
    
    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestSubmittedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");
    
    hr = CoreSetDisposition(prow, DB_DISP_ACTIVE);
    _JumpIfError(hr, error, "CoreSetDisposition");
    
    hr = prow->SetProperty(
        g_wszPropRequestType,
        PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
        sizeof(dwFlags),
        (BYTE const *) &dwFlags);
    _JumpIfError(hr, error, "SetProperty(type)");
    
    if (L'\0' != *pwszUserName)
    {
        hr = prow->SetProperty(
            g_wszPropRequesterName,
            PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            MAXDWORD,
            (BYTE const *) pwszUserName);
        _JumpIfError(hr, error, "SetProperty(requester)");

        hr = prow->SetProperty(
            g_wszPropCallerName,
            PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            MAXDWORD,
            (BYTE const *) pwszUserName);
        _JumpIfError(hr, error, "SetProperty(caller)");
    }
    
    if (NULL != pwszAttributes && L'\0' != *pwszAttributes)
    {
        WCHAR awcAttributes[CCH_DBMAXTEXT_ATTRSTRING + 1];
        
        wcsncpy(awcAttributes, pwszAttributes, CCH_DBMAXTEXT_ATTRSTRING);
        awcAttributes[CCH_DBMAXTEXT_ATTRSTRING] = L'\0';
        if (wcslen(pwszAttributes) > CCH_DBMAXTEXT_ATTRSTRING)
        {
            DBGPRINT((
                DBG_SS_CERTSRV,
                "coreCreateRequest: truncating Attributes %u -> %u chars\n",
                wcslen(pwszAttributes),
                CCH_DBMAXTEXT_ATTRSTRING));
        }
        hr = prow->SetProperty(
            g_wszPropRequestAttributes,
            PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            MAXDWORD,
            (BYTE const *) awcAttributes);
        _JumpIfError(hr, error, "SetProperty(attrib)");
    }
    
    hr = PropParseRequest(prow, dwFlags, cbRequest, pbRequest, pResult);
    _JumpIfError(hr, error, "PropParseRequest");

    hr = PKCSParseAttributes(
			prow,
			pwszAttributes,
			FALSE,
			PROPTABLE_REQUEST,
			NULL);
    _JumpIfError(hr, error, "PKCSParseAttributes");

    hr = prow->CopyRequestNames();	// after parsing request attributes!
    _JumpIfError(hr, error, "CopyRequestNames");
    
    hr = PKCSVerifyChallengeString(prow);
    _JumpIfError(hr, error, "PKCSVerifyChallengeString");

    cb = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &cb,
		    (BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty");

    if (CR_FLG_ENROLLONBEHALFOF & dwRequestFlags)
    {
	hr = coreGetComContextUserDNFromSamName(
			    TRUE,		// fDeleteUserDNOnly
			    NULL,		// pwszSamName
			    0,			// Context
			    dwComContextIndex,
			    NULL);		// pwszDN
	_JumpIfError(hr, error, "coreGetComContextUserDNFromSamName");
    }
    hr = S_OK;
    
error:
    return(hr);
}


HRESULT
coreFetchCertificate(
    IN ICertDBRow *prow,
    OUT CERTTRANSBLOB *pctbCert)	// CoTaskMem*
{
    HRESULT hr;
    DWORD cbProp;
    
    pctbCert->pb = NULL;
    cbProp = 0;
    hr = prow->GetProperty(
        g_wszPropRawCertificate,
        PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
        &cbProp,
        NULL);
    _JumpIfError(hr, error, "GetProperty(raw cert size)");
    
    pctbCert->pb = (BYTE *) CoTaskMemAlloc(cbProp);
    if (NULL == pctbCert->pb)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "CoTaskMemAlloc(raw cert)");
    }
    hr = prow->GetProperty(
        g_wszPropRawCertificate,
        PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
        &cbProp,
        pctbCert->pb);
    _JumpIfError(hr, error, "GetProperty(raw cert)");
    
error:
    if (S_OK != hr && NULL != pctbCert->pb)
    {
        CoTaskMemFree(pctbCert->pb);
        pctbCert->pb = NULL;
    }
    pctbCert->cb = cbProp;
    return(hr);
}


HRESULT
coreRetrievePending(
    IN ICertDBRow *prow,
    IN BOOL fIncludeCRLs,
    OUT WCHAR **ppwszDisposition,		// LocalAlloc
    OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)	// CoTaskMem*
{
    HRESULT hr;
    DWORD cbProp;
    WCHAR *pwszDisposition = NULL;
    DWORD Disposition;
    HRESULT hrRequest;
    BOOL fIssued;

    *ppwszDisposition = NULL;
    *ppCAContext = NULL;
    cbProp = sizeof(Disposition);
    hr = prow->GetProperty(
		g_wszPropRequestDisposition,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cbProp,
		(BYTE *) &Disposition);
    _JumpIfError(hr, error, "GetProperty(disposition)");

    cbProp = sizeof(hrRequest);
    hr = prow->GetProperty(
		    g_wszPropRequestStatusCode,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &cbProp,
		    (BYTE *) &hrRequest);
    _JumpIfError(hr, error, "GetProperty(status code)");

    hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequestDispositionMessage,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    (BYTE **) &pwszDisposition);
    _PrintIfError2(hr, "PKCSGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    fIssued = FALSE;
    switch (Disposition)
    {
	FILETIME FileTime;

	case DB_DISP_ACTIVE:
	case DB_DISP_PENDING:
	    *pResult->pdwDisposition = CR_DISP_UNDER_SUBMISSION;
	    break;

	case DB_DISP_ISSUED:
	case DB_DISP_CA_CERT:
	case DB_DISP_CA_CERT_CHAIN:
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    if (DB_DISP_CA_CERT == Disposition && IsRootCA(g_CAType))
	    {
		cbProp = sizeof(FileTime);
		hr = prow->GetProperty(
			g_wszPropRequestRevokedEffectiveWhen,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cbProp,
			(BYTE *) &FileTime);
	    }
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		*pResult->pdwDisposition = CR_DISP_ISSUED;
		fIssued = TRUE;
		break;
	    }
	    // FALLTHROUGH

	case DB_DISP_REVOKED:
	    *pResult->pdwDisposition = CR_DISP_REVOKED;
	    fIssued = TRUE;
	    break;

	case DB_DISP_ERROR:
	    *pResult->pdwDisposition = CR_DISP_ERROR;
	    break;

	case DB_DISP_DENIED:
	    *pResult->pdwDisposition = CR_DISP_DENIED;
	    if (FAILED(hrRequest))
	    {
		*pResult->pdwDisposition = hrRequest;
	    }
	    break;

	default:
	    *pResult->pdwDisposition = CR_DISP_INCOMPLETE;
	    break;
    }
    if (fIssued)
    {
	BOOL fErrorLogged = FALSE;

	hr = coreFetchCertificate(prow, pResult->pctbCert);
	_JumpIfError(hr, error, "coreFetchCertificate");

	CSASSERT(NULL != pResult->pctbCert && NULL != pResult->pctbCert->pb);
	hr = PKCSCreateCertificate(
			    prow,
			    Disposition,
			    fIncludeCRLs,
			    &fErrorLogged,
			    ppCAContext,
			    pResult);

	CSASSERT(!fErrorLogged);

	if (S_OK != hr)
	{
	    if (CERTLOG_ERROR <= g_dwLogLevel)
	    {
		LogEventHResult(
			    EVENTLOG_ERROR_TYPE,
			    MSG_E_CANNOT_BUILD_CERT_OR_CHAIN,
			    hr);
	    }
	    _JumpError(hr, error, "PKCSCreateCertificate");
	}
    }
    *ppwszDisposition = pwszDisposition;
    pwszDisposition = NULL;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != pResult->pctbCert->pb)
    {
        CoTaskMemFree(pResult->pctbCert->pb);
        pResult->pctbCert->pb = NULL;
    }
    if (NULL != pwszDisposition)
    {
	LocalFree(pwszDisposition);
    }
    return(hr);
}


VOID
CoreLogRequestStatus(
    IN ICertDBRow *prow,
    IN DWORD LogMsg,
    IN DWORD ErrCode,
    OPTIONAL IN WCHAR const *pwszDisposition)
{
    HRESULT hr;
    DWORD cbProp;
    WCHAR awcSubject[1024];
    WCHAR const *pwszSubject;
    WCHAR wszRequestId[11 + 1];
    WCHAR awchr[cwcHRESULTSTRING];
    WORD cString = 0;
    WCHAR const *apwsz[4];
    DWORD ReqId;
    DWORD infotype = EVENTLOG_INFORMATION_TYPE;
    WCHAR const *pwszMessageText = NULL;
    DWORD LogMsg2;
    
    prow->GetRowId(&ReqId);
    wsprintf(wszRequestId, L"%u", ReqId);
    apwsz[cString++] = wszRequestId;

    LogMsg2 = LogMsg;
    switch (LogMsg)
    {
	case MSG_DN_CERT_ISSUED:
	    LogMsg2 = MSG_DN_CERT_ISSUED_WITH_INFO;
	    break;

	case MSG_DN_CERT_PENDING:
	    LogMsg2 = MSG_DN_CERT_PENDING_WITH_INFO;
	    break;

        case MSG_DN_CERT_ADMIN_DENIED:
            LogMsg2 = MSG_DN_CERT_ADMIN_DENIED_WITH_INFO;
            break;

	case MSG_DN_CERT_DENIED:
	    LogMsg2 = MSG_DN_CERT_DENIED_WITH_INFO;
	    infotype = EVENTLOG_WARNING_TYPE;
	    break;

	case MSG_E_PROCESS_REQUEST_FAILED:
	    LogMsg2 = MSG_E_PROCESS_REQUEST_FAILED_WITH_INFO;
	    infotype = EVENTLOG_ERROR_TYPE;
	    break;
    }
    if (EVENTLOG_INFORMATION_TYPE != infotype)
    {
	if (S_OK == ErrCode)
	{
	    ErrCode = SEC_E_CERT_UNKNOWN;	// unknown error
	}
	pwszMessageText = myGetErrorMessageText(ErrCode, TRUE);
	if (NULL == pwszMessageText)
	{
	    pwszMessageText = myHResultToStringRaw(awchr, ErrCode);
	}
	apwsz[cString++] = pwszMessageText;
    }
    
    cbProp = sizeof(awcSubject);
    hr = prow->GetProperty(
		    g_wszPropSubjectDistinguishedName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbProp,
		    (BYTE *) awcSubject);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
        cbProp = sizeof(awcSubject);
        hr = prow->GetProperty(
			g_wszPropSubjectDistinguishedName,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cbProp,
			(BYTE *) awcSubject);
    }
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
        cbProp = sizeof(awcSubject);
        hr = prow->GetProperty(
			g_wszPropRequesterName,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cbProp,
			(BYTE *) awcSubject);
    }
    pwszSubject = awcSubject;
    if (S_OK != hr)
    {
        _PrintError(hr, "GetProperty(DN/Requester)");
	pwszSubject = g_pwszUnknownSubject;
    }
    apwsz[cString++] = pwszSubject;
    
    if (NULL != pwszDisposition)
    {
	LogMsg = LogMsg2;
        apwsz[cString++] = pwszDisposition;
    }
    
    if (CERTLOG_VERBOSE <= g_dwLogLevel ||
        (EVENTLOG_WARNING_TYPE == infotype && CERTLOG_WARNING <= g_dwLogLevel) ||
        (EVENTLOG_ERROR_TYPE == infotype && CERTLOG_ERROR <= g_dwLogLevel))
    {
        LogEvent(infotype, LogMsg, cString, apwsz);
    }

#if 0 == i386
# define IOBUNALIGNED(pf) ((sizeof(WCHAR) - 1) & (DWORD) (ULONG_PTR) (pf)->_ptr)
# define ALIGNIOB(pf) \
    { \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fflush(pf); /* fails when running as a service */ \
	} \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fprintf(pf, " "); \
	    fflush(pf); \
	} \
    }
#else
# define IOBUNALIGNED(pf) FALSE
# define ALIGNIOB(pf)
#endif

    {
	BOOL fRetried = FALSE;
	
	while (TRUE)
	{
	    ALIGNIOB(stdout);
	    __try
	    {
		wprintf(
		    // L"\nCertSrv Request %u: rc=%x: %ws: %ws '%ws'\n"
		    g_pwszPrintfCertRequestDisposition,
		    ReqId,
		    ErrCode,
		    NULL != pwszMessageText? pwszMessageText : L"",
		    NULL != pwszDisposition? pwszDisposition : L"",
		    pwszSubject);
		hr = S_OK;
	    }
	    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	    {
	    }
	    if (S_OK == hr || fRetried || !IOBUNALIGNED(stdout))
	    {
		break;
	    }
	    ALIGNIOB(stdout);
	    fRetried = TRUE;
	}
    }
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
}


WCHAR *
CoreBuildDispositionString(
    OPTIONAL IN WCHAR const *pwszDispositionBase,
    OPTIONAL IN WCHAR const *pwszUserName,
    OPTIONAL IN WCHAR const *pwszDispositionDetail,
    OPTIONAL IN WCHAR const *pwszBy,
    IN HRESULT hrFail,
    IN BOOL fPublishError)
{
    DWORD cwc = 0;
    WCHAR *pwsz = NULL;
    WCHAR const *pwszMessageText = NULL;
    WCHAR awchr[cwcHRESULTSTRING];

    if (NULL == pwszUserName)
    {
	pwszUserName = L"";
    }
    if (NULL != pwszDispositionBase)
    {
	cwc += wcslen(pwszDispositionBase) + wcslen(pwszUserName);
    }
    if (NULL != pwszDispositionDetail)
    {
	if (0 != cwc)
	{
	    cwc += 2;  // spaces
	}
	cwc += wcslen(pwszDispositionDetail);
    }
    if (NULL != pwszBy)
    {
	if (0 != cwc)
	{
	    cwc += 2;  // spaces
	}
	cwc += wcslen(pwszBy) + wcslen(pwszUserName);
    }
    if (S_OK != hrFail)
    {
	pwszMessageText = myGetErrorMessageText(hrFail, TRUE);
	if (NULL == pwszMessageText)
	{
	    pwszMessageText = myHResultToStringRaw(awchr, hrFail);
	}
	if (0 != cwc)
	{
	    cwc += 2;  // spaces
	}
	if (fPublishError)
	{
	    cwc += wcslen(g_pwszPublishError);
	    cwc += 2;  // spaces
	}
	cwc += wcslen(pwszMessageText);
    }
    if (0 != cwc)
    {
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL != pwsz)
	{
	    pwsz[0] = L'\0';
	    if (NULL != pwszDispositionBase)
	    {
		wsprintf(pwsz, pwszDispositionBase, pwszUserName);
	    }
	    if (NULL != pwszDispositionDetail)
	    {
		if (L'\0' != pwsz[0])
		{
		    wcscat(pwsz, L"  ");
		}
		wcscat(pwsz, pwszDispositionDetail);
	    }
	    if (NULL != pwszBy)
	    {
		if (L'\0' != pwsz[0])
		{
		    wcscat(pwsz, L"  ");
		}
		wsprintf(&pwsz[wcslen(pwsz)], pwszBy, pwszUserName);
	    }
	    if (S_OK != hrFail)
	    {
		if (L'\0' != pwsz[0] && L'\n' != pwsz[wcslen(pwsz) - 1])
		{
		    wcscat(pwsz, L"  ");
		}
		if (fPublishError)
		{
		    wcscat(pwsz, g_pwszPublishError);
		    wcscat(pwsz, L"  ");
		}
		wcscat(pwsz, pwszMessageText);
	    }
	}
	CSASSERT(wcslen(pwsz) <= cwc);
    }

//error:
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
    return(pwsz);
}


VOID
coreLogPublishError(
    IN DWORD RequestId,
    IN WCHAR const *pwszSamName,
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN WCHAR const *pwszError,
    IN HRESULT hrPublish)
{
    HRESULT hr;
    WCHAR const *apwsz[6];
    WORD cpwsz;
    WCHAR wszRequestId[11 + 1];
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszMessageText = NULL;
    WCHAR *pwszHostName = NULL;
    DWORD LogMsg;

    wsprintf(wszRequestId, L"%u", RequestId);
    if (NULL != pld)
    {
	myLdapGetDSHostName(pld, &pwszHostName);
    }
    pwszMessageText = myGetErrorMessageText(hrPublish, TRUE);
    if (NULL == pwszMessageText)
    {
	pwszMessageText = myHResultToStringRaw(awchr, hrPublish);
    }
    cpwsz = 0;
    apwsz[cpwsz++] = wszRequestId;
    apwsz[cpwsz++] = pwszDN;
    apwsz[cpwsz++] = pwszMessageText;

    LogMsg = MSG_E_CERT_PUBLICATION;
    if (NULL != pwszHostName)
    {
	LogMsg = MSG_E_CERT_PUBLICATION_HOST_NAME;
    }
    else
    {
	pwszHostName = L"";
    }
    apwsz[cpwsz++] = pwszHostName;
    apwsz[cpwsz++] = NULL != pwszError? L"\n" : L"";
    apwsz[cpwsz++] = NULL != pwszError? pwszError : L"";
    CSASSERT(ARRAYSIZE(apwsz) >= cpwsz);

    if (CERTLOG_WARNING <= g_dwLogLevel)
    {
	hr = LogEvent(EVENTLOG_WARNING_TYPE, LogMsg, cpwsz, apwsz);
	_PrintIfError(hr, "LogEvent");
    }

//error:
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
}


HRESULT
corePublishKRACertificate(
    IN DWORD RequestId,
    IN WCHAR const *pwszSamName,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    LDAP *pld = NULL;
    HCERTSTORE hStore = NULL;
    DWORD dwDisposition;
    WCHAR *pwszError = NULL;

    hr = myRobustLdapBind(&pld, FALSE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    hStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE,
			wszKRA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CertOpenStore", wszKRA_CERTSTORE);
    }

    // It's a new cert.  CERT_STORE_ADD_ALWAYS is faster.

    if (!CertAddCertificateContextToStore(
				    hStore,
				    pcc,
				    CERT_STORE_ADD_ALWAYS,
				    NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }

    hr = myLdapPublishCertToDS(
			pld,
			pcc,
			g_pwszKRAPublishURL,
			wszDSKRACERTATTRIBUTE,
			LPC_KRAOBJECT,
			&dwDisposition,
			&pwszError);
    _JumpIfError(hr, error, "myLdapPublishCertToDS");

error:
    if (S_OK != hr)
    {
	coreLogPublishError(
			RequestId,
			pwszSamName,
			pld,
			g_pwszKRAPublishURL,
			pwszError,
			hr);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    return(hr);
}


HRESULT
corePublishCrossCertificate(
    IN DWORD RequestId,
    IN WCHAR const *pwszSamName,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    HRESULT hr2;
    LDAP *pld = NULL;
    DWORD dwDisposition;
    WCHAR *pwszError = NULL;
    WCHAR const *pwszDN = g_pwszAIACrossCertPublishURL;
    CAutoLPWSTR pwszSubjectHash;
    CAutoLPWSTR pwszSubjectDN, pwszSubject;
    LPCWSTR pcwszFormatDN = L"LDAP:///CN=%s%s";
    DWORD dwFlags = LPC_CAOBJECT;
    bool fPublishToSubject = false;

    hr = myRobustLdapBind(&pld, FALSE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    // Attempt to build the location based on subject name:
    //  
    //  LDAP:///CN=<subject DN hasn>,<AIA container DN>
    //
    // In case of errors, fall back to publishing to CA AIA object

    hr = CertNameToHashString(
        &pcc->pCertInfo->Subject,
        &pwszSubjectHash);

    if(S_OK==hr)
    {
        WCHAR *pchRelDN = wcschr(pwszDN, L',');
        if(pchRelDN)
        {
            pwszSubjectDN = (LPWSTR)LocalAlloc(LMEM_FIXED, 
                (wcslen(pwszSubjectHash)+
                 wcslen(pchRelDN)+
                 wcslen(pcwszFormatDN))*sizeof(WCHAR));
            if(pwszSubjectDN)
            {
                wsprintf(pwszSubjectDN, pcwszFormatDN, 
                    (LPCWSTR)pwszSubjectHash, pchRelDN);
                pwszDN = pwszSubjectDN;

                // we'll publish to subject's DS object which might not exist
                dwFlags |= LPC_CREATEOBJECT;

                fPublishToSubject = true;
            }
        }
    }

    hr = myLdapPublishCertToDS(
			pld,
			pcc,
			pwszDN,
			wszDSCROSSCERTPAIRATTRIBUTE,
			dwFlags,
			&dwDisposition,
			&pwszError);
    if (S_OK != hr)
    {
	    _PrintErrorStr(hr, "myLdapPublishCertToDS", pwszDN);
	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
	        IsRootCA(g_CAType))
	    {
	        hr = S_OK;
	    }
    }

    _JumpIfErrorStr(hr, error, "myLdapPublishCertToDS", pwszDN);

    if(fPublishToSubject)
    {
        hr = myCertNameToStr(
            X509_ASN_ENCODING,
            &pcc->pCertInfo->Subject,
            CERT_X500_NAME_STR, //| CERT_NAME_STR_REVERSE_FLAG,
            &pwszSubject);
        _JumpIfError(hr, error, "myCertNameToStr");

        hr = myLDAPSetStringAttribute(
            pld,
            pwszDN,
            CA_PROP_CERT_DN,
            pwszSubject,
            &dwDisposition, 
            &pwszError
            );
        _JumpIfErrorStr(hr, error, "myLDAPSetStringAttribute", pwszDN);
    }

error:
    if (S_OK != hr)
    {
	coreLogPublishError(RequestId, pwszSamName, pld, pwszDN, pwszError, hr);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    return(hr);
}


VOID
coreFreeDSCacheEntry(
    IN OUT DSCACHE *pdsc)
{
    if (NULL != pdsc->pld)
    {
	ldap_unbind(pdsc->pld);
	pdsc->pld = NULL;
    }
    if (NULL != pdsc->pwszDomain)
    {
	LocalFree(pdsc->pwszDomain);
	pdsc->pwszDomain = NULL;
    }
    LocalFree(pdsc);
}


VOID
coreFreeDSCache()
{
    DSCACHE *pdsc;

    // only called during shutdown

    while (NULL != g_DSCache)
    {
       // remove from head of list

       pdsc = g_DSCache;
       g_DSCache = pdsc->pdscNext;

       coreFreeDSCacheEntry(pdsc);
    }
    coreDSUnBind(TRUE);
}


HRESULT
coreGetCachedDS(
    IN WCHAR const *pwszSamName,
    IN BOOL fRediscover,
    OUT LDAP **ppld)
{
    HRESULT hr;
    ULONG ldaperr;
    DS_NAME_RESULTW *pNameResults = NULL;
    WCHAR *pwszDomain = NULL;
    DSCACHE *pdsc = NULL;
    DSCACHE **ppdscPrev;
    DSCACHE *pdscFree = NULL;
    DWORD cwc;
    WCHAR *pwsz;

    CSASSERT(NULL != ppld);
    *ppld = NULL;

    // Copy domain out of the SamName

    pwsz = wcschr(pwszSamName, L'\\');
    if (NULL != pwsz)
    {
        cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszSamName);
    }
    else
    {
        cwc = wcslen(pwszSamName);
    }
    pwszDomain = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszDomain)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszDomain, pwszSamName, sizeof(WCHAR) * cwc);
    pwszDomain[cwc] = L'\0';

    ppdscPrev = &g_DSCache;
    for (pdsc = g_DSCache; NULL != pdsc; pdsc = pdsc->pdscNext)
    {
	if (0 == lstrcmpi(pdsc->pwszDomain, pwszDomain))
	{
	    // should we toss the cached entry?

	    if (fRediscover)
	    {
		// unhook from cache list & free the entry,

		*ppdscPrev = pdsc->pdscNext;
		coreFreeDSCacheEntry(pdsc);
		pdsc = NULL;
	    }
	    break;
	}
	ppdscPrev = &pdsc->pdscNext;
    }

    if (fRediscover)
    {
	coreDSUnBind(FALSE);
    }
    if (NULL == pdsc)
    {
	pdsc = (DSCACHE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				sizeof(*pdsc));
	if (NULL == pdsc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pdscFree = pdsc;

	pdsc->pwszDomain = pwszDomain;
	pwszDomain = NULL;
    }
    CSASSERT(NULL != pdsc->pwszDomain);

    // if we don't have an ldap handle yet, get a good one

    if (NULL == pdsc->pld)
    {
	CSASSERT(pdsc == pdscFree);

	hr = myRobustLdapBindEx(
                        FALSE,			// fGC
                        FALSE,			// fRediscover
                        LDAP_VERSION2,		// uVersion
			pwszDomain,		// pwszDomainName
                        &pdsc->pld,		// ppld
                        NULL);			// ppwszForestDNSName
	_JumpIfError(hr, error, "Policy:myRobustLdapBindEx");

	// link into list: we have all data necessary

	pdsc->pdscNext = g_DSCache;
	g_DSCache = pdsc;
	pdscFree = NULL;
    }
    *ppld = pdsc->pld;

error:
    if (NULL != pwszDomain)
    {
        LocalFree(pwszDomain);
    }
    if (NULL != pNameResults)
    {
        DsFreeNameResult(pNameResults);
    }
    if (NULL != pdscFree)
    {
       coreFreeDSCacheEntry(pdscFree);
    }
    return(hr);
}


HRESULT
corePublishIssuedCertificate(
    IN DWORD RequestId,
    IN DWORD dwComContextIndex,
    IN WCHAR const *pwszSamName,
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwObjectType)	// LPC_*
{
    HRESULT hr;
    WCHAR *pwszSamNamePatched = NULL;
    WCHAR const *pwszUserName;
    DWORD cbProp;
    LDAP *pld = NULL;
    WCHAR const *pwszDN;
    DWORD dwDisposition;
    BOOL fCritSecEntered = FALSE;
    WCHAR *pwszError = NULL;

    hr = myAddDomainName(pwszSamName, &pwszSamNamePatched, &pwszUserName);
    _JumpIfError(hr, error, "myAddDomainName");

    if (NULL != pwszSamNamePatched)
    {
	pwszSamName = pwszSamNamePatched;
    }

    EnterCriticalSection(&g_critsecDSCache);
    fCritSecEntered = TRUE;
    __try
    {
	BOOL fRediscover = FALSE;

	hr = coreGetComContextUserDNFromSamName(
			    FALSE,		// fDeleteUserDNOnly
			    pwszSamName,
			    0,			// Context
			    dwComContextIndex,
			    &pwszDN);
	_JumpIfError(hr, error, "coreGetComContextUserDNFromSamName");

	while (TRUE)
	{
	    if (NULL != pwszError)
	    {
		LocalFree(pwszError);
		pwszError = NULL;
	    }
	    pld = NULL;

	    hr = coreGetCachedDS(pwszSamName, fRediscover, &pld); 
	    if (S_OK != hr)
	    {
		_PrintErrorStr(
			    hr,
			    "coreGetCachedDS",
			    fRediscover? L"noncached" : L"cached");
		if (fRediscover)
		{
		    _leave;
		}
	    }
	    else
	    {
		hr = myLdapPublishCertToDS(
				    pld,
				    pcc,
				    pwszDN,
				    wszDSUSERCERTATTRIBUTE,
				    dwObjectType,	// LPC_*
				    &dwDisposition,
				    &pwszError);
		_PrintIfErrorStr(hr, "myLdapPublishCertToDS", pwszDN);
		if (fRediscover || S_OK == hr)
		{
		    break;
		}
		if (!myLdapRebindRequired(dwDisposition, pld))
		{
		    _LeaveError(hr, "myLdapPublishCertToDS");
		}
	    }
	    fRediscover = TRUE;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (S_OK != hr)
    {
	coreLogPublishError(RequestId, pwszSamName, pld, pwszDN, pwszError, hr);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pwszSamNamePatched)
    {
	LocalFree(pwszSamNamePatched);
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_critsecDSCache);
    }
    return(hr);
}


HRESULT
CorePublishCertificate(
    IN ICertDBRow *prow,
    IN DWORD dwComContextIndex)
{
    HRESULT hr;
    DWORD cbProp;
    DWORD RequestId;
    DWORD GeneralFlags;
    DWORD EnrollmentFlags;
    DWORD cbCert;
    BYTE *pbCert = NULL;
    CERT_CONTEXT const *pcc = NULL;
    WCHAR *pwszSamName = NULL;
    
    prow->GetRowId(&RequestId);

    cbProp = sizeof(EnrollmentFlags);
    hr = prow->GetProperty(
		    wszPROPCERTIFICATEENROLLMENTFLAGS,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbProp,
		    (BYTE *) &EnrollmentFlags);
    _PrintIfError2(hr, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK != hr)
    {
	EnrollmentFlags = 0;
    }

    if (0 == ((CT_FLAG_PUBLISH_TO_DS | CT_FLAG_PUBLISH_TO_KRA_CONTAINER) &
							    EnrollmentFlags))
    {
	hr = S_OK;
	goto error;
    }

    cbProp = sizeof(GeneralFlags);
    hr = prow->GetProperty(
		    wszPROPCERTIFICATEGENERALFLAGS,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbProp,
		    (BYTE *) &GeneralFlags);
    _PrintIfError2(hr, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK != hr)
    {
	GeneralFlags = 0;
    }

    // Get the name of the user or machine

    hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequesterName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    (BYTE **) &pwszSamName);
    _JumpIfError(hr, error, "PKCSGetProperty");

    hr = PKCSGetProperty(
		prow, 
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbCert,
		&pbCert);
    _JumpIfError(hr, error, "PKCSGetProperty(raw cert)");

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    hr = S_OK;
    if (CT_FLAG_PUBLISH_TO_DS & EnrollmentFlags)
    {
	if (CT_FLAG_IS_CROSS_CA & GeneralFlags)
	{
	    hr = corePublishCrossCertificate(RequestId, pwszSamName, pcc);
	    _PrintIfError(hr, "corePublishCrossCertificate");
	}
	else
	{
	    hr = corePublishIssuedCertificate(
				    RequestId,
				    dwComContextIndex,
				    pwszSamName,
				    pcc,
				    (CT_FLAG_MACHINE_TYPE & GeneralFlags)?
					LPC_MACHINEOBJECT : LPC_USEROBJECT);
	    _PrintIfError(hr, "corePublishIssuedCertificate");
	}
    }

    if (CT_FLAG_PUBLISH_TO_KRA_CONTAINER & EnrollmentFlags)
    {
	HRESULT hr2;
	
	hr2 = corePublishKRACertificate(RequestId, pwszSamName, pcc);
	_PrintIfError(hr2, "corePublishKRACertificate");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    _JumpIfError(hr, error, "CorePublishCertificate");

error:
    if (NULL != pwszSamName)
    {
	LocalFree(pwszSamName);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    return(hr);
}


HRESULT
coreAcceptRequest(
    IN ICertDBRow *prow,
    IN BOOL fIncludeCRLs,
    IN DWORD dwComContextIndex,
    OUT BOOL *pfErrorLogged,
    OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult,	// CoTaskMem*
    OUT HRESULT *phrPublish)
{
    HRESULT hr;

    *ppCAContext = NULL;
    *phrPublish = S_OK;

    // Force Cert creation:
    CSASSERT(NULL == pResult->pctbCert || NULL == pResult->pctbCert->pb);

    hr = CoreValidateRequestId(prow, DB_DISP_ACTIVE);
    _JumpIfError(hr, error, "CoreValidateRequestId");

    hr = PKCSCreateCertificate(
			prow,
			DB_DISP_ACTIVE,
			fIncludeCRLs,
			pfErrorLogged,
			ppCAContext,
			pResult);
    _JumpIfError(hr, error, "PKCSCreateCertificate");

    *phrPublish = CorePublishCertificate(prow, dwComContextIndex);
    _PrintIfError(*phrPublish, "CorePublishCertificate");
    if (S_OK != *phrPublish)
    {
	hr = PKCSSetRequestFlags(prow, TRUE, CR_FLG_PUBLISHERROR);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


HRESULT
coreVerifyRequest(
    IN OUT ICertDBRow **pprow,
    IN DWORD OpRequest,
    IN BOOL fIncludeCRLs,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD dwComContextIndex,
    OUT DWORD *pReqId,
    OUT LONG *pExitEvent,
    OUT WCHAR **ppwszDisposition,		// LocalAlloc
    OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)	// CoTaskMem*
{
    HRESULT hr;
    HRESULT hr2;
    HRESULT hrRequest = S_OK;
    HRESULT hrPublish = S_OK;
    DWORD VerifyStatus;
    DWORD DBDisposition;
    BOOL fResolved;
    LONG ExitEvent;
    BOOL fPending;
    BOOL fSubmit;
    BOOL fRetrieve;
    BOOL fDenied;
    BOOL fUpdateDisposition = FALSE;

    WCHAR *pwszDispositionRetrieved = NULL;
    WCHAR const *pwszDispositionBase = NULL;
    WCHAR *pwszDispositionDetail = NULL;
    WCHAR *pwszDisposition = NULL;
    WCHAR const *pwszBy = NULL;

    DWORD LogMsg = MSG_E_PROCESS_REQUEST_FAILED;
    BOOL fErrorLogged = FALSE;
    DWORD ReqId;
    ICertDBRow *prow = *pprow;
    
    prow->GetRowId(&ReqId);
    
    *ppCAContext = NULL;
    *pResult->pdwDisposition = CR_DISP_ERROR;
    DBDisposition = DB_DISP_ERROR;
    *ppwszDisposition = NULL;
    
    ExitEvent = EXITEVENT_INVALID;
    
    fSubmit = CR_IN_NEW == OpRequest || CR_IN_RESUBMIT == OpRequest;
    fPending = CR_IN_DENY == OpRequest || CR_IN_RESUBMIT == OpRequest;
    fRetrieve = CR_IN_RETRIEVE == OpRequest;
    
#if DBG_COMTEST
    if (fSubmit && fComTest && !ComTest((LONG) ReqId))
    {
        _PrintError(0, "ComTest");
    }
#endif

    if (fRetrieve)
    {
        hr = coreRetrievePending(
			    prow,
			    fIncludeCRLs,
			    &pwszDispositionRetrieved,
			    ppCAContext,
			    pResult);	// CoTaskMem*
	_JumpIfError(hr, error, "coreRetrievePending");

	pwszDispositionBase = pwszDispositionRetrieved;
        ExitEvent = EXITEVENT_CERTRETRIEVEPENDING;
    }
    else
    {
        // If the current status is expected to be pending, verify that now,
        // and make the request active.
	//
	// If it was already marked active, then something went wrong last time
	// we processed the request (out of disk space?), and we can try to
	// pick up where we left off, by resubmitting or denying the request.

        if (fPending)
        {
            hr = CoreValidateRequestId(prow, DB_DISP_PENDING);
	    if (CERTSRV_E_BAD_REQUESTSTATUS == hr)
	    {
		hr = CoreValidateRequestId(prow, DB_DISP_ACTIVE);
	    }
	    if (CERTSRV_E_BAD_REQUESTSTATUS == hr && fSubmit)
	    {
		hr = CoreValidateRequestId(prow, DB_DISP_DENIED);
		if (S_OK == hr)
		{
		    DBGPRINT((
			DBG_SS_CERTSRV,
			"Resubmit failed request %u\n",
			ReqId));
		}
	    }
            _JumpIfError(hr, error, "CoreValidateRequestId");

            hr = CoreSetDisposition(prow, DB_DISP_ACTIVE);
            _JumpIfError(hr, error, "CoreSetDisposition");
        }
        fUpdateDisposition = TRUE;
        if (fSubmit)
        {
	    if (fPending)
	    {
		pwszBy = g_pwszResubmittedBy;

		hr = PKCSSetServerProperties(
				prow,
				g_lValidityPeriodCount,
				g_enumValidityPeriod);
		_JumpIfError(hr, error, "PKCSSetServerProperties");
	    }

            hr = prow->CommitTransaction(TRUE);
            _JumpIfError(hr, error, "CommitTransaction");

            prow->Release();
            prow = NULL;
            *pprow = NULL;

            hr = PolicyVerifyRequest(
		            g_wszCommonName,
		            ReqId,
		            g_PolicyFlags,
		            CR_IN_NEW == OpRequest,
			    dwComContextIndex,
			    &pwszDispositionDetail, 
		            &VerifyStatus);
	    if (S_OK != hr)
	    {
		_PrintError(hr, "PolicyVerifyRequest");
		if (SUCCEEDED(hr))
		{
		    if (S_FALSE == hr)
		    {
			hr = E_UNEXPECTED;
		    }
		    else
		    {
			hr = myHError(hr);
		    }
		}
		VerifyStatus = hr;
	    }

            hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, ReqId, NULL, &prow);
	    _JumpIfError(hr, error, "OpenRow");

	    CSASSERT(NULL != prow);
            *pprow = prow;
        }
        else	// else we're denying the request!
        {
            VerifyStatus = VR_INSTANT_BAD;
        }

        fResolved = FALSE;
        fDenied = FALSE;
        switch (VerifyStatus)
        {
            case VR_PENDING:
		hr = S_OK;
		DBDisposition = DB_DISP_PENDING;
		ExitEvent = EXITEVENT_CERTPENDING;
		LogMsg = MSG_DN_CERT_PENDING;
		*pResult->pdwDisposition = CR_DISP_UNDER_SUBMISSION;
		pwszDispositionBase = g_pwszUnderSubmission;
		break;

            case VR_INSTANT_OK:
		hr = coreAcceptRequest(
				prow,
				fIncludeCRLs,
				dwComContextIndex,
				&fErrorLogged,
				ppCAContext,
				pResult,
				&hrPublish);
		if (S_OK != hr)
		{
	            CSASSERT(FAILED(hr));
	            _PrintError(hr, "coreAcceptRequest");
	            pwszDispositionBase = g_pwszRequestProcessingError;
	            VerifyStatus = hr;
	            hr = S_OK;
	            fDenied = TRUE;
		}
		else
		{
	            fResolved = TRUE;
	            DBDisposition = DB_DISP_ISSUED;
	            ExitEvent = EXITEVENT_CERTISSUED;
	            LogMsg = MSG_DN_CERT_ISSUED;
	            *pResult->pdwDisposition = CR_DISP_ISSUED;
	            pwszDispositionBase = g_pwszIssued;
		}
		break;

            default:
		if (SUCCEEDED(VerifyStatus))
		{
		    CSASSERT(
			VerifyStatus == VR_PENDING ||
			VerifyStatus == VR_INSTANT_OK ||
			VerifyStatus == VR_INSTANT_BAD);
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _JumpError(hr, error, "VerifyStatus");
		}
		// FALLTHROUGH

            case VR_INSTANT_BAD:
		hr = CoreValidateRequestId(prow, DB_DISP_ACTIVE);
		_JumpIfError(hr, error, "CoreValidateRequestId");

		fDenied = TRUE;
		break;
        }
        if (fDenied)
        {
            fResolved = TRUE;
            DBDisposition = DB_DISP_DENIED;
            ExitEvent = EXITEVENT_CERTDENIED;

            *pResult->pdwDisposition = CR_DISP_DENIED;
            if (FAILED(VerifyStatus))
            {
                *pResult->pdwDisposition = VerifyStatus;
                hrRequest = VerifyStatus;
            }

            if (fSubmit)
            {
	        if (NULL == pwszDispositionBase)
		{
		    pwszDispositionBase = g_pwszPolicyDeniedRequest;
		}
                LogMsg = MSG_DN_CERT_DENIED;
            }
            else
            {
	        pwszDispositionBase = g_pwszDeniedBy;
                LogMsg = MSG_DN_CERT_ADMIN_DENIED;
            }
        }
        if (fResolved)
        {
            hr = PropSetRequestTimeProperty(prow, g_wszPropRequestResolvedWhen);
            _JumpIfError(hr, error, "PropSetRequestTimeProperty");
        }
    }
    
error:
    *pReqId = ReqId;
    *pExitEvent = ExitEvent;
    
    // If we verified or denied the request, set the status & disposition

    // Build the full disposition string

    pwszDisposition = CoreBuildDispositionString(
				    pwszDispositionBase,
				    pwszUserName,
				    pwszDispositionDetail,
				    pwszBy,
				    hrPublish,
				    TRUE);

    if (NULL != pwszDispositionDetail)
    {
        LocalFree(pwszDispositionDetail);
    }

    if (S_OK == hrRequest && S_OK != hr)
    {
	hrRequest = hr;
    }
    if (fUpdateDisposition && NULL != prow)
    {
        hr2 = CoreSetRequestDispositionFields(
				    prow,
				    hrRequest,
				    DBDisposition,
				    pwszDisposition);
        if (S_OK == hr)
        {
            hr = hr2;
        }
    }

    if (!fErrorLogged &&
         NULL != prow &&
        (fUpdateDisposition || S_OK != hr))
    {
        CoreLogRequestStatus(prow, LogMsg, hrRequest, pwszDisposition);
    }

    if (NULL != ppwszDisposition)
    {
        *ppwszDisposition = pwszDisposition;
    }
    else if (NULL != pwszDisposition)
    {
        LocalFree(pwszDisposition);
    }
    if (NULL != pwszDispositionRetrieved)
    {
        LocalFree(pwszDispositionRetrieved);
    }
    return(hr);
}


HRESULT
coreAuditAddStringProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN CertSrv::CAuditEvent *pevent)
{
    HRESULT hr;
    WCHAR const *pwszLogValue = L"";
    WCHAR *pwszPropValue = NULL;

    hr = PKCSGetProperty(
		prow, 
		pwszPropName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		NULL,
		(BYTE **) &pwszPropValue);
    _PrintIfErrorStr(hr, "PKCSGetProperty", pwszPropName);
    if (S_OK == hr)
    {
	pwszLogValue = pwszPropValue;
    }
    hr = pevent->AddData(pwszLogValue);
    _JumpIfError(hr, error, "CAuditEvent::AddData");

error:
    if (NULL != pwszPropValue)
    {
	LocalFree(pwszPropValue);
    }
    return(hr);
}

    
HRESULT
coreAuditRequestDisposition(
    OPTIONAL IN ICertDBRow *prow,
    IN DWORD ReqId,
    IN WCHAR const *pwszUserName,
    IN WCHAR const *pwszAttributes,
    IN DWORD dwDisposition)
{
    HRESULT hr;

    CertSrv::CAuditEvent 
    audit(0, g_dwAuditFilter);

    hr = audit.AddData(ReqId); // %1 request ID
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(pwszUserName); // %2 requester
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(pwszAttributes); // %3 attributes
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(dwDisposition); // %4 disposition
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    if (NULL != prow)
    {
	hr = coreAuditAddStringProperty(
			prow,
			g_wszPropCertificateSubjectKeyIdentifier,
			&audit); // %5 SKI
	_JumpIfError(hr, error, "coreAuditAddStringProperty");

	hr = coreAuditAddStringProperty(
			prow,
			g_wszPropSubjectDistinguishedName,
			&audit); // %6 Subject
	_JumpIfError(hr, error, "coreAuditAddStringProperty");
    }
    else // we need to guarantee the same number of audit params
    {
        hr = audit.AddData(L""); // %5 SKI
        _JumpIfError(hr, error, "");

        hr = audit.AddData(L""); // %6 Subject
        _JumpIfError(hr, error, "");
    }

    switch (dwDisposition)
    {
	case CR_DISP_ISSUED: 
	    audit.SetEventID(SE_AUDITID_CERTSRV_REQUESTAPPROVED);
	    hr = audit.Report();
	    _JumpIfError(hr, error, "CAuditEvent::Report");

	    break;

	case CR_DISP_UNDER_SUBMISSION:
	    audit.SetEventID(SE_AUDITID_CERTSRV_REQUESTPENDING);
	    hr = audit.Report();
	    _JumpIfError(hr, error, "CAuditEvent::Report");

	    break;

	case CR_DISP_DENIED: // fail over
	default:
	    audit.SetEventID(SE_AUDITID_CERTSRV_REQUESTDENIED);
	    hr = audit.Report(false);
	    _JumpIfError(hr, error, "CAuditEvent::Report");
        break;

    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}

#define LOGMSG_ATTACK_DELAY_SECONDS (CVT_MINUTES * 20)
static FILETIME g_ftLogNextAttackMsg = {0};

HRESULT ValidateMessageSize(OPTIONAL LPCWSTR pwszUser, DWORD cbRequest)
{
    HRESULT hr = S_OK;

    if (cbRequest > g_cbMaxIncomingMessageSize)
    {
        hr = HRESULT_FROM_WIN32(ERROR_MESSAGE_EXCEEDS_MAX_SIZE);

        SYSTEMTIME stNow;
        FILETIME ftNow;
        GetSystemTime(&stNow);

        // if VERBOSE -or- it's time to log the next msg (Next < Now)
        if ( (CERTLOG_VERBOSE <= g_dwLogLevel) ||
             ( (SystemTimeToFileTime(&stNow, &ftNow)) && (0 > CompareFileTime(&g_ftLogNextAttackMsg, &ftNow)) )
           )
        {
            // g_ftLogNextAttackMsg = ftNow + DELAY;

            ULARGE_INTEGER ui;
            ui.LowPart = ftNow.dwLowDateTime;
            ui.HighPart = ftNow.dwHighDateTime;
            ui.QuadPart += ((LONGLONG)LOGMSG_ATTACK_DELAY_SECONDS) * CVT_BASE;
            g_ftLogNextAttackMsg.dwLowDateTime = ui.LowPart;
            g_ftLogNextAttackMsg.dwHighDateTime = ui.HighPart;

            // don't pass NULL
            if (NULL == pwszUser)
               pwszUser = L"?";

            LogEventStringHResult(EVENTLOG_ERROR_TYPE,
			    MSG_E_POSSIBLE_DENIAL_OF_SERVICE_ATTACK,
                            pwszUser,
			    hr);
        }
    }

    return hr;
}


HRESULT
coreInitRequest(
    IN DWORD dwFlags,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwComContextIndex,
    OUT DWORD *pOpRequest,
    OUT ICertDBRow **pprow,		// may return non-NULL on error
    OUT WCHAR **ppwszDisposition,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    
    *pprow = NULL;
    *ppwszDisposition = NULL;

    // for Denial-of-Service reasons, don't do anything with a too-long message

    hr = ValidateMessageSize(pwszUserName, cbRequest);
    _JumpIfError(hr, error, "ValidateMessageSize");

    // Called in several cases:
    //
    // - CR_IN_NEW: Create a new request and return error/pending/etc &
    //	 possibly the cert:
    //       NULL != pbRequest && NULL != pResult->pctbCert, etc.
    //
    // - CR_IN_DENY: Deny a pending request:
    //       NULL == pbRequest && NULL == pResult->pctbCert, etc.
    //
    // - CR_IN_RESUBMIT: Resubmit a pending request and return hr/pending/etc.
    //       NULL == pbRequest && NULL == pResult->pctbCert, etc.
    //
    // - CR_IN_RETRIEVE: Retrieve a cert for a processed request and return
    //   error/pending/etc & possibly the cert:
    //       NULL == pbRequest && NULL != pResult->pctbCert, etc.
    
    *pOpRequest = (CR_IN_COREMASK & dwFlags);
    switch (*pOpRequest)
    {
        // Process a new request:

        case CR_IN_NEW:
            CSASSERT(NULL != pwszUserName);
            CSASSERT(0 != cbRequest);
            CSASSERT(NULL != pbRequest);

            CSASSERT(0 == *pResult->pdwRequestId);
            *pResult->pdwRequestId = 0;

            hr = coreCreateRequest(
			    ~CR_IN_COREMASK & dwFlags,
		            pwszUserName,
		            cbRequest,
		            pbRequest,
		            pwszAttributes,
			    dwComContextIndex,
		            pprow,
			    pResult);
            _JumpIfError(hr, error, "coreCreateRequest");

            (*pprow)->GetRowId(pResult->pdwRequestId);
            {         
                CertSrv::CAuditEvent 
                    audit(SE_AUDITID_CERTSRV_NEWREQUEST, g_dwAuditFilter);

                hr = audit.AddData(*pResult->pdwRequestId); // %1 request ID
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                hr = audit.AddData(pwszUserName); // %2 requester
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                hr = audit.AddData(pwszAttributes); // %3 attributes
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                hr = audit.Report();
                _JumpIfError(hr, error, "CAuditEvent::Report");
            }
            break;

        // Deny a request:
        // Resubmit a request:

        case CR_IN_DENY:
        case CR_IN_RESUBMIT:
            break;

        // Retrieve a cert:

        case CR_IN_RETRIEVE:
            break;

        default:
	    CSASSERT(*pOpRequest != *pOpRequest);
	    break;
    }
    if (CR_IN_NEW != *pOpRequest)
    {
	hr = E_INVALIDARG;
	if (0 != cbRequest || NULL != pbRequest)
	{
	    _JumpError(hr, error, "unexpected request");
	}
        if ((0 != *pResult->pdwRequestId) ^ (NULL == pwszSerialNumber))
	{
	    _JumpError(hr, error, "expected RequestId or SerialNumber");
	}

	// RetrievePending by RequestId OR SerialNumber in pwszSerialNumber

        hr = g_pCertDB->OpenRow(
			    PROPTABLE_REQCERT,
			    *pResult->pdwRequestId,
			    pwszSerialNumber,
			    pprow);
        _JumpIfError(hr, error, "OpenRow");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	HRESULT hr2;
	WCHAR const *pwszDisp = g_pwszRequestParsingError;
	
	hr2 = myDupString(pwszDisp, ppwszDisposition);
	_PrintIfError(hr2, "myDupString");

	if (NULL != *pprow)
	{
	    hr2 = CoreSetRequestDispositionFields(
					    *pprow,
					    hr,
					    DB_DISP_ERROR,
					    pwszDisp);
	    _PrintIfError(hr2, "CoreSetRequestDispositionFields");
	    
	    CoreLogRequestStatus(
			    *pprow,
			    MSG_E_PROCESS_REQUEST_FAILED,
			    hr,
			    pwszDisp);
	}
    }
    return(hr);
}


HRESULT
CoreProcessRequest(
    IN DWORD dwFlags,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwComContextIndex,
    IN DWORD dwRequestId,
    OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    HRESULT hr2;
    WCHAR *pwszDisposition = NULL;
    DWORD OpRequest;
    ICertDBRow *prow = NULL;
    DWORD ReqId;
    LONG ExitEvent = EXITEVENT_INVALID;
    BOOL fCoInitialized = FALSE;
    CACTX *pCAContext;
    BOOL fCommitted = FALSE;
    
    CSASSERT(NULL != pResult->pdwRequestId);
    CSASSERT(NULL != pResult->pdwDisposition);

    if (MAXDWORD == dwRequestId)
    {
	dwRequestId = 0;
    }
    *pResult->pdwRequestId = dwRequestId;
    *pResult->pdwDisposition = CR_DISP_ERROR;
    
    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitializeEx");
    }
    fCoInitialized = TRUE;

    hr = coreInitRequest(
		    dwFlags,
		    pwszUserName,
		    cbRequest,
		    pbRequest,
		    pwszAttributes,
		    pwszSerialNumber,
		    dwComContextIndex,
		    &OpRequest,
		    &prow,
		    &pwszDisposition,
		    pResult);
    _PrintIfError(hr, "coreInitRequest");

    pCAContext = NULL;
    if (S_OK == hr)
    {
	CSASSERT(NULL == pwszDisposition);	// error string only
	if (CR_IN_NEW != OpRequest)
	{
	    DWORD cb;
	    DWORD dw;
	    
	    cb = sizeof(dw);
	    hr = prow->GetProperty(
			g_wszPropRequestType,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cb,
			(BYTE *) &dw);
	    if (S_OK == hr)
	    {
		dwFlags |= (CR_IN_CRLS & dw);
	    }
	}
	hr = coreVerifyRequest(
			&prow,
			OpRequest,
			0 != (CR_IN_CRLS & dwFlags),
			pwszUserName,
			dwComContextIndex,
			&ReqId,
			&ExitEvent,
			&pwszDisposition,
			&pCAContext,
			pResult);		// CoTaskMem
	_PrintIfError(hr, "coreVerifyRequest");
    }
    else
    {
	WCHAR *pwszDisposition2 = CoreBuildDispositionString(
				    pwszDisposition,
				    NULL,	// pwszUserName
				    NULL,	// pwszDispositionDetail
				    NULL,	// pwszBy
				    hr,
				    FALSE);
	if (NULL != pwszDisposition2)
	{
	    if (NULL != pwszDisposition)
	    {
		LocalFree(pwszDisposition);
	    }
	    pwszDisposition = pwszDisposition2;
	}
    }

    if (NULL != pResult->pctbFullResponse)
    {
	BYTE const *pbCert = NULL;
	DWORD cbCert = 0;
	
	if (NULL != pResult->pctbCert && NULL != pResult->pctbCert->pb)
	{
	    pbCert = pResult->pctbCert->pb;
	    cbCert = pResult->pctbCert->cb;
	}
	CSASSERT(NULL == pResult->pctbFullResponse->pb);
	hr2 = PKCSEncodeFullResponse(
			    prow,
			    pResult,
			    hr,
			    pwszDisposition,
			    pCAContext,
			    pbCert,		// pbCertLeaf
			    cbCert,		// cbCertLeaf
			    0 != (CR_IN_CRLS & dwFlags),
			    &pResult->pctbFullResponse->pb,	// CoTaskMem*
			    &pResult->pctbFullResponse->cb);
	_PrintIfError(hr2, "PKCSEncodeFullResponse");
	if (S_OK == hr &&
	    (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr2 || IsWhistler()))
	{
	    hr = hr2;
	}
    }

    hr2 = coreAuditRequestDisposition(
				prow,
				ReqId,
				pwszUserName,
				pwszAttributes,
				*pResult->pdwDisposition);
    _PrintIfError(hr2, "coreAuditRequestDisposition");
    if (S_OK == hr)
    {
	hr = hr2;
    }
    
    if (NULL != pwszDisposition && NULL != pResult->pctbDispositionMessage)
    {
	DWORD cbAlloc = (wcslen(pwszDisposition) + 1) * sizeof(WCHAR);
	BYTE *pbAlloc;

        pbAlloc = (BYTE *) CoTaskMemAlloc(cbAlloc);
        if (NULL != pbAlloc)
        {
	    CopyMemory(pbAlloc, pwszDisposition, cbAlloc);
	    pResult->pctbDispositionMessage->pb = pbAlloc;
	    pResult->pctbDispositionMessage->cb = cbAlloc;
        }
    }
    if (NULL != prow)
    {
	if (pResult->fKeyArchived && (KRAF_SAVEBADREQUESTKEY & g_KRAFlags))
	{
	    BOOL fSave = FALSE;

	    switch (*pResult->pdwDisposition)
	    {
		case CR_DISP_INCOMPLETE:
		case CR_DISP_ERROR:
		case CR_DISP_DENIED:
		    fSave = TRUE;
		    break;

		default:
		    if (S_OK != hr)
		    {
			fSave = TRUE;
		    }
		    break;
	    }
	    if (fSave)
	    {
		hr2 = prow->SetProperty(
			g_wszPropRequestRawRequest,
			PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			cbRequest,
			pbRequest);
		_PrintIfError(hr2, "SetProperty(request)");
		if (S_OK == hr)
		{
		    hr = hr2;
		}
	    }
	}

        hr2 = prow->CommitTransaction(TRUE);
        _PrintIfError(hr2, "CommitTransaction");
	fCommitted = S_OK == hr2;
        if (S_OK == hr)
        {
            hr = hr2;
        }
    }
    
error:
    // If the request exists, clean up the DB
    
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
        {
            hr2 = prow->CommitTransaction(FALSE);
            _PrintIfError(hr2, "CommitTransaction");
        }
        prow->Release();
    }
    if (EXITEVENT_INVALID != ExitEvent)
    {
        CSASSERT(fCoInitialized);
        ExitNotify(ExitEvent, ReqId, dwComContextIndex);
    }
    if (fCoInitialized)
    {
        CoUninitialize();
    }
    if (S_OK != hr)
    {
        WCHAR const *pwszMsg;

        pwszMsg = myGetErrorMessageText(hr, TRUE);
        if (NULL != pwszMsg)
        {
            CONSOLEPRINT1((DBG_SS_CERTSRV, "%ws\n", pwszMsg));
            LocalFree(const_cast<WCHAR *>(pwszMsg));
        }
    }
    if (NULL != pwszDisposition)
    {
        LocalFree(pwszDisposition);
    }

    // Hide the failed HRESULT in the returned Disposition.
    // This allows the encoded Full response and disposition message to be
    // returned via DCOM or RPC.  Returning S_OK != hr defeats this mechanism.

    if (FAILED(hr) &&
	(CR_DISP_ERROR == *pResult->pdwDisposition ||
	 CR_DISP_DENIED == *pResult->pdwDisposition))
    {
	*pResult->pdwDisposition = hr;
	hr = S_OK;
    }
    return(hr);
}


HRESULT
CoreValidateRequestId(
    IN ICertDBRow *prow,
    IN DWORD ExpectedDisposition)
{
    HRESULT hr;
    DWORD cbProp;
    DWORD Disposition;
    
    cbProp = sizeof(Disposition);
    hr = prow->GetProperty(
        g_wszPropRequestDisposition,
        PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
        &cbProp,
        (BYTE *) &Disposition);
    _PrintIfError(hr, "GetProperty");
    if (S_OK != hr || sizeof(Disposition) != cbProp)
    {
        hr = CERTSRV_E_NO_REQUEST;
    }
    else if (Disposition != ExpectedDisposition)
    {
        hr = CERTSRV_E_BAD_REQUESTSTATUS;
    }
    return(hr);
}


HRESULT
SetCAObjectFlags(
    IN DWORD dwFlags)
{
    HRESULT hr = S_OK;
    HCAINFO hCAInfo = NULL;
    DWORD dwCAFlags;

    hr = CAFindByName(
		g_wszSanitizedName,
		NULL,
		CA_FIND_LOCAL_SYSTEM | CA_FIND_INCLUDE_UNTRUSTED,
		&hCAInfo);
    _JumpIfError(hr, error, "CAFindByName");

    hr = CAGetCAFlags(hCAInfo, &dwCAFlags);
    _JumpIfError(hr, error, "CAGetCAFlags");

    dwCAFlags |= dwFlags;

    hr = CASetCAFlags(hCAInfo, dwCAFlags);
    _JumpIfError(hr, error, "CASetCAFlags");

    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");

error:
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\cscom.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cscom.h
//
// Contents:    Cert Server Policy & Exit module callouts
//
//---------------------------------------------------------------------------

#include "certdb.h"


HRESULT ComInit(VOID);

// Releases all Policy/Exit modules
VOID ComShutDown(VOID);

HRESULT
PolicyInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName);

HRESULT PolicyVerifyRequest(
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,
    IN BOOL fNewRequest,
    IN DWORD dwComContextIndex,
    OUT LPWSTR *pwszDispositionMessage, // LocalAlloced.
    OUT DWORD *pVerifyStatus); // VR_PENDING || VR_INSTANT_OK || VR_INSTANT_BAD

extern BOOL g_fEnablePolicy;


HRESULT
ExitInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName);

HRESULT
ExitNotify(
    IN LONG Event,
    IN LONG RequestId,
    IN DWORD dwComContextIndex); //MAXDWORD means no context

BSTR
ExitGetDescription(
    IN DWORD iExitMod);

extern BOOL g_fEnableExit;


HRESULT ComVerifyRequestContext(
    IN BOOL fAllowZero,
    IN DWORD Flags,
    IN LONG Context,
    OUT DWORD *pRequestId);

HRESULT
ComGetClientInfo(
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OUT CERTSRV_COM_CONTEXT **ppComContext);

HRESULT
RegisterComContext(
    IN CERTSRV_COM_CONTEXT *pComContext,
    IN OUT DWORD *pdwIndex);

VOID
UnregisterComContext(
    IN CERTSRV_COM_CONTEXT *pComContext,
    IN DWORD  dwIndex);

CERTSRV_COM_CONTEXT*
GetComContextFromIndex(
    IN DWORD  dwIndex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\elog.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        elog.cpp
//
// Contents:    Cert Server Core implementation
//
// History:     02-Jan-97       terences created
//
//---------------------------------------------------------------------------

// TBD: add AddLoggingEvent, which will log to file instead of the event log
// TBD: add audit events
// TBD: add filtering so that criticality sorting of events can take place

#include <pch.cpp>

#pragma hdrstop


#if DBG_CERTSRV
WCHAR const *
wszEventType(
    IN DWORD dwEventType)
{
    WCHAR const *pwsz;

    switch (dwEventType)
    {
	case EVENTLOG_ERROR_TYPE:	pwsz = L"Error";	 break;
	case EVENTLOG_WARNING_TYPE:	pwsz = L"Warning";	 break;
	case EVENTLOG_INFORMATION_TYPE:	pwsz = L"Information";	 break;
	case EVENTLOG_AUDIT_SUCCESS:	pwsz = L"AuditSuccess";	 break;
	case EVENTLOG_AUDIT_FAILURE:	pwsz = L"AuditFailiure"; break;
	default:			pwsz = L"???";		 break;
    }
    return(pwsz);
}
#endif // DBG_CERTSRV


/*********************************************************************
* FUNCTION: LogEvent(	DWORD   dwEventType,                 	     *
*                       DWORD   dwIdEvent,                           *
*			WORD    cStrings,                            *
*                       LPTSTR *apwszStrings);                        *
*                                                                    *
* PURPOSE: add the event to the event log                            *
*                                                                    *
* INPUT: the event ID to report in the log, the number of insert     *
*        strings, and an array of null-terminated insert strings     *
*                                                                    *
* RETURNS: none                                                      *
*********************************************************************/

HRESULT
LogEvent(
    DWORD dwEventType,
    DWORD dwIdEvent,
    WORD cStrings,
    WCHAR const **apwszStrings)
{
    HRESULT hr;
    HANDLE hAppLog = NULL;
    WORD wElogType;

#if DBG_CERTSRV
    CONSOLEPRINT3((
	    DBG_SS_CERTSRV,
	    "LogEvent(Type=%x(%ws), Id=%x)\n",
	    dwEventType,
	    wszEventType(dwEventType),
	    dwIdEvent));

    for (DWORD i = 0; i < cStrings; i++)
    {
	CONSOLEPRINT2((
		DBG_SS_CERTSRV,
		"LogEvent[%u]: %ws\n",
		i,
		apwszStrings[i]));
    }
#endif // DBG_CERTSRV

    wElogType = (WORD) dwEventType;

    hAppLog = RegisterEventSource(NULL, g_wszCertSrvServiceName);
    if (NULL == hAppLog)
    {
	hr = myHLastError();
	_JumpError(hr, error, "RegisterEventSource");
    }

    if (!ReportEvent(
		hAppLog,
		wElogType,
		0,
		dwIdEvent,
		NULL,
		cStrings,
		0,
		apwszStrings,
		NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "ReportEvent");
    }
    hr = S_OK;

error:
    if (NULL != hAppLog)
    {
	DeregisterEventSource(hAppLog);
    }
    return(hr);
}


HRESULT
LogEventHResult(
    DWORD dwEventType,
    DWORD dwIdEvent,
    HRESULT hrEvent)
{
    HRESULT hr;
    WCHAR const *apwsz[1];
    WORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];

    apwsz[0] = myGetErrorMessageText(hrEvent, TRUE);
    cpwsz = ARRAYSIZE(apwsz);
    if (NULL == apwsz[0])
    {
	apwsz[0] = myHResultToString(awchr, hrEvent);
    }

    hr = LogEvent(dwEventType, dwIdEvent, cpwsz, apwsz);
    _JumpIfError(hr, error, "LogEvent");

error:
    if (NULL != apwsz[0] && awchr != apwsz[0])
    {
	LocalFree(const_cast<WCHAR *>(apwsz[0]));
    }
    return(hr);
}


HRESULT
LogEventString(
    DWORD dwEventType,
    DWORD dwIdEvent,
    OPTIONAL WCHAR const *pwszString)
{
    return(LogEvent(
		dwEventType,
		dwIdEvent,
		NULL == pwszString? 0 : 1,
		NULL == pwszString? NULL : &pwszString));
}


HRESULT
LogEventStringHResult(
    DWORD dwEventType,
    DWORD dwIdEvent,
    WCHAR const *pwszString,
    HRESULT hrEvent)
{
    HRESULT hr;
    WCHAR const *apwsz[2];
    WORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];

    apwsz[0] = pwszString;
    apwsz[1] = myGetErrorMessageText(hrEvent, TRUE);
    if (NULL == apwsz[1])
    {
	apwsz[1] = myHResultToString(awchr, hrEvent);
    }
    cpwsz = ARRAYSIZE(apwsz);

    hr = LogEvent(dwEventType, dwIdEvent, cpwsz, apwsz);
    _JumpIfError(hr, error, "LogEvent");

error:
    if (NULL != apwsz[1] && awchr != apwsz[1])
    {
	LocalFree(const_cast<WCHAR *>(apwsz[1]));
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\event.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999 - 2000
//
// File:        event.cpp
//
// Contents:    Cert CAuditEvent class implementation
//
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop
#include <sid.h>
#include <tfc.h>
#include <authzi.h>

using namespace CertSrv;

CAuditEvent::AUDIT_CATEGORIES cat[] = 
{    // event ID                            // event category         no of   check role separation
                                                                    //args    for this event
    {SE_AUDITID_CERTSRV_SHUTDOWN,           AUDIT_FILTER_STARTSTOP,    0,   TRUE},
    {SE_AUDITID_CERTSRV_SERVICESTART,       AUDIT_FILTER_STARTSTOP,    2,   TRUE},
    {SE_AUDITID_CERTSRV_SERVICESTOP,        AUDIT_FILTER_STARTSTOP,    2,   TRUE},

    {SE_AUDITID_CERTSRV_BACKUPSTART,        AUDIT_FILTER_BACKUPRESTORE,1,   TRUE},
    {SE_AUDITID_CERTSRV_BACKUPEND,          AUDIT_FILTER_BACKUPRESTORE,0,   TRUE},
    {SE_AUDITID_CERTSRV_RESTORESTART,       AUDIT_FILTER_BACKUPRESTORE,0,   FALSE},
    {SE_AUDITID_CERTSRV_RESTOREEND,         AUDIT_FILTER_BACKUPRESTORE,0,   FALSE},

    {SE_AUDITID_CERTSRV_DENYREQUEST,        AUDIT_FILTER_CERTIFICATE,  1,   TRUE},
    {SE_AUDITID_CERTSRV_RESUBMITREQUEST,    AUDIT_FILTER_CERTIFICATE,  1,   TRUE},
    {SE_AUDITID_CERTSRV_SETEXTENSION,       AUDIT_FILTER_CERTIFICATE,  5,   TRUE},
    {SE_AUDITID_CERTSRV_SETATTRIBUTES,      AUDIT_FILTER_CERTIFICATE,  2,   TRUE},
    {SE_AUDITID_CERTSRV_IMPORTCERT,         AUDIT_FILTER_CERTIFICATE,  2,   TRUE},
    {SE_AUDITID_CERTSRV_NEWREQUEST,         AUDIT_FILTER_CERTIFICATE,  3,   FALSE},
    {SE_AUDITID_CERTSRV_REQUESTAPPROVED,    AUDIT_FILTER_CERTIFICATE,  6,   FALSE},
    {SE_AUDITID_CERTSRV_REQUESTDENIED,      AUDIT_FILTER_CERTIFICATE,  6,   FALSE},
    {SE_AUDITID_CERTSRV_REQUESTPENDING,     AUDIT_FILTER_CERTIFICATE,  6,   FALSE},
    {SE_AUDITID_CERTSRV_DELETEROW,          AUDIT_FILTER_CERTIFICATE,  3,   TRUE},
    {SE_AUDITID_CERTSRV_PUBLISHCACERT,      AUDIT_FILTER_CERTIFICATE,  3,   FALSE},

    {SE_AUDITID_CERTSRV_REVOKECERT,         AUDIT_FILTER_CERTREVOCATION, 2, TRUE},
    {SE_AUDITID_CERTSRV_PUBLISHCRL,         AUDIT_FILTER_CERTREVOCATION, 3, TRUE},
    {SE_AUDITID_CERTSRV_AUTOPUBLISHCRL,     AUDIT_FILTER_CERTREVOCATION, 5, FALSE},

    {SE_AUDITID_CERTSRV_SETSECURITY,        AUDIT_FILTER_CASECURITY,   1,   TRUE},
    {SE_AUDITID_CERTSRV_SETAUDITFILTER,     AUDIT_FILTER_CASECURITY,   1,   TRUE},
    {SE_AUDITID_CERTSRV_SETOFFICERRIGHTS,   AUDIT_FILTER_CASECURITY,   2,   TRUE},
    {SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE,AUDIT_FILTER_CASECURITY,   1,   FALSE},

    {SE_AUDITID_CERTSRV_GETARCHIVEDKEY,     AUDIT_FILTER_KEYAARCHIVAL, 1,   TRUE},
    {SE_AUDITID_CERTSRV_KEYARCHIVED,        AUDIT_FILTER_KEYAARCHIVAL, 3,   FALSE},
    {SE_AUDITID_CERTSRV_IMPORTKEY,          AUDIT_FILTER_KEYAARCHIVAL, 1,   TRUE},

    {SE_AUDITID_CERTSRV_SETCONFIGENTRY,     AUDIT_FILTER_CACONFIG,     3,   TRUE},
    {SE_AUDITID_CERTSRV_SETCAPROPERTY,      AUDIT_FILTER_CACONFIG,     4,   TRUE},
};
CAuditEvent::AUDIT_CATEGORIES *CAuditEvent::m_gAuditCategories = cat;

DWORD CAuditEvent::m_gdwAuditCategoriesSize = sizeof(cat)/sizeof(cat[0]);

bool CAuditEvent::m_gfRoleSeparationEnabled = false;

CAuditEvent::CAuditEvent(ULONG ulEventID, DWORD dwFilter) :
    m_cEventData(0),
    m_cRequiredEventData(0),
    m_dwFilter(dwFilter),
    m_fRoleSeparationEnabled(false),
    m_pISS(NULL),
    m_hClientToken(NULL),
    m_pCASD(NULL),
    m_ClientContext(NULL),
    m_pSDPrivileges(NULL),
    m_pDaclPrivileges(NULL),
    m_hRpc(NULL),
    m_Error(0),
    m_MaskAllowed(0),
    m_crtGUID(0),
    m_pUserSid(NULL),
    m_hAuditEventType(NULL)
{
    m_AuthzHandle = NULL;

    m_Request.ObjectTypeList = NULL;
    m_Request.PrincipalSelfSid = NULL;
    m_Request.ObjectTypeListLength = 0;
    m_Request.OptionalArguments = NULL;

    m_Reply.ResultListLength = 1;
    m_Reply.GrantedAccessMask = &m_MaskAllowed;
    m_Reply.Error = &m_Error;
    m_Reply.SaclEvaluationResults = &m_SaclEval;

    SetEventID(ulEventID);
};

// initializes internal data associated with a particular audit event
void CAuditEvent::SetEventID(ULONG ulEventID)
{
    m_ulEventID = ulEventID;

    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(((DWORD)m_ulEventID)==((DWORD)m_gAuditCategories[c].ulAuditID))
        {
            m_fRoleSeparationEnabled = 
                m_gAuditCategories[c].fRoleSeparationEnabled;

            m_cRequiredEventData = m_gAuditCategories[c].dwParamCount;

            CSASSERT(m_EventDataMaxSize>=m_cRequiredEventData);

            if(!m_gAuditCategories[c].hAuditEventType)
            {
                AuthziInitializeAuditEventType(
                    0,
                    SE_CATEGID_OBJECT_ACCESS,
                    (USHORT)m_ulEventID,
                    (USHORT)m_gAuditCategories[c].dwParamCount,
                    &m_gAuditCategories[c].hAuditEventType);

            }
            m_hAuditEventType = m_gAuditCategories[c].hAuditEventType;
            break;
        }
    }
}

CAuditEvent::~CAuditEvent()
{
    for(DWORD cData=0;cData<m_cEventData;cData++)
        delete m_pEventDataList[cData];

    FreeCachedHandles();
}

void CAuditEvent::CleanupAuditEventTypeHandles()
{
    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(m_gAuditCategories[c].hAuditEventType)
        {
            AuthziFreeAuditEventType(m_gAuditCategories[c].hAuditEventType);
        }
    }
}

bool CAuditEvent::IsEventValid()
{
    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(m_ulEventID==m_gAuditCategories[c].ulAuditID)
            return true;
    }
    return false;
}

bool CAuditEvent::IsEventEnabled()
{
    if(0==m_ulEventID) // event is used for access check only
        return false;

    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(((DWORD)m_ulEventID)==((DWORD)m_gAuditCategories[c].ulAuditID))
        {
            return (m_dwFilter&m_gAuditCategories[c].dwFilter)?true:false;
        }
    }
    // if get here the event has an unknown ID
    CSASSERT(!L"Invalid event found");
    return false;
}

inline bool CAuditEvent::IsEventRoleSeparationEnabled()
{
    return RoleSeparationIsEnabled() && m_fRoleSeparationEnabled;
}

HRESULT CAuditEvent::AddData(DWORD dwValue)
{
    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_UI4;
    V_UI4(pvtData) = dwValue;
    return S_OK;
}

HRESULT CAuditEvent::AddData(PBYTE pData, DWORD dwDataLen)
{
    CSASSERT(pData && dwDataLen);

    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_BLOB;
    pvtData->blob.cbSize = dwDataLen;
    pvtData->blob.pBlobData = (BYTE*)CoTaskMemAlloc(dwDataLen);
    if(!pvtData->blob.pBlobData)
    {
        return E_OUTOFMEMORY;
    }
    memcpy(pvtData->blob.pBlobData, pData, dwDataLen);
    return S_OK;
}

HRESULT CAuditEvent::AddData(bool fData)
{
    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_BOOL;
    V_BOOL(pvtData) = fData?VARIANT_TRUE:VARIANT_FALSE;
    return S_OK;
}

HRESULT CAuditEvent::AddData(LPCWSTR pcwszData)
{
    if(!pcwszData)
        pcwszData = L"";

    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_LPWSTR;
    pvtData->pwszVal = 
        (LPWSTR)CoTaskMemAlloc((wcslen(pcwszData)+1)*sizeof(WCHAR));
    if(!pvtData->pwszVal)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(pvtData->pwszVal, pcwszData);
    return S_OK;
}

HRESULT CAuditEvent::AddData(LPCWSTR *ppcwszData)
{
    CSASSERT(ppcwszData);

    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_LPWSTR;

    DWORD dwTextLen = 1;

    for(LPCWSTR *ppcwszStr=ppcwszData; *ppcwszStr; ppcwszStr++)
    {
        dwTextLen += wcslen(*ppcwszStr)+2;
    }
    
    pvtData->pwszVal = 
        (LPWSTR)CoTaskMemAlloc(dwTextLen*sizeof(WCHAR));
    if(!pvtData->pwszVal)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(pvtData->pwszVal, L"");
    for(ppcwszStr=ppcwszData;  *ppcwszStr; ppcwszStr++)
    {
        wcscat(pvtData->pwszVal, *ppcwszStr);
        wcscat(pvtData->pwszVal, L"; ");
    }
    return S_OK;
}

HRESULT CAuditEvent::AddData(FILETIME time)
{
    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_FILETIME;
    pvtData->filetime = time;
    return S_OK;
}

HRESULT CAuditEvent::AddData(const VARIANT *pvar, bool fDoublePercentInStrings=false)
{
    CSASSERT(pvar);

    EventData *pData = CreateNewEventData1();
    if(!pData)
    {
        return E_OUTOFMEMORY;
    }
    pData->m_fDoublePercentsInStrings = fDoublePercentInStrings;

    HRESULT hr = VariantCopy((VARIANT*)&pData->m_vtData, (VARIANT*)pvar);

    return hr;
}


PROPVARIANT *CAuditEvent::CreateNewEventData()
{
    EventData *pData = CreateNewEventData1();
    return &pData->m_vtData;
}

CAuditEvent::EventData *CAuditEvent::CreateNewEventData1()
{
    EventData *pData = new EventData;
    if(!pData)
    {
        return NULL;
    }
    m_pEventDataList[m_cEventData++] = pData;
    return pData;
}

HRESULT CAuditEvent::EventData::ConvertToStringI2I4(
    LONG lVal,
    LPWSTR *ppwszOut)
{
    WCHAR wszVal[100]; // big enough to hold a LONG as string
    _itow(lVal, wszVal, 10);
    *ppwszOut = new WCHAR[wcslen(wszVal)+1];
    if(!*ppwszOut)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*ppwszOut, wszVal);
    return S_OK;
}

HRESULT CAuditEvent::EventData::ConvertToStringUI2UI4(
    ULONG ulVal,
    LPWSTR *ppwszOut)
{
    WCHAR wszVal[100]; // big enough to hold a LONG as string
    _itow(ulVal, wszVal, 10);
    *ppwszOut = new WCHAR[wcslen(wszVal)+1];
    if(!*ppwszOut)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*ppwszOut, wszVal);
    return S_OK;
}

HRESULT CAuditEvent::EventData::DoublePercentsInString(
    LPCWSTR pcwszIn,
    LPWSTR *ppwszOut)
{
    const WCHAR *pchSrc;
    WCHAR *pchDest;
    int cPercentChars = 0;

    wprintf(L"********Found %d percents\n", cPercentChars);

    *ppwszOut = new WCHAR[2*wcslen(pcwszIn)+1];
    if(!*ppwszOut)
        return E_OUTOFMEMORY;

    for(pchSrc = pcwszIn, pchDest = *ppwszOut; 
        L'\0'!=*pchSrc; 
        pchSrc++, pchDest++)
    {
        *pchDest = *pchSrc;
        if(L'%'==*pchSrc)
            *(++pchDest) = L'%';
    }
    *pchDest = L'\0';

    wprintf(L"****************************");
    wprintf(L"%s%", *ppwszOut);
    wprintf(L"****************************");

    return S_OK;
}


HRESULT CAuditEvent::EventData::ConvertToStringWSZ(
    LPCWSTR pcwszVal,
    LPWSTR *ppwszOut)

{
    if(m_fDoublePercentsInStrings)
    {
        // replace each occurence of % with %%
        return DoublePercentsInString(
            pcwszVal,
            ppwszOut);
    }
    else
    {
        *ppwszOut = new WCHAR[(wcslen(pcwszVal)+1)];
        if(!*ppwszOut)
        {
            return E_OUTOFMEMORY;
        }
        wcscpy(*ppwszOut, pcwszVal);
    }
    return S_OK;
}

HRESULT CAuditEvent::EventData::ConvertToStringBOOL(
    BOOL fVal,
    LPWSTR *ppwszOut)

{
    LPCWSTR pwszBoolVal = 
        fVal==VARIANT_TRUE?
        g_pwszYes:
        g_pwszNo;
    *ppwszOut = new WCHAR[wcslen(pwszBoolVal)+1];
    if(!*ppwszOut)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*ppwszOut, pwszBoolVal);
    return S_OK;
}


HRESULT CAuditEvent::EventData::ConvertToStringArrayUI1(
    LPSAFEARRAY psa,
    LPWSTR *ppwszOut)
{
    SafeArrayEnum<BYTE> saenum(psa);
    if(!saenum.IsValid())
    {
        return E_INVALIDARG;
    }
    BYTE b;
    // byte array is formated as "0x00 0x00..." ie 5 
    // chars per byte
    *ppwszOut = new WCHAR[saenum.GetCount()*5];
    if(!*ppwszOut)
        return E_OUTOFMEMORY;

    LPWSTR pwszCrt = *ppwszOut;
    while(S_OK==saenum.Next(b))
    {
        wsprintf(pwszCrt, L"0x%02X ", b); // eg "0x0f" or "0xa4"
        pwszCrt+=5;
    }
    return S_OK;
}

HRESULT CAuditEvent::EventData::ConvertToStringArrayBSTR(
    LPSAFEARRAY psa,
    LPWSTR *ppwszOut)
{
    SafeArrayEnum<BSTR> saenum(psa);
    if(!saenum.IsValid())
    {
        return E_INVALIDARG;
    }
    DWORD dwLen = 1;
    BSTR bstr;

    while(S_OK==saenum.Next(bstr))
    {
        dwLen+=2*wcslen(bstr)+10;
    }
    *ppwszOut = new WCHAR[dwLen];
    if(!*ppwszOut)
        return E_OUTOFMEMORY;
    **ppwszOut = L'\0';
        
    saenum.Reset();

    while(S_OK==saenum.Next(bstr))
    {
        if(m_fDoublePercentsInStrings)
        {
            CAutoLPWSTR pwszTemp;
            if(S_OK != DoublePercentsInString(bstr,
                &pwszTemp))
            {
                delete[] *ppwszOut;
                *ppwszOut = NULL;
                return E_OUTOFMEMORY;
            }
            wcscat(*ppwszOut, pwszTemp);
        }
        else
        {
            wcscat(*ppwszOut, bstr);
        }
        wcscat(*ppwszOut, L"\n");
    }
    return S_OK;
}

HRESULT CAuditEvent::EventData::ConvertToString(LPWSTR *ppwszValue)
{
    LPWSTR pwszVal = NULL;
    HRESULT hr = S_OK;
    switch(V_VT(&m_vtData))
    {
    case VT_I2:
        hr = ConvertToStringI2I4(V_I2(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_I2:
        hr = ConvertToStringI2I4(*V_I2REF(&m_vtData), ppwszValue);
        break;
    case VT_I4:
        hr = ConvertToStringI2I4(V_I4(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_I4:
        hr = ConvertToStringI2I4(*V_I4REF(&m_vtData), ppwszValue);
        break;
    case VT_UI2:
        hr = ConvertToStringUI2UI4(V_UI2(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_UI2:
        hr = ConvertToStringUI2UI4(*V_UI2REF(&m_vtData), ppwszValue);
        break;
    case VT_UI4:
        hr = ConvertToStringUI2UI4(V_UI4(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_UI4:
        hr = ConvertToStringUI2UI4(*V_UI4REF(&m_vtData), ppwszValue);
        break;

    case VT_BLOB:
	// We don't call CryptBinaryToString directly anywhere in the CA tree.
	// This avoids errors when linking in the CryptBinaryToString code
	// for NT 4 reskit builds.

        WCHAR *pwszLocalAlloc;

        hr = myCryptBinaryToString(
                m_vtData.blob.pBlobData,
                m_vtData.blob.cbSize,
                CRYPT_STRING_BASE64,
                &pwszLocalAlloc);
        if (S_OK != hr)
        {
            return(hr);
        }
        pwszVal = new WCHAR[(wcslen(pwszLocalAlloc) + 1)];
        if (NULL == pwszVal)
        {
            LocalFree(pwszLocalAlloc);
            return E_OUTOFMEMORY;
        }
        wcscpy(pwszVal, pwszLocalAlloc);
        LocalFree(pwszLocalAlloc);
        *ppwszValue = pwszVal;
//        pwszVal[cOut-2] = L'\0'; \\ Base64Encode adds a new line
        break;

    case VT_BOOL:
        hr = ConvertToStringBOOL(V_BOOL(&m_vtData), ppwszValue);
        break;
    case VT_BOOL|VT_BYREF:
        hr = ConvertToStringBOOL(*V_BOOLREF(&m_vtData), ppwszValue);
        break;

    case VT_LPWSTR:
        hr = ConvertToStringWSZ(m_vtData.pwszVal, ppwszValue);
        break;
    case VT_BSTR:
        hr = ConvertToStringWSZ(V_BSTR(&m_vtData), ppwszValue);
        break;
    case VT_BSTR|VT_BYREF:
        hr = ConvertToStringWSZ(*V_BSTRREF(&m_vtData), ppwszValue);
        break;

    case VT_FILETIME:
        {
        LPWSTR pwszTime = NULL;
        hr = myFileTimeToWszTime(
                &m_vtData.filetime,
                TRUE,
                &pwszTime);
        if(FAILED(hr))
            return hr;
        pwszVal = new WCHAR[wcslen(pwszTime)+1];
        if(!pwszVal)
        {
            return E_OUTOFMEMORY;
        }
        wcscpy(pwszVal, pwszTime);
        LocalFree(pwszTime);
        *ppwszValue = pwszVal;
        }
        break;

    case VT_ARRAY|VT_UI1:
        hr = ConvertToStringArrayUI1(V_ARRAY(&m_vtData), ppwszValue);
        break;
    case VT_ARRAY|VT_UI1|VT_BYREF:
        hr = ConvertToStringArrayUI1(*V_ARRAYREF(&m_vtData), ppwszValue);
        break;
    case VT_ARRAY|VT_BSTR:
        hr = ConvertToStringArrayBSTR(V_ARRAY(&m_vtData), ppwszValue);
        break;
    case VT_ARRAY|VT_BSTR|VT_BYREF:
        hr = ConvertToStringArrayBSTR(*V_ARRAYREF(&m_vtData), ppwszValue);
        break;

    default:
        {
            LPCWSTR pwszValOut = cAuditString_UnknownDataType;
            VARIANT varOut;
            VariantInit(&varOut);

            hr = VariantChangeType(&varOut, (VARIANT*)&m_vtData, 0, VT_BSTR);
            if(S_OK==hr)
            {
                pwszValOut = V_BSTR(&varOut);
            }
            pwszVal = new WCHAR[wcslen(pwszValOut)+1];
            if(!pwszVal)
            {
                return E_OUTOFMEMORY;
            }
            wcscpy(pwszVal, pwszValOut);
            VariantClear(&varOut);
            *ppwszValue = pwszVal;
            hr = S_OK;
        }
        break;
    }
    
    return hr;
}

HRESULT CAuditEvent::Report(bool fSuccess /* = true */)
{
    HRESULT hr;
    AUTHZ_AUDIT_EVENT_HANDLE AuthzAIH = NULL;
    PAUDIT_PARAMS pAuditParams = NULL;
    PAUDIT_PARAM pParamArray = NULL;

    if(!IsEventEnabled())
    {
        return S_OK;
    }
    hr = BuildAuditParamArray(pParamArray);
    _JumpIfError(hr, error, "GetAuditText");

    if(!AuthziAllocateAuditParams(
        &pAuditParams, 
        (USHORT)(m_cEventData+2))) // authz adds 2 
    {                                                             // extra params
        hr = myHLastError();                                      // internally
        _JumpError(hr, error, "AuthziAllocateAuditParams");
    }

#ifndef _DISABLE_AUTHZ_
    if(!AuthziInitializeAuditParamsFromArray(
            fSuccess?APF_AuditSuccess:APF_AuditFailure,
            g_AuthzCertSrvRM,
            (USHORT)m_cEventData,
            pParamArray,
            pAuditParams))
#else
    SetLastError(E_INVALIDARG);
#endif
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthziInitializeAuditParamsFromArray");
    }

    if (!AuthziInitializeAuditEvent(0,
                                   g_AuthzCertSrvRM,
                                   m_hAuditEventType,
                                   pAuditParams,
                                   NULL,
                                   INFINITE,
                                   L"",
                                   L"",
                                   L"",
                                   L"",
                                   &AuthzAIH))

    {
        hr = myHLastError();
        _JumpIfError(hr, error, "AuthzInitializeAuditInfo");
    }

   if(!AuthziLogAuditEvent( 0, AuthzAIH, NULL ))
   {
       hr = myHLastError();
       _JumpIfError(hr, error, "AuthzGenAuditEvent");
   }

    DBGPRINT((
	DBG_SS_AUDIT,
	"Audit event ID=%d\n",
	m_ulEventID));

error:

    if(AuthzAIH)
    {
        AuthzFreeAuditEvent(AuthzAIH);
    }

    if(pAuditParams)
    {
        AuthziFreeAuditParams(pAuditParams);
    }

    FreeAuditParamArray(pParamArray);

    return hr;
}

HRESULT CAuditEvent::SaveFilter(LPCWSTR pcwszSanitizedName)
{
    return mySetCertRegDWValue(
			    pcwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGAUDITFILTER,
                m_dwFilter);
}

HRESULT CAuditEvent::LoadFilter(LPCWSTR pcwszSanitizedName)
{
    return myGetCertRegDWValue(
			    pcwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGAUDITFILTER,
                &m_dwFilter);
}

HRESULT CAuditEvent::Impersonate()
{
    HRESULT hr;
    HANDLE hThread = NULL;

    CSASSERT(NULL==m_pISS);
    CSASSERT(NULL==m_hClientToken);
    
    if (NULL == m_hRpc)
    {
        // dcom impersonate
        hr = CoGetCallContext(IID_IServerSecurity, (void**)&m_pISS);
        _JumpIfError(hr, error, "CoGetCallContext");

        hr = m_pISS->ImpersonateClient();
        _JumpIfError(hr, error, "ImpersonateClient");
    }
    else
    {
        // rpc impersonate
        hr = RpcImpersonateClient((RPC_BINDING_HANDLE) m_hRpc);
        if (S_OK != hr)
        {
            hr = myHError(hr);
            _JumpError(hr, error, "RpcImpersonateClient");
        }
    }

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }
    if (!OpenThreadToken(hThread,
                         TOKEN_QUERY | TOKEN_DUPLICATE,
                         FALSE,  // client impersonation
                         &m_hClientToken))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "OpenThreadToken");
    }

error:

    if(S_OK!=hr)
    {
        if(NULL!=m_pISS)
        {
            m_pISS->Release();
            m_pISS = NULL;
        }
    }
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    return hr;
}

HRESULT CAuditEvent::RevertToSelf()
{
    HRESULT hr = S_OK;
//    CSASSERT(m_pISS||m_hRpc);

    if (NULL != m_hRpc) // rpc
    {
        hr = RpcRevertToSelf();
        if (S_OK != hr)
        {
            hr = myHError(hr);
            _JumpError(hr, error, "RpcRevertToSelf");
        }
        m_hRpc = NULL;
    }
    else  if(m_pISS) // dcom
    {
        hr = m_pISS->RevertToSelf();
        _JumpIfError(hr, error, "IServerSecurity::RpcRevertToSelf");

        m_pISS->Release();
        m_pISS = NULL;
    }

error:
    return hr;
}

HANDLE CAuditEvent::GetClientToken()
{
    CSASSERT(m_hClientToken);
    HANDLE hSave = m_hClientToken;
    m_hClientToken = NULL;
    return hSave;
}

// dwAuditFlags - not asking for both success and failure implicitely
// means the handles will be cached for future audit
HRESULT
CAuditEvent::AccessCheck(
    ACCESS_MASK Mask,
    DWORD dwAuditFlags,
    handle_t hRpc,
    HANDLE *phToken)
{
    HRESULT hr = S_OK;
    LUID luid = {0,0};
    bool fAccessAllowed = false;
    DWORD dwRoles = 0;
    DWORD dwRolesChecked = 0;
    PACL pDacl = NULL;

    FreeCachedHandles();

    m_hRpc = hRpc;

    if (!g_CASD.IsInitialized())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        _JumpError(hr, error, "Security not enabled");
    }
    
    hr = g_CASD.LockGet(&m_pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = Impersonate();
    _JumpIfError(hr, error, "CAuditEvent::Impersonate");

    if(!AuthzInitializeContextFromToken(
            0,
            m_hClientToken,
            g_AuthzCertSrvRM,
            NULL,
            luid,
            NULL,
            &m_ClientContext))
    {
        hr = myHLastError();
        _PrintError(hr, "AuthzInitializeContextFromToken");
    
        if (E_INVALIDARG == hr && !IsWhistler())
        {
            hr = S_OK;
            fAccessAllowed = TRUE;
        }
        goto error;
    }

    if(Mask & CA_ACCESS_LOCALADMIN)
    {
        bool fLocalAdmin;

        hr = IsCurrentUserBuiltinAdmin(&fLocalAdmin);
        _JumpIfError(hr, error, "IsCurrentUserBuiltinAdmin");

        if(fLocalAdmin)
        {
            dwRoles |= CA_ACCESS_LOCALADMIN;
        }
    }

    RevertToSelf();

    // Get privilege based roles if checking access on a privilege role
    // or if role separation is enabled when we have to know all roles
    if(IsEventRoleSeparationEnabled() ||
       Mask & (CA_ACCESS_OPERATOR|CA_ACCESS_AUDITOR|CA_ACCESS_LOCALADMIN))
    {
        hr = GetPrivilegeRoles(&dwRoles);
        _JumpIfError(hr, error, "CAuditEvent::GetPrivilegeRolesCount");

        hr = BuildPrivilegeSecurityDescriptor(dwRoles);
        _JumpIfError(hr, error, "CAuditEvent::BuildPrivilegeSecurityDescriptor");
    }

    // Get security descriptor based roles
    m_Request.DesiredAccess = MAXIMUM_ALLOWED;
    CSASSERT(!m_AuthzHandle);
    if(!AuthzAccessCheck(
            0,
            m_ClientContext,
            &m_Request,
            NULL, //no audit
            m_pCASD,
            m_pSDPrivileges?(&m_pSDPrivileges):NULL,
            m_pSDPrivileges?1:0,
            &m_Reply,
            IsEventEnabled()?&m_AuthzHandle:NULL)) // no caching if no audit
                                                   // event will be generated
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzAccessCheck");
    }
    
    dwRoles |= m_Reply.GrantedAccessMask[0];
    
    if(m_Reply.Error[0]==ERROR_SUCCESS &&
       m_Reply.GrantedAccessMask[0]&Mask)
    {
        fAccessAllowed = true;
    }

    if(IsEventRoleSeparationEnabled() &&
       GetBitCount(dwRoles&CA_ACCESS_MASKROLES)>1)
    {
        hr = CERTSRV_E_ROLECONFLICT;
        fAccessAllowed = false;
        // don't return yet, we need to generate an audit
    }

    // Next is a fake access check to generate an audit. 
    // Access is denied if:
    // - role separation is enabled and user has more than one role
    // - none of the roles requested is allowed

    // Generate audit if event is enabled and 
    if(IsEventEnabled() &&
        (!fAccessAllowed && !(dwAuditFlags&m_gcNoAuditFailure) ||
         fAccessAllowed && !(dwAuditFlags&m_gcNoAuditSuccess)))
    {

        m_Request.DesiredAccess = 
            fAccessAllowed?
            m_Reply.GrantedAccessMask[0]&Mask:
            Mask;

        if(CERTSRV_E_ROLECONFLICT==hr)
            m_Request.DesiredAccess = 0x0000ffff; //force a failure audit
        
        HRESULT hr2 = CachedGenerateAudit();
        if(S_OK != hr2)
        {
            hr = hr2;
            _JumpIfError(hr, error, "CAuditEvent::CachedGenerateAudit");
        }
    }

    if(phToken)
    {
        *phToken = GetClientToken();
    }

error:

#ifdef DBG_CERTSRV_DEBUG_PRINT
    if(IsEventRoleSeparationEnabled())
    {
        DBGPRINT((DBG_SS_AUDIT, "EVENT %d ROLES: 0x%x %s%s%s%s%s%s\n", 
            m_ulEventID,
            dwRoles,
        (dwRoles&CA_ACCESS_ADMIN)?"CAADMIN ":"",
        (dwRoles&CA_ACCESS_OFFICER)?"OFFICER ":"",
        (dwRoles&CA_ACCESS_AUDITOR)?"AUDITOR ":"",
        (dwRoles&CA_ACCESS_OPERATOR)?"OPERATOR ":"",
        (dwRoles&CA_ACCESS_ENROLL)?"ENROLL ":"",
        (dwRoles&CA_ACCESS_READ)?"READ ":""));
    }
#endif

    if(!IsEventEnabled())
    {
        FreeCachedHandles();
    }

    if(S_OK==hr)
    {
        hr = fAccessAllowed?S_OK:E_ACCESSDENIED;
    }

    return(hr);
}

HRESULT 
CAuditEvent::CachedGenerateAudit()
{
    HRESULT hr = S_OK;
    AUTHZ_AUDIT_EVENT_HANDLE AuditInfo = NULL;
    PAUDIT_PARAMS pAuditParams = NULL;
    PAUDIT_PARAM pParamArray = NULL;

    if(!IsEventEnabled())
    {
        FreeCachedHandles();
        return S_OK;
    }

    CSASSERT(m_AuthzHandle);

    hr = BuildAuditParamArray(pParamArray);
    _JumpIfError(hr, error, "GetAuditText");

    if(!AuthziAllocateAuditParams(
        &pAuditParams, 
        (USHORT)(m_cEventData+2))) // authz adds 2 
    {                                                             // extra params
        hr = myHLastError();                                      // internally
        _JumpError(hr, error, "AuthziAllocateAuditParams");
    }

#ifndef _DISABLE_AUTHZ_
    if(!AuthziInitializeAuditParamsFromArray(
            APF_AuditSuccess|APF_AuditFailure,
            g_AuthzCertSrvRM,
            (USHORT)m_cEventData,
            pParamArray,
            pAuditParams))
#else
    SetLastError(E_INVALIDARG);
#endif
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitAuditParams");
    }

    if(!AuthziInitializeAuditEvent(
            0,
            g_AuthzCertSrvRM,
            m_hAuditEventType,
            pAuditParams,
            NULL,
            INFINITE,
            L"",
            L"",
            L"",
            L"",
            &AuditInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitAuditInfoHandle");
    }

    if(!AuthzCachedAccessCheck(
            0,
            m_AuthzHandle,
            &m_Request,
            AuditInfo,
            &m_Reply))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzCachedAccessCheck");
    }

error:

    if(AuditInfo)
    {
        AuthzFreeAuditEvent(AuditInfo);
    }

    if(pAuditParams)
    {
        AuthziFreeAuditParams(pAuditParams);
    }

    FreeCachedHandles();
    FreeAuditParamArray(pParamArray);

    return hr;
}


void CAuditEvent::FreeCachedHandles()
{
    if(m_hClientToken)
    {
        CloseHandle(m_hClientToken);
        m_hClientToken = NULL;
    }

    if(m_AuthzHandle)
    {
        AuthzFreeHandle(m_AuthzHandle);
        m_AuthzHandle = NULL;
    }

    if(m_pCASD)
    {
        g_CASD.Unlock();
        m_pCASD = NULL;
    }

    if(m_ClientContext)
    {
        AuthzFreeContext(m_ClientContext);
        m_ClientContext = NULL;
    }

    if(m_pUserSid)
    {
        LocalFree(m_pUserSid);
        m_pUserSid = NULL;
    }
    if(m_pSDPrivileges)
    {
        LocalFree(m_pSDPrivileges);
        m_pSDPrivileges = NULL;
    }
    if(m_pDaclPrivileges)
    {
        LocalFree(m_pDaclPrivileges);
        m_pDaclPrivileges = NULL;
    }
}

HRESULT CAuditEvent::RoleSeparationFlagSave(LPCWSTR pcwszSanitizedName)
{
    return mySetCertRegDWValue(
			    pcwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGROLESEPARATIONENABLED,
                RoleSeparationIsEnabled()?1:0);
}

HRESULT CAuditEvent::RoleSeparationFlagLoad(LPCWSTR pcwszSanitizedName)
{
    DWORD dwFlags = 0;
    HRESULT hr = myGetCertRegDWValue(
			        pcwszSanitizedName,
			        NULL,
			        NULL,
			        wszREGROLESEPARATIONENABLED,
                    &dwFlags);
    if(S_OK==hr)
    {
        RoleSeparationEnable(dwFlags?true:false);
    }

    return hr;
}

HRESULT CAuditEvent::GetPrivilegeRoles(PDWORD pdwRoles)
{
    HRESULT hr = S_OK;
    PTOKEN_USER pTokenUser = NULL;
    DWORD cbTokenUser = 0;
    PTOKEN_GROUPS pTokenGroups = NULL;
    DWORD cbTokenGroups = 0;
    DWORD dwRoles = 0;
    LSA_HANDLE lsahPolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS NTStatus;

    // first get roles for the user itself
    AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoUserSid,
            0,
            &cbTokenUser,
            NULL);       
     
    if(GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    pTokenUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, cbTokenUser);
    _JumpIfAllocFailed(pTokenUser, error);

    if(!AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoUserSid,
            cbTokenUser,
            &cbTokenUser,
            pTokenUser))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    // Object attributes are reserved, so initalize to zeroes.
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    NTStatus = LsaOpenPolicy(
                NULL,
                &ObjectAttributes,
                POLICY_LOOKUP_NAMES,
                &lsahPolicyHandle);
    if(STATUS_SUCCESS!=NTStatus)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(NTStatus));
        _JumpError(hr, error, "LsaOpenPolicy");
    }
  
    CSASSERT(!m_pUserSid);
    m_pUserSid = (PSID)LocalAlloc(LMEM_FIXED, GetLengthSid(pTokenUser->User.Sid));
    _JumpIfAllocFailed(m_pUserSid, error);

    CopySid(
        GetLengthSid(pTokenUser->User.Sid), 
        m_pUserSid,
        pTokenUser->User.Sid);

    hr = GetUserPrivilegeRoles(lsahPolicyHandle, &pTokenUser->User, &dwRoles);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr =S_OK;
    }
    _JumpIfError(hr, error, "CAuditEvent::GetUserPrivilegeRoles");

    *pdwRoles |= dwRoles;

    // then find the roles assigned to the groups the user is member of

    AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoGroupsSids,
            0,
            &cbTokenGroups,
            NULL);

    if(GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    pTokenGroups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, cbTokenGroups);
    _JumpIfAllocFailed(pTokenGroups, error);

    if(!AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoGroupsSids,
            cbTokenGroups,
            &cbTokenGroups,
            pTokenGroups))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    for(DWORD cGroups = 0; cGroups<pTokenGroups->GroupCount; cGroups++)
    {
        dwRoles = 0;
        hr = GetUserPrivilegeRoles(
                lsahPolicyHandle,
                &pTokenGroups->Groups[cGroups], 
                &dwRoles);
        if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
        {
            hr =S_OK;
        }
        _JumpIfError(hr, error, "CAuditEvent::GetUserPrivilegeRoles");

        *pdwRoles |= dwRoles;
    }

error:
    if(pTokenUser)
    {
        LocalFree(pTokenUser);
    }
    if(pTokenGroups)
    {
        LocalFree(pTokenGroups);
    }
    if(lsahPolicyHandle)
    {
        LsaClose(lsahPolicyHandle);
    }
    return hr;
}


HRESULT CAuditEvent::GetUserPrivilegeRoles(
    LSA_HANDLE lsah,
    PSID_AND_ATTRIBUTES pSA, 
    PDWORD pdwRoles)
{
    NTSTATUS NTStatus;
    PLSA_UNICODE_STRING pLSAString = NULL;
    ULONG cRights, c;
    
    NTStatus = LsaEnumerateAccountRights(
                lsah,
                pSA->Sid,
                &pLSAString,
                &cRights);

    if(STATUS_SUCCESS!=NTStatus)
    {
        return HRESULT_FROM_WIN32(LsaNtStatusToWinError(NTStatus));
    }

    for(c=0; c<cRights; c++)
    {
        if(0==_wcsicmp(SE_SECURITY_NAME, pLSAString[c].Buffer))
        {
            *pdwRoles |= CA_ACCESS_AUDITOR;
        }
        else if(0==_wcsicmp(SE_BACKUP_NAME, pLSAString[c].Buffer))
        {
            *pdwRoles |= CA_ACCESS_OPERATOR;
        }
    }

    if(pLSAString)
    {
        LsaFreeMemory(pLSAString);
    }

    return S_OK;
}

HRESULT
CAuditEvent::GetMyRoles(
    DWORD *pdwRoles)
{
    HRESULT hr = S_OK;
    LUID luid = {0,0};
    bool fAccessAllowed = true;
    DWORD dwRoles = 0;

    if (!g_CASD.IsInitialized())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        _JumpError(hr, error, "Security not enabled");
    }
    
    hr = g_CASD.LockGet(&m_pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = Impersonate();
    _JumpIfError(hr, error, "CAuditEvent::Impersonate");

    if(!AuthzInitializeContextFromToken(
            0,
            m_hClientToken,
            g_AuthzCertSrvRM,
            NULL,
            luid,
            NULL,
            &m_ClientContext))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitializeContextFromToken");
    }

    RevertToSelf();

    hr = GetPrivilegeRoles(&dwRoles);
    _JumpIfError(hr, error, "CAuditEvent::GetPrivilegeRoles");

    m_Request.DesiredAccess = MAXIMUM_ALLOWED;
    m_Reply.GrantedAccessMask[0] = 0;

    if(!AuthzAccessCheck(
            0,
            m_ClientContext,
            &m_Request,
            NULL, //no audit
            m_pCASD,
            NULL,
            0,
            &m_Reply,
            NULL))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzAccessCheck");
    }
    
    dwRoles |= (m_Reply.GrantedAccessMask[0] &
                (CA_ACCESS_MASKROLES | // returned mask could also
                 CA_ACCESS_READ |      // include generic rights (like
                 CA_ACCESS_ENROLL));   // read and write DACL) which
                                       // we are not interested in
    *pdwRoles = dwRoles;

error:

    FreeCachedHandles();

    return(hr);
}


// Build a one ace DACL security descriptor with the roles
// passed in
HRESULT CAuditEvent::BuildPrivilegeSecurityDescriptor(DWORD dwRoles)
{
    HRESULT hr = S_OK;
    DWORD dwDaclSize;
    PSID pOwnerSid = NULL; // no free
    PSID pGroupSid = NULL; // no free
    BOOL fDefaulted;

    CSASSERT(NULL == m_pSDPrivileges);
    CSASSERT(NULL == m_pDaclPrivileges);

    m_pSDPrivileges = (PSECURITY_DESCRIPTOR)LocalAlloc(
                        LMEM_FIXED,
                        SECURITY_DESCRIPTOR_MIN_LENGTH);
    _JumpIfAllocFailed(m_pSDPrivileges, error);

    if (!InitializeSecurityDescriptor(
            m_pSDPrivileges,
            SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    CSASSERT(m_pUserSid && IsValidSid(m_pUserSid));

    dwDaclSize =  sizeof(ACL) +
        sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+
        GetLengthSid(m_pUserSid);
    
    m_pDaclPrivileges = (PACL)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, dwDaclSize);
    _JumpIfAllocFailed(m_pDaclPrivileges, error);

    if(!InitializeAcl(m_pDaclPrivileges, dwDaclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    if(!AddAccessAllowedAce(
            m_pDaclPrivileges,
            ACL_REVISION,
            dwRoles,
            m_pUserSid))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AddAccessAllowedAce");
    }

    if(!GetSecurityDescriptorOwner(m_pCASD,
                                  &pOwnerSid,
                                  &fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorOwner");
    }

    if(!SetSecurityDescriptorOwner(m_pSDPrivileges,
                                  pOwnerSid,
                                  fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorOwner");
    }

    if(!GetSecurityDescriptorGroup(m_pCASD,
                                  &pGroupSid,
                                  &fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
    }

    if(!SetSecurityDescriptorGroup(m_pSDPrivileges,
                                  pGroupSid,
                                  fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorGroup");
    }

    if(!SetSecurityDescriptorDacl(m_pSDPrivileges,
                                  TRUE,
                                  m_pDaclPrivileges,
                                  FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    CSASSERT(IsValidSecurityDescriptor(m_pSDPrivileges));

error:

    if(S_OK != hr)
    {
        if(m_pDaclPrivileges)
        {
            LocalFree(m_pDaclPrivileges);
            m_pDaclPrivileges = NULL;
        }

        if(m_pSDPrivileges)
        {
            LocalFree(m_pSDPrivileges);
            m_pSDPrivileges = NULL;
        }
    }
    return hr;
}

HRESULT CAuditEvent::BuildAuditParamArray(PAUDIT_PARAM& rpParamArray)
{
    HRESULT hr = S_OK;

    // number of parameters added should be the same as the number of
    // params defined in the audit format string in msaudite.dll
    CSASSERT(m_cEventData == m_cRequiredEventData);

    rpParamArray = (PAUDIT_PARAM) LocalAlloc(
        LMEM_FIXED | LMEM_ZEROINIT, 
        sizeof(AUDIT_PARAM)*m_cEventData);
    _JumpIfAllocFailed(rpParamArray, error);

    for(USHORT c=0;c<m_cEventData;c++)
    {
        rpParamArray[c].Type = APT_String;
        
        hr = m_pEventDataList[c]->ConvertToString(
            &rpParamArray[c].String);
        _JumpIfError(hr, error, "ConvertToString");
    }

error:
    return hr;
}

void CAuditEvent::FreeAuditParamArray(PAUDIT_PARAM pParamArray)
{
    if(pParamArray)
    {
        for(USHORT c=0;c<m_cEventData;c++)
        {
            if(pParamArray[c].String)
                delete[]  pParamArray[c].String;
        }

        LocalFree(pParamArray);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\elog.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        elog.cpp
//
// Contents:    Event log helper functions
//
// History:     02-Jan-97       terences created
//
//---------------------------------------------------------------------------


HRESULT
LogEvent(
    DWORD dwEventType,
    DWORD dwIdEvent,
    WORD cStrings,
    WCHAR const **pszStrings);

HRESULT
LogEventHResult(
    DWORD dwEventType,
    DWORD dwIdEvent,
    HRESULT hr);

HRESULT
LogEventString(
    DWORD dwEventType,
    DWORD dwIdEvent,
    WCHAR const *pwszString);

HRESULT
LogEventStringHResult(
    DWORD dwEventType,
    DWORD dwIdEvent,
    WCHAR const *pwszString,
    HRESULT hr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certsrv"


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef MAXDWORD
# define MAXDWORD MAXULONG
#endif

#include <windows.h>
#include <wincrypt.h>
#include <authz.h>
#include <adtgen.h>
#include <msaudite.h>

#include "certlib.h"
#include "certsrv.h"
#include "certdb.h"
#include "config.h"
#include "audit.h"
#include "csext.h"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

SOURCE_DIR=..\idl\rpc\$(O)

$(NTTARGETFILE1):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\resource.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        resource.h
//
// Contents:    Cert Server resource definitions
//
//---------------------------------------------------------------------------

#define IDS_DENIEDBY			 1
#define IDS_POLICYDENIED		 2
#define IDS_ISSUED			 3
#define IDS_UNDERSUBMISSION		 4
#define IDS_REVOKEDBY			 5
#define IDS_PRINTFCERTREQUESTDISPOSITION 6
#define IDS_USAGE 			 7
#define IDS_REQUESTPROCESSERROR		 8
#define IDS_RESUBMITTEDBY		 9
#define IDS_USAGE_FULL			 10
#define IDS_USAGE_COMTEST		 11
#define IDS_UNKNOWNSUBJECT		 12
#define IDS_UNREVOKEDBY			 13
#define IDS_REQUESTEDBY			 14
#define IDS_INTERMEDIATECASTORE		 15
#define IDS_PUBLISHERROR		 16
#define IDS_PUBLISHEDBY			 17
#define IDS_REQUESTPARSEERROR		 18
#define IDS_YES				 19
#define IDS_NO				 20
#define IDS_ALLOW			 21
#define IDS_DENY			 22
#define IDS_CAADMIN			 23
#define IDS_OFFICER			 24
#define IDS_READ			 25
#define IDS_ENROLL			 26

#define IDI_APP                          201
#define IDI_PRODUCT                      202

// Marshalling uses AT LEAST WM_USER+0

#define WM_STARTSERVER		WM_USER+20
#define WM_STOPSERVER		WM_USER+21
#define WM_SUSPENDSERVER	WM_USER+22
#define WM_RESTARTSERVER	WM_USER+23
#define WM_SYNC_CLOSING_THREADS WM_USER+24
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\prop.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        prop.cpp
//
// Contents:    Cert Server Property interface implementation
//
// History:     31-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "cscom.h"
#include "csdisp.h"
#include "com.h"
#include "certlog.h"
#include "elog.h"

#ifndef DBG_PROP
# define DBG_PROP	0
#endif


HRESULT
PropSetRequestTimeProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszProp)
{
    HRESULT hr;
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SystemTimeToFileTime");
    }
    hr = prow->SetProperty(
		pwszProp,
		PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		sizeof(ft),
		(BYTE *) &ft);
    _JumpIfError(hr, error, "SetProperty");

error:
    return(hr);
}


HRESULT
PropParseRequest(
    IN ICertDBRow *prow,
    IN DWORD dwFlags,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;

    pResult->dwFlagsTop = dwFlags;
    hr = PKCSParseRequest(
		    dwFlags,
		    prow,
		    cbRequest,
		    pbRequest,
		    NULL,
		    NULL,
		    pResult);
    _JumpIfError(hr, error, "PKCSParseRequest");

error:
    return(hr);
}


HRESULT
propVerifyDateRange(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN FILETIME const *pft)
{
    HRESULT hr;
    DWORD cbProp;
    FILETIME ftNotBefore;
    FILETIME ftNotAfter;

    hr = E_INVALIDARG;
    CSASSERT((PROPTYPE_MASK & Flags) == PROPTYPE_DATE);

    if ((PROPTABLE_MASK & Flags) != PROPTABLE_CERTIFICATE)
    {
	_JumpError(hr, error, "Flags: Invalid table");
    }
    if (0 != lstrcmpi(pwszPropertyName, g_wszPropCertificateNotBeforeDate) &&
	0 != lstrcmpi(pwszPropertyName, g_wszPropCertificateNotAfterDate))
    {
	_JumpError(hr, error, "pwszPropertyName: Invalid date property");
    }

    cbProp = sizeof(ftNotBefore);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    Flags,
		    &cbProp,
		    (BYTE *) &ftNotBefore);
    _JumpIfError(hr, error, "GetProperty");

    cbProp = sizeof(ftNotAfter);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotAfterDate,
		    Flags,
		    &cbProp,
		    (BYTE *) &ftNotAfter);
    _JumpIfError(hr, error, "GetProperty");

    if (0 > CompareFileTime(pft, &ftNotBefore) ||
	0 < CompareFileTime(pft, &ftNotAfter))
    {
	CERTSRVDBGPRINTTIME("Old Not Before", &ftNotBefore);
	CERTSRVDBGPRINTTIME(" Old Not After", &ftNotAfter);
	CERTSRVDBGPRINTTIME(
		0 == lstrcmpi(
			pwszPropertyName,
			g_wszPropCertificateNotBeforeDate)?
		    "New Not Before" : " New Not After",
		pft);

	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "FILETIME out of range", pwszPropertyName);
    }

error:
    return(myHError(hr));
}


// Returns TRUE if names match!

#define PROPNAMEMATCH(cwcNameVariable, pwszNameVariable, wszNameLiteral) \
    (WSZARRAYSIZE((wszNameLiteral)) == (cwcNameVariable) && \
     0 == lstrcmpi((pwszNameVariable), (wszNameLiteral)))

HRESULT
propGetSystemProperty(
    IN WCHAR const *pwszPropName,
    IN DWORD Flags, 
    OUT BYTE *rgbFastBuf,
    IN DWORD cbFastBuf,
    IN LONG  Context,
    OUT BOOL *pfSystemProperty,
    OUT VARIANT *pvarPropertyValue)
{
    HRESULT hr = S_OK;
    BYTE *pbFree = NULL;
    DWORD cwcPropName;
    DWORD cwcBaseName;
    WCHAR wszBaseName[32];
    WCHAR const *pwszIndex;
    WCHAR wszRenewalSuffix[cwcFILENAMESUFFIXMAX];
    DWORD iCert = MAXDWORD;
    DWORD iCRL;
    DWORD iDummy;
    DWORD State;
    DWORD PropType;
    DWORD cbCopy;
    DWORD cbOut;
    BYTE const *pbOut = NULL;		// PROPTYPE_LONG or PROPTYPE_BINARY
    WCHAR const *pwszOut = NULL;	// PROPTYPE_STRING
    CRL_CONTEXT const *pCRL = NULL;
    CERTSRV_COM_CONTEXT *pComContext;

    *pfSystemProperty = FALSE;
    wszRenewalSuffix[0] = L'\0';

    // Allow "PropName.#"
    // Copy the base part of the property name to a local buffer, so we can do
    // case ignore string compares.

    cwcPropName = wcslen(pwszPropName);

    cwcBaseName = wcscspn(pwszPropName, L".");
    if (ARRAYSIZE(wszBaseName) - 1 < cwcBaseName)
    {
	cwcBaseName = ARRAYSIZE(wszBaseName) - 1;
    }

    CopyMemory(wszBaseName, pwszPropName, cwcBaseName * sizeof(WCHAR));
    wszBaseName[cwcBaseName] = L'\0';

    pwszIndex = &pwszPropName[cwcBaseName];
    if (L'.' == *pwszIndex)
    {
	pwszIndex++;
	iCert = _wtol(pwszIndex);
	for ( ; L'\0' != *pwszIndex; pwszIndex++)
	{
	    if (!iswdigit(*pwszIndex))
	    {
		CSASSERT(S_OK == hr);	// Not a system property, return S_OK
		goto error;
	    }
	}
    }

    // Assume property type is a long:

    PropType = PROPTYPE_LONG;
    *pfSystemProperty = TRUE;

    if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPCATYPE))
    {
        pbOut = (BYTE const *) &g_CAType;
        cbOut = sizeof(g_CAType);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPUSEDS))
    {
        pbOut = (BYTE const *) &g_fUseDS;
        cbOut = sizeof(g_fUseDS);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPSERVERUPGRADED))
    {
        pbOut = (BYTE const *) &g_fServerUpgraded;
        cbOut = sizeof(g_fServerUpgraded);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPLOGLEVEL))
    {
        pbOut = (BYTE const *) &g_dwLogLevel;
        cbOut = sizeof(g_dwLogLevel);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPREQUESTERTOKEN))
    {
	hr = ComGetClientInfo(Context, MAXDWORD, &pComContext);
        _JumpIfError(hr, error, "ComGetClientInfo");

	if (NULL == pComContext->hAccessToken ||
	    INVALID_HANDLE_VALUE == pComContext->hAccessToken)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "ComGetClientInfo(bad hAccessToken)");
	}
	pbOut = (BYTE const *) &pComContext->hAccessToken;
	cbOut = sizeof(pComContext->hAccessToken);
        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPREQUESTERCAACCESS))
    {
	hr = ComGetClientInfo(Context, MAXDWORD, &pComContext);
        _JumpIfError(hr, error, "ComGetClientInfo");

	if (MAXDWORD == pComContext->fInRequestGroup)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "ComGetClientInfo(bad fInRequestGroup)");
	}
	pbOut = (BYTE const *) &pComContext->fInRequestGroup;
	cbOut = sizeof(pComContext->fInRequestGroup);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPUSERDN))
    {
	hr = ComGetClientInfo(Context, MAXDWORD, &pComContext);
        _JumpIfError(hr, error, "ComGetClientInfo");

	if (NULL == pComContext->pwszUserDN)
	{
	    if (!g_fUseDS)
	    {
		hr = CERTSRV_E_PROPERTY_EMPTY;
		_JumpError(hr, error, "ComGetClientInfo(bad pwszUserDN)");
	    }
	    hr = CoreSetComContextUserDN(
				pComContext->RequestId,
				Context,
				MAXDWORD,
				&pwszOut);
	    _JumpIfError(hr, error, "CoreSetComContextUserDN");
	}
	pwszOut = pComContext->pwszUserDN;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPCERTCOUNT))
    {
        pbOut = (BYTE const *) &g_cCACerts;
        cbOut = sizeof(g_cCACerts);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPSANITIZEDCANAME))
    {
        pwszOut = g_wszSanitizedName;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPSANITIZEDSHORTNAME))
    {
        pwszOut = g_pwszSanitizedDSName;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPMACHINEDNSNAME))
    {
        pwszOut = g_pwszServerName;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPCONFIGDN))
    {
	pwszOut = g_strConfigDN;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPDOMAINDN))
    {
	pwszOut = g_strDomainDN;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPMODULEREGLOC))
    {
        // future: cache storage location once it is built

        WCHAR *pwszQuasiPath;
        DWORD cwcQuasiPath;
	WCHAR const *pwszPrefix;
        MarshalInterface *pIF;

        if ((PROPCALLER_MASK & Flags) == PROPCALLER_POLICY)
	{
	    pIF = &g_miPolicy;
	    cwcQuasiPath = ARRAYSIZE(L"Policy\\");	// includes L'\0'
	    pwszPrefix = L"Policy\\";
	}
	else
	{
	    hr = ExitGetActiveModule(Context, &pIF);
            _JumpIfError(hr, error, "ExitGetActiveModule");
	    cwcQuasiPath = ARRAYSIZE(L"Exit\\");	// includes L'\0'
	    pwszPrefix = L"Exit\\";
	}

        cwcQuasiPath += wcslen(pIF->GetProgID());
        pwszQuasiPath = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    cwcQuasiPath * sizeof(WCHAR));
        if (NULL == pwszQuasiPath)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(pwszQuasiPath, pwszPrefix);
        wcscat(pwszQuasiPath, pIF->GetProgID()); 

        hr = myRegOpenRelativeKey(
			    pIF->GetConfig(),
			    pwszQuasiPath,
			    RORKF_FULLPATH | RORKF_CREATESUBKEYS,
			    (WCHAR **) &pwszOut,
			    NULL,
			    NULL);
	LocalFree(pwszQuasiPath);
        _JumpIfError(hr, error, "myRegOpenRelativeKey");

	CSASSERT(NULL != pwszOut);
	pbFree = (BYTE *) pwszOut;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPRAWCACERTIFICATE))
    {
        hr = PKCSGetCACert(iCert, const_cast<BYTE **>(&pbOut), &cbOut);	// not alloc'd
        _JumpIfError(hr, error, "PKCSGetCACert");

        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPRAWCRL))
    {
        hr = CRLGetCRL(iCert, FALSE, &pCRL, NULL);
        _JumpIfError(hr, error, "CRLGetCRL");

        cbOut = pCRL->cbCrlEncoded;
        pbOut = pCRL->pbCrlEncoded;
        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPRAWDELTACRL))
    {
        hr = CRLGetCRL(iCert, TRUE, &pCRL, NULL);
        _JumpIfError(hr, error, "CRLGetCRL");

        cbOut = pCRL->cbCrlEncoded;
        pbOut = pCRL->pbCrlEncoded;
        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCERTSTATE))
    {
        hr = PKCSMapCertIndex(iCert, &iCert, &State);
        _JumpIfError(hr, error, "PKCSMapCertIndex");

        pbOut = (BYTE *) &State;
        cbOut = sizeof(State);
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCERTSUFFIX))
    {
        hr = PKCSMapCertIndex(iCert, &iCert, &State);
        _JumpIfError(hr, error, "PKCSMapCertIndex");

        pwszOut = wszRenewalSuffix;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCRLINDEX))
    {
        hr = PKCSMapCRLIndex(iCert, &iCert, &iCRL, &State);
        _JumpIfError(hr, error, "PKCSMapCRLIndex");

        pbOut = (BYTE *) &iCRL;
        cbOut = sizeof(iCRL);
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCRLSTATE))
    {
        hr = PKCSMapCRLIndex(iCert, &iCert, &iCRL, &State);
        _JumpIfError(hr, error, "PKCSMapCRLIndex");

        pbOut = (BYTE *) &State;
        cbOut = sizeof(State);
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCRLSUFFIX))
    {
        hr = PKCSMapCRLIndex(iCert, &iDummy, &iCert, &State);
        _JumpIfError(hr, error, "PKCSMapCRLIndex");

	pwszOut = wszRenewalSuffix;
    }
    else if(PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPTEMPLATECHANGESEQUENCENUMBER))
    {
        pbOut = (BYTE const *) &g_cTemplateUpdateSequenceNum;
        cbOut = sizeof(g_cTemplateUpdateSequenceNum);
    }
    else
    {
        CSASSERT(S_OK == hr);	// Not a system property, return S_OK
	*pfSystemProperty = FALSE;
        goto error;
    }

    CSASSERT((NULL != pbOut) ^ (NULL != pwszOut)); // exactly 1 must be set

    cbCopy = cbOut;
    if (NULL != pwszOut)
    {
	if (wszRenewalSuffix == pwszOut && 0 != iCert)
	{
            wsprintf(wszRenewalSuffix, L"(%u)", iCert);
	}
	PropType = PROPTYPE_STRING;
	cbOut = wcslen(pwszOut) * sizeof(WCHAR);
	cbCopy = cbOut + sizeof(WCHAR);
	pbOut = (BYTE *) pwszOut;
    }

    if ((PROPTYPE_MASK & Flags) != PropType)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad PropType");
    }

    hr = myUnmarshalVariant(
		    PROPMARSHAL_LOCALSTRING | Flags,
		    cbOut,
		    pbOut,
		    pvarPropertyValue);
    _JumpIfError(hr, error, "myUnmarshalVariant");

error:
    if (NULL != pCRL)
    {
        CertFreeCRLContext(pCRL);
    }
    if (NULL != pbFree)
    {
	LocalFree(pbFree);
    }
    return(hr);
}


FNCIGETPROPERTY PropCIGetProperty;

HRESULT
PropCIGetProperty(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DWORD RequestId;
    DWORD cbprop;
    BYTE *pbprop = NULL;
    ICertDBRow *prow = NULL;
    BYTE rgbFastBuf[128];   // many properties are small (128)
    BOOL fSystemProperty;

    if (NULL != pvarPropertyValue)
    {
	VariantInit(pvarPropertyValue);
    }
    if (NULL == pwszPropertyName || NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = E_INVALIDARG;
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY &&
	(PROPCALLER_MASK & Flags) != PROPCALLER_EXIT &&
	(PROPCALLER_MASK & Flags) != PROPCALLER_SERVER)
    {
	_JumpError(hr, error, "Flags: Invalid caller");
    }

    if ((PROPTABLE_MASK & Flags) != PROPTABLE_REQUEST &&
	(PROPTABLE_MASK & Flags) != PROPTABLE_CERTIFICATE &&
	(PROPTABLE_MASK & Flags) != PROPTABLE_ATTRIBUTE)
    {
	_JumpError(hr, error, "Flags: Invalid table");
    }

    fSystemProperty = FALSE;
    if ((PROPTABLE_MASK & Flags) == PROPTABLE_CERTIFICATE)
    {
	hr = ComVerifyRequestContext(TRUE, Flags, Context, &RequestId);
	_JumpIfError(hr, error, "ComVerifyRequestContext");

	// Check for special, hard-coded properties first

	hr = propGetSystemProperty(
			    pwszPropertyName,
			    Flags, 
			    rgbFastBuf,
			    sizeof(rgbFastBuf),
			    Context,
			    &fSystemProperty,
			    pvarPropertyValue);
	_JumpIfError(hr, error, "propGetSystemProperty");
    }

    if (!fSystemProperty)
    {
	DWORD VerifyFlags = Flags;
	
	if (((PROPCALLER_MASK | PROPTABLE_MASK | PROPTYPE_MASK) & Flags) ==
	     (PROPCALLER_SERVER | PROPTABLE_REQUEST | PROPTYPE_LONG) &&
	    0 == lstrcmpi(pwszPropertyName, wszPROPREQUESTREQUESTID))
	{
	    VerifyFlags = PROPCALLER_EXIT | (~PROPCALLER_MASK & VerifyFlags);
	}
	hr = ComVerifyRequestContext(FALSE, VerifyFlags, Context, &RequestId);
	_JumpIfError(hr, error, "ComVerifyRequestContext");

        pbprop = rgbFastBuf;
        cbprop = sizeof(rgbFastBuf);

	// PROPCALLER_SERVER indicates this call is only for Context validation
	// -- return a zero RequestId.  This keeps CRL publication exit module
	// notification from failing.

	if (0 == RequestId &&
	    ((PROPCALLER_MASK | PROPTABLE_MASK | PROPTYPE_MASK) & Flags) ==
	     (PROPCALLER_SERVER | PROPTABLE_REQUEST | PROPTYPE_LONG) &&
	    0 == lstrcmpi(pwszPropertyName, wszPROPREQUESTREQUESTID))
	{
	    *(DWORD *) pbprop = 0;
	    cbprop = sizeof(DWORD);
	}
	else
	{
	    hr = g_pCertDB->OpenRow(
				PROPOPEN_READONLY | PROPTABLE_REQCERT,
				RequestId,
				NULL,
				&prow);
	    _JumpIfError(hr, error, "OpenRow");

	    hr = prow->GetProperty(
			    pwszPropertyName,
			    Flags,
			    &cbprop,
			    pbprop);
	    if (S_OK != hr)
	    {
		if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
		{
		    _JumpIfError2(
			    hr,
			    error,
			    "GetProperty",
			    CERTSRV_E_PROPERTY_EMPTY);
		}
		
		CSASSERT(ARRAYSIZE(rgbFastBuf) < cbprop);

		DBGPRINT((
		    DBG_SS_CERTSRVI,
		    "FastBuf miss: PropCIGetProperty - pbprop %i bytes\n",
		    cbprop));

		pbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
		if (NULL == pbprop)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		
		hr = prow->GetProperty(
				pwszPropertyName,
				Flags,
				&cbprop,
				pbprop);
		_JumpIfError(hr, error, "GetProperty");
	    }
        } // property is in-hand

        hr = myUnmarshalVariant(
		        PROPMARSHAL_LOCALSTRING | Flags,
		        cbprop,
		        pbprop,
		        pvarPropertyValue);
        _JumpIfError(hr, error, "myUnmarshalVariant");
    }

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbprop && pbprop != rgbFastBuf)
    {
    	LocalFree(pbprop);
    }
    return(myHError(hr));
}


HRESULT
propSetSystemProperty(
    IN WCHAR const *pwszPropName,
    IN DWORD Flags, 
    OUT BOOL *pfSystemProperty,
    IN VARIANT const *pvarPropertyValue)
{
    HRESULT hr = S_OK;
    DWORD cbprop;
    BYTE *pbprop = NULL;
    DWORD LogLevel = MAXDWORD;
    DWORD infotype = EVENTLOG_INFORMATION_TYPE;
    DWORD LogMsg = MSG_POLICY_LOG_INFORMATION;

    *pfSystemProperty = FALSE;

    if (0 == lstrcmpi(pwszPropName, wszPROPEVENTLOGTERSE))
    {
	LogLevel = CERTLOG_TERSE;
    }
    else
    if (0 == lstrcmpi(pwszPropName, wszPROPEVENTLOGERROR))
    {
	LogLevel = CERTLOG_ERROR;
	infotype = EVENTLOG_ERROR_TYPE;
	LogMsg = MSG_POLICY_LOG_ERROR;
    }
    else
    if (0 == lstrcmpi(pwszPropName, wszPROPEVENTLOGWARNING))
    {
	LogLevel = CERTLOG_WARNING;
	infotype = EVENTLOG_WARNING_TYPE;
	LogMsg = MSG_POLICY_LOG_WARNING;
    }
    else
    if (0 == lstrcmpi(pwszPropName, wszPROPEVENTLOGVERBOSE))
    {
	LogLevel = CERTLOG_VERBOSE;
    }
    else
    {
        CSASSERT(S_OK == hr);	// Not a system property, return S_OK
        goto error;
    }
    *pfSystemProperty = TRUE;

    if (PROPTYPE_STRING != (PROPTYPE_MASK & Flags) ||
	VT_BSTR != pvarPropertyValue->vt ||
	NULL == pvarPropertyValue->bstrVal)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "string property value/type", pwszPropName);
    }

    CSASSERT(MAXDWORD != LogLevel);
    if (LogLevel <= g_dwLogLevel)
    {
	WCHAR const *apwsz[2];

	apwsz[0] = g_strPolicyDescription;
	apwsz[1] = pvarPropertyValue->bstrVal;

	hr = LogEvent(infotype, LogMsg, ARRAYSIZE(apwsz), apwsz);
	_JumpIfError(hr, error, "LogEvent");
    }
    hr = S_OK;

error:
    return(myHError(hr));
}


FNCISETPROPERTY PropCISetProperty;

HRESULT
PropCISetProperty(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN VARIANT const *pvarPropertyValue)
{
    HRESULT hr;
    DWORD RequestId;
    DWORD cbprop;
    BYTE *pbprop = NULL;
    ICertDBRow *prow = NULL;
    BOOL fSubjectDot = FALSE;
    BOOL fSystemProperty;
    BOOL fCommitted = FALSE;
    
    if (NULL == pwszPropertyName || NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = E_INVALIDARG;
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY)
    {
	_JumpError(hr, error, "Flags: Invalid caller");
    }
    if ((PROPTABLE_MASK & Flags) != PROPTABLE_CERTIFICATE)
    {
	_JumpError(hr, error, "Flags: Invalid table");
    }

    hr = ComVerifyRequestContext(TRUE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    // Check for special, hard-coded properties first

    fSystemProperty = FALSE;
    hr = propSetSystemProperty(
			pwszPropertyName,
			Flags, 
			&fSystemProperty,
			pvarPropertyValue);
    _JumpIfError(hr, error, "propGetSystemProperty");

    if (!fSystemProperty)
    {
	hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
	_JumpIfError(hr, error, "ComVerifyRequestContext");

	hr = myMarshalVariant(
			pvarPropertyValue,
			PROPMARSHAL_NULLBSTROK | PROPMARSHAL_LOCALSTRING | Flags,
			&cbprop,
			&pbprop);
	_JumpIfError(hr, error, "myMarshalVariant");

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, RequestId, NULL, &prow);
	_JumpIfError(hr, error, "OpenRow");

	if (PROPTYPE_DATE == (PROPTYPE_MASK & Flags))
	{
	    hr = propVerifyDateRange(
				prow,
				Flags,
				pwszPropertyName,
				(FILETIME *) pbprop);
	    _JumpIfError(hr, error, "propVerifyDateRange");
	}
	else
	if (PROPTYPE_STRING == (PROPTYPE_MASK & Flags) &&
	    PROPTABLE_CERTIFICATE == (PROPTABLE_MASK & Flags))
	{
	    hr = PKCSVerifySubjectRDN(
				prow,
				pwszPropertyName,
				(WCHAR const *) pbprop,
				&fSubjectDot);
	    _JumpIfError(hr, error, "PKCSVerifySubjectRDN");
	}

	if (NULL == pbprop && fSubjectDot)
	{
	    hr = PKCSDeleteAllSubjectRDNs(prow, Flags);
	    _JumpIfError(hr, error, "PKCSDeleteAllSubjectRDNs");
	}
	else
	{
	    hr = prow->SetProperty(pwszPropertyName, Flags, cbprop, pbprop);
	    _JumpIfError(hr, error, "SetProperty");
	}

	hr = prow->CommitTransaction(TRUE);
	_JumpIfError(hr, error, "CommitTransaction");

	fCommitted = TRUE;
    }
    hr = S_OK;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pbprop)
    {
	LocalFree(pbprop);
    }
    return(myHError(hr));
}


HRESULT
PropGetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue)    // LocalAlloc
{
    HRESULT hr;
    DWORD cbprop;
    BYTE *pbprop = NULL;

    CSASSERT(
	PROPCALLER_EXIT == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_POLICY == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_SERVER == (PROPCALLER_MASK & Flags));

    CSASSERT(0 == (~(PROPCALLER_MASK | PROPTYPE_MASK) & Flags));

    hr = myVerifyObjId(pwszExtensionName);
    _JumpIfError(hr, error, "myVerifyObjId");

    cbprop = 0;
    hr = prow->GetExtension(pwszExtensionName, pdwExtFlags, &cbprop, NULL);
    _JumpIfError2(hr, error, "GetExtension(NULL)", CERTSRV_E_PROPERTY_EMPTY);

    pbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
    if (NULL == pbprop)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc(ExtValue)");
    }

    hr = prow->GetExtension(pwszExtensionName, pdwExtFlags, &cbprop, pbprop);
    _JumpIfError(hr, error, "GetExtension");

    if (PROPTYPE_BINARY == (PROPTYPE_MASK & Flags))
    {
	*pcbValue = cbprop;
	*ppbValue = pbprop;
	pbprop = NULL;
    }
    else
    {
	hr = myDecodeExtension(Flags, pbprop, cbprop, ppbValue, pcbValue);
	_JumpIfError(hr, error, "myDecodeExtension");
    }

error:
    if (NULL != pbprop)
    {
	LocalFree(pbprop);
    }
    return(myHError(hr));
}


HRESULT
PropSetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue)
{
    HRESULT hr;
    DWORD cbprop;
    BYTE *pbprop = NULL;

    CSASSERT(
	PROPCALLER_ADMIN == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_POLICY == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_SERVER == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_REQUEST == (PROPCALLER_MASK & Flags));

    CSASSERT(0 == (~(PROPCALLER_MASK | PROPTYPE_MASK) & Flags));

    hr = myVerifyObjId(pwszExtensionName);
    _JumpIfError(hr, error, "myVerifyObjId");

    if (PROPTYPE_BINARY == (PROPTYPE_MASK & Flags))
    {
	cbprop = cbValue;
	pbprop = (BYTE *) pbValue;
    }
    else
    {
	hr = myEncodeExtension(Flags, pbValue, cbValue, &pbprop, &cbprop);
	_JumpIfError(hr, error, "myEncodeExtension");
    }

    hr = prow->SetExtension(pwszExtensionName, ExtFlags, cbprop, pbprop);
    _JumpIfError(hr, error, "SetExtension");

error:
    if (NULL != pbprop && pbprop != pbValue)
    {
	LocalFree(pbprop);
    }
    return(hr);
}


FNCIGETEXTENSION PropCIGetExtension;

HRESULT
PropCIGetExtension(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT VARIANT *pvarValue)
{
    HRESULT hr;
    DWORD RequestId;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    ICertDBRow *prow = NULL;

    if (NULL != pvarValue)
    {
	VariantInit(pvarValue);
    }
    if (NULL == pwszExtensionName || NULL == pdwExtFlags || NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = g_pCertDB->OpenRow(PROPOPEN_READONLY | PROPTABLE_REQCERT, RequestId, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PropGetExtension(
		    prow,
		    Flags,
		    pwszExtensionName,
		    pdwExtFlags,
		    &cbValue,
		    &pbValue);
    _JumpIfError2(hr, error, "PropGetExtension", CERTSRV_E_PROPERTY_EMPTY);

    hr = myUnmarshalVariant(
		    PROPMARSHAL_LOCALSTRING | Flags,
		    cbValue,
		    pbValue,
		    pvarValue);
    _JumpIfError(hr, error, "myUnmarshalVariant");

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    return(hr);
}


FNCISETPROPERTY PropCISetExtension;

HRESULT
PropCISetExtension(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN VARIANT const *pvarValue)
{
    HRESULT hr;
    DWORD RequestId;
    DWORD cbprop;
    BYTE *pbprop = NULL;
    ICertDBRow *prow = NULL;
    BOOL fCommitted = FALSE;
    
    if (NULL == pwszExtensionName || NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags: Invalid caller");
    }
    hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = myMarshalVariant(
		    pvarValue,
		    PROPMARSHAL_LOCALSTRING | Flags,
		    &cbprop,
		    &pbprop);
    _JumpIfError(hr, error, "myMarshalVariant");

    hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, RequestId, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PropSetExtension(
		    prow,
		    Flags,
		    pwszExtensionName,
		    ExtFlags,
		    cbprop,
		    pbprop);
    _JumpIfError(hr, error, "PropSetExtension");

    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pbprop)
    {
	LocalFree(pbprop);
    }
    return(myHError(hr));
}


FNCIENUMSETUP PropCIEnumSetup;

HRESULT
PropCIEnumSetup(
    IN LONG Context,
    IN LONG Flags,
    IN OUT CIENUM *pciEnum)
{
    HRESULT hr;
    DWORD RequestId;
    
    CSASSERT(CIE_CALLER_POLICY == PROPCALLER_POLICY);
    CSASSERT(CIE_CALLER_EXIT == PROPCALLER_EXIT);
    CSASSERT(CIE_CALLER_MASK == PROPCALLER_MASK);
    
    hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = pciEnum->EnumSetup(RequestId, Context, Flags);
    _JumpIfError(hr, error, "EnumSetup");

error:
    return(hr);
}


FNCIENUMNEXT PropCIEnumNext;

HRESULT
PropCIEnumNext(
    IN OUT CIENUM *pciEnum,
    OUT BSTR *pstrPropertyName)
{
    HRESULT hr;
    DWORD RequestId;

    CSASSERT(CIE_CALLER_POLICY == PROPCALLER_POLICY);
    CSASSERT(CIE_CALLER_EXIT == PROPCALLER_EXIT);
    CSASSERT(CIE_CALLER_MASK == PROPCALLER_MASK);
    
    hr = ComVerifyRequestContext(
			    FALSE,
			    pciEnum->GetFlags(),
			    pciEnum->GetContext(),
			    &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = pciEnum->EnumNext(pstrPropertyName);
    _JumpIfError2(hr, error, "EnumNext", S_FALSE);

error:
    return(hr);
}


FNCIENUMCLOSE PropCIEnumClose;

HRESULT
PropCIEnumClose(
    IN OUT CIENUM *pciEnum)
{
    HRESULT hr;
    
    hr = pciEnum->EnumClose();
    _JumpIfError(hr, error, "EnumClose");

error:
    return(hr);
}


HRESULT
PropSetAttributeProperty(
    IN ICertDBRow *prow,
    IN BOOL fConcatenateRDNs,
    IN DWORD dwTable,
    IN DWORD cwcNameMax,
    OPTIONAL IN WCHAR const *pwszSuffix,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValue)
{
    HRESULT hr = S_OK;
    WCHAR *pwszTemp = NULL;
    WCHAR const *pwszValue2 = pwszValue;
    DWORD cbProp;
    DWORD dwFlags = dwTable | PROPTYPE_STRING | PROPCALLER_SERVER;

    CSASSERT(
	PROPTABLE_ATTRIBUTE == dwTable ||
	PROPTABLE_REQUEST == dwTable ||
	PROPTABLE_CERTIFICATE == dwTable);


    // if the name and value are both non-empty ...

    if (NULL != pwszName && L'\0' != *pwszName &&
	NULL != pwszValue && L'\0' != *pwszValue)
    {
	if (PROPTABLE_ATTRIBUTE != dwTable)
	{
	    if (g_fEnforceRDNNameLengths && wcslen(pwszValue) > cwcNameMax)
	    {
		hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "RDN component too long: %u/%u: %ws=\"%ws\"\n",
		    wcslen(pwszValue),
		    cwcNameMax,
		    pwszName,
		    pwszValue));
		_JumpErrorStr(hr, error, "RDN component too long", pwszValue);
	    }
	    if (fConcatenateRDNs)
	    {
		cbProp = 0;
		hr = prow->GetProperty(pwszName, dwFlags, &cbProp, NULL);
		if (CERTSRV_E_PROPERTY_EMPTY != hr)
		{
		    _JumpIfError(hr, error, "GetProperty");

                    // cbProp includes trailing L'\0' when out buffer is NULL

		    pwszTemp = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    cbProp + sizeof(WCHAR) * (1 + wcslen(pwszValue)));
		    if (NULL == pwszTemp)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }

		    hr = prow->GetProperty(
				    pwszName,
				    dwFlags,
				    &cbProp,
				    (BYTE *) pwszTemp);
		    _JumpIfError(hr, error, "GetProperty");

                    // If there are multiple RDN components for the same DB
                    // column, concatenate them even if the feature is disabled.

		    wcscat(pwszTemp, wszNAMESEPARATORDEFAULT);
		    wcscat(pwszTemp, pwszValue);
		    pwszValue2 = pwszTemp;

                    // cbProp now does NOT include trailing L'\0'
                    CSASSERT(
			sizeof(WCHAR) * wcslen(pwszTemp) ==
			cbProp + sizeof(WCHAR) * (1 + wcslen(pwszValue)));
		}
	    }
	    else if (NULL != pwszSuffix)
	    {
		hr = myAddNameSuffix(
				pwszValue,
				pwszSuffix,
				cwcNameMax,
				&pwszTemp);
		_JumpIfError(hr, error, "myAddNameSuffix");
		
		pwszValue2 = pwszTemp;
	    }
	}
	hr = prow->SetProperty(
			pwszName,
			dwFlags,
			MAXDWORD,
			(BYTE const *) pwszValue2);
	_JumpIfError(hr, error, "SetProperty");
    }

error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_DENIEDBY),
    RESSTR(IDS_POLICYDENIED),
    RESSTR(IDS_ISSUED),
    RESSTR(IDS_UNDERSUBMISSION),
    RESSTR(IDS_REVOKEDBY),
    RESSTR(IDS_PRINTFCERTREQUESTDISPOSITION),
    RESSTR(IDS_USAGE),
    RESSTR(IDS_REQUESTPROCESSERROR),
    RESSTR(IDS_RESUBMITTEDBY),
    RESSTR(IDS_USAGE_FULL),
    RESSTR(IDS_USAGE_COMTEST),
    RESSTR(IDS_UNKNOWNSUBJECT),
    RESSTR(IDS_UNREVOKEDBY),
    RESSTR(IDS_REQUESTEDBY),
    RESSTR(IDS_INTERMEDIATECASTORE),
    RESSTR(IDS_PUBLISHERROR),
    RESSTR(IDS_PUBLISHEDBY),
    RESSTR(IDS_REQUESTPARSEERROR),
    RESSTR(IDS_YES),
    RESSTR(IDS_NO),
    RESSTR(IDS_ALLOW),
    RESSTR(IDS_DENY),
    RESSTR(IDS_CAADMIN),
    RESSTR(IDS_OFFICER),
    RESSTR(IDS_READ),
    RESSTR(IDS_ENROLL),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\request.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.h
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

// class definition
// Request Interface
class CCertRequestD : public ICertRequestD2
{
public:
    // IUnknown

    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // ICertRequestD

    virtual STDMETHODIMP Request(
	IN     DWORD                dwFlags,
	IN     wchar_t const       *pwszAuthority,
	IN OUT DWORD               *pdwRequestId,
	OUT    DWORD               *pdwDisposition,
	IN     wchar_t const       *pwszAttributes,
	IN     CERTTRANSBLOB const *pctbRequest,
	OUT    CERTTRANSBLOB       *pctbCertChain,
	OUT    CERTTRANSBLOB       *pctbEncodedCert,
	OUT    CERTTRANSBLOB       *pctbDispositionMessage);

    virtual STDMETHODIMP GetCACert(
	IN  DWORD          Flags,
	IN  wchar_t const *pwszAuthority,
	OUT CERTTRANSBLOB *pctbOut);

    virtual STDMETHODIMP Ping(	// test function
			wchar_t const *pwszAuthority);

    // ICertRequestD2

    virtual STDMETHODIMP Request2( 
	IN     wchar_t const       *pwszAuthority,
	IN     DWORD                dwFlags,
	IN     wchar_t const       *pwszSerialNumber,
	IN OUT DWORD               *pdwRequestId,
	OUT    DWORD               *pdwDisposition,
	IN     wchar_t const       *pwszAttributes,
	IN     CERTTRANSBLOB const *pctbRequest,
	OUT    CERTTRANSBLOB       *pctbFullResponse,
	OUT    CERTTRANSBLOB       *pctbEncodedCert,
	OUT    CERTTRANSBLOB       *pctbDispositionMessage);

    virtual STDMETHODIMP GetCAProperty(
	IN  wchar_t const *pwszAuthority,
	IN  LONG           PropId,	// CR_PROP_*
	IN  LONG           PropIndex,
	IN  LONG           PropType,	// PROPTYPE_*
	OUT CERTTRANSBLOB *pctbPropertyValue);

    virtual STDMETHODIMP GetCAPropertyInfo(
	IN  wchar_t const *pwszAuthority,
	OUT LONG          *pcProperty,
	OUT CERTTRANSBLOB *pctbPropInfo);

    virtual STDMETHODIMP Ping2( 
	IN     wchar_t const *pwszAuthority);
    
    // CCertRequestD

    // Constructor
    CCertRequestD();

    // Destructor
    ~CCertRequestD();

private:
    // this is a test function
    HRESULT _Ping(
        IN wchar_t const *pwszAuthority);

    HRESULT _Request( 
	IN          WCHAR const            *pwszAuthority,
	IN          DWORD                   dwFlags,
	OPTIONAL IN WCHAR const            *pwszSerialNumber,
	IN          DWORD                   dwRequestId,
	OPTIONAL IN WCHAR const            *pwszAttributes,
	OPTIONAL IN CERTTRANSBLOB const    *pctbRequest,
	OUT         CERTSRV_RESULT_CONTEXT *pResult);

private:
    // Reference count
    long m_cRef;
};


// Class of Request factory
class CRequestFactory : public IClassFactory
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // Interface IClassFactory
    virtual STDMETHODIMP CreateInstance(
				    IUnknown *pUnknownOuter,
				    const IID& iid,
				    void **ppv);

    virtual STDMETHODIMP LockServer(BOOL bLock);

    // Constructor
    CRequestFactory() : m_cRef(1) { }

    // Destructor
    ~CRequestFactory() { }

public:
    static HRESULT CanUnloadNow();
    static HRESULT StartFactory();
    static void    StopFactory();

private:
    long m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\pkcs.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pkcs.cpp
//
// Contents:    Cert Server Extension interfaces -- PKCS implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <time.h>

#define SECURITY_WIN32
#include <security.h>

#include "resource.h"
#include "cscom.h"
#include "csprop.h"
#include "elog.h"
#include "certlog.h"
#include "csdisp.h"
#include "cscsp.h"
#include <certca.h>
#include <esent.h>

#include <winldap.h>
#include "csldap.h"
#include "cainfop.h"

#define __dwFILE__	__dwFILE_CERTSRV_PKCS_CPP_

CSURLTEMPLATE *g_paRevURL = NULL;
DWORD g_caRevURL = 0;

CSURLTEMPLATE *g_paCACertURL = NULL;
DWORD g_caCACertURL = 0;

BSTR g_strDomainDN = NULL;
BSTR g_strConfigDN = NULL;

WCHAR *g_pwszKRAPublishURL = NULL;
WCHAR *g_pwszAIACrossCertPublishURL = NULL;
WCHAR *g_pwszRootTrustCrossCertPublishURL = NULL;


// Note on Renewal and Key reuse:
//
// Cert Indexes, Key Indexes and CRL Name Indexes are all zero based.
//
// One CRL is issued by this CA for each unique key.  Each CRL covers all of
// the certs issued by this CA for one key, even though the key may have been
// used by multiple renewal certs.
//
// The database IssuerNameID PROPTYPE_LONG column holds the Key Index in the
// top 16 bits and the Cert Index in the bottom 16 bits.  This allows a pair of
// query restrictions to reduce the result row set to those revoked certs
// that will be placed into a single CRL.
//
// When Cert File, Key Container, CRL File or DS Object name templates include
// an Index Suffix, an empty string suffix, "", is used when the index is zero.
// Otherwise the Suffix is "(%u)", where the index itself is passed to wsprintf
// to construct the %u field.
//
// Cert Indexes increment each time the CA cert is renewed.  Because 16 bit
// Cert Indexes are stored in the database, a CA may have up to 64k certs,
// and be renewed a maximum of 64k-1 times.
//
// The Cert File Name Suffix is built from the Cert Index.
//
// Key Indexes:  The original installed CA cert uses a Key Index of 0.
// If a renewal cert uses the same key as any previous cert used by this CA,
// the Key Index for the new CA cert is taken from the previous CA cert.
// If a renewal cert uses a new Key, the Cert Index is used for the Key Index.
// The primary reason sequential Key Indexes are not used for new keys is that
// too much context information is required to determine the next Key Index --
// which is particularly difficult to obtain when performing PFX restore.
//
// The Key Container Name Suffix is built from the Key Index.
//
//
// CRL Indexes:  same as Key Index.
// CRL File Name Suffix:  same as Key Container Name Suffix.
//
// Example:		Cert   CertName	Key	KeyName	CRL	CRLName
//			Index	Suffix	Index	Suffix	Index	Suffix
// Original Install	0	""	0	""	0	""
//
// Renew, new Key	1	"(1)"	1	"(1)"	1	"(1)"
// *Renew, reuse Key	2	"(2)"	1	"(1)"	1	"(1)"
// *Renew, reuse Key	3	"(3)"	1	"(1)"	1	"(1)"
//
// Renew, new Key	4	"(4)"	4	"(4)"	4	"(4)"
// *Renew, reuse Key	5	"(5)"	4	"(4)"	4	"(4)"
//
// Renew, new Key	6	"(6)"	6	"(6)"	6	"(6)"
// *Renew, reuse Key	7	"(7)"	6	"(6)"	6	"(6)"
//
//
// CCertRequest::GetCACertificate can be used to fetch Certs and CRLs by Index.
// This API always accepts a Cert Index.
//
// When fetching a certificate:  If the Cert Index is valid, the appropriate
// certificate or chain is returned, even if it is expired or revoked.
//
// When fetching a CRL:  If the Cert Index is valid AND if the Cert Index
// MATCHES the Key Index for the indexed Cert, the appropriate CRL is returned.
// This means that an error will be returned when requesting CRLs associated
// with entries in the above table that reused keys (marked with an asterisk
// in the first column).  The nearest previous unmarked entry's CRL covers
// revocations for the marked entries.
//
//
// CCertServer{Policy,Exit}::GetCertificateProperty can be used to fetch
// information about Certs and CRLs.  This API allows an optional numeric
// suffix on the property name, as in "RawCRL.3".  The suffix is always
// interpreted as a Cert Index.
//
// wszPROPCERTCOUNT:  Returns total CA Cert count, including expired and
// revoked certs.  No numeric Cert Index suffix is allowed.
//
// wszPROPRAWCACERTIFICATE:  Returns the Cert for the passed Cert Index.
// Returns the Cert for the most recent Cert Index if no Cert Index is
// specified.  Expired and revoked certs are still retrievable.
//
// wszPROPCERTSTATE:  Returns the Cert State for the passed Cert Index.
// Returns the Cert State for the most recent Cert Index if no Cert Index is
// specified.
// Values for wszPROPCERTSTATE (see certadm.h):
//   CA_DISP_REVOKED    // This Cert has been revoked.
//   CA_DISP_VALID      // This Cert is still valid
//   CA_DISP_INVALID    // This Cert has expired.
//   CA_DISP_ERROR      // Cert unavailable (placehholder in registry?)
//
// wszPROPCERTSUFFIX: Returns the Cert FileName Suffix for the passed Cert
// Index.  Returns the Cert FileName Suffix for the most recent Cert Index if
// no Cert Index is specified.
//
// wszPROPRAWCRL:  Returns the CRL for the passed Cert Index.  As with
// CCertRequest::GetCACertificate, it is an error to fetch a CRL for a Cert
// that reused keys.  In the above table, only "RawCRL.0", "RawCRL.1",
// "RawCRL.4", "RawCRL.6" & "RawCRL" are allowed.  "RawCRL" will fetch the most
// recent CRL.  Use the wszPROPCRLSTATE with a numeric Cert Index suffix to
// determine which CRLs are valid to fetch.  CA_DISP_ERROR indicates the
// CRL cannot be fetched.  CA_DISP_REVOKED and CA_DISP_INVALID CRLs are still
// retrievable via this method call.
//
// All of the other CRL-related property fetches are supported for all valid
// Cert Index values:
//
// wszPROPCRLINDEX:  Returns the CRL Index value for the passed Cert Index.
// Returns the CRL Index value for the most recent Cert Index if no Cert Index
// is specified.
//
// wszPROPCRLSTATE:  Returns the CRL State for the passed Cert Index.
// Returns the CRL State for the most recent Cert Index if no Cert Index is
// specified.
// Values for wszPROPCRLSTATE (see certadm.h):
//   CA_DISP_REVOKED    // All unexpired certs using this Cert's CRL have been
//                      // revoked.
//   CA_DISP_VALID      // This Cert is still publishing CRLs as needed.
//   CA_DISP_INVALID    // All certs using this Cert's CRL are expired.
//   CA_DISP_ERROR      // This Cert's CRL is managed by another Cert.
//
// wszPROPCRLSUFFIX: Returns the CRL FileName Suffix for the passed Cert Index.
// Returns the CRL FileName Suffix for the most recent Cert Index if no Cert
// Index is specified.


CACTX *g_aCAContext;		// allocated array of CACTXs
CACTX *g_pCAContextCurrent;	// current CACTX is last g_aCAContext element
CERT_CONTEXT const **g_rgKRACerts = NULL;
BSTR *g_rgstrKRAHashes = NULL;
DWORD g_cKRAHashes = 0;
DWORD g_cKRACertsRoundRobin = 0;
DWORD g_iKRACerts;  // Next KRA cert to be used by this CA
HRESULT g_hrKRALoad = S_OK;

DWORD g_cCAKeys;    // Total number of unique CA keys managed by this CA
DWORD g_cCACerts;   // Total number of CA certs managed by this CA
DWORD g_cKRACerts;  // Total number of KRA certs used by this CA

CAXCHGCTX *g_aCAXchgContext;	// allocated array of CAXCHGCTXs
CAXCHGCTX *g_pCAXchgContextCurrent;	// current CAXCHGCTX is last element
DWORD g_cCAXchgCerts;		// number of CA Xchg certs managed by this CA
HCERTSTORE g_hStoreCAXchg = NULL;
DWORD g_dwXchgProvType;
WCHAR *g_pwszXchgProvName = NULL;
ALG_ID g_XchgidAlg;
BOOL g_fXchgMachineKeyset;
DWORD g_dwXchgKeySize;

LONG g_lValidityPeriodCount = dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE;
enum ENUM_PERIOD g_enumValidityPeriod = dwVALIDITYPERIODENUMDEFAULT;

enum ENUM_PERIOD g_enumCAXchgValidityPeriod = dwCAXCHGVALIDITYPERIODENUMDEFAULT;
LONG g_lCAXchgValidityPeriodCount = dwCAXCHGVALIDITYPERIODCOUNTDEFAULT;

enum ENUM_PERIOD g_enumCAXchgOverlapPeriod = dwCAXCHGOVERLAPPERIODENUMDEFAULT;
LONG g_lCAXchgOverlapPeriodCount = dwCAXCHGOVERLAPPERIODCOUNTDEFAULT;

typedef enum {
    ST_COUNTRY = 0,
    ST_ORGANIZATION,
    ST_ORGANIZATIONALUNIT,
    ST_COMMONNAME,
    ST_LOCALITY,
    ST_STATEORPROVINCE,
    ST_TITLE,
    ST_GIVENNAME,
    ST_INITIALS,
    ST_SURNAME,
    ST_DOMAINCOMPONENT,
    ST_EMAIL,
    ST_STREETADDRESS,
    ST_UNSTRUCTUREDNAME,
    ST_UNSTRUCTUREDADDRESS,
    ST_DEVICESERIALNUMBER,
    ST_NULL
};

typedef struct _SUBJECTTABLE
{
    WCHAR const         *pwszPropName;
    CHAR const          *pszObjId;
    WCHAR const * const *apwszAttributeName;
    DWORD                cchMax;
    DWORD                dwValueType;
    DWORD                dwSubjectTableValue;
} SUBJECTTABLE;


WCHAR const *apwszAttrCountry[] = {
    wszATTRCOUNTRY1,
    wszATTRCOUNTRY2,
    TEXT(szOID_COUNTRY_NAME),
    NULL
};

WCHAR const *apwszAttrOrg[] = {
    wszATTRORG1,
    wszATTRORG2,
    wszATTRORG3,
    TEXT(szOID_ORGANIZATION_NAME),
    NULL
};

WCHAR const *apwszAttrOrgUnit[] = {
    wszATTRORGUNIT1,
    wszATTRORGUNIT2,
    wszATTRORGUNIT3,
    wszATTRORGUNIT4,
    TEXT(szOID_ORGANIZATIONAL_UNIT_NAME),
    NULL
};

WCHAR const *apwszAttrCommonName[] = {
    wszATTRCOMMONNAME1,
    wszATTRCOMMONNAME2,
    TEXT(szOID_COMMON_NAME),
    NULL
};

WCHAR const *apwszAttrLocality[] = {
    wszATTRLOCALITY1,
    wszATTRLOCALITY2,
    TEXT(szOID_LOCALITY_NAME),
    NULL
};

WCHAR const *apwszAttrState[] = {
    wszATTRSTATE1,
    wszATTRSTATE2,
    wszATTRSTATE3,
    TEXT(szOID_STATE_OR_PROVINCE_NAME),
    NULL
};

WCHAR const *apwszAttrTitle[] = {
    wszATTRTITLE1,
    wszATTRTITLE2,
    TEXT(szOID_TITLE),
    NULL
};

WCHAR const *apwszAttrGivenName[] = {
    wszATTRGIVENNAME1,
    wszATTRGIVENNAME2,
    TEXT(szOID_GIVEN_NAME),
    NULL
};

WCHAR const *apwszAttrInitials[] = {
    wszATTRINITIALS1,
    wszATTRINITIALS2,
    TEXT(szOID_INITIALS),
    NULL
};

WCHAR const *apwszAttrSurName[] = {
    wszATTRSURNAME1,
    wszATTRSURNAME2,
    TEXT(szOID_SUR_NAME),
    NULL
};

WCHAR const *apwszAttrDomComp[] = {
    wszATTRDOMAINCOMPONENT1,
    wszATTRDOMAINCOMPONENT2,
    TEXT(szOID_DOMAIN_COMPONENT),
    NULL
};

WCHAR const *apwszAttrEMail[] = {
    wszATTREMAIL1,
    wszATTREMAIL2,
    TEXT(szOID_RSA_emailAddr),
    NULL
};

WCHAR const *apwszAttrStreetAddr[] = {
    wszATTRSTREETADDRESS1,
    wszATTRSTREETADDRESS2,
    TEXT(szOID_STREET_ADDRESS),
    NULL
};

WCHAR const *apwszAttrUnstructName[] = {
    wszATTRUNSTRUCTUREDNAME1,
    TEXT(szOID_RSA_unstructName),
    NULL
};

WCHAR const *apwszAttrUnstructAddr[] = {
    wszATTRUNSTRUCTUREDADDRESS1,
    TEXT(szOID_RSA_unstructAddr),
    NULL
};

WCHAR const *apwszAttrDeviceSerialNumber[] = {
    wszATTRDEVICESERIALNUMBER1,
    TEXT(szOID_DEVICE_SERIAL_NUMBER),
    NULL
};


SUBJECTTABLE const pkcs_subject[] =
{
    {
        // "Country",
	g_wszPropSubjectCountry,
        szOID_COUNTRY_NAME,
	apwszAttrCountry,
	cchCOUNTRYNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_COUNTRY,
    },
    {
        // "Organization",
	g_wszPropSubjectOrganization,
        szOID_ORGANIZATION_NAME,
	apwszAttrOrg,
	cchORGANIZATIONNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_ORGANIZATION,
    },
    {
        // "OrganizationalUnit",
	g_wszPropSubjectOrgUnit,
        szOID_ORGANIZATIONAL_UNIT_NAME,
	apwszAttrOrgUnit,
	cchORGANIZATIONALUNITNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_ORGANIZATIONALUNIT,
    },
    {
        // "CommonName",
	g_wszPropSubjectCommonName,
        szOID_COMMON_NAME,
	apwszAttrCommonName,
	cchCOMMONNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_COMMONNAME,
    },
    {
        // "Locality",
	g_wszPropSubjectLocality,
        szOID_LOCALITY_NAME,
	apwszAttrLocality,
	cchLOCALITYMANAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_LOCALITY,
    },
    {
        // "StateOrProvince",
	g_wszPropSubjectState,
        szOID_STATE_OR_PROVINCE_NAME,
	apwszAttrState,
	cchSTATEORPROVINCENAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_STATEORPROVINCE,
    },
    {
        // "Title",
        g_wszPropSubjectTitle,
        szOID_TITLE,
	apwszAttrTitle,
	cchTITLEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_TITLE,
    },
    {
        // "GivenName",
        g_wszPropSubjectGivenName,
        szOID_GIVEN_NAME,
	apwszAttrGivenName,
	cchGIVENNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_GIVENNAME,
    },
    {
        // "Initials",
        g_wszPropSubjectInitials,
        szOID_INITIALS,
	apwszAttrInitials,
	cchINITIALSMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_INITIALS,
    },
    {
        // "SurName",
        g_wszPropSubjectSurName,
        szOID_SUR_NAME,
	apwszAttrSurName,
	cchSURNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_SURNAME,
    },
    {
        // "DomainComponent",
	g_wszPropSubjectDomainComponent,
        szOID_DOMAIN_COMPONENT,
	apwszAttrDomComp,
	cchDOMAINCOMPONENTMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_DOMAINCOMPONENT,
    },
    {
        // "EMail",
	g_wszPropSubjectEMail,
        szOID_RSA_emailAddr,
	apwszAttrEMail,
	cchEMAILMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_EMAIL,
    },
    {
        // "StreetAddress",
	g_wszPropSubjectStreetAddress,
        szOID_STREET_ADDRESS,
	apwszAttrStreetAddr,
	cchSTREETADDRESSMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_STREETADDRESS,
    },
    {
        // "UnstructuredName",
	g_wszPropSubjectUnstructuredName,
        szOID_RSA_unstructName,
	apwszAttrUnstructName,
	cchUNSTRUCTUREDNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_UNSTRUCTUREDNAME,
    },
    {
        // "UnstructuredAddress",
	g_wszPropSubjectUnstructuredAddress,
        szOID_RSA_unstructAddr,
	apwszAttrUnstructAddr,
	cchUNSTRUCTUREDADDRESSMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_UNSTRUCTUREDADDRESS,
    },
    {
        // "DeviceSerialNumber",
	g_wszPropSubjectDeviceSerialNumber,
        szOID_DEVICE_SERIAL_NUMBER,
	apwszAttrDeviceSerialNumber,
	cchDEVICESERIALNUMBERMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_DEVICESERIALNUMBER,
    },
    {
	NULL,
        NULL,
        NULL,
        0,
        0,
        ST_NULL,
    },
};

#define CSUBJECTTABLE (sizeof(pkcs_subject) / sizeof(pkcs_subject[0]))

SUBJECTTABLE const *pkcs_apSubject[CSUBJECTTABLE];
SUBJECTTABLE const **pkcs_ppSubjectLast;
BOOL pkcsfSubjectTemplate = FALSE;

WCHAR const g_wszCNXchgSuffix[] = wszCNXCHGSUFFIX;

WCHAR const g_wszNTAuth[]=L"ldap:///CN=Public Key Services,CN=Services,%s?cACertificate?one?cn=NTAuthCertificates";

#define SHA1_HASH_LENGTH    20

VOID
pkcsSetDistinguishedName(
    IN ICertDBRow *prow,
    IN DWORD dwTable,
    IN CERT_NAME_BLOB const *pSubject)
{
    DWORD cwc;
    WCHAR awcName[CCH_DBMAXTEXT_DN + 1];
    HRESULT hr;

    CSASSERT(PROPTABLE_REQUEST == dwTable || PROPTABLE_CERTIFICATE == dwTable);

    cwc = CertNameToStr(
		    X509_ASN_ENCODING,
		    const_cast<CERT_NAME_BLOB *>(pSubject),
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    awcName,
		    ARRAYSIZE(awcName));
    if (0 != cwc && L'\0' != awcName[0])
    {
#if DBG_CERTSRV
	DWORD ReqId;

	prow->GetRowId(&ReqId);
	DBGPRINT((
            DBG_SS_CERTSRVI,
	    "%ws DN(%u): '%ws'\n",
	    PROPTABLE_REQUEST == dwTable? L"Request" : L"Certificate",
	    ReqId,
	    awcName));
#endif
	if (wcslen(awcName) == ARRAYSIZE(awcName) - 1)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"pkcsSetDistinguishedName: possible DN truncation: %u chars: '%ws'\n",
		ARRAYSIZE(awcName) - 1,
		awcName));
	}
	hr = prow->SetProperty(
		g_wszPropSubjectDistinguishedName,
		PROPTYPE_STRING | PROPCALLER_SERVER | dwTable,
		MAXDWORD,
		(BYTE const *) awcName);
	_PrintIfError(hr, "SetProperty(DN)");
    }
}


WCHAR const *
PKCSMapAttributeName(
    OPTIONAL IN WCHAR const *pwszAttributeName,
    OPTIONAL IN CHAR const *pszObjId,
    OUT DWORD *pdwIndex,
    OUT DWORD *pcchMax)
{
    SUBJECTTABLE const *pSubjectTable;
    WCHAR const *pwszPropName = NULL;

    for (pSubjectTable = pkcs_subject; ; pSubjectTable++)
    {
	WCHAR const * const *ppwsz;

	if (NULL == pSubjectTable->pwszPropName)
	{
	    goto error;
	}
	if (NULL != pwszAttributeName)
	{
	    for (ppwsz = pSubjectTable->apwszAttributeName;
		 NULL != *ppwsz;
		 ppwsz++)
	    {
		if (0 == lstrcmpi(pwszAttributeName, *ppwsz))
		{
		    break;
		}
	    }
	    if (NULL != *ppwsz ||
		0 == lstrcmpi(pwszAttributeName, pSubjectTable->pwszPropName))
	    {
		break;
	    }
	}
	if (NULL != pszObjId &&
	    0 == strcmp(pszObjId, pSubjectTable->pszObjId))
	{
	    break;
	}
    }
    CSASSERT(NULL != pSubjectTable->pwszPropName);
    pwszPropName = pSubjectTable->pwszPropName;
    *pdwIndex = pSubjectTable->dwSubjectTableValue;
    *pcchMax = pSubjectTable->cchMax;

error:
    return(pwszPropName);
}


HRESULT
pkcsFindCAContext(
    IN DWORD iCert,		// MAXDWORD -> use current
    IN DWORD iKey,		// MAXDWORD -> use current
    OUT CACTX **ppCAContext)
{
    HRESULT hr = E_INVALIDARG;
    DWORD i;
    CACTX *pCAContext;

    *ppCAContext = NULL;

    // Lookup is either by cert index OR by key index, but not both or neither

    CSASSERT((MAXDWORD == iCert) ^ (MAXDWORD == iKey));

    if (MAXDWORD != iCert)
    {
	if ((~_16BITMASK & iCert) || iCert >= g_cCACerts)
	{
	    _JumpError(hr, error, "bad cert index");
	}
	*ppCAContext = &g_aCAContext[iCert];
	CSASSERT(iCert == (*ppCAContext)->iCert);
    }
    else
    {
	CSASSERT(MAXDWORD != iKey);

	if ((~_16BITMASK & iKey) || iKey >= g_cCAKeys)
	{
	    _JumpError(hr, error, "bad key index");
	}
	for (i = g_cCACerts; ; i--)
	{
	    if (0 == i)
	    {
		_JumpError(hr, error, "key index not found");
	    }
	    pCAContext = &g_aCAContext[i - 1];
	    if (iKey == pCAContext->iKey)
	    {
		*ppCAContext = pCAContext;
		break;
	    }
	}
    }
    hr = S_OK;		// found it!

error:
    return(hr);
}


// Returns Cert Index in *piCert on success.
//
// returned in *piCert:
//  If iCert input value is not MAXDWORD, validate & return iCert.
//  If iCert input value is MAXDWORD, return the most current Cert Index.

HRESULT
PKCSMapCertIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,
    OUT DWORD *pState)
{
    HRESULT hr;
    CACTX *pCAContext;
    DBGCODE(DWORD iCertSave = iCert);

    *pState = CA_DISP_ERROR;
    if (MAXDWORD == iCert)
    {
	iCert = g_cCACerts - 1;
    }
    if (iCert >= g_cCACerts)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad CertIndex");
    }
    pCAContext = &g_aCAContext[iCert];
    PKCSVerifyCAState(pCAContext);

    *pState = CA_DISP_VALID;
    if (CTXF_CERTMISSING & pCAContext->Flags)
    {
	*pState = CA_DISP_ERROR;
    }
    else
    if (CTXF_REVOKED & pCAContext->Flags)
    {
	*pState = CA_DISP_REVOKED;
    }
    else
    if (CTXF_EXPIRED & pCAContext->Flags)
    {
	*pState = CA_DISP_INVALID;
    }
    *piCert = iCert;
    hr = S_OK;

error:
    DBGPRINT((
            DBG_SS_CERTSRVI,
	    "PKCSMapCertIndex(%u) --> %u, s=%u, hr=%x\n",
	    iCertSave,
	    *piCert,
	    *pState,
	    hr));
    return(hr);
}


// Returns Cert Index in *piCert and CRL Index in *piCRL on success.
//
// returned in *piCert:
//  If iCert input value is not MAXDWORD, validate iCert.  Look up the newest
//  Cert Index that uses the same key as the passed iCert.
//  If iCert input value is MAXDWORD, return the most current Cert Index.
//
// returned in *piCRL:
//  CRL index (same as Key Index)
//

HRESULT
PKCSMapCRLIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,	// returns newest iCert w/matching iKey for passed iCert
    OUT DWORD *piCRL,
    OUT DWORD *pState)
{
    HRESULT hr;
    CACTX *pCAContext;
    CACTX *pCAContextNewest;
    DWORD i;
    DBGCODE(DWORD iCertSave = iCert);

    hr = PKCSMapCertIndex(iCert, piCert, pState);
    _JumpIfError(hr, error, "PKCSMapCertIndex");

    // Now we know *piCert is a valid Cert Index:

    pCAContext = &g_aCAContext[*piCert];
    *piCRL = pCAContext->iKey;

    // find the newest iCert with matching iKey

    for (i = *piCert + 1; i < g_cCACerts; i++)
    {
	if (*piCRL == g_aCAContext[i].iKey)
	{
	    *piCert = i;
	}
    }
    pCAContextNewest = &g_aCAContext[*piCert];

    if (CTXF_CRLZOMBIE & pCAContext->Flags)
    {
	*pState = CA_DISP_VALID;
    }
    else
    if (pCAContext->iCert != pCAContext->iKey)
    {
	*pState = CA_DISP_ERROR;
    }
    else
    if (CTXF_EXPIRED == ((CTXF_EXPIRED | CTXF_SKIPCRL) & pCAContextNewest->Flags))
    {
	*pState = CA_DISP_VALID;
    }
    hr = S_OK;

error:
    DBGPRINT((
            DBG_SS_CERTSRVI,
	    "PKCSMapCRLIndex(%u) --> %u, iCRL=%u, s=%u, hr=%x\n",
	    iCertSave,
	    *piCert,
	    *piCRL,
	    *pState,
	    hr));
    return(hr);
}


HRESULT
PKCSGetCACertStatusCode(
    IN DWORD iCert,
    OUT HRESULT *phrCAStatusCode)
{
    HRESULT hr;
    DWORD State;
    
    *phrCAStatusCode = E_FAIL;

    hr = PKCSMapCertIndex(iCert, &iCert, &State);
    _JumpIfError(hr, error, "PKCSMapCertIndex");

    *phrCAStatusCode = g_aCAContext[iCert].hrVerifyStatus;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
PKCSGetCAState(
    IN BOOL fCertState,
    OUT BYTE *pb)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < g_cCACerts; i++)
    {
	DWORD iCert;
	DWORD iCRL;
	DWORD State;

	if (fCertState)
	{
	    hr = PKCSMapCertIndex(i, &iCert, &State);
	    _JumpIfError(hr, error, "PKCSMapCertIndex");
	}
	else
	{
	    hr = PKCSMapCRLIndex(i, &iCert, &iCRL, &State);
	    _JumpIfError(hr, error, "PKCSMapCRLIndex");
	}
	CSASSERT(0 == (~0xff & State));
	*pb++ = (BYTE) State;
    }

error:
    return(hr);
}

inline DWORD MapHRESULTToKRADisposition(HRESULT hr)
{
    switch(hr)
    {

    case CERT_E_EXPIRED:    return KRA_DISP_EXPIRED;

    case CRYPT_E_NOT_FOUND: return KRA_DISP_NOTFOUND;

    case CRYPT_E_REVOKED:   return KRA_DISP_REVOKED;

    case S_OK:              return KRA_DISP_VALID;

    case CERT_E_UNTRUSTEDROOT:
    case CERT_E_CHAINING:   return KRA_DISP_UNTRUSTED;

    case ERROR_NOT_FOUND:   return KRA_DISP_NOTLOADED;

    default:                return KRA_DISP_INVALID;
    }
}


HRESULT
PKCSGetKRAState(
    IN DWORD cKRA,
    OUT BYTE *pb)
{
    HRESULT hr = S_OK;
    DWORD dwCount = 0, dwUsedCount;
    HCERTSTORE hKRAStore = NULL;
    CERT_CONTEXT const *pCertContext = NULL;

    hKRAStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        X509_ASN_ENCODING,
        NULL,                   // hProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        wszKRA_CERTSTORE);
    _JumpIfError(hr, error, "CertOpenStore KRA");

    for (dwCount = 0, dwUsedCount = 0; dwCount < cKRA; dwCount++)
    {
        hr = myFindCACertByHashIndex(
			hKRAStore,
			g_wszSanitizedName,
			CSRH_CAKRACERT,
			dwCount,
			NULL,
			&pCertContext);
        if (S_OK == hr)
        {
            hr = myVerifyKRACertContext(
			    pCertContext,
			    (CRLF_REVCHECK_IGNORE_OFFLINE & g_dwCRLFlags)?
				CA_VERIFY_FLAGS_IGNORE_OFFLINE : 0);
            
            // check if the CA is using this cert (was able to 
            // load it last time it started)
            if(S_OK==hr)
            {
                hr = ERROR_NOT_FOUND;
                for(dwUsedCount=0; dwUsedCount< g_cKRACerts; dwUsedCount++)
                {
                    if(CertCompareCertificate(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        pCertContext->pCertInfo,
                        g_rgKRACerts[dwUsedCount]->pCertInfo))
                    {
                        // the CA is using this KRA cert
                        hr = S_OK;
                        break;
                    }
                }
            }
        }

        CSASSERT(0 == (~0xff & MapHRESULTToKRADisposition(hr)));
        pb[dwCount] = (BYTE)MapHRESULTToKRADisposition(hr);
        hr = S_OK;
        CertFreeCertificateContext(pCertContext);
        pCertContext = NULL;
    }

error:

    if(NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if (NULL != hKRAStore)
    {
        CertCloseStore(hKRAStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }

    return hr;
}


HRESULT
pkcsSetRequestNameInfo(
    IN ICertDBRow *prow,
    IN CERT_NAME_BLOB const *pSubject,
    OPTIONAL IN WCHAR const *pwszCNSuffix,
    IN OUT DWORD *pdwRequestFlags,
    OUT BOOL *pfSubjectNameSet)
{
    HRESULT hr;
    CERT_RDN *prdn;
    CERT_RDN *prdnEnd;
    CERT_NAME_INFO *pNameInfo = NULL;
    WCHAR const *pwszPropName;
    DWORD cbNameInfo;
    DWORD dwIndex;
    DWORD cchMax;
    BYTE afSubjectTable[CSUBJECTTABLE];	// see PKCSParseAttributes note
    SUBJECTTABLE const *pSubjectTable;

    *pfSubjectNameSet = FALSE;
    ZeroMemory(&afSubjectTable, sizeof(afSubjectTable));
    CSASSERT(0 == FALSE);

    hr = prow->SetProperty(
		    g_wszPropSubjectRawName,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    pSubject->cbData,
		    pSubject->pbData);
    _JumpIfError(hr, error, "SetProperty");

    pkcsSetDistinguishedName(prow, PROPTABLE_REQUEST, pSubject);

    if (!myDecodeName(
                X509_ASN_ENCODING,
		X509_UNICODE_NAME,
                pSubject->pbData,
                pSubject->cbData,
                CERTLIB_USE_LOCALALLOC,
                &pNameInfo,
                &cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    if (ENUM_TELETEX_ON == (ENUM_TELETEX_MASK & g_fForceTeletex))
    {
        *pdwRequestFlags |= CR_FLG_FORCETELETEX;
    }
    if (ENUM_TELETEX_UTF8 & g_fForceTeletex)
    {
        *pdwRequestFlags |= CR_FLG_FORCEUTF8;
    }

    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    CSASSERT(
		prdna->dwValueType == CERT_RDN_PRINTABLE_STRING ||
		prdna->dwValueType == CERT_RDN_UNICODE_STRING ||
		prdna->dwValueType == CERT_RDN_TELETEX_STRING ||
		prdna->dwValueType == CERT_RDN_IA5_STRING ||
		prdna->dwValueType == CERT_RDN_UTF8_STRING);

	    if (NULL == prdna->Value.pbData ||
		sizeof(WCHAR) > prdna->Value.cbData ||
		L'\0' == *(WCHAR *) prdna->Value.pbData)
	    {
		continue;
	    }

            if (CERT_RDN_TELETEX_STRING == prdna->dwValueType &&
                ENUM_TELETEX_AUTO == (ENUM_TELETEX_MASK & g_fForceTeletex))
            {
                *pdwRequestFlags |= CR_FLG_FORCETELETEX;
            }

	    pwszPropName = PKCSMapAttributeName(
					NULL,
					prdna->pszObjId,
					&dwIndex,
					&cchMax);
	    if (NULL != pwszPropName)
            {
                BOOL fCN;

		// CAPI null-terminates strings

                CSASSERT(
		 sizeof(WCHAR) * wcslen((WCHAR const *) prdna->Value.pbData) ==
		 prdna->Value.cbData);

		fCN = 0 == strcmp(szOID_COMMON_NAME, prdna->pszObjId);

		hr = PropSetAttributeProperty(
				prow,
				afSubjectTable[dwIndex], // fConcatenateRDNs
				PROPTABLE_REQUEST,
				cchMax,
				fCN? pwszCNSuffix : NULL,
				pwszPropName,
				(WCHAR const *) prdna->Value.pbData);
		if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) == hr)
		{
		    hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		}
		_JumpIfError(hr, error, "PropSetAttributeProperty");

		afSubjectTable[dwIndex] = TRUE;
		*pfSubjectNameSet = TRUE;

		if (fCN)
		{
		    pwszCNSuffix = NULL;
		}
            }
        }
    }
    hr = S_OK;

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HRESULT
PKCSSetRequestFlags(
    IN ICertDBRow *prow,
    IN BOOL fSet,
    IN DWORD dwChange)
{
    HRESULT hr;
    DWORD dwOld;
    DWORD dwNew;
    DWORD cb;
    
    cb = sizeof(dwOld);
    hr = prow->GetProperty(
		g_wszPropRequestFlags,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cb,
		(BYTE *) &dwOld);
    _JumpIfError(hr, error, "GetProperty");

    if (fSet)
    {
	dwNew = dwOld | dwChange;
    }
    else
    {
	dwNew = dwOld & ~dwChange;
    }

    if (dwOld != dwNew)
    {
	hr = prow->SetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(dwNew),
		    (BYTE const *) &dwNew);
	_JumpIfError(hr, error, "SetProperty(RequestFlags)");
    }

error:
    return(hr);
}


HRESULT
pkcsSetAttributeProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValue,
    IN DWORD dwTable,
    IN BYTE afSubjectTable[],
    OUT BOOL *pfSubjectModified,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf)
{
    HRESULT hr;
    WCHAR const *pwszPropName;
    DWORD dwIndex;
    DWORD cwcMax;
    BOOL fConcatenateRDNs;

    *pfSubjectModified = FALSE;
    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }

    // See if the attribute name can be mapped to a standard property.

    pwszPropName = PKCSMapAttributeName(pwszName, NULL, &dwIndex, &cwcMax);
    if (NULL != pwszPropName)
    {
	fConcatenateRDNs = afSubjectTable[dwIndex];
	afSubjectTable[dwIndex] = TRUE;
	*pfSubjectModified = TRUE;
    }
    else
    {
	pwszPropName = pwszName;
	cwcMax = MAXDWORD;
	fConcatenateRDNs = FALSE;
	dwTable = PROPTABLE_ATTRIBUTE;

	if (0 == lstrcmpi(g_wszPropRequesterName, pwszPropName))
	{
	    if (NULL == pfEnrollOnBehalfOf)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "NULL pfEnrollOnBehalfOf");
	    }
	    *pfEnrollOnBehalfOf = TRUE;
	    dwTable = PROPTABLE_REQUEST;
	}
    }
    hr = PropSetAttributeProperty(
			    prow,
			    fConcatenateRDNs,
			    dwTable,
			    cwcMax,
			    NULL,	// pwszSuffix
			    pwszPropName,
			    pwszValue);
    _JumpIfError(hr, error, "PropSetAttributeProperty");

error:
    return(hr);
}


// Note on Request Attribute and Subject RDN processing:
//
// Subject RDN strings and Request Attributes may be set several ways, in
// the following order.  Subsequent changes overwrite earlier changes, so the
// order implies precedence:
//
// - Subject in the inner PKCS10 (if no PKCS10 subject, then use the Subject
//	in the PKCS7 renewal cert)
// - the next outer PKCS7 or CMC Attributes 
// - ...
// - the most outer PKCS7 or CMC Attributes 
// - Request Attribute string passed with the request when first submitted
// - Policy Module may set subject RDNs in the certificate table
// - ICertAdmin::SetAttributes' Request Attribute string (if request pending)
//
// "PKCS7 or CMC Attributes" means either of the following:
// 1) Authenticated Attributes associated with a (non-CMC) PKCS7 signer info.
// 2) Tagged Attributes and/or RegInfo Control Attributes in a CMC request.
//
// None of the secured attributes listed in the registry (which is set to
// wszzDEFAULTSIGNEDATTRIBUTES by default) may be set unless the source is
// PKCS7 or CMC Attributes.
//
// The original request attribute string is stored in the RequestAttributes
// column in the request table.  It is never modified after that.  Individual
// request attribute values are parsed out of this string (when the request is
// submitted and when ICertAdmin::SetAttributes is called) and stored in a
// Subject RDN column of the request or certificate table if the attribute
// name matches an alias for a Subject RDN, or in a unique row in the
// attribute table otherwise.
//
// Individual Subject RDNs may be specified multiple times (multiple "OU",
// "CN", strings).  If all of the RDNs were set from the same source,
// they must be concatenated, but if some RDNs were specified from one source,
// then modified by another source, the previous set of RDNs should be
// overwritten by the new ones.  If the original Request Attribute string
// specified "CN:foo\nOU:ou2\nCN:bar", the two CN strings should be
// concatenated.  If one or more CN values are also specified later by a
// single call to ICertAdmin::SetAttributes, the original CN values should be
// overwritten by the new value(s).
//
// It is possible to have the CN strings specified by one source and the OU
// strings specified by another.
//
// Before the policy module gets control, all Subject RDN changes are written
// to the Request table.  Just before dispatching to the policy module, the
// Request Subject RDNs are copied to the Certificate Table RDNs.  The policy
// module may modify the Certificate Table RDNs only.
//
// If the request is made pending, ICertAdmin::SetAttributes may be used to
// modify request attributes and Certificate Table RDNs.
//
// The certificate Subject is constructed from the Certificate Table RDNs.

HRESULT
PKCSParseAttributes(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszAttributes,
    IN BOOL fRegInfo,
    IN DWORD dwRDNTable,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszBuf;
    WCHAR const *pwszName;
    WCHAR const *pwszValue;
    WCHAR const *pwszSecuredAttr;
    BYTE afSubjectTable[CSUBJECTTABLE];	// see PKCSParseAttributes note
    WCHAR *pwszNameAlloc = NULL;
    WCHAR *pwszValueAlloc = NULL;
    BOOL fSubjectModified = FALSE;

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    if (NULL == pwszAttributes)
    {
	hr = S_OK;
        goto error;		// silently ignore empty string
    }

    hr = myDupString(pwszAttributes, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszBuf = pwszDup;

    ZeroMemory(&afSubjectTable, sizeof(afSubjectTable));
    CSASSERT(0 == FALSE);

    while (TRUE)
    {
	hr = myParseNextAttribute(&pwszBuf, fRegInfo, &pwszName, &pwszValue);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "myParseNextAttribute");

	if (fRegInfo)
	{
	    if (NULL != pwszNameAlloc)
	    {
		LocalFree(pwszNameAlloc);
		pwszNameAlloc = NULL;
	    }
	    if (NULL != pwszValueAlloc)
	    {
		LocalFree(pwszValueAlloc);
		pwszValueAlloc = NULL;
	    }
	    hr = myUncanonicalizeURLParm(pwszName, &pwszNameAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    hr = myUncanonicalizeURLParm(pwszValue, &pwszValueAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    pwszName = pwszNameAlloc;
	    pwszValue = pwszValueAlloc;
	}

	if (!fRegInfo)
	{
	    // Only set the attribute if it's not one of the attributes
	    // that is required to be secure.

	    for (pwszSecuredAttr = g_wszzSecuredAttributes;
		 NULL != pwszSecuredAttr && L'\0' != *pwszSecuredAttr;
		 pwszSecuredAttr += wcslen(pwszSecuredAttr) + 1)
	    {
		if (0 == lstrcmpi(pwszSecuredAttr, pwszName))
		{
		    break;
		}
	    }
	}

        if (fRegInfo || NULL == pwszSecuredAttr || L'\0' == *pwszSecuredAttr)
        {
	    BOOL fEnrollOnBehalfOf = FALSE;
	    BOOL fSubjectModifiedT = FALSE;

	    hr = pkcsSetAttributeProperty(
			prow,
			pwszName,
			pwszValue,
			dwRDNTable,
			afSubjectTable,
			&fSubjectModified,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL);
	    _JumpIfError(hr, error, "PKCSSetRequestFlags");

	    if (fSubjectModifiedT)
	    {
		fSubjectModified = TRUE;
	    }
	    if (fEnrollOnBehalfOf)
	    {
		*pfEnrollOnBehalfOf = TRUE;
	    }
        }
    }
    if (fSubjectModified)
    {
	hr = PKCSSetRequestFlags(prow, FALSE, CR_FLG_SUBJECTUNMODIFIED);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }
    hr = S_OK;

error:
    if (NULL != pwszNameAlloc)
    {
	LocalFree(pwszNameAlloc);
    }
    if (NULL != pwszValueAlloc)
    {
	LocalFree(pwszValueAlloc);
    }
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
pkcsSetAltSubjectNameExtension(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN CERT_EXTENSION const *rgExtension,
    IN DWORD cExtension,
    IN DWORD cAltSubjectExtension)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_INFO **apInfo = NULL;
    DWORD i;
    DWORD j;
    DWORD cInfo = 0;
    DWORD cb;
    CERT_ALT_NAME_INFO ResultInfo;
    DWORD cbResult;
    BYTE *pbResult = NULL;

    ResultInfo.cAltEntry = 0;
    ResultInfo.rgAltEntry = NULL;

    apInfo = (CERT_ALT_NAME_INFO **) LocalAlloc(
			LMEM_FIXED,
			sizeof(CERT_ALT_NAME_INFO *) * cAltSubjectExtension);
    if (NULL == apInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // Decode all AltNames

    for (i = 0; i < cExtension; i++)
    {
        // This is an OID, generated by capi2, so we don't need to
        // do a case-insensitive comparison

        if (0 == strcmp(rgExtension[i].pszObjId, szOID_SUBJECT_ALT_NAME2))
        {
	    CSASSERT(cInfo < cAltSubjectExtension);

            // Decode to plain text

            if (!myDecodeObject(
		            X509_ASN_ENCODING,
		            X509_ALTERNATE_NAME,
		            rgExtension[i].Value.pbData,
		            rgExtension[i].Value.cbData,
		            CERTLIB_USE_LOCALALLOC,
		            (VOID **) &apInfo[cInfo],
		            &cb))
            {
		hr = myHLastError();
                _JumpError(hr, error, "myDecodeObject");
            }
            if (rgExtension[i].fCritical)
            {
                ExtFlags |= EXTENSION_CRITICAL_FLAG;
            }
            ResultInfo.cAltEntry += apInfo[cInfo]->cAltEntry;
            cInfo++;
        }
    }
    CSASSERT(cInfo == cAltSubjectExtension);

    ResultInfo.rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			LMEM_FIXED,
			ResultInfo.cAltEntry * sizeof(CERT_ALT_NAME_ENTRY));
    if (NULL == ResultInfo.rgAltEntry)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }

    j = 0;
    for (i = 0; i < cInfo; i++)
    {
        CopyMemory(
		&ResultInfo.rgAltEntry[j],
		apInfo[i]->rgAltEntry,
		apInfo[i]->cAltEntry * sizeof(CERT_ALT_NAME_ENTRY));
        j += apInfo[i]->cAltEntry;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &ResultInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbResult,
		    &cbResult))
    {
	hr = myHLastError();
        _JumpError(hr, error, "myEncodeObject");
    }

    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_REQUEST,
		    TEXT(szOID_SUBJECT_ALT_NAME2),
		    ExtFlags,
		    cbResult,
		    pbResult);
    _JumpIfError(hr, error, "PropSetExtension");

error:
    if (NULL != apInfo)
    {
        for (i = 0; i < cInfo; i++)
        {
            if (NULL != apInfo[i])
            {
                LocalFree(apInfo[i]);
            }
        }
        LocalFree(apInfo);
    }
    if (NULL != ResultInfo.rgAltEntry)
    {
        LocalFree(ResultInfo.rgAltEntry);
    }
    if (NULL != pbResult)
    {
        LocalFree(pbResult);
    }
    return(hr);
}


// Scan extension array, and merge all the AltSubjectName Extensions into one.

HRESULT
pkcsSetExtensions(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN CERT_EXTENSION const *rgExtension,
    IN DWORD cExtension)
{
    HRESULT hr;
    WCHAR *pwszObjId = NULL;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION const *pExtEnd;
    DWORD cAltSubjectExtension = 0;

    pExtEnd = &rgExtension[cExtension];
    for (pExt = rgExtension; pExt < pExtEnd; pExt++)
    {
	DWORD ExtFlagsT;

	if (EXTENSION_ORIGIN_RENEWALCERT == (EXTENSION_ORIGIN_MASK & ExtFlags))
	{
	    char const * const *ppszObjId;
	    static char const * const apszObjIdFilter[] = {
		szOID_CERTSRV_CA_VERSION,
		szOID_AUTHORITY_INFO_ACCESS,
		szOID_CRL_DIST_POINTS,
		szOID_AUTHORITY_KEY_IDENTIFIER2,
		szOID_SUBJECT_KEY_IDENTIFIER,
		NULL
	    };
	    for (ppszObjId = apszObjIdFilter; NULL != *ppszObjId; ppszObjId++)
	    {
		if (0 == strcmp(*ppszObjId, pExt->pszObjId))
		{
		    break;
		}
	    }
	    if (NULL != *ppszObjId)
	    {
		continue;		// skip this extension
	    }
	}

	if (NULL != pwszObjId)
	{
	    LocalFree(pwszObjId);
	    pwszObjId = NULL;
	}
	if (!ConvertSzToWsz(&pwszObjId, pExt->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz(ObjId)");
	}
	ExtFlagsT = ExtFlags;
	if (pExt->fCritical)
	{
	    ExtFlagsT |= EXTENSION_CRITICAL_FLAG;
	}

        // AltSubjectName needs to be merged, so we do that later.
        // This is an OID, generated by capi2, so we don't need to
        // do a case-insensitive comparison.

        if (0 == lstrcmp(pwszObjId, TEXT(szOID_SUBJECT_ALT_NAME2)))
        {
	    cAltSubjectExtension++;
            continue;
        }

	hr = PropSetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_REQUEST,
			pwszObjId,
			ExtFlagsT,
			pExt->Value.cbData,
			pExt->Value.pbData);
	_JumpIfError(hr, error, "PropSetExtension");

	DBGPRINT((
		DBG_SS_CERTSRVI,
		"PropSetExtension(%ws, f=%x, cb=%x, pb=%x)\n",
		pwszObjId,
		ExtFlagsT,
		pExt->Value.cbData,
		pExt->Value.pbData));
    }

    if (0 != cAltSubjectExtension)
    {
	hr = pkcsSetAltSubjectNameExtension(
					prow,
					ExtFlags,
					rgExtension,
					cExtension,
					cAltSubjectExtension);
	_JumpIfError(hr, error, "pkcsSetAltSubjectNameExtension");
    }
    hr = S_OK;

error:
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsSetOSVersion(
    IN ICertDBRow *prow,
    IN CRYPT_ATTR_BLOB *pAttrBlob)
{
    HRESULT hr;
    CERT_NAME_VALUE *pOSVersionString = NULL;
    BSTR strVersion = NULL;
    DWORD cb;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_ANY_STRING,
		    pAttrBlob->pbData,
		    pAttrBlob->cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pOSVersionString,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (NULL != pOSVersionString)
    {
	if (!IS_CERT_RDN_CHAR_STRING(pOSVersionString->dwValueType))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "version string is numeric data");
	}

	// If it's an 8 bit string, convert it to UNICODE

	if (CERT_RDN_UNIVERSAL_STRING > pOSVersionString->dwValueType)
	{
	    // Pass byte count in to allocate enough characters for
	    // the converted Unicode string

	    strVersion = SysAllocStringLen(
					NULL,
					pOSVersionString->Value.cbData);

	    // This is expected to be only numbers and '.'s,

	    if (NULL == strVersion)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "SysAllocStringLen");
	    }
	    mbstowcs(
		strVersion,
		(char const *) pOSVersionString->Value.pbData,
		pOSVersionString->Value.cbData);
	}
	else if (CERT_RDN_BMP_STRING == pOSVersionString->dwValueType ||
		 CERT_RDN_UNICODE_STRING == pOSVersionString->dwValueType)
	{
	    strVersion = SysAllocStringLen(
		    (WCHAR *) pOSVersionString->Value.pbData,
		    pOSVersionString->Value.cbData/sizeof(WCHAR));
	    if (NULL == strVersion)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "SysAllocStringLen");
	    }
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "unknown string type");
	}

	hr = prow->SetProperty(
			g_wszPropRequestOSVersion,
			PROPTYPE_STRING |
			    PROPCALLER_SERVER |
			    PROPTABLE_ATTRIBUTE,
			SysStringByteLen(strVersion),
			(BYTE *) strVersion);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = S_OK;

error:
    if (NULL != strVersion)
    {
	SysFreeString(strVersion);
    }
    if (NULL != pOSVersionString)
    {
	LocalFree(pOSVersionString);
    }
    return(hr);
}


HRESULT
pkcsSetCSPProvider(
    IN ICertDBRow *prow,
    IN CRYPT_ATTR_BLOB *pAttrBlob)
{
    HRESULT hr;
    CRYPT_CSP_PROVIDER *pccp = NULL;

    hr = myDecodeCSPProviderAttribute(
			    pAttrBlob->pbData,
			    pAttrBlob->cbData,
			    &pccp);
    _JumpIfError(hr, error, "myDecodeCSPProviderAttribute");

    if (NULL != pccp->pwszProviderName && L'\0' != *pccp->pwszProviderName)
    {
	hr = prow->SetProperty(
			g_wszPropRequestCSPProvider,
			PROPTYPE_STRING |
			    PROPCALLER_SERVER |
			    PROPTABLE_ATTRIBUTE,
			MAXDWORD,
			(BYTE const *) pccp->pwszProviderName);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = S_OK;

error:
    if (NULL != pccp)
    {
	LocalFree(pccp);
    }
    return(hr);
}


HRESULT
pkcsSetExtensionsFromAttributeBlob(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN CRYPT_ATTRIBUTE const *pAttrib)
{
    HRESULT hr;
    CRYPT_ATTR_BLOB *pAttrBlob;
    CERT_NAME_VALUE *pNameInfo = NULL;
    CERT_EXTENSIONS *pCertExtensions = NULL;
    DWORD cb;

    pAttrBlob = pAttrib->rgValue;
    while (TRUE)
    {
	if (NULL != pCertExtensions)
	{
	    LocalFree(pCertExtensions);
	    pCertExtensions = NULL;
	}
	if (myDecodeObject(
			X509_ASN_ENCODING,
			X509_EXTENSIONS,
			pAttrBlob->pbData,
			pAttrBlob->cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pCertExtensions,
			&cb))
	{
	    break;	// success
	}
	hr = myHLastError();

	// if we already decoded the attribute as a T61 string, or if it is
	// not a PKCS 9.14 attribute, fail -- we don't know what it contains.

	if (NULL != pNameInfo ||
	    0 != strcmp(pAttrib->pszObjId, szOID_RSA_certExtensions))
	{
	    _JumpError(hr, error, "myDecodeObject");
	}

	// Decode the attribute as a T61 string.  Some implementations wrap the
	// PKCS 9.14 extension array in an extra level of encoding as a Teletex
	// string.

	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_ANY_STRING,
			pAttrBlob->pbData,
			pAttrBlob->cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pNameInfo,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}

	// Loop again and try to decode the raw name blob as X509_EXTENSIONS.

	pAttrBlob = &pNameInfo->Value;
    }
    hr = pkcsSetExtensions(
		    prow,
		    EXTENSION_DISABLE_FLAG | ExtFlags,
		    pCertExtensions->rgExtension,
		    pCertExtensions->cExtension);
    _JumpIfError(hr, error, "pkcsSetExtensions(attributes)");

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pCertExtensions)
    {
	LocalFree(pCertExtensions);
    }
    return(hr);
}


HRESULT
PKCSGetProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    OPTIONAL OUT DWORD *pcbData,
    OUT BYTE **ppbData)
{
    HRESULT hr;
    BYTE *pbData = NULL;
    DWORD cbData;

    if (NULL != pcbData)
    {
	*pcbData = 0;
    }
    *ppbData = NULL;

    cbData = 0;
    hr = prow->GetProperty(pwszPropName, Flags, &cbData, pbData);
    _JumpIfError2(hr, error, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);

    pbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbData);
    if (NULL == pbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    hr = prow->GetProperty(pwszPropName, Flags, &cbData, pbData);
    _JumpIfError(hr, error, "GetProperty");

    if (NULL != pcbData)
    {
	*pcbData = cbData;
    }
    *ppbData = pbData;
    pbData = NULL;

error:
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    return(hr);
}


VOID
pkcsFreePublicKeyInfo(
    IN OUT CERT_PUBLIC_KEY_INFO *pPublicKeyInfo)
{
    if (NULL != pPublicKeyInfo->Algorithm.pszObjId)
    {
	LocalFree(pPublicKeyInfo->Algorithm.pszObjId);
    }
    if (NULL != pPublicKeyInfo->Algorithm.Parameters.pbData)
    {
	LocalFree(pPublicKeyInfo->Algorithm.Parameters.pbData);
    }
    if (NULL != pPublicKeyInfo->PublicKey.pbData)
    {
	LocalFree(pPublicKeyInfo->PublicKey.pbData);
    }
    ZeroMemory(pPublicKeyInfo, sizeof(*pPublicKeyInfo));
}


HRESULT
pkcsGetPublicKeyInfo(
    IN ICertDBRow *prow,
    OUT CERT_PUBLIC_KEY_INFO *pPublicKeyInfo)
{
    HRESULT hr;
    WCHAR *pwszObjId = NULL;

    ZeroMemory(pPublicKeyInfo, sizeof(*pPublicKeyInfo));
    hr = PKCSGetProperty(
		    prow,
		    g_wszPropCertificatePublicKeyAlgorithm,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    (BYTE **) &pwszObjId);
    _JumpIfError(hr, error, "PKCSGetProperty");

    if (!ConvertWszToSz(&pPublicKeyInfo->Algorithm.pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz(AlgObjId)");
    }

    hr = PKCSGetProperty(
		prow,
		g_wszPropCertificateRawPublicKeyAlgorithmParameters,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&pPublicKeyInfo->Algorithm.Parameters.cbData,
		&pPublicKeyInfo->Algorithm.Parameters.pbData);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "PKCSGetProperty");
    }

    hr = PKCSGetProperty(
		prow,
		g_wszPropCertificateRawPublicKey,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&pPublicKeyInfo->PublicKey.cbData,
		&pPublicKeyInfo->PublicKey.pbData);
    _JumpIfError(hr, error, "PKCSGetProperty");

error:
    if (S_OK != hr)
    {
	pkcsFreePublicKeyInfo(pPublicKeyInfo);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsEncryptPrivateKey(
    IN BYTE *pbDecrypted,
    IN DWORD cbDecrypted,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted,
    OUT WCHAR **ppwszKRAHashes)
{
    HRESULT hr;
    DWORD i;
    DWORD iKRACert;
    DWORD cwc;
    WCHAR *pwszKRAHashes = NULL;
    CERT_CONTEXT const **rgKRACerts = NULL;
    static bool fUseCAProv = true;

    *ppbEncrypted = NULL;
    *ppwszKRAHashes = NULL;

    CSASSERT(
	NULL != g_rgKRACerts &&
	0 != g_cKRACerts &&
	0 != g_cKRACertsRoundRobin &&
	NULL != g_rgstrKRAHashes);

    for (cwc = 0, i = 0; i < g_cKRACertsRoundRobin; i++)
    {
	iKRACert = (g_iKRACerts + i) % g_cKRACerts;
	cwc += wcslen(g_rgstrKRAHashes[iKRACert]) + 1;
    }
    pwszKRAHashes = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszKRAHashes)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    rgKRACerts = (CERT_CONTEXT const **) LocalAlloc(
				LMEM_FIXED,
				g_cKRACertsRoundRobin * sizeof(rgKRACerts[0]));
    if (NULL == rgKRACerts)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszKRAHashes[0] = L'\0';
    for (i = 0; i < g_cKRACertsRoundRobin; i++)
    {
	iKRACert = (g_iKRACerts + i) % g_cKRACerts;
	rgKRACerts[i] = g_rgKRACerts[iKRACert];
	if (0 != i)
	{
	    wcscat(pwszKRAHashes, L"\n");
	}
	wcscat(pwszKRAHashes, g_rgstrKRAHashes[iKRACert]);
    }
    CSASSERT(wcslen(pwszKRAHashes) + 1 == cwc);

    hr = myCryptEncryptMessage(
			CALG_3DES,
			g_cKRACertsRoundRobin,	// cCertRecipient
			rgKRACerts,		// rgCertRecipient
			pbDecrypted,
			cbDecrypted,
			fUseCAProv? g_pCAContextCurrent->hProvCA : NULL,
			ppbEncrypted,
			pcbEncrypted);
    if (FAILED(hr) && fUseCAProv)
    {
        // Failed to use the CA HCRYPTPROV, fall back to
        // default
        fUseCAProv = false;
        hr = myCryptEncryptMessage(
			    CALG_3DES,
			    g_cKRACertsRoundRobin,	// cCertRecipient
			    rgKRACerts,			// rgCertRecipient
			    pbDecrypted,
			    cbDecrypted,
			    NULL,
			    ppbEncrypted,
			    pcbEncrypted);
    }
    _JumpIfError(hr, error, "myCryptEncryptMessage");

    *ppwszKRAHashes = pwszKRAHashes;
    pwszKRAHashes = NULL;

error:
    if (NULL != pwszKRAHashes)
    {
	LocalFree(pwszKRAHashes);
    }
    if (NULL != rgKRACerts)
    {
	LocalFree(rgKRACerts);
    }
    return(hr);
}


HRESULT
PKCSArchivePrivateKey(
    IN ICertDBRow *prow,
    IN BOOL fV1Cert,
    IN BOOL fOverwrite,
    IN CRYPT_ATTR_BLOB const *pBlobEncrypted,
    OPTIONAL IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    BYTE *pbDecrypted = NULL;
    DWORD cbDecrypted;
    BYTE *pbEncrypted = NULL;
    DWORD cbEncrypted;
    DWORD iCertSig;
    BYTE *pbCert;	// do not free!
    DWORD cbCert;
    WCHAR *pwszKRAHashes = NULL;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;
    WCHAR *pwszUserName = NULL;
    DWORD cb;
    BYTE *pbKeyHash = NULL;
    DWORD cbKeyHash;

    ZeroMemory(&PublicKeyInfo, sizeof(PublicKeyInfo));

    if (0 == g_cKRACerts)
    {
	if (0 == g_cKRAHashes)
	{
	    hr = CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED;
	}
	else
	{
	    hr = CERTSRV_E_NO_VALID_KRA;
	}
	_JumpError(hr, error, "no KRA encryption certs");
    }

    if (NULL != pResult)
    {
	if (NULL == pResult->pbKeyHashIn)
	{
	    if (0 == (CRLF_ACCEPT_OLDRFC_CMC & g_dwCRLFlags))
	    {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpError(hr, error, "missing encrypted key hash");
	    }
	}
	else
	{
	    hr = myCalculateKeyArchivalHash(
				pBlobEncrypted->pbData,
				pBlobEncrypted->cbData,
				&pbKeyHash,
				&cbKeyHash);
	    _JumpIfError(hr, error, "myCalculateKeyArchivalHash");

	    if (pResult->cbKeyHashIn != cbKeyHash ||
		0 != memcmp(pResult->pbKeyHashIn, pbKeyHash, cbKeyHash))
	    {
		hr = S_OK;
		_JumpError(S_FALSE, error, "Ignoring key: hash mismatch");
	    }
	}
    }
    hr = prow->GetProperty(
		    g_wszPropRequestRawArchivedKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &cb,
		    NULL);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	if (S_OK == hr && !fOverwrite)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
	}
	_JumpIfError2(
		hr,
		error,
		"GetProperty",
		HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
    }

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		(BYTE **) &pwszUserName);
    _JumpIfError(hr, error, "PKCSGetProperty");

    if (NULL == g_hStoreCAXchg)
    {
	hr = PKCSGetCAXchgCert(0, pwszUserName, &iCertSig, &pbCert, &cbCert);
	_JumpIfError(hr, error, "PKCSGetCAXchgCert");
    }
    CSASSERT(NULL != g_hStoreCAXchg);
    hr = myCryptDecryptMessage(
		    g_hStoreCAXchg,
		    pBlobEncrypted->pbData,
		    pBlobEncrypted->cbData,
		    CERTLIB_USE_LOCALALLOC,
		    &pbDecrypted,
		    &cbDecrypted);
    _JumpIfError(hr, error, "myCryptDecryptMessage");

    DBGDUMPHEX((DBG_SS_CERTSRVI, 0, pbDecrypted, cbDecrypted));

    hr = pkcsGetPublicKeyInfo(prow, &PublicKeyInfo);
    _JumpIfError(hr, error, "pkcsGetPublicKeyInfo");

    hr = myValidateKeyBlob(
			pbDecrypted,
			cbDecrypted,
			&PublicKeyInfo,
			fV1Cert,
			NULL);
    _JumpIfError(hr, error, "myValidateKeyBlob");

    hr = pkcsEncryptPrivateKey(
			pbDecrypted,
			cbDecrypted,
			&pbEncrypted,
			&cbEncrypted,
			&pwszKRAHashes);
    _JumpIfError(hr, error, "pkcsEncryptPrivateKey");

    hr = prow->SetProperty(
		    g_wszPropRequestRawArchivedKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    cbEncrypted,
		    pbEncrypted);
    _JumpIfError(hr, error, "PKCSArchivePrivateKey:SetProperty");

    hr = prow->SetProperty(
		    g_wszPropRequestKeyRecoveryHashes,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszKRAHashes);
    _JumpIfError(hr, error, "SetProperty");

    if (NULL != pResult && NULL == pResult->pbKeyHashOut)
    {
	pResult->pbKeyHashOut = pbKeyHash;
	pResult->cbKeyHashOut = cbKeyHash;
	pbKeyHash = NULL;
    }

    {
	CertSrv::CAuditEvent audit(SE_AUDITID_CERTSRV_KEYARCHIVED, g_dwAuditFilter);
	DWORD dwRequestID = 0;
	DWORD cb = sizeof(DWORD);

	if (audit.IsEventEnabled())
	{
	    hr = prow->GetProperty(
			g_wszPropRequestRequestID,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cb,
			(BYTE *)&dwRequestID);
	    _JumpIfError(hr, error, "Report");

	    hr = audit.AddData(dwRequestID); // %1 request ID
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    hr = audit.AddData(pwszUserName); // %2 requester
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    hr = audit.AddData(pwszKRAHashes);// %3 KRA hashes
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    hr = audit.Report();
	    _JumpIfError(hr, error, "Report");
	}
    }

error:
    pkcsFreePublicKeyInfo(&PublicKeyInfo);
    if (NULL != pbDecrypted)
    {
	ZeroMemory(pbDecrypted, cbDecrypted);	// Private Key Material!
	LocalFree(pbDecrypted);
    }
    if (NULL != pbEncrypted)
    {
	LocalFree(pbEncrypted);
    }
    if (NULL != pwszKRAHashes)
    {
	LocalFree(pwszKRAHashes);
    }
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pbKeyHash)
    {
	LocalFree(pbKeyHash);
    }
    return(hr);
}


HRESULT
pkcsSaveRequestWithoutArchivedKey(
    IN ICertDBRow *prow,
    IN DWORD cbIn,
    IN BYTE const *pbIn)
{
    HRESULT hr;
    HCRYPTMSG hMsg = NULL;
    DWORD cSigner;
    DWORD iSigner;
    DWORD i;
    DWORD cb;
    BYTE *pbWithoutKey = NULL;
    DWORD cbWithoutKey;
    CRYPT_ATTRIBUTES *pAttrib = NULL;
    BOOL fKeyDeleted = FALSE;

    hMsg = CryptMsgOpenToDecode(
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    0,			// dwFlags
			    0,			// dwMsgType
			    NULL,		// hCryptProv
			    NULL,		// pRecipientInfo
			    NULL);		// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    if (!CryptMsgUpdate(hMsg, pbIn, cbIn, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    cb = sizeof(cSigner);
    if (!CryptMsgGetParam(
		    hMsg,
		    CMSG_SIGNER_COUNT_PARAM,
		    0,
		    &cSigner,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgGetParam(signer count)");
    }

    DBGPRINT((DBG_SS_CERTSRV, "cSigner=%u\n", cSigner));

    for (iSigner = 0; iSigner < cSigner; iSigner++)
    {
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_SIGNER_UNAUTH_ATTR_PARAM,
			    iSigner,		// dwIndex
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pAttrib,
			    &cb);
	_PrintIfError2(hr, "myCryptMsgGetParam(content)", hr);
	if (S_FALSE == hr)
	{
	    continue;
	}
	_JumpIfError(hr, error, "myCryptMsgGetParam(content)");

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "iSigner=%u, cAttr=%u\n",
	    iSigner,
	    pAttrib->cAttr));

	// Loop through deleting attributes from the end to avoid invalidated
	// indexes, which may result from deleting earlier attributes.

	for (i = 0; i < pAttrib->cAttr; i++)
	{
	    CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA DelPara;
	    DWORD iAttr = pAttrib->cAttr - i - 1;

	    DBGPRINT((
		DBG_SS_CERTSRV,
		"iSigner=%u, iAttr=%u %hs\n",
		iSigner,
		iAttr,
		pAttrib->rgAttr[iAttr].pszObjId));
	    if (0 == strcmp(
			pAttrib->rgAttr[iAttr].pszObjId,
			szOID_ARCHIVED_KEY_ATTR))
	    {
		ZeroMemory(&DelPara, sizeof(DelPara));
		DelPara.cbSize = sizeof(DelPara);
		DelPara.dwSignerIndex = iSigner;
		DelPara.dwUnauthAttrIndex = iAttr;

		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "Delete Key(signer=%u, attrib=%u)\n",
		    DelPara.dwSignerIndex,
		    DelPara.dwUnauthAttrIndex));

		if (!CryptMsgControl(
				hMsg,
				0,
				CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR,
				&DelPara))
		{
		    hr = myHLastError();
		    _PrintError(hr, "CryptMsgControl");
		}
		fKeyDeleted = TRUE;
	    }
	}
	LocalFree(pAttrib);
	pAttrib = NULL;
    }
    if (!fKeyDeleted)
    {
	hr = S_FALSE;
	_JumpError(hr, error, "no Encrypted Key attribute");
    }

    hr = myCryptMsgGetParam(
			hMsg,
			CMSG_ENCODED_MESSAGE,
			0,		// dwIndex
                        CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbWithoutKey,
			&cbWithoutKey);
    _JumpIfError(hr, error, "myCryptMsgGetParam(content)");

    hr = prow->SetProperty(
		    g_wszPropRequestRawRequest,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    cbWithoutKey,
		    pbWithoutKey);
    _JumpIfError(hr, error, "SetProperty(request)");

error:
    if (NULL != pAttrib)
    {
	LocalFree(pAttrib);
    }
    if (NULL != pbWithoutKey)
    {
	LocalFree(pbWithoutKey);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    return(hr);
}


#define PSA_DISALLOW_EXTENSIONS		0x00000001
#define PSA_DISALLOW_NAMEVALUEPAIRS	0x00000002
#define PSA_DISALLOW_ARCHIVEDKEY	0x00000004

HRESULT
pkcsSetAttributes(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN DWORD dwDisallowFlags,
    IN CRYPT_ATTRIBUTE const *rgAttrib,
    IN DWORD cAttrib,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE const *pAttrib;
    CRYPT_ATTRIBUTE const *pAttribEnd;
    DWORD i;
    BYTE afSubjectTable[CSUBJECTTABLE];	// see PKCSParseAttributes note
    CRYPT_DATA_BLOB *pBlob = NULL;
    BOOL fSubjectModified = FALSE;

    ZeroMemory(&afSubjectTable, sizeof(afSubjectTable));
    CSASSERT(0 == FALSE);

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }

    pAttribEnd = &rgAttrib[cAttrib];
    for (pAttrib = rgAttrib; pAttrib < pAttribEnd; pAttrib++)
    {
        if (0 == strcmp(pAttrib->pszObjId, szOID_OS_VERSION))
        {
            if (1 != pAttrib->cValue)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = pkcsSetOSVersion(prow, pAttrib->rgValue);
	    _JumpIfError(hr, error, "pkcsSetOSVersion");
        }
        else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ENROLLMENT_CSP_PROVIDER))
        {
            // Check to see if we have a CSPPROVIDER attribute.  We use this in
            // the policy module to determine if xenroll generated the request,
	    // so we can behave differently for old xenroll requests (put the
	    // UPN in the subject to avoid enrollment loops)

            if (1 != pAttrib->cValue)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = pkcsSetCSPProvider(prow, pAttrib->rgValue);
	    _JumpIfError(hr, error, "pkcsSetCSPProvider");
        }
        else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ENCRYPTED_KEY_HASH))
        {
	    DWORD cb;
	    
	    if (NULL != pResult->pbKeyHashIn || NULL != pBlob)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpError(hr, error, "Multiple key hashes");
	    }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pAttrib->rgValue[0].pbData,
			    pAttrib->rgValue[0].cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pBlob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    pResult->pbKeyHashIn = (BYTE *) LocalAlloc(
						LMEM_FIXED,
						pBlob->cbData);
	    if (NULL == pResult->pbKeyHashIn)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pResult->pbKeyHashIn, pBlob->pbData, pBlob->cbData);
	    pResult->cbKeyHashIn = pBlob->cbData;
	}
        else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ARCHIVED_KEY_ATTR))
        {
	    // Pull encrypted private key out of the attribute for archival.
	    //
	    // Save request in database without private key now, to keep the
	    // error path from saving the request later *with* the key.

	    if (NULL != pbRequest)
	    {
		hr = pkcsSaveRequestWithoutArchivedKey(
						prow,
						cbRequest,
						pbRequest);
		_PrintIfError(hr, "pkcsSaveRequestWithoutArchivedKey");
		if (S_OK == hr)
		{
		    pResult->fKeyArchived = TRUE;
		}
	    }

	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    if (PSA_DISALLOW_ARCHIVEDKEY & dwDisallowFlags)
	    {
		hr = CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL;
		_JumpError(hr, error, "archived key disallowed");
	    }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = PKCSArchivePrivateKey(
				prow,
				FALSE,
				FALSE,
				&pAttrib->rgValue[0],
				pResult);
	    _JumpIfError(hr, error, "PKCSArchivePrivateKey");
        }
	else
	if (0 == strcmp(pAttrib->pszObjId, szOID_CERT_EXTENSIONS) ||
	    0 == strcmp(pAttrib->pszObjId, szOID_RSA_certExtensions))
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    if (PSA_DISALLOW_EXTENSIONS & dwDisallowFlags)
            {
                _JumpError(hr, error, "extensions disallowed");
            }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = pkcsSetExtensionsFromAttributeBlob(
						prow,
						ExtFlags,
						pAttrib);
	    _JumpIfError(hr, error, "pkcsSetExtensionsFromAttributeBlob");
	}
	else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ENROLLMENT_NAME_VALUE_PAIR))
	{
	    // Can't apply name value pair attributes to a renewal or CMC

	    if (PSA_DISALLOW_NAMEVALUEPAIRS & dwDisallowFlags)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "name/value pairs disallowed");
	    }

	    for (i = 0; i < pAttrib->cValue; i++)
	    {
		CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pInfo = NULL;
		DWORD cbInfo = 0;
		CRYPT_ATTR_BLOB const *pvalue = &pAttrib->rgValue[i];

		WCHAR const *pwszPropName;
		BOOL fConcatenateRDNs;
		DWORD dwIndex;
		DWORD cchMax;
		DWORD dwTable;

		if (!myDecodeNameValuePair(
					X509_ASN_ENCODING,
					pvalue->pbData,
					pvalue->cbData,
					CERTLIB_USE_LOCALALLOC,
					&pInfo,
					&cbInfo))
		{
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _JumpError(hr, error, "myDecodeNameValuePair");

		    // if the attribute name & value are both non-empty ...
		}

		BOOL fEnrollOnBehalfOf = FALSE;
		BOOL fSubjectModifiedT = FALSE;

		hr = pkcsSetAttributeProperty(
			prow,
			pInfo->pwszName,
			pInfo->pwszValue,
			PROPTABLE_REQUEST,
			afSubjectTable,
			&fSubjectModified,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL);
		if (fSubjectModifiedT)
		{
		    fSubjectModified = TRUE;
		}
		if (fEnrollOnBehalfOf)
		{
		    *pfEnrollOnBehalfOf = TRUE;
		}
		if (NULL != pInfo)
		{
		    LocalFree(pInfo);
		}
		_JumpIfError(hr, error, "pkcsSetAttributeProperty");
	    }
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"Skipping authenticated attribute %hs\n",
		pAttrib->pszObjId));
	}
    }
    if (fSubjectModified)
    {
	hr = PKCSSetRequestFlags(prow, FALSE, CR_FLG_SUBJECTUNMODIFIED);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }
    hr = S_OK;

error:
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}


HRESULT
pkcsVerifyCertContext(
    OPTIONAL IN FILETIME const *pft,
    IN BOOL fTimeOnly,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    FILETIME ft;

    if (NULL == pft)
    {
	GetSystemTimeAsFileTime(&ft);
	pft = &ft;
    }
    if (0 > CompareFileTime(pft, &pcc->pCertInfo->NotBefore))
    {
	hr = CERT_E_EXPIRED;
	_JumpError(hr, error, "cert not yet valid");
    }
    if (0 < CompareFileTime(pft, &pcc->pCertInfo->NotAfter))
    {
	hr = CERT_E_EXPIRED;
	_JumpError(hr, error, "cert is expired");
    }
    if (!fTimeOnly)
    {
	hr = myVerifyCertContext(
			pcc,			// pCert
			(CRLF_REVCHECK_IGNORE_OFFLINE & g_dwCRLFlags)?
			    CA_VERIFY_FLAGS_IGNORE_OFFLINE : 0,	// dwFlags
			0,			// cUsageOids
			NULL,			// apszUsageOids
			HCCE_LOCAL_MACHINE,	// hChainEngine
			NULL,			// hAdditionalStore
			NULL);			// ppwszMissingIssuer
	_JumpIfError(hr, error, "myVerifyCertContext");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsSetValidityPeriod(
    IN ICertDBRow *prow,
    IN LONG lValidityPeriodCount,
    IN enum ENUM_PERIOD enumValidityPeriod)
{
    HRESULT hr;
    FILETIME ftNotBefore;
    FILETIME ftNotAfter;
    LONGLONG delta;
    CACTX *pCAContext = g_pCAContextCurrent;

    GetSystemTimeAsFileTime(&ftNotBefore);

    hr = pkcsVerifyCertContext(&ftNotBefore, TRUE, pCAContext->pccCA);
    _JumpIfErrorStr(hr, error, "pkcsVerifyCertContext", L"CA cert expired");

    ftNotAfter = ftNotBefore;

    // Set the start date to the current time minus clock skew.  But ensure the
    // new cert's start date is not before the CA certificate's start date.

    delta = g_dwClockSkewMinutes * CVT_MINUTES;
    myAddToFileTime(&ftNotBefore, -delta * CVT_BASE);

    if (0 > CompareFileTime(
			&ftNotBefore,
			&pCAContext->pccCA->pCertInfo->NotBefore))
    {
	ftNotBefore = pCAContext->pccCA->pCertInfo->NotBefore;
    }

    hr = prow->SetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(ftNotBefore),
                    (BYTE *) &ftNotBefore);
    _JumpIfError(hr, error, "pkcsSetValidityPeriod:SetProperty");

    // Set the end date to the start date plus the registry-configured
    // validity period.  Then clamp the new cert's end date to the CA
    // certificate's end date.

    myMakeExprDateTime(&ftNotAfter, lValidityPeriodCount, enumValidityPeriod);

    if (0 < CompareFileTime(
			&ftNotAfter,
			&pCAContext->pccCA->pCertInfo->NotAfter))
    {
	ftNotAfter = pCAContext->pccCA->pCertInfo->NotAfter;
    }

    hr = prow->SetProperty(
		    g_wszPropCertificateNotAfterDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(ftNotAfter),
                    (BYTE *) &ftNotAfter);
    _JumpIfError(hr, error, "pkcsSetValidityPeriod:SetProperty");

error:
    return(hr);
}


HRESULT
pkcsSetServerExtension(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszObjId,
    IN DWORD cbExt,
    IN BYTE const *pbExt)
{
    HRESULT hr;
    BYTE *pbOld = NULL;
    DWORD cbOld;
    DWORD ExtFlags;

    ExtFlags = 0;
    if (NULL == pbExt)
    {
	CSASSERT(0 == cbExt);

	hr = PropGetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    pwszObjId,
		    &ExtFlags,
		    &cbOld,
		    &pbOld);
	if (S_OK != hr)
	{
	    ExtFlags = 0;
	}
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    ExtFlags |= EXTENSION_DISABLE_FLAG;
	}
    }
    if (NULL != pbExt || (EXTENSION_DISABLE_FLAG & ExtFlags))
    {
	ExtFlags &= ~EXTENSION_ORIGIN_MASK;
	ExtFlags |= EXTENSION_ORIGIN_SERVER;
	hr = PropSetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_SERVER,
			pwszObjId,
			ExtFlags,
			cbExt,
			pbExt);
	_JumpIfError(hr, error, "PropSetExtension");
    }
    hr = S_OK;

error:
    if (NULL != pbOld)
    {
	LocalFree(pbOld);
    }
    return(hr);
}


HRESULT
PKCSSetServerProperties(
    IN ICertDBRow *prow,
    IN LONG lValidityPeriodCount,
    IN enum ENUM_PERIOD enumValidityPeriod)
{
    HRESULT hr;
    CACTX *pCAContext = g_pCAContextCurrent;

    hr = pkcsSetServerExtension(
			prow,
			TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			pCAContext->KeyAuthority2Cert.cbData,
			pCAContext->KeyAuthority2Cert.pbData);
    _JumpIfError(hr, error, "pkcsSetServerExtension");

    hr = pkcsSetServerExtension(
			prow,
			TEXT(szOID_CRL_DIST_POINTS),
			pCAContext->CDPCert.cbData,
			pCAContext->CDPCert.pbData);
    _JumpIfError(hr, error, "pkcsSetServerExtension");

    hr = pkcsSetServerExtension(
			prow,
			TEXT(szOID_AUTHORITY_INFO_ACCESS),
			pCAContext->AIACert.cbData,
			pCAContext->AIACert.pbData);
    _JumpIfError(hr, error, "pkcsSetServerExtension");

    hr = pkcsSetValidityPeriod(prow, lValidityPeriodCount, enumValidityPeriod);
    _JumpIfError(hr, error, "pkcsSetValidityPeriod");

error:
    return(hr);
}


HRESULT
pkcsSetPublicKeyProperties(
    IN ICertDBRow *prow,
    IN CERT_PUBLIC_KEY_INFO const *pSubjectPublicKeyInfo)
{
    HRESULT hr;
    WCHAR *pwszExtensionName;
    WCHAR *pwszObjId = NULL;
    CACTX *pCAContext = g_pCAContextCurrent;
    CERT_EXTENSION ext;
    DWORD ExtFlags;
    DWORD dwCaller;
    DWORD cbitKey;

    ext.Value.pbData = NULL;

    // Public Key size must be a multiple of 8 bits.
    if (0 != pSubjectPublicKeyInfo->PublicKey.cUnusedBits)
    {
	hr = NTE_BAD_KEY;
	_JumpError(hr, error, "PublicKey.cUnusedBits");
    }
    hr = prow->SetProperty(
		    g_wszPropCertificateRawPublicKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    pSubjectPublicKeyInfo->PublicKey.cbData,
		    pSubjectPublicKeyInfo->PublicKey.pbData);
    _JumpIfError(hr, error, "SetProperty");

    cbitKey = CertGetPublicKeyLength(
		    X509_ASN_ENCODING,
		    const_cast<CERT_PUBLIC_KEY_INFO *>(pSubjectPublicKeyInfo));
    hr = prow->SetProperty(
		    g_wszPropCertificatePublicKeyLength,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    sizeof(cbitKey),
		    (BYTE const *) &cbitKey);
    _JumpIfError(hr, error, "SetProperty(KeyLength)");

    if (!ConvertSzToWsz(
		    &pwszObjId,
		    pSubjectPublicKeyInfo->Algorithm.pszObjId,
		    -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertSzToWsz(AlgObjId)");
    }
    hr = prow->SetProperty(
		    g_wszPropCertificatePublicKeyAlgorithm,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    MAXDWORD,
		    (BYTE const *) pwszObjId);
    _JumpIfError(hr, error, "SetProperty");

    if (NULL != pSubjectPublicKeyInfo->Algorithm.Parameters.pbData)
    {
	hr = prow->SetProperty(
		    g_wszPropCertificateRawPublicKeyAlgorithmParameters,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    pSubjectPublicKeyInfo->Algorithm.Parameters.cbData,
		    pSubjectPublicKeyInfo->Algorithm.Parameters.pbData);
	_JumpIfError(hr, error, "SetProperty");
    }

    // Subject Key Identifier extension:

    hr = PropGetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_SUBJECT_KEY_IDENTIFIER),
		    &ExtFlags,
		    &ext.Value.cbData,
		    &ext.Value.pbData);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "PropGetExtension");

	dwCaller = PROPCALLER_REQUEST;
	ExtFlags &= ~EXTENSION_DISABLE_FLAG;
    }
    else
    {
	dwCaller = PROPCALLER_SERVER;
	ExtFlags = EXTENSION_ORIGIN_SERVER;

	hr = myCreateSubjectKeyIdentifierExtension(
					pSubjectPublicKeyInfo,
					&ext.Value.pbData,
					&ext.Value.cbData);
	_JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");
    }

    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | dwCaller,
		    TEXT(szOID_SUBJECT_KEY_IDENTIFIER),
		    ExtFlags,
		    ext.Value.cbData,
		    ext.Value.pbData);
    _JumpIfError(hr, error, "PropSetExtension");

error:
    if (NULL != ext.Value.pbData)
    {
	LocalFree(ext.Value.pbData);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsParsePKCS10Request(
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN CERT_CONTEXT const *pSigningAuthority,
    OUT BOOL *pfRenewal,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD cbCertInfo;
    CERT_REQUEST_INFO *pRequestInfo = NULL;
    CRYPT_ATTRIBUTE const *pAttrib;
    CRYPT_ATTRIBUTE const *pAttribEnd;
    CRYPT_ATTR_BLOB *pAttrBlob;
    CERT_CONTEXT const *pOldCert = NULL;
    DWORD dwRequestFlags = 0;
    BOOL fRenewal = FALSE;
    BOOL fSubjectNameSet;

    CSASSERT(CR_IN_PKCS10 == (CR_IN_FORMATMASK & dwFlags));
    CSASSERT(
	CR_IN_PKCS10 == (CR_IN_FORMATMASK & pResult->dwFlagsTop) ||
	CR_IN_PKCS7 == (CR_IN_FORMATMASK & pResult->dwFlagsTop) ||
	CR_IN_CMC == (CR_IN_FORMATMASK & pResult->dwFlagsTop));

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pbRequest,
		    cbRequest,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pRequestInfo,
		    &cbCertInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    // verify with the public key passed in the PKCS10

    if (!CryptVerifyCertificateSignature(
			    NULL,
			    X509_ASN_ENCODING,
			    const_cast<BYTE *>(pbRequest),
			    cbRequest,
			    &pRequestInfo->SubjectPublicKeyInfo))
    {
	hr = myHLastError();
	_PrintError3(
		hr,
		"CryptVerifyCertificateSignature",
		E_INVALIDARG,
		CRYPT_E_ASN1_BADTAG);
	if (CR_IN_CMC == (CR_IN_FORMATMASK & pResult->dwFlagsTop))
	{
	    if (E_INVALIDARG == hr)			// NULL signature?
	    {
		CRYPT_DATA_BLOB Blob;
		
		Blob.cbData = cbRequest;
		Blob.pbData = const_cast<BYTE *>(pbRequest);
		if (!CryptVerifyCertificateSignatureEx(
					NULL,		// hCryptProv
					X509_ASN_ENCODING,
					CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
					&Blob,
					CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL,
					NULL,		// pvIssuer
					0,		// dwFlags
					NULL))		// pvReserved
		{
		    HRESULT hr2 = myHLastError();

		    _PrintError(hr2, "CryptVerifyCertificateSignatureEx");
		}
		else
		{
		    hr = S_OK;
		}
	    }
	    else if ((CRLF_ACCEPT_OLDRFC_CMC & g_dwCRLFlags) &&
		     CRYPT_E_ASN1_BADTAG == hr)		// No signature?
	    {
		hr = S_OK;
	    }
	}
	if (E_INVALIDARG == hr || CRYPT_E_ASN1_BADTAG == hr)
	{
	    hr = NTE_BAD_SIGNATURE;
	}
	_JumpIfError(hr, error, "CryptVerifyCertificateSignature");
    }

    // handle renewal certificate extensions BEFORE processing the rest of
    // the request attributes (which may also contain extensions)

    pAttribEnd = &pRequestInfo->rgAttribute[pRequestInfo->cAttribute];
    for (pAttrib = pRequestInfo->rgAttribute; pAttrib < pAttribEnd; pAttrib++)
    {
        if (0 == strcmp(pAttrib->pszObjId, szOID_RENEWAL_CERTIFICATE))
        {
	    hr = CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE;
            if (fRenewal)
	    {
                _JumpError(hr, error, "Multiple renewal certs!");
	    }
	    if (CR_IN_PKCS7 != (CR_IN_FORMATMASK & pResult->dwFlagsTop) &&
		CR_IN_CMC != (CR_IN_FORMATMASK & pResult->dwFlagsTop))
	    {
                _JumpError(hr, error, "renewal cert must be in PKCS7 or CMC");
	    }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
            pAttrBlob = pAttrib->rgValue;

            pOldCert = CertCreateCertificateContext(
						X509_ASN_ENCODING,
						pAttrBlob->pbData,
						pAttrBlob->cbData);
            if (NULL == pOldCert)
            {
                _JumpError(hr, error, "CertCreateCertificateContext");
            }

            // The old raw certificate, and the signer of the PKCS7 must match!

            if (NULL == pSigningAuthority ||
               !CertCompareCertificate(
				pSigningAuthority->dwCertEncodingType,
				pSigningAuthority->pCertInfo,
				pOldCert->pCertInfo))
            {
		_JumpError(hr, error, "CertCompareCertificate");
            }

            // This is a renewal, mark it as such.

            hr = prow->SetProperty(
		            g_wszPropRequestRawOldCertificate,
		            PROPTYPE_BINARY |
				PROPCALLER_SERVER |
				PROPTABLE_REQUEST,
		            pAttrBlob->cbData,
		            pAttrBlob->pbData);
            _JumpIfError(hr, error, "SetProperty(old cert)");

	    hr = pkcsSetExtensions(
			prow,
			EXTENSION_ORIGIN_RENEWALCERT | EXTENSION_DISABLE_FLAG,
			pOldCert->pCertInfo->rgExtension,
			pOldCert->pCertInfo->cExtension);
            _JumpIfError(hr, error, "pkcsSetExtensions(old cert)");

            fRenewal = TRUE;
        }
    }

    // handle certificate extensions/known atributes

    hr = pkcsSetAttributes(
		    prow,
		    EXTENSION_ORIGIN_REQUEST,
		    PSA_DISALLOW_ARCHIVEDKEY,
		    pRequestInfo->rgAttribute,
		    pRequestInfo->cAttribute,
		    0,
		    NULL,
		    NULL,
		    pResult);
    _JumpIfError(hr, error, "pkcsSetAttributes(PKCS10)");

    hr = pkcsSetRequestNameInfo(
			prow,
			&pRequestInfo->Subject,
			NULL,		// pwszCNSuffix
			&dwRequestFlags,
			&fSubjectNameSet);
    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");

    if (fSubjectNameSet)
    {
	dwRequestFlags |= CR_FLG_SUBJECTUNMODIFIED;
    }

    if (fRenewal)
    {
	if (!fSubjectNameSet)
	{
	    CSASSERT(NULL != pOldCert);
	    CSASSERT(NULL != pOldCert->pCertInfo);
	    hr = pkcsSetRequestNameInfo(
			    prow,
			    &pOldCert->pCertInfo->Subject,
			    NULL,		// pwszCNSuffix
			    &dwRequestFlags,
			    &fSubjectNameSet);
	    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");
	}
        dwRequestFlags |= CR_FLG_RENEWAL;
    }

    hr = prow->SetProperty(
            g_wszPropRequestFlags,
            PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            sizeof(dwRequestFlags),
            (BYTE const *) &dwRequestFlags);
    _JumpIfError(hr, error, "SetProperty(RequestFlags)");

    hr = pkcsSetPublicKeyProperties(prow, &pRequestInfo->SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = PKCSSetServerProperties(
			prow,
			g_lValidityPeriodCount,
			g_enumValidityPeriod);
    _JumpIfError(hr, error, "PKCSSetServerProperties");

    if (NULL != pfRenewal)
    {
        *pfRenewal = fRenewal;
    }

error:
    if (NULL != pOldCert)
    {
	CertFreeCertificateContext(pOldCert);
    }
    if (NULL != pRequestInfo)
    {
	LocalFree(pRequestInfo);
    }
    return(hr);
}


HRESULT
PKCSVerifyChallengeString(
    IN ICertDBRow *prow)
{
    HRESULT hr;
    DWORD cb;
    WCHAR wszPassed[MAX_PATH];
    WCHAR wszExpected[MAX_PATH];

    cb = sizeof(wszExpected);
    hr = prow->GetProperty(
		    g_wszPropExpectedChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    &cb,
		    (BYTE *) wszExpected);
    if (S_OK != hr || L'\0' == wszExpected[0])
    {
	hr = S_OK;	// no challenge expected
	goto error;
    }

    cb = sizeof(wszPassed);
    hr = prow->GetProperty(
		    g_wszPropChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    &cb,
		    (BYTE *) wszPassed);
    if (S_OK != hr)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
	_JumpError(hr, error, "Missing Challenge String");
    }
    if (0 != wcscmp(wszExpected, wszPassed))
    {
	CONSOLEPRINT2((
		    DBG_SS_CERTSRV,
		    "Challenge: passed(%ws) expected(%ws)\n",
		    wszPassed,
		    wszExpected));

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
	_JumpError(hr, error, "Invalid Challenge String");
    }
    hr = prow->SetProperty(
		    g_wszPropExpectedChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    0,
		    NULL);
    _PrintIfError(hr, "SetProperty");

    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsParseKeyGenRequest(
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD cbKeyGenRequest;
    CERT_KEYGEN_REQUEST_INFO *pKeyGenRequest = NULL;
    DWORD dwRequestFlags;

    CSASSERT(CR_IN_KEYGEN == (CR_IN_FORMATMASK & dwFlags));

    // Decode KeyGenRequest structure
    if (!myDecodeKeyGenRequest(
		    pbRequest,
		    cbRequest,
		    CERTLIB_USE_LOCALALLOC,
		    &pKeyGenRequest,
		    &cbKeyGenRequest))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeKeyGen");
    }

    // verify with the public key passed in the PKCS10
    if (!CryptVerifyCertificateSignature(
			    NULL,
			    X509_ASN_ENCODING,
			    (BYTE *) pbRequest,
			    cbRequest,
			    &pKeyGenRequest->SubjectPublicKeyInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptVerifyCertificateSignature");
    }

    hr = pkcsSetPublicKeyProperties(
				prow,
				&pKeyGenRequest->SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = PKCSSetServerProperties(
			prow,
			g_lValidityPeriodCount,
			g_enumValidityPeriod);
    _JumpIfError(hr, error, "PKCSSetServerProperties");

    hr = prow->SetProperty(
		    g_wszPropExpectedChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    MAXDWORD,
		    (BYTE *) pKeyGenRequest->pwszChallengeString);
    _JumpIfError(hr, error, "SetProperty");

    dwRequestFlags = 0;
    switch (ENUM_TELETEX_MASK & g_fForceTeletex)
    {
	case ENUM_TELETEX_ON:
	case ENUM_TELETEX_AUTO:
	    dwRequestFlags |= CR_FLG_FORCETELETEX;
	    break;
    }
    if (ENUM_TELETEX_UTF8 & g_fForceTeletex)
    {
        dwRequestFlags |= CR_FLG_FORCEUTF8;
    }

    hr = prow->SetProperty(
            g_wszPropRequestFlags,
            PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            sizeof(dwRequestFlags),
            (BYTE const *) &dwRequestFlags);
    _JumpIfError(hr, error, "SetProperty(RequestFlags)");

error:
    if (NULL != pKeyGenRequest)
    {
	LocalFree(pKeyGenRequest);
    }
    return(hr);
}


// Validate the certificate:
//    Signed by CA Certificate
//    issuer name == CA Certificate subject
//    NotBefore >= CA Certificate NotBefore
//    NotAfter <= CA Certificate NotAfter
//    if KEYID2 issuer KeyId set: == CA Certificate KeyId
//    if KEYID2 issuer Name set: == CA Certificate Issuer
//    if KEYID2 issuer Serial Number set: == CA Certificate serial number

HRESULT
pkcsVerifyCertIssuer(
    IN CERT_CONTEXT const *pCert,
    IN CACTX const *pCAContext)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    CERT_INFO const *pCertInfo = pCert->pCertInfo;
    CERT_INFO const *pCACertInfo = pCAContext->pccCA->pCertInfo;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION const *pExtEnd;
    CERT_AUTHORITY_KEY_ID2_INFO *pkeyAuth = NULL;
    DWORD cbkeyAuth;
    CERT_NAME_BLOB const *pName;

    // verify with the CA cert's public key

    if (!CryptVerifyCertificateSignature(
				NULL,
				X509_ASN_ENCODING,
				pCert->pbCertEncoded,
				pCert->cbCertEncoded,
				const_cast<CERT_PUBLIC_KEY_INFO *>(
				    &pCACertInfo->SubjectPublicKeyInfo)))
    {
	hr = myHLastError();
	_JumpError2(
		hr,
		error,
		"CryptVerifyCertificateSignature",
		NTE_BAD_SIGNATURE);
    }

    // Check Issuer name:

    if (!myAreBlobsSame(
		pCACertInfo->Subject.pbData,
		pCACertInfo->Subject.cbData,
		pCertInfo->Issuer.pbData,
		pCertInfo->Issuer.cbData))
    {
	_JumpError(hr, error, "Bad Issuer Name");
    }

    // Check that NotBefore >= CA Certificate NotBefore

    if (0 > CompareFileTime(&pCertInfo->NotBefore, &pCACertInfo->NotBefore))
    {
	_JumpError(hr, error, "NotBefore too early");
    }

    // Check that NotAfter <= CA Certificate NotAfter

    if (0 < CompareFileTime(&pCertInfo->NotAfter, &pCACertInfo->NotAfter))
    {
	_JumpError(hr, error, "NotAfter too late");
    }

    pExtEnd = &pCert->pCertInfo->rgExtension[pCert->pCertInfo->cExtension];
    for (pExt = pCert->pCertInfo->rgExtension; pExt < pExtEnd; pExt++)
    {
        if (0 == strcmp(pExt->pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2))
        {
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_AUTHORITY_KEY_ID2,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pkeyAuth,
			    &cbkeyAuth))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }

	    // Check Issuer KeyId:

	    if (NULL != pCAContext->IssuerKeyId.pbData &&
		NULL != pkeyAuth->KeyId.pbData &&
		!myAreBlobsSame(
			pCAContext->IssuerKeyId.pbData,
			pCAContext->IssuerKeyId.cbData,
			pkeyAuth->KeyId.pbData,
			pkeyAuth->KeyId.cbData))
	    {
		_JumpError(hr, error, "Bad AuthorityKeyId KeyId");
	    }

	    // Check Issuer name:

	    if (1 == pkeyAuth->AuthorityCertIssuer.cAltEntry &&
		CERT_ALT_NAME_DIRECTORY_NAME ==
		pkeyAuth->AuthorityCertIssuer.rgAltEntry[0].dwAltNameChoice)
	    {
		pName = &pkeyAuth->AuthorityCertIssuer.rgAltEntry[0].DirectoryName;

		if (NULL != pName->pbData &&
		    !myAreBlobsSame(
			pCACertInfo->Issuer.pbData,
			pCACertInfo->Issuer.cbData,
			pName->pbData,
			pName->cbData))
		{
		    _JumpError(hr, error, "Bad AuthorityKeyId Issuer Name");
		}
	    }

	    // Check Issuer SerialNumber:

	    if (NULL != pkeyAuth->AuthorityCertSerialNumber.pbData &&
		!myAreSerialNumberBlobsSame(
			    &pCACertInfo->SerialNumber,
			    &pkeyAuth->AuthorityCertSerialNumber))
	    {
		_JumpError(hr, error, "Bad AuthorityKeyId Issuer Serial Number");
	    }
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != pkeyAuth)
    {
	LocalFree(pkeyAuth);
    }
    return(hr);
}


HRESULT
PKCSVerifyIssuedCertificate(
    IN CERT_CONTEXT const *pCert,
    OUT CACTX **ppCAContext)
{
    HRESULT hr;
    DWORD i;
    CACTX *pCAContext;

    *ppCAContext = NULL;

    CSASSERT(0 != g_cCACerts);
    for (i = g_cCACerts; i > 0; i--)
    {
	pCAContext = &g_aCAContext[i - 1];

	hr = pkcsVerifyCertIssuer(pCert, pCAContext);
	if (S_OK == hr)
	{
	    *ppCAContext = pCAContext;
	    break;
	}
	_PrintError2(hr, "pkcsVerifyCertIssuer", NTE_BAD_SIGNATURE);
    }

//error:
    return(hr);
}


HRESULT
pkcsSetCertHash(
    IN ICertDBRow *prow,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BSTR strHash = NULL;
    CACTX *pCAContext = g_pCAContextCurrent;

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pcc,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = prow->SetProperty(
		g_wszPropCertificateHash,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE const *) strHash);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
pkcsSetCertAndKeyHashes(
    IN ICertDBRow *prow,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strHash = NULL;

    hr = pkcsSetCertHash(prow, pcc);
    _JumpIfError(hr, error, "pkcsSetCertHash");

    hr = myGetPublicKeyHash(
		    pcc->pCertInfo,
		    &pcc->pCertInfo->SubjectPublicKeyInfo,
		    &pbHash,
		    &cbHash);
    _JumpIfError(hr, error, "myGetPublicKeyHash");

    hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = prow->SetProperty(
		g_wszPropCertificateSubjectKeyIdentifier,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE const *) strHash);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    return(hr);
}


HRESULT
PKCSParseImportedCertificate(
    IN DWORD Disposition,
    IN ICertDBRow *prow,
    OPTIONAL IN CACTX const *pCAContext,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    CERT_INFO const *pCertInfo = pCert->pCertInfo;
    DWORD dwRequestFlags = 0;
    BOOL fSubjectNameSet;
    HRESULT ErrCode = S_OK;
    BSTR strSerialNumber = NULL;

    // set raw cert property in the db
    hr = prow->SetProperty(
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		pCert->cbCertEncoded,
		pCert->pbCertEncoded);
    _JumpIfError(hr, error, "SetProperty");

    // set extensions
    hr = pkcsSetExtensions(
			prow,
			EXTENSION_ORIGIN_IMPORTEDCERT,
			pCertInfo->rgExtension,
			pCertInfo->cExtension);
    _JumpIfError(hr, error, "pkcsSetExtensions");

    // set request name info
    hr = pkcsSetRequestNameInfo(
			prow,
			&pCertInfo->Subject,
			NULL,		// pwszCNSuffix
			&dwRequestFlags,
			&fSubjectNameSet);
    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");

    hr = pkcsSetPublicKeyProperties(prow, &pCertInfo->SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = prow->CopyRequestNames();
    _JumpIfError(hr, error, "CopyRequestNames");

    hr = pkcsSetCertAndKeyHashes(prow, pCert);
    _JumpIfError(hr, error, "pkcsSetCertAndKeyHashes");

    hr = prow->SetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(pCertInfo->NotBefore),
                    (BYTE *) &pCertInfo->NotBefore);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCertificateNotAfterDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(pCertInfo->NotAfter),
                    (BYTE *) &pCertInfo->NotAfter);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		g_wszPropSubjectRawName,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		pCertInfo->Subject.cbData,
		pCertInfo->Subject.pbData);
    _JumpIfError(hr, error, "SetProperty");

    // set distinguished name
    pkcsSetDistinguishedName(
			prow,
			PROPTABLE_CERTIFICATE,
			&pCertInfo->Subject);

    // set disposition issued
    hr = prow->SetProperty(
			g_wszPropRequestDisposition,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(Disposition),
			(BYTE const *) &Disposition);
    _JumpIfError(hr, error, "SetProperty(disposition)");

    // set disposition status code
    hr = prow->SetProperty(
			g_wszPropRequestStatusCode,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(ErrCode),
			(BYTE const *) &ErrCode);
    _JumpIfError(hr, error, "SetProperty(status code)");

    if (NULL != pCAContext)
    {
	hr = prow->SetProperty(
		    g_wszPropCertificateIssuerNameID,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    sizeof(pCAContext->NameId),
		    (BYTE *) &pCAContext->NameId);
	_JumpIfError(hr, error, "SetProperty");
    }

    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestResolvedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    // Convert serial number to string and set in DB

    hr = MultiByteIntegerToBstr(
			FALSE,
			pCertInfo->SerialNumber.cbData,
			pCertInfo->SerialNumber.pbData,
			&strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = prow->SetProperty(
		g_wszPropCertificateSerialNumber,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE *) strSerialNumber);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != strSerialNumber)
    {
        SysFreeString(strSerialNumber);
    }
    return(hr);
}


// Return TRUE if Data and Cert references apply to the specified CMC message

BOOL
pkcsCMCReferenceMatch(
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN DWORD dwCmcDataReference,
    IN DWORD cCertReference,
    IN DWORD const *rgdwCertReference)
{
    BOOL fMatch = FALSE;
    DWORD i;

    if (MAXDWORD != DataReference && dwCmcDataReference == DataReference)
    {
	fMatch = TRUE;
    }
    else if (MAXDWORD != CertReference && 0 == dwCmcDataReference)
    {
	for (i = 0; i < cCertReference; i++)
	{
	    if (rgdwCertReference[i] == CertReference)
	    {
		fMatch = TRUE;
		break;
	    }
	}
    }
    return(fMatch);
}


HRESULT
pkcsSetCMCExtensions(
    IN ICertDBRow *prow,
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN BYTE const *pbData,
    IN DWORD cbData)
{
    HRESULT hr;
    CMC_ADD_EXTENSIONS_INFO *pcmcExt = NULL;
    DWORD cb;

    // Decode CMC_ADD_EXTENSIONS_INFO from Attribute Blob

    CSASSERT(NULL == pcmcExt);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_EXTENSIONS,
		    pbData,
		    cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcExt,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (pkcsCMCReferenceMatch(
		    DataReference,
		    CertReference,
		    pcmcExt->dwCmcDataReference,
		    pcmcExt->cCertReference,
		    pcmcExt->rgdwCertReference))
    {
	hr = pkcsSetExtensions(
			prow,
			EXTENSION_ORIGIN_CMC | EXTENSION_DISABLE_FLAG,
			pcmcExt->rgExtension,
			pcmcExt->cExtension);
	_JumpIfError(hr, error, "pkcsSetExtensions(request)");
    }
    hr = S_OK;

error:
    if (NULL != pcmcExt)
    {
	LocalFree(pcmcExt);
    }
    return(hr);
}


HRESULT
pkcsSetCMCAttributes(
    IN ICertDBRow *prow,
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN BYTE const *pbData,
    IN DWORD cbData,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    DWORD cb;

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }

    // Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

    CSASSERT(NULL == pcmcAttrib);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    pbData,
		    cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcAttrib,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (pkcsCMCReferenceMatch(
		    DataReference,
		    CertReference,
		    pcmcAttrib->dwCmcDataReference,
		    pcmcAttrib->cCertReference,
		    pcmcAttrib->rgdwCertReference))
    {
	hr = pkcsSetAttributes(
			prow,
			EXTENSION_ORIGIN_CMC,
			PSA_DISALLOW_EXTENSIONS | PSA_DISALLOW_ARCHIVEDKEY,
			pcmcAttrib->rgAttribute,
			pcmcAttrib->cAttribute,
			0,
			NULL,
			pfEnrollOnBehalfOf,
			pResult);
	_JumpIfError(hr, error, "pkcsSetAttributes(CMC)");
    }
    hr = S_OK;

error:
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    return(hr);
}


// map "email_mail" to "email"
// map "email_*" to "*"?
// mail_firstName=Terry&mail_lastName=Cheung+CMC+Zero+2&mail_email=
// tcheung%40verisign%2Ecom&challenge=test&

HRESULT
pkcsSetCMCRegInfo(
    IN ICertDBRow *prow,
    IN BYTE const *pbOctet,
    IN DWORD cbOctet,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf)
{
    HRESULT hr;
    WCHAR *pwszRA = NULL;

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    hr = myDecodeCMCRegInfo(pbOctet, cbOctet, &pwszRA);
    _JumpIfError(hr, error, "myDecodeCMCRegInfo");

    hr = PKCSParseAttributes(
			prow,
			pwszRA,
			TRUE,
			PROPTABLE_REQUEST,
			pfEnrollOnBehalfOf);
    _JumpIfError(hr, error, "PKCSParseAttributes");

error:
    if (NULL != pwszRA)
    {
	LocalFree(pwszRA);
    }
    return(hr);
}


HRESULT
pkcsSetTaggedAttributes(
    IN ICertDBRow *prow,
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN CMC_TAGGED_ATTRIBUTE const *pTaggedAttribute,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD i;
    CRYPT_ATTRIBUTE const *pAttribute = &pTaggedAttribute->Attribute;
    DWORD cb;
    BOOL fEnrollOnBehalfOf;

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    for (i = 0; i < pAttribute->cValue; i++)
    {
	if (0 == strcmp(szOID_CMC_ADD_EXTENSIONS, pAttribute->pszObjId))
	{
	    hr = pkcsSetCMCExtensions(
				prow,
				DataReference,
				CertReference,
				pAttribute->rgValue[i].pbData,
				pAttribute->rgValue[i].cbData);
	    _JumpIfError(hr, error, "pkcsSetCMCExtensions");
	}
	else
	if (0 == strcmp(szOID_CMC_ADD_ATTRIBUTES, pAttribute->pszObjId))
	{
	    fEnrollOnBehalfOf = FALSE;

	    hr = pkcsSetCMCAttributes(
			prow,
			DataReference,
			CertReference,
			pAttribute->rgValue[i].pbData,
			pAttribute->rgValue[i].cbData,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL,
			pResult);
	    _JumpIfError(hr, error, "pkcsSetCMCAttributes");

	    if (fEnrollOnBehalfOf)
	    {
		CSASSERT(NULL != pfEnrollOnBehalfOf);
		*pfEnrollOnBehalfOf = TRUE;
	    }
	}
	else
	if (0 == strcmp(szOID_CMC_REG_INFO, pAttribute->pszObjId))
	{
	    fEnrollOnBehalfOf = FALSE;

	    hr = pkcsSetCMCRegInfo(
			prow,
			pAttribute->rgValue[i].pbData,
			pAttribute->rgValue[i].cbData,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL);
	    _JumpIfError(hr, error, "pkcsSetCMCRegInfo");

	    if (fEnrollOnBehalfOf)
	    {
		CSASSERT(NULL != pfEnrollOnBehalfOf);
		*pfEnrollOnBehalfOf = TRUE;
	    }
	}
	else
	if (0 == strcmp(szOID_CMC_TRANSACTION_ID, pAttribute->pszObjId))
	{
	    DWORD dwTransactionId;
	    
	    cb = sizeof(dwTransactionId);
	    dwTransactionId = 0;
	    if (!CryptDecodeObject(
				X509_ASN_ENCODING,
				X509_INTEGER,
				pAttribute->rgValue[i].pbData,
				pAttribute->rgValue[i].cbData,
				0,
				&dwTransactionId,
				&cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptDecodeObject");
	    }
	    pResult->fTransactionId = TRUE;
	    pResult->dwTransactionId = dwTransactionId;
	}
	else
	if (0 == strcmp(szOID_CMC_SENDER_NONCE, pAttribute->pszObjId))
	{
	    CRYPT_DATA_BLOB *pBlob;
	    BYTE *pb;

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pAttribute->rgValue[i].pbData,
			    pAttribute->rgValue[i].cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pBlob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, pBlob->cbData);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
	    }
	    else
	    {
		CopyMemory(pb, pBlob->pbData, pBlob->cbData);
		if (NULL != pResult->pbSenderNonce)
		{
		    LocalFree(pResult->pbSenderNonce);
		}
		pResult->pbSenderNonce = pb;
		pResult->cbSenderNonce = pBlob->cbData;
		hr = S_OK;
	    }
	    LocalFree(pBlob);
	    _JumpIfError(hr, error, "LocalAlloc");
	}
	else if (0 == (CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES & g_dwCRLFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "unknown tagged attribute");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+------------------------------------------------------------------------
// pkcsParseCMCRequest
//
// Crack a CMC request and dig the goodies out of it.
// Crack the contents of the CMC request recursively.
//-------------------------------------------------------------------------

HRESULT
pkcsParseCMCRequest(
    IN ICertDBRow *prow,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    OPTIONAL OUT BOOL *pfRenewal,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD cb;
    CMC_DATA_INFO const *pcmcData = NULL;
    DWORD i;
    DWORD DataReference = MAXDWORD;	// nested CMC message Body Part Id
    DWORD CertReference = MAXDWORD;	// PKCS10 Cert Request Body Part Id

    if (NULL != pfRenewal)
    {
	*pfRenewal = FALSE;
    }
    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcData,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (0 != pcmcData->cTaggedOtherMsg)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "unknown other message");
    }

    // Process nested CMC messages

    if (0 != pcmcData->cTaggedContentInfo)
    {
	CMC_TAGGED_CONTENT_INFO const *pTaggedContentInfo;

	// Only handle one CMC message at a time for now.

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	if (1 < pcmcData->cTaggedContentInfo)
	{
	    _JumpError(hr, error, "multiple nested CMC messages");
	}

	// Disallow CMC message recursion below a PKCS10 request.

	if (0 != pcmcData->cTaggedRequest)
	{
	    _JumpError(hr, error, "recursion below PKCS10 request");
	}

	// Recurse on the nested CMC message

	pTaggedContentInfo = &pcmcData->rgTaggedContentInfo[0];

	hr = PKCSParseRequest(
			CR_IN_CMC | (~CR_IN_FORMATMASK & pResult->dwFlagsTop),
			prow,
			pTaggedContentInfo->EncodedContentInfo.cbData,
			pTaggedContentInfo->EncodedContentInfo.pbData,
			pCertSigner,
			pfRenewal,
			pResult);
	_JumpIfError(hr, error, "PKCSParseRequest");

	DataReference = pTaggedContentInfo->dwBodyPartID;
    }

    // Process nested PKCS10 requests

    if (0 != pcmcData->cTaggedRequest)
    {
	CMC_TAGGED_REQUEST const *pTaggedRequest;
	CMC_TAGGED_CERT_REQUEST const *pTaggedCertRequest;

	// Only handle one request at a time for now.

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	if (1 < pcmcData->cTaggedRequest)
	{
	    _JumpError(hr, error, "multiple PKCS10 requests");
	}

	pTaggedRequest = &pcmcData->rgTaggedRequest[0];

	// The request must be a PKCS10 request

	if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
	    pTaggedRequest->dwTaggedRequestChoice)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "recursion below PKCS10 request");
	}

	pTaggedCertRequest = pTaggedRequest->pTaggedCertRequest;

	hr = PKCSParseRequest(
		    CR_IN_PKCS10 | (~CR_IN_FORMATMASK & pResult->dwFlagsTop),
		    prow,
		    pTaggedCertRequest->SignedCertRequest.cbData,
		    pTaggedCertRequest->SignedCertRequest.pbData,
		    pCertSigner,
		    pfRenewal,
		    pResult);
	_JumpIfError(hr, error, "PKCSParseRequest");

	CertReference = pTaggedCertRequest->dwBodyPartID;
    }

    // Process extensions and attributes

    for (i = 0; i < pcmcData->cTaggedAttribute; i++)
    {
	hr = pkcsSetTaggedAttributes(
			prow,
			DataReference,
			CertReference,
			&pcmcData->rgTaggedAttribute[i],
			pfEnrollOnBehalfOf,
			pResult);
	_JumpIfError(hr, error, "pkcsSetTaggedAttributes");
    }
    hr = S_OK;

error:
    if (NULL != pcmcData)
    {
	LocalFree((VOID *) pcmcData);
    }
    return(hr);
}


HRESULT
pkcsAppendPolicies(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    OPTIONAL IN WCHAR const *pwszzPolicies)
{
    HRESULT hr;
    WCHAR *pwszOld = NULL;
    WCHAR *pwszNew = NULL;
    WCHAR const *pwszIn;
    WCHAR *pwsz;
    DWORD cwc = 0;
    DWORD cb;

    hr = PKCSGetProperty(
		prow,
		pwszPropName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cb,
		(BYTE **) &pwszOld);
    _PrintIfError2(hr, "PKCSGetProperty", hr);
    if (S_OK != hr)
    {
	pwszOld = NULL;
    }
    if (NULL != pwszOld)
    {
	cwc = wcslen(pwszOld) + 1;	// allow for \n separator
    }
    if (NULL == pwszzPolicies || L'\0' == *pwszzPolicies)
    {
	pwszzPolicies = L"-\0";
    }
    for (pwszIn = pwszzPolicies; L'\0' != *pwszIn; pwszIn += wcslen(pwszIn) + 1)
	    ;

    cwc += SAFE_SUBTRACT_POINTERS(pwszIn, pwszzPolicies);
    pwszNew = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pwsz = pwszNew;

    if (NULL != pwszOld)
    {
	wcscpy(pwsz, pwszOld);
	pwsz += wcslen(pwsz);

	wcscpy(pwsz, L"\n");
	pwsz++;
    }

    for (pwszIn = pwszzPolicies; L'\0' != *pwszIn; pwszIn += wcslen(pwszIn) + 1)
    {
	if (pwszIn != pwszzPolicies)
	{
	    wcscpy(pwsz, L",");
	    pwsz++;
	}
	wcscpy(pwsz, pwszIn);
	pwsz += wcslen(pwsz);
    }
    CSASSERT(&pwsz[1] == &pwszNew[cwc]);

    hr = prow->SetProperty(
	    pwszPropName,
	    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
	    MAXDWORD,
	    (BYTE const *) pwszNew);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != pwszOld)
    {
	LocalFree(pwszOld);
    }
    if (NULL != pwszNew)
    {
	LocalFree(pwszNew);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// pkcsParsePKCS7Request
//
// Crack a PKCS7 and dig the goodies out of it.
// Verify the signature of the 7 against the cert given in the 7.
// Crack the contents of the 7 recursively.
//-------------------------------------------------------------------------

HRESULT
pkcsParsePKCS7Request(
    IN BOOL fTopLevel,
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    CERT_CONTEXT const *pCertSigner = NULL;
    HCERTSTORE hStore = NULL;
    HCRYPTMSG hMsg = NULL;
    char *pszInnerContentObjId = NULL;
    DWORD i;
    BOOL fCMC;
    BOOL fRenewal = FALSE;
    DWORD cbAttrib;
    char *apszEnrollOids[] = {szOID_ENROLLMENT_AGENT};
    DWORD dwVerifyContextFlags;
    DWORD dwMsgType;
    DWORD cSigner;
    DWORD cFirstSigner;
    BOOL fFirstSigner;
    DWORD cRecipient;
    DWORD cb;
    CMSG_CMS_SIGNER_INFO *pcsi = NULL;
    DWORD dwDisallowFlags;
    DWORD iElement;
    WCHAR *pwszzIssuancePolicies = NULL;
    WCHAR *pwszzApplicationPolicies = NULL;
    CERT_REQUEST_INFO *pRequest = NULL;
    BOOL fEnrollOnBehalfOf;

    CSASSERT(
	CR_IN_PKCS7 == (CR_IN_FORMATMASK & dwFlags) ||
	CR_IN_CMC == (CR_IN_FORMATMASK & dwFlags));

    // Crack the 7 and verify the signature.

    hr = myDecodePKCS7(
		    pbIn,
		    cbIn,
		    &pbContents,
		    &cbContents,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    &hStore,
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7");

    if (CMSG_SIGNED != dwMsgType || 0 == cSigner)
    {
	hr = CRYPT_E_NO_SIGNER;
	_JumpIfError(hr, error, "myDecodePKCS7(no signing cert)");
    }

#define szOID_CT_PKI_DATA_OLDRFC     "1.3.6.1.5.5.7.5.2" // BUGBUG: temporary!
    fCMC = NULL != pszInnerContentObjId &&
	   (0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA) ||
	    (0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA_OLDRFC) &&
	     (CRLF_ACCEPT_OLDRFC_CMC & g_dwCRLFlags)));


    // Decode the contents.

    if (fCMC)
    {
	if (CR_IN_CMC != (CR_IN_FORMATMASK & dwFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwFlags");
	}
	// CMC renewal requests may have one 'first' signer (non-NULL KeyId or
	// Dummy signer) and one additional Issuer+Serial signer.  If the
	// request has the appropriate signatures, pass the cert to the lowest
	// level to see if it really is a renewal request.

	if (1 <= cSigner && 2 >= cSigner)
	{
	    DWORD iCertSigner = MAXDWORD;

	    cFirstSigner = 0;
	    for (i = 0; i < cSigner; i++)
	    {
		if (NULL != pcsi)
		{
		    LocalFree(pcsi);
		    pcsi = NULL;
		}
		hr = myCryptMsgGetParam(
				    hMsg,
				    CMSG_CMS_SIGNER_INFO_PARAM,
				    i,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pcsi,
				    &cb);
		_JumpIfError(hr, error, "myCryptMsgGetParam");

		fFirstSigner = FALSE;
		if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
		    (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
		     0 == strcmp(
			    szOID_PKIX_NO_SIGNATURE,
			    pcsi->HashEncryptionAlgorithm.pszObjId)))
		{
		    fFirstSigner = TRUE;
		}
		else if ((CRLF_ACCEPT_OLDRFC_CMC & g_dwCRLFlags) &&
		    CERT_ID_ISSUER_SERIAL_NUMBER == pcsi->SignerId.dwIdChoice)
		{
		    hr = myIsFirstSigner(
				    &pcsi->SignerId.IssuerSerialNumber.Issuer,
				    &fFirstSigner);
		    _JumpIfError(hr, error, "myIsFirstSigner");
		}

		if (fFirstSigner)
		{
		    cFirstSigner++;
		}
		else
		{
		    if (MAXDWORD != iCertSigner)
		    {
			iCertSigner = MAXDWORD;	// must not be a renewal
			break;
		    }
		    iCertSigner = i;
		}
	    }
	    if (MAXDWORD != iCertSigner && 1 >= cFirstSigner)
	    {
		iElement = iCertSigner;
		if (!CryptMsgGetAndVerifySigner(
					hMsg,
					0,		// cSignerStore
					NULL,		// rghSignerStore
					CMSG_USE_SIGNER_INDEX_FLAG,
					&pCertSigner,
					&iElement))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
		}
	    }
	}
	fEnrollOnBehalfOf = FALSE;
	hr = pkcsParseCMCRequest(
			    prow,
			    cbContents,
			    pbContents,
			    pCertSigner,
			    &fRenewal,
			    &fEnrollOnBehalfOf,
			    pResult);
	_JumpIfError(hr, error, "pkcsParseCMCRequest");

	if (fEnrollOnBehalfOf)
	{
	    pResult->fEnrollOnBehalfOf = TRUE;
	}
	if (0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA_OLDRFC))
	{
	    hr = PKCSSetRequestFlags(prow, TRUE, CR_FLG_OLDRFCCMC);
	    _JumpIfError(hr, error, "PKCSSetRequestFlags");
	}
    }
    else
    {
	if (CR_IN_PKCS7 != (CR_IN_FORMATMASK & dwFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwFlags");
	}

	// Expect only one signer for PKCS7 renewal requests.  Pass the cert
	// to the lowest level to see if it really is a renewal request.

	iElement = 0;
	if (!CryptMsgGetAndVerifySigner(
				hMsg,
				0,		// cSignerStore
				NULL,		// rghSignerStore
				CMSG_USE_SIGNER_INDEX_FLAG,
				&pCertSigner,
				&iElement))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
	}
	hr = PKCSParseRequest(
		CR_IN_FORMATANY | (~CR_IN_FORMATMASK & pResult->dwFlagsTop),
		prow,
		cbContents,
		pbContents,
		pCertSigner,
		&fRenewal,
		pResult);
	_JumpIfError(hr, error, "PKCSParseRequest");
    }

    // Loop through the signers, verifying signatures and saving attributes.

    cFirstSigner = 0;
    for (i = 0; i < cSigner; i++)
    {
	BOOL fNTAuth;
	BOOL fEnrollOnBehalfOf;

	if (NULL != pcsi)
	{
	    LocalFree(pcsi);
	    pcsi = NULL;
	}
	if (NULL != pwszzIssuancePolicies)
	{
	    LocalFree(pwszzIssuancePolicies);
	    pwszzIssuancePolicies = NULL;
	}
	if (NULL != pwszzApplicationPolicies)
	{
	    LocalFree(pwszzApplicationPolicies);
	    pwszzApplicationPolicies = NULL;
	}
	if (NULL != pCertSigner)
	{
	    CertFreeCertificateContext(pCertSigner);
	    pCertSigner = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_CMS_SIGNER_INFO_PARAM,
			    i,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pcsi,
			    &cb);
	_JumpIfError(hr, error, "myCryptMsgGetParam");

	fFirstSigner = FALSE;
	if (fCMC &&
	    (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
	     (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
	      0 == strcmp(
		    szOID_PKIX_NO_SIGNATURE,
		    pcsi->HashEncryptionAlgorithm.pszObjId))))
	{
	    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cvse;

	    fFirstSigner = TRUE;
	    ZeroMemory(&cvse, sizeof(cvse));
	    cvse.cbSize = sizeof(cvse);
	    cvse.dwSignerIndex = i;

	    if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice)
	    {
		if (NULL == pRequest)
		{
		    hr = myGetInnerPKCS10(
				    hMsg,
				    pszInnerContentObjId,
				    &pRequest);
		    _JumpIfError(hr, error, "myGetInnerPKCS10");
		}
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
		cvse.pvSigner = &pRequest->SubjectPublicKeyInfo;
	    }
	    else
	    {
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
	    }

	    if (!CryptMsgControl(
			    hMsg,
			    0,		// dwFlags
			    CMSG_CTRL_VERIFY_SIGNATURE_EX,
			    &cvse))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgControl(VerifySig)");
	    }
	}
	else
	{
	    if (fCMC &&
		(CRLF_ACCEPT_OLDRFC_CMC & g_dwCRLFlags) &&
		CERT_ID_ISSUER_SERIAL_NUMBER == pcsi->SignerId.dwIdChoice)
	    {
		hr = myIsFirstSigner(
				&pcsi->SignerId.IssuerSerialNumber.Issuer,
				&fFirstSigner);
		_JumpIfError(hr, error, "myIsFirstSigner");
	    }
	    iElement = i;
	    if (!CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,			// cSignerStore
				    NULL,		// rghSignerStore
				    CMSG_USE_SIGNER_INDEX_FLAG,
				    &pCertSigner,
				    &iElement))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgGetAndVerifySigner");
	    }
	}

	// Only enroll-on-behalf-of requests may contain Name, Value pairs.
	// Only enroll-on-behalf-of requests and renewal requests may contain
	// certificate extensions.

	dwDisallowFlags = PSA_DISALLOW_ARCHIVEDKEY;
	if (fRenewal)
	{
	    dwDisallowFlags |= PSA_DISALLOW_NAMEVALUEPAIRS;
	}
	if (fCMC)
	{
	    dwDisallowFlags |= PSA_DISALLOW_EXTENSIONS |
			       PSA_DISALLOW_NAMEVALUEPAIRS;
	}
	fEnrollOnBehalfOf = FALSE;
	hr = pkcsSetAttributes(
			prow,
			EXTENSION_ORIGIN_PKCS7,
			dwDisallowFlags,
			pcsi->AuthAttrs.rgAttr,
			pcsi->AuthAttrs.cAttr,
			0,
			NULL,
			&fEnrollOnBehalfOf,
			pResult);
	_JumpIfError(hr, error, "pkcsSetAttributes(Authenticated)");

	if (fEnrollOnBehalfOf)
	{
	    pResult->fEnrollOnBehalfOf = TRUE;
	}

	// Pull encrypted private key out of unauthenticated attributes

	hr = pkcsSetAttributes(
			prow,
			EXTENSION_ORIGIN_PKCS7,
			((fTopLevel && fFirstSigner)? 0 :  PSA_DISALLOW_ARCHIVEDKEY) |
			    PSA_DISALLOW_EXTENSIONS |
			    PSA_DISALLOW_NAMEVALUEPAIRS,
			pcsi->UnauthAttrs.rgAttr,
			pcsi->UnauthAttrs.cAttr,
			cbIn,
			fTopLevel? pbIn : NULL,
			NULL,
			pResult);
	_JumpIfError(hr, error, "pkcsSetAttributes(UNauthenticated)");

	if (fFirstSigner)
	{
	    cFirstSigner++;
	}
	else
	{
	    // This is a renewal request, an enroll-on-behalf-of request, a CMC
	    // request or just a request inside a PKCS 7 -- verify the cert
	    // chain for all signers.  If enroll-on-behalf-of on an Enterprise
	    // CA (if requester name is set in the authenticated attributes),
	    // check the signing cert via NTAuth policy and check for
	    // szOID_ENROLLMENT_AGENT usage.  NtAuth verification was added to
	    // control the ability of enroll-on-behalf agents to add usernames
	    // to the PKCS7 wrapper.

	    fNTAuth = pResult->fEnrollOnBehalfOf && IsEnterpriseCA(g_CAType);
	    dwVerifyContextFlags = 0;
	    if (CRLF_REVCHECK_IGNORE_OFFLINE & g_dwCRLFlags)
	    {
		dwVerifyContextFlags |= CA_VERIFY_FLAGS_IGNORE_OFFLINE;
	    }
	    if (fNTAuth)
	    {
		dwVerifyContextFlags |= CA_VERIFY_FLAGS_NT_AUTH;
	    }

	    hr = myVerifyCertContextEx(
			    pCertSigner,
			    dwVerifyContextFlags,
			    (DWORD)(fNTAuth? ARRAYSIZE(apszEnrollOids) : 0),
			    fNTAuth? apszEnrollOids : NULL,
			    HCCE_LOCAL_MACHINE,		// hChainEngine
			    NULL,			// pft
			    hStore,			// hAdditionalStore
			    NULL,			// ppwszMissingIssuer
			    &pwszzIssuancePolicies,
			    &pwszzApplicationPolicies);
	    _JumpIfError(hr, error, "myVerifyCertContextEx");

	    if (fTopLevel)
	    {
		// save Issuance Policies

		hr = pkcsAppendPolicies(
				    prow,
				    wszPROPSIGNERPOLICIES,
				    pwszzIssuancePolicies);
		_JumpIfError(hr, error, "pkcsAppendPolicies");

		// save Application Policies

		hr = pkcsAppendPolicies(
				    prow,
				    wszPROPSIGNERAPPLICATIONPOLICIES,
				    pwszzApplicationPolicies);
		_JumpIfError(hr, error, "pkcsAppendPolicies");
	    }
	}
    }
    if (pResult->fEnrollOnBehalfOf)
    {
	hr = PKCSSetRequestFlags(prow, TRUE, CR_FLG_ENROLLONBEHALFOF);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");

	if (fCMC && cSigner == cFirstSigner)
	{
	    hr = CRYPT_E_NO_TRUSTED_SIGNER;
	    _JumpError(hr, error, "No NTAuth signer");
	}
    }
    if ((fCMC && 1 < cFirstSigner) || (!fCMC && 0 < cFirstSigner))
    {
	hr = NTE_BAD_SIGNATURE;
	_JumpError(hr, error, "cFirstSigner");
    }

error:
    if (NULL != pRequest)
    {
	LocalFree(pRequest);
    }
    if (NULL != pcsi)
    {
	LocalFree(pcsi);
    }
    if (NULL != pwszzIssuancePolicies)
    {
	LocalFree(pwszzIssuancePolicies);
    }
    if (NULL != pwszzApplicationPolicies)
    {
	LocalFree(pwszzApplicationPolicies);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pCertSigner)
    {
	CertFreeCertificateContext(pCertSigner);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbContents)
    {
	LocalFree(pbContents);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    return(hr);
}


typedef struct _REQUESTFORMATS
{
    char const *pszFormat;
    DWORD       dwFlags;
} REQUESTFORMATS;


REQUESTFORMATS g_arf[] = {
    { X509_CERT_REQUEST_TO_BE_SIGNED,   CR_IN_PKCS10 },
    { X509_KEYGEN_REQUEST_TO_BE_SIGNED, CR_IN_KEYGEN },
};
#define CREQUESTFORMATS		ARRAYSIZE(g_arf)


HRESULT
pkcsCrackRequestType(
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    OUT DWORD *pdwFlags)
{
    HRESULT hr;
    DWORD cb;
    BYTE *pbDecoded = NULL;
    REQUESTFORMATS const *prf;
    REQUESTFORMATS const *prfEnd;
    HCRYPTMSG hMsg = NULL;
    char *pszInnerContentObjId = NULL;

    prfEnd = &g_arf[CREQUESTFORMATS];
    for (prf = g_arf; prf < prfEnd; prf++)
    {
	CSASSERT(NULL == pbDecoded);
	if (myDecodeObject(
			X509_ASN_ENCODING,
			prf->pszFormat,
			pbRequest,
			cbRequest,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cb))
	{
	    *pdwFlags = prf->dwFlags;
	    break;
	}
	hr = myHLastError();
	CSASSERT(S_OK != hr);
    }
    if (prf >= prfEnd)
    {
	CSASSERT(S_OK != hr);

	hr = myDecodePKCS7(
			pbRequest,
			cbRequest,
			NULL,		// ppbContents
			NULL,		// pcbContents
			NULL,		// pdwMsgType
			&pszInnerContentObjId,
			NULL,		// pcSigner
			NULL,		// pcRecipient
			NULL,		// phStore
			&hMsg);
	_JumpIfError(hr, error, "myDecodePKCS7");

	*pdwFlags = CR_IN_PKCS7;	// default to renewal

	if (NULL != pszInnerContentObjId &&
	    (0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA) ||
	     0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA_OLDRFC)))
	{
	    *pdwFlags = CR_IN_CMC;
	}
    }
    hr = S_OK;

error:
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    return(hr);
}


HRESULT
PKCSParseRequest(
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN CERT_CONTEXT const *pSigningAuthority,
    OPTIONAL OUT BOOL *pfRenewal,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;

    if (NULL != pfRenewal)
    {
	*pfRenewal = FALSE;
    }

    if (CR_IN_FORMATANY == (CR_IN_FORMATMASK & dwFlags))
    {
	hr = pkcsCrackRequestType(cbRequest, pbRequest, &dwFlags);
	_JumpIfError(hr, error, "pkcsCrackRequestType");

	dwFlags |= ~CR_IN_FORMATMASK & pResult->dwFlagsTop;

	// If this is the top level caller, store a more specific request type:

	if (NULL == pfRenewal)
	{
	    pResult->dwFlagsTop = dwFlags;
	    hr = prow->SetProperty(
		g_wszPropRequestType,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		sizeof(dwFlags),
		(BYTE const *) &dwFlags);
	    _JumpIfError(hr, error, "SetProperty(reqtype)");
	}
    }

    switch (CR_IN_FORMATMASK & dwFlags)
    {
	case CR_IN_PKCS10:
	    hr = pkcsParsePKCS10Request(
				    dwFlags,
				    prow,
				    cbRequest,
				    pbRequest,
				    pSigningAuthority,
				    pfRenewal,
				    pResult);
	    _JumpIfError(hr, error, "pkcsParsePKCS10Request");
	    break;

	case CR_IN_KEYGEN:
	    hr = pkcsParseKeyGenRequest(
				    dwFlags,
				    prow,
				    cbRequest,
				    pbRequest,
				    pResult);
	    _JumpIfError(hr, error, "pkcsParseKeyGenRequest");
	    break;

	case CR_IN_CMC:
	case CR_IN_PKCS7:
	    // PKCS7 requests can either be an 'enroll on behalf of', renewal
	    // request or a CMC request.  We need to recursively unwrap it to
	    // process it.

	    hr = pkcsParsePKCS7Request(
				NULL == pfRenewal,	// fTopLevel
				dwFlags,
				prow,
				cbRequest,
				pbRequest,
				pResult);
	    _JumpIfError(hr, error, "pkcsParsePKCS7Request");

	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwFlags");
    }

error:
    if (NULL == pfRenewal)
    {
	HRESULT hr2;
	DWORD cbData;

	hr2 = prow->GetProperty(
		    g_wszPropRequestRawRequest,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &cbData,
		    NULL);
	if (S_OK != hr2)
	{
	    hr2 = prow->SetProperty(
			g_wszPropRequestRawRequest,
			PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			cbRequest,
			pbRequest);
	    _PrintIfError(hr2, "SetProperty(request)");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    return(hr);
}


HRESULT
PKCSGetCRLList(
    IN BOOL fDelta,
    IN DWORD iCert,
    OUT WCHAR const * const **ppapwszCRLList)
{
    HRESULT hr = E_INVALIDARG;

    *ppapwszCRLList = NULL;
    if (iCert < g_cCACerts)
    {
	CACTX *pCAContext = &g_aCAContext[iCert];

	if (NULL == pCAContext->pccCA)
	{
	    hr = S_FALSE;
	    goto error;
	}
	*ppapwszCRLList = fDelta?
			    pCAContext->papwszDeltaCRLFiles :
			    pCAContext->papwszCRLFiles;
	if (NULL != *ppapwszCRLList)
	{
	    hr = S_OK;
	}
    }
error:
    return(hr);
}


HRESULT
pkcsBuildCRLList(
    IN BOOL fDelta,
    IN OUT CACTX *pCAContext,
    OUT WCHAR ***ppapwszOut)
{
    HRESULT hr;
    DWORD cFiles;
    CSURLTEMPLATE const *pTemplate;
    CSURLTEMPLATE const *pTemplateEnd;

    cFiles = 0;
    pTemplateEnd = &g_paRevURL[g_caRevURL];
    for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (CSURL_SERVERPUBLISH & pTemplate->Flags)
	{
	    cFiles++;
	}
    }
    *ppapwszOut = (WCHAR **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				(cFiles + 1) * sizeof((*ppapwszOut)[0]));
    if (NULL == *ppapwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    DBGPRINT((
	DBG_SS_CERTSRVI,
	"CRLList alloc[%u] = %x @%x\n",
	cFiles,
	*ppapwszOut,
	ppapwszOut));

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    cFiles = 0;
    for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (CSURL_SERVERPUBLISH & pTemplate->Flags)
	{
	    hr = myFormatCertsrvStringArray(
		    FALSE,			// fURL
		    g_pwszServerName,		// pwszServerName_p1_2
		    g_wszSanitizedName,		// pwszSanitizedName_p3_7
		    pCAContext->iKey,		// iCert_p4 -- use iKey!!
		    g_strDomainDN,		// pwszDomainDN_p5
		    g_strConfigDN,		// pwszConfigDN_p6
		    pCAContext->iKey,		// iCRL_p8
		    fDelta,			// fDeltaCRL_p9
		    FALSE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pTemplate->pwszURL, // apwszStringsIn
		    &(*ppapwszOut)[cFiles]);	     // apwszStringsOut
	    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"CRLList format[%u] = %x @%x (%ws)\n",
		cFiles,
		(*ppapwszOut)[cFiles],
		&(*ppapwszOut)[cFiles],
		(*ppapwszOut)[cFiles]));

	    cFiles++;
	}
    }
    (*ppapwszOut)[cFiles] = NULL;
    hr = S_OK;

error:
    // Freeing the CACTX structure during shutdown will free orphaned CRL paths
    return(hr);
}


HRESULT
pkcsBuildKeyAuthority2(
    IN DWORD EditFlags,
    IN CACTX const *pCAContext,
    OUT CRYPT_OBJID_BLOB *pKeyAuthority2)
{
    HRESULT hr = S_OK;
    CERT_AUTHORITY_KEY_ID2_INFO keyAuth;
    CERT_ALT_NAME_ENTRY AltNameEntry;

    if (0 ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL) & EditFlags))
    {
	goto error;
    }
    ZeroMemory(&keyAuth, sizeof(keyAuth));

    // Issuer's KeyId:

    if ((EDITF_ENABLEAKIKEYID & EditFlags) &&
	NULL != pCAContext->IssuerKeyId.pbData)
    {
	keyAuth.KeyId = pCAContext->IssuerKeyId;
    }

    // The Issuer's Issuer name and the Issuer's SerialNumber combined
    // should uniquely identify the Issuer cert.

    // Issuer's Issuer name:
    // -------- ------ ----

    if (EDITF_ENABLEAKIISSUERNAME & EditFlags)
    {
	AltNameEntry.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
	AltNameEntry.DirectoryName = pCAContext->pccCA->pCertInfo->Issuer;
	keyAuth.AuthorityCertIssuer.cAltEntry = 1;
	keyAuth.AuthorityCertIssuer.rgAltEntry = &AltNameEntry;
    }

    // Issuer's SerialNumber:

    if (EDITF_ENABLEAKIISSUERSERIAL & EditFlags)
    {
	keyAuth.AuthorityCertSerialNumber =
	    pCAContext->pccCA->pCertInfo->SerialNumber;
    }

    // put in Key Authority Info

    if (!myEncodeKeyAuthority2(
			X509_ASN_ENCODING,
			&keyAuth,
			CERTLIB_USE_LOCALALLOC,
			&pKeyAuthority2->pbData,
			&pKeyAuthority2->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeKeyAuthority2");
    }

error:
    return(hr);
}


HRESULT
pkcsBuildCDP(
    IN DWORD Flags,
    IN BOOL fDelta,
    IN CACTX const *pCAContext,
    OUT CRYPT_OBJID_BLOB *pCDP)
{
    HRESULT hr;
    DWORD i;
    CSURLTEMPLATE const *pTemplate;
    CSURLTEMPLATE const *pTemplateEnd;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    CRL_DIST_POINT CRLDistPoint;
    CERT_ALT_NAME_INFO *pAltInfo;

    ZeroMemory(&CRLDistPoint, sizeof(CRLDistPoint));
    pAltInfo = &CRLDistPoint.DistPointName.FullName;

    pCDP->pbData = NULL;
    pCDP->cbData = 0;

    if (0 != g_caRevURL)
    {
	pTemplateEnd = &g_paRevURL[g_caRevURL];
	for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
	{
	    if (Flags & pTemplate->Flags)
	    {
		pAltInfo->cAltEntry++;
	    }
	}
    }
    if (0 == pAltInfo->cAltEntry)
    {
	hr = S_FALSE;
	goto error;
    }

    CRLDistInfo.cDistPoint = 1;
    CRLDistInfo.rgDistPoint = &CRLDistPoint;

    CRLDistPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;

    pAltInfo->rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			pAltInfo->cAltEntry * sizeof(pAltInfo->rgAltEntry[0]));
    if (NULL == pAltInfo->rgAltEntry)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    i = 0;
    for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (Flags & pTemplate->Flags)
	{
	    hr = myFormatCertsrvStringArray(
		    TRUE,			// fURL
		    g_pwszServerName,		// pwszServerName_p1_2
		    g_wszSanitizedName,		// pwszSanitizedName_p3_7
		    pCAContext->iCert,		// iCert_p4
		    g_strDomainDN,		// pwszDomainDN_p5
		    g_strConfigDN,		// pwszConfigDN_p6
		    pCAContext->iKey,		// iCRL_p8
		    fDelta,			// fDeltaCRL_p9
		    TRUE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pTemplate->pwszURL,   // apwszStringsIn
		    &pAltInfo->rgAltEntry[i].pwszURL); // apwszStringsOut
	    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

	    pAltInfo->rgAltEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;
	    i++;
	}
    }
    CSASSERT(pAltInfo->cAltEntry == i);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pCDP->pbData,
		    &pCDP->cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pAltInfo->rgAltEntry)
    {
	for (i = 0; i < pAltInfo->cAltEntry; i++)
	{
	    if (NULL != pAltInfo->rgAltEntry[i].pwszURL)
	    {
		LocalFree(pAltInfo->rgAltEntry[i].pwszURL);
	    }
	}
	LocalFree(pAltInfo->rgAltEntry);
    }
    return(hr);
}


HRESULT
pkcsBuildAIA(
    IN DWORD Flags,
    IN CACTX const *pCAContext,
    OUT CRYPT_OBJID_BLOB *pAIA)
{
    HRESULT hr;
    DWORD cAIA;
    DWORD i;
    CSURLTEMPLATE const *pTemplate;
    CSURLTEMPLATE const *pTemplateEnd;
    CERT_AUTHORITY_INFO_ACCESS caio;
    CERT_ACCESS_DESCRIPTION *pcad;

    caio.cAccDescr = 0;
    caio.rgAccDescr = NULL;

    pAIA->pbData = NULL;
    pAIA->cbData = 0;

    cAIA = 0;
    if (0 != g_caRevURL)
    {
	pTemplateEnd = &g_paCACertURL[g_caCACertURL];
	for (pTemplate = g_paCACertURL; pTemplate < pTemplateEnd; pTemplate++)
	{
	    if (Flags & pTemplate->Flags)
	    {
		cAIA++;
	    }
	}
    }
    if (0 == cAIA)
    {
	hr = S_FALSE;
	goto error;
    }

    caio.rgAccDescr = (CERT_ACCESS_DESCRIPTION *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cAIA * sizeof(caio.rgAccDescr[0]));
    if (NULL == caio.rgAccDescr)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    for (pTemplate = g_paCACertURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (Flags & pTemplate->Flags)
	{
	    pcad = &caio.rgAccDescr[caio.cAccDescr];

	    pcad->pszAccessMethod = (CSURL_ADDTOCERTOCSP & pTemplate->Flags)?
		szOID_PKIX_OCSP : szOID_PKIX_CA_ISSUERS;
	    pcad->AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;

	    hr = myFormatCertsrvStringArray(
		    TRUE,			// fURL
		    g_pwszServerName,		// pwszServerName_p1_2
		    g_wszSanitizedName,		// pwszSanitizedName_p3_7
		    pCAContext->iCert,		// iCert_p4
		    g_strDomainDN,		// pwszDomainDN_p5
		    g_strConfigDN,		// pwszConfigDN_p6
		    pCAContext->iKey,		// iCRL_p8
		    FALSE,			// fDeltaCRL_p9
		    TRUE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pTemplate->pwszURL, // apwszStringsIn
		    &pcad->AccessLocation.pwszURL);  // apwszStringsOut

	    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

	    caio.cAccDescr++;
	}
    }
    CSASSERT(caio.cAccDescr == cAIA);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pAIA->pbData,
		    &pAIA->cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != caio.rgAccDescr)
    {
	for (i = 0; i < caio.cAccDescr; i++)
	{
	    pcad = &caio.rgAccDescr[i];
	    if (NULL != pcad->AccessLocation.pwszURL)
	    {
		LocalFree(pcad->AccessLocation.pwszURL);
	    }
	}
	LocalFree(caio.rgAccDescr);
    }
    return(hr);
}


// Find the newest cert with the matching key container name:

HRESULT
pkcsFindMatchingKeyContext(
    OPTIONAL IN CERT_PUBLIC_KEY_INFO *pPublicKeyInfo,
    IN DWORD iKey,
    OUT CACTX **ppCAContext)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    DWORD i;
    CACTX *pCAContext;

    *ppCAContext = NULL;
    for (i = g_cCACerts; i > 0; i--)
    {
	pCAContext = &g_aCAContext[i - 1];

	if ((MAXDWORD != iKey && iKey == pCAContext->iKey) ||
	    (NULL != pCAContext->pccCA &&
	     NULL != pPublicKeyInfo &&
	     CertComparePublicKeyInfo(
			X509_ASN_ENCODING,
			pPublicKeyInfo,
			&pCAContext->pccCA->pCertInfo->SubjectPublicKeyInfo)))
	{
	    // by design, CertComparePublicKeyInfo doesn't set last error!

	    *ppCAContext = pCAContext;
	    hr = S_OK;
	    break;
	}
    }
    return(hr);
}


HRESULT
pkcsLoadTemplates(
    IN WCHAR const *pwszRegName,
    OUT CSURLTEMPLATE **ppaURL,
    OUT DWORD *pcaURL)
{
    HRESULT hr;
    WCHAR *pwszzTemplates = NULL;
    WCHAR *pwsz;
    DWORD cTemplate = 0;
    CSURLTEMPLATE *pTemplate;
    DWORD Flags;
    WCHAR *pwsz2;

    *ppaURL = NULL;
    *pcaURL = 0;

    // get (multiple) path templates

    hr = myGetCertRegMultiStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegName,
			    &pwszzTemplates);
    _JumpIfError(hr, error, "myGetCertRegStrValue");

    for (pwsz = pwszzTemplates; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	Flags = _wtoi(pwsz);
	pwsz2 = pwsz;
	while (iswdigit(*pwsz2))
	{
	    pwsz2++;
	}
	if (0 != Flags && pwsz2 > pwsz && L':' == *pwsz2)
	{
	    cTemplate++;
	}
    }
    if (0 != cTemplate)
    {
	*ppaURL = (CSURLTEMPLATE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cTemplate * sizeof((*ppaURL)[0]));
	if (NULL == *ppaURL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pTemplate = *ppaURL;
	*pcaURL = cTemplate;

	for (pwsz = pwszzTemplates; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    Flags = _wtoi(pwsz);
	    pwsz2 = pwsz;
	    while (iswdigit(*pwsz2))
	    {
		pwsz2++;
	    }
	    if (0 != Flags && pwsz2 > pwsz && L':' == *pwsz2)
	    {
		pTemplate->Flags = Flags;

		hr = myDupString(&pwsz2[1], &pTemplate->pwszURL);
		_JumpIfError(hr, error, "myDupString");

		pTemplate++;
	    }
	}
	CSASSERT(pTemplate == &(*ppaURL)[*pcaURL]);
    }

error:
    if (NULL != pwszzTemplates)
    {
	LocalFree(pwszzTemplates);
    }
    return(hr);
}


VOID
pkcsFreeTemplates(
    IN OUT CSURLTEMPLATE **ppaURL,
    IN OUT DWORD *pcaURL)
{
    CSURLTEMPLATE *pTemplate;
    CSURLTEMPLATE *pTemplateEnd;

    if (0 != *pcaURL && NULL != *ppaURL)
    {
	pTemplateEnd = &(*ppaURL)[*pcaURL];
	for (pTemplate = *ppaURL; pTemplate < pTemplateEnd; pTemplate++)
	{
	    if (NULL != pTemplate->pwszURL)
	    {
		LocalFree(pTemplate->pwszURL);
	    }
	}
	LocalFree(*ppaURL);
	*ppaURL = NULL;
    }
}


HRESULT
pkcsGetCertFilename(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    OUT WCHAR **ppwszCertFile)
{
    HRESULT hr;
    WCHAR wszBuf[MAX_PATH];
    WCHAR *pwszIndexedName = NULL;
    DWORD cwc;

    *ppwszCertFile = NULL;

    hr = myAllocIndexedName(
			pwszSanitizedName,
			iCert,
			&pwszIndexedName);
    _JumpIfError(hr, error, "myAllocIndexedName");

    if (0 == GetEnvironmentVariable(L"SystemRoot", wszBuf, ARRAYSIZE(wszBuf)))
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "GetEnvironmentVariable");
    }
    cwc = wcslen(wszBuf) +
	    WSZARRAYSIZE(L"\\System32\\" wszCERTENROLLSHAREPATH L"\\") +
	    wcslen(g_pwszServerName) +
	    WSZARRAYSIZE(L"_") +
	    wcslen(pwszIndexedName) +
	    WSZARRAYSIZE(L".crt") +
	    1;

    *ppwszCertFile = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == *ppwszCertFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(*ppwszCertFile, wszBuf);
    wcscat(*ppwszCertFile, L"\\System32\\" wszCERTENROLLSHAREPATH L"\\");
    wcscat(*ppwszCertFile, g_pwszServerName);
    wcscat(*ppwszCertFile, L"_");
    wcscat(*ppwszCertFile, pwszIndexedName);
    wcscat(*ppwszCertFile, L".crt");
    CSASSERT(1 + wcslen(*ppwszCertFile) == cwc);

error:
    if (NULL != pwszIndexedName)
    {
	LocalFree(pwszIndexedName);
    }
    return(hr);
}


HRESULT
pkcsReloadMissingCertByHash(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD dwRegHashChoice,
    IN BYTE const *pbHashReg,
    IN DWORD cbHashReg,
    IN DWORD iHash)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    BSTR strHash = NULL;
    ICertDBRow *prow = NULL;
    DWORD cbCert;
    BYTE *pbCert = NULL;
    WCHAR *pwszCertFile = NULL;
    CERT_CONTEXT const *pcc = NULL;

    hr = MultiByteIntegerToBstr(TRUE, cbHashReg, pbHashReg, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    DBGPRINT((
	    DBG_SS_CERTSRV,
	    "Reloading %wsContext[%u]\n    %ws\n",
	    CSRH_CASIGCERT == dwRegHashChoice? L"CA" : L"KRA",
	    iHash,
	    strHash));

    hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY |
			    PROPOPEN_CERTHASH |
			    PROPTABLE_REQCERT,
			0,
			strHash,
			&prow);
    _PrintIfErrorStr(hr, "OpenRow", strHash);
    if (S_OK == hr)
    {
	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRawCertificate,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbCert,
		    (BYTE **) &pbCert);
	_JumpIfError(hr, error, "PKCSGetProperty(cert)");
    }
    else if (CSRH_CASIGCERT != dwRegHashChoice)
    {
	_JumpError(hr, error, "OpenRow");
    }
    else
    {
	hr = pkcsGetCertFilename(
			pwszSanitizedName,
			iHash,
			&pwszCertFile);
	_JumpIfError(hr, error, "myGetCertFilename");

	hr = DecodeFileW(pwszCertFile, &pbCert, &cbCert, CRYPT_STRING_ANY);
	_JumpIfError(hr, error, "DecodeFileW");
    }

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pcc,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    if (cbHash != cbHashReg || 0 != memcmp(abHash, pbHashReg, cbHash))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "wrong Cert");
    }

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
			hStore,
			X509_ASN_ENCODING,
			pbCert,
			cbCert,
			CERT_STORE_ADD_REPLACE_EXISTING,
			NULL))			// ppCertContext
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    DBGPRINT((
	DBG_SS_CERTSRV,
	"Reloaded %wsContext[%u]\n",
	CSRH_CASIGCERT == dwRegHashChoice? L"CA" : L"KRA",
	iHash));
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pwszCertFile)
    {
	LocalFree(pwszCertFile);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
pkcsReloadMissingCAOrKRACert(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD dwRegHashChoice,
    IN DWORD iHash)
{
    HRESULT hr;
    BYTE *pbHashReg = NULL;
    DWORD cbHashReg;

    hr = myGetCARegHash(
		    pwszSanitizedName,
		    dwRegHashChoice,
		    iHash,
		    &pbHashReg,
		    &cbHashReg);
    _JumpIfError(hr, error, "myGetCARegHash");

    hr = pkcsReloadMissingCertByHash(
		    hStore,
		    pwszSanitizedName,
		    dwRegHashChoice,
		    pbHashReg,
		    cbHashReg,
		    iHash);
    _JumpIfError(hr, error, "pkcsReloadMissingCertByHash");

error:
    if (NULL != pbHashReg)
    {
	LocalFree(pbHashReg);
    }
    return(hr);
}


VOID
pkcsFreeBlobArray(
    IN DWORD cBlob,
    CERT_BLOB *rgBlob)
{
    DWORD i;

    for (i = 0; i < cBlob; i++)
    {
	if (NULL != rgBlob[cBlob].pbData)
	{
	    LocalFree(rgBlob[i].pbData);
	}
    }
    LocalFree(rgBlob);
}


HRESULT
pkcsGetKRACertBlobs(
    IN ICertDBRow *prow,
    OUT DWORD *pcCertBlob,
    OUT CERT_BLOB **prgCertBlob)
{
    HRESULT hr;
    WCHAR *pwszHashes = NULL;
    WCHAR *pwsz;
    DWORD cb;
    DWORD cHash;
    DWORD i;
    CERT_BLOB *rgBlob = NULL;
    HCERTSTORE hStore = NULL;
    CRYPT_DATA_BLOB HashBlob;
    DWORD cBlobLoaded;
    CERT_CONTEXT const *pcc = NULL;

    HashBlob.pbData = NULL;

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequestKeyRecoveryHashes,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cb,
		(BYTE **) &pwszHashes);
    _JumpIfError(hr, error, "PKCSGetProperty(KRA hashes)");

    cHash = 1;
    pwsz = pwszHashes;
    while (TRUE)
    {
	pwsz = wcschr(pwsz, L'\n');
	if (NULL == pwsz)
	{
	    break;
	}
	*pwsz++ = L'\0';
	cHash++;
    }
    cBlobLoaded = 0;
    rgBlob = (CERT_BLOB *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cHash * sizeof(rgBlob[0]));
    if (NULL == rgBlob)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // open KRA store

    hStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,			// hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE,
			wszKRA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    pwsz = pwszHashes;
    for (i = 0; i < cHash; i++)
    {
	BOOL fReloaded;

	hr = WszToMultiByteInteger(
				TRUE,
				pwsz,
				&HashBlob.cbData,
				&HashBlob.pbData);
	_JumpIfError(hr, error, "WszToMultiByteInteger");

	fReloaded = FALSE;
	while (TRUE)
	{
	    pcc = CertFindCertificateInStore(
					hStore,
					X509_ASN_ENCODING,
					0,
					CERT_FIND_HASH,
					&HashBlob,
					NULL);
	    if (fReloaded || NULL != pcc)
	    {
		break;
	    }
	    hr = pkcsReloadMissingCertByHash(
					hStore,
					g_wszSanitizedName,
					CSRH_CAKRACERT,
					HashBlob.pbData,
					HashBlob.cbData,
					i);
	    _PrintIfError(hr, "pkcsReloadMissingCertByHash");
	    fReloaded = TRUE;
	}
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError(hr, "CertFindCertificateInStore");
	}
	else
	{
	    rgBlob[cBlobLoaded].pbData = (BYTE *) LocalAlloc(
							LMEM_FIXED,
							pcc->cbCertEncoded);
	    if (NULL == rgBlob[cBlobLoaded].pbData)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    rgBlob[cBlobLoaded].cbData = pcc->cbCertEncoded;
	    CopyMemory(
		    rgBlob[cBlobLoaded].pbData,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded);
	    cBlobLoaded++;

	    CertFreeCertificateContext(pcc);
	    pcc = NULL;
	}
	pwsz += wcslen(pwsz) + 1;
	LocalFree(HashBlob.pbData);
	HashBlob.pbData = NULL;
    }
    *pcCertBlob = cBlobLoaded;
    *prgCertBlob = rgBlob;
    rgBlob = NULL;

error:
    if (NULL != rgBlob)
    {
	pkcsFreeBlobArray(cBlobLoaded, rgBlob);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != HashBlob.pbData)
    {
	LocalFree(HashBlob.pbData);
    }
    if (NULL != pwszHashes)
    {
	LocalFree(pwszHashes);
    }
    return(hr);
}


HRESULT
pkcsGetHashAsOctet(
    IN ICertDBRow *prow,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    WCHAR *pwszHash = NULL;
    DWORD cb;
    CRYPT_DATA_BLOB Blob;
    DWORD cbHash;

    *ppbData = NULL;
    Blob.pbData = NULL;

    hr = PKCSGetProperty(
		prow,
		g_wszPropCertificateHash,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cb,
		(BYTE **) &pwszHash);
    _JumpIfError(hr, error, "PKCSGetProperty(hash)");

    hr = WszToMultiByteInteger(TRUE, pwszHash, &Blob.cbData, &Blob.pbData);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &Blob,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbData,
		    pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pwszHash)
    {
	LocalFree(pwszHash);
    }
    if (NULL != Blob.pbData)
    {
	LocalFree(Blob.pbData);
    }
    return(hr);
}


VOID
AddCertBlobToArray(
    IN CERT_CONTEXT const *pcc,
    IN CERT_BLOB *rgCertBlobAll,
    IN CERT_BLOB **ppCertBlob)
{
    CERT_BLOB *pCertBlob = *ppCertBlob;
    DWORD i;
    DWORD cBlob;

    cBlob = SAFE_SUBTRACT_POINTERS(pCertBlob, rgCertBlobAll);
    for (i = 0; i < cBlob; i++)
    {
	if (rgCertBlobAll[i].cbData == pcc->cbCertEncoded &&
	    0 == memcmp(
		    rgCertBlobAll[i].pbData,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded))
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"Duplicate Recovery Blob Cert[%u]\n",
		i));
	    goto error;
	}
    }
    DBGPRINT((
	DBG_SS_CERTSRV,
	"Adding Recovery Blob Cert[%u]\n",
	cBlob));
    pCertBlob->cbData = pcc->cbCertEncoded;
    pCertBlob->pbData = pcc->pbCertEncoded;
    pCertBlob++;

    *ppCertBlob = pCertBlob;

error:
    ;
}


HRESULT
PKCSGetArchivedKey(
    IN DWORD dwRequestId,
    OUT BYTE **ppbArchivedKey,	// CoTaskMem*
    OUT DWORD *pcbArchivedKey)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    BYTE *pbCertUser = NULL;
    DWORD cbCertUser;
    DWORD cb;
    HCRYPTMSG hMsg = NULL;
    CACTX *pCAContext;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CERT_CONTEXT const *pccUser = NULL;
    CERT_CHAIN_CONTEXT const *pCertChainContextUser = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_BLOB *rgCertBlobKRA = NULL;
    DWORD cCertBlobKRA;
    CERT_BLOB *rgCertBlobAll = NULL;
    DWORD cCertBlobAll;
    CERT_BLOB *pCertBlob;
    CRYPT_ATTRIBUTE HashAttrib;
    CRYPT_ATTR_BLOB HashAttribBlob;
    DWORD i;

    *ppbArchivedKey = NULL;
    HashAttribBlob.pbData = NULL;

    hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY | PROPTABLE_REQCERT,
			dwRequestId,
			NULL,
			&prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequestRawArchivedKey,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cbKey,
		&pbKey);
    _JumpIfError(hr, error, "PKCSGetProperty(key)");

    hr = pkcsGetKRACertBlobs(prow, &cCertBlobKRA, &rgCertBlobKRA);
    _JumpIfError(hr, error, "pkcsGetKRACertBlobs");

    hr = pkcsGetHashAsOctet(
		    prow,
		    &HashAttribBlob.pbData,
		    &HashAttribBlob.cbData);
    _JumpIfError(hr, error, "pkcsGetHashAsOctet");

    HashAttrib.pszObjId = szOID_ARCHIVED_KEY_CERT_HASH;
    HashAttrib.cValue = 1;
    HashAttrib.rgValue = &HashAttribBlob;

    hr = PKCSGetProperty(
		prow,
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbCertUser,
		&pbCertUser);
    _JumpIfError(hr, error, "PKCSGetProperty(cert)");

    pccUser = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    pbCertUser,
				    cbCertUser);
    if (NULL == pccUser)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    // build the user cert chain

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pccUser,
			    NULL,
			    NULL,
			    &CertChainPara,
			    0,
			    NULL,
			    &pCertChainContextUser))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChainContextUser->cChain)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "No user chain");
    }

    // Encode the encrypted key into a PKCS 7, signed by the current CA cert.
    // Initialize the CMSG_SIGNER_ENCODE_INFO structure for one signer.

    pCAContext = g_pCAContextCurrent;
    cCertBlobAll = cCertBlobKRA +
		   pCAContext->cCACertChain +
		   pCertChainContextUser->rgpChain[0]->cElement;

    rgCertBlobAll = (CERT_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    cCertBlobAll * sizeof(rgCertBlobAll[0]));
    if (NULL == rgCertBlobAll)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pCertBlob = rgCertBlobAll;

    CopyMemory(pCertBlob, rgCertBlobKRA, cCertBlobKRA * sizeof(pCertBlob[0]));
    pCertBlob += cCertBlobKRA;

    // Add the current CA cert chain

    for (i = 0; i < pCAContext->cCACertChain; i++)
    {
	AddCertBlobToArray(
		    pCAContext->apCACertChain[i],
		    rgCertBlobAll,
		    &pCertBlob);
    }

    // Add the user cert chain

    {
	CERT_SIMPLE_CHAIN *pSimpleChain;

	pSimpleChain = pCertChainContextUser->rgpChain[0];
	for (i = 0; i < pSimpleChain->cElement; i++)
	{
	    AddCertBlobToArray(
			pSimpleChain->rgpElement[i]->pCertContext,
			rgCertBlobAll,
			&pCertBlob);
	}
    }
    CSASSERT(pCertBlob <= &rgCertBlobAll[cCertBlobAll]);
    DBGPRINT((
	DBG_SS_CERTSRV,
	"Recovery Certs: %u --> %u\n",
	cCertBlobAll,
	SAFE_SUBTRACT_POINTERS(pCertBlob, rgCertBlobAll)));
    cCertBlobAll = SAFE_SUBTRACT_POINTERS(pCertBlob, rgCertBlobAll);

    ZeroMemory(&SignerEncodeInfo, sizeof(SignerEncodeInfo));
    SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);
    SignerEncodeInfo.pCertInfo = pCAContext->pccCA->pCertInfo;
    SignerEncodeInfo.hCryptProv = pCAContext->hProvCA;
    SignerEncodeInfo.dwKeySpec = AT_SIGNATURE;
    SignerEncodeInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    SignerEncodeInfo.cAuthAttr = 1;
    SignerEncodeInfo.rgAuthAttr = &HashAttrib;
    //SignerEncodeInfo.cUnauthAttr = 0;
    //SignerEncodeInfo.rgUnauthAttr = NULL;
    //SignerEncodeInfo.HashEncryptionAlgorithm.pszObjId = ???;

    // CERT_ID_SHA1_HASH is not yet implemented in CryptMsgOpenToEncode
    //SignerEncodeInfo.SignerId.dwIdChoice = CERT_ID_SHA1_HASH;
    //SignerEncodeInfo.SignerId.HashId.cbData = cb;
    //SignerEncodeInfo.SignerId.HashId.pbData = abHash;

    ZeroMemory(&SignedMsgEncodeInfo, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.cSigners = 1;
    SignedMsgEncodeInfo.rgSigners = &SignerEncodeInfo;
    SignedMsgEncodeInfo.cCertEncoded = cCertBlobAll;
    SignedMsgEncodeInfo.rgCertEncoded = rgCertBlobAll;
    //SignedMsgEncodeInfo.cCrlEncoded = 0;
    //SignedMsgEncodeInfo.rgCrlEncoded = NULL;

    hMsg = CryptMsgOpenToEncode(
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    0,				// dwFlags
			    CMSG_SIGNED,		// dwMsgType
			    &SignedMsgEncodeInfo,	// pvMsgEncodeInfo
			    NULL,			// pszInnerContentObjID
			    NULL);			// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    if (!CryptMsgUpdate(hMsg, pbKey, cbKey, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    // Return the encoded and signed content.
    // Use CMSG_CONTENT_PARAM to get the signed message.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
		    CERTLIB_USE_COTASKMEMALLOC,
		    (VOID **) ppbArchivedKey,
		    pcbArchivedKey);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

error:
    if (pCertChainContextUser != NULL)
    {
	CertFreeCertificateChain(pCertChainContextUser);
    }
    if (NULL != pccUser)
    {
	CertFreeCertificateContext(pccUser);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != rgCertBlobKRA)
    {
	pkcsFreeBlobArray(cCertBlobKRA, rgCertBlobKRA);
    }
    if (NULL != rgCertBlobAll)
    {
	LocalFree(rgCertBlobAll);
    }
    if (NULL != HashAttribBlob.pbData)
    {
	LocalFree(HashAttribBlob.pbData);
    }
    if (NULL != pbKey)
    {
	LocalFree(pbKey);
    }
    if (NULL != pbCertUser)
    {
	LocalFree(pbCertUser);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
pkcsGetKeyContainerName(
    IN CERT_CONTEXT const *pccCA,
    OUT WCHAR **ppwszKeyContainerName)
{
    HRESULT hr;
    CRYPT_HASH_BLOB KeyIdentifier;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD cb;

    KeyIdentifier.pbData = NULL;
    *ppwszKeyContainerName = NULL;

    hr = myGetPublicKeyHash(
			pccCA->pCertInfo,
			&pccCA->pCertInfo->SubjectPublicKeyInfo,
			&KeyIdentifier.pbData,
			&KeyIdentifier.cbData);
    _JumpIfError(hr, error, "myGetPublicKeyHash");

    cb = 0;
    while (TRUE)
    {
	if (!CryptGetKeyIdentifierProperty(
			    &KeyIdentifier,
			    CERT_KEY_PROV_INFO_PROP_ID,
			    CRYPT_KEYID_MACHINE_FLAG,
			    NULL,			// pwszComputerName
			    NULL,			// pvReserved
			    pkpi,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Cert index");
	}
	if (NULL != pkpi)
	{
	    break;
	}
	pkpi = (CRYPT_KEY_PROV_INFO *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pkpi)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = myDupString(pkpi->pwszContainerName, ppwszKeyContainerName);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != KeyIdentifier.pbData)
    {
	LocalFree(KeyIdentifier.pbData);
    }
    return(hr);
}


HRESULT
pkcsLoadCAContext(
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR *pwszProvName,
    IN DWORD dwProvType,
    IN ALG_ID idAlg,
    IN BOOL fMachineKeyset,
    IN DWORD iHash,
    IN HCERTSTORE hMyStore)
{
    HRESULT hr;
    HCRYPTPROV hProvCA = NULL;
    char *pszObjIdSignatureAlgorithm = NULL;
    WCHAR *pwszKeyContainerName = NULL;
    CERT_CONTEXT const *pccCA = NULL;
    DWORD cCACertChain;
    CERT_CONTEXT const **apCACertChain = NULL;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    CACTX *pCAContext;
    DWORD i;
    DWORD cbKey;
    DWORD iCert;
    DWORD iKey;
    DWORD NameId;
    BOOL fReloaded;

    hr = myGetSigningOID(
		    NULL,	// hProv
		    pwszProvName,
		    dwProvType,
		    idAlg,
		    &pszObjIdSignatureAlgorithm);
    _JumpIfError(hr, error, "myGetSigningOID");

    if (~_16BITMASK & iHash)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Cert index");
    }

    fReloaded = FALSE;
    while (TRUE)
    {
	hr = myFindCACertByHashIndex(
				hMyStore,
				pwszSanitizedName,
				CSRH_CASIGCERT,
				iHash,
				&NameId,
				&pccCA);
	iCert = iHash;
	iKey = iCert;
	if (S_OK == hr)
	{
	    break;
	}

	// if no hash entry exists for this index, fake up a CA Context
	// as a place holder.

	if (S_FALSE == hr)
	{
	    CSASSERT(MAXDWORD == NameId);
	    CSASSERT(NULL == pccCA);
	    break;
	}
	if (fReloaded || CRYPT_E_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "myFindCACertByHashIndex");
	}
	_PrintError(hr, "myFindCACertByHashIndex");

	// The CA cert is missing from the HKLM "my" store -- look it up in
	// the DB or the CertEnroll directory, and put it back in the store.

	hr = pkcsReloadMissingCAOrKRACert(
				hMyStore,
				pwszSanitizedName,
				CSRH_CASIGCERT,
				iHash);
	_JumpIfError(hr, error, "pkcsReloadMissingCAOrKRACert");

	fReloaded = TRUE;
    }

    CSASSERT(S_FALSE == hr || S_OK == hr);
    if (S_OK == hr)
    {
	if (MAXDWORD != NameId && iCert != CANAMEIDTOICERT(NameId))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"NameId=%u.%u iCert=%u\n",
		CANAMEIDTOICERT(NameId),
		CANAMEIDTOIKEY(NameId),
		iCert));
	    _JumpError(hr, error, "bad iCert");
	}

	fReloaded = FALSE;
	while (TRUE)
	{
	    if (NULL != pwszKeyContainerName)
	    {
		LocalFree(pwszKeyContainerName);
		pwszKeyContainerName = NULL;
	    }
	    if (!fReloaded)
	    {
		// get the private key provider info

		if (!myCertGetCertificateContextProperty(
						pccCA,
						CERT_KEY_PROV_INFO_PROP_ID,
						CERTLIB_USE_LOCALALLOC,
						(VOID **) &pKey,
						&cbKey))
		{
		    hr = myHLastError();
		    if (CRYPT_E_NOT_FOUND != hr)
		    {
			_JumpError(hr, error, "myCertGetCertificateContextProperty");
		    }
		    _PrintError(hr, "CertGetCertificateContextProperty");

		    // The Key Provider Info is missing -- use the sanitized
		    // name and key index to construct the key container name.
		    // If that key matches, we'll write out the new Key
		    // Provider Info below.

		    hr = myAllocIndexedName(
			    pwszSanitizedName,
			    MAXDWORD != NameId? CANAMEIDTOIKEY(NameId) : iCert,
			    &pwszKeyContainerName);
		    _JumpIfError(hr, error, "myAllocIndexedName");
		}
		else
		{
		    hr = myDupString(pKey->pwszContainerName, &pwszKeyContainerName);
		    _JumpIfError(hr, error, "myDupString");
		}
	    }
	    else
	    {
		hr = pkcsGetKeyContainerName(pccCA, &pwszKeyContainerName);
		_JumpIfError(hr, error, "pkcsGetKeyContainerName");
	    }

	    // signing testing

	    hr = myValidateHashForSigning(
				pwszKeyContainerName,
				pwszProvName,
				dwProvType,
				fMachineKeyset,
				&pccCA->pCertInfo->SubjectPublicKeyInfo,
				idAlg);
	    if (S_OK == hr)
	    {
		break;
	    }
	    if (fReloaded)
	    {
		_JumpError(hr, error, "myValidateHashForSigning");
	    }
	    _PrintError(hr, "myValidateHashForSigning");

	    fReloaded = TRUE;
	}

	// If the Key Provider Info is missing, write out new Key Provider Info

	if (NULL == pKey)
	{
	    CRYPT_KEY_PROV_INFO kpi;

	    ZeroMemory(&kpi, sizeof(kpi));
	    kpi.pwszContainerName = pwszKeyContainerName;
	    kpi.pwszProvName = pwszProvName;
	    kpi.dwProvType = dwProvType;
	    kpi.dwFlags = fMachineKeyset? CRYPT_MACHINE_KEYSET : 0;
	    kpi.dwKeySpec = AT_SIGNATURE;

	    if (!CertSetCertificateContextProperty(
					    pccCA,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    0,
					    &kpi))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertSetCertificateContextProperty");
	    }
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"Reloaded CAContext[%u] KeyProvInfo[%u]\n",
		iCert,
		iKey));
	}

	hr = pkcsFindMatchingKeyContext(
			    &pccCA->pCertInfo->SubjectPublicKeyInfo,
			    MAXDWORD,
			    &pCAContext);
	if (S_OK != hr && MAXDWORD != NameId)
	{
	    iKey = CANAMEIDTOIKEY(NameId);
	    if (iKey < iCert)
	    {
		hr = pkcsFindMatchingKeyContext(NULL, iKey, &pCAContext);
		_JumpIfError(hr, error, "pkcsFindMatchingKeyContext");
	    }
	}
	if (S_OK == hr)
	{
	    iKey = pCAContext->iKey;
	    if (MAXDWORD != NameId && iKey != CANAMEIDTOIKEY(NameId))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "bad iKey");
	    }
	    if (NULL == pCAContext->pccCA)
	    {
		CSASSERT(pCAContext->Flags & CTXF_CERTMISSING);
		pCAContext->Flags |= CTXF_CRLZOMBIE;
	    }
	    else
	    {
		CSASSERT(0 == (pCAContext->Flags & CTXF_CERTMISSING));
		pCAContext->Flags |= CTXF_SKIPCRL;
	    }
	}
	else
	{
	    g_cCAKeys++;	// this key has not previously been loaded
	}

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CAContext[%u]: Key %u: %ws\n",
	    iCert,
	    iKey,
	    pwszKeyContainerName));

	// get private key handler for later use if current CA

	if (!myCertSrvCryptAcquireContext(
				   &hProvCA,
				   pwszKeyContainerName,
				   pwszProvName,
				   dwProvType,
				   g_fCryptSilent? CRYPT_SILENT : 0,
				   fMachineKeyset))
	{
	    hr = myHLastError();
	    _JumpErrorStr(
			hr,
			error,
			"myCertSrvCryptAcquireContext",
			pwszKeyContainerName);
	}

	// now try to figure out the chain

	ZeroMemory(&CertChainPara, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				HCCE_LOCAL_MACHINE,
				pccCA,
				NULL,
				NULL,
				&CertChainPara,
				0,
				NULL,
				&pCertChainContext))
	{
	    hr = myHLastError();
	    goto error;
	}

	// make sure there is at least 1 simple chain

	if (pCertChainContext->cChain == 0)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "No valid trust chain could be formed");
	}

	// tell global how many elements we have in our chain

	cCACertChain = pCertChainContext->rgpChain[0]->cElement;

	// Allocate memory for global.  Allocate one extra pointer to allow loop
	// to assign NULL pointer in place in array.  Leave the count set to the
	// actual number of CA cert contexts, excluding the NULL pointer.

	apCACertChain = (CERT_CONTEXT const **) LocalAlloc(
				    LMEM_FIXED,
				    (cCACertChain + 1) * sizeof(apCACertChain[0]));
	if (NULL == apCACertChain)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	// copy chain in reverse order: from parent to child

	{
	    int i;

	    for (i = cCACertChain - 1; i >= 0; i--)
	    {
		apCACertChain[i] = CertDuplicateCertificateContext(
		    pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext);

		if (NULL == apCACertChain[i])
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertDuplicateCertificateContext");
		}
	    }
	}
    }

    for (i = 0; i < g_cCACerts; i++)
    {
	if (iCert < g_aCAContext[i].iCert)
	{
	    MoveMemory(
		    &g_aCAContext[i + 1],
		    &g_aCAContext[i],
		    (g_cCACerts - i) * sizeof(g_aCAContext[0]));
	    break;
	}
    }
    g_cCACerts++;

    pCAContext = &g_aCAContext[i];
    ZeroMemory(pCAContext, sizeof(*pCAContext));

    if (NULL == pccCA)
    {
	pCAContext->Flags |= CTXF_CERTMISSING | CTXF_SKIPCRL;
    }
    pCAContext->iCert = iCert;
    pCAContext->iKey = iKey;
    pCAContext->NameId = MAKECANAMEID(iCert, iKey);

    pCAContext->hProvCA = hProvCA;
    hProvCA = NULL;

    pCAContext->pccCA = pccCA;
    pccCA = NULL;

    if (NULL != apCACertChain)
    {
	pCAContext->cCACertChain = cCACertChain;
	pCAContext->apCACertChain = apCACertChain;
	apCACertChain = NULL;
    }

    pCAContext->pszObjIdSignatureAlgorithm = pszObjIdSignatureAlgorithm;
    pszObjIdSignatureAlgorithm = NULL;

    pCAContext->pwszKeyContainerName = pwszKeyContainerName;
    pwszKeyContainerName = NULL;


    // Ignore failure from here on -- collected data is optional

    if (NULL != pCAContext->pccCA)
    {
	hr = myGetPublicKeyHash(
			pCAContext->pccCA->pCertInfo,
			&pCAContext->pccCA->pCertInfo->SubjectPublicKeyInfo,
			&pCAContext->IssuerKeyId.pbData,
			&pCAContext->IssuerKeyId.cbData);
	_PrintIfError(hr, "myGetPublicKeyHash");

	if (0 == (CTXF_SKIPCRL & pCAContext->Flags))
	{
	    hr = pkcsBuildKeyAuthority2(
				g_CRLEditFlags,
				pCAContext,
				&pCAContext->KeyAuthority2CRL);
	    _PrintIfError(hr, "pkcsBuildKeyAuthority2");

	    hr = pkcsBuildCDP(
			CSURL_ADDTOFRESHESTCRL,
			TRUE,
			pCAContext,
			&pCAContext->CDPCRLFreshest);
	    _PrintIfError(hr, "pkcsBuildCDP");

	    hr = pkcsBuildCDP(
			CSURL_ADDTOCRLCDP,
			FALSE,
			pCAContext,
			&pCAContext->CDPCRLBase);
	    _PrintIfError(hr, "pkcsBuildCDP");

	    hr = pkcsBuildCDP(
			CSURL_ADDTOCRLCDP,
			TRUE,
			pCAContext,
			&pCAContext->CDPCRLDelta);
	    _PrintIfError(hr, "pkcsBuildCDP");

	    hr = pkcsBuildCRLList(
				FALSE,
				pCAContext,
				&pCAContext->papwszCRLFiles);
	    _JumpIfError(hr, error, "pkcsBuildCRLList");

	    hr = pkcsBuildCRLList(
				TRUE,
				pCAContext,
				&pCAContext->papwszDeltaCRLFiles);
	    _JumpIfError(hr, error, "pkcsBuildCRLList");
	}
    }
    hr = S_OK;

error:
    if (NULL != hProvCA)
    {
	CryptReleaseContext(hProvCA, 0);
    }
    if (NULL != pszObjIdSignatureAlgorithm)
    {
	LocalFree(pszObjIdSignatureAlgorithm);
    }
    if (NULL != pwszKeyContainerName)
    {
	LocalFree(pwszKeyContainerName);
    }
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (pCertChainContext != NULL)
    {
	CertFreeCertificateChain(pCertChainContext);
    }
    if (NULL != pccCA)
    {
	CertFreeCertificateContext(pccCA);
    }
    return(hr);
}


HRESULT
pkcsLoadCAContextArray(
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    DWORD cCACerts;
    HCERTSTORE hMyStore = NULL;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    ALG_ID idAlg;
    BOOL fMachineKeyset;
    DWORD iHash;

    // get provider name

    hr = myGetCertSrvCSP(
		    FALSE,	// fEncryptionCSP
		    pwszSanitizedName,
		    &dwProvType,
		    &pwszProvName,
		    &idAlg,
		    &fMachineKeyset,
		    NULL);	// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    // open MY store

    hMyStore = CertOpenStore(
		       CERT_STORE_PROV_SYSTEM_W,
		       X509_ASN_ENCODING,
		       NULL,			// hProv
		       CERT_SYSTEM_STORE_LOCAL_MACHINE,
		       wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    // find & load CA certs, etc.

    hr = myGetCARegHashCount(pwszSanitizedName, CSRH_CASIGCERT, &cCACerts);
    if (S_OK == hr && 0 == cCACerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    _JumpIfError(hr, error, "myGetCARegHashCount");

    g_aCAContext = (CACTX *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cCACerts * sizeof(g_aCAContext[0]));
    if (NULL == g_aCAContext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (iHash = 0; iHash < cCACerts; iHash++)
    {
	hr = pkcsLoadCAContext(
			pwszSanitizedName,
			pwszProvName,
			dwProvType,
			idAlg,
			fMachineKeyset,
			iHash,
			hMyStore);
	if (S_FALSE == hr)
	{
	    continue;
	}
	_JumpIfError(hr, error, "pkcsLoadCAContext");
    }

    g_pCAContextCurrent = &g_aCAContext[g_cCACerts - 1];

    // Only build a Key Authority extension for the current CACTX -- it's the
    // only one used to issue certs.

    hr = pkcsBuildKeyAuthority2(
			EDITF_ENABLEAKIKEYID |
			    EDITF_ENABLEAKIISSUERNAME |
			    EDITF_ENABLEAKIISSUERSERIAL,
			g_pCAContextCurrent,
			&g_pCAContextCurrent->KeyAuthority2Cert);
    _PrintIfError(hr, "pkcsBuildKeyAuthority2");

    // Only build a CDP extension for the current CACTX -- it's the
    // only one used to issue certs.

    hr = pkcsBuildCDP(
		CSURL_ADDTOCERTCDP,
		FALSE,
		g_pCAContextCurrent,
		&g_pCAContextCurrent->CDPCert);
    _PrintIfError(hr, "pkcsBuildCDP");

    // Only build a CDP extension for the current CACTX -- it's the
    // only one used to issue certs.

    hr = pkcsBuildAIA(
		CSURL_ADDTOCERTCDP | CSURL_ADDTOCERTOCSP,
		g_pCAContextCurrent,
		&g_pCAContextCurrent->AIACert);
    _PrintIfError(hr, "pkcsBuildAIA");

    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    if (NULL != hMyStore)
    {
	CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
pkcsImportCAOrKRACert(
    IN CERT_CONTEXT const *pcc,
    IN DWORD DBDisposition,
    OPTIONAL IN CACTX const *pCAContext)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BSTR strHash = NULL;
    ICertDBRow *prow = NULL;
    WCHAR *pwszUserName = NULL;
    DWORD cb;
    BOOL fCommit = FALSE;
    BOOL fCommitted = FALSE;

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
			pcc,
			CERT_HASH_PROP_ID,
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    // Import Cert if it doesn't already exist in DB:

    hr = g_pCertDB->OpenRow(
			PROPOPEN_CERTHASH | PROPTABLE_REQCERT,
			0,
			strHash,
			&prow);
    if (S_OK != hr)
    {
	CSASSERT(CERTSRV_E_PROPERTY_EMPTY == hr);

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, &prow);
	_JumpIfError(hr, error, "OpenRow");

	hr = PKCSParseImportedCertificate(
				    DBDisposition,
				    prow,
				    pCAContext,
				    pcc);
	_JumpIfError(hr, error, "PKCSParseImportedCertificate");

	fCommit = TRUE;
    }

    // Set requester name if missing

    hr = prow->GetProperty(
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cb,
		NULL);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = myGetComputerObjectName(NameSamCompatible, &pwszUserName);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myGetComputerObjectName");

	    hr = myGetUserNameEx(NameSamCompatible, &pwszUserName);
	    _JumpIfError(hr, error, "myGetUserNameEx");
	}

	hr = prow->SetProperty(
		    g_wszPropRequesterName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszUserName);
	_JumpIfError(hr, error, "SetProperty");

	hr = prow->SetProperty(
		    g_wszPropCallerName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszUserName);
	_JumpIfError(hr, error, "SetProperty");

	fCommit = TRUE;
    }
    hr = prow->CommitTransaction(fCommit);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;
    hr = S_OK;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
pkcsImportCAContext(
    IN CACTX const *pCAContext)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;

    hr = S_OK;
    for (i = 0; i < pCAContext->cCACertChain; i++)
    {
	CERT_CONTEXT const *pCert = pCAContext->apCACertChain[i];

	hr2 = pkcsImportCAOrKRACert(
			    pCert,
			    0 == i? DB_DISP_CA_CERT : DB_DISP_CA_CERT_CHAIN,
			    pCAContext);
	if (S_OK != hr2)
	{
	    if (S_OK == hr)
	    {
		hr = hr2;	// return first error
	    }
	    _PrintError(hr2, "pkcsImportCAOrKRACert");
	    continue;
	}
    }
    _JumpIfError(hr, error, "pkcsImportCAOrKRACert");

error:
    return(hr);
}


HRESULT
pkcsImportCAContextArray()
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD i;

    for (i = 0; i < g_cCACerts; i++)
    {
	CACTX *pCAContext = &g_aCAContext[i];

	if (NULL == pCAContext->pccCA)
	{
	    continue;
	}
	hr2 = pkcsImportCAContext(pCAContext);
	if (S_OK != hr2)
	{
	    _PrintError(hr2, "pkcsImportCAContext");
	    if (S_OK == hr)
	    {
		hr = hr2;	// return first error
	    }
	}
    }

//error:
    return(hr);
}

PCCERT_CONTEXT pkcsFindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LENGTH];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LENGTH;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LENGTH != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,      // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

HRESULT pkcsObtainNTAuthStore(IN HCERTSTORE *phCertStore)
{
    HRESULT         hr=E_INVALIDARG;
    HCERTSTORE      hEnterpriseStore = NULL;

    LPWSTR          pwszLdapStore=NULL;
    

    if((NULL==phCertStore) || (NULL==g_strConfigDN))
	    _JumpError(hr, error, "LocalAlloc for pwazLdapStore");

    *phCertStore=NULL;

    pwszLdapStore = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(g_strConfigDN)+wcslen(g_wszNTAuth)));

    if(pwszLdapStore == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc for pwazLdapStore");
    }

    wsprintf(pwszLdapStore, 
             g_wszNTAuth,
             g_strConfigDN);

    hEnterpriseStore = CertOpenStore(CERT_STORE_PROV_LDAP, 
                  0,
                  0,
                  CERT_STORE_READONLY_FLAG | CERT_LDAP_STORE_SIGN_FLAG,
                  pwszLdapStore);

    if(NULL == hEnterpriseStore)
    {
        hr=myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
    }

    *phCertStore=hEnterpriseStore;

    hr = S_OK;
    
error:

    if(pwszLdapStore)
        LocalFree(pwszLdapStore);

    return hr;
}


HRESULT
pkcsVerifySignatureCertContext(
    IN WCHAR const * pwszCommonName,
    IN HCERTSTORE hNTAuthStore,
    IN DWORD    dwCAIndex,
    IN OUT CACTX *pCAContext,
    OUT DWORD *pLogMsg,
    OUT BOOL *pfWarn)
{
    HRESULT hr;
    WCHAR awc[11];
    WCHAR const *apwsz[2];

    PCCERT_CONTEXT          pCertContext = NULL;

    *pLogMsg = 0;
    *pfWarn = FALSE;
    hr = myVerifyCertContext(
			pCAContext->pccCA,	// pCert
			0,			// dwFlags
			0,			// cUsageOids
			NULL,			// apszUsageOids
			HCCE_LOCAL_MACHINE,	// hChainEngine
			NULL,			// hAdditionalStore
			NULL);			// ppwszMissingIssuer
    pCAContext->hrVerifyStatus = hr;
    if (S_OK != hr)
    {
	_PrintError2(hr, "myVerifyCertContext", CRYPT_E_REVOCATION_OFFLINE);
	if (CERT_E_EXPIRED == hr)
	{
	    pCAContext->Flags |= CTXF_EXPIRED;
	    if (0 == (CRLF_PUBLISH_EXPIRED_CERT_CRLS & g_dwCRLFlags))
	    {
		pCAContext->Flags |= CTXF_SKIPCRL;
	    }
	    *pLogMsg = MSG_E_CA_CERT_EXPIRED;
	}
	else if (CRYPT_E_REVOKED == hr)
	{
	    pCAContext->Flags |= CTXF_REVOKED | CTXF_SKIPCRL;
	    *pLogMsg = MSG_E_CA_CERT_REVOKED;
	}
	else if (CRYPT_E_REVOCATION_OFFLINE == hr)
	{
	    DWORD dwState;

	    hr = GetSetupStatus(NULL, &dwState);
	    if ((S_OK != hr || 0 == (SETUP_CREATEDB_FLAG & dwState)) &&
		CERTLOG_WARNING <= g_dwLogLevel)
	    {
		*pLogMsg = MSG_E_CA_CERT_REVOCATION_OFFLINE;
		*pfWarn = TRUE;
	    }
	    else
	    {
		hr = S_OK;
	    }
	}
	else if (CRYPT_E_NO_REVOCATION_CHECK == hr)
	{
	    if (CERTLOG_VERBOSE <= g_dwLogLevel)
	    {
		*pLogMsg = MSG_E_CA_CERT_REVOCATION_NOT_CHECKED;
		*pfWarn = TRUE;
	    }
	    else
	    {
		hr = S_OK;
	    }
	}
	else
	{
	    *pLogMsg = MSG_E_CA_CHAIN;
	}
	_JumpIfError(hr, error, "myVerifyCertContext");
    }

    //the CA's certificate looks good.  We verify the CA's
    //certificate is in the NTAuth store
    if(hNTAuthStore)
    {
        if(NULL == (pCertContext=pkcsFindCertificateInOtherStore(
                hNTAuthStore,
                pCAContext->pccCA)))

        {
            wsprintf(awc, L"%u", dwCAIndex);
            apwsz[0] = awc;
            apwsz[1] = pwszCommonName;

            LogEvent(EVENTLOG_WARNING_TYPE, MSG_CA_CERT_NO_IN_AUTH, ARRAYSIZE(apwsz), apwsz);
        }

        if(pCertContext)
            CertFreeCertificateContext(pCertContext);
    }

error:
    return(hr);
}


HRESULT
pkcsVerifySignatureCertContextArray(
    IN  WCHAR const * pwszCommonName,
    OUT DWORD *pLogMsg,
    OUT BOOL *pfWarn)
{
    HRESULT hr;
    DWORD i;
    WCHAR const *apwsz[1];

    HCERTSTORE  hNTAuthStore=NULL;

    CSASSERT(0 != g_cCACerts);

    //we need to verify CA's certificates should be in 
    //the NTAuth store if the certificate is not yet expired or revoked
    if(IsEnterpriseCA(g_CAType))
	{
        pkcsObtainNTAuthStore(&hNTAuthStore);

		if(NULL == hNTAuthStore)
		{
            apwsz[0] = pwszCommonName;

            LogEvent(EVENTLOG_WARNING_TYPE, MSG_CA_CERT_NO_AUTH_STORE, ARRAYSIZE(apwsz), apwsz);
		}
	}


    for (i = 0; i < g_cCACerts; i++)
    {
	CACTX *pCAContext = &g_aCAContext[i];

	if (NULL == pCAContext->pccCA)
	{
	    continue;
	}

	// Ignore all errors except for the current CA (last entry in array)

	hr = pkcsVerifySignatureCertContext(
                    pwszCommonName,
                    hNTAuthStore,
                    i,
		    pCAContext,
		    pLogMsg,
		    pfWarn);
    }

    if(hNTAuthStore)
        CertCloseStore(hNTAuthStore, 0);

    return(hr);
}


VOID
PKCSVerifyCAState(
    IN OUT CACTX *pCAContext)
{
    HRESULT hr;
    
    if (0 == pCAContext->Flags && NULL != pCAContext->pccCA)
    {
	DWORD LogMsg = MAXDWORD;
	BOOL fWarn = FALSE;

	hr = pkcsVerifySignatureCertContext(NULL, NULL, 0, pCAContext, &LogMsg, &fWarn);
	if (S_OK != hr)
	{
	    CSASSERT(MAXDWORD != LogMsg);
	    LogEventStringHResult(
			    fWarn? EVENTLOG_WARNING_TYPE : EVENTLOG_ERROR_TYPE,
			    LogMsg,
			    g_wszCommonName,
			    hr);
	}
    }
}


HRESULT
pkcsVerifyDSCACert(
    IN LDAP *pld)
{
    HRESULT hr;
    HCAINFO hCAInfo = NULL;
    PCCERT_CONTEXT pDSCertContext = NULL;

    // BUGBUG: verify all of this CA's unexpired signature certs are in the DS.
    // Republish any that aren't.  Cleans up DS replication conflicts.

    CSASSERT(g_pCAContextCurrent && g_pCAContextCurrent->pccCA);

    hr = CAFindByName(
        g_wszSanitizedName,
        NULL,
        CA_FIND_LOCAL_SYSTEM |
        CA_FIND_INCLUDE_UNTRUSTED, // this will cause findbyname to skip
        &hCAInfo);                 // ca cert checking
    _JumpIfErrorStr(hr, error, "CAFindByName", g_wszSanitizedName);

    hr = CAGetCACertificate(hCAInfo, &pDSCertContext);
    _JumpIfError(hr, error, "CAGetCACertificate");

    if(!pDSCertContext ||
       pDSCertContext->cbCertEncoded !=
       g_pCAContextCurrent->pccCA->cbCertEncoded ||
       0 != memcmp(pDSCertContext->pbCertEncoded,
                   g_pCAContextCurrent->pccCA->pbCertEncoded,
                   g_pCAContextCurrent->pccCA->cbCertEncoded))
    {
        // published cert is invalid or old, publish the current one

        hr = CASetCACertificate(
            hCAInfo,
            g_pCAContextCurrent->pccCA);
        _JumpIfError(hr, error, "CASetCACertificate");

        hr = CAUpdateCA(hCAInfo);
        _JumpIfError(hr, error, "CAUpdateCA");

        {
            CAuditEvent audit(SE_AUDITID_CERTSRV_PUBLISHCACERT, g_dwAuditFilter);

            hr = audit.AddData( // %1 Certificate Hash
                g_pCAContextCurrent->pccCA->pCertInfo->SerialNumber.pbData,
                g_pCAContextCurrent->pccCA->pCertInfo->SerialNumber.cbData);
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = audit.AddData(g_pCAContextCurrent->pccCA->pCertInfo->NotBefore); // %2 Valid From
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = audit.AddData(g_pCAContextCurrent->pccCA->pCertInfo->NotAfter); //%3 Valid To
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = audit.Report();
            _JumpIfError(hr, error, "CAuditEvent::Report");
        }
    }

    hr = S_OK;
error:

    if(hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    if(pDSCertContext)
    {
        CertFreeCertificateContext(pDSCertContext);
    }
    return(hr);
}


VOID
pkcsReleaseKRACertArray()
{
    DWORD i;

    if (NULL != g_rgKRACerts)
    {
	for (i = 0; i < g_cKRACerts; i++)
	{
	    if (NULL != g_rgKRACerts[i])
	    {
		CertFreeCertificateContext(g_rgKRACerts[i]);
	    }
	}
	LocalFree(g_rgKRACerts);
	g_rgKRACerts = NULL;
    }
    if (NULL != g_rgstrKRAHashes)
    {
	for (i = 0; i < g_cKRACerts; i++)
	{
	    if (NULL != g_rgstrKRAHashes[i])
	    {
		SysFreeString(g_rgstrKRAHashes[i]);
	    }
	}
	LocalFree(g_rgstrKRAHashes);
	g_rgstrKRAHashes = NULL;
    }
    g_cKRACerts = 0;
    g_hrKRALoad = S_OK;
}


VOID
pkcsLogKRACertError(
    IN DWORD LogMsg,
    IN DWORD iHash,
    OPTIONAL IN CERT_CONTEXT const *pcc,
    IN HRESULT hrLog)
{
    HRESULT hr;
    WCHAR awc[11];
    WCHAR *pwszName = NULL;
    WCHAR const *pwszError = NULL;
    WCHAR const *apwsz[3];

    wsprintf(awc, L"%u", iHash);
    apwsz[0] = awc;

    if (NULL != pcc)
    {
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pcc->pCertInfo->Subject,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszName);
	_PrintIfError(hr, "myCertNameToStr");
    }
    apwsz[1] = NULL != pwszName? pwszName : L"";

    pwszError = myGetErrorMessageText(hrLog, TRUE);
    apwsz[2] = NULL != pwszError? pwszError : L"";

    LogEvent(EVENTLOG_ERROR_TYPE, LogMsg, ARRAYSIZE(apwsz), apwsz);

//error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
}


HRESULT
pkcsLoadKRACertContext(
    IN DWORD iHash,
    IN HCERTSTORE hStore)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    BSTR strHash = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    DWORD LogMsg = 0;
    BOOL fReloaded;

    DBGPRINT((DBG_SS_CERTSRV, "Loading KRA Cert[%u]:\n", iHash));

    fReloaded = FALSE;
    while (TRUE)
    {
	hr = myFindCACertByHashIndex(
				hStore,
				g_wszSanitizedName,
				CSRH_CAKRACERT,
				iHash,
				NULL,		// pNameId
				&pcc);
	if (S_OK == hr)
	{
	    break;
	}
	if (fReloaded || CRYPT_E_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "myFindCACertByHashIndex");
	}
	_PrintError(hr, "myFindCACertByHashIndex");

	// The KRA cert is missing from the HKLM "kra" store -- look it up in
	// the DB, and put it back in the store.

	hr = pkcsReloadMissingCAOrKRACert(
				hStore,
				g_wszSanitizedName,
				CSRH_CAKRACERT,
				iHash);
	_JumpIfError(hr, error, "pkcsReloadMissingCAOrKRACert");

	fReloaded = TRUE;
    }

    hr = myVerifyKRACertContext(
			    pcc,
			    (CRLF_REVCHECK_IGNORE_OFFLINE & g_dwCRLFlags)?
				CA_VERIFY_FLAGS_IGNORE_OFFLINE : 0);
    if (S_OK != hr)
    {
	LogMsg = MSG_E_INVALID_KRA_CERT;
	_JumpErrorStr(hr, error, "myVerifyKRACertContext", L"KRA cert invalid");
    }

    hr = pkcsImportCAOrKRACert(pcc, DB_DISP_KRA_CERT, NULL);
    _JumpIfError(hr, error, "pkcsReloadMissingCAOrKRACert");

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pcc,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    g_rgstrKRAHashes[g_cKRACerts] = strHash;
    g_rgKRACerts[g_cKRACerts] = pcc;
    g_cKRACerts++;
    strHash = NULL;
    pcc = NULL;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (0 == LogMsg)
	{
	    LogMsg = MSG_E_CANNOT_LOAD_KRA_CERT;
	}
	pkcsLogKRACertError(LogMsg, iHash, pcc, hr);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
pkcsLoadKRACertArray()
{
    HRESULT hr;
    DWORD iHash;
    DWORD i;
    HCERTSTORE hStore = NULL;
    DWORD LogMsg = 0;

    if (!g_fAdvancedServer)
    {
	LogMsg = MSG_E_KRA_NOT_ADVANCED_SERVER;
	hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
	_JumpError(hr, error, "!g_fAdvancedServer");
    }

    // open KRA store

    hStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,			// hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE,
			wszKRA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    // find & load KRA certs

    hr = myGetCARegHashCount(g_wszSanitizedName, CSRH_CAKRACERT, &g_cKRAHashes);
    if (S_OK == hr && 0 == g_cKRAHashes)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    _JumpIfError(hr, error, "myGetCARegHashCount");

    g_rgKRACerts = (CERT_CONTEXT const **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				g_cKRAHashes * sizeof(g_rgKRACerts[0]));
    if (NULL == g_rgKRACerts)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    g_rgstrKRAHashes = (BSTR *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				g_cKRAHashes * sizeof(g_rgstrKRAHashes[0]));
    if (NULL == g_rgstrKRAHashes)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (iHash = 0; iHash < g_cKRAHashes; iHash++)
    {
	hr = pkcsLoadKRACertContext(iHash, hStore);
	if (S_OK != hr)
	{
	    _PrintError(hr, "pkcsLoadKRACertContext");
	    g_hrKRALoad = hr;
	}
    }
    if (0 == g_cKRACerts)
    {
	LogMsg = MSG_E_NO_VALID_KRA_CERTS;
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "g_cKRACerts == 0");
    }
    g_iKRACerts = 0;
    if (g_cKRACerts > g_cKRACertsRoundRobin)
    {
	srand((unsigned) time(NULL));
	g_iKRACerts = rand() % g_cKRACerts;
    }
    else
    {
	g_cKRACertsRoundRobin = g_cKRACerts;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (0 == LogMsg)
	{
	    LogMsg = MSG_E_LOADING_KRA_CERTS;
	}
	LogEventHResult(EVENTLOG_ERROR_TYPE, LogMsg, hr);
	pkcsReleaseKRACertArray();
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
pkcsExpandURL(
    IN WCHAR const *pwszURLTemplate,
    OUT WCHAR **ppwszURL)
{
    HRESULT hr;

    *ppwszURL = NULL;

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    hr = myFormatCertsrvStringArray(
	    FALSE,			// fURL
	    g_pwszServerName,		// pwszServerName_p1_2
	    g_wszSanitizedName,		// pwszSanitizedName_p3_7
	    0,				// iCert_p4
	    g_strDomainDN,		// pwszDomainDN_p5
	    g_strConfigDN,		// pwszConfigDN_p6
	    0,				// iCRL_p8
	    FALSE,			// fDeltaCRL_p9
	    FALSE,			// fDSAttrib_p10_11
	    1,				// cStrings
	    &pwszURLTemplate,		// apwszStringsIn
	    ppwszURL);			// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

error:
    return(hr);
}


HRESULT
pkcsPatchDN(
    IN HRESULT hrFail,
    IN WCHAR const *pwszRegName,
    IN OUT BSTR *pstrDSValue)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    
    hr = myGetCertRegStrValue(
		    g_wszSanitizedName,
		    NULL,
		    NULL,
		    pwszRegName,
		    &pwszRegValue);
    _PrintIfErrorStr(hr, "myGetCertRegStrValue", pwszRegName);

    if (NULL != *pstrDSValue)
    {
	if (NULL == pwszRegValue || 0 != lstrcmp(*pstrDSValue, pwszRegValue))
	{
	    // set reg value

	    hr = mySetCertRegStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegName,
			    *pstrDSValue);
	    _PrintIfErrorStr(hr, "mySetCertRegStrValue", pwszRegName);
	}
    }
    else
    {
	if (NULL == pwszRegValue || L'\0' == *pwszRegValue)
	{
	    hr = hrFail;
	    _JumpError(hr, error, "both DS and Reg NULL");
	}
	if (!ConvertWszToBstr(pstrDSValue, pwszRegValue, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszRegValue)
    {
	LocalFree(pwszRegValue);
    }
    return(hr);
}


HRESULT
pkcsGetAuthoritativeDomainDn(
    IN WCHAR const *pwszCommonName,
    OUT LDAP **ppld,
    OUT BSTR *pstrDomainDN,
    OUT BSTR *pstrConfigDN)
{
    HRESULT hr;
    WCHAR *pwszConfigDN = NULL;
    WCHAR *pwszDomainDN = NULL;

    // Get domain and config containers (%5, %6)

    *ppld = NULL;
    *pstrDomainDN = NULL;
    *pstrConfigDN = NULL;

    if (g_fUseDS)
    {
	HRESULT hr2;

	hr = myRobustLdapBind(ppld, FALSE);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myRobustLdapBind");
	}
	else
	{
	    hr = myGetAuthoritativeDomainDn(*ppld, pstrDomainDN, pstrConfigDN);
	    _PrintIfError(hr, "myGetAuthoritativeDomainDn");
	}
	if (S_OK != hr)
	{
	    LogEventStringHResult(
			EVENTLOG_ERROR_TYPE,
			MSG_E_DS_RETRY,
			pwszCommonName,
			hr);
	}
	hr2 = hr;

	hr = pkcsPatchDN(hr2, wszREGDSCONFIGDN, pstrConfigDN);
	_JumpIfError(hr, error, "pkcsPatchDN");

	hr = pkcsPatchDN(hr2, wszREGDSDOMAINDN, pstrDomainDN);
	_JumpIfError(hr, error, "pkcsPatchDN");
    }
    else
    {
	*pstrDomainDN = SysAllocString(L"");
	*pstrConfigDN = SysAllocString(L"");
	if (NULL == *pstrDomainDN || NULL == *pstrConfigDN)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocString");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
PKCSSetup(
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    LDAP *pld = NULL;
    DWORD LogMsg = MAXDWORD;
    BOOL fWarn = FALSE;

    // set crypt handles and load certificate chain

    hr = pkcsGetAuthoritativeDomainDn(
				pwszCommonName,
				&pld,
				&g_strDomainDN,
				&g_strConfigDN);
    if (S_OK != hr)
    {
	LogMsg = MSG_E_NO_DS;
	_JumpError(hr, error, "pkcsGetAuthoritativeDomainDn");
    }

    // get (multiple) CRL path templates

    hr = pkcsLoadTemplates(
		    wszREGCRLPUBLICATIONURLS,
		    &g_paRevURL,
		    &g_caRevURL);
    _PrintIfErrorStr(hr, "pkcsLoadTemplates", wszREGCRLPUBLICATIONURLS);

    // get (multiple) CA Cert path templates

    hr = pkcsLoadTemplates(
		    wszREGCACERTPUBLICATIONURLS,
		    &g_paCACertURL,
		    &g_caCACertURL);
    _PrintIfErrorStr(hr, "pkcsLoadTemplates", wszREGCACERTPUBLICATIONURLS);

    hr = DBOpen(pwszSanitizedName);
    if (S_OK != hr)
    {
	LogMsg = MSG_E_DB_INIT_FAILED;
	_JumpError(hr, error, "PKCSSetup:DBOpen");
    }

    hr = pkcsLoadCAContextArray(pwszCommonName, pwszSanitizedName);
    if (S_OK != hr)
    {
	LogMsg = MSG_E_CA_CHAIN;
	_JumpError(hr, error, "pkcsLoadCAContextArray");
    }

    hr = pkcsImportCAContextArray();
    _PrintIfError(hr, "pkcsImportCAContextArray");

    hr = pkcsVerifySignatureCertContextArray(pwszCommonName, &LogMsg, &fWarn);
    _JumpIfError(hr, error, "pkcsVerifySignatureCertContextArray");

    if (0 != g_cKRACertsRoundRobin)
    {
	hr = pkcsLoadKRACertArray();
	_PrintIfError(hr, "pkcsLoadKRACertArray");
    }

    hr = pkcsExpandURL(g_wszzLDAPKRACertURLTemplate, &g_pwszKRAPublishURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    hr = pkcsExpandURL(
		g_wszzLDAPIssuerCertURLTemplate,
		&g_pwszAIACrossCertPublishURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    hr = pkcsExpandURL(
		g_wszLDAPRootTrustURLTemplate,
		&g_pwszRootTrustCrossCertPublishURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    if (NULL != pld)
    {
	hr = pkcsVerifyDSCACert(pld);
	_PrintIfError(hr, "pkcsVerifyDSCACert");
    }

    hr = S_OK;

error:
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    if (S_OK != hr)
    {
	CSASSERT(MAXDWORD != LogMsg);
	if (!fWarn)
	{
	    PKCSTerminate();
	}
	LogEventStringHResult(
			fWarn? EVENTLOG_WARNING_TYPE : EVENTLOG_ERROR_TYPE,
			LogMsg,
			pwszCommonName,
			hr);
	if (fWarn)
	{
	    hr = S_OK;
	}
    }
    return(hr);
}


VOID
pkcsReleaseCACertificateChain(
    CERT_CONTEXT const **apCACertChain,
    DWORD                cCACertChain)
{
    DWORD i;

    if (NULL != apCACertChain)
    {
	for (i = 0; i < cCACertChain; ++i)
	{
	    CertFreeCertificateContext(apCACertChain[i]);
	}
	LocalFree(apCACertChain);
    }
}


VOID
pkcsReleaseCAContext(
    IN OUT CACTX *pCAContext)
{
    pkcsReleaseCACertificateChain(
			    pCAContext->apCACertChain,
			    pCAContext->cCACertChain);
    //pCAContext->apCACertChain = NULL;
    //pCAContext->pccCA = NULL;

    if (NULL != pCAContext->hProvCA)
    {
	CryptReleaseContext(pCAContext->hProvCA, 0);
    }
    if (NULL != pCAContext->IssuerKeyId.pbData)
    {
	LocalFree(pCAContext->IssuerKeyId.pbData);
    }
    if (NULL != pCAContext->pszObjIdSignatureAlgorithm)
    {
	LocalFree(pCAContext->pszObjIdSignatureAlgorithm);
    }
    if (NULL != pCAContext->KeyAuthority2Cert.pbData)
    {
	LocalFree(pCAContext->KeyAuthority2Cert.pbData);
    }
    if (NULL != pCAContext->KeyAuthority2CRL.pbData)
    {
	LocalFree(pCAContext->KeyAuthority2CRL.pbData);
    }
    if (NULL != pCAContext->CDPCert.pbData)
    {
	LocalFree(pCAContext->CDPCert.pbData);
    }
    if (NULL != pCAContext->CDPCRLFreshest.pbData)
    {
	LocalFree(pCAContext->CDPCRLFreshest.pbData);
    }
    if (NULL != pCAContext->CDPCRLBase.pbData)
    {
	LocalFree(pCAContext->CDPCRLBase.pbData);
    }
    if (NULL != pCAContext->CDPCRLDelta.pbData)
    {
	LocalFree(pCAContext->CDPCRLDelta.pbData);
    }
    if (NULL != pCAContext->AIACert.pbData)
    {
	LocalFree(pCAContext->AIACert.pbData);
    }
    if (NULL != pCAContext->pwszKeyContainerName)
    {
	LocalFree(pCAContext->pwszKeyContainerName);
    }
    if (NULL != pCAContext->papwszCRLFiles)
    {
	WCHAR **ppwsz;

	for (ppwsz = pCAContext->papwszCRLFiles; NULL != *ppwsz; ppwsz++)
	{
	    LocalFree(*ppwsz);
	}
	LocalFree(pCAContext->papwszCRLFiles);
    }
    if (NULL != pCAContext->papwszDeltaCRLFiles)
    {
	WCHAR **ppwsz;

	for (ppwsz = pCAContext->papwszDeltaCRLFiles; NULL != *ppwsz; ppwsz++)
	{
	    LocalFree(*ppwsz);
	}
	LocalFree(pCAContext->papwszDeltaCRLFiles);
    }
}


VOID
pkcsReleaseCAContextArray()
{
    DWORD i;

    if (NULL != g_aCAContext)
    {
	for (i = 0; i < g_cCACerts; i++)
	{
	    pkcsReleaseCAContext(&g_aCAContext[i]);
	}
	LocalFree(g_aCAContext);
	g_aCAContext = NULL;
    }
    g_cCACerts = 0;
    g_pCAContextCurrent = NULL;
}


// Trim  off leading and trailing whitespace and separator characters

WCHAR *
pkcsTrimToken(
    IN WCHAR *pwszIn,
    IN WCHAR wchSeparator)
{
    WCHAR *pwsz;

    while (wchSeparator == *pwszIn || iswspace(*pwszIn))
    {
	pwszIn++;
    }
    pwsz = &pwszIn[wcslen(pwszIn)];
    while (--pwsz >= pwszIn &&
	(wchSeparator == *pwsz || iswspace(*pwsz)))
    {
	*pwsz = L'\0';
    }
    if (L'\0' == *pwszIn)
    {
	pwszIn = NULL;
    }
    return(pwszIn);
}


WCHAR *
PKCSSplitToken(
    IN OUT WCHAR **ppwszIn,
    IN WCHAR *pwcSeparator,
    OUT BOOL *pfSplit)
{
    WCHAR *pwszOut = NULL;
    WCHAR *pwszNext = NULL;
    BOOL fSplit = FALSE;
    WCHAR *pwszIn;
    WCHAR *pwsz;

    pwszIn = *ppwszIn;
    if (NULL != pwszIn)
    {
	pwszOut = pwszIn;
	if (NULL != pwcSeparator)
	{
	    pwsz = wcschr(pwszIn, *pwcSeparator);
	    if (NULL != pwsz)
	    {
		*pwsz = L'\0';

		pwszNext = pkcsTrimToken(&pwsz[1], *pwcSeparator);
		pwszOut = pkcsTrimToken(pwszOut, *pwcSeparator);
		fSplit = TRUE;
	    }
	}
    }
    *ppwszIn = pwszNext;
    *pfSplit = fSplit;
    return(pwszOut);
}


HRESULT
PKCSSetSubjectTemplate(
    IN WCHAR const *pwszzTemplate)
{
    HRESULT hr;
    BOOL fSplit;
    WCHAR const *pwszz;
    WCHAR const *pwszPropName;
    BSTR  bstrToken;
    SUBJECTTABLE const **ppSubject;
    SUBJECTTABLE const **pps;
    SUBJECTTABLE const *pSubject;
    DWORD dwIndex;
    DWORD cchMax;

    hr = E_INVALIDARG;
    if (NULL == pwszzTemplate)
    {
	_JumpError(hr, error, "pwszzTemplate NULL");
    }
    ppSubject = pkcs_apSubject; // fill in this empty subject array with string matches

    for (pwszz = pwszzTemplate; L'\0' != *pwszz; pwszz += wcslen(pwszz) + 1)
    {
	pwszPropName = PKCSMapAttributeName(pwszz, NULL, &dwIndex, &cchMax);
	if (NULL == pwszPropName)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "PKCSMapAttributeName", pwszz);
	}

	for (pSubject = pkcs_subject; ; pSubject++)
	{
	    if (NULL == pSubject->pwszPropName)
	    {
		_JumpError(hr, error, "pkcs_subject lookup");
	    }
	    if (0 == lstrcmpi(pSubject->pwszPropName, pwszPropName))
	    {
		break;
	    }
	}
	for (pps = pkcs_apSubject; pps < ppSubject; pps++)
	{
	    if (*pps == pSubject)
	    {
		_JumpErrorStr(hr, error, "pkcs_subject duplicate", pwszz);
	    }
	}
	if (ppSubject >= &pkcs_apSubject[CSUBJECTTABLE])
	{
	    _JumpError(hr, error, "pkcs_subject overflow");
	}
	DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "Subject Template[%u]: %hs -- %ws\n",
	    SAFE_SUBTRACT_POINTERS(ppSubject, pkcs_apSubject),
	    pSubject->pszObjId,
	    pSubject->pwszPropName));
	*ppSubject++ = pSubject;
    }
    CSASSERT(ppSubject <= &pkcs_apSubject[CSUBJECTTABLE]);

    if (ppSubject == pkcs_apSubject)
    {
	_JumpError(hr, error, "pwszzTemplate empty");
    }
    pkcs_ppSubjectLast = ppSubject - 1;
    pkcsfSubjectTemplate = TRUE;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsSplitRDNComponents(
    IN SUBJECTTABLE const *pSubjectTable,
    IN OUT WCHAR *pwszRDN,	// Parsing stomps string in-place
    IN DWORD cAttrMax,
    OUT DWORD *pcAttr,
    OUT CERT_RDN_ATTR *rgAttr)
{
    HRESULT hr;
    DWORD cAttr;
    DWORD i;
    DWORD cwc;
    WCHAR *pwszRemain;
    WCHAR const *pwszToken;
    WCHAR *pwszT;
    BOOL fSplit;

    *pcAttr = 0;
    cAttr = 0;
    if (NULL != pwszRDN)
    {
	// Allocate memory for each RDN component filled in:

	pwszRemain = pwszRDN;
	while (TRUE)
	{
	    pwszToken = PKCSSplitToken(
				&pwszRemain,
				wszNAMESEPARATORDEFAULT,
				&fSplit);
	    if (NULL == pwszToken)
	    {
		break;
	    }

	    if (cAttr >= cAttrMax)
	    {
		hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		_JumpError(hr, error, "Subject RDN overflow");
	    }

	    cwc = wcslen(pwszToken);
	    if (g_fEnforceRDNNameLengths && cwc > pSubjectTable->cchMax)
	    {
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "RDN component too long: %u/%u: %ws[%u]=\"%ws\"\n",
		    cwc,
		    pSubjectTable->cchMax,
		    pSubjectTable->pwszPropName,
		    cAttr,
		    pwszToken));
		hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		_JumpErrorStr(hr, error, "RDN component too long", pwszToken);
	    }
	    pwszT = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	    if (NULL == pwszT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc(pwszToken)");
	    }
	    wcscpy(pwszT, pwszToken);

	    rgAttr[cAttr].pszObjId = (char *) pSubjectTable->pszObjId;
	    rgAttr[cAttr].dwValueType = CERT_RDN_ANY_TYPE;  // 'best' encoding
	    rgAttr[cAttr].Value.pbData = (BYTE *) pwszT;
	    rgAttr[cAttr].Value.cbData = 0;	// Indicate Unicode input

	    cAttr++;
	}
    }
    *pcAttr = cAttr;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	for (i = 0; i < cAttr; i++)
	{
	    LocalFree(rgAttr[i].Value.pbData);
	}
    }
    return(hr);
}


#define CSUBJECTRDNMAX	(4 * CSUBJECTTABLE)

HRESULT
pkcsEncodeSubjectName(
    IN ICertDBRow *prow,
    IN CERT_RDN_ATTR const *rgAttr,
    IN DWORD cAttr,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    DWORD i;
    DWORD cbprop;
    DWORD dwRequestFlags;
    DWORD dwFlags;
    CERT_RDN rgRDN[CSUBJECTRDNMAX];
    CERT_NAME_INFO nameinfo;

    CSASSERT(ARRAYSIZE(rgRDN) >= cAttr);
    for (i = 0; i < cAttr; i++)
    {
	rgRDN[i].cRDNAttr = 1;
	rgRDN[i].rgRDNAttr = (CERT_RDN_ATTR *) &rgAttr[i];
    }
    nameinfo.cRDN = cAttr;
    nameinfo.rgRDN = rgRDN;

    cbprop = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
			g_wszPropRequestFlags,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cbprop,
			(BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty");

    CSASSERT(sizeof(dwRequestFlags) == cbprop);
    dwFlags = 0;
    if (CR_FLG_FORCETELETEX & dwRequestFlags)
    {
	dwFlags |= CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    }
    if (CR_FLG_FORCEUTF8 & dwRequestFlags)
    {
	dwFlags |= CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;
    }

    if (!myEncodeName(
		X509_ASN_ENCODING,
		&nameinfo,
		dwFlags,
		CERTLIB_USE_LOCALALLOC,
		ppbData,
		pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeName");
    }

error:
    return(hr);
}


HRESULT
pkcsBuildSubjectFromNamesTable(
    IN ICertDBRow *prow,
    OUT CERT_NAME_BLOB *pSubject)
{
    HRESULT hr;
    DWORD cbData = 0;
    DWORD i;
    DWORD cAttr;
    DWORD cAttrT;
    CERT_RDN_ATTR rgAttr[CSUBJECTRDNMAX];
    SUBJECTTABLE const * const *ppSubject;
    WCHAR *pwszData = NULL;

    pSubject->pbData = NULL;
    CSASSERT(NULL != pkcs_ppSubjectLast);

    cAttr = 0;
    for (
	ppSubject = pkcs_ppSubjectLast;
	ppSubject >= pkcs_apSubject;
	ppSubject--)
    {
	hr = PKCSGetProperty(
		prow,
		(*ppSubject)->pwszPropName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbData,
		(BYTE **) &pwszData);
	if (S_OK != hr)
	{
	    continue;
	}
	if (0 != cbData)
	{

	    // Allocates memory for each RDN component filled in:

	    hr = pkcsSplitRDNComponents(
				*ppSubject,
				pwszData,
				ARRAYSIZE(rgAttr) - cAttr,
				&cAttrT,
				&rgAttr[cAttr]);
	    _JumpIfError(hr, error, "SplitRDNComponents");

	    cAttr += cAttrT;
	}
	LocalFree(pwszData);
	pwszData = NULL;
    }

    // done building string of subject entries, time to encode

    hr = pkcsEncodeSubjectName(
		    prow,
		    rgAttr,
		    cAttr,
		    &pSubject->pbData,
		    &pSubject->cbData);
    _JumpIfError(hr, error, "pkcsEncodeSubjectName");

    hr = prow->SetProperty(
		g_wszPropSubjectRawName,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		pSubject->cbData,
		pSubject->pbData);
    _JumpIfError(hr, error, "SetProperty");

    pkcsSetDistinguishedName(prow, PROPTABLE_CERTIFICATE, pSubject);

error:
    for (i = 0; i < cAttr; i++)
    {
	LocalFree(rgAttr[i].Value.pbData);
    }
    if (NULL != pwszData)
    {
	LocalFree(pwszData);
    }
    return(hr);
}


HRESULT
pkcsCheck7f(
    IN ICertDBRow *prow,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    OUT BOOL *pfErrorLogged)
{
    HRESULT hr;
    DWORD cbProp;
    WCHAR awcSubject[1024];
    WCHAR wszDword[2+8+1];
    WCHAR wszRequestId[11+1];
    WCHAR const *pwszDword;
    WORD cString = 0;
    WCHAR const *apwsz[4];

    DWORD State;
    DWORD Index1;
    DWORD Index2;
    DWORD cwcField;
    WCHAR wszField[128];
    DWORD cwcObjectId;
    WCHAR wszObjectId[128];
    WCHAR const *pwszObjectIdDescription = NULL;
	WCHAR *wszBuf=NULL;
    const DWORD dwDefaultBufSize = 2048*sizeof(WCHAR);

    *pfErrorLogged = FALSE;
    cwcField = sizeof(wszField)/sizeof(wszField[0]);
    cwcObjectId = sizeof(wszObjectId)/sizeof(wszObjectId[0]);
    hr = myCheck7f(
		pbCert,
		cbCert,
		FALSE,
		&State,
		&Index1,
		&Index2,
		&cwcField,
		wszField,
		&cwcObjectId,
		wszObjectId,
		&pwszObjectIdDescription);	// Static: do not free!
    _JumpIfError(hr, error, "myCheck7f");

    if (CHECK7F_NONE != State)
    {
	DWORD ReqId;

    wszBuf = (WCHAR*)LocalAlloc(LMEM_FIXED, dwDefaultBufSize);
    if (NULL == wszBuf)
    {
	hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }

	prow->GetRowId(&ReqId);
	wsprintf(wszRequestId, L"%u", ReqId);
	apwsz[cString++] = wszRequestId;
	apwsz[cString++] = wszDword;

	cbProp = sizeof(awcSubject);
	hr = prow->GetProperty(
		g_wszPropSubjectDistinguishedName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbProp,
		(BYTE *) awcSubject);
	if (S_OK != hr)
	{
	    _PrintError(hr, "GetProperty(DN)");
	    wcscpy(awcSubject, L"???");
	}
	apwsz[cString++] = awcSubject;

	wcscpy(wszBuf, wszField);
	if (0 != Index1)
	{
	    wsprintf(
		&wszBuf[wcslen(wszBuf)],
		0 != Index2? L"[%u,%u]" : L"[%u]",
		Index1 - 1,
		Index2 - 1);
	}

	if (0 != cwcObjectId)
	{
	    wcscat(wszBuf, L" ObjectId=");
	    wcscat(wszBuf, wszObjectId);
	}
	if (NULL != pwszObjectIdDescription)
	{
	// If buffer too small, reallocate enough space for old buffer,
	// OID description, () and trailing zero
	DWORD dwBufLen = (wcslen(wszBuf)+wcslen(pwszObjectIdDescription)+3)*
			 sizeof(WCHAR);
	if(dwDefaultBufSize<dwBufLen)
	{
	    WCHAR *pTempBuf = (WCHAR*)LocalReAlloc(
		wszBuf,
		dwBufLen,
		LMEM_MOVEABLE);
	    if(NULL == pTempBuf)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalReAlloc");
	    }
	    wszBuf = pTempBuf;
	}

	wcscat(wszBuf, L" (");
	    wcscat(wszBuf, pwszObjectIdDescription);
	    wcscat(wszBuf, L")");
	}
	apwsz[cString++] = wszBuf;

	hr = CERTSRV_E_ENCODING_LENGTH;
	wsprintf(wszDword, L"0x%x", hr);

	if (CERTLOG_ERROR <= g_dwLogLevel)
	{
	    LogEvent(
		EVENTLOG_ERROR_TYPE,
		MSG_E_BADCERTLENGTHFIELD,
		cString,
		apwsz);
	}

	CONSOLEPRINT4((
		    DBG_SS_CERTSRV,
		    "CertSrv Request %u: rc=%x: Bad encoded length detected: %ws \"%ws\"\n",
		    ReqId,
		    hr,
		    wszBuf,
		    awcSubject));
	*pfErrorLogged = TRUE;
    }
error:

    if (NULL != wszBuf)
    {
	    LocalFree(wszBuf);
    }
    return(hr);
}


HRESULT
pkcsCreateCertSerialNumber(
    IN ICertDBRow *prow,
    IN CACTX const *pCAContext,
    OUT BSTR *pstrSerialNumber)
{
    HRESULT hr;
    DWORD dw;
    USHORT us;
    BYTE abRandom[8];
    BYTE abSerial[max(
      sizeof(dw) + sizeof(us) + sizeof(dw),
      sizeof(dw) + sizeof(us) + sizeof(abRandom) + sizeof(dw) + sizeof(BYTE))];
    BSTR strSerialNumber = NULL;
    DWORD cbSerial;
    BYTE *pb;
    DWORD cb;
//#define TEST_SPECIAL_SERIAL_NUMBERS
#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    BOOL fAddZeroByte = FALSE;
#endif

    *pstrSerialNumber = NULL;
    pb = abSerial;

    prow->GetRowId(&dw);
    CopyMemory(pb, &dw, sizeof(dw));
    pb += sizeof(dw);

    us = (USHORT) pCAContext->iCert;
    CopyMemory(pb, &us, sizeof(us));
    pb += sizeof(us);

    if (0 != g_dwHighSerial)
    {
	if (!CryptGenRandom(
		    g_pCAContextCurrent->hProvCA,
		    ARRAYSIZE(abRandom),
		    abRandom))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptGenRandom");
	    memset(abRandom, g_dwHighSerial, sizeof(abRandom));
	}
	CopyMemory(pb, abRandom, sizeof(abRandom));
	pb += sizeof(abRandom);

	CopyMemory(pb, &dw, sizeof(dw));
	pb += sizeof(dw);

	*pb++ = (BYTE) g_dwHighSerial;
    }
    else
    {
	dw = GetTickCount();
	CopyMemory(pb, &dw, sizeof(dw));
	pb += sizeof(dw);
    }
    cbSerial = SAFE_SUBTRACT_POINTERS(pb, abSerial);

    // Make sure the sreial number doesn't overflow the buffer:

    CSASSERT(sizeof(abSerial) >= cbSerial);

    // IETF max serial number length is 20 bytes:

    CSASSERT(20 >= cbSerial);

    pb--;
    if (0 == *pb)
    {
	*pb = 'a';
    }
    else if (0 == (0xf0 & *pb))
    {
	*pb |= 0x10;	// make high nibble non-zero
    }
    *pb &= 0x7f;	// Some clients can't handle negative serial numbers:
#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    if (1 & abSerial[0])
    {
	*pb |= 0x80;	// Test negative serial numbers:
	if (2 & abSerial[0])
	{
	    *pb-- = 0;		// Test high zero byte serial numbers:
	    *pb |= 0x80;	// Test negative serial numbers:
	    fAddZeroByte = TRUE;
	}
    }
#endif

    hr = MultiByteIntegerToBstr(FALSE, cbSerial, abSerial, &strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    if (fAddZeroByte)
    {
	BSTR str = NULL;

	str = SysAllocStringLen(NULL, 2 + wcslen(strSerialNumber));
	if (NULL != str)
	{
	    wcscpy(str, L"00");
	    wcscat(str, strSerialNumber);
	    SysFreeString(strSerialNumber);
	    strSerialNumber = str;
	}
    }
#endif

    *pstrSerialNumber = strSerialNumber;
    strSerialNumber = NULL;
    hr = S_OK;

error:
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
PKCSVerifySubjectRDN(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropertyName,
    OPTIONAL IN WCHAR const *pwszPropertyValue,
    OUT BOOL *pfSubjectDot)
{
    HRESULT hr;
    WCHAR const *pwsz;
    WCHAR const *pwszName = pwszPropertyName;
    WCHAR wszPrefix[ARRAYSIZE(wszPROPSUBJECTDOT)];
    SUBJECTTABLE const *pSubjectTable;
    DWORD i;
    DWORD cAttr = 0;
    CERT_RDN_ATTR rgAttr[CSUBJECTRDNMAX];
    WCHAR *pwszValue = NULL;
    DWORD cbData;
    BYTE *pbData = NULL;

    hr = S_OK;
    *pfSubjectDot = FALSE;

    // Check to see if the request is for L"Subject.".

    pwsz = wcschr(pwszName, L'.');
    if (NULL != pwsz &&
	SAFE_SUBTRACT_POINTERS(pwsz, pwszName) + 2 == ARRAYSIZE(wszPrefix))
    {
	pwsz++;		// skip past L'.'

	CopyMemory(
	    wszPrefix,
	    pwszName,
	    (SAFE_SUBTRACT_POINTERS(pwsz, pwszName) * sizeof(WCHAR)));
	wszPrefix[ARRAYSIZE(wszPrefix) - 1] = L'\0';

	if (0 == lstrcmpi(wszPrefix, wszPROPSUBJECTDOT))
	{
	    pwszName = pwsz;
	    if (L'\0' == *pwszName)
	    {
		*pfSubjectDot = TRUE;
	    }
	}
    }

    if (!*pfSubjectDot)
    {
	for (pSubjectTable = pkcs_subject; ; pSubjectTable++)
	{
	    WCHAR const * const *ppwsz;

	    if (NULL == pSubjectTable->pwszPropName)
	    {
		goto error;
	    }

	    // Check for matching full name without "Subject." prefix:

	    pwsz = wcschr(pSubjectTable->pwszPropName, L'.');
	    if (NULL != pwsz && 0 == lstrcmpi(pwszName, &pwsz[1]))
	    {
		break;
	    }

	    // Check for matching OID:

	    if (!iswdigit(*pwszName))
	    {
		continue;
	    }
	    for (
		ppwsz = pSubjectTable->apwszAttributeName;
		NULL != *ppwsz;
		ppwsz++)
	    {
		if (*pwszName == **ppwsz && 0 == lstrcmp(pwszName, *ppwsz))
		{
		    break;
		}
	    }
	    if (NULL != *ppwsz)
	    {
		break;
	    }
	}
    }

    // It's a valid Certificate Table Subject RDN.  Call pkcsSplitRDNComponents
    // to split the string into individual RDN components and optionally
    // enforce each component is under the maximum length.

    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "PKCSVerifySubjectRDN(%ws) --> '%ws'\n",
	    pwszPropertyName,
	    pwszName));

    if (!*pfSubjectDot && NULL != pwszPropertyValue)
    {
	pwszValue = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszPropertyValue) + 1) * sizeof(WCHAR));
	if (NULL == pwszValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszValue, pwszPropertyValue);

	hr = pkcsSplitRDNComponents(
			    pSubjectTable,
			    pwszValue,
			    ARRAYSIZE(rgAttr),
			    &cAttr,
			    rgAttr);
	_JumpIfError(hr, error, "SplitRDNComponents");

	// Call myEncodeName merely to test for valid string data.
	// Some RDN OIDs are restricted to IA5 strings.

	hr = pkcsEncodeSubjectName(prow, rgAttr, cAttr, &pbData, &cbData);
	_JumpIfError(hr, error, "pkcsEncodeSubjectName");
    }
    hr = PKCSSetRequestFlags(prow, FALSE, CR_FLG_SUBJECTUNMODIFIED);
    _JumpIfError(hr, error, "PKCSSetRequestFlags");

error:
    for (i = 0; i < cAttr; i++)
    {
	LocalFree(rgAttr[i].Value.pbData);
    }
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
PKCSDeleteAllSubjectRDNs(
    IN ICertDBRow *prow,
    IN DWORD Flags)
{
    HRESULT hr;
    SUBJECTTABLE const *pSubjectTable;
    WCHAR const *pwszPropName = NULL;

    for (pSubjectTable = pkcs_subject; ; pSubjectTable++)
    {
	if (NULL == pSubjectTable->pwszPropName)
	{
	    break;
	}
	hr = prow->SetProperty(pSubjectTable->pwszPropName, Flags, 0, NULL);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsverifyIssuedPolices(
    IN CERT_CONTEXT const *pcc,
    IN CHAR const *pszObjId,
    OPTIONAL IN WCHAR const *pwszzPolicies)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    CERT_POLICIES_INFO *pcpsi = NULL;
    DWORD cb;
    DWORD i;
    WCHAR const *pwsz;
    WCHAR *pwszObjId = NULL;

    if (NULL == pwszzPolicies)
    {
	hr = S_OK;
	goto error;
    }
    pExt = CertFindExtension(
			pszObjId,
			pcc->pCertInfo->cExtension,
			pcc->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	hr = S_OK;
	goto error;
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_POLICIES,
		    pExt->Value.pbData,
		    pExt->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcpsi,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    for (i = 0; i < pcpsi->cPolicyInfo; i++)
    {
	CSASSERT(NULL == pwszObjId);

	if (!myConvertSzToWsz(
			&pwszObjId,
			pcpsi->rgPolicyInfo[i].pszPolicyIdentifier,
			-1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz(ObjId)");
	}
	for (pwsz = pwszzPolicies; ; pwsz += wcslen(pwsz) + 1)
	{
	    if (L'\0' == *pwsz)
	    {
		hr = CERT_E_INVALID_POLICY;
		_JumpErrorStr(hr, error, "Chain invalidates policy", pwszObjId);
	    }
	    if (0 == lstrcmp(pwsz, pwszObjId))
	    {
		break;
	    }
	}
	LocalFree(pwszObjId);
	pwszObjId = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pcpsi)
    {
	LocalFree(pcpsi);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsEncodeSubjectCert(
    IN ICertDBRow *prow,
    IN CACTX const *pCAContext,
    OUT BYTE **ppbEncoded,  // CoTaskMem*
    OUT DWORD *pcbEncoded,
    OUT BOOL *pfErrorLogged)
{
    HRESULT hr;
    HRESULT hrValidate = S_OK;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    DWORD ExtFlags;
    BSTR strSerialNumber = NULL;
    IEnumCERTDBNAME *penum = NULL;
    CERTDBNAME cdbn;
    FILETIME ftNotBefore;
    DWORD dwRequestFlags;
    WCHAR *pwszIssuer = NULL;
    WCHAR *pwszSubject = NULL;

    CERT_INFO Cert;
    CERT_EXTENSION *pExt = NULL;
    DWORD           cExt = INCREMENT_EXTENSIONS;

    DWORD cbprop;
    DWORD i;
    CHAR *pChar;
    CHAR szObjId[MAX_PATH];
    BYTE *pb;
    CERT_CONTEXT const *pcc = NULL;
    WCHAR *pwszzIssuancePolicies = NULL;
    WCHAR *pwszzApplicationPolicies = NULL;

    cdbn.pwszName = NULL;
    *pfErrorLogged = FALSE;

    // CERT
    ZeroMemory(&Cert, sizeof(Cert));
    pExt = (CERT_EXTENSION *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cExt * sizeof(*pExt));
    if (NULL == pExt)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    Cert.dwVersion = CERT_V3;

    hr = pkcsCreateCertSerialNumber(prow, pCAContext, &strSerialNumber);
    _JumpIfError(hr, error, "pkcsCreateCertSerialNumber");

    // convert to int
    hr = WszToMultiByteInteger(
			    FALSE,
			    strSerialNumber,
			    &Cert.SerialNumber.cbData,
			    &Cert.SerialNumber.pbData);
    _JumpIfError(hr, error, "WszToMultiByteInteger");


    Cert.SignatureAlgorithm.pszObjId = pCAContext->pszObjIdSignatureAlgorithm;
    Cert.Issuer = pCAContext->pccCA->pCertInfo->Subject;


    cbprop = sizeof(Cert.NotBefore);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbprop,
		    (BYTE *) &Cert.NotBefore);
    _JumpIfError(hr, error, "GetProperty");

    CSASSERT(sizeof(Cert.NotBefore) == cbprop);

    cbprop = sizeof(Cert.NotAfter);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotAfterDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbprop,
		    (BYTE *) &Cert.NotAfter);
    _JumpIfError(hr, error, "GetProperty");

    CSASSERT(sizeof(Cert.NotAfter) == cbprop);

    CSASSERT(NULL == Cert.Subject.pbData);

    cbprop = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
		g_wszPropRequestFlags,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cbprop,
		(BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty");

    if (!pkcsfSubjectTemplate ||
	((CRLF_REBUILD_MODIFIED_SUBJECT_ONLY & g_dwCRLFlags) &&
	 (CR_FLG_SUBJECTUNMODIFIED & dwRequestFlags)))
    {
	hr = PKCSGetProperty(
		    prow,
		    g_wszPropSubjectRawName,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &Cert.Subject.cbData,
		    &Cert.Subject.pbData);
	if (S_OK == hr &&
	    0 == Cert.Subject.cbData &&
	    NULL != Cert.Subject.pbData)
	{
	    LocalFree(Cert.Subject.pbData);
	    Cert.Subject.pbData = NULL;
	}
    }

    if (NULL == Cert.Subject.pbData)
    {
	hr = pkcsBuildSubjectFromNamesTable(prow, &Cert.Subject);
	_JumpIfError(hr, error, "pkcsBuildSubjectFromNamesTable");
    }

    if (CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &Cert.Issuer,
			    &Cert.Subject))
    {
	hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	_JumpError(hr, error, "Subject matches Issuer");
    }
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&Cert.Issuer,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwszIssuer);
    _JumpIfError(hr, error, "myCertNameToStr");

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&Cert.Subject,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwszSubject);
    _JumpIfError(hr, error, "myCertNameToStr");

    if (0 == lstrcmpi(pwszIssuer, pwszSubject))
    {
	hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	_JumpError(hr, error, "Subject string matches Issuer");
    }

    hr = pkcsGetPublicKeyInfo(prow, &Cert.SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsGetPublicKeyInfo");

    Cert.rgExtension = pExt;
    i = 0;

    hr = prow->EnumCertDBName(CIE_TABLE_EXTENSIONS, &penum);
    _JumpIfError(hr, error, "EnumCertDBName");

    hr = CERTSRV_E_PROPERTY_EMPTY;
    while (TRUE)
    {
	ULONG celtFetched;

	if (cExt == i)
	{
	    CERT_EXTENSION *pExtT;

	    // reached max, increse size
	    cExt += INCREMENT_EXTENSIONS;
	    pExtT = (CERT_EXTENSION *) LocalReAlloc(
						pExt,
						cExt * sizeof(*pExt),
						LMEM_ZEROINIT | LMEM_MOVEABLE);
	    if (NULL == pExtT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalReAlloc");
	    }
	    pExt = pExtT;
	    Cert.rgExtension = pExt;
	}

	hr = penum->Next(1, &cdbn, &celtFetched);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "Next");

	CSASSERT(1 == celtFetched);
	CSASSERT(NULL != cdbn.pwszName);

	if (!ConvertWszToSz(
			&Cert.rgExtension[i].pszObjId,
			cdbn.pwszName,
			-1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToSz(ExtObjId)");
	}

	hr = PropGetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_SERVER,
			cdbn.pwszName,
			&ExtFlags,
			&Cert.rgExtension[i].Value.cbData,
			&Cert.rgExtension[i].Value.pbData);
	_JumpIfError(hr, error, "PropGetExtension");

	DBGPRINT((
		DBG_SS_CERTSRVI,
		"pkcsEncodeSubjectCert: Ext=%ws, ExtFlags=%x, len=%x\n",
		cdbn.pwszName,
		ExtFlags,
		Cert.rgExtension[i].Value.cbData));

	Cert.rgExtension[i].fCritical =
	    (EXTENSION_CRITICAL_FLAG & ExtFlags)? TRUE : FALSE;

	CoTaskMemFree(cdbn.pwszName);
	cdbn.pwszName = NULL;

	if (EXTENSION_DISABLE_FLAG & ExtFlags)
	{
	    if (NULL != pExt[i].pszObjId)
	    {
		LocalFree(pExt[i].pszObjId);
		pExt[i].pszObjId = NULL;
	    }
	    if (NULL != pExt[i].Value.pbData)
	    {
		LocalFree(pExt[i].Value.pbData);
		pExt[i].Value.pbData = NULL;
	    }
	    continue;
	}
	i++;
    }

    Cert.cExtension = i;

    // encode the cert contents

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    &Cert,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbCertEncoded,
		    &cbCertEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    // sign the cert, then encode the signed info
    hr = myEncodeSignedContent(
			pCAContext->hProvCA,
			X509_ASN_ENCODING,
			Cert.SignatureAlgorithm.pszObjId,
			pbCertEncoded,
			cbCertEncoded,
			CERTLIB_USE_COTASKMEMALLOC,
			ppbEncoded,
			pcbEncoded); // use CoTaskMem*
    _JumpIfError(hr, error, "myEncodeSignedContent");

    pcc = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				*ppbEncoded,
				*pcbEncoded);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    if (g_fCertEnrollCompatible)
    {
	hr = pkcsCheck7f(
		    prow,
		    *ppbEncoded,
		    *pcbEncoded,
		    pfErrorLogged);
	if (S_OK != hr)
	{
	    CoTaskMemFree(*ppbEncoded);
	    *ppbEncoded = NULL;
	    _JumpError(hr, error, "pkcsCheck7f");
	}
    }

    ftNotBefore = pcc->pCertInfo->NotBefore;
    myMakeExprDateTime(&ftNotBefore, g_dwClockSkewMinutes, ENUM_PERIOD_MINUTES);

    hr = myVerifyCertContextEx(
			pcc,			// pCert
			(CRLF_REVCHECK_IGNORE_OFFLINE & g_dwCRLFlags)?
			    CA_VERIFY_FLAGS_IGNORE_OFFLINE : 0,
						// dwFlags
			0,			// cUsageOids
			NULL,			// apszUsageOids
			HCCE_LOCAL_MACHINE,	// hChainEngine
			&ftNotBefore,		// pft
			NULL,			// hAdditionalStore
			NULL,			// ppwszMissingIssuer
			&pwszzIssuancePolicies,
			&pwszzApplicationPolicies);
    _PrintIfError(hr, "myVerifyCertContextEx");
    if (S_OK != hr)
    {
	if (0 == (CRLF_SAVE_FAILED_CERTS & g_dwCRLFlags))
	{
	    goto error;
	}
	hrValidate = hr;
    }

    if (S_OK == hrValidate &&
	0 == (CRLF_IGNORE_INVALID_POLICIES & g_dwCRLFlags))
    {
	hr = pkcsverifyIssuedPolices(
				pcc,
				szOID_CERT_POLICIES,
				pwszzIssuancePolicies);
	_PrintIfError(hr, "pkcsverifyIssuedPolices");
	if (S_OK != hr)
	{
	    if (0 == (CRLF_SAVE_FAILED_CERTS & g_dwCRLFlags))
	    {
		goto error;
	    }
	    if (S_OK == hrValidate)
	    {
		hrValidate = hr;
	    }
	}

	hr = pkcsverifyIssuedPolices(
				pcc,
				szOID_APPLICATION_CERT_POLICIES,
				pwszzApplicationPolicies);
	_PrintIfError(hr, "pkcsverifyIssuedPolices");
	if (S_OK != hr)
	{
	    if (0 == (CRLF_SAVE_FAILED_CERTS & g_dwCRLFlags))
	    {
		goto error;
	    }
	    if (S_OK == hrValidate)
	    {
		hrValidate = hr;
	    }
	}
    }

    hr = pkcsSetCertAndKeyHashes(prow, pcc);
    _JumpIfError(hr, error, "pkcsSetCertAndKeyHashes");

    hr = prow->SetProperty(
		    g_wszPropCertificateIssuerNameID,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    sizeof(pCAContext->NameId),
		    (BYTE *) &pCAContext->NameId);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCertificateSerialNumber,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    MAXDWORD,
		    (BYTE *) strSerialNumber);
    _JumpIfError(hr, error, "SetProperty");

#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    if (L'0' == strSerialNumber[0] && L'0' == strSerialNumber[1])
    {
	hr = prow->SetProperty(
		    g_wszPropCertificateSerialNumber,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    MAXDWORD,
		    (BYTE *) &strSerialNumber[2]);
	_JumpIfError(hr, error, "SetProperty");
    }
#endif

error:
    if (S_OK != hrValidate)
    {
	hr = hrValidate;
    }
    if (NULL != pwszIssuer)
    {
	LocalFree(pwszIssuer);
    }
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != pwszzIssuancePolicies)
    {
	LocalFree(pwszzIssuancePolicies);
    }
    if (NULL != pwszzApplicationPolicies)
    {
	LocalFree(pwszzApplicationPolicies);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pExt)
    {
	i = 0;
	if (NULL != cdbn.pwszName)
	{
	    CoTaskMemFree(cdbn.pwszName);
	}
	while (cExt != i)
	{
	    if (NULL != pExt[i].pszObjId)
	    {
		LocalFree(pExt[i].pszObjId);
	    }
	    if (NULL != pExt[i].Value.pbData)
	    {
		LocalFree(pExt[i].Value.pbData);
	    }
	    i++;
	}
	LocalFree(pExt);
    }
    if (NULL != penum)
    {
	penum->Release();
    }
    if (NULL != Cert.SerialNumber.pbData)
    {
	LocalFree(Cert.SerialNumber.pbData);
    }
    if (NULL != Cert.Subject.pbData)
    {
	LocalFree(Cert.Subject.pbData);
    }
    pkcsFreePublicKeyInfo(&Cert.SubjectPublicKeyInfo);
    if (NULL != pbCertEncoded)
    {
	LocalFree(pbCertEncoded);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


VOID
pkcsFreeCRLChain(
    IN DWORD cCert,
    OPTIONAL IN OUT CERT_BLOB *prgCertBlob,
    OPTIONAL IN OUT CERT_CONTEXT const **rgCert,
    IN DWORD cCRL,
    OPTIONAL IN OUT CRL_BLOB *rgCRLBlob,
    OPTIONAL IN OUT CRL_CONTEXT const **rgCRL)
{
    DWORD i;

    if (NULL != prgCertBlob)
    {
	LocalFree(prgCertBlob);
    }
    if (NULL != rgCert)
    {
	for (i = 0; i < cCert; i++)
	{
	    if (NULL != rgCert[i])
	    {
		CertFreeCertificateContext(rgCert[i]);
	    }
	}
	LocalFree(rgCert);
    }
    if (NULL != rgCRLBlob)
    {
	LocalFree(rgCRLBlob);
    }
    if (NULL != rgCRL)
    {
	for (i = 0; i < cCRL; i++)
	{
	    if (NULL != rgCRL[i])
	    {
		CertFreeCRLContext(rgCRL[i]);
	    }
	}
	LocalFree(rgCRL);
    }
}


// Build the CA's cert chain and collect all paremt CA CRLs.
// Add in the optional passed leaf cert and the CA's CRLs.
// This ensures that the chain includes at least this CA's correct cert & CRLs.


HRESULT
pkcsBuildCRLChain(
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BOOL fIncludeCRLs,
    OUT DWORD *pcCert,
    OPTIONAL OUT CERT_BLOB **prgCertBlob,
    OUT CERT_CONTEXT const ***prgCert,
    OUT DWORD *pcCRLBlob,
    OPTIONAL OUT CRL_BLOB **prgCRLBlob,
    OUT CRL_CONTEXT const ***prgCRL)
{
    HRESULT hr;
    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    DWORD cElement;
    CERT_CHAIN_ELEMENT **rgpElement;
    DWORD cCert;
    CERT_CONTEXT const **rgpCert = NULL;
    CERT_CONTEXT const *pccCertLeaf = NULL;
    CERT_BLOB *rgCertBlob = NULL;
    DWORD cCRL;
    CRL_CONTEXT const **rgpCRL = NULL;
    CRL_BLOB *rgCRLBlob = NULL;
    DWORD i;
    DWORD iCert;
    DWORD iCRL;

    if (NULL != prgCertBlob)
    {
	*prgCertBlob = NULL;
    }
    *prgCert = NULL;
    if (NULL != prgCRLBlob)
    {
	*prgCRLBlob = NULL;
    }
    *prgCRL = NULL;

    if (NULL != pbCertLeaf)
    {
	pccCertLeaf = CertCreateCertificateContext(
						X509_ASN_ENCODING,
						pbCertLeaf,
						cbCertLeaf);
	if (NULL == pccCertLeaf)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
    }
    CSASSERT(NULL != pCAContext || NULL != pccCertLeaf);
    if (NULL == pCAContext || fIncludeCRLs)
    {
	// Get the CA cert chain and parent CA CRLs:

	ZeroMemory(&ChainParams, sizeof(ChainParams));
	ChainParams.cbSize = sizeof(ChainParams);
	//ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
	//ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
	//ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

	if (!CertGetCertificateChain(
				HCCE_LOCAL_MACHINE,	// hChainEngine
				NULL != pCAContext?
				    pCAContext->pccCA : pccCertLeaf,
				NULL,		// pTime
				NULL,		// hAdditionalStore
				&ChainParams,	// pChainPara
				CERT_CHAIN_REVOCATION_CHECK_END_CERT |
				     CERT_CHAIN_REVOCATION_CHECK_CHAIN,
				NULL,		// pvReserved
				&pChainContext))	// ppChainContext
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateChain");
	}
	if (0 == pChainContext->cChain ||
	    0 == pChainContext->rgpChain[0]->cElement)
	{
	    hr = CRYPT_E_NOT_FOUND;
	    _JumpError(hr, error, "No chain");
	}
	cElement = pChainContext->rgpChain[0]->cElement;
	rgpElement = pChainContext->rgpChain[0]->rgpElement;
    }
    else
    {
	cElement = pCAContext->cCACertChain;
    }
    cCert = cElement;
    cCRL = 2 * (cCert + 1);	// Worst case.  *Always* include this CA's CRLs
    if (NULL != pbCertLeaf)
    {
	cCert++;
    }
    rgpCert = (CERT_CONTEXT const **) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    cCert * sizeof(rgpCert[0]));
    if (NULL == rgpCert)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (fIncludeCRLs)
    {
	rgpCRL = (CRL_CONTEXT const **) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    cCRL * sizeof(rgpCRL[0]));
	if (NULL == rgpCRL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    iCert = 0;
    iCRL = 0;

    // Add parent CA certs and CRLs:

    if (NULL == pCAContext || fIncludeCRLs)
    {
	for (i = 0; i < cElement; i++)
	{
	    CERT_CHAIN_ELEMENT const *pElement = rgpElement[i];
	    CERT_REVOCATION_INFO *pRevocationInfo;

	    rgpCert[iCert] = CertDuplicateCertificateContext(
						    pElement->pCertContext);
	    if (NULL != rgpCert[iCert])
	    {
		iCert++;
	    }
	    pRevocationInfo = pElement->pRevocationInfo;

	    if (fIncludeCRLs &&
		NULL != pRevocationInfo &&
		CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		    pRevocationInfo->cbSize &&
		NULL != pRevocationInfo->pCrlInfo)
	    {
		CERT_REVOCATION_CRL_INFO *pCrlInfo;

		pCrlInfo = pRevocationInfo->pCrlInfo;
		if (NULL != pCrlInfo)
		{
		    if (NULL != pCrlInfo->pBaseCrlContext)
		    {
			rgpCRL[iCRL] = CertDuplicateCRLContext(
						pCrlInfo->pBaseCrlContext);
			if (NULL != rgpCRL[iCRL])
			{
			    iCRL++;
			}
		    }
		    if (NULL != pCrlInfo->pDeltaCrlContext)
		    {
			rgpCRL[iCRL] = CertDuplicateCRLContext(
						pCrlInfo->pDeltaCrlContext);
			if (NULL != rgpCRL[iCRL])
			{
			    iCRL++;
			}
		    }
		}
	    }
	}
    }
    else
    {
	for (i = 0; i < pCAContext->cCACertChain; i++)
	{
	    rgpCert[iCert] = CertDuplicateCertificateContext(
					    pCAContext->apCACertChain[i]);
	    if (NULL != rgpCert[iCert])
	    {
		iCert++;
	    }
	}
    }

    if (NULL != pCAContext)
    {
	// Add issued cert at the end -- optional Leaf cert:

	if (NULL != pbCertLeaf)
	{
	    for (i = 0; i < iCert; i++)
	    {
		if (cbCertLeaf == rgpCert[i]->cbCertEncoded &&
		    0 == memcmp(
			    pbCertLeaf,
			    rgpCert[i]->pbCertEncoded,
			    cbCertLeaf))
		{
		    break;
		}
	    }
	    if (i == iCert)	// if not found in existing array
	    {
		rgpCert[iCert] = CertDuplicateCertificateContext(pccCertLeaf);
		if (NULL != rgpCert[iCert])
		{
		    iCert++;
		}
	    }
	}

	// Add current CA's Base and delta CRLs:

	if (fIncludeCRLs)
	{
	    hr = CRLGetCRL(
			pCAContext->iKey,
			FALSE,		// fDelta
			&rgpCRL[iCRL],
			NULL);		// pdwCRLPublishFlags
	    _JumpIfError(hr, error, "CRLGetCRL(base)"); // Base CRL must exist

	    iCRL++;

	    hr = CRLGetCRL(
			pCAContext->iKey,
			TRUE,		// fDelta
			&rgpCRL[iCRL],
			NULL);		// pdwCRLPublishFlags
	    _PrintIfError(hr, "CRLGetCRL(delta)");	// Delta CRL might not exist
	    if (S_OK == hr)
	    {
		iCRL++;
	    }
	}
    }
    CSASSERT(iCert <= cCert);
    CSASSERT(iCRL <= cCRL);

    if (NULL != prgCertBlob)
    {
	rgCertBlob = (CERT_BLOB *) LocalAlloc(
					LMEM_FIXED,
					iCert * sizeof(rgCertBlob[0]));
	if (NULL == rgCertBlob)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	for (i = 0; i < iCert; i++)
	{
	    rgCertBlob[i].cbData = rgpCert[i]->cbCertEncoded;
	    rgCertBlob[i].pbData = rgpCert[i]->pbCertEncoded;
	}
    }
    if (NULL != prgCRLBlob && 0 != iCRL)
    {
	rgCRLBlob = (CERT_BLOB *) LocalAlloc(
					LMEM_FIXED,
					iCRL * sizeof(rgCRLBlob[0]));
	if (NULL == rgCRLBlob)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	for (i = 0; i < iCRL; i++)
	{
	    rgCRLBlob[i].cbData = rgpCRL[i]->cbCrlEncoded;
	    rgCRLBlob[i].pbData = rgpCRL[i]->pbCrlEncoded;
	}
    }
    *pcCert = iCert;
    *prgCert = rgpCert;
    rgpCert = NULL;
    if (NULL != prgCertBlob)
    {
	*prgCertBlob = rgCertBlob;
	rgCertBlob = NULL;
    }

    *pcCRLBlob = iCRL;
    *prgCRL = rgpCRL;
    rgpCRL = NULL;
    if (NULL != prgCRLBlob)
    {
	*prgCRLBlob = rgCRLBlob;
	rgCRLBlob = NULL;
    }

    hr = S_OK;

error:
    pkcsFreeCRLChain(cCert, rgCertBlob, rgpCert, cCRL, rgCRLBlob, rgpCRL);
    if (NULL != pccCertLeaf)
    {
        CertFreeCertificateContext(pccCertLeaf);
    }
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


// Build a PKCS7 CMC response

HRESULT
PKCSEncodeFullResponse(
    OPTIONAL IN ICertDBRow *prow,
    IN CERTSRV_RESULT_CONTEXT const *pResult,
    IN HRESULT hrRequest,
    IN WCHAR *pwszDispositionString,
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbResponse,    // CoTaskMem*
    OUT DWORD *pcbResponse)
{
    HRESULT hr;
    CMC_RESPONSE_INFO Response;
    CMC_STATUS_INFO Status;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    DWORD dwBodyPartIdOfRequest = 1;
    DWORD dwCMCDataReference = 0;
    DWORD dwBodyPartId = 1;
    CMC_TAGGED_ATTRIBUTE aTaggedAttribute[5];
    DWORD ita = 0;
    CRYPT_ATTRIBUTE aAttr[2];
    DWORD iAttr = 0;
    CRYPT_ATTR_BLOB aAttrBlob[7];
    DWORD iblob = 0;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CMC_PEND_INFO PendInfo;
    DWORD ReqId;
    DWORD dwRequestFlags;
    DWORD cb;
    DWORD i;
    HCRYPTMSG hMsg = NULL;
    CERT_CONTEXT const **prgCert = NULL;
    CRL_CONTEXT const **prgCRL = NULL;
    CHAR szNonce[(11 + 1) + (8 + 1) * 3];

    ZeroMemory(aAttrBlob, sizeof(aAttrBlob));
    ZeroMemory(&Status, sizeof(Status));
    ZeroMemory(&Response, sizeof(Response));

    ZeroMemory(&SignedMsgEncodeInfo, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.cSigners = 1;
    SignedMsgEncodeInfo.rgSigners = &SignerEncodeInfo;
    //SignedMsgEncodeInfo.cCertEncoded = 0;
    //SignedMsgEncodeInfo.rgCertEncoded = NULL;
    //SignedMsgEncodeInfo.cCrlEncoded = 0;
    //SignedMsgEncodeInfo.rgCrlEncoded = NULL;

    Status.cBodyList = 1;
    Status.dwOtherInfoChoice = CMC_OTHER_INFO_NO_CHOICE;
    Status.rgdwBodyList = &dwBodyPartIdOfRequest;
    Status.pwszStatusString = pwszDispositionString;

    switch (*pResult->pdwDisposition)
    {
	case CR_DISP_ISSUED:
	case CR_DISP_ISSUED_OUT_OF_BAND:
	case CR_DISP_REVOKED:	// map revoked to CMC_STATUS_FAILED?
	    Status.dwStatus = CMC_STATUS_SUCCESS;
	    break;

	case CR_DISP_UNDER_SUBMISSION:
	    Status.dwStatus = CMC_STATUS_PENDING;
	    Status.dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
	    Status.pPendInfo = &PendInfo;

	    CSASSERT(NULL != prow);
	    prow->GetRowId(&ReqId);

	    PendInfo.PendToken.cbData = sizeof(ReqId);
	    PendInfo.PendToken.pbData = (BYTE *) &ReqId;

	    cb = sizeof(PendInfo.PendTime);
	    hr = prow->GetProperty(
			g_wszPropRequestSubmittedWhen,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cb,
			(BYTE *) &PendInfo.PendTime);
	    _JumpIfError(hr, error, "GetProperty");

	    break;

	//case CR_DISP_INCOMPLETE:
	//case CR_DISP_ERROR:
	//case CR_DISP_DENIED:
	default:
	    Status.dwStatus = CMC_STATUS_FAILED;
	    if (NULL != prow)
	    {
		cb = sizeof(hrRequest);
		hr = prow->GetProperty(
			g_wszPropRequestStatusCode,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			&cb,
			(BYTE *) &hrRequest);
		_JumpIfError(hr, error, "GetProperty(status code)");
	    }
	    switch (hrRequest)
	    {
		case CERTSRV_E_BAD_REQUESTSUBJECT:
		    Status.dwFailInfo = CMC_FAIL_BAD_REQUEST;
		    Status.dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
		    break;
	    }
	    break;
    }

    // Encode control attributes for Status, Transaction Id, Sender and
    // Recipient Nonces and Issued Cert Hash.

    ZeroMemory(aTaggedAttribute, sizeof(aTaggedAttribute));

    // Status:

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_STATUS,
		    &Status,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aAttrBlob[iblob].pbData,
		    &aAttrBlob[iblob].cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
    aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_STATUS_INFO;
    aTaggedAttribute[ita].Attribute.cValue = 1;
    aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
    iblob++;
    ita++;

    // Transaction Id:

    if (pResult->fTransactionId)
    {
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			&pResult->dwTransactionId,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
	aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_TRANSACTION_ID;
	aTaggedAttribute[ita].Attribute.cValue = 1;
	aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
	iblob++;
	ita++;
    }

    if (NULL != pResult->pbSenderNonce && 0 != pResult->cbSenderNonce)
    {
	CRYPT_DATA_BLOB Blob;
	FILETIME ft;
	DWORD dw;
	DWORD cch;

	// Recipient Nonce:

	Blob.pbData = const_cast<BYTE *>(pResult->pbSenderNonce);
	Blob.cbData = pResult->cbSenderNonce;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&Blob,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
	aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_RECIPIENT_NONCE;
	aTaggedAttribute[ita].Attribute.cValue = 1;
	aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
	iblob++;
	ita++;

	// Sender Nonce:

	GetSystemTimeAsFileTime(&ft);
	dw = GetTickCount();

	cch = sprintf(
		    szNonce,
		    "%u %08lx %08lx-%08lx",
		    *pResult->pdwRequestId,
		    dw,
		    ft.dwHighDateTime,
		    ft.dwLowDateTime);
	CSASSERT(ARRAYSIZE(szNonce) > cch);

	Blob.pbData = (BYTE *) szNonce;
	Blob.cbData = cch;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&Blob,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
	aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_SENDER_NONCE;
	aTaggedAttribute[ita].Attribute.cValue = 1;
	aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
	iblob++;
	ita++;
    }

    // Issued Cert Hash:

    if (NULL != pbCertLeaf)
    {
	CSASSERT(NULL != prow);
	hr = pkcsGetHashAsOctet(
			prow,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData);
	_JumpIfError(hr, error, "pkcsGetHashAsOctet");

	aAttr[iAttr].pszObjId = szOID_ISSUED_CERT_HASH;
	aAttr[iAttr].cValue = 1;
	aAttr[iAttr].rgValue = &aAttrBlob[iblob];
	iblob++;
	iAttr++;
    }

    // Computed hash of private key encrypted to this CA, for client
    // confirmation.

    if (NULL != pResult->pbKeyHashOut)
    {
	CRYPT_DATA_BLOB Blob;

	Blob.pbData = pResult->pbKeyHashOut;
	Blob.cbData = pResult->cbKeyHashOut;
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&Blob,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aAttr[iAttr].pszObjId = szOID_ENCRYPTED_KEY_HASH;
	aAttr[iAttr].cValue = 1;
	aAttr[iAttr].rgValue = &aAttrBlob[iblob];
	iblob++;
	iAttr++;
    }

    if (0 != iAttr)
    {
	hr = BuildCMCAttributes(
			iAttr,		// cAttribute
			aAttr,		// rgAttribute
			dwCMCDataReference,
			dwBodyPartIdOfRequest,
			dwBodyPartId++,
			&aTaggedAttribute[ita],
			&aAttrBlob[iblob]);
	_JumpIfError(hr, error, "BuildCMCAttributes");

	iblob++;
	ita++;
    }

    CSASSERT(ARRAYSIZE(aTaggedAttribute) >= ita);
    CSASSERT(ARRAYSIZE(aAttr) >= iAttr);
    CSASSERT(ARRAYSIZE(aAttrBlob) >= iblob);

    Response.cTaggedAttribute = ita;
    Response.rgTaggedAttribute = aTaggedAttribute;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_RESPONSE,
		    &Response,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbContent,
		    &cbContent))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    if (NULL == pCAContext)
    {
	pCAContext = g_pCAContextCurrent;
    }
    ZeroMemory(&SignerEncodeInfo, sizeof(SignerEncodeInfo));
    SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);
    SignerEncodeInfo.pCertInfo = pCAContext->pccCA->pCertInfo;
    SignerEncodeInfo.hCryptProv = pCAContext->hProvCA;
    SignerEncodeInfo.dwKeySpec = AT_SIGNATURE;
    SignerEncodeInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    //SignerEncodeInfo.pvHashAuxInfo = NULL;
    //SignerEncodeInfo.cAuthAttr = 0;
    //SignerEncodeInfo.rgAuthAttr = NULL;
    //SignerEncodeInfo.cUnauthAttr = 0;
    //SignerEncodeInfo.rgUnauthAttr = NULL;

    if (NULL != pbCertLeaf)
    {
	hr = pkcsBuildCRLChain(
			pCAContext,
			pbCertLeaf,
			cbCertLeaf,
			fIncludeCRLs,
			&SignedMsgEncodeInfo.cCertEncoded,
			&SignedMsgEncodeInfo.rgCertEncoded,
			&prgCert,
			&SignedMsgEncodeInfo.cCrlEncoded,
			&SignedMsgEncodeInfo.rgCrlEncoded,
			&prgCRL);
	_JumpIfError(hr, error, "pkcsBuildCRLChain");
    }

    dwRequestFlags = 0;
    if (NULL != prow)
    {
	cb = sizeof(dwRequestFlags);
	hr = prow->GetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &cb,
		    (BYTE *) &dwRequestFlags);
	_JumpIfError(hr, error, "GetProperty");
    }

#define szOID_CT_PKI_RESPONSE_OLDRFC "1.3.6.1.5.5.7.5.3" // BUGBUG: temporary!
    hMsg = CryptMsgOpenToEncode(
			PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			CMSG_CMS_ENCAPSULATED_CONTENT_FLAG,	// dwFlags
			CMSG_SIGNED,
			&SignedMsgEncodeInfo,
			(CR_FLG_OLDRFCCMC & dwRequestFlags)?
			    szOID_CT_PKI_RESPONSE_OLDRFC :
			    szOID_CT_PKI_RESPONSE,
			NULL);		// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToEncode");
    }

    if (!CryptMsgUpdate(hMsg, pbContent, cbContent, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    // Return the encoded and signed content.
    // Use CMSG_CONTENT_PARAM to get the signed message.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
		    CERTLIB_USE_COTASKMEMALLOC,
		    (VOID **) ppbResponse,
		    pcbResponse);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

error:
    pkcsFreeCRLChain(
		SignedMsgEncodeInfo.cCertEncoded,
		SignedMsgEncodeInfo.rgCertEncoded,
		prgCert,
		SignedMsgEncodeInfo.cCrlEncoded,
		SignedMsgEncodeInfo.rgCrlEncoded,
		prgCRL);
    for (i = 0; i < ARRAYSIZE(aAttrBlob); i++)
    {
	if (NULL != aAttrBlob[i].pbData)
	{
	    LocalFree(aAttrBlob[i].pbData);
	}
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pbContent)
    {
	LocalFree(pbContent);
    }
    return(hr);
}


// Build a PKCS7 NULL signature with encapsulated certs

HRESULT
pkcsEncodeCertChain(
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BYTE const *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCertChain,    // CoTaskMem*
    OUT DWORD *pcbCertChain)
{
    HRESULT hr;
    CRYPT_SIGN_MESSAGE_PARA csmp;
    CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm = { szOID_OIWSEC_sha1, 0, 0 };

    // init csmp for empty signature

    ZeroMemory(&csmp, sizeof(csmp));
    csmp.cbSize = sizeof(csmp);
    csmp.dwMsgEncodingType = PKCS_7_ASN_ENCODING;
    //csmp.pSigningCert = NULL;
    csmp.HashAlgorithm = DigestAlgorithm;
    //csmp.cMsgCert = 0;
    //csmp.rgpMsgCert = NULL;
    //csmp.cMsgCrl = 0;
    //csmp.rgpMsgCrl = NULL;

    hr = pkcsBuildCRLChain(
		    pCAContext,
		    pbCertLeaf,
		    cbCertLeaf,
		    fIncludeCRLs,
		    &csmp.cMsgCert,
		    NULL,
		    &csmp.rgpMsgCert,
		    &csmp.cMsgCrl,
		    NULL,
		    &csmp.rgpMsgCrl);
    _JumpIfError(hr, error, "pkcsBuildCRLChain");

    if (!myCryptSignMessage(
			&csmp,
			pbToBeSigned,
			cbToBeSigned,
			CERTLIB_USE_COTASKMEMALLOC,
			ppbCertChain,
			pcbCertChain))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignMessage");
    }
    hr = S_OK;

error:
    pkcsFreeCRLChain(
		csmp.cMsgCert,
		NULL,
		csmp.rgpMsgCert,
		csmp.cMsgCrl,
		NULL,
		csmp.rgpMsgCrl);
    return(hr);
}


HRESULT
PKCSGetCACert(
    IN DWORD iCert,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert)
{
    HRESULT hr;
    DWORD State;
    CACTX *pCAContext;

    hr = PKCSMapCertIndex(iCert, &iCert, &State);
    _JumpIfError(hr, error, "PKCSMapCertIndex");

    // Now we know iCert is a valid Cert Index:

    pCAContext = &g_aCAContext[iCert];
    if (NULL == pCAContext->pccCA)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid cert");
    }
    *pcbCACert = pCAContext->pccCA->cbCertEncoded;
    *ppbCACert = pCAContext->pccCA->pbCertEncoded;

error:
    return(hr);
}


HRESULT
PKCSGetCAChain(
    IN DWORD iCert,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain)
{
    HRESULT hr;
    DWORD State;
    CACTX *pCAContext;

    hr = PKCSMapCertIndex(iCert, &iCert, &State);
    _JumpIfError(hr, error, "PKCSMapCertIndex");

    // Now we know iCert is a valid Cert Index:

    pCAContext = &g_aCAContext[iCert];
    if (NULL == pCAContext->pccCA)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid cert");
    }
    hr = pkcsEncodeCertChain(
			pCAContext,
			NULL,				  // pbCertLeaf
			0,				  // cbCertLeaf
			pCAContext->pccCA->pbCertEncoded, // pbToBeSigned
			pCAContext->pccCA->cbCertEncoded, // cbToBeSigned
			fIncludeCRLs,
			ppbCAChain,			  // CoTaskMem*
			pcbCAChain);
    _JumpIfError(hr, error, "PKCSEncodeCertChain");

error:
    return(hr);
}


HRESULT
pkcsFormXchgKeyContainerName(
    IN DWORD dwRequestId,
    OUT WCHAR **ppwszKeyContainer)
{
    HRESULT hr;
    DWORD cwcSuffix;
    DWORD cwcName;
    WCHAR wszSuffix[32];
    WCHAR wszKeyContainer[MAX_PATH];

    *ppwszKeyContainer = NULL;

    cwcSuffix = wsprintf(wszSuffix, L"%ws(%u)", g_wszCNXchgSuffix, dwRequestId);
    CSASSERT(ARRAYSIZE(wszSuffix) > cwcSuffix);

    cwcName = wcslen(g_wszSanitizedName);
    if (cwcName > MAX_PATH - cwcSuffix)
    {
	cwcName = MAX_PATH - cwcSuffix;
    }
    CSASSERT(ARRAYSIZE(wszKeyContainer) > cwcName);
    wcscpy(wszKeyContainer, g_wszSanitizedName);
    wcscpy(&wszKeyContainer[cwcName], wszSuffix);

    hr = myDupString(wszKeyContainer, ppwszKeyContainer);
    _JumpIfError(hr, error, "myDupString");

    DBGPRINT((
	DBG_SS_CERTSRV,
	"pkcsFormXchgKeyContainerName: %ws\n",
	*ppwszKeyContainer));

error:
    return(hr);
}


HRESULT
pkcsAcquireKey(
    OPTIONAL IN WCHAR const *pwszKeyContainer,
    OUT HCRYPTPROV *phProv)
{
    HRESULT hr;

    *phProv = NULL;
    if (!CryptAcquireContext(
			phProv,
			pwszKeyContainer,
			g_pwszXchgProvName,
			g_dwXchgProvType,
			g_fXchgMachineKeyset? CRYPT_MACHINE_KEYSET : 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
pkcsDeleteKey(
    OPTIONAL IN WCHAR const *pwszKeyContainer)
{
    HRESULT hr;
    HCRYPTPROV hProv;

    if (NULL != pwszKeyContainer)
    {
	if (!CryptAcquireContext(
			    &hProv,
			    pwszKeyContainer,
			    g_pwszXchgProvName,
			    g_dwXchgProvType,
			    CRYPT_DELETEKEYSET |
			     (g_fXchgMachineKeyset? CRYPT_MACHINE_KEYSET : 0)))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptAcquireContext");
	}
    }
error:
    ;
}


VOID
pkcsLoadCAXchgCSPInfo(
    IN BOOL fSetDefaults)
{
    HRESULT hr = S_FALSE;

    if (NULL != g_pwszXchgProvName)
    {
	LocalFree(g_pwszXchgProvName);
	g_pwszXchgProvName = NULL;
    }
    if (!fSetDefaults)
    {
	hr = myGetCertSrvCSP(
			TRUE,	// fEncryptionCSP
			g_wszSanitizedName,
			&g_dwXchgProvType,
			&g_pwszXchgProvName,
			&g_XchgidAlg,
			&g_fXchgMachineKeyset,
			&g_dwXchgKeySize);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myGetCertSrvCSP(CAXchg)");
	}
    }
    if (S_OK != hr)
    {
	g_dwXchgProvType = PROV_RSA_FULL;
	g_pwszXchgProvName = NULL;
	g_XchgidAlg = CALG_3DES;
	g_fXchgMachineKeyset = TRUE;
	g_dwXchgKeySize = 0;
    }
    if (0 == g_dwXchgKeySize)
    {
	g_dwXchgKeySize = 1024;
    }
}


HRESULT
pkcsCreateNewCAXchgCert(
    IN WCHAR const *pwszUserName)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD dwRequestFlags = CR_FLG_CAXCHGCERT;
    BOOL fSubjectNameSet;
    BOOL fErrorLogged;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cb;
    CAXCHGCTX CAXchgContext;
    CAXCHGCTX *rgCAXchgContext;
    CERT_EXTENSION aExt[4];
    DWORD cExt;
    DWORD i;
    CERTTRANSBLOB ctbCert;		// CoTaskMem*
    CERTSRV_RESULT_CONTEXT Result;
    WCHAR *pwszDisposition = NULL;
    WCHAR *pwszMachineRequesterName = NULL;
    BOOL fCommitted = FALSE;
    static char *s_apszObjId[] =
    {
	szOID_KP_CA_EXCHANGE,
    };

    ZeroMemory(&CAXchgContext, sizeof(CAXchgContext));
    ZeroMemory(&aExt, sizeof(aExt));
    ZeroMemory(&ctbCert, sizeof(ctbCert));

    hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    prow->GetRowId(&CAXchgContext.ReqId);

    hr = myGetComputerObjectName(NameSamCompatible, &pwszMachineRequesterName);
    if (S_OK != hr)
    {
	_PrintError(hr, "myGetComputerObjectName");

	hr = myGetUserNameEx(NameSamCompatible, &pwszMachineRequesterName);
	_JumpIfError(hr, error, "myGetUserNameEx");
    }

    hr = prow->SetProperty(
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		MAXDWORD,
		(BYTE const *) pwszMachineRequesterName);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		g_wszPropCallerName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		MAXDWORD,
		(BYTE const *) pwszUserName);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		wszPROPCERTIFICATETEMPLATE,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE const *) wszCERTTYPE_CA_EXCHANGE);
    _JumpIfError(hr, error, "SetProperty");

    hr = pkcsFormXchgKeyContainerName(
				CAXchgContext.ReqId,
				&CAXchgContext.pwszKeyContainerName);
    _JumpIfError(hr, error, "pkcsFormXchgKeyContainerName");

    for (i = 0; ; i++)
    {
	hr = myGenerateKeys(
			CAXchgContext.pwszKeyContainerName,
			g_pwszXchgProvName,
			g_fXchgMachineKeyset,
			AT_KEYEXCHANGE,
			g_dwXchgProvType,
			g_dwXchgKeySize,
			&CAXchgContext.hProvCA);
	if (S_OK == hr)
	{
	    break;
	}
	_PrintErrorStr(hr, "myGenerateKeys", g_pwszXchgProvName);
	LogEventHResult(
		    EVENTLOG_ERROR_TYPE,
		    NULL == g_pwszXchgProvName?
			MSG_E_BAD_DEFAULT_CA_XCHG_CSP :
			MSG_E_BAD_REGISTRY_CA_XCHG_CSP,
		    hr);
	if (0 != i || NULL == g_pwszXchgProvName)
	{
	    _JumpError(hr, error, "myGenerateKeys");
	}
	pkcsLoadCAXchgCSPInfo(TRUE);	// switch to default CSP
    }
    if (0 != i)
    {
	hr = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_USE_DEFAULT_CA_XCHG_CSP,
		    0,			// cpwsz
		    NULL);		// apwsz
	_PrintIfError(hr, "LogEvent");
    }

    if (!myCryptExportPublicKeyInfo(
				CAXchgContext.hProvCA,
				AT_KEYEXCHANGE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestSubmittedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    hr = CoreSetDisposition(prow, DB_DISP_ACTIVE);
    _JumpIfError(hr, error, "CoreSetDisposition");

    hr = pkcsSetRequestNameInfo(
			prow,
			&g_pCAContextCurrent->pccCA->pCertInfo->Subject,
			g_wszCNXchgSuffix,
			&dwRequestFlags,
			&fSubjectNameSet);
    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");

    hr = prow->SetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(dwRequestFlags),
		    (BYTE const *) &dwRequestFlags);
    _JumpIfError(hr, error, "SetProperty(RequestFlags)");

    CSASSERT(fSubjectNameSet);

    hr = pkcsSetPublicKeyProperties(prow, pPubKey);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = prow->CopyRequestNames();
    _JumpIfError(hr, error, "CopyRequestNames");

    hr = PKCSSetServerProperties(
			prow,
			g_lCAXchgValidityPeriodCount,
			g_enumCAXchgValidityPeriod);
    _JumpIfError(hr, error, "PKCSSetServerProperties");

    cExt = 0;

    // szOID_KEY_USAGE
    {
	CRYPT_BIT_BLOB KeyUsage;
	BYTE abKeyUsage[1] =
	    { CERT_KEY_ENCIPHERMENT_KEY_USAGE | CERT_KEY_AGREEMENT_KEY_USAGE };

	KeyUsage.pbData = abKeyUsage;
	KeyUsage.cbData = sizeof(abKeyUsage);
	KeyUsage.cUnusedBits = 0;

	if (!myEncodeKeyUsage(
			X509_ASN_ENCODING,
			&KeyUsage,
			CERTLIB_USE_LOCALALLOC,
			&aExt[cExt].Value.pbData,
			&aExt[cExt].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeKeyUsage");
	}
    }
    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_KEY_USAGE),
		    0,			// ExtFlags
		    aExt[cExt].Value.cbData,
		    aExt[cExt].Value.pbData);
    _JumpIfError(hr, error, "PropSetExtension");

    cExt++;

    // szOID_ENHANCED_KEY_USAGE
    {
	CERT_ENHKEY_USAGE eku;

	eku.cUsageIdentifier = ARRAYSIZE(s_apszObjId);
	eku.rgpszUsageIdentifier = s_apszObjId;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_ENHANCED_KEY_USAGE,
			&eku,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aExt[cExt].Value.pbData,
			&aExt[cExt].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
    }
    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_ENHANCED_KEY_USAGE),
		    0,			// ExtFlags
		    aExt[cExt].Value.cbData,
		    aExt[cExt].Value.pbData);
    _JumpIfError(hr, error, "PropSetExtension");

    cExt++;

    // szOID_APPLICATION_CERT_POLICIES
    {
	CERT_POLICY_INFO acpi[ARRAYSIZE(s_apszObjId)];
	CERT_POLICIES_INFO cps;

	ZeroMemory(&acpi, sizeof(acpi));
	cps.cPolicyInfo = ARRAYSIZE(s_apszObjId);
	cps.rgPolicyInfo = acpi;
	for (i = 0; i < ARRAYSIZE(s_apszObjId); i++)
	{
	    acpi[i].pszPolicyIdentifier = s_apszObjId[i];
	}
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_CERT_POLICIES,
			&cps,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aExt[cExt].Value.pbData,
			&aExt[cExt].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
    }
    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_APPLICATION_CERT_POLICIES),
		    0,			// ExtFlags
		    aExt[cExt].Value.cbData,
		    aExt[cExt].Value.pbData);
    _JumpIfError(hr, error, "PropSetExtension");

    cExt++;

    // szOID_ENROLL_CERTTYPE_EXTENSION

    hr = myBuildCertTypeExtension(wszCERTTYPE_CA_EXCHANGE, &aExt[cExt]);
    _JumpIfError(hr, error, "myBuildCertTypeExtension");

    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
		    0,			// ExtFlags
		    aExt[cExt].Value.cbData,
		    aExt[cExt].Value.pbData);
    _JumpIfError(hr, error, "PropSetExtension");

    cExt++;
    CSASSERT(cExt == ARRAYSIZE(aExt));

    ZeroMemory(&Result, sizeof(Result));
    Result.pctbCert = &ctbCert;
    hr = PKCSCreateCertificate(
			prow,
			DB_DISP_ISSUED,
			FALSE,
			&fErrorLogged,
			NULL,
			&Result);
    _JumpIfError(hr, error, "PKCSCreateCertificate");

    CAXchgContext.pccCA = CertCreateCertificateContext(
					    X509_ASN_ENCODING,
					    ctbCert.pb,
					    ctbCert.cb);
    if (NULL == CAXchgContext.pccCA)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    if (NULL == g_aCAXchgContext)
    {
	CSASSERT(0 == g_cCAXchgCerts);
	rgCAXchgContext = (CAXCHGCTX *) LocalAlloc(
					    LMEM_FIXED,
					    sizeof(rgCAXchgContext[0]));
    }
    else
    {
	rgCAXchgContext = (CAXCHGCTX *) LocalReAlloc(
			    g_aCAXchgContext,
			    (g_cCAXchgCerts + 1) * sizeof(rgCAXchgContext[0]),
			    LMEM_MOVEABLE);
    }
    if (NULL == rgCAXchgContext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc/ReAlloc");
    }
    g_aCAXchgContext = rgCAXchgContext;
    g_aCAXchgContext[g_cCAXchgCerts] = CAXchgContext;

    pwszDisposition = CoreBuildDispositionString(
					g_pwszRequestedBy,
					pwszUserName,
					NULL,
					NULL,
					S_OK,
					FALSE);

    hr = CoreSetRequestDispositionFields(
				prow,
				S_OK,
				DB_DISP_ISSUED,
				pwszDisposition);
    _JumpIfError(hr, error, "CoreSetRequestDispositionFields");

    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

    g_pCAXchgContextCurrent = &g_aCAXchgContext[g_cCAXchgCerts];

    g_cCAXchgCerts++;
    ZeroMemory(&CAXchgContext, sizeof(CAXchgContext));

error:
    if (NULL != pwszMachineRequesterName)
    {
        LocalFree(pwszMachineRequesterName);
    }
    if (NULL != pwszDisposition)
    {
        LocalFree(pwszDisposition);
    }
    for (i = 0; i < ARRAYSIZE(aExt); i++)
    {
	if (NULL != aExt[i].Value.pbData)
	{
	    LocalFree(aExt[i].Value.pbData);
	}
    }
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != ctbCert.pb)
    {
	CoTaskMemFree(ctbCert.pb);
    }
    if (NULL != pPubKey)
    {
	LocalFree(pPubKey);
    }
    if (NULL != CAXchgContext.pccCA)
    {
	CertFreeCertificateContext(CAXchgContext.pccCA);
    }
    if (NULL != CAXchgContext.hProvCA)
    {
	CryptReleaseContext(CAXchgContext.hProvCA, 0);
	pkcsDeleteKey(CAXchgContext.pwszKeyContainerName);
    }
    if (NULL != CAXchgContext.pwszKeyContainerName)
    {
	LocalFree(CAXchgContext.pwszKeyContainerName);
    }
    return(hr);
}


VOID
pkcsReleaseCAXchgContext(
    IN OUT CAXCHGCTX *pCAXchgContext)
{
    if (NULL != pCAXchgContext->hProvCA)
    {
	CryptReleaseContext(pCAXchgContext->hProvCA, 0);
	pCAXchgContext->hProvCA = NULL;
    }
    if (NULL != pCAXchgContext->pccCA)
    {
	CertFreeCertificateContext(pCAXchgContext->pccCA);
	pCAXchgContext->pccCA = NULL;
    }
    if (NULL != pCAXchgContext->pwszKeyContainerName)
    {
	LocalFree(pCAXchgContext->pwszKeyContainerName);
	pCAXchgContext->pwszKeyContainerName = NULL;
    }
}


VOID
pkcsReleaseCAXchgContextArray()
{
    DWORD i;

    if (NULL != g_aCAXchgContext)
    {
	for (i = 0; i < g_cCAXchgCerts; i++)
	{
	    pkcsReleaseCAXchgContext(&g_aCAXchgContext[i]);
	}
	LocalFree(g_aCAXchgContext);
	g_aCAXchgContext = NULL;
    }
    g_cCAXchgCerts = 0;
    g_pCAContextCurrent = NULL;
}


HRESULT
pkcsLoadCAXchgContext(
    IN DWORD iHash)
{
    HRESULT hr;
    CAXCHGCTX *pCAXchgContext;
    DWORD dwRequestFlags;
    DWORD NameId;
    HCRYPTPROV hProv = NULL;
    WCHAR *pwszKeyContainer = NULL;
    WCHAR *pwszHash = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    DWORD cb;
    BSTR strHash = NULL;
    ICertDBRow *prow = NULL;
    DWORD dwRequestId;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fDeleteKey = FALSE;
    DWORD i;

    hr = myGetCARegHash(
		g_wszSanitizedName,
		CSRH_CAXCHGCERT,
		iHash,
		&pbHash,
		&cbHash);
    _JumpIfError2(hr, error, "myGetCARegHash", S_FALSE);

    hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    DBGPRINT((
	DBG_SS_CERTSRV,
	"Reloading Xchg CAContext[%u]:\n    %ws\n",
	iHash,
	strHash));

    hr = g_pCertDB->OpenRow(
		    PROPOPEN_READONLY | PROPOPEN_CERTHASH | PROPTABLE_REQCERT,
		    0,
		    strHash,
		    &prow);
    _JumpIfError(hr, error, "OpenRow(xchg cert)");

    prow->GetRowId(&dwRequestId);

    hr = pkcsFormXchgKeyContainerName(dwRequestId, &pwszKeyContainer);
    _JumpIfError(hr, error, "pkcsFormXchgKeyContainerName");

    cb = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &cb,
		    (BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty(RequestFlags)");

    if (0 == (CR_FLG_CAXCHGCERT & dwRequestFlags))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Not a CA Xchg cert");
    }

    cb = sizeof(NameId);
    hr = prow->GetProperty(
		    g_wszPropCertificateIssuerNameID,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cb,
		    (BYTE *) &NameId);
    _JumpIfError(hr, error, "GetProperty");

    hr = PKCSGetProperty(
		prow,
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbCert,
		(BYTE **) &pbCert);
    _JumpIfError(hr, error, "PKCSGetProperty(xchg cert)");

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    for (i = 0; ; i++)
    {
	hr = pkcsAcquireKey(pwszKeyContainer, &hProv);
	_PrintIfErrorStr(hr, "pkcsAcquireKey", g_pwszXchgProvName);

	if (S_OK == hr)
	{
	    hr = myValidateKeyForEncrypting(
				    hProv,
				    &pcc->pCertInfo->SubjectPublicKeyInfo,
				    CALG_3DES);
	    _PrintIfErrorStr(hr, "myValidateKeyForEncrypting", g_pwszXchgProvName);
	}
	if (S_OK == hr)
	{
	    break;
	}
	LogEventHResult(
		    EVENTLOG_ERROR_TYPE,
		    NULL == g_pwszXchgProvName?
			MSG_E_BAD_DEFAULT_CA_XCHG_CSP :
			MSG_E_BAD_REGISTRY_CA_XCHG_CSP,
		    hr);
	if (0 != i || NULL == g_pwszXchgProvName)
	{
	    fDeleteKey = TRUE;
	    _JumpError(hr, error, "pkcsAcquireKey/myValidateKeyForEncrypting");
	}
	pkcsLoadCAXchgCSPInfo(TRUE);	// switch to default CSP
    }
    if (0 != i)
    {
	hr = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_USE_DEFAULT_CA_XCHG_CSP,
		    0,			// cpwsz
		    NULL);		// apwsz
	_PrintIfError(hr, "LogEvent");
    }

    hr = pkcsVerifyCertContext(NULL, FALSE, pcc);
    if (S_OK != hr)
    {
	fDeleteKey = TRUE;
	_JumpErrorStr(hr, error, "pkcsVerifyCertContext", L"CAXchg cert invalid");
    }

    pCAXchgContext = &g_aCAXchgContext[g_cCAXchgCerts];
    ZeroMemory(pCAXchgContext, sizeof(*pCAXchgContext));

    pCAXchgContext->ReqId = dwRequestId;

    pCAXchgContext->pccCA = pcc;
    pcc = NULL;

    pCAXchgContext->hProvCA = hProv;
    hProv = NULL;

    pCAXchgContext->pwszKeyContainerName = pwszKeyContainer;
    pwszKeyContainer = NULL;

    pCAXchgContext->iCertSig = CANAMEIDTOICERT(NameId);
    g_cCAXchgCerts++;
    hr = S_OK;

error:
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (fDeleteKey)
    {
	pkcsDeleteKey(pwszKeyContainer);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pwszKeyContainer)
    {
	LocalFree(pwszKeyContainer);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
pkcsLoadCAXchgContextArray(
    OUT BOOL *pfIncompleteLoad)
{
    HRESULT hr;
    DWORD cCAXchgCerts;
    DWORD iHash;
    DWORD i;

    // get provider name, etc.

    pkcsLoadCAXchgCSPInfo(FALSE);

    // find & load CA Xchg certs, etc.

    *pfIncompleteLoad = TRUE;
    hr = myGetCARegHashCount(
			g_wszSanitizedName,
			CSRH_CAXCHGCERT,
			&cCAXchgCerts);
    if (S_OK == hr && 0 == cCAXchgCerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    _JumpIfError(hr, error, "myGetCARegHashCount");

    g_aCAXchgContext = (CAXCHGCTX *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cCAXchgCerts * sizeof(g_aCAXchgContext[0]));
    if (NULL == g_aCAXchgContext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (iHash = 0; iHash < cCAXchgCerts; iHash++)
    {
	hr = pkcsLoadCAXchgContext(iHash);
	_PrintIfError(hr, "pkcsLoadCAXchgContext");
    }
    if (0 == g_cCAXchgCerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "g_cCAXchgCerts");
    }
    g_pCAXchgContextCurrent = &g_aCAXchgContext[0];
    for (i = 1; i < g_cCAXchgCerts; i++)
    {
	if (0 < CompareFileTime(
			&g_aCAXchgContext[i].pccCA->pCertInfo->NotAfter,
			&g_pCAXchgContextCurrent->pccCA->pCertInfo->NotAfter))
	{
	    g_pCAXchgContextCurrent = &g_aCAXchgContext[i];
	}
    }
    if (cCAXchgCerts == g_cCAXchgCerts)
    {
	*pfIncompleteLoad = FALSE;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (NULL != g_aCAXchgContext)
	{
	    LocalFree(g_aCAXchgContext);
	    g_aCAXchgContext = NULL;
	}
	g_cCAXchgCerts = 0;
	g_pCAXchgContextCurrent = NULL;
    }
    return(hr);
}


HRESULT
pkcsUpdateCAXchgStoreAndRegistry(
    IN BOOL fUpdateRegistry)
{
    HRESULT hr;
    DWORD i;
    DWORD iHash;
    CAXCHGCTX *pCAXchgContext;
    HCERTSTORE hStore = NULL;
    CERT_KEY_CONTEXT ckc;
    CERT_CONTEXT const *pccStore = NULL;

    hStore = CertOpenStore(
		       CERT_STORE_PROV_MEMORY,
		       X509_ASN_ENCODING,
		       NULL,			// hProv
		       0,			// dwFlags
		       NULL);			// pvPara
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }
    if (fUpdateRegistry)
    {
	hr = myDeleteCertRegValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    g_wszRegCAXchgCertHash);
	_PrintIfError(hr, "myDeleteCertRegValue");
    }

    ZeroMemory(&ckc, sizeof(ckc));
    ckc.cbSize = sizeof(ckc);
    ckc.dwKeySpec = AT_KEYEXCHANGE;

    iHash = 0;
    for (i = 0; i < g_cCAXchgCerts; i++)
    {
	pCAXchgContext = &g_aCAXchgContext[i];
	if (CTXF_EXPIRED & pCAXchgContext->Flags)
	{
	    continue;
	}

	// Add as encoded blob to avoid all properties, key prov info, etc.

	if (!CertAddEncodedCertificateToStore(
			hStore,
			X509_ASN_ENCODING,
			pCAXchgContext->pccCA->pbCertEncoded,
			pCAXchgContext->pccCA->cbCertEncoded,
			CERT_STORE_ADD_REPLACE_EXISTING,
			&pccStore))			// ppCertContext
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddEncodedCertificateToStore");
	}
	ckc.hCryptProv = pCAXchgContext->hProvCA;
	if (!CertSetCertificateContextProperty(
					pccStore,
					CERT_KEY_CONTEXT_PROP_ID,
					CERT_STORE_NO_CRYPT_RELEASE_FLAG,
					&ckc))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertSetCertificateContextProperty");
	}
	CertFreeCertificateContext(pccStore);
	pccStore = NULL;

	DBGPRINT((
            DBG_SS_CERTSRV,
	    "Add to CA Xchg memory store: '%ws'\n",
	    pCAXchgContext->pwszKeyContainerName));

	if (fUpdateRegistry)
	{
	    hr = mySetCARegHash(
			    g_wszSanitizedName,
			    CSRH_CAXCHGCERT,
			    iHash,
			    pCAXchgContext->pccCA);
	    if (S_OK != hr)
	    {
		_PrintError(hr, "mySetCARegHash");
		continue;
	    }
	}
	iHash++;
    }
    if (NULL != g_hStoreCAXchg)
    {
	CertCloseStore(g_hStoreCAXchg, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    g_hStoreCAXchg = hStore;
    hStore = NULL;
    hr = S_OK;

error:
    if (NULL != pccStore)
    {
	CertFreeCertificateContext(pccStore);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
PKCSIsRevoked(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT LONG *pRevocationReason,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strHash = NULL;
    DWORD Disposition;
    DWORD cbProp;
    FILETIME ftRevoked;
    FILETIME ftCurrent;

    *pRevocationReason = CRL_REASON_UNSPECIFIED;
    *pDisposition = CA_DISP_INVALID;

    hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY | PROPTABLE_REQCERT,
			RequestId,
			pwszSerialNumber,
			&prow);
    _PrintIfErrorStr2(hr, "OpenRow", pwszSerialNumber, CERTSRV_E_PROPERTY_EMPTY);

    if (CERTSRV_E_PROPERTY_EMPTY == hr && NULL != pwszSerialNumber)
    {
	_PrintErrorStr2(
		hr,
		"OpenRow(serial)",
		pwszSerialNumber,
		CERTSRV_E_PROPERTY_EMPTY);

	hr = WszToMultiByteInteger(TRUE, pwszSerialNumber, &cbHash, &pbHash);
	_JumpIfError(hr, error, "WszToMultiByteInteger");

	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");

	hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY |
			    PROPOPEN_CERTHASH |
			    PROPTABLE_REQCERT,
			RequestId,
			strHash,
			&prow);
	_PrintIfErrorStr2(hr, "OpenRow", strHash, CERTSRV_E_PROPERTY_EMPTY);
    }
    if (S_OK != hr)
    {
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK; // disposition indicates cert is invalid
	}
	goto error;
    }

    cbProp = sizeof(Disposition);
    hr = prow->GetProperty(
		   g_wszPropRequestDisposition,
		   PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		   &cbProp,
		   (BYTE *) &Disposition);
    _JumpIfError(hr, error, "GetProperty(Disposition)");

    if (DB_DISP_ISSUED == Disposition ||
	(DB_DISP_CA_CERT == Disposition && IsRootCA(g_CAType)))
    {
	*pDisposition = CA_DISP_VALID;
	goto error;
    }

    if (DB_DISP_REVOKED != Disposition)
    {
	goto error;
    }

    cbProp = sizeof(ftRevoked);
    hr = prow->GetProperty(
		    g_wszPropRequestRevokedEffectiveWhen,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &cbProp,
		    (BYTE *) &ftRevoked);

    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	*pDisposition = CA_DISP_VALID;
	hr = S_OK;
	goto error;
    }
    _JumpIfError(hr, error, "GetProperty(RevokedEffectiveWhen)");

    GetSystemTimeAsFileTime(&ftCurrent);
    if (0 < CompareFileTime(&ftRevoked, &ftCurrent))
    {
	*pDisposition = CA_DISP_VALID;
	goto error;
    }

    cbProp = sizeof(*pRevocationReason);
    hr = prow->GetProperty(
		   g_wszPropRequestRevokedReason,
		   PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		   &cbProp,
		   (BYTE *) pRevocationReason);
    _JumpIfError(hr, error, "GetProperty(RevokedReason)");

    *pDisposition = CA_DISP_REVOKED;

error:
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
PKCSGetCAXchgCert(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    OUT DWORD *piCertSig,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert)
{
    HRESULT hr;
    DWORD State;
    BOOL fNewCert = FALSE;
    BOOL fIncompleteLoad = FALSE;
    FILETIME ft;

    if (MAXDWORD != iCert && 0 != iCert)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Xchg CertIndex");
    }
    if (NULL == g_pCAXchgContextCurrent ||
	NULL == g_pCAXchgContextCurrent->pccCA)
    {
	hr = pkcsLoadCAXchgContextArray(&fIncompleteLoad);
	_PrintIfError(hr, "pkcsLoadCAXchgContextArray");

	if (S_OK != hr)
	{
	    fNewCert = TRUE;
	}
    }
    if (NULL != g_pCAXchgContextCurrent &&
	NULL != g_pCAXchgContextCurrent->pccCA)
    {
	CERT_INFO const *pCertInfo = g_pCAXchgContextCurrent->pccCA->pCertInfo;
	
	GetSystemTimeAsFileTime(&ft);

	if (0 < CompareFileTime(&ft, &pCertInfo->NotAfter))
	{
	    g_pCAXchgContextCurrent->Flags |= CTXF_EXPIRED;
	    hr = CERT_E_EXPIRED;
	    _PrintError(hr, "CA Xchg certificate is expired -- delete key");

	    pkcsDeleteKey(g_pCAXchgContextCurrent->pwszKeyContainerName);
	    fNewCert = TRUE;
	}
	else
	if (0 > CompareFileTime(&ft, &pCertInfo->NotBefore))
	{
	    hr = CERT_E_EXPIRED;
	    _PrintError(hr, "CA Xchg certificate not yet valid");
	    fNewCert = TRUE;
	}
	else
	{
	    myMakeExprDateTime(
			&ft,
			g_lCAXchgOverlapPeriodCount,
			g_enumCAXchgOverlapPeriod);

	    if (0 < CompareFileTime(&ft, &pCertInfo->NotAfter))
	    {
		hr = CERT_E_EXPIRED;
		_PrintError(hr, "CA Xchg certificate expires too soon");
		fNewCert = TRUE;
	    }
	    else
	    {
		hr = pkcsVerifyCertIssuer(
				g_pCAXchgContextCurrent->pccCA,
				g_pCAContextCurrent);
		if (S_OK != hr)
		{
		    _PrintError(hr, "CA Xchg cert not issued by current CA");
		    fNewCert = TRUE;
		}
		else
		{
		    LONG RevocationReason;
		    LONG Disposition;

		    hr = PKCSIsRevoked(
				g_pCAXchgContextCurrent->ReqId,
				NULL,		// pwszSerialNumber
				&RevocationReason,
				&Disposition);
		    if (S_OK != hr)
		    {
			_PrintError(hr, "PKCSIsRevoked");
			fNewCert = TRUE;
		    }
		    else
		    if (CA_DISP_VALID != Disposition)
		    {
			hr = CRYPT_E_REVOKED;
			_PrintError(hr, "revoked or bad CA Xchg certificate");
			fNewCert = TRUE;
		    }
		}
	    }
	}
    }
    if (fNewCert)
    {
	hr = pkcsCreateNewCAXchgCert(pwszUserName);
	_JumpIfError(hr, error, "pkcsCreateNewCAXchgCert");
    }
    hr = pkcsUpdateCAXchgStoreAndRegistry(fNewCert || fIncompleteLoad);
    _JumpIfError(hr, error, "pkcsUpdateCAXchgStoreAndRegistry");

    *piCertSig = g_pCAXchgContextCurrent->iCertSig;
    *pcbCACert = g_pCAXchgContextCurrent->pccCA->cbCertEncoded;
    *ppbCACert = g_pCAXchgContextCurrent->pccCA->pbCertEncoded;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
PKCSGetCAXchgChain(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain)
{
    HRESULT hr;
    BYTE *pbCACert;
    DWORD cbCACert;
    CACTX *pCAContext;

    hr = PKCSGetCAXchgCert(iCert, pwszUserName, &iCert, &pbCACert, &cbCACert);
    _JumpIfError(hr, error, "PKCSGetCAXchgCert");

    // iCert now indexes the signature cert that signed the current Xchg cert

    pCAContext = &g_aCAContext[iCert];
    if (NULL == pCAContext->pccCA)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid cert");
    }
    hr = pkcsEncodeCertChain(
			pCAContext,
			pbCACert,	// pbCertLeaf
			cbCACert,	// cbCertLeaf
			pbCACert,	// pbToBeSigned
			cbCACert,	// cbToBeSigned
			fIncludeCRLs,
			ppbCAChain,	// CoTaskMem*
			pcbCAChain);
    _JumpIfError(hr, error, "PKCSEncodeCertChain");

error:
    return(hr);
}


VOID
PKCSTerminate(VOID)
{
    pkcsReleaseCAContextArray();
    pkcsReleaseCAXchgContextArray();
    if (NULL != g_hStoreCAXchg)
    {
	CertCloseStore(g_hStoreCAXchg, CERT_CLOSE_STORE_CHECK_FLAG);
	g_hStoreCAXchg = NULL;
    }
    pkcsLoadCAXchgCSPInfo(TRUE);
    pkcsReleaseKRACertArray();

    pkcsFreeTemplates(&g_paRevURL, &g_caRevURL);
    pkcsFreeTemplates(&g_paCACertURL, &g_caCACertURL);
    if (NULL != g_pwszKRAPublishURL)
    {
	LocalFree(g_pwszKRAPublishURL);
	g_pwszKRAPublishURL = NULL;
    }
    if (NULL != g_pwszAIACrossCertPublishURL)
    {
	LocalFree(g_pwszAIACrossCertPublishURL);
	g_pwszAIACrossCertPublishURL = NULL;
    }
    if (NULL != g_pwszRootTrustCrossCertPublishURL)
    {
	LocalFree(g_pwszRootTrustCrossCertPublishURL);
	g_pwszRootTrustCrossCertPublishURL = NULL;
    }
    if (NULL != g_strDomainDN)
    {
	SysFreeString(g_strDomainDN);
	g_strDomainDN = NULL;
    }
    if (NULL != g_strConfigDN)
    {
	SysFreeString(g_strConfigDN);
	g_strConfigDN = NULL;
    }
}


// PKCSCreateCertificate -- Create certificate & build PKCS 7 or Full Response.
//
// If pResult->pctbCert is non-NULL and pResult->pctbCert->pb is NULL:
// CR_IN_NEW:
//	Build, store and return cert
//	Use current CA Context
//	Build and return PKCS 7 or Full Response
//
// If pResult->pctbCert is non-NULL and pResult->pctbCert->pb is non-NULL:
// CR_IN_RETRIEVEPENDING:
//	Use passed cert
//	Find matching CA Context
//	Build and return PKCS 7 or Full Response
//
// If pResult->pctbCert is NULL:
// CR_IN_RESUBMIT:
//	Build and store cert -- don't return cert
//	Use current CA Context
//	Don't build or return PKCS 7 or Full Response


HRESULT
PKCSCreateCertificate(
    IN ICertDBRow *prow,
    IN DWORD Disposition,
    IN BOOL fIncludeCRLs,
    OUT BOOL *pfErrorLogged,
    OPTIONAL OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)	// CoTaskMem*
{
    HRESULT hr;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    BYTE *pbCertChain = NULL;
    DWORD cbCertChain;
    DWORD cCert;
    BOOL fCreated = FALSE;
    DWORD i;
    CACTX *pCAContext;
    CERT_CONTEXT const *pcc = NULL;

    if (NULL != ppCAContext)
    {
	*ppCAContext = NULL;
    }
    *pfErrorLogged = FALSE;
    CSASSERT(NULL == pResult->pctbCertChain || NULL == pResult->pctbCertChain->pb);
    CSASSERT(NULL == pResult->pctbFullResponse || NULL == pResult->pctbFullResponse->pb);

    if (NULL != pResult->pctbCert && NULL != pResult->pctbCert->pb)
    {
	pbCert = pResult->pctbCert->pb;
	cbCert = pResult->pctbCert->cb;

	pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
	pCAContext = NULL;
	if (DB_DISP_CA_CERT != Disposition &&
	    DB_DISP_CA_CERT_CHAIN != Disposition)
	{
	    hr = PKCSVerifyIssuedCertificate(pcc, &pCAContext);
	    _JumpIfError(hr, error, "PKCSVerifyIssuedCertificate");
	}
    }
    else
    {
	pCAContext = g_pCAContextCurrent;
	cbCert = 0;
	hr = pkcsEncodeSubjectCert(
			    prow,
			    pCAContext,
			    &pbCert,	// CoTaskMem*
			    &cbCert,
			    pfErrorLogged);
	_JumpIfError(hr, error, "pkcsEncodeSubjectCert");

	fCreated = TRUE;

	hr = prow->SetProperty(
		    g_wszPropRawCertificate,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    cbCert,
		    pbCert);
	_JumpIfError(hr, error, "SetProperty");
    }

    if (NULL != pResult->pctbCertChain)
    {
	hr = pkcsEncodeCertChain(
			    pCAContext,
			    pbCert,		// pbCertLeaf
			    cbCert,		// cbCertLeaf
			    pbCert,		// pbToBeSigned
			    cbCert,		// cbToBeSigned
			    fIncludeCRLs,
			    &pbCertChain,	// CoTaskMem*
			    &cbCertChain);
	_JumpIfError(hr, error, "pkcsEncodeCertChain");
    }
    if (fCreated && NULL != pResult->pctbCert)
    {
	pResult->pctbCert->pb = pbCert;
	pResult->pctbCert->cb = cbCert;
	pbCert = NULL;
    }
    if (NULL != pResult->pctbCertChain)
    {
	pResult->pctbCertChain->pb = pbCertChain;
	pResult->pctbCertChain->cb = cbCertChain;
	pbCertChain = NULL;
    }
    if (NULL != ppCAContext)
    {
	*ppCAContext = pCAContext;
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (fCreated && NULL != pbCert)
    {
	CoTaskMemFree(pbCert);
    }
    if (fCreated && NULL != pbCertChain)
    {
	CoTaskMemFree(pbCertChain);
    }
    CSASSERT(
	NULL == pResult->pctbCertChain ||
	((S_OK == hr) ^ (NULL == pResult->pctbCertChain->pb)));
    return(hr);
}


HRESULT
PKCSGetKRACert(
    IN DWORD iCert,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert)
{
    HRESULT hr = S_OK;
    DWORD State;

    if (MAXDWORD == iCert)
    {
        iCert = g_iKRACerts;
    }
    if (iCert >= g_cKRACerts)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "bad CertIndex");
    }

    *pcbCert = g_rgKRACerts[iCert]->cbCertEncoded;
    *ppbCert = g_rgKRACerts[iCert]->pbCertEncoded;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.cpp
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <accctrl.h>

#include "cscom.h"
#include "csprop.h"
#include "certsrvd.h"
#include "request.h"
#include "certacl.h"
#include "tmpllist.h"

#define __dwFILE__	__dwFILE_CERTSRV_REQUEST_CPP__

extern HINSTANCE g_hInstApp;
extern const GUID *g_guidAdmin[1];
extern const GUID *g_guidsReadAdminOfficer[3];

// Global variables
long g_cRequestComponents = 0;     // Count of active components
long g_cRequestServerLocks = 0;    // Count of locks
DWORD g_dwRequestRegister = 0;
IClassFactory* g_pIRequestFactory = NULL;
// Sequence# incremented every time the CA template list is changed.
// Policy module detects any changes to this number and refreshes its
// template data from DS.
long g_cTemplateUpdateSequenceNum = 0; 

#ifdef DBG_CERTSRV_DEBUG_PRINT
DWORD s_ssRequest = DBG_SS_CERTSRVI;
#endif

using namespace CertSrv;

#ifndef CERTSRV_E_UNKNOWN_CERT_TYPE
// begin implementation of component functions

// Request component
// begin implementing cert request services

//
// MessageId: CERTSRV_E_UNKNOWN_CERT_TYPE
//
// MessageText:
//
// One or more certificate templates to be enabled on this certification authority could not be found.
//
#define CERTSRV_E_UNKNOWN_CERT_TYPE         _HRESULT_TYPEDEF_(0x80094010L)

//
// MessageId: CERTSRV_E_ENROLL_DENIED
//
// MessageText:
//
// The permissions on this certification authority do not allow current user to enroll for certificates.
//
#define CERTSRV_E_ENROLL_DENIED         _HRESULT_TYPEDEF_(0x80094011L)

#endif // CERTSRV_E_UNKNOWN_CERT_TYPE

HRESULT RequestAccessCheck(
    OPTIONAL OUT BOOL *pfInRequesterGroup = NULL,
    OPTIONAL OUT HANDLE *phToken = NULL)
{
    HRESULT hr = S_OK;
    CAuditEvent audit(0, g_dwAuditFilter);
    BOOL fInRequesterGroup = FALSE;

    hr = audit.AccessCheck(
			CA_ACCESS_ENROLL,
			audit.m_gcNoAuditSuccess |
            audit.m_gcNoAuditFailure,
            NULL,
            phToken);

    if(S_OK==hr)
    {
        fInRequesterGroup = TRUE;
    } 

    if(pfInRequesterGroup)
        *pfInRequesterGroup = fInRequesterGroup;

    if(E_ACCESSDENIED==hr)
    {
        // When this flag is set, ICertReq calls should immediately return
        // if access is denied. If not set, we ignore access denied error
        // but pass down the result to the policy module through fInRequesterGroup
        if(g_fLockICertRequest)
        {
            hr = CERTSRV_E_ENROLL_DENIED;
        }
        else
        {
            hr = S_OK;
        }
    }

    _JumpIfError(hr, error, "CAuditEvent::AccessCheck");

error:
    return hr;
}


VOID
ReleaseResult(
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    if (NULL != pResult->pbSenderNonce)
    {
	LocalFree(pResult->pbSenderNonce);
    }
    if (NULL != pResult->pbKeyHashIn)
    {
	LocalFree(pResult->pbKeyHashIn);
    }
    if (NULL != pResult->pbKeyHashOut)
    {
	LocalFree(pResult->pbKeyHashOut);
    }
}


STDMETHODIMP
CCertRequestD::Request(
    /* [in] */ DWORD dwFlags,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAttributes,
    /* [ref][in] */ CERTTRANSBLOB const __RPC_FAR *pctbRequest,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCertChain,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbEncodedCert,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbDispositionMessage)
{
    HRESULT hr;
    WCHAR const *pwszSerialNumber = NULL;
    CERTSRV_RESULT_CONTEXT Result;

    ZeroMemory(&Result, sizeof(Result));
    if (NULL != pctbRequest && NULL == pctbRequest->pb)
    {
	// RetrievePending by SerialNumber in pwszAttributes

	pwszSerialNumber = pwszAttributes;
	pwszAttributes = NULL;
    }
    Result.pdwRequestId = pdwRequestId;
    Result.pdwDisposition = pdwDisposition;
    Result.pctbDispositionMessage = pctbDispositionMessage;
    Result.pctbCert = pctbEncodedCert;
    Result.pctbCertChain = pctbCertChain;

    hr = _Request(
		pwszAuthority,
		dwFlags,
		pwszSerialNumber,
		*pdwRequestId,
		pwszAttributes,
		pctbRequest,
		&Result);
    _JumpIfError(hr, error, "Request");

error:
    ReleaseResult(&Result);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::Request2(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwFlags,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszSerialNumber,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAttributes,
    /* [ref][in] */ const CERTTRANSBLOB __RPC_FAR *pctbRequest,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbFullResponse,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbEncodedCert,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbDispositionMessage)
{
    HRESULT hr;
    CERTSRV_RESULT_CONTEXT Result;

    ZeroMemory(&Result, sizeof(Result));
    Result.pdwRequestId = pdwRequestId;
    Result.pdwDisposition = pdwDisposition;
    Result.pctbDispositionMessage = pctbDispositionMessage;
    Result.pctbCert = pctbEncodedCert;
    if (CR_IN_FULLRESPONSE & dwFlags)
    {
	Result.pctbFullResponse = pctbFullResponse;
    }
    else
    {
	Result.pctbCertChain = pctbFullResponse;
    }

    hr = _Request(
		pwszAuthority,
		dwFlags,
		pwszSerialNumber,
		*pdwRequestId,
		pwszAttributes,
		pctbRequest,
		&Result);
    _JumpIfError(hr, error, "Request2");

error:
    ReleaseResult(&Result);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
requestRegisterMemFreeBlob(
    OPTIONAL CERTTRANSBLOB const *pctb)
{
    if (NULL != pctb && NULL != pctb->pb)
    {
	myRegisterMemFree(pctb->pb, CSM_MIDLUSERALLOC);
    }
}


HRESULT
CCertRequestD::_Request(
    IN WCHAR const *pwszAuthority,
    IN DWORD dwFlags,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwRequestId,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN CERTTRANSBLOB const *pctbRequest,
    OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD OpRequest;
    WCHAR *pwszUserName = NULL;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_COM_CONTEXT ComContext;
    DWORD State = 0;

    DBGPRINT((
        s_ssRequest,
        "CCertRequestD::Request2(tid=%d)\n",
        GetCurrentThreadId()));

    ZeroMemory(&ComContext, sizeof(ComContext));
    //ComContext.pwszUserDN = NULL;
    //ComContext.hAccessToken = NULL;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegsiterComContext");

    __try
    {
        hr = RequestAccessCheck(
                &ComContext.fInRequestGroup,
                &ComContext.hAccessToken);
        _LeaveIfError(hr, "RequestAccessCheck");

        // Set up default output parameters:
        
        *pResult->pdwRequestId = 0;
        *pResult->pdwDisposition = CR_DISP_ERROR;
        
        OpRequest = CR_IN_RETRIEVE;
        if (NULL != pctbRequest->pb)
        {
            OpRequest = CR_IN_NEW;
        }
       
        hr = GetClientUserName(
			NULL,
			&pwszUserName,
			CR_IN_NEW == OpRequest && IsEnterpriseCA(g_CAType)?
			    &ComContext.pwszUserDN : NULL);
        _LeaveIfError(hr, "GetClientUserName");

        hr = CoreProcessRequest(
			OpRequest | (dwFlags & ~CR_IN_COREMASK),
			pwszUserName,
			pctbRequest->cb,	// cbRequest
			pctbRequest->pb,	// pbRequest
			pwszAttributes,
			pwszSerialNumber,
			dwComContextIndex,
			dwRequestId,
			pResult);	// Allocates returned memory
        if (S_OK != hr)
        {
            hr = myHError(hr);
            _LeaveError(hr, "CoreProcessRequest");
        }
        
        requestRegisterMemFreeBlob(pResult->pctbDispositionMessage);
        requestRegisterMemFreeBlob(pResult->pctbCert);
        requestRegisterMemFreeBlob(pResult->pctbCertChain);
        requestRegisterMemFreeBlob(pResult->pctbFullResponse);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
            _PrintError(hr, "Exception");
        }

error:
    // CloseHandle can throw an exception

    if (NULL != ComContext.hAccessToken)
    {
        __try
        {
            CloseHandle(ComContext.hAccessToken);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
            _PrintError(hr, "Exception");
        }
    }
    if (NULL != pwszUserName)
    {
    LocalFree(pwszUserName);
    }
    if (MAXDWORD != dwComContextIndex)
    {
    if (NULL != ComContext.pwszUserDN)
    {
        LocalFree(ComContext.pwszUserDN);
    }
    UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


#define MAX_VERSION_RESOURCE_SIZE 64

HRESULT
GetVersionString(
    IN DWORD type,
    OUT WCHAR *pwszVersion)
{
    HRESULT hr;

    typedef struct _MY_RESOURCE_DATA
    {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
        VS_FIXEDFILEINFO FixedFileInfo;
    } MY_RESOURCE_DATA;

    MY_RESOURCE_DATA *pResource;
    HRSRC hrsc;
    HGLOBAL hg;

    // FindResource: don't need to free hrsc
    hrsc = FindResource(g_hInstApp, MAKEINTRESOURCE(1), RT_VERSION);
    if (NULL == hrsc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "FindResource");
    }

    // LoadResource: don't need to free HGLOBAL
    hg = LoadResource(g_hInstApp, hrsc); 
    if (NULL == hg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "LoadResource");
    }

    // LockResource: don't need to free pResource
    pResource = (MY_RESOURCE_DATA *) LockResource(hg);
    if (NULL == pResource)
    {
	hr = myHLastError();
	if (S_OK == hr)		// LockResource isn't doc'd to use SetLastError
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
	_JumpError(hr, error, "LockResource");
    }

    if (0 != lstrcmpi(pResource->Name, L"VS_VERSION_INFO"))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto error;
    }
   
    if (CR_PROP_FILEVERSION == type)
    {
	wsprintf(
	    pwszVersion,
	    L"%d.%d:%d.%d",
	    HIWORD(pResource->FixedFileInfo.dwFileVersionMS),
	    LOWORD(pResource->FixedFileInfo.dwFileVersionMS),
	    HIWORD(pResource->FixedFileInfo.dwFileVersionLS),
	    LOWORD(pResource->FixedFileInfo.dwFileVersionLS));
    }
    else
    {
	wsprintf(
	    pwszVersion,
	    L"%d.%d:%d.%d",
	    HIWORD(pResource->FixedFileInfo.dwProductVersionMS),
	    LOWORD(pResource->FixedFileInfo.dwProductVersionMS),
	    HIWORD(pResource->FixedFileInfo.dwProductVersionLS),
	    LOWORD(pResource->FixedFileInfo.dwProductVersionLS));
    }
    hr = S_OK;

error:
    return(hr);
}


// for ICertRequest2::GetCAProperty & ICertAdmin2::GetCAProperty

LONG g_CAPropIdMax = 0;

CAPROP g_aCAProp[] = {
    { CR_PROP_FILEVERSION,	 PROPTYPE_STRING, },
    { CR_PROP_PRODUCTVERSION,	 PROPTYPE_STRING, },
    { CR_PROP_EXITCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_EXITDESCRIPTION,	 PROPTYPE_STRING | PROPFLAGS_INDEXED, },
    { CR_PROP_POLICYDESCRIPTION, PROPTYPE_STRING, },
    { CR_PROP_CANAME,		 PROPTYPE_STRING, },
    { CR_PROP_SANITIZEDCANAME,	 PROPTYPE_STRING, },
    { CR_PROP_SHAREDFOLDER,	 PROPTYPE_STRING, },
    { CR_PROP_PARENTCA,		 PROPTYPE_STRING, FALSE, },

    { CR_PROP_CATYPE,		 PROPTYPE_LONG, },
    { CR_PROP_CASIGCERTCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_CASIGCERT,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CASIGCERTCHAIN,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CAXCHGCERTCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_CAXCHGCERT,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CAXCHGCERTCHAIN,	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_BASECRL,		 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_DELTACRL,		 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CACERTSTATE,	 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CRLSTATE,		 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CAPROPIDMAX,	 PROPTYPE_LONG, },
    { CR_PROP_DNSNAME,		 PROPTYPE_STRING, },
//    { CR_PROP_ROLESEPARATIONENABLED,    PROPTYPE_LONG, },
    { CR_PROP_KRACERTUSEDCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_KRACERTCOUNT,	 PROPTYPE_LONG, },
    { CR_PROP_KRACERT,	 	 PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_KRACERTSTATE,	 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_ADVANCEDSERVER,PROPTYPE_LONG, },
    { CR_PROP_TEMPLATES,     PROPTYPE_STRING, },
    { CR_PROP_BASECRLPUBLISHSTATUS, PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_DELTACRLPUBLISHSTATUS, PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { CR_PROP_CASIGCERTCRLCHAIN, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CAXCHGCERTCRLCHAIN,PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { CR_PROP_CACERTSTATUSCODE,  PROPTYPE_LONG | PROPFLAGS_INDEXED, },
};


// Map old ICertRequest::GetCACertificate calls to ICertRequest2::GetCAProperty

typedef struct _GETCERTMAP {
    DWORD dwGetCert;
    LONG  lPropId;
    LONG  lPropType;
} GETCERTMAP;

GETCERTMAP g_aCAPropMap[] = {
  { GETCERT_FILEVERSION,        CR_PROP_FILEVERSION,	   PROPTYPE_STRING, },
  { GETCERT_PRODUCTVERSION,     CR_PROP_PRODUCTVERSION,    PROPTYPE_STRING, },
  { GETCERT_EXITVERSIONBYINDEX, CR_PROP_EXITDESCRIPTION,   PROPTYPE_STRING, },
  { GETCERT_POLICYVERSION,      CR_PROP_POLICYDESCRIPTION, PROPTYPE_STRING, },
  { GETCERT_CANAME,             CR_PROP_CANAME,		   PROPTYPE_STRING, },
  { GETCERT_SANITIZEDCANAME,    CR_PROP_SANITIZEDCANAME,   PROPTYPE_STRING, },
  { GETCERT_SHAREDFOLDER,       CR_PROP_SHAREDFOLDER,	   PROPTYPE_STRING, },
  { GETCERT_PARENTCONFIG,       CR_PROP_PARENTCA,	   PROPTYPE_STRING, },
  { GETCERT_CAINFO,             CR_PROP_CATYPE,		   PROPTYPE_LONG, },
  { GETCERT_CACERTBYINDEX,      CR_PROP_CASIGCERT,	   PROPTYPE_BINARY, },
  { GETCERT_CRLBYINDEX,         CR_PROP_BASECRL,	   PROPTYPE_BINARY, },
  { GETCERT_CACERTSTATEBYINDEX, CR_PROP_CACERTSTATE,	   PROPTYPE_LONG, },
  { GETCERT_CRLSTATEBYINDEX,    CR_PROP_CRLSTATE,	   PROPTYPE_LONG, },
};

// Handled via code hacks:
//{ GETCERT_CASIGCERT,          CR_PROP_CASIGCERTCRLCHAIN, PROPTYPE_BINARY, },
//{ GETCERT_CASIGCERT,          CR_PROP_CASIGCERTCHAIN,    PROPTYPE_BINARY, },
//{ GETCERT_CASIGCERT,          CR_PROP_CASIGCERT,         PROPTYPE_BINARY, },
//{ GETCERT_CAXCHGCERT,         CR_PROP_CAXCHGCERT,        PROPTYPE_BINARY, },
//{ GETCERT_CAXCHGCERT,         CR_PROP_CAXCHGCERTCRLCHAIN,PROPTYPE_BINARY, },
//{ GETCERT_CAXCHGCERT,         CR_PROP_CAXCHGCERTCHAIN,   PROPTYPE_BINARY, },
//{ GETCERT_CURRENTCRL,         CR_PROP_BASECRL,           PROPTYPE_BINARY, },
//{ GETCERT_CATYPE,             CR_PROP_CATYPE,            PROPTYPE_LONG, },


HRESULT
RequestInitCAPropertyInfo(VOID)
{
    HRESULT hr;
    CAPROP *pcap;

    g_CAPropIdMax = 0;
    for (pcap = g_aCAProp; pcap < &g_aCAProp[ARRAYSIZE(g_aCAProp)]; pcap++)
    {
	hr = myCAPropGetDisplayName(pcap->lPropId, &pcap->pwszDisplayName);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"myCAPropGetDisplayName(%u)\n",
		pcap->lPropId));
	    _PrintError(hr, "myCAPropGetDisplayName");
	}

	if (g_CAPropIdMax < pcap->lPropId)
	{
	    g_CAPropIdMax = pcap->lPropId;
	}
    }
    return(S_OK);
}


HRESULT
RequestGetCAPropertyInfo(
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo)
{
    HRESULT hr;
    LONG i;
    DWORD cb;
    DWORD cbT;
    CAPROP *rgcap = NULL;
    CAPROP *pcap;
    CAPROP *pcapEnd;

    pctbPropInfo->pb = NULL;
    pctbPropInfo->cb = 0;

    __try
    {

	cb = sizeof(g_aCAProp);
	for (i = 0; i < ARRAYSIZE(g_aCAProp); i++)
	{
	    if (NULL != g_aCAProp[i].pwszDisplayName)
	    {
		cbT = (wcslen(g_aCAProp[i].pwszDisplayName) + 1) * sizeof(WCHAR);
		cb += DWORDROUND(cbT);
	    }
	}

	rgcap = (CAPROP *) MIDL_user_allocate(cb);
	if (NULL == rgcap)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "MIDL_user_allocate rgcap");
	}
	CopyMemory(rgcap, g_aCAProp, sizeof(g_aCAProp));

	cb = sizeof(g_aCAProp);
	pcapEnd = &rgcap[ARRAYSIZE(g_aCAProp)];
	for (pcap = rgcap; pcap < pcapEnd; pcap++)
	{
	    DBGPRINT((
		    DBG_SS_CERTSRVI,
		    "RequestGetCAPropertyInfo: ielt=%d idx=%x t=%x \"%ws\"\n",
		    pcap - rgcap,
		    pcap->lPropId,
		    pcap->lPropFlags,
		    pcap->pwszDisplayName));

	    if (NULL != pcap->pwszDisplayName)
	    {
		cbT = (wcslen(pcap->pwszDisplayName) + 1) * sizeof(WCHAR);
		CopyMemory(Add2Ptr(rgcap, cb), pcap->pwszDisplayName, cbT);

		pcap->pwszDisplayName = (WCHAR *) (ULONG_PTR) cb;
		cb += DWORDROUND(cbT);
	    }
	}

	pctbPropInfo->cb = cb;
	pctbPropInfo->pb = (BYTE *) rgcap;
	rgcap = NULL;
	*pcProperty = ARRAYSIZE(g_aCAProp);

	myRegisterMemFree(pctbPropInfo->pb, CSM_MIDLUSERALLOC);
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

//error:
    if (NULL != rgcap)
    {
	MIDL_user_free(rgcap);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
ValidatePropertyParameters(
    LONG PropId,
    LONG PropIndex,
    LONG PropType)
{
    HRESULT hr;
    CAPROP const * pcap;

    hr = E_INVALIDARG;
    for (pcap = g_aCAProp; ; pcap++)
    {
	if (pcap >= &g_aCAProp[ARRAYSIZE(g_aCAProp)])
	{
	    _JumpError(hr, error, "invalid propid");
	}
        if (PropId == pcap->lPropId)
        {
            if ((PropType != (PROPTYPE_MASK & pcap->lPropFlags)) ||
                (0 == (PROPFLAGS_INDEXED & pcap->lPropFlags) && 
                 0 != PropIndex))
            {
	        _JumpError(hr, error, "invalid type/index");
            }
            break;
	}
    }
    hr = S_OK;

error:
    DBGPRINT((
	S_OK != hr? DBG_SS_ERROR : DBG_SS_CERTSRVI,
	"ValidatePropertyParameters(PropId=%x, PropIndex=%x, PropType=%x) -> %x\n",
	PropId,
	PropIndex,
	PropType,
	hr));
    return(hr);
}


// Returns a string containing the list of templates supported
// by this CA, one pair of name and string OID for each template,
// separated by new lines:
//
//     "name1\nOID1\nname2\OID2...\nnameN\nOIDN\0"
//
// If the template doesn't have an OID (Win2k domain) there will
// be an empty string in its place

HRESULT 
GetCATemplates(
    BYTE*& rpb,
    DWORD& rcb)
{
    HRESULT hr = S_OK;
    HCAINFO hCAInfo = NULL;
    HCERTTYPE hCrtCertType = NULL;
    HCERTTYPE hPrevCertType = NULL;
    LPWSTR* pwszCertTypeCN = NULL;
    LPWSTR* pwszCertTypeOID = NULL;
    CTemplateList CATemplateList;

    rpb = NULL;
    rcb = 0;

    hr = CAFindByName(
        g_wszSanitizedName,
        NULL,
        CA_FIND_LOCAL_SYSTEM,
        &hCAInfo);
    _JumpIfError(hr, error, "CAFindByName");

    hr = CAEnumCertTypesForCA(
        hCAInfo, 
        CT_ENUM_MACHINE_TYPES |
        CT_ENUM_USER_TYPES |
        CT_FIND_LOCAL_SYSTEM |
        CT_FLAG_NO_CACHE_LOOKUP,
        &hCrtCertType);
    _JumpIfError(hr, error, "CAEnumCertTypesForCA");

    while(hCrtCertType)
    {
        hr = CAGetCertTypeProperty(
                            hCrtCertType,
                            CERTTYPE_PROP_CN,
                            &pwszCertTypeCN);
        _JumpIfError(hr, error, "CAGetCertTypeProperty CERTTYPE_PROP_CN");

        hr = CAGetCertTypeProperty(
                            hCrtCertType,
                            CERTTYPE_PROP_OID,
                            &pwszCertTypeOID);
        _JumpIfError(hr, error, "CAGetCertTypeProperty CERTTYPE_PROP_OID");

        hr = CATemplateList.AddTemplateInfo(
            pwszCertTypeCN?*pwszCertTypeCN:NULL,
            pwszCertTypeOID?*pwszCertTypeOID:NULL);
        _JumpIfError(hr, error, "CTemplateList::AddTemplate");

        if(pwszCertTypeCN)
        {
            CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeCN);
            pwszCertTypeCN = NULL;
        }
        if(pwszCertTypeOID)
        {
            CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeOID);
            pwszCertTypeOID = NULL;
        }
        
        hPrevCertType = hCrtCertType;

        hr = CAEnumNextCertType(hCrtCertType, &hCrtCertType);
        _JumpIfError(hr, error, "CAEnumNextCertType");

        CACloseCertType(hPrevCertType);
    }

    hCrtCertType = NULL;

    hr = CATemplateList.Marshal(rpb, rcb);
    _JumpIfError(hr, error, "CTemplateList::Marshal");


error:

    if(pwszCertTypeCN)
    {
        CSASSERT(hCrtCertType);
        CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeCN);
    }
    if(pwszCertTypeOID)
    {
        CSASSERT(hCrtCertType);
        CAFreeCertTypeProperty(hCrtCertType, pwszCertTypeOID);
    }
    if(hCrtCertType)
    {
        CACloseCertType(hCrtCertType);   
    }
    if(hCAInfo)
    {
        CACloseCA(hCAInfo);
    }

    return hr;
}


HRESULT 
SetCATemplates(
    const BYTE* pb,
    DWORD cb)
{
    HRESULT hr = S_OK;
    HCAINFO hCAInfo = NULL;
    CTemplateList CATemplateList;
    CTemplateListEnum CATemplateListEnum(CATemplateList);
    CTemplateInfo *pTemplateInfo;
    DWORD cTempl;
    DWORD nTemplates;
    LPCWSTR *ppTemplateList = NULL;
    HCERTTYPE hCertType = NULL;
    bool fRefreshTemplateCache = true;

    hr = CATemplateList.Unmarshal(pb, cb);
    _JumpIfError(hr, error, "CTemplateList::Unmarshal");
    
    hr = CAFindByName(
        g_wszSanitizedName,
        NULL,
        CA_FIND_LOCAL_SYSTEM,
        &hCAInfo);
    _JumpIfError(hr, error, "CAFindByName");

    nTemplates = CATemplateList.GetCount();

    ppTemplateList = (LPCWSTR*)LocalAlloc(
        LMEM_FIXED|LMEM_ZEROINIT, 
        sizeof(LPWSTR)* (nTemplates+1) );
    _JumpIfAllocFailed(ppTemplateList, error);

    CATemplateListEnum.Reset();

    for(pTemplateInfo=CATemplateListEnum.Next(), cTempl=0; 
        pTemplateInfo; 
        pTemplateInfo=CATemplateListEnum.Next(), cTempl++)
    {
        
        ppTemplateList[cTempl] = pTemplateInfo->GetName();

        // check if this is a valid template

        hr = CAFindCertTypeByName(
            pTemplateInfo->GetName(),
            NULL,
            CT_FIND_LOCAL_SYSTEM |
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES |
            (fRefreshTemplateCache?CT_FLAG_NO_CACHE_LOOKUP:0),
            &hCertType);
        
        fRefreshTemplateCache = false;
        
        if(HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
        {
            // try with the OID

            hr = CAFindCertTypeByName(
                pTemplateInfo->GetOID(),
                NULL,
                CT_FIND_LOCAL_SYSTEM |
                CT_ENUM_MACHINE_TYPES |
                CT_ENUM_USER_TYPES |
                CT_FIND_BY_OID,
                &hCertType);

            if(HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
            {
                hr = CERTSRV_E_UNKNOWN_CERT_TYPE;
                _JumpErrorStr(hr, error, "CAFindCertTypeByOID", 
                    pTemplateInfo->GetOID());
            }
            _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pTemplateInfo->GetOID());
        }

        _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pTemplateInfo->GetName());

        CACloseCertType(hCertType);
        hCertType = NULL;
        hr = S_OK;
    }

    ppTemplateList[nTemplates] = NULL;

    hr = CASetCAProperty(hCAInfo, CA_PROP_CERT_TYPES, 
        const_cast<LPWSTR*>(ppTemplateList));
    _JumpIfError(hr, error, "CASetCAProperty(CA_PROP_CERT_TYPES)");

    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");

    // Increment sequence number so that policy module can detect
    // there was a template change
    InterlockedIncrement(&g_cTemplateUpdateSequenceNum);

error:

    LOCAL_FREE(ppTemplateList);
    if(hCAInfo)
    {
        CACloseCA(hCAInfo);
    }

    return hr;
}


STDMETHODIMP
RequestGetCAPropertySub(
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbOut)
{
    HRESULT hr = S_OK;
    CAPROP const *pcap;
    BYTE *pbReturn;
    BYTE *pbAlloc = NULL;
    WCHAR wszVersion[MAX_VERSION_RESOURCE_SIZE];
    BYTE *pb = NULL;
    WCHAR const *pwsz = NULL;
    WCHAR *pwszSharedFolder = NULL;
    CAINFO CAInfo;
    DWORD iCertSig;
    CRL_CONTEXT const *pCRL = NULL;
    WCHAR *pwszUserName = NULL;
    HCERTSTORE hKRAStore = NULL;
    CERT_CONTEXT const *pCertContext = NULL;
    HRESULT hrCAStatusCode;

    switch (PropId)
    {
	case CR_PROP_FILEVERSION:
	case CR_PROP_PRODUCTVERSION:
	    hr = GetVersionString(PropId, wszVersion);
	    _JumpIfError(hr, error, "GetVersionString");

	    pwsz = wszVersion;
	    break;

	case CR_PROP_EXITDESCRIPTION:
	case CR_PROP_POLICYDESCRIPTION:
	    pwsz = CR_PROP_EXITDESCRIPTION == PropId?
		ExitGetDescription(PropIndex) :
		g_strPolicyDescription;
	    if (NULL == pwsz)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "No description");
	    }
	    break;

	case CR_PROP_CANAME:
	    pwsz = g_wszCommonName;
	    break;

	case CR_PROP_SANITIZEDCANAME:
	    pwsz = g_wszSanitizedName;
	    break;

	case CR_PROP_SHAREDFOLDER:
	    hr = myGetCertRegStrValue(
		    NULL,
		    NULL,
		    NULL,
		    wszREGDIRECTORY,
		    &pwszSharedFolder);
	    _JumpIfError(hr, error, "myGetCertRegStrValue");

	    if (NULL == pwszSharedFolder)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "No shared folder");
	    }
	    pwsz = pwszSharedFolder;
	    break;

	case CR_PROP_PARENTCA:
	    if (L'\0' == g_wszParentConfig[0])
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "No parent");
	    }
	    pwsz = g_wszParentConfig;
	    break;

	case CR_PROP_CATYPE:
	case CR_PROP_CASIGCERTCOUNT:
	case CR_PROP_CAXCHGCERTCOUNT:
	case CR_PROP_EXITCOUNT:
	case CR_PROP_CAPROPIDMAX:
	case CR_PROP_ROLESEPARATIONENABLED:
	case CR_PROP_KRACERTUSEDCOUNT:
	case CR_PROP_KRACERTCOUNT:
	case CR_PROP_ADVANCEDSERVER:
	    ZeroMemory(&CAInfo, sizeof(CAInfo));
	    CAInfo.cbSize = sizeof(CAInfo);
	    CAInfo.CAType = g_CAType;
	    CAInfo.cCASignatureCerts = g_cCACerts;
	    CAInfo.cCAExchangeCerts = 1;	// current Xchg cert only
	    CAInfo.cExitModules = g_cExitMod;
	    CAInfo.lPropIdMax = g_CAPropIdMax;
	    CAInfo.lRoleSeparationEnabled = CAuditEvent::RoleSeparationIsEnabled();
	    CAInfo.fAdvancedServer = g_fAdvancedServer;

	    hr = myGetCertRegDWValue(
		    g_wszSanitizedName,
		    NULL,
		    NULL,
		    wszREGKRACERTCOUNT,
		    &CAInfo.cKRACertUsedCount);
	    _JumpIfError(hr, error, "myGetCertRegDWValue wszREGKRACERTCOUNT");
        
	    hr = myGetCARegHashCount(
		g_wszSanitizedName,
		CSRH_CAKRACERT,
		&CAInfo.cKRACertCount);
	    _JumpIfError(hr, error, "myGetCertRegStrValue wszREGKRACERTCOUNT");

	    pctbOut->cb = sizeof(CAInfo);
	    pb = (BYTE *) &CAInfo;
	    break;

	case CR_PROP_CASIGCERT:
	    hr = PKCSGetCACert(PropIndex, &pb, &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCACert");

	    break;

	case CR_PROP_CASIGCERTCHAIN:
	case CR_PROP_CASIGCERTCRLCHAIN:
	    hr = PKCSGetCAChain(
			    PropIndex,
			    CR_PROP_CASIGCERTCRLCHAIN == PropId,
			    &pbAlloc,
			    &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCAChain");

	    pb = pbAlloc;	// must be freed
	    break;

	case CR_PROP_CAXCHGCERT:
	    hr = GetClientUserName(NULL, &pwszUserName, NULL);
	    _JumpIfError(hr, error, "GetClientUserName");

	    hr = PKCSGetCAXchgCert(
			    PropIndex,
			    pwszUserName,
			    &iCertSig,
			    &pb,
			    &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCAXchgCert");

	    break;

	case CR_PROP_CAXCHGCERTCHAIN:
	case CR_PROP_CAXCHGCERTCRLCHAIN:
	    hr = GetClientUserName(NULL, &pwszUserName, NULL);
	    _JumpIfError(hr, error, "GetClientUserName");

	    hr = PKCSGetCAXchgChain(
			    PropIndex,
			    pwszUserName,
			    CR_PROP_CAXCHGCERTCRLCHAIN == PropId,
			    &pbAlloc,
			    &pctbOut->cb);
	    _JumpIfError(hr, error, "PKCSGetCAXchgChain");

	    pb = pbAlloc;	// must be freed
	    break;

	case CR_PROP_BASECRL:
	case CR_PROP_DELTACRL:
	    hr = CRLGetCRL(
		    PropIndex,
		    CR_PROP_DELTACRL == PropId,
		    &pCRL,
		    NULL);
	    _JumpIfError(hr, error, "CRLGetCRL");

	    pctbOut->cb = pCRL->cbCrlEncoded;
	    pb = (BYTE *) pCRL->pbCrlEncoded;
	    break;

	case CR_PROP_CACERTSTATUSCODE:
	    hr = PKCSGetCACertStatusCode(PropIndex, &hrCAStatusCode);
	    pctbOut->cb = sizeof(hrCAStatusCode);
	    pb = (BYTE *) &hrCAStatusCode;
	    break;

	case CR_PROP_CACERTSTATE:
	case CR_PROP_CRLSTATE:
	    pctbOut->cb = g_cCACerts;
	    pbAlloc = (BYTE *) MIDL_user_allocate(g_cCACerts);
	    if (NULL == pbAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "no memory");
	    }
	    pb = pbAlloc;	// must be freed

	    hr = PKCSGetCAState(CR_PROP_CACERTSTATE == PropId, pb);
	    _JumpIfError(hr, error, "PKCSGetCAState");
	    break;

	case CR_PROP_KRACERTSTATE:
	    hr = myGetCARegHashCount(
		    g_wszSanitizedName,
		    CSRH_CAKRACERT,
		    &pctbOut->cb);
	    _JumpIfError(hr, error, "myGetCARegHashCount CSRH_CAKRACERT");

	    pbAlloc = (BYTE *) MIDL_user_allocate(pctbOut->cb);
	    if (NULL == pbAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "no memory");
	    }
	    pb = pbAlloc;	// must be freed
	    hr = PKCSGetKRAState(pctbOut->cb, pb);
	    _JumpIfError(hr, error, "PKCSGetKRAState");

	    break;

	case CR_PROP_DNSNAME:
	    pwsz = g_pwszServerName;
	    break;

	case CR_PROP_KRACERT:
	    hKRAStore = CertOpenStore(
				CERT_STORE_PROV_SYSTEM_W,
				X509_ASN_ENCODING,
				NULL,                   // hProv
				CERT_SYSTEM_STORE_LOCAL_MACHINE,
				wszKRA_CERTSTORE);

	    hr = myFindCACertByHashIndex(
		    hKRAStore,
		    g_wszSanitizedName,
		    CSRH_CAKRACERT,
		    PropIndex,
		    NULL,
		    &pCertContext);
	    _JumpIfError(hr, error, "myFindCACertByHashIndex");

	    pb = pCertContext->pbCertEncoded;
	    pctbOut->cb = pCertContext->cbCertEncoded;
	    break;

	case CR_PROP_TEMPLATES:
	    hr = GetCATemplates(pbAlloc, pctbOut->cb);
	    _JumpIfError(hr, error, "GetCATemplates");

	    break;

	case CR_PROP_BASECRLPUBLISHSTATUS:
	case CR_PROP_DELTACRLPUBLISHSTATUS:
    
	    pctbOut->cb = sizeof(DWORD);
	    pbAlloc = (BYTE *) MIDL_user_allocate(pctbOut->cb);
	    _JumpIfAllocFailed(pbAlloc, error);

	    pb = pbAlloc;	// must be freed

	    hr = CRLGetCRL(
		    PropIndex,
		    CR_PROP_DELTACRLPUBLISHSTATUS == PropId, // fDelta
		    NULL,
		    (DWORD *) pbAlloc);
	    _JumpIfError(hr, error, "CRLGetCRL");

	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Bad PropId");
    }

    // not yet populated?

    if (NULL == pb && NULL != pwsz)
    {
	pctbOut->cb = (wcslen(pwsz) + 1) * sizeof(WCHAR);
	pb = (BYTE *) pwsz;
    }
    if (NULL != pbAlloc)
    {
	pctbOut->pb = pbAlloc;
	pbAlloc = NULL;
    }
    else
    {
        if (NULL == pb)
        {
            hr = E_POINTER;
            _JumpError(hr, error, "pb NULL");
        }

	pbReturn = (BYTE *) MIDL_user_allocate(pctbOut->cb);
	if (NULL == pbReturn)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "no memory");
	}
	CopyMemory(pbReturn, pb, pctbOut->cb);
	pctbOut->pb = pbReturn;
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pCRL)
    {
        CertFreeCRLContext(pCRL);
    }
    if (NULL != pbAlloc)
    {
	CoTaskMemFree(pbAlloc);
    }
    if (NULL != pwszSharedFolder)
    {
        LocalFree(pwszSharedFolder);
    }
    if (NULL != hKRAStore)
    {
        CertCloseStore(hKRAStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
RequestGetCAProperty(
    IN  LONG           PropId,          // CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,        // PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;

    pctbPropertyValue->pb = NULL;
    pctbPropertyValue->cb = 0;

	hr = ValidatePropertyParameters(PropId, PropIndex, PropType);
	_JumpIfError(hr, error, "Invalid prop params");

    hr = RequestGetCAPropertySub(
                            PropId,
                            PropIndex,
                            PropType,
                            pctbPropertyValue);
    _JumpIfError(hr, error, "RequestGetCAPropertySub");

    myRegisterMemFree(pctbPropertyValue->pb, CSM_COTASKALLOC);

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
RequestSetCAPropertySub(
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    IN  CERTTRANSBLOB *pctbIn)
{
    HRESULT hr = S_OK;
    LONG lVal = 0;
    const CERT_CONTEXT *pCertContext = NULL;
    HCERTSTORE hKRAStore = NULL;

    switch(PropId)
    {
	case CR_PROP_ROLESEPARATIONENABLED:
        {
	    lVal = *(LONG *) pctbIn->pb;
	    CAuditEvent SaveFlagObj; // used just for saving the flag
	    SaveFlagObj.RoleSeparationEnable(lVal? true : false);
	    hr = SaveFlagObj.RoleSeparationFlagSave(g_wszSanitizedName);
	    _JumpIfError(hr, error, "failed to save ");
        }
        break;
    case CR_PROP_KRACERTUSEDCOUNT:
        CSASSERT(sizeof(DWORD)==pctbIn->cb);
        hr = mySetCertRegDWValue(
                g_wszSanitizedName,
                NULL,
                NULL,
                wszREGKRACERTCOUNT,
                *(DWORD*)pctbIn->pb);
        _JumpIfError(hr, error, "mySetCertRegDWValue ");
        break;
    case CR_PROP_KRACERTCOUNT:
        // New hash count; calling this should follow a sequence of 
        // SetCaProperty(CR_PROP_KRACERT) and should be called only if 
        // new hash count is smaller than current count. If PropIndex>=current count
        // this fails with E_INVALIDARG;
        CSASSERT(sizeof(DWORD)==pctbIn->cb);
        hr = myShrinkCARegHash(
                g_wszSanitizedName,
                CSRH_CAKRACERT,
                *(DWORD*)pctbIn->pb);
        _JumpIfError(hr, error, "myShrinkCARegHash");
        break;
    case CR_PROP_KRACERT:
        pCertContext = CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pctbIn->pb,
            pctbIn->cb);

        if(!pCertContext)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "CertCreateCertificateContext");
        }

        // add certificate to KRA store
        hKRAStore = CertOpenStore(
                           CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING,
                           NULL,                   // hProv
                           CERT_SYSTEM_STORE_LOCAL_MACHINE,
                           wszKRA_CERTSTORE);
        if (NULL == hKRAStore)
        {
           hr = myHLastError();
           _JumpError(hr, error, "CertOpenStore");
        }

        if (!CertAddCertificateContextToStore(
                    hKRAStore,
                    pCertContext,
                    CERT_STORE_ADD_NEW,
                    NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(CRYPT_E_EXISTS) != hr)
            {
                _JumpError(hr, error, "CertAddCertificateContextToStore");
            }
            //the cert exists, ignore error
            hr = S_OK;
        }

        // persist the hash        
        hr = mySetCARegHash(
                g_wszSanitizedName,
                CSRH_CAKRACERT,
                PropIndex,
                pCertContext);
        _JumpIfError(hr, error, "mySetCARegHash");
        break;

    case CR_PROP_TEMPLATES:
        hr = SetCATemplates(
            pctbIn->pb,
            pctbIn->cb);
        _JumpIfError(hr, error, "GetCATemplates");
        break;
        
	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Bad PropId");
    }

error:
    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }
    return hr;
}


STDMETHODIMP
RequestSetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,          // CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,        // PROPTYPE_*
    IN  CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETCAPROPERTY, g_dwAuditFilter);
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
        hr = ValidatePropertyParameters(
                PropId,
                PropIndex,
                PropType);
        _LeaveIfError(hr, "Invalid prop params");

        hr = CheckAuthorityName(pwszAuthority);
        _LeaveIfError(hr, "No authority name");

        // Ignore role separation if setting the role separation flag.
        // This allows an admin to turn the flag off even with role separation
        // enabled so he won't lock himself out.
        if(CR_PROP_ROLESEPARATIONENABLED==PropId)
        {
            audit.EventRoleSeparationEnable(false);
        }

        hr = audit.AddData((DWORD)PropId); // %1 property ID
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = audit.AddData((DWORD)PropIndex); // %2 index
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = audit.AddData((DWORD)PropType); // %3 type
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = audit.AddData(pctbPropertyValue->pb, pctbPropertyValue->cb); // %4 value
        _JumpIfError(hr, error, "CAuditEvent::AddData");

        hr = audit.AccessCheck(
		    CA_ACCESS_ADMIN,
		    audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        hr = RequestSetCAPropertySub(
                                PropId,
                                PropIndex,
                                PropType,
                                pctbPropertyValue);
        _LeaveIfError(hr, "RequestSetCAPropertySub");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    return(hr);
}


STDMETHODIMP
CCertRequestD::GetCACert(
    /* [in] */ DWORD Flags,
    /* [unique][size_is][in] */ USHORT const __RPC_FAR *pwszAuthority,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbOut)
{
    HRESULT hr = S_OK;
    DWORD type = GETCERT_VERSIONMASK & Flags;
    LONG PropIndex;
    LONG PropId;
    LONG PropType;
    BOOL fChainAllowed;
    GETCERTMAP const *pmap;
    GETCERTMAP const *pmapFound;
    DWORD State = 0;

    DBGPRINT((
	    s_ssRequest,
	    "CCertRequestD::GetCACert(tid=%d, Flags=0x%x)\n",
	    GetCurrentThreadId(),
	    Flags));

    hr = CertSrvEnterServer(&State);    
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    // allow empty name only if the client attempts retrieving the name
    if(hr == E_INVALIDARG &&
       (GETCERT_CANAME ==  type ||
        GETCERT_SANITIZEDCANAME == type))
    {
        hr = S_OK;
    }
    _JumpIfError(hr, error, "No authority name");

	__try
	{
	hr = RequestAccessCheck();
	_LeaveIfError(hr, "RequestAccessCheck");

	type = GETCERT_VERSIONMASK & Flags;

	PropIndex = 0;

	// NOTE: all of these should return only a single entry -- 
	// multiple entries will be batched up by the caller 
	// (eg multiple CAs on a machine)

	DBGCODE(WCHAR wszArg[10]);	// Build up a nice debug print:

	PropId = 0;
	PropType = PROPTYPE_BINARY;
	switch (type)
	{
	    case GETCERT_CASIGCERT:
		DBGCODE(wcscpy(wszArg, L"Cert"));
		PropId = CR_PROP_CASIGCERT;
		PropIndex = -1;	// return latest Cert
		break;

	    case GETCERT_CAXCHGCERT:
		DBGCODE(wcscpy(wszArg, L"XchgCert"));
		PropId = CR_PROP_CAXCHGCERT;
		PropIndex = -1;	// return latest Xchg Cert
		break;

	    case GETCERT_CURRENTCRL:
		DBGCODE(wcscpy(wszArg, L"CRL"));
		PropId = CR_PROP_BASECRL;
		PropIndex = -1;	// return latest CRL
		break;

	    default:
	    {
		DBGCODE(wszArg[0] = ((char *) &type)[3]);
		DBGCODE(wszArg[1] = ((char *) &type)[2]);
		DBGCODE(wszArg[2] = ((char *) &type)[1]);
		DBGCODE(wszArg[3] = ((char *) &type)[0]);
		DBGCODE(wszArg[4] = L'\0');

		switch (GETCERT_BYINDEXMASK & Flags)
		{
		    case GETCERT_CACERTSTATEBYINDEX:
		    case GETCERT_CRLSTATEBYINDEX:
			if (0 != (GETCERT_INDEXVALUEMASK & Flags))
			{
			    hr = E_INVALIDARG;
			    _LeaveError(hr, "Invalid State Index");
			}
			// FALLTHROUGH

		    case GETCERT_EXITVERSIONBYINDEX:
		    case GETCERT_CACERTBYINDEX:
		    case GETCERT_CRLBYINDEX:
			PropIndex = GETCERT_INDEXVALUEMASK & Flags;
			type = GETCERT_BYINDEXMASK & Flags;
			DBGCODE(swprintf(&wszArg[2], L".%u", PropIndex));
		    break;
		}
		break;
	    }
	}
	DBGPRINT((
		s_ssRequest,
		"CCertRequestD::GetCACert(\"%ws\"%ws)\n",
		wszArg,
		(GETCERT_CHAIN & Flags)? L"+Chain" : L""));

	for (
	    pmap = g_aCAPropMap;
	    pmap < &g_aCAPropMap[ARRAYSIZE(g_aCAPropMap)];
	    pmap++)
	{
	    if (type == pmap->dwGetCert)
	    {
		PropId = pmap->lPropId;
		PropType = pmap->lPropType;
		break;
	    }
	}
	if (CR_PROP_CASIGCERT == PropId)
	{
	    if (GETCERT_CHAIN & Flags)
	    {
		PropId = CR_PROP_CASIGCERTCHAIN;
		if (GETCERT_CRLS & Flags)
		{
		    PropId = CR_PROP_CASIGCERTCRLCHAIN;
		}
	    }
	}
	else if (CR_PROP_CAXCHGCERT == PropId)
	{
	    if (GETCERT_CHAIN & Flags)
	    {
		PropId = CR_PROP_CAXCHGCERTCHAIN;
		if (GETCERT_CRLS & Flags)
		{
		    PropId = CR_PROP_CAXCHGCERTCRLCHAIN;
		}
	    }
	}
	else if ((GETCERT_CHAIN | GETCERT_CRLS) & Flags)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "Chain/CRLS Flag");
	}

	if (0 == PropId)
	{
	    BYTE *pb;
	    
	    switch (type)
	    {
		case GETCERT_CATYPE:
		    pctbOut->cb = sizeof(g_CAType);
		    pb = (BYTE *) &g_CAType;
		    break;

		default:
		    hr = E_INVALIDARG;
		    _LeaveError(hr, "Invalid GetCert Flags");
	    }
	    pctbOut->pb = (BYTE *) MIDL_user_allocate(pctbOut->cb);
	    if (NULL == pctbOut->pb)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "no memory");
	    }
	    CopyMemory(pctbOut->pb, pb, pctbOut->cb);
	}
	else
	{
	    hr = RequestGetCAPropertySub(
				    PropId,
				    PropIndex,
				    PropType,
				    pctbOut);
	    _LeaveIfError(hr, "RequestGetCAPropertySub");
	}
	myRegisterMemFree(pctbOut->pb, CSM_COTASKALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::GetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::GetCAProperty(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    if (NULL == pwszAuthority ||
        ((L'\0' != *pwszAuthority ||
        (CR_PROP_CANAME != PropId &&
         CR_PROP_DNSNAME != PropId &&
         CR_PROP_SANITIZEDCANAME != PropId)) &&
         0 != lstrcmpi(pwszAuthority, g_wszCommonName) &&
         0 != lstrcmpi(pwszAuthority, g_wszSanitizedName) &&
         0 != lstrcmpi(pwszAuthority, g_pwszSanitizedDSName)))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "bad authority name");
    }

    __try
    {
        hr = RequestAccessCheck();
        _LeaveIfError(hr, "RequestAccessCheck");

        hr = RequestGetCAProperty(
                PropId,
                PropIndex,
                PropType,
                pctbPropertyValue);
        _LeaveIfError(hr,  "RequestGetCAProperty");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::GetCAPropertyInfo(
    IN  wchar_t const *pwszAuthority,
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::GetCAPropertyInfo(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = RequestAccessCheck();
        _LeaveIfError(hr, "RequestAccessCheck");

        hr = RequestGetCAPropertyInfo(
                pcProperty,
                pctbPropInfo);
        _JumpIfError(hr, error, "RequestGetCAPropertyInfo");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertRequestD::_Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
    hr = CheckAuthorityName(pwszAuthority, true); // allow empty name
    _JumpIfError(hr, error, "No authority name");

    hr = RequestAccessCheck();
    _LeaveIfError(hr, "RequestAccessCheck");
    
#if 1
    wprintf(L".");	// may fault if I/O buffer is odd aligned
    fprintf(stdout, ".");
    wprintf(L".\n");	// may fault if I/O buffer is odd aligned
#endif

    hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    
    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::Ping(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertRequestD::Ping2(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    
    DBGPRINT((
	s_ssRequest,
	"CCertRequestD::Ping2(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Constructor
CCertRequestD::CCertRequestD() : m_cRef(1)
{
    InterlockedIncrement(&g_cRequestComponents);
}


// Destructor
CCertRequestD::~CCertRequestD()
{
    InterlockedDecrement(&g_cRequestComponents);
    if (m_cRef != 0)
    {
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CCertRequestD has %d instances left over\n",
	    m_cRef));
    }
}


// IUnknown implementation
STDMETHODIMP
CCertRequestD::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertRequestD *>(this);
    }
    else if (iid == IID_ICertRequestD)
    {
	*ppv = static_cast<ICertRequestD *>(this);
    }
    else if (iid == IID_ICertRequestD2)
    {
	*ppv = static_cast<ICertRequestD2 *>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CCertRequestD::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertRequestD::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


// Class factory IUnknown implementation
STDMETHODIMP
CRequestFactory::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
	*ppv = static_cast<IClassFactory*>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CRequestFactory::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CRequestFactory::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
	return(0);
    }
    return(cRef);
}


// IClassFactory implementation
STDMETHODIMP
CRequestFactory::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    CCertRequestD *pA;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
	hr = CLASS_E_NOAGGREGATION;
	_JumpError(hr, error, "pUnknownOuter");
    }

    // Create component.

    pA = new CCertRequestD;
    if (pA == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "out of memory");
    }

    // Get the requested interface.

    hr = pA->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)

    pA->Release();

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// LockServer
STDMETHODIMP
CRequestFactory::LockServer(
    BOOL bLock)
{
    if (bLock)
    {
	InterlockedIncrement(&g_cRequestServerLocks);
    }
    else
    {
	InterlockedDecrement(&g_cRequestServerLocks);
    }
    return(S_OK);
}


STDMETHODIMP
CRequestFactory::CanUnloadNow()
{
    if (g_cRequestComponents || g_cRequestServerLocks)
    {
        return(S_FALSE);
    }
    return(S_OK);
}


STDMETHODIMP
CRequestFactory::StartFactory()
{
    HRESULT hr;

    g_pIRequestFactory = new CRequestFactory();
    if (NULL == g_pIRequestFactory)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "alloc CRequestFactory");
    }

    hr = CoRegisterClassObject(
                      CLSID_CCertRequestD,
                      static_cast<IUnknown *>(g_pIRequestFactory),
                      CLSCTX_LOCAL_SERVER,
                      REGCLS_MULTIPLEUSE,
                      &g_dwRequestRegister);
    _JumpIfError(hr, error, "CoRegisterClassObject");

error:
    if (S_OK != hr)
    {
        // does deletion
	CRequestFactory::StopFactory();
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
CRequestFactory::StopFactory()
{
    HRESULT hr;
    
    if (0 != g_dwRequestRegister)
    {
        hr = CoRevokeClassObject(g_dwRequestRegister);
	_PrintIfError(hr, "CoRevokeClassObject");
        g_dwRequestRegister = 0;
    }
    if (NULL != g_pIRequestFactory)
    {
        g_pIRequestFactory->Release();
        g_pIRequestFactory = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\service.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        service.cpp
//
// Contents:    Cert Server service processing
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "resource.h"

#define __dwFILE__	__dwFILE_CERTSRV_SERVICE_CPP__


SERVICE_STATUS           g_ssStatus;
SERVICE_STATUS_HANDLE    g_sshStatusHandle;
HANDLE                   g_hServiceStoppingEvent = NULL;
HANDLE                   g_hServiceStoppedEvent = NULL;
DWORD                    g_dwCurrentServiceState = SERVICE_STOPPED;


BOOL
ServiceReportStatusToSCMgrEx(
    IN DWORD dwCurrentState,
    IN DWORD dwWin32ExitCode,
    IN DWORD dwCheckPoint,
    IN DWORD dwWaitHint, 
    IN BOOL  fInitialized)
{
    BOOL fResult;
    HRESULT hr;

    // dwWin32ExitCode can only be set to a Win32 error code (not an HRESULT).

    g_ssStatus.dwServiceSpecificExitCode = myHError(dwWin32ExitCode);
    g_ssStatus.dwWin32ExitCode = HRESULT_CODE(dwWin32ExitCode);
    if ((ULONG) HRESULT_FROM_WIN32(g_ssStatus.dwWin32ExitCode) ==
	g_ssStatus.dwServiceSpecificExitCode)
    {
	// If dwWin32ExitCode is a Win32 error, clear dwServiceSpecificExitCode

	g_ssStatus.dwServiceSpecificExitCode = S_OK;
    }
    else
    {
	// Else dwServiceSpecificExitCode is an HRESULT that cannot be
	// translated to a Win32 error, set dwWin32ExitCode to indicate so.

	g_ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    // save this as global state for interrogation
    g_dwCurrentServiceState = dwCurrentState;

    g_ssStatus.dwControlsAccepted = (SERVICE_START_PENDING == dwCurrentState) ? 0 : SERVICE_ACCEPT_STOP;

    // don't say we'll accept PAUSE until we're really going
    if (fInitialized)
        g_ssStatus.dwControlsAccepted |= SERVICE_ACCEPT_PAUSE_CONTINUE;

    g_ssStatus.dwCurrentState = dwCurrentState;
    g_ssStatus.dwCheckPoint = dwCheckPoint;
    g_ssStatus.dwWaitHint = dwWaitHint;

    fResult = SetServiceStatus(g_sshStatusHandle, &g_ssStatus);
    if (!fResult)
    {
	hr = GetLastError();
        _JumpError(hr, error, "SetServiceStatus");
    }
    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "ServiceReportStatusToSCMgr(state=%x, err=%x(%d), hr=%x(%d), ckpt=%x, wait=%x)\n",
	    dwCurrentState,
	    g_ssStatus.dwWin32ExitCode,
	    g_ssStatus.dwWin32ExitCode,
	    g_ssStatus.dwServiceSpecificExitCode,
	    g_ssStatus.dwServiceSpecificExitCode,
	    dwCheckPoint,
	    dwWaitHint));

error:
    return(fResult);
}


BOOL
ServiceReportStatusToSCMgr(
    IN DWORD dwCurrentState,
    IN DWORD dwWin32ExitCode,
    IN DWORD dwCheckPoint,
    IN DWORD dwWaitHint)
{
    // most callers don't care about initialized/uninitialized distinction
    return ServiceReportStatusToSCMgrEx(
              dwCurrentState,
              dwWin32ExitCode,
              dwCheckPoint,
              dwWaitHint,
              TRUE);
}


VOID
serviceControlHandler(
    IN DWORD dwCtrlCode)
{
    switch (dwCtrlCode)
    {
        case SERVICE_CONTROL_PAUSE:
            if (SERVICE_RUNNING == g_ssStatus.dwCurrentState)
            {
                g_dwCurrentServiceState = SERVICE_PAUSED;
            }
            break;

        case SERVICE_CONTROL_CONTINUE:
            if (SERVICE_PAUSED == g_ssStatus.dwCurrentState)
            {
                g_dwCurrentServiceState = SERVICE_RUNNING;
            }
            break;

        case SERVICE_CONTROL_STOP:
	{
            HRESULT hr;
	    DWORD State = 0;
	    
	    // put us in "stop pending" mode
            g_dwCurrentServiceState = SERVICE_STOP_PENDING;

            // post STOP message to msgloop and bail
            // message loop handles all other shutdown work
            // WM_STOPSERVER signals events that trigger thread synchronization, etc.
	    hr = CertSrvLockServer(&State);
	    _PrintIfError(hr, "CertSrvLockServer");

            PostMessage(g_hwndMain, WM_STOPSERVER, 0, 0);  

            break;
	}

        case SERVICE_CONTROL_INTERROGATE:
            break;
    }
    ServiceReportStatusToSCMgr(g_dwCurrentServiceState, NO_ERROR, 0, 0);
}


//+--------------------------------------------------------------------------
// Service Main
// Anatomy for start/stop cert Service
//
// How we go here:
// wWinMain created a thread which called StartServiceCtrlDispatcher, then went
// into a message loop. StartServiceCtrlDispatcher calls us through the SCM and
// blocks until we return. We hang here until we're completely done.
//
// Service Start
// Create the service start thread. When it is done with init, the thread will
// exit. We hang on the thread, pinging the SCM with START_PENDING and watch
// for the thread exit code. When we see it, we know if the start was a
// success or not. If success, then hang on "stop initiated" event. If
// failure, report failure to SCM and exit service main.
//
// Service Stop
// Events that we need for stop synchronization were created during startup.
// When we get notified fo "stop initiated" event, we begin pinging SCM
// with "STOP_PENDING". When we get "stop complete" event, we are done and need
// to exit service main. The message loop thread is still active -- we'll tell
// it we're shutting down -- it will detect when the StartServiceCtrlDispatcher
// thread it created exits.
//+--------------------------------------------------------------------------

VOID
ServiceMain(
    IN DWORD dwArgc,
    IN LPWSTR *lpszArgv)
{
    HRESULT hr = S_OK;
    int iStartPendingCtr;
    DWORD dwThreadId, dwWaitObj;
    HANDLE hServiceThread = NULL;

    __try
    {
        g_ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
        g_ssStatus.dwServiceSpecificExitCode = 0;
        g_sshStatusHandle = RegisterServiceCtrlHandler(
					      g_wszCertSrvServiceName,
					      serviceControlHandler);
        if (NULL == g_sshStatusHandle)
        {
    	    hr = myHLastError();
            _LeaveError(hr, "RegisterServiceCtrlHandler");
        }

        if (0 != g_dwDelay2)
        {
	        DBGPRINT((
		        DBG_SS_CERTSRV,
		        "ServiceMain: sleeping %u seconds\n",
		        g_dwDelay2));

            iStartPendingCtr = 0;
            while (TRUE)
            {
                ServiceReportStatusToSCMgr(
			    SERVICE_START_PENDING,
			    hr,
			    iStartPendingCtr++,
			    2000);
                Sleep(1000);    // sleep 1 sec

                if (iStartPendingCtr >= (int)g_dwDelay2)
                    break;
            }
        }

        // NOTE: strange event
        // We're starting yet another thread, calling CertSrvStartServerThread.
        // Here, CertSrvStartServerThread actually blocks on server initialization
        hServiceThread = CreateThread(
				    NULL,
				    0,
				    CertSrvStartServerThread,
				    0,
				    0,
				    &dwThreadId);
        if (NULL == hServiceThread)
        {
            hr = myHLastError();
            _LeaveError(hr, "CreateThread");
        }

        // don't wait on startup thread to return, report "started" but give initialization hint
        ServiceReportStatusToSCMgrEx(SERVICE_RUNNING, hr, 0, 0, FALSE /*fInitialized*/);

        // wait on the startup thread to terminate before we continue
        dwWaitObj = WaitForSingleObject(hServiceThread, INFINITE);
        if (dwWaitObj != WAIT_OBJECT_0)
        {
            hr = myHLastError();
            _LeaveError(hr, "WaitForSingleObject");
        }

        if (!GetExitCodeThread(hServiceThread, (DWORD *) &hr))
        {
            hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NO_THREAD);
            _LeaveError(hr, "GetExitCodeThread");
        }
        _LeaveIfError(hr, "CertSrvStartServer");        // error during CertSrvStartServerThread gets reported here

        // now give trigger "we're really ready!"
        ServiceReportStatusToSCMgrEx(SERVICE_RUNNING, hr, 0, 0, TRUE/*fInitialized*/);

        /////////////////////////////////////////////////////////////
        // Work to be done during certsrv operation: CRL
         CertSrvBlockThreadUntilStop();
        /////////////////////////////////////////////////////////////

        iStartPendingCtr = 0;
        while (TRUE)
        {
            // wait for 1 sec, ping Service ctl
            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hServiceStoppedEvent, 1000))
                break;

            ServiceReportStatusToSCMgr(
                SERVICE_STOP_PENDING,
                S_OK,
                iStartPendingCtr++,
                2000);
        }

        DBGPRINT((DBG_SS_CERTSRV, "ServiceMain: Service reported stopped\n"));
        hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

//error:
    __try
    {
        ServiceReportStatusToSCMgr(SERVICE_STOPPED, hr, 0, 0);
        
        if (NULL != hServiceThread)
        {
            CloseHandle(hServiceThread);
        }
        
        DBGPRINT((DBG_SS_CERTSRV, "ServiceMain: Exit: %x\n", hr));
        
        // pass return code to msg loop, tell it to watch for
        // StartServiceCtrlDispatcher to exit
        
        if (!PostMessage(g_hwndMain, WM_SYNC_CLOSING_THREADS, 0, hr))
        {
            hr = myHLastError();
            _PrintIfError(hr, "PostMessage WM_SYNC_CLOSING_THREADS");
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    	_PrintError(hr, "Exception");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\attrib.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        attrib.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certdb.h>
#include "csdisp.h"
#include "column.h"
#include "attrib.h"
#include "ext.h"
#include "row.h"
#include "view.h"


#if DBG_CERTSRV
LONG g_cCertViewAttribute;
LONG g_cCertViewAttributeTotal;
#endif

CEnumCERTVIEWATTRIBUTE::CEnumCERTVIEWATTRIBUTE()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewAttribute));
    DBGCODE(InterlockedIncrement(&g_cCertViewAttributeTotal));
    m_pvw = NULL;
    m_aelt = NULL;
    m_cRef = 1;
}


CEnumCERTVIEWATTRIBUTE::~CEnumCERTVIEWATTRIBUTE()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewAttribute));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWATTRIBUTE",
	    m_cRef));
    }
#endif

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
	m_aelt = NULL;
    }
    if (NULL != m_pvw)
    {
	m_pvw->Release();
	m_pvw = NULL;
    }
}


HRESULT
CEnumCERTVIEWATTRIBUTE::Open(
    IN LONG RowId,
    IN LONG Flags,
    IN ICertView *pvw)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_RowId = RowId;
    m_Flags = Flags;
    m_pvw = pvw;
    m_pvw->AddRef();

    if (0 != Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }
    hr = Reset();
    _JumpIfError2(hr, error, "Reset", S_FALSE);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbAttributes;

    ctbAttributes.pb = NULL;
    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pIndex = -1;
    if (m_ieltCurrent + 1 >= m_celtCurrent && !m_fNoMore)
    {
	hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					    m_RowId,
					    CDBENUM_ATTRIBUTES,
					    NULL == m_aelt?
						NULL :
						m_aelt[m_ieltCurrent].pwszName,
					    CEXT_CHUNK,
					    &celt,
					    &ctbAttributes);
	if (S_FALSE == hr)
	{
	    m_fNoMore = TRUE;
	}
	else
	{
	    _JumpIfError(hr, error, "EnumAttributesOrExtensions");
	}
	hr = _SaveAttributes(celt, &ctbAttributes);
	_JumpIfError(hr, error, "_SaveAttributes");

	m_ieltCurrent = -1;
	m_celtCurrent = celt;
    }
    if (m_ieltCurrent + 1 >= m_celtCurrent)
    {
	hr = S_FALSE;
	goto error;
    }
    m_ielt++;
    m_ieltCurrent++;
    *pIndex = m_ielt;
    m_fNoCurrentRecord = FALSE;
    hr = S_OK;

error:
    if (NULL != ctbAttributes.pb)
    {
	CoTaskMemFree(ctbAttributes.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Next"));
}


HRESULT
CEnumCERTVIEWATTRIBUTE::_SaveAttributes(
    IN DWORD celt,
    IN CERTTRANSBLOB const *pctbAttributes)
{
    HRESULT hr;
    DWORD cbNew;
    CERTDBATTRIBUTE *peltNew = NULL;
    CERTDBATTRIBUTE *pelt;
    CERTTRANSDBATTRIBUTE *ptelt;
    CERTTRANSDBATTRIBUTE *pteltEnd;
    BYTE *pbNext;
    BYTE *pbEnd;

    if (NULL == pctbAttributes)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cbNew = pctbAttributes->cb + celt * (sizeof(*pelt) - sizeof(*ptelt));
    peltNew = (CERTDBATTRIBUTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbNew);
    if (NULL == peltNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pteltEnd = &((CERTTRANSDBATTRIBUTE *) pctbAttributes->pb)[celt];
    if ((BYTE *) pteltEnd > &pctbAttributes->pb[pctbAttributes->cb])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad marshalled data");
    }
    pelt = peltNew;
    pbNext = (BYTE *) &peltNew[celt];
    pbEnd = (BYTE *) Add2Ptr(peltNew, cbNew);
    for (ptelt = (CERTTRANSDBATTRIBUTE *) pctbAttributes->pb;
	 ptelt < pteltEnd;
	 ptelt++, pelt++)
    {
	hr = CopyMarshalledString(
			    pctbAttributes, 
			    ptelt->obwszName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszName);
	_JumpIfError(hr, error, "CopyMarshalledString");

	hr = CopyMarshalledString(
			    pctbAttributes, 
			    ptelt->obwszValue,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszValue);
	_JumpIfError(hr, error, "CopyMarshalledString");
    }
    CSASSERT(pbNext == (BYTE *) Add2Ptr(peltNew, cbNew));

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
    }
    m_aelt = peltNew;
    peltNew = NULL;
    hr = S_OK;

error:
    if (NULL != peltNew)
    {
	LocalFree(peltNew);
    }
    return(hr);
}


HRESULT
CEnumCERTVIEWATTRIBUTE::_FindAttribute(
    OUT CERTDBATTRIBUTE const **ppcda)
{
    HRESULT hr;

    if (NULL == ppcda)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_aelt)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_aelt");
    }
    if (m_fNoCurrentRecord ||
	m_ieltCurrent < 0 ||
	m_ieltCurrent >= m_celtCurrent)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_fNoCurrentRecord || m_ieltCurrent");
    }
    *ppcda = &m_aelt[m_ieltCurrent];
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::GetName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;
    CERTDBATTRIBUTE const *pcda;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindAttribute(&pcda);
    _JumpIfError(hr, error, "_FindAttribute");

    if (!ConvertWszToBstr(pstrOut, pcda->pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::GetName"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::GetValue(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;
    CERTDBATTRIBUTE const *pcda;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindAttribute(&pcda);
    _JumpIfError(hr, error, "_FindAttribute");

    if (L'\0' == *pcda->pwszValue)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "NULL value");
    }
    if (!ConvertWszToBstr(pstrOut, pcda->pwszValue, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::GetValue"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG ieltnew = m_ielt + celt;

    if (-1 > ieltnew)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Skip back to before start");
    }
    m_ielt = ieltnew;
    m_ieltCurrent += celt;
    m_fNoCurrentRecord = TRUE;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Reset(VOID)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbAttributes;

    ctbAttributes.pb = NULL;
    m_fNoMore = FALSE;

    hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					m_RowId,
					CDBENUM_ATTRIBUTES,
					NULL,
					CEXT_CHUNK,
					&celt,
					&ctbAttributes);
    if (S_FALSE == hr)
    {
	m_fNoMore = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumAttributesOrExtensions");
    }

    hr = _SaveAttributes(celt, &ctbAttributes);
    _JumpIfError(hr, error, "_SaveAttributes");

    m_ielt = -1;
    m_ieltCurrent = -1;
    m_celtCurrent = celt;
    m_fNoCurrentRecord = TRUE;

error:
    if (NULL != ctbAttributes.pb)
    {
	CoTaskMemFree(ctbAttributes.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Reset"));
}


STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::Clone(
    /* [out] */ IEnumCERTVIEWATTRIBUTE **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWATTRIBUTE;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWATTRIBUTE");
    }

    hr = ((CEnumCERTVIEWATTRIBUTE *) penum)->Open(m_RowId, m_Flags, m_pvw);
    _JumpIfError(hr, error, "Open");

    if (-1 != m_ielt)
    {
	hr = penum->Skip(m_ielt);
	_JumpIfError(hr, error, "Skip");

	if (!m_fNoCurrentRecord)
	{
	    LONG Index;

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == m_ielt);
	}
    }
    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWATTRIBUTE::Clone"));
}


HRESULT
CEnumCERTVIEWATTRIBUTE::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWATTRIBUTE",
			    &IID_IEnumCERTVIEWATTRIBUTE);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


#if 1
// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWATTRIBUTE::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWATTRIBUTE *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWATTRIBUTE *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWATTRIBUTE)
    {
	*ppv = static_cast<IEnumCERTVIEWATTRIBUTE *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWATTRIBUTE::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWATTRIBUTE::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certsrv\rpc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        rpc.cpp
//
// Contents:    Cert Server RPC
//
// History:     03-Sep-96       larrys created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <accctrl.h>

#include "certrpc.h"
#include "certacl.h"
#include "cscom.h"
#include "resource.h"

#define __dwFILE__	__dwFILE_CERTSRV_RPC_CPP__


RPC_BINDING_VECTOR *pvBindings  = NULL;

char *pszProtSeqNp = "ncacn_np";

char *pszProtSeqTcp = "ncacn_ip_tcp";


typedef struct _CS_RPC_ATHN_LIST
{
    DWORD dwAuthnLevel;
    DWORD dwPrinceNameService;
    DWORD dwAuthnService;
} CS_RPC_ATHN_LIST ;

CS_RPC_ATHN_LIST  g_acsAthnList[] =
{
    { RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_GSS_NEGOTIATE, RPC_C_AUTHN_GSS_NEGOTIATE },
    { RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_NONE, RPC_C_AUTHN_NONE }
};

DWORD g_ccsAthnList = sizeof(g_acsAthnList)/sizeof(g_acsAthnList[0]);


HRESULT
RPCInit(VOID)
{
    char *pszEndpoint = "\\pipe\\cert";

    LPSTR pszPrincName = NULL;
    HRESULT hr;
    DWORD i;

    if (RPC_S_OK == RpcNetworkIsProtseqValidA((unsigned char *) pszProtSeqNp))
    {
        hr = RpcServerUseProtseqEpA(
                            (unsigned char *) pszProtSeqNp,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            (unsigned char *) pszEndpoint,
                            NULL);
        _JumpIfError(hr, error, "RpcServerUseProtseqEpA");
    }

    if (RPC_S_OK == RpcNetworkIsProtseqValidA((unsigned char *) pszProtSeqTcp))
    {

        hr = RpcServerUseProtseqA(
                            (unsigned char *) pszProtSeqTcp,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            NULL);
	if ((HRESULT) ERROR_OUTOFMEMORY == hr)
	{
	    OSVERSIONINFO ovi;

	    ovi.dwOSVersionInfoSize = sizeof(ovi);
	    if (GetVersionEx(&ovi) &&
		VER_PLATFORM_WIN32_NT == ovi.dwPlatformId &&
		4 >= ovi.dwMajorVersion)
	    {
		hr = S_OK;			// Ignore IP failure
	    }
	}
        _JumpIfError(hr, error, "RpcServerUseProtseqA");
    }

    hr = RpcServerInqBindings(&pvBindings);
    _JumpIfError(hr, error, "RpcServerInqBindings");

    hr = RpcServerRegisterIf(s_ICertPassage_v0_0_s_ifspec, NULL, NULL);
    _JumpIfError(hr, error, "RpcServerRegisterIf");

    // Register Authentication Services

    for (i = 0; i < g_ccsAthnList; i++)
    {

        pszPrincName = NULL;
        if (g_acsAthnList[i].dwPrinceNameService != RPC_C_AUTHN_NONE)
        {
            hr  = RpcServerInqDefaultPrincNameA(
					g_acsAthnList[i].dwPrinceNameService,
					(BYTE **) &pszPrincName);
            if (hr != RPC_S_OK)
            {
                continue;
            }
        }



        hr = RpcServerRegisterAuthInfoA(
				    (BYTE *) pszPrincName,
				    g_acsAthnList[i].dwAuthnService,
				    0,
				    0);
        if(hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            continue;
        }
        if(hr != RPC_S_OK)
        {
            break;
        }
    }

    if (hr != RPC_S_UNKNOWN_AUTHN_SERVICE)
    {
        _JumpIfError(hr, error, "RpcServerRegisterAuthInfoA");
    }


    hr = RpcEpRegister(s_ICertPassage_v0_0_s_ifspec, pvBindings, NULL, NULL);
    _JumpIfError(hr, error, "RpcEpRegister");

    // Listen, but don't wait...

    hr = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    _JumpIfError(hr, error, "RpcServerListen");

error:
    if (NULL != pszPrincName)
    {
        RpcStringFreeA((BYTE **) &pszPrincName);
    }
    return(hr);
}


HRESULT
RPCTeardown(VOID)
{ 
    HRESULT hr;
    
    // tear down, don't wait for calls to complete

    hr = RpcServerUnregisterIf(s_ICertPassage_v0_0_s_ifspec, NULL, FALSE);  
    _JumpIfError(hr, error, "RpcServerUnregisterIf");

    // We have no good way of knowing if all RPC requests are done, so let it
    // leak on shutdown.
    // RPC_STATUS RPC_ENTRY RpcMgmtWaitServerListen(VOID); ??

    hr = S_OK;

error:
    return(hr);
}


HRESULT
SetTransBlobString(
    CERTTRANSBLOB const *pctb,
    WCHAR const **ppwsz)
{
    HRESULT hr;

    if (NULL != pctb->pb && 0 != pctb->cb)
    {
	*ppwsz = (WCHAR const *) pctb->pb;

	// use lstrlen here for protection against non-zero terminated bufs!
	// lstrlen will catch AV's and return error

	if ((lstrlen(*ppwsz) + 1) * sizeof(WCHAR) != pctb->cb)
	{
	    hr = E_INVALIDARG;
	    _JumpIfError(hr, error, "Bad TransBlob string");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


/* server prototype */
DWORD
s_CertServerRequest(
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFlags,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition,
    /* [ref][in] */ CERTTRANSBLOB const __RPC_FAR *pctbAttribs,
    /* [ref][in] */ CERTTRANSBLOB const __RPC_FAR *pctbRequest,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCertChain,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbEncodedCert,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbDispositionMessage)
{
    HRESULT hr = S_OK;
    DWORD OpRequest;
    WCHAR const *pwszAttributes = NULL;
    WCHAR const *pwszSerialNumber = NULL;
    CERTTRANSBLOB ctbEmpty = { 0, NULL };
    CERTTRANSBLOB const *pctbSerial = &ctbEmpty;
    WCHAR *pwszUserName = NULL;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_COM_CONTEXT ComContext;
    CERTSRV_RESULT_CONTEXT ResultContext;
    DWORD State = 0;

    ZeroMemory(&ComContext, sizeof(ComContext));
    ZeroMemory(&ResultContext, sizeof(ResultContext));

    DBGPRINT((
	    DBG_SS_CERTSRV,
	    "s_CertServerRequest(tid=%d)\n",
	    GetCurrentThreadId()));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegisterComContext");

    OpRequest = CR_IN_RETRIEVE;
    if (NULL != pctbRequest->pb)
    {
	*pdwRequestId = 0;
	OpRequest = CR_IN_NEW;
    }
    else
    {
	// RetrievePending by SerialNumber in pctbAttribs

	pctbSerial = pctbAttribs;
	pctbAttribs = &ctbEmpty;
    }
    *pdwDisposition = CR_DISP_ERROR;

    __try
    {
        hr = CheckCertSrvAccess(
			    pwszAuthority,
			    h,
			    CA_ACCESS_ENROLL,
			    &ComContext.fInRequestGroup,
			    &ComContext.hAccessToken);
	_LeaveIfError(hr, "CheckCertSrvAccess");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
    _JumpIfError(hr, error, "CheckCertSrvAccess");

    hr = SetTransBlobString(pctbAttribs, &pwszAttributes);
    _JumpIfError(hr, error, "SetTransBlobString");

    hr = SetTransBlobString(pctbSerial, &pwszSerialNumber);
    _JumpIfError(hr, error, "SetTransBlobString");

    ResultContext.pdwRequestId = pdwRequestId;
    ResultContext.pdwDisposition = pdwDisposition;
    ResultContext.pctbDispositionMessage = pctbDispositionMessage;
    ResultContext.pctbCert = pctbEncodedCert;
    if (CR_IN_FULLRESPONSE & dwFlags)
    {
	ResultContext.pctbFullResponse = pctbCertChain;
    }
    else
    {
	ResultContext.pctbCertChain = pctbCertChain;
    }

    __try
    {
	hr = GetClientUserName(
			h,
			&pwszUserName,
			CR_IN_NEW == OpRequest && IsEnterpriseCA(g_CAType)?
			    &ComContext.pwszUserDN : NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = CoreProcessRequest(
			OpRequest | (dwFlags & CR_IN_FORMATMASK),
			pwszUserName,
			pctbRequest->cb,	// cbRequest
			pctbRequest->pb,	// pbRequest
			pwszAttributes,
			pwszSerialNumber,
			dwComContextIndex,
			*pdwRequestId,
			&ResultContext);	// Allocates returned memory
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "CoreProcessRequest");

    // Post-processing
    pctbDispositionMessage->cb = 0;
    if (NULL != pctbDispositionMessage->pb)
    {
        pctbDispositionMessage->cb =
           (wcslen((WCHAR *) pctbDispositionMessage->pb) + 1) * sizeof(WCHAR);
    }

error:
    ReleaseResult(&ResultContext);
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != ComContext.hAccessToken)
    {
	HRESULT hr2;

        // closehandle can throw
        __try
        {
            CloseHandle(ComContext.hAccessToken);
        }
        __except(hr2 = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
	    _PrintError(hr2, "Exception");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
        }
    }
    if (MAXDWORD != dwComContextIndex)
    {
	if (NULL != ComContext.pwszUserDN)
	{
	    LocalFree(ComContext.pwszUserDN);
	}
	UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(State);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// MIDL_user_allocate -- Allocates memory for RPC operations.
//
// Parameters:
// cb - # of bytes to allocate
//
// Returns:
// Memory allocated, or NULL if not enough memory.
//---------------------------------------------------------------------------

void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    IN size_t cb)
{
    return(CoTaskMemAlloc(cb));
}


//+--------------------------------------------------------------------------
// MIDL_user_free -- Free memory allocated via MIDL_user_allocate.
//
// Parameters:
// pvBuffer - The buffer to free.
//
// Returns:
// None.
//---------------------------------------------------------------------------

void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *pb)
{
    CoTaskMemFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\attrib.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        attrib.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

#define wszCLASS_EnumCERTVIEWATTRIBUTE TEXT("xxxxxxxxxxxx")

class CEnumCERTVIEWATTRIBUTE:
    public IDispatchImpl<
		IEnumCERTVIEWATTRIBUTE,
		&IID_IEnumCERTVIEWATTRIBUTE,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWATTRIBUTE>,
    public CComObjectRoot
    //public CComObject<IEnumCERTVIEWATTRIBUTE>
    // Not externally createable:
    // public CComCoClass<CEnumCERTVIEWATTRIBUTE, &CLSID_CEnumCERTVIEWATTRIBUTE>
{
public:
    CEnumCERTVIEWATTRIBUTE();
    ~CEnumCERTVIEWATTRIBUTE();

BEGIN_COM_MAP(CEnumCERTVIEWATTRIBUTE)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWATTRIBUTE)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWATTRIBUTE)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWATTRIBUTE,
    wszCLASS_EnumCERTVIEWATTRIBUTE TEXT(".1"),
    wszCLASS_EnumCERTVIEWATTRIBUTE,
    1, //IDS_ENUMCERTVIEWATTRIBUTE_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWATTRIBUTE
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(GetName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetValue)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWATTRIBUTE **ppenum);

    // CEnumCERTVIEWATTRIBUTE
    HRESULT Open(
	IN LONG RowId,
	IN LONG Flags,
	IN ICertView *pvw);
	
private:
    HRESULT _FindAttribute(
	OUT CERTDBATTRIBUTE const **ppcde);

    HRESULT _SaveAttributes(
	IN DWORD celt,
	IN CERTTRANSBLOB const *pctbAttributes);

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);
	
    LONG             m_RowId;
    LONG             m_Flags;
    ICertView       *m_pvw;
    LONG             m_ielt;
    LONG             m_ieltCurrent;
    LONG             m_celtCurrent;
    CERTDBATTRIBUTE *m_aelt;
    BOOL             m_fNoMore;
    BOOL             m_fNoCurrentRecord;

    // Reference count
    long             m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\certview.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certview.cpp
//
// Contents:    CertView database implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <certdb.h>
#include "view.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertView, CCertView)
END_OBJECT_MAP()

HINSTANCE g_hInstance;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    g_hInstance = hInstance;
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

	case DLL_PROCESS_DETACH:
	    _Module.Term();
        break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\column.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.cpp
//
// Contents:    Cert Server Data Base interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"
#include "column.h"
#include "view.h"


#if DBG_CERTSRV
LONG g_cCertViewColumn;
LONG g_cCertViewColumnTotal;
#endif


CEnumCERTVIEWCOLUMN::CEnumCERTVIEWCOLUMN()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewColumn));
    DBGCODE(InterlockedIncrement(&g_cCertViewColumnTotal));
    m_pvw = NULL;
    m_prow = NULL;
    m_cRef = 1;
}


CEnumCERTVIEWCOLUMN::~CEnumCERTVIEWCOLUMN()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewColumn));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWCOLUMN",
	    m_cRef));
    }
#endif

    if (NULL != m_pvw)
    {
	m_pvw->Release();
    }
    if (NULL != m_prow)
    {
	LocalFree(m_prow);
    }
}


HRESULT
CEnumCERTVIEWCOLUMN::Open(
    IN LONG Flags,
    IN LONG iRow,
    IN ICertView *pvw,
    OPTIONAL IN CERTTRANSDBRESULTROW const *prow)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(0 == (CVRC_TABLE_MASK & CVRC_COLUMN_MASK));

    hr = E_INVALIDARG;
    if (~(CVRC_TABLE_MASK | CVRC_COLUMN_MASK) & Flags)
    {
	_JumpError(hr, error, "Flags");
    }
    switch (CVRC_COLUMN_MASK & Flags)
    {
	case CVRC_COLUMN_SCHEMA:
	case CVRC_COLUMN_RESULT:
	case CVRC_COLUMN_VALUE:
	    break;

	default:
	    _JumpError(hr, error, "Flags column");
    }
    switch (CVRC_TABLE_MASK & Flags)
    {
	case CVRC_TABLE_REQCERT:
	case CVRC_TABLE_EXTENSIONS:
	case CVRC_TABLE_ATTRIBUTES:
	case CVRC_TABLE_CRL:
	    break;

	default:
	    _JumpError(hr, error, "Flags table");
    }

    m_Flags = Flags;
    m_iRow = iRow;
    m_pvw = pvw;
    m_pvw->AddRef();

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "CEnumCERTVIEWCOLUMN::Open(cvrcTable=%x, cvrcColumn=%x)\n",
	    CVRC_TABLE_MASK & Flags,
	    CVRC_COLUMN_MASK & Flags));

    if (NULL != prow)
    {
	m_prow = (CERTTRANSDBRESULTROW *) LocalAlloc(LMEM_FIXED, prow->cbrow);
	if (NULL == m_prow)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(m_prow, prow, prow->cbrow);
    }

    hr = m_pvw->GetColumnCount(m_Flags, &m_celt);
    _JumpIfError(hr, error, "GetColumnCount");

    Reset();

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;

    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (-1 > m_ielt || m_ielt >= m_celt - 1)
    {
	*pIndex = -1;
	hr = S_FALSE;
	goto error;
    }
    m_ielt++;

    hr = ((CCertView *) m_pvw)->FindColumn(
				    m_Flags,
				    m_ielt,
				    &m_pcol,
				    &m_pwszDisplayName);
    _JumpIfError(hr, error, "FindColumn");

    *pIndex = m_ielt;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::Next"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    if (!ConvertWszToBstr(pstrOut, m_pcol->pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetName"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetDisplayName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pwszDisplayName)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pwszDisplayName NULL");
    }

    if (!ConvertWszToBstr(pstrOut, m_pwszDisplayName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetDisplayName"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetType(
    /* [out, retval] */ LONG *pType)
{
    HRESULT hr;

    if (NULL == pType)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    *pType = PROPTYPE_MASK & m_pcol->Type;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetType"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::IsIndexed(
    /* [out, retval] */ LONG *pIndexed)
{
    HRESULT hr;

    if (NULL == pIndexed)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    *pIndexed = (PROPFLAGS_INDEXED & m_pcol->Type)? TRUE : FALSE;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::IsIndexed"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetMaxLength(
    /* [out, retval] */ LONG *pMaxLength)
{
    HRESULT hr;

    if (NULL == pMaxLength)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcol)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcol NULL");
    }
    *pMaxLength = m_pcol->cbMax;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetMaxLength"));
}


DWORD
AsnPropId(
    IN LONG Flags,
    IN WCHAR const *pwszName)
{
    DWORD PropId = CR_PROP_NONE;
    
    switch (CVRC_TABLE_MASK & Flags)
    {
	case CVRC_TABLE_CRL:
	    if (0 == lstrcmpi(pwszName, wszPROPCRLRAWCRL))
	    {
		PropId = CR_PROP_BASECRL;
	    }
	    break;

	case CVRC_TABLE_REQCERT:
	    if (0 == lstrcmpi(pwszName, wszPROPREQUESTRAWREQUEST))
	    {
		PropId = MAXDWORD;
	    }
	    break;
    }
    return(PropId);
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::GetValue(
    /* [in] */          LONG Flags,
    /* [out, retval] */ VARIANT *pvarValue)
{
    HRESULT hr = E_UNEXPECTED;
    BYTE const *pbValue;
    CERTTRANSDBRESULTCOLUMN const *pColResult;

    if (NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarValue);
    if (CVRC_COLUMN_VALUE != (CVRC_COLUMN_MASK & m_Flags))
    {
	_JumpError(hr, error, "No Value");
    }
    if (NULL == m_pcol)
    {
	_JumpError(hr, error, "m_pcol NULL");
    }

    pColResult = &((CERTTRANSDBRESULTCOLUMN const *) (m_prow + 1))[m_ielt];

    CSASSERT(m_pcol->Type == pColResult->Type);

    if (0 == pColResult->obValue)
    {
	hr = S_OK;		// leave VariantClear()'s VT_EMPTY tag
	goto error;
    }

    pbValue = (BYTE const *) Add2ConstPtr(m_prow, pColResult->obValue);

    hr = myUnmarshalFormattedVariant(
			Flags,
			AsnPropId(m_Flags, m_pcol->pwszName),
			m_pcol->Type,
			pColResult->cbValue,
			pbValue,
			pvarValue);
    _JumpIfError(hr, error, "myUnmarshalFormattedVariant");

error:
    if (S_OK != hr)
    {
	VariantClear(pvarValue);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::GetValue"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG ieltnew = m_ielt + celt;

    if (-1 > ieltnew)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Skip back to before start");
    }
    m_ielt = ieltnew;
    m_pcol = NULL;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Reset(VOID)
{
    m_ielt = -1;
    m_pcol = NULL;
    return(S_OK);
}


STDMETHODIMP
CEnumCERTVIEWCOLUMN::Clone(
    /* [out] */ IEnumCERTVIEWCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWCOLUMN");
    }

    hr = ((CEnumCERTVIEWCOLUMN *) penum)->Open(
				    m_Flags,
				    -1,
				    m_pvw,
				    m_prow);
    _JumpIfError(hr, error, "Open");

    if (-1 != m_ielt)
    {
	hr = penum->Skip(m_ielt);
	_JumpIfError(hr, error, "Skip");

	if (NULL != m_pcol)
	{
	    LONG Index;

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == m_ielt);
	}
    }
    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWCOLUMN::Clone"));
}


HRESULT
CEnumCERTVIEWCOLUMN::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWCOLUMN",
			    &IID_IEnumCERTVIEWCOLUMN);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


#if 1
// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWCOLUMN::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else if (iid == IID_ISupportErrorInfo)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWCOLUMN)
    {
	*ppv = static_cast<IEnumCERTVIEWCOLUMN *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWCOLUMN::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWCOLUMN::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\column.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------


// CEnumCERTVIEWCOLUMN::Open Flags:
// CVRC_COLUMN_*	// enumerate schema, result columns or values
// CVRC_TABLE_*		// specifies the DB table to enumerate


class CEnumCERTVIEWCOLUMN: 
    public IDispatchImpl<
		IEnumCERTVIEWCOLUMN,
		&IID_IEnumCERTVIEWCOLUMN,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWCOLUMN>,
    public CComObjectRoot
    // Not externally createable:
    //public CComCoClass<CEnumCERTVIEWCOLUMN, &CLSID_CEnumCERTVIEWCOLUMN>
{
public:
    CEnumCERTVIEWCOLUMN();
    ~CEnumCERTVIEWCOLUMN();

BEGIN_COM_MAP(CEnumCERTVIEWCOLUMN)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWCOLUMN)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWCOLUMN)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWCOLUMN,
    wszCLASS_EnumCERTVIEWCOLUMN TEXT(".1"),
    wszCLASS_EnumCERTVIEWCOLUMN,
    IDS_ENUMCERTVIEWCOLUMN_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWCOLUMN
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(GetName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetDisplayName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetType)(
	/* [out, retval] */ LONG *pType);

    STDMETHOD(IsIndexed)(
	/* [out, retval] */ LONG *pIndexed);

    STDMETHOD(GetMaxLength)(
	/* [out, retval] */ LONG *pMaxLength);
    
    STDMETHOD(GetValue)(
	/* [in] */          LONG Flags,
	/* [out, retval] */ VARIANT *pvarValue);
    
    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWCOLUMN **ppenum);

    // CEnumCERTVIEWCOLUMN
    HRESULT Open(
	IN LONG Flags,
	IN LONG iRow,
	IN ICertView *pvw,
	OPTIONAL IN CERTTRANSDBRESULTROW const *prow);
	
private:
    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);

    ICertView            *m_pvw;
    CERTTRANSDBRESULTROW *m_prow;
    LONG                  m_iRow;
    LONG                  m_ielt;
    LONG                  m_celt;
    LONG                  m_Flags;
    CERTDBCOLUMN const   *m_pcol;
    WCHAR const          *m_pwszDisplayName;

    // Reference count
    long                  m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\csview.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csview.h
//
// Contents:    CertView includes
//
//---------------------------------------------------------------------------

#include <certdb.h>

#include "view.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certview"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\ext.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ext.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

#define CEXT_CHUNK	20

class CEnumCERTVIEWEXTENSION:
    public IDispatchImpl<
		IEnumCERTVIEWEXTENSION,
		&IID_IEnumCERTVIEWEXTENSION,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWEXTENSION>,
    public CComObjectRoot
    // Not externally createable:
    //public CComCoClass<CEnumCERTVIEWEXTENSION, &CLSID_CEnumCERTVIEWEXTENSION>
{
public:
    CEnumCERTVIEWEXTENSION();
    ~CEnumCERTVIEWEXTENSION();

BEGIN_COM_MAP(CEnumCERTVIEWEXTENSION)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWEXTENSION)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWEXTENSION)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWEXTENSION,
    wszCLASS_EnumCERTVIEWEXTENSION TEXT(".1"),
    wszCLASS_EnumCERTVIEWEXTENSION,
    IDS_ENUMCERTVIEWEXTENSION_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWEXTENSION
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(GetName)(
	/* [out, retval] */ BSTR *pstrOut);

    STDMETHOD(GetFlags)(
	/* [out, retval] */ LONG *pFlags);

    STDMETHOD(GetValue)(
	/* [in] */          LONG Type,
	/* [in] */          LONG Flags,
	/* [out, retval] */ VARIANT *pvarValue);

    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWEXTENSION **ppenum);

    // CEnumCERTVIEWEXTENSION
    HRESULT Open(
	IN LONG RowId,
	IN LONG Flags,
	IN ICertView *pvw);

private:
    HRESULT _FindExtension(
	OUT CERTDBEXTENSION const **ppcde);

    HRESULT _SaveExtensions(
	IN DWORD celt,
	IN CERTTRANSBLOB const *pctbExtensions);

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);
	
    LONG             m_RowId;
    LONG             m_Flags;
    ICertView       *m_pvw;
    LONG             m_ielt;
    LONG             m_ieltCurrent;
    LONG             m_celtCurrent;
    CERTDBEXTENSION *m_aelt;
    BOOL             m_fNoMore;
    BOOL             m_fNoCurrentRecord;

    // Reference count
    long             m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\ext.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ext.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certdb.h>
#include "csdisp.h"

#include "column.h"
#include "attrib.h"
#include "ext.h"
#include "row.h"
#include "view.h"


#if DBG_CERTSRV
LONG g_cCertViewExtension;
LONG g_cCertViewExtensionTotal;
#endif

CEnumCERTVIEWEXTENSION::CEnumCERTVIEWEXTENSION()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewExtension));
    DBGCODE(InterlockedIncrement(&g_cCertViewExtensionTotal));
    m_pvw = NULL;
    m_aelt = NULL;
    m_cRef = 1;
}


CEnumCERTVIEWEXTENSION::~CEnumCERTVIEWEXTENSION()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewExtension));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWEXTENSION",
	    m_cRef));
    }
#endif

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
	m_aelt = NULL;
    }
    if (NULL != m_pvw)
    {
	m_pvw->Release();
	m_pvw = NULL;
    }
}


HRESULT
CEnumCERTVIEWEXTENSION::Open(
    IN LONG RowId,
    IN LONG Flags,
    IN ICertView *pvw)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_RowId = RowId;
    m_Flags = Flags;
    m_pvw = pvw;
    m_pvw->AddRef();

    if (0 != Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }
    hr = Reset();
    _JumpIfError2(hr, error, "Reset", S_FALSE);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbExtensions;

    ctbExtensions.pb = NULL;
    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pIndex = -1;
    if (m_ieltCurrent + 1 >= m_celtCurrent && !m_fNoMore)
    {
	hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					    m_RowId,
					    CDBENUM_EXTENSIONS,
					    NULL == m_aelt?
						NULL :
						m_aelt[m_ieltCurrent].pwszName,
					    CEXT_CHUNK,
					    &celt,
					    &ctbExtensions);
	if (S_FALSE == hr)
	{
	    m_fNoMore = TRUE;
	}
	else
	{
	    _JumpIfError(hr, error, "EnumAttributesOrExtensions");
	}
	hr = _SaveExtensions(celt, &ctbExtensions);
	_JumpIfError(hr, error, "_SaveExtensions");

	m_ieltCurrent = -1;
	m_celtCurrent = celt;
    }
    if (m_ieltCurrent + 1 >= m_celtCurrent)
    {
	hr = S_FALSE;
	goto error;
    }
    m_ielt++;
    m_ieltCurrent++;
    *pIndex = m_ielt;
    m_fNoCurrentRecord = FALSE;
    hr = S_OK;

error:
    if (NULL != ctbExtensions.pb)
    {
	CoTaskMemFree(ctbExtensions.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Next"));
}


HRESULT
CopyMarshalledString(
    IN CERTTRANSBLOB const *pctb,
    IN ULONG obwsz,
    IN BYTE *pbEnd,
    IN BYTE **ppbNext,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;

    *ppwszOut = NULL;
    if (0 != obwsz)
    {
	WCHAR *pwsz;
	WCHAR *pwszEnd;
	WCHAR *pwszT;
	DWORD cb;

	pwsz = (WCHAR *) Add2Ptr(pctb->pb, obwsz);
	pwszEnd = &((WCHAR *) pctb->pb)[pctb->cb / sizeof(WCHAR)];
	for (pwszT = pwsz; ; pwszT++)
	{
	    if (pwszT >= pwszEnd)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "bad marshalled data");
	    }
	    if (L'\0' == *pwszT)
	    {
		break;
	    }
	}
	cb = (SAFE_SUBTRACT_POINTERS(pwszT, pwsz) + 1) * sizeof(WCHAR);
	if (&(*ppbNext)[DWORDROUND(cb)] > pbEnd)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "bad marshalled data");
	}
	CopyMemory(*ppbNext, pwsz, cb);

	*ppwszOut = (WCHAR *) *ppbNext;
	*ppbNext += DWORDROUND(cb);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CopyMarshalledBlob(
    IN CERTTRANSBLOB const *pctb,
    IN DWORD cbValue,
    IN ULONG obValue,
    IN BYTE *pbEnd,
    IN BYTE **ppbNext,
    OUT DWORD *pcbOut,
    OUT BYTE **ppbOut)
{
    HRESULT hr;

    *pcbOut = 0;
    *ppbOut = NULL;
    if (0 != obValue)
    {
	BYTE *pb;

	pb = (BYTE *) Add2Ptr(pctb->pb, obValue);
	if (&pb[cbValue] > &pctb->pb[pctb->cb])
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "bad marshalled data");
	}
	if (&(*ppbNext)[DWORDROUND(cbValue)] > pbEnd)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "bad marshalled data");
	}
	CopyMemory(*ppbNext, pb, cbValue);

	*pcbOut = cbValue;
	*ppbOut = *ppbNext;
	*ppbNext += DWORDROUND(cbValue);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTVIEWEXTENSION::_SaveExtensions(
    IN DWORD celt,
    IN CERTTRANSBLOB const *pctbExtensions)
{
    HRESULT hr;
    DWORD cbNew;
    CERTDBEXTENSION *peltNew = NULL;
    CERTDBEXTENSION *pelt;
    CERTTRANSDBEXTENSION *ptelt;
    CERTTRANSDBEXTENSION *pteltEnd;
    BYTE *pbNext;
    BYTE *pbEnd;

    if (NULL == pctbExtensions)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cbNew = pctbExtensions->cb + celt * (sizeof(*pelt) - sizeof(*ptelt));
    peltNew = (CERTDBEXTENSION *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbNew);
    if (NULL == peltNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pteltEnd = &((CERTTRANSDBEXTENSION *) pctbExtensions->pb)[celt];
    if ((BYTE *) pteltEnd > &pctbExtensions->pb[pctbExtensions->cb])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad marshalled data");
    }
    pelt = peltNew;
    pbNext = (BYTE *) &peltNew[celt];
    pbEnd = (BYTE *) Add2Ptr(peltNew, cbNew);
    for (ptelt = (CERTTRANSDBEXTENSION *) pctbExtensions->pb;
	 ptelt < pteltEnd;
	 ptelt++, pelt++)
    {
	pelt->ExtFlags = ptelt->ExtFlags;

	hr = CopyMarshalledString(
			    pctbExtensions, 
			    ptelt->obwszName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszName);
	_JumpIfError(hr, error, "CopyMarshalledString");

	hr = CopyMarshalledBlob(
			    pctbExtensions, 
			    ptelt->cbValue,
			    ptelt->obValue,
			    pbEnd,
			    &pbNext,
			    &pelt->cbValue,
			    &pelt->pbValue);
	_JumpIfError(hr, error, "CopyMarshalledBlob");
    }
    CSASSERT(pbNext == pbEnd);

    if (NULL != m_aelt)
    {
	LocalFree(m_aelt);
    }
    m_aelt = peltNew;
    peltNew = NULL;
    hr = S_OK;

error:
    if (NULL != peltNew)
    {
	LocalFree(peltNew);
    }
    return(hr);
}


HRESULT
CEnumCERTVIEWEXTENSION::_FindExtension(
    OUT CERTDBEXTENSION const **ppcde)
{
    HRESULT hr;

    if (NULL == ppcde)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_aelt)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_aelt");
    }
    if (m_fNoCurrentRecord ||
	m_ieltCurrent < 0 ||
	m_ieltCurrent >= m_celtCurrent)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_fNoCurrentRecord || m_ieltCurrent");
    }
    *ppcde = &m_aelt[m_ieltCurrent];
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::GetName(
    /* [out, retval] */ BSTR *pstrOut)
{
    HRESULT hr;
    CERTDBEXTENSION const *pcde;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindExtension(&pcde);
    _JumpIfError(hr, error, "_FindExtension");

    if (!ConvertWszToBstr(pstrOut, pcde->pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::GetName"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::GetFlags(
    /* [out, retval] */ LONG *pFlags)
{
    HRESULT hr;
    CERTDBEXTENSION const *pcde;

    if (NULL == pFlags)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _FindExtension(&pcde);
    _JumpIfError(hr, error, "_FindExtension");

    *pFlags = pcde->ExtFlags;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::GetFlags"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::GetValue(
    /* [in] */          LONG Type,
    /* [in] */          LONG Flags,
    /* [out, retval] */ VARIANT *pvarValue)
{
    HRESULT hr;
    CERTDBEXTENSION const *pcde;
    BYTE *pballoc = NULL;
    BYTE *pbValue;
    DWORD cbValue;

    if (NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarValue);
    pvarValue->bstrVal = NULL;

    CSASSERT(CV_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CV_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CV_OUT_BINARY == CRYPT_STRING_BINARY);
    CSASSERT(CV_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER);
    CSASSERT(CV_OUT_HEX == CRYPT_STRING_HEX);
    CSASSERT(CV_OUT_HEXADDR == CRYPT_STRING_HEXADDR);
    CSASSERT(CV_OUT_BASE64X509CRLHEADER == CRYPT_STRING_BASE64X509CRLHEADER);
    CSASSERT(CV_OUT_HEXASCII == CRYPT_STRING_HEXASCII);
    CSASSERT(CV_OUT_HEXASCIIADDR == CRYPT_STRING_HEXASCIIADDR);

    switch (Flags)
    {
	case CV_OUT_BASE64HEADER:
	case CV_OUT_BASE64:
	case CV_OUT_BINARY:
	case CV_OUT_BASE64REQUESTHEADER:
	case CV_OUT_HEX:
	case CV_OUT_HEXASCII:
	case CV_OUT_BASE64X509CRLHEADER:
	case CV_OUT_HEXADDR:
	case CV_OUT_HEXASCIIADDR:
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Flags");
    }


    hr = _FindExtension(&pcde);
    _JumpIfError(hr, error, "_FindExtension");

    if (0 == pcde->cbValue || NULL == pcde->pbValue)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "NULL value");
    }
    if (PROPTYPE_BINARY == (PROPTYPE_MASK & Type))
    {
	pbValue = pcde->pbValue;
	cbValue = pcde->cbValue;
    }
    else
    {
	hr = myDecodeExtension(
			Type,
			pcde->pbValue,
			pcde->cbValue,
			&pballoc,
			&cbValue);
	_JumpIfError(hr, error, "myDecodeExtension");

	pbValue = pballoc;
    }
    if (CV_OUT_BINARY == Flags)
    {
	switch (PROPTYPE_MASK & Type)
	{
	    case PROPTYPE_LONG:
		CSASSERT(sizeof(LONG) == cbValue);
		pvarValue->lVal = *(LONG *) pbValue;
		pvarValue->vt = VT_I4;
		break;

	    case PROPTYPE_DATE:
		CSASSERT(sizeof(FILETIME) == cbValue);

		hr = myFileTimeToDate(
				(FILETIME const *) pbValue,
				&pvarValue->date);
		_JumpIfError(hr, error, "myFileTimeToDate");

		pvarValue->vt = VT_DATE;
		break;

	    case PROPTYPE_STRING:
	    case PROPTYPE_BINARY:
		if (!ConvertWszToBstr(
				&pvarValue->bstrVal,
				(WCHAR const *) pbValue,
				cbValue))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
		}
		pvarValue->vt = VT_BSTR;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Type");

	}
    }
    else
    {
	hr = EncodeCertString(
			pbValue,
			cbValue,
			Flags,
			&pvarValue->bstrVal);
	_JumpIfError(hr, error, "EncodeCertString");

	pvarValue->vt = VT_BSTR;
    }

error:
    if (NULL != pballoc)
    {
	LocalFree(pballoc);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::GetValue"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG ieltnew = m_ielt + celt;

    if (-1 > ieltnew)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Skip back to before start");
    }
    m_ielt = ieltnew;
    m_ieltCurrent += celt;
    m_fNoCurrentRecord = TRUE;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Reset(VOID)
{
    HRESULT hr;
    DWORD celt;
    CERTTRANSBLOB ctbExtensions;

    ctbExtensions.pb = NULL;
    m_fNoMore = FALSE;

    hr = ((CCertView *) m_pvw)->EnumAttributesOrExtensions(
					m_RowId,
					CDBENUM_EXTENSIONS,
					NULL,
					CEXT_CHUNK,
					&celt,
					&ctbExtensions);
    if (S_FALSE == hr)
    {
	m_fNoMore = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumAttributesOrExtensions");
    }

    hr = _SaveExtensions(celt, &ctbExtensions);
    _JumpIfError(hr, error, "_SaveExtensions");

    m_ielt = -1;
    m_ieltCurrent = -1;
    m_celtCurrent = celt;
    m_fNoCurrentRecord = TRUE;

error:
    if (NULL != ctbExtensions.pb)
    {
	CoTaskMemFree(ctbExtensions.pb);
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Reset"));
}


STDMETHODIMP
CEnumCERTVIEWEXTENSION::Clone(
    /* [out] */ IEnumCERTVIEWEXTENSION **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWEXTENSION;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWEXTENSION");
    }

    hr = ((CEnumCERTVIEWEXTENSION *) penum)->Open(m_RowId, m_Flags, m_pvw);
    _JumpIfError(hr, error, "Open");

    if (-1 != m_ielt)
    {
	hr = penum->Skip(m_ielt);
	_JumpIfError(hr, error, "Skip");

	if (!m_fNoCurrentRecord)
	{
	    LONG Index;

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == m_ielt);
	}
    }
    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWEXTENSION::Clone"));
}


HRESULT
CEnumCERTVIEWEXTENSION::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWEXTENSION",
			    &IID_IEnumCERTVIEWEXTENSION);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


#if 1
// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWEXTENSION::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWEXTENSION *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWEXTENSION *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWEXTENSION)
    {
	*ppv = static_cast<IEnumCERTVIEWEXTENSION *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWEXTENSION::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWEXTENSION::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\csviewm.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certviewm.h
//
// Contents:    CertView object map entries
//
//---------------------------------------------------------------------------

    OBJECT_ENTRY(CLSID_CCertView, CCertView)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\row.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certdb.h>
#include "csdisp.h"
#include "column.h"
#include "attrib.h"
#include "ext.h"
#include "row.h"
#include "view.h"


#if DBG_CERTSRV
LONG g_cCertViewRow;
LONG g_cCertViewRowTotal;
#endif


#define CB_TARGETBUFFERSIZE	(128 * 1024)	// remote buffer size target
#define CROW_VIEWCHUNKMIN	35


CEnumCERTVIEWROW::CEnumCERTVIEWROW()
{
    DBGCODE(InterlockedIncrement(&g_cCertViewRow));
    DBGCODE(InterlockedIncrement(&g_cCertViewRowTotal));
    m_pvw = NULL;
    m_arowCache = NULL;
    m_prowCacheCurrent = NULL;
    m_cRef = 1;
    m_ieltMax = -1;
}


CEnumCERTVIEWROW::~CEnumCERTVIEWROW()
{
    DBGCODE(InterlockedDecrement(&g_cCertViewRow));

#if DBG_CERTSRV
    if (m_cRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CEnumCERTVIEWROW",
	    m_cRef));
    }
#endif

    if (NULL != m_arowCache)
    {
	CoTaskMemFree((VOID *) m_arowCache);
	m_arowCache = NULL;
    }
    if (NULL != m_pvw)
    {
	m_pvw->Release();
    }
}


HRESULT
CEnumCERTVIEWROW::Open(
    IN ICertView *pvw)
{
    HRESULT hr;

    if (NULL == pvw)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = ((CCertView *) pvw)->GetTable(&m_cvrcTable);
    _JumpIfError(hr, error, "GetTable");

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "CEnumCERTVIEWROW::Open(cvrcTable=%x)\n",
	    m_cvrcTable));

    m_pvw = pvw;
    m_pvw->AddRef();
    m_fNoMoreData = FALSE;
    m_cskip = 0;
    m_ielt = 0;
    m_ieltCacheNext = 1;
    m_crowChunk = 0;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTVIEWROW::_FindCachedRow(
    IN LONG ielt,
    OUT CERTTRANSDBRESULTROW const **ppRow)
{
    HRESULT hr;
    CERTTRANSDBRESULTROW const *prow;
    ULONG i;

    CSASSERT(NULL != ppRow);
    *ppRow = NULL;

    // If the server threw in an extra CERTTRANSDBRESULTROW structure containing
    // the maximum element count, save the maximum count for later use.

    prow = m_arowCache;
    if (NULL != prow && m_fNoMoreData)
    {
	for (i = 0; i < m_celtCache; i++)
	{
	    prow = (CERTTRANSDBRESULTROW const *) Add2ConstPtr(prow, prow->cbrow);
	}
	if (&prow[1] <=
	    (CERTTRANSDBRESULTROW const *) Add2ConstPtr(m_arowCache, m_cbCache) &&
	    prow->rowid == ~prow->ccol)
	{
	    DBGPRINT((
		    DBG_SS_CERTVIEWI,
		    "_FindCachedRow: ieltMax = %d -> %d\n",
		    m_ieltMax,
		    prow->rowid));
	    CSASSERT(-1 == m_ieltMax || (LONG) prow->rowid == m_ieltMax);
	    m_ieltMax = prow->rowid;
	}
    }

    prow = m_arowCache;
    if (NULL == prow || ielt < m_ieltCacheFirst || ielt >= m_ieltCacheNext)
    {
	hr = S_FALSE;		// requested row is not in the cached rowset
	goto error;
    }
    for (ielt -= m_ieltCacheFirst; 0 < ielt; ielt--)
    {
	prow = (CERTTRANSDBRESULTROW const *) Add2ConstPtr(prow, prow->cbrow);
    }
    *ppRow = prow;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTVIEWROW::GetMaxIndex(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;

    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (-1 == m_ieltMax)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_ieltMax not set");
    }
    *pIndex = m_ieltMax;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::GetMaxIndex"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Next(
    /* [out, retval] */ LONG *pIndex)
{
    HRESULT hr;
    LONG ielt;
    LONG ieltNext;
    LONG ieltFirst;
    LONG cbrowResultNominal;

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "Trace: hr = pRow->Next(&lNext);\t_PrintIfError(hr, \"Next\");\n"));
    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pIndex = -1;
    m_prowCacheCurrent = NULL;

    ielt = m_ielt + m_cskip + 1;

    hr = _FindCachedRow(ielt, &m_prowCacheCurrent);
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "_FindCachedRow");
    }
    else
    {
	if (m_fNoMoreData)
	{
	    hr = S_FALSE;
	    _JumpError2(hr, error, "NoMoreData", S_FALSE);
	}
	if (NULL != m_arowCache)
	{
	    CoTaskMemFree((VOID *) m_arowCache);
	    m_arowCache = NULL;
	}
	if (0 == m_crowChunk)	// First call
	{
	    hr = ((CCertView *) m_pvw)->SetViewColumns(&cbrowResultNominal);
	    _JumpIfError(hr, error, "SetViewColumns");

	    m_crowChunk = CB_TARGETBUFFERSIZE / cbrowResultNominal;

	    DBGPRINT((
		DBG_SS_CERTVIEWI,
		"ViewRow::Next: cbrowNominal=%d crowChunk=%d\n",
		cbrowResultNominal,
		m_crowChunk));

	    if (CROW_VIEWCHUNKMIN > m_crowChunk)
	    {
		m_crowChunk = CROW_VIEWCHUNKMIN;
	    }
	}
	hr = ((CCertView *) m_pvw)->EnumView(
					ielt - m_ieltCacheNext,
					m_crowChunk,
					&m_celtCache,
					&m_ieltCacheNext,
					&m_cbCache,
					&m_arowCache);
	if (S_FALSE == hr)
	{
	    m_fNoMoreData = TRUE;
	}
	else
	{
	    _JumpIfError(hr, error, "EnumView");
	}
	m_ieltCacheFirst = m_ieltCacheNext - m_celtCache;

        // workaround for bug 339811 causes this to fail
	//CSASSERT(ielt == m_ieltCacheFirst);

	hr = _FindCachedRow(ielt, &m_prowCacheCurrent);
	_JumpIfError2(hr, error, "_FindCachedRow", S_FALSE);
    }
    m_cskip = 0;
    m_ielt = ielt;

    *pIndex = m_ielt;
    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"ViewRow::Next: cskip=%d, ccache=%u:%u-%u, ielt=%u, ieltMax=%d, RowId=%u\n",
	m_cskip,
	m_celtCache,
	m_ieltCacheFirst,
	m_ieltCacheNext,
	m_ielt,
	m_ieltMax,
	m_prowCacheCurrent->rowid));

error:
    if (S_OK != hr)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "ViewRow::Next: cskip=%d, ccache=%u:%u-%u, ielt=%u, ieltMax=%d, *pIndex=%d, hr=%x\n",
	    m_cskip,
	    m_celtCache,
	    m_ieltCacheFirst,
	    m_ieltCacheNext,
	    m_ielt,
	    m_ieltMax,
	    NULL != pIndex? *pIndex : -1,
	    hr));
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Next"));
}


STDMETHODIMP
CEnumCERTVIEWROW::EnumCertViewColumn(
    /* [out] */ IEnumCERTVIEWCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_prowCacheCurrent)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prowCacheCurrent");
    }

    penum = new CEnumCERTVIEWCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWCOLUMN");
    }

    hr = ((CEnumCERTVIEWCOLUMN *) penum)->Open(
					    CVRC_COLUMN_VALUE,
					    m_ielt,
					    m_pvw,
					    m_prowCacheCurrent);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::EnumCertViewColumn"));
}


STDMETHODIMP
CEnumCERTVIEWROW::EnumCertViewAttribute(
    /* [in] */          LONG Flags,
    /* [out, retval] */ IEnumCERTVIEWATTRIBUTE **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    if (NULL == m_prowCacheCurrent)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prowCacheCurrent");
    }
    if (CVRC_TABLE_REQCERT != m_cvrcTable)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "table has no attributes");
    }

    penum = new CEnumCERTVIEWATTRIBUTE;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWATTRIBUTE");
    }

    hr = ((CEnumCERTVIEWATTRIBUTE *) penum)->Open(
					    m_prowCacheCurrent->rowid,
					    Flags,
					    m_pvw);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::EnumCertViewAttribute"));
}


STDMETHODIMP
CEnumCERTVIEWROW::EnumCertViewExtension(
    /* [in] */          LONG Flags,
    /* [out, retval] */ IEnumCERTVIEWEXTENSION **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    if (NULL == m_prowCacheCurrent)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prowCacheCurrent");
    }
    if (CVRC_TABLE_REQCERT != m_cvrcTable)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "table has no extensions");
    }

    penum = new CEnumCERTVIEWEXTENSION;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWEXTENSION");
    }

    hr = ((CEnumCERTVIEWEXTENSION *) penum)->Open(
					    m_prowCacheCurrent->rowid,
					    Flags,
					    m_pvw);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::EnumCertViewExtension"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Skip(
    /* [in] */ LONG celt)
{
    HRESULT hr;
    LONG cskipnew;
    
    cskipnew = m_cskip + celt;

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "Trace: hr = pRow->Skip(%d);\t_PrintIfError(hr, \"Skip(%d)\");\n",
	    celt,
	    celt));
    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"ViewRow::Skip(%d) ielt=%d: %d --> %d, skip=%d --> %d\n",
	celt,
	m_ielt,
	m_ielt + m_cskip,
	m_ielt + cskipnew,
	m_cskip,
	cskipnew));

    CSASSERT(0 <= m_ielt);
    if (0 > celt)
    {
	if (-1 > m_ielt + cskipnew)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Skip back to before start");
	}
	m_fNoMoreData = FALSE;
    }

    m_prowCacheCurrent = NULL;
    m_cskip = cskipnew;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Skip"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Reset(VOID)
{
    HRESULT hr;

    // Trailing // and no newline comment out Skip() call we trigger:

    DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "Trace: hr = pRow->Reset();\t_PrintIfError(hr, \"Reset\");\n// "));

    hr = Skip(-(m_ielt + m_cskip));
    _JumpIfError(hr, error, "Skip");

error:
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Reset"));
}


STDMETHODIMP
CEnumCERTVIEWROW::Clone(
    /* [out] */ IEnumCERTVIEWROW **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWROW *penum = NULL;
    LONG ielt;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = m_pvw->OpenView(&penum);
    _JumpIfError(hr, error, "OpenView");

    ielt = m_ielt + m_cskip;
    if (-1 != ielt)
    {
	if (NULL == m_prowCacheCurrent)
	{
	    hr = penum->Skip(ielt);
	    _JumpIfError(hr, error, "Skip");
	}
	else
	{
	    LONG Index;

	    hr = penum->Skip(ielt - 1);
	    _JumpIfError(hr, error, "Skip");

	    hr = penum->Next(&Index);
	    _JumpIfError(hr, error, "Next");

	    CSASSERT(Index == ielt);
	}
    }

error:
    if (NULL != ppenum)
    {
	*ppenum = penum;
    }
    return(_SetErrorInfo(hr, L"CEnumCERTVIEWROW::Clone"));
}


HRESULT
CEnumCERTVIEWROW::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW L".CEnumCERTVIEWROW",
			    &IID_IEnumCERTVIEWROW);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTVIEWROW::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTVIEWROW *>(this);
    }
    else if (iid == IID_IDispatch)
    {
	*ppv = static_cast<IEnumCERTVIEWROW *>(this);
    }
    else if (iid == IID_IEnumCERTVIEWROW)
    {
	*ppv = static_cast<IEnumCERTVIEWROW *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWROW::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTVIEWROW::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\row.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.h
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

class CEnumCERTVIEWROW:
    public IDispatchImpl<
		IEnumCERTVIEWROW,
		&IID_IEnumCERTVIEWROW,
		&LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_IEnumCERTVIEWROW>,
    public CComObjectRoot
    // Not externally createable:
    //public CComCoClass<CEnumCERTVIEWROW, &CLSID_CEnumCERTVIEWROW>
{
public:
    CEnumCERTVIEWROW();
    ~CEnumCERTVIEWROW();

BEGIN_COM_MAP(CEnumCERTVIEWROW)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IEnumCERTVIEWROW)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CEnumCERTVIEWROW)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 0 // Not externally createable:
DECLARE_REGISTRY(
    CEnumCERTVIEWROW,
    wszCLASS_EnumCERTVIEWROW TEXT(".1"),
    wszCLASS_EnumCERTVIEWROW,
    IDS_ENUMCERTVIEWROW_DESC,
    THREADFLAGS_BOTH)
#endif

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTVIEWROW
    STDMETHOD(Next)(
	/* [out, retval] */ LONG *pIndex);
    
    STDMETHOD(EnumCertViewColumn)(
	/* [out] */ IEnumCERTVIEWCOLUMN **ppenum);

    STDMETHOD(EnumCertViewAttribute)(
	/* [in] */          LONG Flags,
	/* [out, retval] */ IEnumCERTVIEWATTRIBUTE **ppenum);
    
    STDMETHOD(EnumCertViewExtension)(
	/* [in] */          LONG Flags,
	/* [out, retval] */ IEnumCERTVIEWEXTENSION **ppenum);

    STDMETHOD(Skip)(
	/* [in] */ LONG celt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTVIEWROW **ppenum);

    STDMETHOD(GetMaxIndex)(
	/* [out, retval] */ LONG *pIndex);

    // CEnumCERTVIEWROW
    HRESULT Open(
	IN ICertView *pvw);
	
private:
    HRESULT _FindCachedRow(
	IN LONG ielt,
	OUT CERTTRANSDBRESULTROW const **ppRow);

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);

    ICertView                  *m_pvw;

    BOOL                        m_fNoMoreData;
    LONG                        m_cvrcTable;
    LONG                        m_cskip;
    LONG                        m_ielt;		    // index into full rowset
    LONG		        m_crowChunk;	    // Row Chunk Size

    CERTTRANSDBRESULTROW const *m_arowCache;
    ULONG                       m_celtCache;	    // cached rowset count
    LONG                        m_ieltCacheFirst;   // cached rowset first index
    LONG                        m_ieltCacheNext;    // cached rowset last idx+1

    LONG                        m_ieltMax;	    // max valid index
    LONG                        m_cbCache;
    CERTTRANSDBRESULTROW const *m_prowCacheCurrent; // current cached row

    // Reference count
    long                        m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\view.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.cpp
//
// Contents:    CertView implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"
#include "column.h"
#include "row.h"
#include "view.h"

#define __dwFILE__	__dwFILE_CERTVIEW_VIEW_CPP__


WCHAR const g_wszRequestDot[] = wszPROPREQUESTDOT;

#if DBG_CERTSRV
LONG g_cCertView;
LONG g_cCertViewTotal;
#endif


#define CV_COLUMN_CHUNK		66



//+--------------------------------------------------------------------------
// _cbcolNominal -- Return nominal size for DB column data, based on type.
//
// Assume string binary columns are less than full:
//+--------------------------------------------------------------------------

__inline LONG
_cbcolNominal(
    IN LONG Type,
    IN LONG cbMax)
{
    LONG divisor = 1;

    switch (PROPTYPE_MASK & Type)
    {
	case PROPTYPE_STRING: divisor = 2; break;	// one-half full?
	case PROPTYPE_BINARY: divisor = 4; break;	// one-quarter full?
    }
    return(cbMax / divisor);
}


//+--------------------------------------------------------------------------
// CCertView::CCertView -- constructor
//+--------------------------------------------------------------------------

CCertView::CCertView()
{
    DBGCODE(InterlockedIncrement(&g_cCertView));
    DBGCODE(InterlockedIncrement(&g_cCertViewTotal));
    ZeroMemory(&m_aaaColumn, sizeof(m_aaaColumn));
    m_fOpenConnection = FALSE;
    m_dwServerVersion = 0;
    m_pICertAdminD = NULL;
    m_aColumnResult = NULL;
    m_aDBColumnResult = NULL;
    m_pwszAuthority = NULL;
    m_fAddOk = FALSE;
    m_fOpenView = FALSE;
    m_fServerOpenView = FALSE;
    m_aRestriction = NULL;
    m_fTableSet = FALSE;
    m_icvTable = ICVTABLE_REQCERT;
    m_cvrcTable = CVRC_TABLE_REQCERT;
    m_pwszServerName = NULL;
    ZeroMemory(&m_aapwszColumnDisplayName, sizeof(m_aapwszColumnDisplayName));
}


//+--------------------------------------------------------------------------
// CCertView::~CCertView -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertView::~CCertView()
{
    DBGCODE(InterlockedDecrement(&g_cCertView));

#if DBG_CERTSRV
    if (m_dwRef > 1)
    {
	DBGPRINT((
	    DBG_SS_CERTVIEWI,
	    "%hs has %d instances left over\n",
	    "CCertView",
	    m_dwRef));
    }
#endif

    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertView::_Cleanup
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertView::_Cleanup()
{
    LONG i;

    myCloseDComConnection((IUnknown **) &m_pICertAdminD, &m_pwszServerName);
    m_dwServerVersion = 0;
    m_fOpenConnection = FALSE;

    if (NULL != m_aColumnResult)
    {
	LocalFree(m_aColumnResult);
	m_aColumnResult = NULL;
    }
    if (NULL != m_aDBColumnResult)
    {
	LocalFree(m_aDBColumnResult);
	m_aDBColumnResult = NULL;
    }
    for (i = 0; i < ICVTABLE_MAX; i++)
    {
	if (NULL != m_aaaColumn[i])
	{
	    CERTDBCOLUMN **ppcol;

	    for (
		ppcol = m_aaaColumn[i];
		ppcol < &m_aaaColumn[i][m_acaColumn[i]];
		ppcol++)
	    {
		if (NULL != *ppcol)
		{
		    LocalFree(*ppcol);
		}
	    }
	    LocalFree(m_aaaColumn[i]);
	    m_aaaColumn[i] = NULL;
	}
    }
    if (NULL != m_aRestriction)
    {
	for (i = 0; i < m_cRestriction; i++)
	{
	    if (NULL != m_aRestriction[i].pbValue)
	    {
		LocalFree(m_aRestriction[i].pbValue);
	    }
	}
	LocalFree(m_aRestriction);
	m_aRestriction = NULL;
    }
    if (NULL != m_pwszAuthority)
    {
	LocalFree(m_pwszAuthority);
	m_pwszAuthority = NULL;
    }
    for (i = 0; i < ICVTABLE_MAX; i++)
    {
	if (NULL != m_aapwszColumnDisplayName[i])
	{
	    LocalFree(m_aapwszColumnDisplayName[i]);
	    m_aapwszColumnDisplayName[i] = NULL;
	}
    }
}


HRESULT
CCertView::_ValidateFlags(
    IN BOOL fSchemaOnly,
    IN DWORD Flags)
{
    HRESULT hr = E_INVALIDARG;

    if (~CVRC_COLUMN_MASK & Flags)
    {
	_JumpError(hr, error, "invalid bits");
    }
    switch (CVRC_COLUMN_MASK & Flags)
    {
	case CVRC_COLUMN_RESULT:
	case CVRC_COLUMN_VALUE:
	    if (fSchemaOnly)
	    {
		_JumpError(hr, error, "RESULT/VALUE");
	    }
	    break;

	case CVRC_COLUMN_SCHEMA:
	    break;

	default:
	    _JumpError(hr, error, "bad column");
    }
    if (!m_fOpenConnection ||
	(CVRC_COLUMN_SCHEMA != (CVRC_COLUMN_MASK & Flags) &&
	 !m_fOpenView))
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Unexpected");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::_SetTable(
    IN LONG ColumnIndex)	// CVRC_TABLE_* or CV_COLUMN_*_DEFAULT
{
    HRESULT hr;
    LONG cvrcTable;
    LONG icvTable;
    
    if (0 > ColumnIndex)
    {
	switch (ColumnIndex)
	{
	    case CV_COLUMN_LOG_DEFAULT:
	    case CV_COLUMN_LOG_FAILED_DEFAULT:
	    case CV_COLUMN_LOG_REVOKED_DEFAULT:
	    case CV_COLUMN_QUEUE_DEFAULT:
		icvTable = ICVTABLE_REQCERT;
		cvrcTable = CVRC_TABLE_REQCERT;
		break;

	    case CV_COLUMN_EXTENSION_DEFAULT:
		icvTable = ICVTABLE_EXTENSION;
		cvrcTable = CVRC_TABLE_EXTENSIONS;
		break;

	    case CV_COLUMN_ATTRIBUTE_DEFAULT:
		icvTable = ICVTABLE_ATTRIBUTE;
		cvrcTable = CVRC_TABLE_ATTRIBUTES;
		break;

	    case CV_COLUMN_CRL_DEFAULT:
		icvTable = ICVTABLE_CRL;
		cvrcTable = CVRC_TABLE_CRL;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad negative ColumnIndex");
	}
    }
    else
    {
	if (~CVRC_TABLE_MASK & ColumnIndex)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "invalid bits");
	}
	switch (ColumnIndex)
	{
	    case CVRC_TABLE_REQCERT:
		icvTable = ICVTABLE_REQCERT;
		break;

	    case CVRC_TABLE_EXTENSIONS:
		icvTable = ICVTABLE_EXTENSION;
		break;

	    case CVRC_TABLE_ATTRIBUTES:
		icvTable = ICVTABLE_ATTRIBUTE;
		break;

	    case CVRC_TABLE_CRL:
		icvTable = ICVTABLE_CRL;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad table");
	}
	cvrcTable = CVRC_TABLE_MASK & ColumnIndex;
    }
    if (m_fTableSet)
    {
	if (icvTable != m_icvTable || cvrcTable != m_cvrcTable)
	{
	    DBGPRINT((
		DBG_SS_CERTVIEW,
		"_SetTable: cvrcTable=%x <- %x\n",
		m_cvrcTable,
		cvrcTable));
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "mixed tables");
	}
    }
    else
    {
	m_icvTable = icvTable;
	m_cvrcTable = cvrcTable;
	m_fTableSet = TRUE;
	DBGPRINT((DBG_SS_CERTVIEWI, "_SetTable(cvrcTable=%x)\n", m_cvrcTable));
    }
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertView::SetTable(
    /* [in] */ LONG Table)			// CVRC_TABLE_*
{
    HRESULT hr;
    
    hr = _VerifyServerVersion(2);
    _JumpIfError(hr, error, "_VerifyServerVersion");

    if (0 > Table)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Table");
    }
    if (m_fTableSet)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Already set");
    }
    hr = _SetTable(Table);
    _JumpIfError(hr, error, "_SetTable");

error:
    return(hr);
}


HRESULT
CCertView::GetTable(
    OUT LONG *pcvrcTable)
{
    HRESULT hr;
    
    if (NULL == pcvrcTable)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pcvrcTable = m_cvrcTable;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::FindColumn(
    IN LONG Flags,				// CVRC_COLUMN_*
    IN LONG ColumnIndex,
    OUT CERTDBCOLUMN const **ppColumn,		 // localized for server
    OPTIONAL OUT WCHAR const **ppwszDisplayName) // localized for client
{
    HRESULT hr;
    DWORD i;
    DBGCODE(LONG ColumnIndexArg = ColumnIndex);

    if (NULL == ppColumn)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppColumn = NULL;

    hr = _ValidateFlags(FALSE, Flags);
    _JumpIfError(hr, error, "_ValidateFlags");

    hr = E_INVALIDARG;
    if (CVRC_COLUMN_SCHEMA != (CVRC_COLUMN_MASK & Flags))
    {
	if (m_cColumnResult <= ColumnIndex)
	{
	    DBGPRINT((
		DBG_SS_CERTVIEW,
		"FindColumn(Flags=%x, ColumnIndex=%x, m_cColumnResult=%x)\n",
		Flags,
		ColumnIndex,
		m_cColumnResult));
	    _JumpError(hr, error, "Result ColumnIndex");
	}
	ColumnIndex = m_aColumnResult[ColumnIndex];
    }
    if (ColumnIndex >= m_acColumn[m_icvTable])
    {
	_JumpError(hr, error, "ColumnIndex");
    }
    i = ColumnIndex / CV_COLUMN_CHUNK;
    if (i >= m_acaColumn[m_icvTable])
    {
	_JumpError(hr, error, "ColumnIndex2");
    }

    *ppColumn = &m_aaaColumn[m_icvTable][i][ColumnIndex % CV_COLUMN_CHUNK];

    CSASSERT(NULL != m_aapwszColumnDisplayName[m_icvTable]);
    CSASSERT(NULL != m_aapwszColumnDisplayName[m_icvTable][ColumnIndex]);
    if (NULL != ppwszDisplayName)
    {
	*ppwszDisplayName = m_aapwszColumnDisplayName[m_icvTable][ColumnIndex];
    }
    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"FindColumn(Flags=%x, ColumnIndex=%x->%x) --> Type=%x Index=%x %ws/%ws\n",
	Flags,
	ColumnIndexArg,
	ColumnIndex,
	(*ppColumn)->Type,
	(*ppColumn)->Index,
	(*ppColumn)->pwszName,
	m_aapwszColumnDisplayName[m_icvTable][ColumnIndex]));
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::_SaveColumnInfo(
    IN LONG icvTable,
    IN DWORD celt,
    IN CERTTRANSBLOB const *pctbColumn)
{
    HRESULT hr;
    DWORD cbNew;
    CERTDBCOLUMN *peltNew = NULL;
    CERTDBCOLUMN *pelt;
    CERTTRANSDBCOLUMN *ptelt;
    CERTTRANSDBCOLUMN *pteltEnd;
    BYTE *pbNext;
    BYTE *pbEnd;
    CERTDBCOLUMN **ppColumn;

    if (NULL == pctbColumn)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cbNew = pctbColumn->cb + celt * (sizeof(*pelt) - sizeof(*ptelt));
    peltNew = (CERTDBCOLUMN *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbNew);
    if (NULL == peltNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pteltEnd = &((CERTTRANSDBCOLUMN *) pctbColumn->pb)[celt];
    if ((BYTE *) pteltEnd > &pctbColumn->pb[pctbColumn->cb])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad marshalled data");
    }
    pelt = peltNew;
    pbNext = (BYTE *) &peltNew[celt];
    pbEnd = (BYTE *) Add2Ptr(peltNew, cbNew);
    for (ptelt = (CERTTRANSDBCOLUMN *) pctbColumn->pb;
	 ptelt < pteltEnd;
	 ptelt++, pelt++)
    {
	pelt->Type = ptelt->Type;
	pelt->Index = ptelt->Index;
	pelt->cbMax = ptelt->cbMax;

	hr = CopyMarshalledString(
			    pctbColumn, 
			    ptelt->obwszName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszName);
	_JumpIfError(hr, error, "CopyMarshalledString");

	hr = CopyMarshalledString(
			    pctbColumn, 
			    ptelt->obwszDisplayName,
			    pbEnd,
			    &pbNext,
			    &pelt->pwszDisplayName);
	_JumpIfError(hr, error, "CopyMarshalledString");

    }
    CSASSERT(pbNext == pbEnd);

    ppColumn = (CERTDBCOLUMN **) LocalAlloc(
		    LMEM_FIXED,
		    (m_acaColumn[icvTable] + 1) * sizeof(m_aaaColumn[0]));
    if (NULL == ppColumn)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc ppColumn");
    }
    if (NULL != m_aaaColumn[icvTable])
    {
	CopyMemory(
	    ppColumn,
	    m_aaaColumn[icvTable],
	    m_acaColumn[icvTable] * sizeof(m_aaaColumn[0]));
	LocalFree(m_aaaColumn[icvTable]);
    }
    m_aaaColumn[icvTable] = ppColumn;

    m_aaaColumn[icvTable][m_acaColumn[icvTable]] = peltNew;
    peltNew = NULL;

    m_acaColumn[icvTable]++;
    m_acColumn[icvTable] += celt;
    hr = S_OK;

error:
    if (NULL != peltNew)
    {
	LocalFree(peltNew);
    }
    return(hr);
}


HRESULT
CCertView::_LoadSchema(
    IN LONG icvTable,
    IN LONG cvrcTable)
{
    HRESULT hr;
    DWORD icol;
    DWORD ccol;
    CERTTRANSBLOB ctbColumn;

    ctbColumn.pb = NULL;
    icol = 0;

    CSASSERT(icvTable < ICVTABLE_MAX);

    do
    {
	ccol = CV_COLUMN_CHUNK;
	__try
	{
	    if (CVRC_TABLE_REQCERT == cvrcTable)
	    {
		hr = m_pICertAdminD->EnumViewColumn(
					m_pwszAuthority,
					icol,
					ccol,
					&ccol,
					&ctbColumn);
	    }
	    else
	    {
		CSASSERT(S_OK == _VerifyServerVersion(2));
		hr = m_pICertAdminD->EnumViewColumnTable(
					m_pwszAuthority,
					cvrcTable,
					icol,
					ccol,
					&ccol,
					&ctbColumn);
	    }
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_FALSE != hr)
	{
	    _JumpIfError(
		    hr,
		    error,
		    CVRC_TABLE_REQCERT == cvrcTable?
			"EnumViewColumn" : "EnumViewColumnTable");
	}

	myRegisterMemAlloc(ctbColumn.pb, ctbColumn.cb, CSM_MIDLUSERALLOC);

	hr = _SaveColumnInfo(icvTable, ccol, &ctbColumn);
	_JumpIfError(hr, error, "_SaveColumnInfo");

	CoTaskMemFree(ctbColumn.pb);
	ctbColumn.pb = NULL;

	icol += ccol;

    } while (CV_COLUMN_CHUNK == ccol);

    m_aapwszColumnDisplayName[icvTable] = (WCHAR const **) LocalAlloc(
	LMEM_FIXED | LMEM_ZEROINIT,
	m_acColumn[icvTable] * sizeof(m_aapwszColumnDisplayName[icvTable][0]));
    if (NULL == m_aapwszColumnDisplayName[icvTable])
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (icol = 0; icol < (DWORD) m_acColumn[icvTable]; icol++)
    {
	CERTDBCOLUMN const *pColumn;

	CSASSERT(icol / CV_COLUMN_CHUNK < m_acaColumn[icvTable]);
	pColumn = &m_aaaColumn[icvTable][icol / CV_COLUMN_CHUNK][icol % CV_COLUMN_CHUNK];

	hr = myGetColumnDisplayName(
			    pColumn->pwszName,
			    &m_aapwszColumnDisplayName[icvTable][icol]);

	if (E_INVALIDARG == hr)
	{
	    _PrintErrorStr(hr, "myGetColumnDisplayName", pColumn->pwszName);
	    m_aapwszColumnDisplayName[icvTable][icol] = pColumn->pwszName;
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "myGetColumnDisplayName");
    }
    hr = S_OK;

error:
    if (NULL != ctbColumn.pb)
    {
	CoTaskMemFree(ctbColumn.pb);
    }
    return(hr);
}


STDMETHODIMP
CCertView::OpenConnection(
    /* [in] */ BSTR const strConfig)
{
    HRESULT hr;
    DWORD i;
    WCHAR const *pwszAuthority;
    BOOL fTeardownOnError = FALSE;

    static LONG s_aTable[ICVTABLE_MAX] =
    {
	CVRC_TABLE_REQCERT,	// ICVTABLE_REQCERT
	CVRC_TABLE_EXTENSIONS,	// ICVTABLE_EXTENSION
	CVRC_TABLE_ATTRIBUTES,	// ICVTABLE_ATTRIBUTE
	CVRC_TABLE_CRL,		// ICVTABLE_CRL
    };

    if (NULL == strConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (m_fOpenConnection)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Connected");
    }
    fTeardownOnError = TRUE;

    m_dwServerVersion = 0;
    hr = myOpenAdminDComConnection(
			strConfig,
			&pwszAuthority,
			&m_pwszServerName,
			&m_dwServerVersion,
			&m_pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    CSASSERT (0 != m_dwServerVersion);

    hr = myDupString(pwszAuthority, &m_pwszAuthority);
    _JumpIfError(hr, error, "myDupString");

    ZeroMemory(&m_acaColumn, sizeof(m_acaColumn));
    ZeroMemory(&m_acColumn, sizeof(m_acColumn));

    m_cRestriction = 0;
    m_aRestriction = (CERTVIEWRESTRICTION *) LocalAlloc(LMEM_FIXED, 0);
    if (NULL == m_aRestriction)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    m_fOpenConnection = TRUE;

    for (i = 0; i < ICVTABLE_MAX; i++)
    {
	if (m_dwServerVersion >= 2 || ICVTABLE_REQCERT == i)
	{
	    hr = _LoadSchema(i, s_aTable[i]);
	    _JumpIfError(hr, error, "_LoadSchema");
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr && fTeardownOnError)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertView::OpenConnection"));
}


//+--------------------------------------------------------------------------
// CCertView::_VerifyServerVersion -- verify server version
//
//+--------------------------------------------------------------------------

HRESULT
CCertView::_VerifyServerVersion(
    IN DWORD RequiredVersion)
{
    HRESULT hr;
    
    if (!m_fOpenConnection)
    {
	hr = HRESULT_FROM_WIN32(ERROR_ONLY_IF_CONNECTED);
	_JumpError(hr, error, "Not connected");
    }
    if (m_dwServerVersion < RequiredVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertView::EnumCertViewColumn(
    /* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
    /* [out, retval] */ IEnumCERTVIEWCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTVIEWCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWCOLUMN");
    }

    hr = ((CEnumCERTVIEWCOLUMN *) penum)->Open(fResultColumn, -1, this, NULL);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;
    hr = S_OK;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CCertView::EnumCertViewColumn"));
}


STDMETHODIMP
CCertView::GetColumnCount(
    /* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
    /* [out, retval] */ LONG __RPC_FAR *pcColumn)
{
    HRESULT hr;

    if (NULL == pcColumn)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _ValidateFlags(FALSE, fResultColumn);
    _JumpIfError(hr, error, "_ValidateFlags");

    *pcColumn = CVRC_COLUMN_SCHEMA != (CVRC_COLUMN_MASK & fResultColumn)?
			m_cColumnResult : m_acColumn[m_icvTable];

error:
    return(_SetErrorInfo(hr, L"CCertView::GetColumnCount"));
}


STDMETHODIMP
CCertView::GetColumnIndex(
    /* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
    /* [in] */ BSTR const strColumnName,
    /* [out, retval] */ LONG *pColumnIndex)
{
    HRESULT hr;
    CERTDBCOLUMN const *pColumn;
    WCHAR const *pwsz;
    WCHAR *pwszAlloc = NULL;
    WCHAR const *pwszDisplayName;
    LONG icol;
    LONG i;

    if (NULL == strColumnName || NULL == pColumnIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    pwsz = strColumnName;

    hr = _ValidateFlags(FALSE, fResultColumn);
    _JumpIfError(hr, error, "_ValidateFlags");

    // First pass:  i == 0 -- compare against unlocalized column name
    // Second pass: i == 1 -- compare against localized column name
    // Third pass:  i == 2 -- compare Request.pwsz against unlocalized colname

    for (i = 0; ; i++)
    {
	if (1 < i)
	{
	    if (ICVTABLE_REQCERT != m_icvTable || NULL != wcschr(pwsz, L'.'))
	    {
		hr = E_INVALIDARG;
		_JumpErrorStr(hr, error, "Bad Column Name", strColumnName);
	    }
	    pwszAlloc = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					wcslen(pwsz) * sizeof(WCHAR) +
					    sizeof(g_wszRequestDot));
	    if (NULL == pwszAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwszAlloc, g_wszRequestDot);
	    wcscat(pwszAlloc, pwsz);
	    pwsz = pwszAlloc;
	}
	for (icol = 0; icol < m_acColumn[m_icvTable]; icol++)
	{
	    hr = FindColumn(fResultColumn, icol, &pColumn, &pwszDisplayName);
	    _JumpIfErrorStr(hr, error, "FindColumn", strColumnName);

	    CSASSERT(NULL != pColumn);
	    CSASSERT(NULL != pColumn->pwszName);
	    CSASSERT(NULL != pColumn->pwszDisplayName);	// localized for server
	    CSASSERT(NULL != pwszDisplayName);		// localized for client

	    if (0 == lstrcmpi(
			    pwsz,
			    1 == i? pwszDisplayName : pColumn->pwszName))
	    {
		break;
	    }
	}
	if (icol < m_acColumn[m_icvTable])
	{
	    break;
	}
    }

    *pColumnIndex = icol;
    hr = S_OK;

error:
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    return(_SetErrorInfo(hr, L"CCertView::GetColumnIndex"));
}


STDMETHODIMP
CCertView::SetResultColumnCount(
    /* [in] */ LONG cResultColumn)
{
    HRESULT hr;
    DWORD cColumnDefault;
    CERTTRANSBLOB ctbColumnDefault;

    ctbColumnDefault.pb = NULL;
    hr = E_UNEXPECTED;
    if (!m_fOpenConnection)
    {
	_JumpError(hr, error, "No Connection");
    }
    if (NULL != m_aColumnResult)
    {
	_JumpError(hr, error, "2nd call");
    }
    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    m_cbcolResultNominalTotal = 0;
    m_fAddOk = TRUE;
    if (0 > cResultColumn)
    {
	m_fAddOk = FALSE;

	__try
	{
	    hr = m_pICertAdminD->GetViewDefaultColumnSet(
				    m_pwszAuthority,
				    cResultColumn,
				    &cColumnDefault,
				    &ctbColumnDefault);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError(hr, error, "GetViewDefaultColumnSet");

	myRegisterMemAlloc(
		    ctbColumnDefault.pb,
		    ctbColumnDefault.cb,
		    CSM_MIDLUSERALLOC);

	cResultColumn = cColumnDefault;
	CSASSERT(NULL != ctbColumnDefault.pb);
	CSASSERT(cResultColumn * sizeof(DWORD) == ctbColumnDefault.cb);
    }
    else
    {
	cResultColumn &= CVRC_COLUMN_MASK;
    }

    m_aColumnResult = (LONG *) LocalAlloc(
				LMEM_FIXED,
				cResultColumn * sizeof(m_aColumnResult[0]));
    if (NULL == m_aColumnResult)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Result Column array");
    }

    m_aDBColumnResult = (DWORD *) LocalAlloc(
				LMEM_FIXED,
				cResultColumn * sizeof(m_aDBColumnResult[0]));
    if (NULL == m_aDBColumnResult)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Result DB Column array");
    }

    m_cColumnResultMax = cResultColumn;
    m_cColumnResult = 0;

    if (!m_fAddOk)
    {
	LONG i;
	DWORD const *pIndex;

	pIndex = (DWORD const *) ctbColumnDefault.pb;
	for (i = 0; i < cResultColumn; pIndex++, i++)
	{
	    LONG icol;
	    CERTDBCOLUMN const *pColumn;

	    for (icol = 0; icol < m_acColumn[m_icvTable]; icol++)
	    {
		hr = FindColumn(
			    CVRC_COLUMN_SCHEMA,
			    icol,
			    &pColumn,
			    NULL);
		_JumpIfError(hr, error, "FindColumn");

		if (*pIndex == pColumn->Index)
		{
		    m_aDBColumnResult[i] = *pIndex;
		    m_aColumnResult[i] = icol;
		    m_cbcolResultNominalTotal += _cbcolNominal(pColumn->Type, pColumn->cbMax);
		    break;
		}
	    }
	    if (icol >= m_acColumn[m_icvTable])
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "ColumnIndex");
	    }
	}
	m_cColumnResult = cResultColumn;
    }
    hr = S_OK;

error:
    if (NULL != ctbColumnDefault.pb)
    {
	CoTaskMemFree(ctbColumnDefault.pb);
    }
    return(_SetErrorInfo(hr, L"CCertView::SetResultColumnCount"));
}


STDMETHODIMP
CCertView::SetResultColumn(
    /* [in] */ LONG ColumnIndex)
{
    HRESULT hr;
    CERTDBCOLUMN const *pColumn;

    if (m_fOpenView || !m_fAddOk || m_cColumnResultMax <= m_cColumnResult)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Unexpected");
    }
    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    if (m_acColumn[m_icvTable] <= ColumnIndex)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "ColumnIndex");
    }
    m_aColumnResult[m_cColumnResult] = ColumnIndex;

    hr = FindColumn(
		CVRC_COLUMN_SCHEMA,
		ColumnIndex,
		&pColumn,
		NULL);
    _JumpIfError(hr, error, "FindColumn");

    m_aDBColumnResult[m_cColumnResult] = pColumn->Index;
    m_cbcolResultNominalTotal += _cbcolNominal(pColumn->Type, pColumn->cbMax);

    m_cColumnResult++;

error:
    return(_SetErrorInfo(hr, L"CCertView::SetResultColumn"));
}


STDMETHODIMP
CCertView::SetRestriction(
    /* [in] */ LONG ColumnIndex,
    /* [in] */ LONG SeekOperator,
    /* [in] */ LONG SortOrder,
    /* [in] */ VARIANT __RPC_FAR const *pvarValue)
{
    HRESULT hr;
    CERTDBCOLUMN const *pColumn;
    CERTVIEWRESTRICTION cvr;
    CERTVIEWRESTRICTION *pcvr;

    ZeroMemory(&cvr, sizeof(cvr));

    hr = E_UNEXPECTED;
    if (!m_fOpenConnection)
    {
	_JumpError(hr, error, "No Connection");
    }
    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    if (0 > ColumnIndex)
    {
	cvr.ColumnIndex = ColumnIndex;
	CSASSERT(CVR_SEEK_NONE == cvr.SeekOperator);
	CSASSERT(CVR_SORT_NONE == cvr.SortOrder);
	CSASSERT(NULL == cvr.pbValue);
	CSASSERT(0 == cvr.cbValue);
	hr = S_OK;
    }
    else
    {
	if (NULL == pvarValue)
	{
	    hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
	}

	hr = FindColumn(
		    CVRC_COLUMN_SCHEMA,
		    CVRC_COLUMN_MASK & ColumnIndex,
		    &pColumn,
		    NULL);
	_JumpIfError(hr, error, "FindColumn");

	switch (SeekOperator)
	{
	    case CVR_SEEK_EQ:
	    case CVR_SEEK_LT:
	    case CVR_SEEK_LE:
	    case CVR_SEEK_GE:
	    case CVR_SEEK_GT:
            case CVR_SEEK_NONE:
	    //case CVR_SEEK_SET:
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Seek Operator");
	}
	switch (SortOrder)
	{
	    case CVR_SORT_NONE:
	    case CVR_SORT_ASCEND:
	    case CVR_SORT_DESCEND:
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Sort Order");
	}

	hr = myMarshalVariant(
			pvarValue,
			pColumn->Type,
			&cvr.cbValue,
			&cvr.pbValue);
	_JumpIfError(hr, error, "myMarshalVariant");

	cvr.ColumnIndex = pColumn->Index;
	cvr.SeekOperator = SeekOperator;
	cvr.SortOrder = SortOrder;
    }
    pcvr = (CERTVIEWRESTRICTION *) LocalAlloc(
					LMEM_FIXED,
					(m_cRestriction + 1) * sizeof(*pcvr));
    if (NULL == pcvr)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (NULL != m_aRestriction)
    {
	CopyMemory(pcvr, m_aRestriction, m_cRestriction * sizeof(*pcvr));
	LocalFree(m_aRestriction);
    }
    CopyMemory(&pcvr[m_cRestriction], &cvr, sizeof(cvr));
    cvr.pbValue = NULL;

    m_aRestriction = pcvr;
    m_cRestriction++;

error:
    if (NULL != cvr.pbValue)
    {
	LocalFree(cvr.pbValue);
    }
    return(_SetErrorInfo(hr, L"CCertView::SetRestriction"));
}


STDMETHODIMP
CCertView::OpenView(
    /* [out] */ IEnumCERTVIEWROW **ppenum)
{
    HRESULT hr;
    IEnumCERTVIEWROW *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    hr = E_UNEXPECTED;
    if (!m_fOpenConnection)
    {
	_JumpError(hr, error, "No Connection");
    }
    if (m_fOpenView)
    {
	_JumpError(hr, error, "2nd call");
    }

    penum = new CEnumCERTVIEWROW;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTVIEWROW");
    }

    hr = ((CEnumCERTVIEWROW *) penum)->Open(this);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    m_fAddOk = FALSE;
    m_fOpenView = TRUE;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != penum)
    {
	penum->Release();
    }
    return(_SetErrorInfo(hr, L"CCertView::OpenView"));
}


HRESULT
CCertView::SetViewColumns(
    OUT LONG *pcbrowResultNominal)
{
    HRESULT hr;
    LONG icol;

    if (NULL == pcbrowResultNominal)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (m_fServerOpenView)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "View Already Open");
    }

    if (!m_fTableSet)
    {
	hr = _SetTable(CVRC_TABLE_REQCERT);
	_JumpIfError(hr, error, "_SetTable");
    }

    if (NULL == m_aDBColumnResult)
    {
	hr = SetResultColumnCount(m_acColumn[m_icvTable]);
	_JumpIfError(hr, error, "SetResultColumnCount");

	for (icol = 0; icol < m_acColumn[m_icvTable]; icol++)
	{
	    hr = SetResultColumn(icol);
	    _JumpIfError(hr, error, "SetResultColumn");
	}
    }
    *pcbrowResultNominal =
		sizeof(CERTDBRESULTROW) +
		sizeof(CERTDBRESULTCOLUMN) * m_cColumnResultMax +
		m_cbcolResultNominalTotal;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertView::EnumView(
    IN  LONG                         cskip,
    IN  ULONG                        celt,
    OUT ULONG                       *pceltFetched,
    OUT LONG                        *pieltNext,
    OUT LONG		            *pcbResultRows,
    OUT CERTTRANSDBRESULTROW const **ppResultRows)
{
    HRESULT hr;
    CERTTRANSBLOB ctbResultRows;
    
    if (NULL == ppResultRows ||
        NULL == pceltFetched ||
        NULL == pieltNext ||
        NULL == pcbResultRows)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppResultRows = NULL;

    if (!m_fOpenConnection)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "No Connection");
    }

    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"%hs: ielt=%d cskip=%d celt=%d\n",
	m_fServerOpenView? "EnumView" : "OpenView",
	m_fServerOpenView? m_ielt : 1,
	cskip,
	celt));

    if (!m_fServerOpenView)
    {
	if (m_cColumnResultMax != m_cColumnResult)
	{
	    hr = E_UNEXPECTED;
	    _JumpError(hr, error, "Missing Result Columns");
	}

	m_ielt = 1;

	__try
	{
	    hr = m_pICertAdminD->OpenView(
				    m_pwszAuthority,
				    m_cRestriction,
				    m_aRestriction,
				    m_cColumnResultMax,
				    m_aDBColumnResult,
				    m_ielt + cskip,
				    celt,
				    pceltFetched,
				    &ctbResultRows);
	    m_fServerOpenView = TRUE;
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "OpenView");
	}
    }
    else
    {
	__try
	{
	    hr = m_pICertAdminD->EnumView(
				    m_pwszAuthority,
				    m_ielt + cskip,
				    celt,
				    pceltFetched,
				    &ctbResultRows);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "EnumView");
	}
    }
    myRegisterMemAlloc(ctbResultRows.pb, ctbResultRows.cb, CSM_MIDLUSERALLOC);

    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"%hs: *pceltFetched=%d -> %d  @ielt=%d -> %d\n",
	m_fServerOpenView? "EnumView" : "OpenView",
	celt,
	*pceltFetched,
	m_ielt + cskip,
	m_ielt + cskip + *pceltFetched));

    m_ielt += cskip + *pceltFetched;
    *pieltNext = m_ielt;

    DBGPRINT((
	DBG_SS_CERTVIEWI,
	"EnumView: celtFetched=%d ieltNext=%d cb=%d hr=%x\n",
	*pceltFetched,
	*pieltNext,
	ctbResultRows.cb,
	hr));

    *pcbResultRows = ctbResultRows.cb;
    *ppResultRows = (CERTTRANSDBRESULTROW const *) ctbResultRows.pb;

error:
    return(hr);
}


HRESULT
CCertView::EnumAttributesOrExtensions(
    IN DWORD RowId,
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszLast,
    IN DWORD celt,
    OUT DWORD *pceltFetched,
    CERTTRANSBLOB *pctbOut)
{
    HRESULT hr;

    if (NULL == pceltFetched || NULL == pctbOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (!m_fOpenConnection)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "No Connection");
    }
    __try
    {
	hr = m_pICertAdminD->EnumAttributesOrExtensions(
						    m_pwszAuthority,
						    RowId,
						    Flags,
						    pwszLast,
						    celt,
						    pceltFetched,
						    pctbOut);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "EnumAttributesOrExtensions");
    }
    myRegisterMemAlloc(pctbOut->pb, pctbOut->cb, CSM_MIDLUSERALLOC);

error:
    return(hr);
}


HRESULT
CCertView::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTVIEW,
			    &IID_ICertView);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certview\view.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.h
//
// Contents:    Declaration of CCertView
//
//---------------------------------------------------------------------------

#include "certsrvd.h"
#include "cscomres.h"


HRESULT
CopyMarshalledString(
    IN CERTTRANSBLOB const *pctb,
    IN ULONG obwsz,
    IN BYTE *pbEnd,
    IN BYTE **ppbNext,
    OUT WCHAR **ppwszOut);


#define ICVTABLE_REQCERT	0
#define ICVTABLE_EXTENSION	1
#define ICVTABLE_ATTRIBUTE	2
#define ICVTABLE_CRL		3
#define ICVTABLE_MAX		4

/////////////////////////////////////////////////////////////////////////////
// CCertView

class ATL_NO_VTABLE CCertView:
    public IDispatchImpl<ICertView2, &IID_ICertView2, &LIBID_CERTADMINLib>,
    public ISupportErrorInfoImpl<&IID_ICertView2>,
    public CComObjectRoot,
    public CComCoClass<CCertView, &CLSID_CCertView>
{
public:
    CCertView();
    ~CCertView();

BEGIN_COM_MAP(CCertView)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertView)
    COM_INTERFACE_ENTRY(ICertView2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertView)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

#if 1
DECLARE_REGISTRY(
    CCertView,
    wszCLASS_CERTVIEW TEXT(".1"),
    wszCLASS_CERTVIEW,
    IDS_CERTVIEW_DESC,
    THREADFLAGS_BOTH)
#endif

// ICertView
    STDMETHOD(OpenConnection)(
	/* [in] */ BSTR const strConfig);

    STDMETHOD(EnumCertViewColumn)(
	/* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
	/* [out, retval] */ IEnumCERTVIEWCOLUMN **ppenum);

    STDMETHOD(GetColumnCount)(
	/* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
	/* [out, retval] */ LONG __RPC_FAR *pcColumn);

    STDMETHOD(GetColumnIndex)(
	/* [in] */ LONG fResultColumn,		// CVRC_COLUMN_*
	/* [in] */ BSTR const strColumnName,
	/* [out, retval] */ LONG *pColumnIndex);

    STDMETHOD(SetResultColumnCount)(
	/* [in] */ LONG cColumn);

    STDMETHOD(SetResultColumn)(
	/* [in] */ LONG ColumnIndex);

    STDMETHOD(SetRestriction)(
	/* [in] */ LONG ColumnIndex,
	/* [in] */ LONG SeekOperator,
	/* [in] */ LONG SortOrder,
	/* [in] */ VARIANT __RPC_FAR const *pvarValue);

    STDMETHOD(OpenView)(
	/* [out] */ IEnumCERTVIEWROW **ppenum);

// ICertView2
    STDMETHOD(SetTable)(
	/* [in] */ LONG Table);			// CVRC_TABLE_*

// CCertView
    HRESULT GetTable(
	OUT LONG *pcvrcTable);

    HRESULT FindColumn(
	IN LONG Flags,				// CVRC_TABLE_* | CVRC_COLUMN_*
	IN LONG ColumnIndex,
	OUT CERTDBCOLUMN const **ppColumn,
	OPTIONAL OUT WCHAR const **ppwszDisplayName);

    HRESULT SetViewColumns(
	OUT LONG *pcbrowResultNominal);

    HRESULT EnumView(
	IN  LONG                         cskip,
	IN  ULONG                        celt,
	OUT ULONG                       *pceltFetched,
	OUT LONG                        *pieltNext,
	OUT LONG		        *pcbResultRows,
	OUT CERTTRANSDBRESULTROW const **ppResultRows);

    HRESULT EnumAttributesOrExtensions(
	IN DWORD RowId,
	IN DWORD Flags,
	OPTIONAL IN WCHAR const *pwszLast,
	IN DWORD celt,
	OUT DWORD *pceltFetched,
	CERTTRANSBLOB *pctbOut);

// Internal Functions
private:
    VOID _Cleanup();

    HRESULT _VerifyServerVersion(
	IN DWORD RequiredVersion);

    HRESULT _SaveColumnInfo(
	IN LONG icvTable,
	IN DWORD celt,
	IN CERTTRANSBLOB const *pctbColumn);

    HRESULT _LoadSchema(
	IN LONG icvTable,
	IN LONG cvrcTable);

    HRESULT _ValidateFlags(
	IN BOOL fSchemaOnly,
	IN DWORD Flags);

    HRESULT _SetTable(
	IN LONG Table);			// CVRC_TABLE_* or CV_COLUMN_*_DEFAULT

    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription);

    WCHAR           *m_pwszServerName;
    DWORD	     m_dwServerVersion;
    ICertAdminD2    *m_pICertAdminD;

    CERTDBCOLUMN   **m_aaaColumn[ICVTABLE_MAX];
    DWORD            m_acaColumn[ICVTABLE_MAX];
    LONG             m_acColumn[ICVTABLE_MAX];

    CERTVIEWRESTRICTION *m_aRestriction;
    LONG             m_cRestriction;
    BOOL             m_fTableSet;
    LONG             m_icvTable;	// ICVTABLE_*
    LONG             m_cvrcTable;	// CVRC_TABLE_*

    BOOL             m_fAddOk;
    LONG             m_cColumnResultMax;
    LONG             m_cColumnResult;
    LONG             m_cbcolResultNominalTotal;

    LONG            *m_aColumnResult;   // Exposed 0-based Column Index array
    DWORD           *m_aDBColumnResult; // Server DB Column Index array

    WCHAR           *m_pwszAuthority;
    BOOL             m_fOpenConnection;
    BOOL             m_fOpenView;
    BOOL             m_fServerOpenView;
    LONG             m_ielt;
    WCHAR const	   **m_aapwszColumnDisplayName[ICVTABLE_MAX];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certwrap\certwrap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certwrap.cpp
//
//  Contents:   Wrap a command line and expand envronment variables.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>

#include "resource.h"


#define WM_WRAPCOMMAND		WM_USER+0

WCHAR wszAppName[] = L"CertWrap";
HINSTANCE hInstApp;


#define ARRAYLEN(a)	(sizeof(a)/sizeof((a)[0]))

VOID
WrapCommand(
    HWND hWnd,
    WCHAR const *pwszCommand)
{
    WCHAR awc[4096];
    WCHAR awcVar[128];
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;
    WCHAR *pwszVar;
    BOOL fTooLong = FALSE;
    BOOL fVarTooLong = FALSE;
    BOOL fVarNotFound = FALSE;
    DWORD cwc;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL b;

    pwszSrc = pwszCommand;
    pwszDst = awc;
    while (L'\0' != (*pwszDst = *pwszSrc++))
    {
	if ('%' == *pwszDst)
	{
	    *pwszDst = L'\0';
	    pwszVar = awcVar;

	    while (L'\0' != *pwszSrc)
	    {
		if (L'%' == *pwszSrc)
		{
		    pwszSrc++;
		    break;
		}
		*pwszVar++ = *pwszSrc++;
		if (pwszVar >= &awcVar[ARRAYLEN(awcVar) - 1])
		{
		    fVarTooLong = TRUE;
		    goto error;
		}
	    }
	    *pwszVar = L'\0';

	    cwc = GetEnvironmentVariable(
		    awcVar,
		    pwszDst,
		    (DWORD) (ULONG_PTR) (&awcVar[ARRAYLEN(awcVar)] - pwszDst));
	    if (0 == cwc)
	    {
		fVarNotFound = TRUE;
		goto error;
	    }
	    if ((DWORD) (ULONG_PTR) (&awcVar[ARRAYLEN(awcVar)] - pwszDst) <= cwc)
	    {
		fTooLong = TRUE;
		goto error;
	    }
	    pwszDst += cwc;
	}
	else
	{
	    pwszDst++;
	}
	if (pwszDst >= &awc[ARRAYLEN(awc)])
	{
	    fTooLong = TRUE;
	    goto error;
	}
    }

error:
    if (fVarNotFound)
    {
	MessageBox(
		hWnd,
		L"Environment Variable Not Found",
		awcVar,
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    if (fVarTooLong)
    {
	MessageBox(
		hWnd,
		L"Environment Variable Name Too Long",
		L"CertWrapper",
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    if (fTooLong)
    {
	MessageBox(
		hWnd,
		L"Command Line Too Long",
		L"CertWrapper",
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    MessageBox(hWnd, awc, L"CertWrapper", MB_OK);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;

    b = CreateProcess(
		NULL,
		awc,
		NULL,
		NULL,
		FALSE,
		0,
		NULL,
		NULL,	// lpCurrentDirectory
		&si,
		&pi);
    if (!b)
    {
	DWORD err;
	WCHAR awcErr[MAX_PATH];

	err = GetLastError();
	wsprintf(awcErr, L"CreateProcess failed: %d(%x)", err, err);
	MessageBox(
		hWnd,
		awcErr,
		L"CertWrapper",
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
}


//**************************************************************************
// FUNCTION:	MainWndProc(...)
// ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_CREATE:
	    return(0);

        case WM_SIZE:
	    return(0);

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_WRAPCOMMAND:
	    WrapCommand(hWnd, (WCHAR const *) lParam);
	    PostQuitMessage(0);
	    break;

        default:
	    return(DefWindowProc(hWnd, msg, wParam, lParam));
    }
    return(0);
}


//+------------------------------------------------------------------------
//
//  Function:	WinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[lpCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
{
    MSG msg;
    WNDCLASS wcApp;
    HWND hWndMain;

    // Save the current instance
    hInstApp = hInstance;

    // Set up the application's window class
    wcApp.style 	= 0;
    wcApp.lpfnWndProc 	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL, IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL, IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH) GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= wszAppName;
    if (!RegisterClass(&wcApp))
    {
	return(FALSE);
    }

    // Create Main Window
    hWndMain = CreateWindow(wszAppName,
			    L"CertWrapper Application",
			    WS_OVERLAPPEDWINDOW,
			    CW_USEDEFAULT, CW_USEDEFAULT,
			    CW_USEDEFAULT, CW_USEDEFAULT,
			    NULL,
			    NULL,
			    hInstance,
			    NULL);

    if (NULL == hWndMain)
    {
	return(FALSE);
    }

    // Make window visible
    // ShowWindow(hWndMain,nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain, WM_WRAPCOMMAND, 0, (LPARAM) pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    return (int)(msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certweb\certsbrt.inc ===
<%' CODEPAGE=65001 'UTF-8%>
<%' certsbrt.asp - (CERT)srv web - (S)cript: determine (BR)owser (T)ype
  ' Copyright (C) Microsoft Corporation, 1998 - 1999

' first, make sure we have the right URL to prevent cookie problems.
	If "/certsrv" <> Left(Request.ServerVariables("URL"), 8) Then
		If 0<>Len(Request.ServerVariables("QUERY_STRING")) Then
			Response.Redirect "/certsrv" & Mid(Request.ServerVariables("URL"), 9) & "?" & Request.ServerVariables("QUERY_STRING")
		Else
			Response.Redirect "/certsrv" & Mid(Request.ServerVariables("URL"), 9)
		End If
		Response.End
	End If

' We know of three browser types
' sBrowser =
'  "IE"   - IE (use XEnroll)                - javascript available - DHTML available
'  "NN"   - Netscape Navigator (use Keygen) - javascript available - no DHTML
'  "Text" - Lynx or other minimal browser   - no javascript        - no DHTML

' Also, we have a flag we can set when we see an old version of IE.
' bRecommendUpgrade =
'  True  - old version of IE
'  False - other unsupported browser
' bNewThanNT4, boolean to determine browser client platform os version

	Dim sBrowser, bRecommendUpgrade, bNewThanNT4
	bNewThanNT4 = False
	sBrowser=Request.ServerVariables("HTTP_USER_AGENT")
	If 0=InStr(sBrowser, "Mozilla") Then
		'Lynx or other minimal browser
		sBrowser="Text"
		bRecommendUpgrade=False
	ElseIf 0=InStr(sBrowser, "MSIE") Then
		'Netscape Navigator
		sBrowser="NN"
		bRecommendUpgrade=False
	ElseIf CInt(Mid(sBrowser, InStr(sBrowser, "MSIE")+5, 1))<4 Then
		'Too Old Internet Explorer
		sBrowser="Text"
		bRecommendUpgrade=True
	ElseIf 0=InStr(sBrowser, "Win") Or (0=InStr(sBrowser, "95") _
			And 0=InStr(sBrowser, "98") And 0=InStr(sBrowser, "2000") _
			And 0=InStr(sBrowser, "NT")) Then
		'unsupported platform Internet Explorer (eg, Mac, Unix, Win16)
		sBrowser="Text"
		bRecommendUpgrade=False
	ElseIf "Alpha"=Request.ServerVariables("HTTP_UA_CPU") Then
		'NT4 IE4 Alpha, we are no longer building XEnroll for this platform
		sBrowser="Text"
		bRecommendUpgrade=False
	Else
		If 0 <> InStr(sBrowser, "Windows NT 5") Then
			bNewThanNT4 = True
		End If
		'New Internet Explorer
		sBrowser="IE"
		bRecommendUpgrade=False
	End If

	Const L_LabelColWidth_Number=100 ' the standard label-column width in pixels
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certwrap\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

#define IDI_APP                         201
#define IDI_PRODUCT                     202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\certxds.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certxds.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "exit.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertExit, CCertExit)
    OBJECT_ENTRY(CLSID_CCertManageExitModule, CCertManageExitModule)
END_OBJECT_MAP()

HANDLE g_hEventLog = NULL;
HINSTANCE g_hInstance = NULL;
#define EVENT_SOURCE_NAME L"CertEnterprisePolicy"


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        _Module.Init(ObjectMap, hInstance);
        g_hEventLog = RegisterEventSource(NULL, EVENT_SOURCE_NAME);
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        break;
        
    case DLL_PROCESS_DETACH:
        _Module.Term();
        if (g_hEventLog)
        {
            DeregisterEventSource(g_hEventLog);
            g_hEventLog = NULL;
        }
       
        break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\exit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExit implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <security.h>
#include <dsgetdc.h>
#include <userenv.h>

#include "cainfop.h"
#include "csdisp.h"

#include "cspelog.h"
#include "exitlog.h"
#include "exit.h"

#include "cdosys_i.c"
#include <atlbase.h>
#include <atlimpl.cpp>

// begin_sdksample

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

#define myEXITEVENTS \
	EXITEVENT_CERTISSUED | \
	EXITEVENT_CERTPENDING | \
	EXITEVENT_CERTDENIED | \
	EXITEVENT_CERTREVOKED | \
	EXITEVENT_CERTRETRIEVEPENDING | \
	EXITEVENT_CRLISSUED | \
	EXITEVENT_SHUTDOWN

#define CERTTYPE_ATTR_NAME TEXT("CertificateTemplate")
#define MAX_CRL_PROP (32 + 10)

#define cbVALUEZEROPAD     (3 * sizeof(WCHAR))

extern HINSTANCE g_hInstance;


HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Exit:NULL pointer");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerExit,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerExit,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Exit:NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Exit: SetContext");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::~CCertExit -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertExit::~CCertExit()
{
    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
    }
    if (NULL != m_pwszRegStorageLoc)
    {
        LocalFree(m_pwszRegStorageLoc);
    }
    if (NULL != m_hExitKey)
    {
        RegCloseKey(m_hExitKey);
    }
    if (NULL != m_strDescription)
    {
        SysFreeString(m_strDescription);
    }

    VariantClear(&m_varFrom);
    VariantClear(&m_varCC);
    VariantClear(&m_varSubject);

    if(m_pICDOConfig)
    {
        m_pICDOConfig->Release();
    }
}


//+--------------------------------------------------------------------------
// CCertExit::Initialize -- initialize for a CA & return interesting Event Mask
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExit::Initialize(
    /* [in] */ BSTR const strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pEventMask)
{
    HRESULT hr = S_OK;
    HKEY        hkey = NULL;
    DWORD       cbbuf;
    DWORD       dwType;
    ENUM_CATYPES CAType;
    LPWSTR      pwszCLSIDCertExit = NULL;
    ICertServerExit* pServer = NULL;
    VARIANT varValue;
    WCHAR sz[MAX_PATH];

    VariantInit(&varValue);

#ifdef IDS_MODULE_NAME						// no_sdksample
    LoadString(g_hInstance, IDS_MODULE_NAME, sz, ARRAYSIZE(sz));// no_sdksample
#else								// no_sdksample
    CSASSERT(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);
#endif								// no_sdksample

    m_strDescription = SysAllocString(sz);
    if (NULL == m_strDescription)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

    m_strCAName = SysAllocString(strConfig);
    if (NULL == m_strCAName)
    {
    	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

    *pEventMask = myEXITEVENTS;
    DBGPRINT((DBG_SS_CERTEXIT, "Exit:Initialize(%ws) ==> %x\n", m_strCAName, *pEventMask));

    // get server callbacks

    hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "Exit:GetServerCallbackInterface");

    // get storage location

    hr = pServer->GetCertificateProperty(wszPROPMODULEREGLOC, PROPTYPE_STRING, &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPMODULEREGLOC);
    
    m_pwszRegStorageLoc = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(varValue.bstrVal)+1) *sizeof(WCHAR));
    if (NULL == m_pwszRegStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:LocalAlloc");
    }
    wcscpy(m_pwszRegStorageLoc, varValue.bstrVal);
    VariantClear(&varValue);

    // get CA type
    hr = pServer->GetCertificateProperty(wszPROPCATYPE, PROPTYPE_LONG, &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPCATYPE);

    CAType = (ENUM_CATYPES) varValue.lVal;
    VariantClear(&varValue);

    hr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                m_pwszRegStorageLoc,
                0,              // dwReserved
                KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                &m_hExitKey);

    if (S_OK != hr)
    {
        if ((HRESULT) ERROR_FILE_NOT_FOUND == hr)
        {
            hr = S_OK;
            goto error;
        }
        _JumpError(hr, error, "Exit:RegOpenKeyEx");
    }


    hr = pServer->GetCertificateProperty(wszPROPCERTCOUNT, PROPTYPE_LONG, &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPCERTCOUNT);

    m_cCACert = varValue.lVal;

    cbbuf = sizeof(m_dwExitPublishFlags);
    hr = RegQueryValueEx(
		    m_hExitKey,
		    wszREGCERTPUBLISHFLAGS,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) &m_dwExitPublishFlags,
		    &cbbuf);
    if (S_OK != hr)
    {
        m_dwExitPublishFlags = 0;
    }

    hr = _EMailInit();		// no_sdksample
    _JumpIfError(hr, error, "Exit:_EMailInit");

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    VariantClear(&varValue);
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(myHError(hr));
}


//+--------------------------------------------------------------------------
// CCertExit::_ExpandEnvironmentVariables -- Expand environment variables
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_ExpandEnvironmentVariables(
    IN WCHAR const *pwszIn,
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    WCHAR awcVar[MAX_PATH];
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;
    WCHAR *pwszDstEnd;
    WCHAR *pwszVar;
    DWORD cwc;

    pwszSrc = pwszIn;
    pwszDst = pwszOut;
    pwszDstEnd = &pwszOut[cwcOut];

    while (L'\0' != (*pwszDst = *pwszSrc++))
    {
	if ('%' == *pwszDst)
	{
	    *pwszDst = L'\0';
	    pwszVar = awcVar;

	    while (L'\0' != *pwszSrc)
	    {
		if ('%' == *pwszSrc)
		{
		    pwszSrc++;
		    break;
		}
		*pwszVar++ = *pwszSrc++;
		if (pwszVar >= &awcVar[sizeof(awcVar)/sizeof(awcVar[0]) - 1])
		{
		    _JumpError(hr, error, "Exit:overflow 1");
		}
	    }
	    *pwszVar = L'\0';
	    cwc = GetEnvironmentVariable(awcVar, pwszDst, SAFE_SUBTRACT_POINTERS(pwszDstEnd, pwszDst));
	    if (0 == cwc)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Exit:GetEnvironmentVariable");
	    }
	    if ((DWORD) (pwszDstEnd - pwszDst) <= cwc)
	    {
		_JumpError(hr, error, "Exit:overflow 2");
	    }
	    pwszDst += cwc;
	}
	else
	{
	    pwszDst++;
	}
	if (pwszDst >= pwszDstEnd)
	{
	    _JumpError(hr, error, "Exit:overflow 3");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::_WriteCertToFile -- write binary certificate to a file
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_WriteCertToFile(
    IN ICertServerExit *pServer,
    IN BYTE const *pbCert,
    IN DWORD cbCert)
{
    HRESULT hr;
    BSTR strCertFile = NULL;
    DWORD cbWritten;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR wszPath[MAX_PATH];
    WCHAR const *pwszFile;
    WCHAR const *pwsz;


    hr = pServer->GetRequestAttribute(wszPROPEXITCERTFILE, &strCertFile);
    if (S_OK != hr)
    {
	DBGPRINT((
	    DBG_SS_CERTEXIT,
	    "Exit:GetRequestAttribute(%ws): %x%hs\n",
	    wszPROPEXITCERTFILE,
	    hr,
	    CERTSRV_E_PROPERTY_EMPTY == hr? " EMPTY VALUE" : ""));
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    pwszFile = wcsrchr(strCertFile, L'\\');
    if (NULL == pwszFile)
    {
	pwszFile = strCertFile;
    }
    else
    {
	pwszFile++;
    }
    pwsz = wcsrchr(pwszFile, L'/');
    if (NULL != pwsz)
    {
	pwszFile = &pwsz[1];
    }

    hr = _ExpandEnvironmentVariables(
		    L"%SystemRoot%\\System32\\" wszCERTENROLLSHAREPATH L"\\",
		    wszPath,
		    ARRAYSIZE(wszPath));
    _JumpIfError(hr, error, "_ExpandEnvironmentVariables");

    if (ARRAYSIZE(wszPath) <= wcslen(wszPath) + wcslen(pwszFile))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "Exit:Path too long");
    }
    wcscat(wszPath, pwszFile);

    // open file & write binary cert out.

    hFile = CreateFile(
		    wszPath,
		    GENERIC_WRITE,
		    0,			// dwShareMode
		    NULL,		// lpSecurityAttributes
		    CREATE_NEW,
		    FILE_ATTRIBUTE_NORMAL,
		    NULL);		// hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "Exit:CreateFile", wszPath);
    }
    if (!WriteFile(hFile, pbCert, cbCert, &cbWritten, NULL))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "Exit:WriteFile", wszPath);
    }
    if (cbWritten != cbCert)
    {
	hr = STG_E_WRITEFAULT;
	DBGPRINT((
	    DBG_SS_CERTEXIT,
	    "Exit:WriteFile(%ws): attempted %x, actual %x bytes: %x\n",
	    wszPath,
	    cbCert,
	    cbWritten,
	    hr));
	goto error;
    }

error:
    // end_sdksample

    if (hr != S_OK)
    {
        LPCWSTR wszStrings[1];

        wszStrings[0] = wszPath;

        ::LogModuleStatus(
		    g_hInstance,
		    MSG_UNABLE_TO_WRITEFILE,
		    FALSE,
		    m_strDescription,
		    wszStrings);
    }

    // begin_sdksample

    if (INVALID_HANDLE_VALUE != hFile)
    {
	CloseHandle(hFile);
    }
    if (NULL != strCertFile)
    {
	SysFreeString(strCertFile);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::_NotifyNewCert -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_NotifyNewCert(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    HRESULT hr2;
    VARIANT varCert;
    VARIANT varCertType;
    ICertServerExit *pServer = NULL;
    BSTR strCertType;

    VariantInit(&varCert);
    VariantInit(&varCertType);
    hr = CoCreateInstance(
		    CLSID_CCertServerExit,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertServerExit,
		    (VOID **) &pServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    hr = pServer->SetContext(Context);
    _JumpIfError(hr, error, "Exit:SetContext");

    hr = pServer->GetCertificateProperty(
			       wszPROPRAWCERTIFICATE,
			       PROPTYPE_BINARY,
			       &varCert);
    _JumpIfErrorStr(
		hr,
		error,
		"Exit:GetCertificateProperty",
		wszPROPRAWCERTIFICATE);

    if (VT_BSTR != varCert.vt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Exit:BAD cert var type");
    }

    strCertType = NULL;
    hr = pServer->GetCertificateProperty(
			       wszPROPCERTIFICATETEMPLATE,
			       PROPTYPE_STRING,
			       &varCertType);
    if (S_OK == hr && VT_BSTR == varCertType.vt)
    {
	strCertType = varCertType.bstrVal;
	DBGPRINT((DBG_SS_CERTEXIT, "Exit:CertType = %ws\n", strCertType));
    }
    hr = S_OK;

    // only call write fxns if server policy allows

    if (m_dwExitPublishFlags & EXITPUB_FILE)
    {
	hr2 = _WriteCertToFile(
			pServer,
			(BYTE const *) varCert.bstrVal,
			SysStringByteLen(varCert.bstrVal));
	_PrintIfError(hr2, "_WriteCertToFile");
	hr = hr2;
    }

    // end_sdksample

    if (m_fEMailNotify)
    {
        hr2 = _EMailNotify(pServer, strCertType);
        _PrintIfError(hr2, "_EMailNotify");

        if (S_OK == hr)
        {
            hr = hr2;
        }
    }

    // begin_sdksample

error:
    VariantClear(&varCert);
    VariantClear(&varCertType);
    if (NULL != pServer)
    {
	pServer->Release();
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertExit::_NotifyCRLIssued -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExit::_NotifyCRLIssued(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    ICertServerExit *pServer = NULL;
    DWORD i;
    VARIANT varBaseCRL;
    VARIANT varDeltaCRL;
    DWORD cbbuf;
    DWORD dwType;

    VariantInit(&varBaseCRL);
    VariantInit(&varDeltaCRL);

    hr = CoCreateInstance(
		    CLSID_CCertServerExit,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertServerExit,
		    (VOID **) &pServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    hr = pServer->SetContext(Context);
    _JumpIfError(hr, error, "Exit:SetContext");


    // How many CRLs are there?

    // Loop for each CRL
    for (i = 0; i < m_cCACert; i++)
    {
        WCHAR wszCRLPROP[MAX_CRL_PROP];

        // Verify the CRL State says we should update this CRL

        wsprintf(wszCRLPROP, wszPROPCRLSTATE L".%u", i);
        hr = pServer->GetCertificateProperty(
			           wszCRLPROP,
			           PROPTYPE_LONG,
			           &varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszCRLPROP);

	if (CA_DISP_VALID != varBaseCRL.lVal)
	{
	    continue;
	}

        // Grab the raw base CRL

        wsprintf(wszCRLPROP, wszPROPRAWCRL L".%u", i);
        hr = pServer->GetCertificateProperty(
			           wszCRLPROP,
			           PROPTYPE_BINARY,
			           &varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszCRLPROP);

        // Grab the raw delta CRL (which may not exist)

        wsprintf(wszCRLPROP, wszPROPRAWDELTACRL L".%u", i);
        hr = pServer->GetCertificateProperty(
			           wszCRLPROP,
			           PROPTYPE_BINARY,
			           &varDeltaCRL);
        _PrintIfErrorStr(hr, "Exit:GetCertificateProperty", wszCRLPROP);

        // Publish the CRL(s) ...
    }

error:
    if (NULL != pServer)
    {
	pServer->Release();
    }
    VariantClear(&varBaseCRL);
    VariantClear(&varDeltaCRL);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::Notify -- Notify the exit module of an event
//
// Returns S_OK.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExit::Notify(
    /* [in] */ LONG ExitEvent,
    /* [in] */ LONG Context)
{
    char *psz = "UNKNOWN EVENT";
    HRESULT hr = S_OK;

    switch (ExitEvent)
    {
	case EXITEVENT_CERTISSUED:
	    hr = _NotifyNewCert(Context);
	    psz = "certissued";
	    break;

	case EXITEVENT_CERTPENDING:
	    psz = "certpending";
	    break;

	case EXITEVENT_CERTDENIED:
	    psz = "certdenied";
	    break;

	case EXITEVENT_CERTREVOKED:
	    psz = "certrevoked";
	    break;

	case EXITEVENT_CERTRETRIEVEPENDING:
	    psz = "retrievepending";
	    break;

	case EXITEVENT_CRLISSUED:
	    hr = _NotifyCRLIssued(Context);
	    psz = "crlissued";
	    break;

	case EXITEVENT_SHUTDOWN:
	    psz = "shutdown";
	    break;
    }

    DBGPRINT((
	DBG_SS_CERTEXIT,
	"Exit:Notify(%hs=%x, ctx=%x) rc=%x\n",
	psz,
	ExitEvent,
	Context,
	hr));
    return(hr);
}


STDMETHODIMP
CCertExit::GetDescription(
    /* [retval][out] */ BSTR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

#ifdef IDS_MODULE_NAME						// no_sdksample
    LoadString(g_hInstance, IDS_MODULE_NAME, sz, ARRAYSIZE(sz));// no_sdksample
#else								// no_sdksample
    CSASSERT(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);
#endif								// no_sdksample

    *pstrDescription = SysAllocString(sz);
    if (NULL == *pstrDescription)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExit::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExit::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
		    CLSID_CCertManageExitModule,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
		    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CCertExit::InterfaceSupportsErrorInfo(REFIID riid)
{
    int i;
    static const IID *arr[] =
    {
	&IID_ICertExit,
    };

    for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (IsEqualGUID(*arr[i],riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}

// end_sdksample


HRESULT
LoadAnsiResourceString(
    IN LONG idmsg,
    OUT char **ppszString)
{
    HRESULT hr;
    WCHAR awc[4096];

    if (!LoadString(g_hInstance, idmsg, awc, ARRAYSIZE(awc)))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Exit:LoadString");
    }
    if (!ConvertWszToSz(ppszString, awc, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:ConvertWszToSz");
    }
    hr = S_OK;

error:
    return(hr);
}

HRESULT CCertExit::_RegGetValue(
    HKEY hkey,
    LPCWSTR pcwszValName,
    VARIANT* pvarValue)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cbVal;
    BYTE* pbVal = NULL;

    hr = RegQueryValueEx(hkey, pcwszValName, NULL, &dwType, NULL, &cbVal);
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpErrorStr(hr, error, "RegQueryValueEx", pcwszValName);
    }

    pbVal = (BYTE*) LocalAlloc(LMEM_FIXED, cbVal);
    _JumpIfAllocFailed(pbVal, error);

    hr = RegQueryValueEx(hkey, pcwszValName, NULL, &dwType, pbVal, &cbVal);
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpErrorStr(hr, error, "RegQueryValueEx", pcwszValName);
    }

    hr = myRegValueToVariant(
        dwType,
        cbVal,
        pbVal,
        pvarValue);
    _JumpIfError(hr, error, "myRegValueToVariant");

error:
    if(pbVal)
    {
        LocalFree(pbVal);
    }
    return hr;
}

/*HRESULT CCertExit::_LoadBodyFieldsFromRegistry(HKEY hkeySMTP)
{
    HRESULT hr;
    HKEY hkeyBodyFields = NULL;
    DWORD cValues;
    DWORD cbValue;
    DWORD dwValCount;
    DWORD dwType;

    // Enumerate all Body fields under SMTP\BodyFields key. Value names
    // are ordered and named 1, 2, 3 and so on. All values should be strings only
    hr = RegOpenKeyEx(
            hkeySMTP, 
            wszREGEXITSMTPBODYFIELDSKEY, 
            0,
            KEY_QUERY_VALUE|KEY_READ,
            &hkeyBodyFields);
    if(S_OK != hr)
    {
        hr = myHError(hr);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszREGEXITSMTPKEY);
    }

    hr = RegQueryInfoKey(
        hkeyBodyFields,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        &cValues,
        NULL,
        &cbValue,
        NULL,
        NULL);
    _JumpIfErrorStr(hr, error, "RegQueryInfoKey", wszREGEXITSMTPKEY);

    m_pawszBodyFields = (LPWSTR*)LocalAlloc(LMEM_FIXED, sizeof(LPWSTR)*cValues);
    _JumpIfAllocFailed(m_pawszBodyFields, error);

    ZeroMemory(m_pawszBodyFields, sizeof(LPWSTR)*cValues);

    for(dwValCount; dwValCount<cValues; dwValCount++)
    {
        DWORD cbValueTemp = cbValue;
        WCHAR wszValName[20];
        wsprintf(wszVal, L"%d", dwValCount);

        m_pawszBodyFields[dwValCount] = (LPWSTR)LocalAlloc(LMEM_FIXED, cbValueTemp);
        _JumpIfAllocFailed(m_pawszBodyFields[dwValCount] , error);

        hr = RegQueryValueEx(
            hkeyBodyFields, 
            wszValName, 
            NULL, 
            &dwType,
            m_pawszBodyFields[dwValCount],
            &cbValueTemp);
        if (hr != S_OK)
        {
            hr = myHError(hr);
            _JumpError(hr, error, "RegEnumValue");
        }
        if(dwType != REG_SZ)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
            _JumpError(hr, error, "nonstring value type");
        }
    }

error:
    if(hkeyBodyFields)
    {
        RegCloseKey(hkeyBodyFields);
    }
    return hr;
}*/

HRESULT CCertExit::_LoadFieldsFromRegistry(Fields* pFields)
{
    HRESULT hr;
    DWORD dwType;
    BYTE* pbValue = NULL;
    DWORD cbValue;
    VARIANT varValue;
    DWORD dwIndex;
    HKEY hkeySMTP = NULL;
    LPWSTR  pwszValName = NULL;
    DWORD cbValName;
    DWORD cValues;
    static LPCWSTR pcwszHTTP = L"http://";
    static size_t cHTTP = wcslen(pcwszHTTP);

    VariantInit(&varValue);

    // enumerate all CDO fields under SMTP key (value name is full HTTP URL)
    hr = RegOpenKeyEx(
            m_hExitKey, 
            wszREGEXITSMTPKEY, 
            0,
            KEY_QUERY_VALUE|KEY_READ,
            &hkeySMTP);
    if(S_OK != hr)
    {
        hr = myHError(hr);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszREGEXITSMTPKEY);
    }

    hr = RegQueryInfoKey(
        hkeySMTP,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        &cValues,
        &cbValName,
        &cbValue,
        NULL,
        NULL);
    _JumpIfErrorStr(hr, error, "RegQueryInfoKey", wszREGEXITSMTPKEY);

    pwszValName = (LPWSTR) LocalAlloc(LMEM_FIXED, ++cbValName*sizeof(WCHAR));
    _JumpIfAllocFailed(pwszValName, error);

    pbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cbValue);
    _JumpIfAllocFailed(pbValue, error);

    for(dwIndex=0;dwIndex<cValues;dwIndex++)
    {
        DWORD cbValueTemp = cbValue;
        DWORD cbValNameTemp = cbValName;

        hr = RegEnumValue(
            hkeySMTP, 
            dwIndex, 
            pwszValName, 
            &cbValNameTemp,
            NULL, 
            &dwType,
            pbValue, 
            &cbValueTemp);
        if (hr != S_OK)
        {
            hr = myHError(hr);
            _JumpError(hr, error, "RegEnumValue");
        }

        // ignore if not an HTTP URL
        if(_wcsnicmp(pwszValName, pcwszHTTP, cHTTP))
        {
            continue;
        }

        hr = myRegValueToVariant(
            dwType,
            cbValueTemp,
            pbValue,
            &varValue);
        _JumpIfError(hr, error, "myRegValueToVariant");

        hr = _SetField(
            pFields,
            pwszValName,
            &varValue);
        _JumpIfError(hr, error, "_SetField");

        VariantClear(&varValue);
    }

/*    hr = _LoadBodyFieldsFromRegistry(hkeySMTP)
    _JumpIfError(hr, error, "_LoadBodyFieldsFromRegistry");

    // retrieve Body field - mandatory
    hr = _RegGetValue(
        hkeySMTP,
        wszREGEXITSMTPBODY,
        &m_varBody);
    _JumpIfErrorStr(hr, error, "_RegGetValue", wszREGEXITSMTPBODY);

    if(V_VT(&m_varBody) != VT_BSTR)
    {
        VariantClear(&m_varBody);
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpErrorStr(hr, error, "invalid From field", wszREGEXITSMTPBODY);
    }*/

    // retrieve From field - optional; if not present, From field will
    // be built: ca_name@machine_dns_name
    hr = _RegGetValue(
        hkeySMTP,
        wszREGEXITSMTPFROM,
        &m_varFrom);
    if(S_OK==hr &&
       V_VT(&m_varCC) != VT_BSTR)
    {
        VariantClear(&m_varCC);
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpErrorStr(hr, error, "invalid CC field", wszREGEXITSMTPCC);
    }

    // retrieve CC field - optional
    hr = _RegGetValue(
        hkeySMTP,
        wszREGEXITSMTPCC,
        &m_varCC);
    if(S_OK==hr &&
       V_VT(&m_varCC) != VT_BSTR)
    {
        VariantClear(&m_varCC);
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpErrorStr(hr, error, "invalid CC field", wszREGEXITSMTPCC);
    }

    // retrieve Subject field - optional
    hr = _RegGetValue(
        hkeySMTP,
        wszREGEXITSMTPSUBJECT,
        &m_varSubject);
    if(S_OK==hr &&
       V_VT(&m_varCC) != VT_BSTR)
    {
        VariantClear(&m_varCC);
        hr = HRESULT_FROM_WIN32(ERROR_BADKEY);
        _JumpErrorStr(hr, error, "invalid CC field", wszREGEXITSMTPCC);
    }


    hr = S_OK;

error:

    if(hkeySMTP)
    {
        RegCloseKey(hkeySMTP);
    }

    VariantClear(&varValue);

    if(pwszValName)
    {
        LocalFree(pwszValName);
    }

    if(pbValue)
    {
        LocalFree(pbValue);
    }
    return hr;
}

HRESULT CCertExit::_SetField(
    Fields* pFields,
    LPCWSTR pcwszFieldSchemaName,
    VARIANT *pvarFieldValue)
{
    HRESULT hr;
    Field*  pfld = NULL;

    hr = pFields->get_Item(CComVariant(pcwszFieldSchemaName),&pfld);
    _JumpIfErrorStr(hr, error, "CDO::Field::get_Item", pcwszFieldSchemaName);

    hr = pfld->put_Value(*pvarFieldValue);
    _JumpIfErrorStr(hr, error, "CDO::Field::put_Value", pcwszFieldSchemaName);

error:
    if(pfld)
    {
        pfld->Release();
    }
    return hr;
}

HRESULT CCertExit::_LoadFieldsFromLSASecret(
    Fields* pFields)
{
    HRESULT hr;
    VARIANT var; // don't clear
    LPWSTR pwszProfileName = NULL;
    LPWSTR pwszLogonName = NULL;
    LPWSTR pwszPassword = NULL;
    BSTR bstrLogonName = NULL;
    BSTR bstrPassword = NULL;

	hr = myGetMapiInfo(
			NULL,
			&pwszProfileName, // not used
			&pwszLogonName,
			&pwszPassword);
    if(S_OK == hr)  // if NTLM is used, username & password aren't needed
    {
        bstrLogonName = SysAllocString(pwszLogonName);
        _JumpIfAllocFailed(bstrLogonName, error);

        bstrPassword = SysAllocString(pwszPassword);
        _JumpIfAllocFailed(bstrPassword, error);

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = bstrLogonName;

        hr = _SetField(
            pFields,
            cdoSendUserName,
            &var);
        _JumpIfError(hr, error, "_SetField");

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = bstrPassword;

        hr = _SetField(
            pFields,
            cdoSendPassword,
            &var);
        _JumpIfError(hr, error, "_SetField");
    }

error:
    if (NULL != pwszProfileName)
    {
        LocalFree(pwszProfileName);
    }
    if (NULL != pwszLogonName)
    {
        LocalFree(pwszLogonName);
    }
    if (NULL != pwszPassword)
    {
        DWORD cwc = wcslen(pwszPassword);
        ZeroMemory(pwszPassword, cwc * sizeof(WCHAR));
        LocalFree(pwszPassword);
    }
    if(NULL != bstrLogonName)
    {
        SysFreeString(bstrLogonName);
    }
    if(NULL != bstrPassword)
    {
        DWORD cwc = wcslen(bstrPassword);
        ZeroMemory(bstrPassword, cwc * sizeof(WCHAR));
        SysFreeString(bstrPassword);
    }
    return hr;
}

HRESULT CCertExit::_BuildCAMailAddressAndSubject()
{
    HRESULT hr;
    LPWSTR pwszMachineDNSName = NULL;
    LPWSTR pwszMailAddr = NULL;
    // If not specified in the registry, build SMTP "From" field:
    //
    // CA_name@machine_dns_name
    //
    if(V_VT(&m_varFrom)==VT_EMPTY ||
       V_VT(&m_varSubject)==VT_EMPTY)
    {
        hr = myGetMachineDnsName(&pwszMachineDNSName);
        _JumpIfError(hr, error, "myGetMachineDnsName");
        
        pwszMailAddr = (LPWSTR)LocalAlloc(
            LMEM_FIXED,
            sizeof(WCHAR)*(wcslen(m_strCAName)+wcslen(pwszMachineDNSName)+4));
        _JumpIfAllocFailed(pwszMailAddr, error);

        wcscpy(pwszMailAddr, m_strCAName);
        wcscat(pwszMailAddr, L"@");
        wcscat(pwszMailAddr, pwszMachineDNSName);
    }

    if(V_VT(&m_varFrom)==VT_EMPTY)
    {
        V_BSTR(&m_varFrom) = SysAllocString(pwszMailAddr);
        _JumpIfAllocFailed(V_BSTR(&m_varFrom), error);

        V_VT(&m_varFrom) = VT_BSTR;
    }

    if(V_VT(&m_varSubject)==VT_EMPTY)
    {
        V_BSTR(&m_varSubject) = SysAllocString(pwszMailAddr);
        _JumpIfAllocFailed(V_BSTR(&m_varSubject), error);

        V_VT(&m_varSubject) = VT_BSTR;
    }

error:
    if(pwszMachineDNSName)
    {
        LocalFree(pwszMachineDNSName);
    }
    if(pwszMailAddr)
    {
        LocalFree(pwszMailAddr);
    }
    return hr;
}

HRESULT
CCertExit::_EMailInit()
{
    HRESULT hr = S_OK;
    Fields* pFields = NULL;

    if ((EXITPUB_EMAILNOTIFYSMARTCARD | 
         EXITPUB_EMAILNOTIFYALL) &
        m_dwExitPublishFlags)
    {
        m_fEMailNotify = TRUE;
    }

    if (m_fEMailNotify)
    {
        hr = CoCreateInstance(CDO::CLSID_Configuration,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   CDO::IID_IConfiguration,
                                   reinterpret_cast<void**>(&m_pICDOConfig));
        _JumpIfError(hr, error, "CoCreateInstance CDO_IConfiguration");

        hr = m_pICDOConfig->get_Fields(&pFields);
        _JumpIfError(hr, error, "CDO::IConfig::get_Fields");

        hr = _LoadFieldsFromRegistry(pFields);
        _JumpIfError(hr, error, "_LoadFieldsFromRegistry");

        hr = _LoadFieldsFromLSASecret(pFields);
        _JumpIfError(hr, error, "_LoadFieldsFromLSASecret");

        hr = _BuildCAMailAddressAndSubject();
        _JumpIfError(hr, error, "_BuildFromField");

        hr = pFields->Update();
        _JumpIfError(hr, error, "config");
    }

error:

    if (S_OK != hr)
    {
        m_fEMailNotify = FALSE;
        if(m_pICDOConfig)
        {
            m_pICDOConfig->Release();
            m_pICDOConfig = NULL;
        }
    }

    if(pFields)
    {
        pFields->Release();
    }

    return(hr);
}

HRESULT
GetCertTypeFriendlyName(
    IN WCHAR const *pwszCertType,
    OUT BSTR *pstrFriendlyName)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    WCHAR **apwszNames = NULL;

    CSASSERT(NULL == *pstrFriendlyName);

    hr = CAFindCertTypeByName(
			pwszCertType,
			NULL,		// hCAInfo
            CT_FIND_LOCAL_SYSTEM |
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES,		// dwFlags
			&hCertType);
    _JumpIfErrorStr(hr, error, "Exit:CAFindCertTypeByName", pwszCertType);

    hr = CAGetCertTypeProperty(
			hCertType,
			CERTTYPE_PROP_FRIENDLY_NAME,
			&apwszNames);
    _JumpIfError(hr, error, "Exit:CAGetCertTypeProperty");

    if (NULL == apwszNames[0])
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "Exit:NULL friendly name");
    }
    *pstrFriendlyName = SysAllocString(apwszNames[0]);
    if (NULL == *pstrFriendlyName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }

error:
    if (NULL != apwszNames)
    {
        CAFreeCertTypeProperty(hCertType, apwszNames);
    }
    if (NULL != hCertType)
    {
	CACloseCertType(hCertType);
    }
    return(hr);
}


HRESULT
GetStringProperty(
    IN ICertServerExit *pServer,
    IN BOOL fRequest,
    IN BOOL fAllowUnknown,
    OPTIONAL IN WCHAR *pwszProp,
    OUT BSTR *pstr)
{
    HRESULT hr;
    VARIANT var;
    WCHAR awc[64];

    VariantInit(&var);
    CSASSERT(NULL == *pstr);
    
    if (NULL == pwszProp)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
    }
    else
    {
	if (fRequest)
	{
	    hr = pServer->GetRequestProperty(pwszProp, PROPTYPE_STRING, &var);
	}
	else
	{
	    hr = pServer->GetCertificateProperty(
					    pwszProp,
					    PROPTYPE_STRING,
					    &var);
	}
    }
    if (!fAllowUnknown || CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfErrorStr(
		hr,
		error,
		fRequest? "Exit:GetRequestProperty" : "Exit:GetCertificateProperty",
		pwszProp);
	if (VT_BSTR != var.vt)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "Exit:BAD var type", pwszProp);
	}
	*pstr = var.bstrVal;
	var.vt = VT_EMPTY;
    }
    else
    {
	if (!LoadString(g_hInstance, IDS_MAPI_UNKNOWN, awc, ARRAYSIZE(awc)))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Exit:LoadString");
	}
	*pstr = SysAllocString(awc);
	if (NULL == *pstr)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Exit:SysAllocString");
	}
    }
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
CCertExit::_EMailNotify(
    IN ICertServerExit *pServer,
    OPTIONAL IN BSTR strCertType)
{
    HRESULT hr;
    WCHAR *apwsz[6];
    WCHAR *pwszMessage = NULL;
    BSTR strEMail = NULL;
    BSTR strRequester = NULL;
    BSTR strDN = NULL;
    BSTR strSerialNumber = NULL;
    BSTR strCertTypeFriendlyName = NULL;
    IMessage* pMsg = NULL;

    hr = GetStringProperty(
            pServer, 
            FALSE, 
            FALSE, 
            wszPROPEMAIL, 
            &strEMail);
    _PrintIfErrorStr(hr, "Exit:GetStringProperty", wszPROPEMAIL);

    hr = GetStringProperty(
			pServer,
			TRUE,
			TRUE,
			wszPROPREQUESTERNAME,
			&strRequester);
    _JumpIfError(hr, error, "Exit:GetStringProperty");

    hr = GetStringProperty(
			pServer,
			FALSE,
			TRUE,
			wszPROPDISTINGUISHEDNAME,
			&strDN);
    _JumpIfError(hr, error, "Exit:GetStringProperty");

    hr = GetStringProperty(
			pServer,
			FALSE,
			TRUE,
			wszPROPCERTIFICATESERIALNUMBER,
			&strSerialNumber);
    _JumpIfError(hr, error, "Exit:GetStringProperty");

    if (NULL == strCertType)
    {
	// "Unknown"

        hr = GetStringProperty(
			        pServer,
			        FALSE,
			        TRUE,
			        NULL,
			        &strCertTypeFriendlyName);
        _JumpIfError(hr, error, "Exit:GetStringProperty");
    }
    else
    {
        hr = GetCertTypeFriendlyName(strCertType, &strCertTypeFriendlyName);
        _PrintIfErrorStr(hr, "Exit:GetCertTypeFriendlyName", strCertType);
    }

    // %1 is used for a newline!
    // A new certificate requested by %2 was issued for\n%3\n
    // Certificate Type: %4\n
    // Serial Number: %5\n
    // Certification Authority: %6 on Server %7\n

    apwsz[0] = L"\n";
    apwsz[1] = strRequester;
    apwsz[2] = strDN;
    apwsz[3] = NULL != strCertTypeFriendlyName?
        strCertTypeFriendlyName : strCertType;
    apwsz[4] = strSerialNumber;
    apwsz[5] = m_strCAName;
    CSASSERT(6 <= ARRAYSIZE(apwsz));

    if (0 == FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_HMODULE |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            g_hInstance,                                // lpSource
            MSG_ENROLLMENT_NOTIFICATION,                // dwMessageId
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),  // dwLanguageId
            (WCHAR *) &pwszMessage,                     // lpBuffer
            0,                                          // nSize
            (va_list *) apwsz))                         // Arguments
    {
        hr = myHLastError();
        _JumpError(hr, error, "Exit:FormatMessage");
    }

    hr = CoCreateInstance(CDO::CLSID_Message,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               CDO::IID_IMessage,
                               reinterpret_cast<void**>(&pMsg));
    _JumpIfError(hr, error, "CoCreateInstance CDO_IConfiguration");
    
    hr = pMsg->putref_Configuration(m_pICDOConfig);
    _JumpIfError(hr, error, "putref_Configuration");

    // compose and send message

    hr = pMsg->put_To(strEMail);
    _JumpIfError(hr, error, "put_To");

    hr = pMsg->put_From(V_BSTR(&m_varFrom));
    _JumpIfError(hr, error, "put_From");

    hr = pMsg->put_TextBody(pwszMessage);
    _JumpIfError(hr, error, "put_Body");

    // optional, could be empty
    if(VT_BSTR==V_VT(&m_varCC))
    {
        hr = pMsg->put_CC(V_BSTR(&m_varCC));
        _JumpIfError(hr, error, "put_CC");
    }

    // optional, could be empty
    if(VT_BSTR==V_VT(&m_varSubject))
    {
        hr = pMsg->put_Subject(V_BSTR(&m_varSubject));
        _JumpIfError(hr, error, "put_Subject");
    }

    hr = pMsg->Send();
    _JumpIfError(hr, error, "Send");

error:
    if (NULL != pwszMessage)
    {
	LocalFree(pwszMessage);
    }
    if (NULL != strEMail)
    {
	SysFreeString(strEMail);
    }
    if (NULL != strRequester)
    {
	SysFreeString(strRequester);
    }
    if (NULL != strDN)
    {
	SysFreeString(strDN);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    if (NULL != strCertTypeFriendlyName)
    {
	SysFreeString(strCertTypeFriendlyName);
    }
    if(pMsg)
    {
        pMsg->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\exit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExit definition
//
//---------------------------------------------------------------------------

#include <certca.h>
//#include <mapi.h>
//#include <mapix.h>
#include "resource.h"       // main symbols
#include "certxds.h"
#include <winldap.h>
#include <cdosys.h>
//#include <cdosysstr.h>

typedef struct _MAPIINFO
{
    HMODULE        hMod;
    HANDLE	   hLogonToken;
    HANDLE	   hLogonProfile;
    void     *pfnMAPILogon;
    void  *pfnMAPISendMail;
    void    *pfnMAPILogOff;
    HANDLE        lhSession;
    char	  *pszMapiSubject;
    WCHAR         *pwszDnsName;
} MAPIINFO;


// begin_sdksample

HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context);

using namespace CDO;


/////////////////////////////////////////////////////////////////////////////
// certexit

class CCertExit: 
    public CComDualImpl<ICertExit2, &IID_ICertExit2, &LIBID_CERTEXITLib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertExit, &CLSID_CCertExit>
{
public:
    CCertExit() 
    { 
        m_strDescription = NULL;
        m_strCAName = NULL;
        m_pwszRegStorageLoc = NULL;
        m_hExitKey = NULL;
        m_dwExitPublishFlags = 0;
        m_cCACert = 0;

	m_fEMailNotify = FALSE;			// no_sdksample

    m_pICDOConfig = NULL;

    VariantInit(&m_varFrom);
    VariantInit(&m_varCC);
    VariantInit(&m_varSubject);
    }
    ~CCertExit();

BEGIN_COM_MAP(CCertExit)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertExit)
    COM_INTERFACE_ENTRY(ICertExit2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertExit) 

DECLARE_REGISTRY(
    CCertExit,
    wszCLASS_CERTEXIT TEXT(".1"),
    wszCLASS_CERTEXIT,
    IDS_CERTEXIT_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertExit
public:
    STDMETHOD(Initialize)( 
            /* [in] */ BSTR const strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pEventMask);

    STDMETHOD(Notify)(
            /* [in] */ LONG ExitEvent,
            /* [in] */ LONG Context);

    STDMETHOD(GetDescription)( 
            /* [retval][out] */ BSTR *pstrDescription);

// ICertExit2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

private:
    HRESULT _NotifyNewCert(IN LONG Context);

    HRESULT _NotifyCRLIssued(IN LONG Context);

    HRESULT _WriteCertToFile(
	    IN ICertServerExit *pServer,
	    IN BYTE const *pbCert,
	    IN DWORD cbCert);

    HRESULT _ExpandEnvironmentVariables(
	    IN WCHAR const *pwszIn,
	    OUT WCHAR *pwszOut,
	    IN DWORD cwcOut);

    // end_sdksample

    HRESULT _EMailInit();

    HRESULT _EMailNotify(
	    IN ICertServerExit *pServer,
	    OPTIONAL IN BSTR strCertType);

    HRESULT _LoadFieldsFromRegistry(Fields* pFields);

    HRESULT CCertExit::_LoadFieldsFromLSASecret(Fields* pFields);

    HRESULT _BuildCAMailAddressAndSubject();

    HRESULT CCertExit::_SetField(
        Fields* pFields,
        LPCWSTR pcwszFieldSchemaName,
        VARIANT *pvarFieldValue);

    HRESULT _RegGetValue(
        HKEY hkey,
        LPCWSTR pcwszValName,
        VARIANT* pvarValue);

    // begin_sdksample

    // Member variables & private methods here:
    BSTR           m_strDescription;
    BSTR           m_strCAName;
    LPWSTR         m_pwszRegStorageLoc;
    HKEY           m_hExitKey;
    DWORD          m_dwExitPublishFlags;
    DWORD          m_cCACert;
    BOOL           m_fEMailNotify;	// no_sdksample
    IConfiguration *m_pICDOConfig;
    VARIANT        m_varFrom;
    VARIANT        m_varCC;
    VARIANT        m_varSubject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include <commctrl.h>
#include "module.h"
#include "exit.h"
#include "cslistvw.h"

// helpids
#include "csmmchlp.h"

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

extern HINSTANCE g_hInstance;

STDMETHODIMP
CCertManageExitModule::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }

    if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_MODULE_NAME;
    else if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_DESCRIPTION))
        uiStr = IDS_MODULE_DESCR;
    else if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_COPYRIGHT))
        uiStr = IDS_MODULE_COPYRIGHT;
    else if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_FILEVER))
        uiStr = IDS_MODULE_FILEVER;
    else if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_PRODUCTVER))
        uiStr = IDS_MODULE_PRODUCTVER;
    else
        return S_FALSE;  

    // load string from resource
    WCHAR szStr[MAX_PATH];
    szStr[0] = L'\0';
    LoadString(g_hInstance, uiStr, szStr, ARRAYLEN(szStr));

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;
    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller


    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManageExitModule::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvalProperty)
{
    HRESULT hr;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    if (NULL == pvalProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }

     if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvalProperty->vt != VT_BSTR)
              return E_INVALIDARG;
         
         if (SysStringByteLen(pvalProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;

         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvalProperty->bstrVal;
         return S_OK;
     }
     
     return S_FALSE;
}

INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwnd,  
  UINT uMsg,     
  WPARAM  wParam,
  LPARAM  lParam);

struct EXIT_CONFIGSTRUCT
{
    EXIT_CONFIGSTRUCT() :
        pstrConfig(NULL),
        CAType(ENUM_UNKNOWN_CA),
        pCertAdmin(NULL),
        fUseDS(FALSE),
        Flags(),
        dwPageModified(0) {}
    ~EXIT_CONFIGSTRUCT()
    { 
        if(pCertAdmin)
        {
            pCertAdmin->Release();
            pCertAdmin = NULL;
        }
    }
    const BSTR*  pstrConfig;
    ENUM_CATYPES CAType;
    BOOL         fUseDS;
    ICertAdmin2  *pCertAdmin;
    LONG         Flags;

    DWORD        dwPageModified;
};
typedef EXIT_CONFIGSTRUCT *PEXIT_CONFIGSTRUCT;
        

void MessageBoxWarnReboot(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle));
    LoadString(g_hInstance, IDS_WARNING_REBOOT, szText, ARRAYLEN(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

void MessageBoxNoSave(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle));
    LoadString(g_hInstance, IDS_WARNING_NOSAVE, szText, ARRAYLEN(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

// dwPageModified
#define PAGE1 (0x1)
#define PAGE2 (0x2)
        
STDMETHODIMP
CCertManageExitModule::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags)
{
    HRESULT hr;
    EXIT_CONFIGSTRUCT sConfig;
    VARIANT varValue;
    VariantInit(&varValue);
    ICertServerExit *pServer = NULL;
    BOOL fLocal;
    LPWSTR szMachine = NULL;
    DWORD dwDisposition;

    hr = myIsConfigLocal(strConfig, &szMachine, &fLocal);
    _JumpIfError(hr, Ret, "myIsConfigLocal");

    // use callbacks for info
    hr = GetServerCallbackInterface(&pServer, 0);    // no context : 0
    _JumpIfError(hr, Ret, "GetServerCallbackInterface");

    // we need to find out who we're running under
    hr = pServer->GetCertificateProperty(wszPROPCATYPE, PROPTYPE_LONG, &varValue);
    _JumpIfError(hr, Ret, "GetCertificateProperty : wszPROPCATYPE");

    hr = GetAdmin(&sConfig.pCertAdmin);
    _JumpIfError(hr, Ret, "GetAdmin");

    sConfig.CAType = (ENUM_CATYPES)varValue.lVal;
    VariantClear(&varValue);

    hr = pServer->GetCertificateProperty(wszPROPUSEDS, PROPTYPE_LONG, &varValue);
    _JumpIfError(hr, Ret, "GetCertificateProperty : wszPROPUSEDS");

    sConfig.fUseDS = (BOOL)varValue.lVal;
    VariantClear(&varValue);

    sConfig.pstrConfig = &strConfig;
    sConfig.Flags = dwFlags;

    PROPSHEETPAGE page[1];
    ZeroMemory(&page[0], sizeof(PROPSHEETPAGE));
    page[0].dwSize = sizeof(PROPSHEETPAGE);
    page[0].dwFlags = PSP_DEFAULT;
    page[0].hInstance = g_hInstance;
    page[0].lParam = (LPARAM)&sConfig;
    page[0].pszTemplate = MAKEINTRESOURCE(IDD_EXITPG2);
    page[0].pfnDlgProc = WizPage2DlgProc;


    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.pszCaption = MAKEINTRESOURCE(IDS_MODULE_NAME);
    sSheet.nPages = ARRAYLEN(page);
    sSheet.ppsp = page;

    
    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

Ret:
    if (szMachine)
        LocalFree(szMachine);

    if (pServer)
        pServer->Release();

    return S_OK;
}


void mySetModified(HWND hwndPage, EXIT_CONFIGSTRUCT* psConfig)
{
    if (psConfig->dwPageModified != 0)
    {
        PropSheet_Changed( ::GetParent(hwndPage), hwndPage); 
    }
    else
    {
        PropSheet_UnChanged( ::GetParent(hwndPage), hwndPage); 
    }
}


INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam)
{
    EXIT_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (EXIT_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwPublish;
            CString strSubkey = wszREGKEYEXITMODULES 
                                L"\\" 
                                wszMICROSOFTCERTMODULE_PREFIX 
                                wszCERTEXITMODULE_POSTFIX;
            VARIANT var;
            VariantInit(&var);
            hr = psConfig->pCertAdmin->GetConfigEntry(
                    *psConfig->pstrConfig,
                    strSubkey.GetBuffer(),
                    wszREGCERTPUBLISHFLAGS,
                    &var);
            if(S_OK!=hr)
                break;

            dwPublish = V_I4(&var);

            // if disposition includes Issue
            if (dwPublish & EXITPUB_FILE)
            {
                SendMessage(GetDlgItem(hwndDlg, IDC_CHECK_FILE), BM_SETCHECK, TRUE, BST_CHECKED);
            }

            psConfig->dwPageModified &= ~PAGE2; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_EXITPG2);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_EXITPG2);
        break;
    }
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (EXIT_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (psConfig->dwPageModified & PAGE2)
                {
                    DWORD dwCheckState, dwRequestDisposition=0;
                    dwCheckState = (DWORD)SendMessage(GetDlgItem(hwndDlg, IDC_CHECK_FILE), BM_GETCHECK, 0, 0);
                    if (dwCheckState == BST_CHECKED)
                        dwRequestDisposition |= EXITPUB_FILE;

                    CString strSubkey = wszREGKEYEXITMODULES 
                                        L"\\" 
                                        wszMICROSOFTCERTMODULE_PREFIX 
                                        wszCERTEXITMODULE_POSTFIX;
                    VARIANT var;
                    VariantInit(&var);
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = dwRequestDisposition;

                    hr = psConfig->pCertAdmin->SetConfigEntry(
                            *psConfig->pstrConfig,
                            strSubkey.GetBuffer(),
                            wszREGCERTPUBLISHFLAGS,
                            &var);
                    if(S_OK!=hr)
                    {
                        MessageBoxNoSave(hwndDlg);
                        psConfig->dwPageModified &= ~PAGE2;
                    }
                    else
                    {
                        MessageBoxWarnReboot(NULL);
                    }
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (EXIT_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE2;
                mySetModified(hwndDlg, psConfig);
            }
            break;
        default:
            break;
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CHECK_FILE:
            {
                // grab our LParam
                psConfig = (EXIT_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (BN_CLICKED == HIWORD(wParam))
                {
                    psConfig->dwPageModified |= PAGE2;
                    mySetModified(hwndDlg, psConfig);
                }
            }
            break;
        default:
            break;
        }
    default:
        break;
    }

    return fReturn;
}

HRESULT CCertManageExitModule::GetAdmin(ICertAdmin2 **ppAdmin)
{
    HRESULT hr = S_OK, hr1;
    BOOL fCoInit = FALSE;

    hr1 = CoInitialize(NULL);
    if ((S_OK == hr1) || (S_FALSE == hr1))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin2,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManageExitModule definition
//
//---------------------------------------------------------------------------

#include "certxds.h"
#include "resource.h"       // main symbols


class CCertManageExitModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTEXITLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModule, &CLSID_CCertManageExitModule>
{
public:
    CCertManageExitModule() {m_hWnd = NULL;}
    ~CCertManageExitModule() {}

BEGIN_COM_MAP(CCertManageExitModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManageExitModule,
    wszCLASS_CERTMANAGEEXITMODULE TEXT(".1"),
    wszCLASS_CERTMANAGEEXITMODULE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

    HWND m_hWnd;

private:
    HRESULT GetAdmin(ICertAdmin2 **ppAdmin);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certweb\certrqtp.inc ===
<%' CODEPAGE=65001 'UTF-8%>
<%' certrqtp.inc - (CERT)srv web - (R)e(Q)uest, available (T)y(P)es
  ' Copyright (C) Microsoft Corporation, 1998 - 1999 %>
<%
	' NOTE: certdat.inc must be included first!
	Dim nAvailReqTypes 
	Dim rgAvailReqTypes(1,4)
	Dim sUserAgent
	Const FIELD_OID=0
	Const FIELD_TEMPLATE=0
	Const FIELD_FRIENDLYNAME=1
	Const FIELD_CSPLIST=2
	Const FIELD_CSPLIST2=3
	
	' Strings for localization
	Const L_WebBrowserCert_Text="Web Browser Certificate"
	Const L_EmailProtectionCert_Text="E-Mail Protection Certificate"
	Const L_UserTemplateCert_Text="User Certificate" 'Note: should match localized name of 'User' template and certrqma.asp's localized string L_TemplateCert_Text

	If "StandAlone"=sServerType Then
		'
		' Request types for stand alone
		'
		rgAvailReqTypes(0,FIELD_OID)="1.3.6.1.5.5.7.3.2"
		rgAvailReqTypes(0,FIELD_FRIENDLYNAME)=L_WebBrowserCert_Text
		rgAvailReqTypes(0,FIELD_CSPLIST)=""

		rgAvailReqTypes(1,FIELD_OID)="1.3.6.1.5.5.7.3.4"
		rgAvailReqTypes(1,FIELD_FRIENDLYNAME)=L_EmailProtectionCert_Text
		rgAvailReqTypes(1,FIELD_CSPLIST)=""

		nAvailReqTypes=2

	Else
		'
		' Request types for enterprise
		'
		rgAvailReqTypes(0,FIELD_TEMPLATE)="User"
		rgAvailReqTypes(0,FIELD_FRIENDLYNAME)=L_UserTemplateCert_Text
		rgAvailReqTypes(0,FIELD_CSPLIST)="Microsoft Enhanced Cryptographic Provider v1.0?Microsoft Base Cryptographic Provider v1.0"
		rgAvailReqTypes(0,FIELD_CSPLIST2)="Microsoft Base Cryptographic Provider v1.0?Microsoft Enhanced Cryptographic Provider v1.0"
		nAvailReqTypes=1

	End If
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certexit.rc
//
#define IDS_CERTEXIT_DESC               1
#define IDS_CERTMANAGEEXITMODULE_DESC   2
#define IDS_NO_CONFIGURABLE_DATA        3
#define IDS_MAPI_SUBJECT        	4
#define IDS_MAPI_UNKNOWN        	5

#define IDC_CHECK1                      201
#define IDC_CHECK_FILE                  201
#define IDC_BUTTON1                     202
#define IDC_REMOVE_CRL                  202
#define IDC_BUTTON2                     203
#define IDC_ADD_CRL                     203
#define IDC_EDIT1                       204
#define IDC_LIST1                       204
#define IDC_EDITURL                     204
#define IDD_EXITPG2                     609

#define IDS_MODULE_NAME                 611
#define IDS_MODULE_DESCR                612
#define IDS_MODULE_COPYRIGHT            613
#define IDS_MODULE_FILEVER              614
#define IDS_MODULE_PRODUCTVER           615
#define IDS_WARNING_REBOOT              616
#define IDS_INVALID_PREFIX              617
#define IDS_WARNING_NOSAVE              618
#define IDS_INVALID_TOKEN               619
#define IDS_INVALID_ENCODING            620


#define IDC_CRL_LIST                    737
#define IDB_CHECKLIST                   738
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\default\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"default"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include "tfc.h"
#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\exit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExitSQLSample implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "exit.h"
#include "module.h"


BOOL fDebug = DBG_CERTSRV;

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

#define ceEXITEVENTS \
	EXITEVENT_CERTISSUED | \
	EXITEVENT_CERTREVOKED

#define CERTTYPE_ATTR_NAME TEXT("CertificateTemplate")

extern HINSTANCE g_hInstance;


// worker
HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Exit:NULL pointer");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerExit,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerExit,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Exit:NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Exit: SetContext");
    }

error:
    return hr;
}


//+--------------------------------------------------------------------------
// CCertExitSQLSample::~CCertExitSQLSample -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertExitSQLSample::~CCertExitSQLSample()
{
	if (SQL_NULL_HDBC != m_hdbc1)
	{
		SQLDisconnect(m_hdbc1);
		SQLFreeHandle(SQL_HANDLE_DBC, m_hdbc1);
	}

    if (SQL_NULL_HENV != m_henv)
	    SQLFreeHandle(SQL_HANDLE_ENV, m_henv);

    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
    }
}


//+--------------------------------------------------------------------------
// CCertExitSQLSample::Initialize -- initialize for a CA & return interesting Event Mask
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSQLSample::Initialize(
    /* [in] */ BSTR const strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pEventMask)
{
    HRESULT hr = S_OK;
    DWORD       dwType;
    
	WCHAR rgchDsn[MAX_PATH];
	WCHAR rgchUser[MAX_PATH];
	WCHAR rgchPwd[MAX_PATH];
	DWORD cbTmp;
    ICertServerExit *pServer = NULL;

	SQLRETURN		retcode = SQL_SUCCESS;

	DWORD dwDisposition;
	HKEY hkeyStorageLocation = NULL;

	VARIANT varValue;
	VariantInit(&varValue);

    m_strCAName = SysAllocString(strConfig);
    if (NULL == m_strCAName)
    {
    	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

	hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

    hr = pServer->GetCertificateProperty(
			       wszPROPMODULEREGLOC,
			       PROPTYPE_STRING,
			       &varValue);
	_JumpIfError(hr, error, "GetCertificateProperty");

    hr = RegCreateKeyEx(
		    HKEY_LOCAL_MACHINE,
		    varValue.bstrVal,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_READ,
		    NULL,
		    &hkeyStorageLocation,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

	cbTmp = sizeof(rgchDsn)*sizeof(WCHAR);

    // dsn
    hr = RegQueryValueEx(
        hkeyStorageLocation,
        wszREG_EXITSQL_DSN,
        0,
        &dwType,
        (PBYTE)rgchDsn,
        &cbTmp);
	if (dwType != REG_SZ) 
		hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
	_JumpIfError(hr, error, "RegQueryValueEx DSN");

	cbTmp = sizeof(rgchUser)*sizeof(WCHAR);

	// username
    hr = RegQueryValueEx(
        hkeyStorageLocation,
        wszREG_EXITSQL_USER,
        0,
        &dwType,
        (PBYTE)rgchUser,
        &cbTmp);
	if (dwType != REG_SZ)
		hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
	_JumpIfError(hr, error, "RegQueryValueEx User");

	cbTmp = sizeof(rgchPwd)*sizeof(WCHAR);

	// password
    hr = RegQueryValueEx(
        hkeyStorageLocation,
        wszREG_EXITSQL_PASSWORD,
        0,
        &dwType,
        (PBYTE)rgchPwd,
        &cbTmp);
	if (dwType != REG_SZ)
		hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
	_JumpIfError(hr, error, "RegQueryValueEx Pwd");


    // Allocate the ODBC Environment and save handle.
    retcode = SQLAllocHandle (SQL_HANDLE_ENV, SQL_NULL_HANDLE, &m_henv);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLAllocHandle");

    // Let ODBC know this is an ODBC 3.0 application.
    retcode = SQLSetEnvAttr(m_henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLSetEnvAttr");

    // Allocate an ODBC connection and connect.
	retcode = SQLAllocHandle(SQL_HANDLE_DBC, m_henv, &m_hdbc1);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLAllocHandle");
	
    retcode = SQLConnect(m_hdbc1, rgchDsn, SQL_NTS, rgchUser, SQL_NTS, rgchPwd, SQL_NTS);
	if (!SQL_SUCCEEDED(retcode))
		_JumpError(retcode, error, "SQLConnect");



    *pEventMask = ceEXITEVENTS;
    DBGPRINT((fDebug, "Exit:Initialize(%ws) ==> %x\n", m_strCAName, *pEventMask));

    hr = S_OK;

error:
	if (pServer)
		pServer->Release();

	if (hkeyStorageLocation)
		RegCloseKey(hkeyStorageLocation);

	if (!SQL_SUCCEEDED(retcode))
        hr = ERROR_BAD_QUERY_SYNTAX;

    return(ceHError(hr));
}




//+--------------------------------------------------------------------------
// CCertExitSQLSample::_NotifyNewCert -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSQLSample::_NotifyNewCert(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    VARIANT varValue;
    ICertServerExit *pServer = NULL;
	SYSTEMTIME stBefore, stAfter;
	FILETIME ftBefore, ftAfter;

	// properties
	LONG lRequestID;
    BSTR bstrCertType = NULL;
	BSTR bstrRequester = NULL;
	DATE dateBefore;
	DATE dateAfter;

    VariantInit(&varValue);


	hr = GetServerCallbackInterface(&pServer, Context);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

	// ReqID
    hr = pServer->GetRequestProperty(
			       wszPROPREQUESTREQUESTID,
			       PROPTYPE_LONG,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

	if (VT_I4 != varValue.vt)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
	}
	lRequestID = varValue.lVal;
	VariantClear(&varValue);

	// Requester Name
    hr = pServer->GetRequestProperty(
			       wszPROPREQUESTERNAME,
			       PROPTYPE_STRING,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

    if (VT_BSTR != varValue.vt)
    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
    }
	bstrRequester = varValue.bstrVal;
	VariantInit(&varValue);	// don't init, bstrRequester nows owns memory

	// not before
    hr = pServer->GetCertificateProperty(
			       wszPROPCERTIFICATENOTBEFOREDATE,
			       PROPTYPE_DATE,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

    if (VT_DATE != varValue.vt)
    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
    }
	dateBefore = varValue.date;
	VariantClear(&varValue);	



	// not after
    hr = pServer->GetCertificateProperty(
			       wszPROPCERTIFICATENOTAFTERDATE,
			       PROPTYPE_DATE,
			       &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPREQUESTREQUESTID);

    if (VT_DATE != varValue.vt)
    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Exit:BAD cert var type");
    }
	dateAfter = varValue.date;
	VariantClear(&varValue);	




	// cert template name
	hr = pServer->GetRequestAttribute(CERTTYPE_ATTR_NAME, &bstrCertType);
	_PrintIfError2(hr, "Exit:GetRequestAttribute", hr);


	// now prettify
	hr = ceDateToFileTime(&dateBefore, &ftBefore);
	_JumpIfError(hr, error, "ceDateToFileTime");

	hr = ceDateToFileTime(&dateAfter, &ftAfter);
	_JumpIfError(hr, error, "ceDateToFileTime");


	hr = ExitModSetODBCProperty(
		lRequestID,
		m_strCAName,
		bstrRequester,
		bstrCertType,
		&ftBefore,
		&ftAfter);
	DBGPRINT((fDebug, "ESQL: Logged request %d to SQL database\n", lRequestID));

error:
    if (NULL != bstrCertType)
	{
		SysFreeString(bstrCertType);
	}

	if (NULL != bstrRequester)
	{
		SysFreeString(bstrCertType);
	}

    VariantClear(&varValue);
    if (NULL != pServer)
    {
	pServer->Release();
    }
    return(hr);
}



//+--------------------------------------------------------------------------
// CCertExitSQLSample::Notify -- Notify the exit module of an event
//
// Returns S_OK.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSQLSample::Notify(
    /* [in] */ LONG ExitEvent,
    /* [in] */ LONG Context)
{
    char *psz = "UNKNOWN EVENT";
    HRESULT hr = S_OK;

    switch (ExitEvent)
    {
	case EXITEVENT_CERTISSUED:
	    hr = _NotifyNewCert(Context);
	    psz = "certissued";
	    break;

	case EXITEVENT_CERTPENDING:
	    psz = "certpending";
	    break;

	case EXITEVENT_CERTDENIED:
	    psz = "certdenied";
	    break;

	case EXITEVENT_CERTREVOKED:
	    psz = "certrevoked";
	    break;

	case EXITEVENT_CERTRETRIEVEPENDING:
	    psz = "retrievepending";
	    break;

	case EXITEVENT_CRLISSUED:
	    psz = "crlissued";
	    break;

	case EXITEVENT_SHUTDOWN:
	    psz = "shutdown";
	    break;
    }

    DBGPRINT((
	fDebug,
	"Exit:Notify(%hs=%x, ctx=%u) rc=%x\n",
	psz,
	ExitEvent,
	Context,
	hr));
    return(hr);
}


STDMETHODIMP
CCertExitSQLSample::GetDescription(
    /* [retval][out] */ BSTR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

    assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);

    *pstrDescription = SysAllocString(sz);
    if (NULL == *pstrDescription)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }

error:
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CCertExitSQLSample::InterfaceSupportsErrorInfo(REFIID riid)
{
    int i;
    static const IID *arr[] =
    {
	&IID_ICertExit,
    };

    for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (IsEqualGUID(*arr[i],riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}

HRESULT
CCertExitSQLSample::ExitModSetODBCProperty(
	IN DWORD dwReqId,
	IN LPWSTR pszCAName,
	IN LPWSTR pszRequester,
	IN LPWSTR pszCertType,
	IN FILETIME* pftBefore,
	IN FILETIME* pftAfter)
{
	SQLRETURN retcode;
	HRESULT hr = S_OK;

	SQLHSTMT        hstmt1 = SQL_NULL_HSTMT;
	SQLWCHAR* pszStatement = NULL;

	SYSTEMTIME stTmp;
	SQL_TIMESTAMP_STRUCT   dateValidFrom, dateValidTo;
	SQLINTEGER        cValidFrom=sizeof(dateValidFrom), cValidTo =sizeof(dateValidTo);

	static WCHAR szSQLInsertStmt[] = L"INSERT INTO OutstandingCertificates (CAName, RequestID,  RequesterName, CertType, validFrom, validTo) VALUES (\'%ws\', %d, \'%ws\', \'%ws\', ?, ?)";

	// temporarily fix NULL to ""
	if (NULL == pszCAName)
		pszCAName = L"";
	if (NULL == pszRequester)
		pszRequester = L"";
	if (NULL == pszCertType)
		pszCertType = L"";


    // Allocate a statement handle.
	retcode = SQLAllocHandle(SQL_HANDLE_STMT, m_hdbc1, &hstmt1);
	if (!SQL_SUCCEEDED(retcode))
		goto error;


	// Bind the parameter.
	retcode = SQLBindParameter(hstmt1, 1, SQL_PARAM_INPUT, SQL_C_TYPE_TIMESTAMP, SQL_TYPE_TIMESTAMP, 0, 0,
					  &dateValidFrom, 0, &cValidFrom);
	if (!SQL_SUCCEEDED(retcode))
		goto error;

	retcode = SQLBindParameter(hstmt1, 2, SQL_PARAM_INPUT, SQL_C_TYPE_TIMESTAMP, SQL_TYPE_TIMESTAMP, 0, 0,
					  &dateValidTo, 0, &cValidTo);
	if (!SQL_SUCCEEDED(retcode))
		goto error;


	// Place the valid from date in the dsOpenDate structure.
	if (!FileTimeToSystemTime(pftBefore, &stTmp))
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		_JumpError(hr, error, "FileTimeToSystemTime");
	}

	dateValidFrom.year = stTmp.wYear;
	dateValidFrom.month = stTmp.wMonth;
	dateValidFrom.day = stTmp.wDay;
    dateValidFrom.hour = stTmp.wHour;
    dateValidFrom.minute = stTmp.wMinute;
    dateValidFrom.second = stTmp.wSecond;

	// Place the valid to date in the dsOpenDate structure.
	if (!FileTimeToSystemTime(pftAfter, &stTmp))
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		_JumpError(hr, error, "FileTimeToSystemTime");
	}

	dateValidTo.year = stTmp.wYear;
	dateValidTo.month = stTmp.wMonth;
	dateValidTo.day = stTmp.wDay;
    dateValidTo.hour = stTmp.wHour;
    dateValidTo.minute = stTmp.wMinute;
    dateValidTo.second = stTmp.wSecond;


	// Build INSERT statement.
	pszStatement = (SQLWCHAR*) LocalAlloc(LMEM_FIXED, (sizeof(szSQLInsertStmt)+wcslen(pszCAName)+wcslen(pszRequester)+wcslen(pszCertType)+15 +1) *2);
	if (NULL == pszStatement)
	{
		hr = E_OUTOFMEMORY;
		goto error;
	}
	
	wsprintf(pszStatement, szSQLInsertStmt, pszCAName, dwReqId, pszRequester, pszCertType);
	//OutputDebugStringW(pszStatement);
	
    // Execute an SQL statement directly on the statement handle.
    // Uses a default result set because no cursor attributes are set.
	retcode = SQLExecDirect(hstmt1, pszStatement, SQL_NTS);
	if (!SQL_SUCCEEDED(retcode))
		goto error;


error:
    /* Clean up. */
	if (NULL != pszStatement)
		LocalFree(pszStatement);

    if (SQL_NULL_HSTMT != hstmt1)
		SQLFreeHandle(SQL_HANDLE_STMT, hstmt1);

	if (!SQL_SUCCEEDED(retcode))
		hr = ERROR_BAD_QUERY_SYNTAX;

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\exitsql.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exitsql.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "exit.h"
#include "module.h"

CComModule _Module;
HINSTANCE g_hInstance;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertExitSQLSample, CCertExitSQLSample)
    OBJECT_ENTRY(CLSID_CCertManageExitModuleSQLSample, CCertManageExitModuleSQLSample)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    g_hInstance = hInstance;
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\exit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExitSQLSample definition
//
//---------------------------------------------------------------------------

#include "exitsql.h"
#include "resource.h"       // main symbols

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>

#define wszREG_EXITSQL_DSN L"DatabaseDSN"
#define wszREG_EXITSQL_USER L"DatabaseUser"
#define wszREG_EXITSQL_PASSWORD L"DatabasePassword"

HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context);

/////////////////////////////////////////////////////////////////////////////
// certexit

class CCertExitSQLSample: 
    public CComDualImpl<ICertExit, &IID_ICertExit, &LIBID_CERTEXITSAMPLELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertExitSQLSample, &CLSID_CCertExitSQLSample>
{
public:
    CCertExitSQLSample() 
    { 
	m_henv = SQL_NULL_HENV;
	m_hdbc1 = SQL_NULL_HDBC;   

        m_strCAName = NULL;
    }
    ~CCertExitSQLSample();

BEGIN_COM_MAP(CCertExitSQLSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertExit)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertExitSQLSample) 

DECLARE_REGISTRY(
    CCertExitSQLSample,
    wszCLASS_CERTEXITSAMPLE TEXT(".1"),
    wszCLASS_CERTEXITSAMPLE,
    IDS_CERTEXIT_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertExit
public:
    STDMETHOD(Initialize)( 
            /* [in] */ BSTR const strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pEventMask);

    STDMETHOD(Notify)(
            /* [in] */ LONG ExitEvent,
            /* [in] */ LONG Context);

    STDMETHOD(GetDescription)( 
            /* [retval][out] */ BSTR *pstrDescription);

private:
    HRESULT _NotifyNewCert(IN LONG Context);

	HRESULT ExitModSetODBCProperty(
	IN DWORD dwReqId,
	IN LPWSTR pszCAName,
	IN LPWSTR pszRequester,
	IN LPWSTR pszCertType,
	IN FILETIME* pftBefore,
	IN FILETIME* pftAfter);


    // Member variables & private methods here:
    BSTR           m_strCAName;

	SQLHENV        m_henv;
	SQLHDBC        m_hdbc1;     
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:	$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certweb\certsrck.inc ===
<%' CODEPAGE=65001 'UTF-8%>
<%' certsrck.inc - (CERT)srv web - (S)cript: (R)equest-(C)ooc(K)ie management
  ' Copyright (C) Microsoft Corporation, 1998 - 1999 %>
<%
	' Format of our cookie:
	' '[' <ReqID> ',' <TargetStoreFlags> ',' <SaveCert> ',' <FriendlyType> ']'...
	Const FIELD_REQID=0
	Const FIELD_TARGETSTOREFLAGS=1
	Const FIELD_SAVECERT=2
	Const FIELD_FRIENDLYTYPE=3
	Const NUM_FIELDS=4
	Const REQUEST_COOKIE_NAME="Requests"
	Dim nReqId

	' Look up the requests in the cookie, and return an array of 'request' arrays
	Function GetRequests()

		' Get the cookie
		Dim sRequests
		sRequests=Request.Cookies(REQUEST_COOKIE_NAME)

		' If the cookie was never set, return an empty array
		If ""=sRequests Then
			GetRequests=Null
			Exit Function
		End If

		Dim nRequests
		Dim rgRequests()
		nRequests=0

		' Loop through all the requests in the string
		Dim nSplitIndex
		Do
			' Find the next request
			nSplitIndex=InStr(sRequests,"]")
			If 0=nSplitIndex Then
				Exit Do
			End If

			' Split this Request off the string
			Dim sElem
			sElem=Mid(sRequests, 2, nSplitIndex-2)
			sRequests=Mid(sRequests, nSplitIndex+1)

			' Spit this request apart
			Dim rgElem
			rgElem=Split(sElem, ",")

			' Safety check
			If NUM_FIELDS-1<>UBound(rgElem) Then
				' Cookie is corrupt
				nRequests=0
				Exit Do
			End If

			' Add this array to our array of requests
			ReDim Preserve rgRequests(nRequests)
			rgRequests(nRequests)=rgElem
			nRequests=nRequests+1

			' safety check for testing
			'If nRequests>25 Then
			'	Err.Raise 6
			'End If

		Loop ' End string-parsing loop
	
		' if there was an error parsing the cookie, just assume it was empty.
		If 0=nRequests Then
			GetRequests=Null
		Else
			GetRequests=rgRequests
		End If

	End Function

	' Combine a requests-array into a single string and set it as a cookie
	Sub PutRequests(rgRequests)
		Dim sCookie, sRequests, nIndex
		sRequests=""

		' check for the empty list
		If IsNull(rgRequests) Then
			' the list is empty
			'   do nothing
			sRequests="-" ' Lynx won't set an empty cookie, so set an invalid one
		Else
			' the list is not empty
			' build a string for each request and concatenate to make cookie
			For nIndex=0 To UBound(rgRequests)
				sRequests=sRequests & "[" & _
					rgRequests(nIndex)(FIELD_REQID) & "," & _
					rgRequests(nIndex)(FIELD_TARGETSTOREFLAGS) & "," & _
					rgRequests(nIndex)(FIELD_SAVECERT) & "," & _
					rgRequests(nIndex)(FIELD_FRIENDLYTYPE) & "]"
			Next
		End If

		' Set the cookie
		Response.Cookies(REQUEST_COOKIE_NAME)=sRequests

		' Set the expiration date
		Response.Cookies(REQUEST_COOKIE_NAME).Expires=Now+nPendingTimeoutDays

		' Set the path
		Response.Cookies(REQUEST_COOKIE_NAME).Path="/certsrv"

	End Sub

	' Remove a given request from the requests cookie
	Sub RemoveReq(nReqID)
		' get the array of requests
		Dim rgRequests
		rgRequests=GetRequests()

		' if the cookie is empty, just ignore
		If IsNull(rgRequests) Then
			Exit Sub
		End If

		' find the request
		Dim nIndex
		Dim nFoundIndex
		nFoundIndex=-1
		For nIndex=0 To UBound(rgRequests)
			If nReqID=rgRequests(nIndex)(FIELD_REQID) Then
				nFoundIndex=nIndex
				Exit For
			End If
		Next

		If -1=nFoundIndex Then
			' request not found, probably a reload and it was deleted already
			'   do nothing
		Else
			' remove the request:
			If 0=UBound(rgRequests) Then
				' this is the last request
				' removing it leaves an empty list
				rgRequests=Null
			Else
				' Not the last request, so shuffle down
				' (this is not the most efficient, but it keeps the requests in order)
				For nIndex=nFoundIndex To UBound(rgRequests)-1
					rgRequests(nIndex)=rgRequests(nIndex+1)
				Next

				' shrink the array
				ReDim Preserve rgRequests(UBound(rgRequests)-1)
			End If

			' set the cookie
			PutRequests rgRequests
		End If
	End Sub

	' Add the current request to the request cookie
	Sub AddRequest
		' build a request object for this request
		Dim rgNewReq(3) 'NUM_FIELDS-1
		nReqId=ICertRequest.GetRequestId()
		rgNewReq(FIELD_REQID)=nReqId
		rgNewReq(FIELD_TARGETSTOREFLAGS)=Request.Form("TargetStoreFlags")
		rgNewReq(FIELD_SAVECERT)=Request.Form("SaveCert")
		rgNewReq(FIELD_FRIENDLYTYPE)=Request.Form("FriendlyType")

		' prevent special split characters from being placed in the string
		' by converting them to spaces
		rgNewReq(FIELD_FRIENDLYTYPE)=Replace(rgNewReq(FIELD_FRIENDLYTYPE), ",", " ")
		rgNewReq(FIELD_FRIENDLYTYPE)=Replace(rgNewReq(FIELD_FRIENDLYTYPE), "]", " ")

		' add it to the list
		Dim rgRequests
		rgRequests=GetRequests()
		If IsNull(rgRequests) Then 
			' cookie has never been set
			ReDim rgRequests(0)
		Else
			' save old requests in cookie
			ReDim Preserve rgRequests(UBound(rgRequests)+1)
		End If
		rgRequests(UBound(rgRequests))=rgNewReq
		PutRequests rgRequests
	End Sub
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManageExitModuleSQLSample definition
//
//---------------------------------------------------------------------------

#include "exitsql.h"
#include "resource.h"       // main symbols


class CCertManageExitModuleSQLSample: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTEXITSAMPLELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModuleSQLSample, &CLSID_CCertManageExitModuleSQLSample>
{
public:
    CCertManageExitModuleSQLSample() { m_hWnd = NULL; }
    ~CCertManageExitModuleSQLSample() {}

BEGIN_COM_MAP(CCertManageExitModuleSQLSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModuleSQLSample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManageExitModuleSQLSample,
    wszCLASS_CERTMANAGESAMPLE TEXT(".1"),
    wszCLASS_CERTMANAGESAMPLE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

public:
    HWND m_hWnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>

#include "celib.h"
#include "module.h"
#include "exit.h"

extern HINSTANCE g_hInstance;
INT_PTR CALLBACK ExitSQLDlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam);



HRESULT
GetMachineFromConfig(
    IN WCHAR const *pwszConfig,
    OUT WCHAR **ppwszMachine)
{
    HRESULT hr;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwsz;
    DWORD cwc;


    if (NULL != ppwszMachine)
    {
		*ppwszMachine = NULL;
    }
	
    while (L'\\' == *pwszConfig)
    {
		pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');

    if (NULL != pwsz)
    {
		cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
    }
    else
    {
		cwc = wcslen(pwszConfig);
    }
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszMachine, pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';
	
    if (NULL != ppwszMachine)
    {
		*ppwszMachine = pwszMachine;
		pwszMachine = NULL;
    }
    hr = S_OK;
	
error:
    if (NULL != pwszMachine)
    {
		LocalFree(pwszMachine);
    }
    return(hr);
}


STDMETHODIMP
CCertManageExitModuleSQLSample::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    LPWSTR szStr = NULL;
    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == wcscmp(strPropertyName, wszCMM_PROP_NAME))
        szStr = wsz_SAMPLE_NAME;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
        szStr = wsz_SAMPLE_DESCRIPTION;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        szStr = wsz_SAMPLE_COPYRIGHT;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_FILEVER))
        szStr = wsz_SAMPLE_FILEVER;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        szStr = wsz_SAMPLE_PRODUCTVER;
    else
        return S_FALSE;  

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}


        
STDMETHODIMP 
CCertManageExitModuleSQLSample::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty)
{
     if (0 == lstrcmpi(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvarProperty->vt != VT_BSTR)
              return E_INVALIDARG;
         
         if (SysStringByteLen(pvarProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;

         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvarProperty->bstrVal;
         return S_OK;
     }

     return S_FALSE;
}
        

typedef struct _EXITSQL_CONFIGSTRUCT
{
    HKEY         hkeyStorageLocation;
    LONG         Flags;

    BOOL	 fPageModified;
} EXITSQL_CONFIGSTRUCT, *PEXITSQL_CONFIGSTRUCT;


STDMETHODIMP
CCertManageExitModuleSQLSample::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG Flags)
{
    HRESULT hr;
    LPWSTR szMachine = NULL;
    HKEY hkeyHKLM = NULL;
    DWORD dwDisposition;

    EXITSQL_CONFIGSTRUCT sConfig;
    ZeroMemory(&sConfig, sizeof(EXITSQL_CONFIGSTRUCT));

    hr = GetMachineFromConfig(strConfig, &szMachine);
    _JumpIfError(hr, Ret, "GetMachineFromConfig");


	// UNDONE: only do this if remote
	hr = RegConnectRegistry(
			szMachine,
			HKEY_LOCAL_MACHINE,
			&hkeyHKLM);
        _JumpIfError(hr, Ret, "RegConnectRegistry");

    // open storage location: write perms if possible
    hr = RegCreateKeyEx(
        hkeyHKLM,
        strStorageLocation,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &sConfig.hkeyStorageLocation,
        &dwDisposition);
    if (hr != S_OK)
    {
        hr = RegOpenKeyEx(
            hkeyHKLM,
            strStorageLocation,
            0,
            KEY_READ,       // fallback: read-only
            &sConfig.hkeyStorageLocation);
        if (hr != ERROR_SUCCESS)
            goto Ret;
    }

    sConfig.Flags = Flags;

    PROPSHEETPAGE page;
    ZeroMemory(&page, sizeof(PROPSHEETPAGE));
    page.dwSize = sizeof(PROPSHEETPAGE);
    page.dwFlags = PSP_DEFAULT;
    page.hInstance = g_hInstance;
    page.lParam = (LPARAM)&sConfig;
    

    page.pszTemplate = MAKEINTRESOURCE(IDD_EXITSQL_PROPERTIES);
    page.pfnDlgProc = ExitSQLDlgProc;


    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.hInstance = g_hInstance;
    sSheet.pszCaption = L"";
    sSheet.nPages = 1;
    sSheet.ppsp = &page;

    
    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

    if ((iRet > 0) && (sConfig.fPageModified))   // successful modification
    {
		MessageBoxW(NULL, L"This action requires the Certificate Service to be restarted before taking effect.", L"Applying ExitSQL Settings", MB_OK|MB_ICONINFORMATION);
    }

Ret:
    if (sConfig.hkeyStorageLocation)
        RegCloseKey(sConfig.hkeyStorageLocation);

    if (szMachine)
        LocalFree(szMachine);

    if (hkeyHKLM)
        RegCloseKey(hkeyHKLM);

    return S_OK;
}



INT_PTR CALLBACK ExitSQLDlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam)
{
    EXITSQL_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
			PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (EXITSQL_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            BYTE pbTmp[MAX_PATH*sizeof(WCHAR)];
            DWORD cbTmp = MAX_PATH*sizeof(WCHAR);
			DWORD dwType;

			// dsn
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREG_EXITSQL_DSN,
                0,
                &dwType,
                pbTmp,
                &cbTmp);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_SZ))
                break;

			SetDlgItemText(hwndDlg, IDC_EDIT_DSN, (LPWSTR)pbTmp);
			((WCHAR*)pbTmp)[0] = L'\0';
			cbTmp = MAX_PATH*sizeof(WCHAR);

			// username
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREG_EXITSQL_USER,
                0,
                &dwType,
                pbTmp,
                &cbTmp);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_SZ))
                break;

			SetDlgItemText(hwndDlg, IDC_EDIT_USER, (LPWSTR)pbTmp);
			((WCHAR*)pbTmp)[0] = L'\0';
			cbTmp = MAX_PATH*sizeof(WCHAR);

			// password
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREG_EXITSQL_PASSWORD,
                0,
                &dwType,
                pbTmp,
                &cbTmp);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_SZ))
                break;

			SetDlgItemText(hwndDlg, IDC_EDIT_PASSWORD, (LPWSTR)pbTmp);
			((WCHAR*)pbTmp)[0] = L'\0';
			cbTmp = MAX_PATH*sizeof(WCHAR);

			psConfig->fPageModified = FALSE;

            // no other work to be done
            fReturn = TRUE;
            break;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_EDIT_DSN:
        case IDC_EDIT_USER:
        case IDC_EDIT_PASSWORD:
         if (HIWORD(wParam) == EN_CHANGE)
 {
                // grab our LParam
                psConfig = (EXITSQL_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

              psConfig->fPageModified = TRUE;
}
        break;
        default:
        break;
        } 
         break;
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
				hr = S_OK;

                // grab our LParam
                psConfig = (EXITSQL_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

				WCHAR szTmp[MAX_PATH];
				GetDlgItemText(hwndDlg, IDC_EDIT_DSN, szTmp, sizeof(szTmp));

					hr = RegSetValueEx(
						psConfig->hkeyStorageLocation,
						wszREG_EXITSQL_DSN,
						0,
						REG_SZ,
						(PBYTE)&szTmp,
						(wcslen(szTmp)+1) * sizeof(WCHAR) );
					if (hr != ERROR_SUCCESS)
						goto savefailure;




				GetDlgItemText(hwndDlg, IDC_EDIT_USER, szTmp, sizeof(szTmp));

					hr = RegSetValueEx(
						psConfig->hkeyStorageLocation,
						wszREG_EXITSQL_USER,
						0,
						REG_SZ,
						(PBYTE)&szTmp,
						(wcslen(szTmp)+1) * sizeof(WCHAR) );
					if (hr != ERROR_SUCCESS)
						goto savefailure;



				GetDlgItemText(hwndDlg, IDC_EDIT_PASSWORD, szTmp, sizeof(szTmp));

					hr = RegSetValueEx(
						psConfig->hkeyStorageLocation,
						wszREG_EXITSQL_PASSWORD,
						0,
						REG_SZ,
						(PBYTE)&szTmp,
						(wcslen(szTmp)+1) * sizeof(WCHAR) );
					if (hr != ERROR_SUCCESS)
						goto savefailure;


savefailure:
                if (hr != ERROR_SUCCESS)
                {
					MessageBoxW(NULL, L"The settings could not be saved.", L"Applying ExitSQL Settings", MB_OK|MB_ICONINFORMATION);
                       psConfig->fPageModified = FALSE;
                }

            }
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#define wszCLASS_CERTEXITSAMPLEPREFIX TEXT("CertAuthority_ExitSQL_Sample")

#define wszCLASS_CERTEXITSAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTEXITMODULE_POSTFIX
#define wszCLASS_CERTMANAGESAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTMANAGEEXIT_POSTFIX

#define wsz_SAMPLE_NAME           L"ODBC logging Exit Module"
#define wsz_SAMPLE_DESCRIPTION    L"Logs issuance events to an ODBC source"
#define wsz_SAMPLE_COPYRIGHT      L"2000 Microsoft Corp"
#define wsz_SAMPLE_FILEVER        L"1.0"
#define wsz_SAMPLE_PRODUCTVER     L"5.01"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\exitsql\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by exitsql.rc
//
#define IDS_CERTEXIT_DESC               1
#define IDS_CERTMANAGEEXITMODULE_DESC   2
#define IDS_MODULE_NAME                 3
#define IDC_EDIT_DSN                    201
#define IDC_EDIT_USER                   202
#define IDC_EDIT_PASSWORD               203
#define IDD_EXITSQL_PROPERTIES          614

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:	$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\certxsam.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certxsam.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "exit.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertExitSample, CCertExitSample)
    OBJECT_ENTRY(CLSID_CCertManageExitModuleSample, CCertManageExitModuleSample)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\exit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExitSample definition
//
//---------------------------------------------------------------------------

#include "certxsam.h"
#include "resource.h"       // main symbols


HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context);

/////////////////////////////////////////////////////////////////////////////
// certexit

class CCertExitSample: 
    public CComDualImpl<ICertExit2, &IID_ICertExit2, &LIBID_CERTEXITSAMPLELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertExitSample, &CLSID_CCertExitSample>
{
public:
    CCertExitSample() 
    { 
	m_strDescription = NULL;
        m_strCAName = NULL;
        m_pwszRegStorageLoc = NULL;
        m_hExitKey = NULL;
        m_dwExitPublishFlags = 0;
        m_cCACert = 0;

    }
    ~CCertExitSample();

BEGIN_COM_MAP(CCertExitSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertExit)
    COM_INTERFACE_ENTRY(ICertExit2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertExitSample) 

DECLARE_REGISTRY(
    CCertExitSample,
    wszCLASS_CERTEXITSAMPLE TEXT(".1"),
    wszCLASS_CERTEXITSAMPLE,
    IDS_CERTEXIT_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertExit
public:
    STDMETHOD(Initialize)( 
            /* [in] */ BSTR const strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pEventMask);

    STDMETHOD(Notify)(
            /* [in] */ LONG ExitEvent,
            /* [in] */ LONG Context);

    STDMETHOD(GetDescription)( 
            /* [retval][out] */ BSTR *pstrDescription);

// ICertExit2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

private:
    HRESULT _NotifyNewCert(IN LONG Context);

    HRESULT _NotifyCRLIssued(IN LONG Context);

    HRESULT _WriteCertToFile(
	    IN ICertServerExit *pServer,
	    IN BYTE const *pbCert,
	    IN DWORD cbCert);

    HRESULT _ExpandEnvironmentVariables(
	    IN WCHAR const *pwszIn,
	    OUT WCHAR *pwszOut,
	    IN DWORD cwcOut);


    // Member variables & private methods here:
    BSTR           m_strDescription;
    BSTR           m_strCAName;
    LPWSTR         m_pwszRegStorageLoc;
    HKEY           m_hExitKey;
    DWORD          m_dwExitPublishFlags;
    DWORD          m_cCACert;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\exit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExitSample implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "exit.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

#define ceEXITEVENTS \
	EXITEVENT_CERTISSUED | \
	EXITEVENT_CERTPENDING | \
	EXITEVENT_CERTDENIED | \
	EXITEVENT_CERTREVOKED | \
	EXITEVENT_CERTRETRIEVEPENDING | \
	EXITEVENT_CRLISSUED | \
	EXITEVENT_SHUTDOWN

#define CERTTYPE_ATTR_NAME TEXT("CertificateTemplate")
#define MAX_CRL_PROP (32 + 10)

extern HINSTANCE g_hInstance;


HRESULT
GetServerCallbackInterface(
    OUT ICertServerExit** ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Exit:NULL pointer");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerExit,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerExit,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Exit:NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Exit: SetContext");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::~CCertExitSample -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertExitSample::~CCertExitSample()
{
    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
    }
    if (NULL != m_pwszRegStorageLoc)
    {
        LocalFree(m_pwszRegStorageLoc);
    }
    if (NULL != m_hExitKey)
    {
        RegCloseKey(m_hExitKey);
    }
    if (NULL != m_strDescription)
    {
        SysFreeString(m_strDescription);
    }
}


//+--------------------------------------------------------------------------
// CCertExitSample::Initialize -- initialize for a CA & return interesting Event Mask
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSample::Initialize(
    /* [in] */ BSTR const strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pEventMask)
{
    HRESULT hr = S_OK;
    HKEY        hkey = NULL;
    DWORD       cbbuf;
    DWORD       dwType;
    ENUM_CATYPES CAType;
    LPWSTR      pwszCLSIDCertExit = NULL;
    ICertServerExit* pServer = NULL;
    VARIANT varValue;
    
    WCHAR sz[MAX_PATH];

    assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);

    m_strDescription = SysAllocString(sz);
    if (NULL == m_strDescription)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }


    VariantInit(&varValue);

    m_strCAName = SysAllocString(strConfig);
    if (NULL == m_strCAName)
    {
    	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:SysAllocString");
    }

    *pEventMask = ceEXITEVENTS;
    DBGPRINT((fDebug, "Exit:Initialize(%ws) ==> %x\n", m_strCAName, *pEventMask));

    // get server callbacks

    hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "Exit:GetServerCallbackInterface");

    // get storage location

    hr = pServer->GetCertificateProperty(wszPROPMODULEREGLOC, PROPTYPE_STRING, &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPMODULEREGLOC);
    
    m_pwszRegStorageLoc = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(varValue.bstrVal)+1) *sizeof(WCHAR));
    if (NULL == m_pwszRegStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Exit:LocalAlloc");
    }
    wcscpy(m_pwszRegStorageLoc, varValue.bstrVal);
    VariantClear(&varValue);

    // get CA type
    hr = pServer->GetCertificateProperty(wszPROPCATYPE, PROPTYPE_LONG, &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPCATYPE);

    CAType = (ENUM_CATYPES) varValue.lVal;
    VariantClear(&varValue);

    hr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                m_pwszRegStorageLoc,
                0,              // dwReserved
                KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                &m_hExitKey);

    if (S_OK != hr)
    {
        if (ERROR_FILE_NOT_FOUND == hr)
        {
            hr = S_OK;
            goto error;
        }
        _JumpError(hr, error, "Exit:RegOpenKeyEx");
    }


    hr = pServer->GetCertificateProperty(wszPROPCERTCOUNT, PROPTYPE_LONG, &varValue);
    _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszPROPCERTCOUNT);

    m_cCACert = varValue.lVal;

    cbbuf = sizeof(m_dwExitPublishFlags);
    hr = RegQueryValueEx(
		    m_hExitKey,
		    wszREGCERTPUBLISHFLAGS,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) &m_dwExitPublishFlags,
		    &cbbuf);
    if (S_OK != hr)
    {
        m_dwExitPublishFlags = 0;
    }
    hr = S_OK;

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    VariantClear(&varValue);
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(ceHError(hr));
}


//+--------------------------------------------------------------------------
// CCertExitSample::_ExpandEnvironmentVariables -- Expand environment variables
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_ExpandEnvironmentVariables(
    IN WCHAR const *pwszIn,
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    WCHAR awcVar[MAX_PATH];
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;
    WCHAR *pwszDstEnd;
    WCHAR *pwszVar;
    DWORD cwc;

    pwszSrc = pwszIn;
    pwszDst = pwszOut;
    pwszDstEnd = &pwszOut[cwcOut];

    while (L'\0' != (*pwszDst = *pwszSrc++))
    {
	if ('%' == *pwszDst)
	{
	    *pwszDst = L'\0';
	    pwszVar = awcVar;

	    while (L'\0' != *pwszSrc)
	    {
		if ('%' == *pwszSrc)
		{
		    pwszSrc++;
		    break;
		}
		*pwszVar++ = *pwszSrc++;
		if (pwszVar >= &awcVar[sizeof(awcVar)/sizeof(awcVar[0]) - 1])
		{
		    _JumpError(hr, error, "Exit:overflow 1");
		}
	    }
	    *pwszVar = L'\0';
	    cwc = GetEnvironmentVariable(awcVar, pwszDst, SAFE_SUBTRACT_POINTERS(pwszDstEnd, pwszDst));
	    if (0 == cwc)
	    {
		hr = ceHLastError();
		_JumpError(hr, error, "Exit:GetEnvironmentVariable");
	    }
	    if ((DWORD) (pwszDstEnd - pwszDst) <= cwc)
	    {
		_JumpError(hr, error, "Exit:overflow 2");
	    }
	    pwszDst += cwc;
	}
	else
	{
	    pwszDst++;
	}
	if (pwszDst >= pwszDstEnd)
	{
	    _JumpError(hr, error, "Exit:overflow 3");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::_WriteCertToFile -- write binary certificate to a file
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_WriteCertToFile(
    IN ICertServerExit *pServer,
    IN BYTE const *pbCert,
    IN DWORD cbCert)
{
    HRESULT hr;
    BSTR strCertFile = NULL;
    DWORD cbWritten;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR wszPath[MAX_PATH];
    WCHAR const *pwszFile;
    WCHAR const *pwsz;


    hr = pServer->GetRequestAttribute(wszPROPEXITCERTFILE, &strCertFile);
    if (S_OK != hr)
    {
	DBGPRINT((
	    fDebug,
	    "Exit:GetRequestAttribute(%ws): %x%hs\n",
	    wszPROPEXITCERTFILE,
	    hr,
	    CERTSRV_E_PROPERTY_EMPTY == hr? " EMPTY VALUE" : ""));
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    pwszFile = wcsrchr(strCertFile, L'\\');
    if (NULL == pwszFile)
    {
	pwszFile = strCertFile;
    }
    else
    {
	pwszFile++;
    }
    pwsz = wcsrchr(pwszFile, L'/');
    if (NULL != pwsz)
    {
	pwszFile = &pwsz[1];
    }

    hr = _ExpandEnvironmentVariables(
		    L"%SystemRoot%\\System32\\" wszCERTENROLLSHAREPATH L"\\",
		    wszPath,
		    ARRAYSIZE(wszPath));
    _JumpIfError(hr, error, "_ExpandEnvironmentVariables");

    if (ARRAYSIZE(wszPath) <= wcslen(wszPath) + wcslen(pwszFile))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "Exit:Path too long");
    }
    wcscat(wszPath, pwszFile);

    // open file & write binary cert out.

    hFile = CreateFile(
		    wszPath,
		    GENERIC_WRITE,
		    0,			// dwShareMode
		    NULL,		// lpSecurityAttributes
		    CREATE_NEW,
		    FILE_ATTRIBUTE_NORMAL,
		    NULL);		// hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = ceHLastError();
	_JumpErrorStr(hr, error, "Exit:CreateFile", wszPath);
    }
    if (!WriteFile(hFile, pbCert, cbCert, &cbWritten, NULL))
    {
	hr = ceHLastError();
	_JumpErrorStr(hr, error, "Exit:WriteFile", wszPath);
    }
    if (cbWritten != cbCert)
    {
	hr = STG_E_WRITEFAULT;
	DBGPRINT((
	    fDebug,
	    "Exit:WriteFile(%ws): attempted %x, actual %x bytes: %x\n",
	    wszPath,
	    cbCert,
	    cbWritten,
	    hr));
	goto error;
    }

error:

    if (INVALID_HANDLE_VALUE != hFile)
    {
	CloseHandle(hFile);
    }
    if (NULL != strCertFile)
    {
	SysFreeString(strCertFile);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::_NotifyNewCert -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_NotifyNewCert(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    HRESULT hr2;
    VARIANT varCert;
    VARIANT varCertType;
    ICertServerExit *pServer = NULL;
    BSTR strCertType;

    VariantInit(&varCert);
    hr = CoCreateInstance(
		    CLSID_CCertServerExit,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertServerExit,
		    (VOID **) &pServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    hr = pServer->SetContext(Context);
    _JumpIfError(hr, error, "Exit:SetContext");

    hr = pServer->GetCertificateProperty(
			       wszPROPRAWCERTIFICATE,
			       PROPTYPE_BINARY,
			       &varCert);
    _JumpIfErrorStr(
		hr,
		error,
		"Exit:GetCertificateProperty",
		wszPROPRAWCERTIFICATE);

    if (VT_BSTR != varCert.vt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Exit:BAD cert var type");
    }

    strCertType = NULL;
    hr = pServer->GetCertificateProperty(
			       wszPROPCERTIFICATETEMPLATE,
			       PROPTYPE_STRING,
			       &varCertType);
    if (S_OK == hr && VT_BSTR == varCertType.vt)
    {
	strCertType = varCertType.bstrVal;
	DBGPRINT((fDebug, "Exit:CertType = %ws\n", strCertType));
    }
    hr = S_OK;

    // only call write fxns if server policy allows

    if (m_dwExitPublishFlags & EXITPUB_FILE)
    {
	hr2 = _WriteCertToFile(
			pServer,
			(BYTE const *) varCert.bstrVal,
			SysStringByteLen(varCert.bstrVal));
	_PrintIfError(hr2, "_WriteCertToFile");
	hr = hr2;
    }


error:
    VariantClear(&varCert);
    VariantClear(&varCertType);
    if (NULL != pServer)
    {
	pServer->Release();
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertExitSample::_NotifyCRLIssued -- Notify the exit module of a new certificate
//
//+--------------------------------------------------------------------------

HRESULT
CCertExitSample::_NotifyCRLIssued(
    /* [in] */ LONG Context)
{
    HRESULT hr;
    ICertServerExit *pServer = NULL;
    DWORD i;
    VARIANT varBaseCRL;
    VARIANT varDeltaCRL;
    DWORD cbbuf;
    DWORD dwType;

    VariantInit(&varBaseCRL);
    VariantInit(&varDeltaCRL);

    hr = CoCreateInstance(
		    CLSID_CCertServerExit,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertServerExit,
		    (VOID **) &pServer);
    _JumpIfError(hr, error, "Exit:CoCreateInstance");

    hr = pServer->SetContext(Context);
    _JumpIfError(hr, error, "Exit:SetContext");


    // How many CRLs are there?

    // Loop for each CRL
    for (i = 0; i < m_cCACert; i++)
    {
        WCHAR wszCRLPROP[MAX_CRL_PROP];

        // Verify the CRL State says we should update this CRL

        wsprintf(wszCRLPROP, wszPROPCRLSTATE L".%u", i);
        hr = pServer->GetCertificateProperty(
			           wszCRLPROP,
			           PROPTYPE_LONG,
			           &varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszCRLPROP);

	if (CA_DISP_VALID != varBaseCRL.lVal)
	{
	    continue;
	}

        // Grab the raw base CRL

        wsprintf(wszCRLPROP, wszPROPRAWCRL L".%u", i);
        hr = pServer->GetCertificateProperty(
			           wszCRLPROP,
			           PROPTYPE_BINARY,
			           &varBaseCRL);
        _JumpIfErrorStr(hr, error, "Exit:GetCertificateProperty", wszCRLPROP);

        // Grab the raw delta CRL (which may not exist)

        wsprintf(wszCRLPROP, wszPROPRAWDELTACRL L".%u", i);
        hr = pServer->GetCertificateProperty(
			           wszCRLPROP,
			           PROPTYPE_BINARY,
			           &varDeltaCRL);
        _PrintIfErrorStr(hr, "Exit:GetCertificateProperty", wszCRLPROP);

        // Publish the CRL(s) ...
    }

error:
    if (NULL != pServer)
    {
	pServer->Release();
    }
    VariantClear(&varBaseCRL);
    VariantClear(&varDeltaCRL);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::Notify -- Notify the exit module of an event
//
// Returns S_OK.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSample::Notify(
    /* [in] */ LONG ExitEvent,
    /* [in] */ LONG Context)
{
    char *psz = "UNKNOWN EVENT";
    HRESULT hr = S_OK;

    switch (ExitEvent)
    {
	case EXITEVENT_CERTISSUED:
	    hr = _NotifyNewCert(Context);
	    psz = "certissued";
	    break;

	case EXITEVENT_CERTPENDING:
	    psz = "certpending";
	    break;

	case EXITEVENT_CERTDENIED:
	    psz = "certdenied";
	    break;

	case EXITEVENT_CERTREVOKED:
	    psz = "certrevoked";
	    break;

	case EXITEVENT_CERTRETRIEVEPENDING:
	    psz = "retrievepending";
	    break;

	case EXITEVENT_CRLISSUED:
	    hr = _NotifyCRLIssued(Context);
	    psz = "crlissued";
	    break;

	case EXITEVENT_SHUTDOWN:
	    psz = "shutdown";
	    break;
    }

    DBGPRINT((
	fDebug,
	"Exit:Notify(%hs=%x, ctx=%x) rc=%x\n",
	psz,
	ExitEvent,
	Context,
	hr));
    return(hr);
}


STDMETHODIMP
CCertExitSample::GetDescription(
    /* [retval][out] */ BSTR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

    assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
    wcscpy(sz, wsz_SAMPLE_DESCRIPTION);

    *pstrDescription = SysAllocString(sz);
    if (NULL == *pstrDescription)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Exit:SysAllocString");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertExitSample::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertExitSample::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
		    CLSID_CCertManageExitModuleSample,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
		    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CCertExitSample::InterfaceSupportsErrorInfo(REFIID riid)
{
    int i;
    static const IID *arr[] =
    {
	&IID_ICertExit,
    };

    for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (IsEqualGUID(*arr[i],riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\exit0.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.cpp
//
// Contents:    CCertExitSample implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "exit.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\exit0.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        exit.h
//
// Contents:    CCertExitSample definition
//
//---------------------------------------------------------------------------

#include "certxsam.h"
#include "resource.h"       // main symbols
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Exit Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include "module.h"
#include "exit.h"


STDMETHODIMP
CCertManageExitModuleSample::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    LPWSTR szStr = NULL;
    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == wcscmp(strPropertyName, wszCMM_PROP_NAME))
        szStr = wsz_SAMPLE_NAME;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
        szStr = wsz_SAMPLE_DESCRIPTION;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        szStr = wsz_SAMPLE_COPYRIGHT;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_FILEVER))
        szStr = wsz_SAMPLE_FILEVER;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        szStr = wsz_SAMPLE_PRODUCTVER;
    else
        return S_FALSE;  

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManageExitModuleSample::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty)
{
     // no settable properties supported
     return S_FALSE;
}
        
STDMETHODIMP
CCertManageExitModuleSample::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG Flags)
{
    MessageBox(NULL, L"No Configurable Options", NULL, MB_OK|MB_ICONINFORMATION);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManageExitModuleSample definition
//
//---------------------------------------------------------------------------

#include "certxsam.h"
#include "resource.h"       // main symbols


class CCertManageExitModuleSample: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTEXITSAMPLELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModuleSample, &CLSID_CCertManageExitModuleSample>
{
public:
    CCertManageExitModuleSample() {}
    ~CCertManageExitModuleSample() {}

BEGIN_COM_MAP(CCertManageExitModuleSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModuleSample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManageExitModuleSample,
    wszCLASS_CERTMANAGEEXITMODULESAMPLE TEXT(".1"),
    wszCLASS_CERTMANAGEEXITMODULESAMPLE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

// include this here so managemodule and exitmodule get to see it

#define wszCLASS_CERTEXITSAMPLEPREFIX TEXT("CertAuthority_Sample")

#define wszCLASS_CERTEXITSAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTEXITMODULE_POSTFIX
#define wszCLASS_CERTMANAGEEXITMODULESAMPLE wszCLASS_CERTEXITSAMPLEPREFIX wszCERTMANAGEEXIT_POSTFIX

#define wsz_SAMPLE_NAME           L"Sample/Test Exit Module"
#define wsz_SAMPLE_DESCRIPTION    L"Sample Exit Module"
#define wsz_SAMPLE_COPYRIGHT      L"(c)1999 Microsoft"
#define wsz_SAMPLE_FILEVER        L"v 1.0"
#define wsz_SAMPLE_PRODUCTVER     L"v 5.00"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\exit\sample\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certexit.rc
//
#define IDS_CERTEXIT_DESC	1
#define IDS_CERTMANAGEEXITMODULE_DESC 2


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\certgen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certgen.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <conio.h>

#include "encode.h"
#include "rsa.h"
#include "md5.h"
#include <wincrypt.h>
#include <certsrv.h>
#include <certca.h>
#include <csdisp.h>
#include "csprop.h"

#define MSTOSEC(ms)	(((ms) + 1000 - 1)/1000)

DWORD g_crdnMax;


HCRYPTPROV g_hMe = NULL;

WCHAR g_wszTestKey[] = L"CertGen_TestKey";


static unsigned char MD5_PRELUDE[] = {
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86,
    0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00,
    0x04, 0x10
};

BYTE            g_CAPIPrivateKey[1000];
DWORD           g_cbPrivateKey;
//LPBSAFE_PRV_KEY g_pRSAPrivateKey;
DWORD           g_cbRSAPrivateKey;
LPBSAFE_PUB_KEY g_pRSAPublicKey;
DWORD           g_cbRSAPublicKey;

WCHAR *g_pwszConfig = NULL;

typedef struct {
    DWORD       magic;                  // Should always be RSA2
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY;

BOOL g_fRPC = FALSE;
BOOL g_fRenewal = FALSE;
BOOL g_fSave = FALSE;
BOOL g_fPrintProperties = FALSE;
BOOL g_fDebug = FALSE;
BOOL g_fIgnoreAccessDenied = FALSE;
BOOL g_fTime = FALSE;
BOOL g_fIgnoreError = FALSE;
BOOL g_fAllowDups = FALSE;
BOOL g_fShowTime = FALSE;

LONG g_IntervalCount;
DWORD g_MaximumCount = MAXDWORD;
DWORD g_DispatchFlags = DISPSETUP_COMFIRST;

BOOL IsCharPrintableString(TCHAR chChar);

WCHAR wszUsage[] =
    TEXT("Usage: CertGen [options]\n")
    TEXT("Options are:\n")
    TEXT("  -a                     - ignore denied requests\n")
    TEXT("  -c #                   - generate # certs\n")
    TEXT("  -config server\\CAName - specify CA config string\n")
    TEXT("  -renewal               - generate renewal requests\n")
    TEXT("  -rpc                   - use RPC to connect to server\n")
    TEXT("  -r                     - put request/cert/chain info into test.req/test.crt/testchain.crt\n")
    TEXT("  -t #                   - print time statistics every # certs\n")
    TEXT("  -p                     - print properties from cert created\n")
    TEXT("  -i                     - don't stop on request errors\n")
    TEXT("  -z                     - allow duplicate subject name components\n")
    TEXT("  -m                     - print start/end time\n")
;


HRESULT
SeedRNG(void)
{
    HRESULT hr;
    unsigned int seed;

    if (!CryptGenRandom(g_hMe, sizeof(seed), (BYTE *) &seed))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }
    srand(seed);
    hr = S_OK;

error:
    return(hr);

}


HRESULT
GenerateString(
    DWORD cnt,
    BYTE *pbStr)
{
    HRESULT hr;
    DWORD i;
    BYTE *pb;

    hr = SeedRNG();
    _JumpIfError(hr, error, "SeedRNG");

    pb = pbStr;
    for (i = 0; i < cnt; i++)
    {
        do
        {
            *pb = rand() % 0x7f;
        } while (!IsCharPrintableString(*pb));
        pb++;
    }
    *pb = '\0';

    // Turn leading and trailing Blanks into '.' characters?
    if (g_fAllowDups && 0 < cnt)
    {
	if (' ' == *pbStr)
	{
	    *pbStr = '.';
	}
	pb--;
	if (' ' == *pb)
	{
	    *pb = '.';
	}
    }

error:
    return(hr);

}


void
FreeLocalMemory(
    NAMETABLE *pNameTable)
{
    NAMEENTRY *pNameEntry = NULL;
    DWORD i;

    pNameEntry = pNameTable->pNameEntry;
    for (i = 0; i < pNameTable->cnt; i++)
    {
        if (NULL != pNameEntry->pbData)
	{
	    LocalFree(pNameEntry->pbData);
	}
	pNameEntry++;
    }
    LocalFree(pNameTable->pNameEntry);
}


HRESULT
GenerateNameTable(
    NAMETABLE *pNameTable)
{
    HRESULT hr;
    NAMEENTRY *pNameEntryAlloc = NULL;
    NAMEENTRY *pNameEntry;
    DWORD cbString;
    BYTE *pbString;
    DWORD i;
    DWORD j;
    DWORD cRetry;

    hr = SeedRNG();
    _JumpIfError(hr, error, "SeedRNG");

    pNameTable->cnt = rand() % g_crdnMax;	// 0 is Ok

    if (1 < g_fPrintProperties)
    {
	wprintf(L"NumEntries = %u\n", pNameTable->cnt);
    }
    for (i = 0; i < g_crdnSubject; i++)
    {
	g_ardnSubject[i].cbRemain = g_ardnSubject[i].cbMaxConcatenated;
    }

    pNameEntryAlloc = (NAMEENTRY *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    pNameTable->cnt * sizeof(NAMEENTRY));

    if (NULL == pNameEntryAlloc)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pNameTable->pNameEntry = pNameEntryAlloc;

    for (i = 0; i < pNameTable->cnt; i++)
    {
	RDNENTRY *prdne;

	pNameEntry = &pNameTable->pNameEntry[i];

        for (cRetry = 0; !g_fAllowDups || cRetry < 2 * pNameTable->cnt; cRetry++)
        {
	    pNameEntry->iRDN = rand() % g_crdnSubject;
	    prdne = &g_ardnSubject[pNameEntry->iRDN];

            if (g_fAllowDups)
	    {
		if (2 > prdne->cbRemain)
		{
		    continue;		// Skip if less than 2 characters left
		}
	    }
	    else
            {            
                for (j = 0; j < i; j++)
                {
                    if (pNameEntry->iRDN == pNameTable->pNameEntry[j].iRDN)
                    {
                       break;
                    }
                }
		if (j < i)
		{
		    continue;		// Skip if a disallowed duplicate
		}
            }
	    break;
        }
	if (g_fAllowDups && cRetry >= 2 * pNameTable->cnt)
	{
	    if (1 < g_fPrintProperties)
	    {
		wprintf(L"Reducing NumEntries = %u --> %i\n", pNameTable->cnt, i);
	    }
	    pNameTable->cnt = i;	// too many retries -- reduce count & quit
	    break;
	}

        pNameEntry->pszObjId = prdne->pszObjId;
        pNameEntry->BerTag = prdne->BerTag;

	assert(2 <= prdne->cbRemain);
	do
	{
            cbString = rand() % min(prdne->cbMaxString, prdne->cbRemain);
	} while (0 == cbString);

	// Reduce remaining count by length of string plus separator: "\n"

	if (1 < g_fPrintProperties)
	{
	    wprintf(
		L"  RDN(%u): %hs=%u/%u/%u/",
		i,
		prdne->pszShortName,
		cbString,
		prdne->cbMaxString,
		prdne->cbRemain);
	}
	prdne->cbRemain -= cbString;
	if (0 < prdne->cbRemain)
	{
	    prdne->cbRemain--;
	}

	// Limit each string to (prdne->cbMaxString + 1) chars, including
	// trailing '\0':

	assert(cbString <= prdne->cbMaxString); // leave room for '\0' in DB

	pbString = (BYTE *) LocalAlloc(LMEM_FIXED, cbString + 1);
	if (NULL == pbString)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hr = GenerateString(cbString, pbString);
	_JumpIfError(hr, error, "GenerateString");

	if (1 < g_fPrintProperties)
	{
	    wprintf(L"%u: \"%hs\"\n", prdne->cbRemain, pbString);
	}
	pNameEntry->cbData = cbString;
	pNameEntry->pbData = pbString;
    }
    pNameEntryAlloc = NULL;

error:
    if (NULL != pNameEntryAlloc)
    {
	FreeLocalMemory(pNameTable);
    }
    return(hr);
}


HRESULT
GenerateTestNameTable(
    NAMETABLE *pNameTable)
{
    HRESULT hr;
    NAMEENTRY *pNameEntryAlloc = NULL;
    NAMEENTRY *pNameEntry;
    DWORD cbString;
    BYTE *pbString;
    DWORD i;
    DWORD j;
    char szTest[2];

    pNameEntryAlloc = (NAMEENTRY *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    sizeof(NAMEENTRY) * g_crdnSubject);

    if (NULL == pNameEntryAlloc)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pNameTable->cnt = g_crdnSubject;
    pNameTable->pNameEntry = pNameEntryAlloc;

    szTest[0] = 'a';
    szTest[1] = '\0';

    for (i = 0; i < g_crdnSubject; i++)
    {
	pNameEntry = &pNameTable->pNameEntry[i];
        pNameEntry->pszObjId = g_ardnSubject[i].pszObjId;
        pNameEntry->BerTag = g_ardnSubject[i].BerTag;

        pbString = (BYTE *) LocalAlloc(LMEM_FIXED, sizeof(szTest));
        if (NULL == pbString)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(pbString, szTest, sizeof(szTest));
        pNameEntry->cbData = sizeof(szTest) - 1;
        pNameEntry->pbData = pbString;
	if ('z' == szTest[0])
	{
	    szTest[0] = 'a';
	}
	else
	{
	    szTest[0]++;
	}
    }
    pNameEntryAlloc = NULL;
    hr = S_OK;

error:
    if (NULL != pNameEntryAlloc)
    {
	FreeLocalMemory(pNameTable);
    }
    return(hr);
}


BOOL
PreparePrivateKeyForImport(
    IN BYTE *pbBlob,
    IN DWORD cbBlob,
    OUT BSAFE_PRV_KEY *pPriKey,
    IN OUT DWORD *pcbPriKey,
    OUT BSAFE_PUB_KEY *pPubKey,
    IN OUT DWORD *pcbPubKey)
{
    EXPORT_PRV_KEY *pExportKey = (EXPORT_PRV_KEY *) pbBlob;
    DWORD cbHalfModLen;
    DWORD cbPub;
    DWORD cbPri;
    BYTE *pbIn;
    BYTE *pbOut;

    if (RSA2 != pExportKey->magic)
    {
        return(FALSE);
    }
    cbHalfModLen = pExportKey->bitlen / 16;

    cbPub = sizeof(BSAFE_PUB_KEY) + (cbHalfModLen + sizeof(DWORD)) * 2;
    cbPri = sizeof(BSAFE_PRV_KEY) + (cbHalfModLen + sizeof(DWORD)) * 10;
    if (NULL == pPriKey || NULL == pPubKey)
    {
        *pcbPubKey = cbPub;
        *pcbPriKey = cbPri;
        return(TRUE);
    }

    if (*pcbPubKey < cbPub || *pcbPriKey < cbPri)
    {
        *pcbPubKey = cbPub;
        *pcbPriKey = cbPri;
        return(FALSE);
    }
    else
    {
        // form the public key
        ZeroMemory(pPubKey, *pcbPubKey);
        pPubKey->magic = RSA1;
        pPubKey->keylen = (cbHalfModLen + sizeof(DWORD)) * 2;
        pPubKey->bitlen = pExportKey->bitlen;
        pPubKey->datalen = cbHalfModLen * 2 - 1;
        pPubKey->pubexp = pExportKey->pubexp;

        pbIn = pbBlob + sizeof(EXPORT_PRV_KEY);
        pbOut = (BYTE *) pPubKey + sizeof(BSAFE_PUB_KEY);

        CopyMemory(pbOut, pbIn, cbHalfModLen * 2);

        // form the private key
        ZeroMemory(pPriKey, *pcbPriKey);
        pPriKey->magic = pExportKey->magic;
        pPriKey->keylen = (cbHalfModLen + sizeof(DWORD)) * 2;
        pPriKey->bitlen = pExportKey->bitlen;
        pPriKey->datalen = cbHalfModLen * 2 - 1;
        pPriKey->pubexp = pExportKey->pubexp;

        pbOut = (BYTE *) pPriKey + sizeof(BSAFE_PRV_KEY);

        CopyMemory(pbOut, pbIn, cbHalfModLen * 2);

        pbOut += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbIn += cbHalfModLen * 2;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen);

        pbOut += cbHalfModLen + sizeof(DWORD);
        pbIn += cbHalfModLen;
        CopyMemory(pbOut, pbIn, cbHalfModLen * 2);
    }
    *pcbPubKey = cbPub;
    *pcbPriKey = cbPri;
    return(TRUE);
}


HRESULT
GetPrivateKeyStuff(
    PctPrivateKey **ppKey)
{
    HRESULT hr;
    BYTE *pbData;
    PctPrivateKey *pKey = NULL;
    HCRYPTKEY hKey = NULL;

    if (!CryptAcquireContext(
			&g_hMe,
			g_wszTestKey,
			MS_DEF_PROV,
			PROV_RSA_FULL,
			CRYPT_DELETEKEYSET))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptAcquireContext");
    }

    if (!CryptAcquireContext(
			&g_hMe,
			g_wszTestKey,
			MS_DEF_PROV,
			PROV_RSA_FULL,
			CRYPT_NEWKEYSET))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (!CryptGetUserKey(g_hMe, AT_SIGNATURE, &hKey))
    {
	hr = myHLastError();
	_PrintError2(hr, "CryptGetUserKey", hr);

        if (!CryptGenKey(g_hMe, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKey))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "CryptGenKey");
        }
    }

    g_cbPrivateKey = sizeof(g_CAPIPrivateKey);

    if (!CryptExportKey(
		    hKey,
		    0,
		    PRIVATEKEYBLOB,
		    0L,
		    &g_CAPIPrivateKey[0],
		    &g_cbPrivateKey))
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptExportKey");
    }

    pbData = &g_CAPIPrivateKey[sizeof(BLOBHEADER)];

    if (!PreparePrivateKeyForImport(
				pbData,
				g_cbPrivateKey - sizeof(BLOBHEADER),
				NULL,
				&g_cbRSAPrivateKey,
				NULL,
				&g_cbRSAPublicKey))
    {
        hr = NTE_BAD_KEY;
	_JumpError(hr, error, "PreparePrivateKeyForImport");
    }

    pKey = (PctPrivateKey *) LocalAlloc(
				LMEM_FIXED,
				g_cbRSAPrivateKey + sizeof(PctPrivateKey));

    g_pRSAPublicKey = (BSAFE_PUB_KEY *) LocalAlloc(
					    LMEM_FIXED,
					    g_cbRSAPublicKey);

    if (pKey == NULL || g_pRSAPublicKey == NULL)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pKey->cbKey = g_cbRSAPrivateKey;
    if (!PreparePrivateKeyForImport(
				pbData,
				g_cbPrivateKey - sizeof(BLOBHEADER),
				(BSAFE_PRV_KEY *) pKey->pKey,
				&g_cbRSAPrivateKey,
				g_pRSAPublicKey,
				&g_cbRSAPublicKey))
    {
        hr = NTE_BAD_KEY;
	_JumpError(hr, error, "PreparePrivateKeyForImport");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    *ppKey = pKey;
    return(hr);
}


VOID
ReverseMemCopy(
    OUT BYTE *pbDest,
    IN BYTE const *pbSource,
    IN DWORD cb)
{
    BYTE *pb;

    pb = pbDest + cb - 1;
    do
    {
        *pb-- = *pbSource++;
    } while (pb >= pbDest);
}


BOOL WINAPI
SigRSAMD5Sign(
    IN BYTE *pbData,
    IN DWORD cbData,
    OUT BYTE *pbSigned,
    OUT DWORD *pcbSigned,
    IN PctPrivateKey const *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *) pKey->pKey;
    BYTE LocalBuffer[300];
    BYTE LocalOutput[300];
    DWORD cb;

    //DumpHex(pbData, cbData);
    if (pk->datalen > sizeof(LocalBuffer)) 
    {
        return(FALSE);
    }

    // Generate the checksum
    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pbData, cbData);
    MD5Final(&DigCtx);

    FillMemory(LocalBuffer, pk->keylen, 0);

    ReverseMemCopy(LocalBuffer, DigCtx.digest, 16);
    ReverseMemCopy(LocalBuffer + 16, MD5_PRELUDE, sizeof(MD5_PRELUDE));
    cb = sizeof(MD5_PRELUDE) + 16;
    LocalBuffer[cb++] = 0;
    while (cb < pk->datalen - 1)
    {
        LocalBuffer[cb++] = 0xff;
    }

    // Make into pkcs block type 1
    LocalBuffer[pk->datalen - 1] = 1;

    *pcbSigned = pk->datalen + 1;

    if (!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return(FALSE);
    }
    ReverseMemCopy(pbSigned, LocalOutput,  *pcbSigned);
    //DumpHex(pbSigned, *pcbSigned);
    return(TRUE);
}


long
EncodeSubjectPubKeyInfo(
    IN PctPrivateKey const *pKey,
    OUT BYTE *pbBuffer)
{
    BYTE *pbEncoded;
    LONG cbResult;
    LONG cbResultHeader;
    LONG PkResult;
    LONG PkResultHeader;
    BYTE *pbSave;
    BYTE *pbBitString;
    BYTE *pbBitStringBase;
    BYTE *pbTop;
    DWORD EstimatedLength;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *) pKey->pKey;

    // Encode public key now...

    EstimatedLength = pk->datalen + 32;

    pbEncoded = pbBuffer;

    cbResultHeader = EncodeHeader(pbEncoded, EstimatedLength);
    pbEncoded += cbResultHeader;

    pbTop = pbEncoded;

    cbResult = EncodeAlgorithm(pbEncoded, ALGTYPE_KEYEXCH_RSA_MD5);
    if (0 > cbResult)
    {
        return(-1);
    }
    pbEncoded += cbResult;

    // now, serialize the rsa key data:

    pbBitString = (BYTE *) LocalAlloc(LMEM_FIXED, EstimatedLength);
    if (NULL == pbBitString)
    {
        return(-1);
    }
    pbBitStringBase = pbBitString;

    // Encode the Sequence header, public key base and exponent as integers

    PkResultHeader = EncodeHeader(pbBitString, EstimatedLength);
    pbBitString += PkResultHeader;

    pbSave = pbBitString;

    PkResult = EncodeInteger(pbBitString, (BYTE *) (pk + 1), pk->keylen);
    pbBitString += PkResult;

    PkResult = EncodeInteger(pbBitString, (BYTE *) &pk->pubexp, sizeof(DWORD));
    pbBitString += PkResult;

    // Rewrite the bitstring header with an accurate length.

    PkResult = EncodeHeader(
			pbBitStringBase,
			SAFE_SUBTRACT_POINTERS(pbBitString, pbSave));

    // Encode the public key sequence as a raw bitstring, and free the memory.

    cbResult = EncodeBitString(
			pbEncoded,
			pbBitStringBase,
			SAFE_SUBTRACT_POINTERS(pbBitString, pbBitStringBase));
    pbEncoded += cbResult;

    LocalFree(pbBitStringBase);

    // Rewrite the header with an accurate length.

    cbResult = EncodeHeader(pbBuffer, SAFE_SUBTRACT_POINTERS(pbEncoded, pbTop));

    return(cbResult + SAFE_SUBTRACT_POINTERS(pbEncoded, pbTop));
}


#if 0
a0 <len>		BER_OPTIONAL | 0 -- Request Attributes
    30 <len>		BER_SEQUENCE
	06 <len>	BER_OBJECT_ID -- szOID_CERT_EXTENSIONS
	31 <len>	BER_SET
	    30 <len>	BER_SEQUENCE
		30 <len>	BER_SEQUENCE	(extension[0])
		    06 <len> BER_OBJECT_ID
		    01 <len> BER_BOOL (Optional)
		    04 <len> BER_OCTET_STRING

		30 <len>	BER_SEQUENCE	(extension[1])
		    06 <len> BER_OBJECT_ID
		    04 <len> BER_OCTET_STRING

		30 <len>	BER_SEQUENCE	(extension[2])
		    06 <len> BER_OBJECT_ID
		    04 <len> BER_OCTET_STRING
#endif


long
AllocEncodeUnicodeString(
    IN WCHAR const *pwszCertType,
    OUT BYTE **ppbOut)
{
    BYTE *pb = NULL;
    LONG cb;

    cb = EncodeUnicodeString(NULL, pwszCertType);
    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == pb)
    {
	cb = -1;
	goto error;
    }
    *ppbOut = pb;
    EncodeUnicodeString(pb, pwszCertType);

error:
    return(cb);
}


long
AllocEncodeExtensionArray(
    IN DWORD cExt,
    IN CERT_EXTENSION const *aExt,
    OUT BYTE **ppbExtensions)
{
    BYTE *pb;
    DWORD i;
    LONG cb;
    LONG cbExtTotal;
    LONG acbLen[3];
    LONG *acbExt = NULL;

    *ppbExtensions = NULL;

    acbExt = (LONG *) LocalAlloc(LMEM_FIXED, cExt * sizeof(acbExt[0]));
    if (NULL == acbExt)
    {
	cbExtTotal = -1;
	_JumpError(-1, error, "LocalAlloc");
    }

    // Construct size from the bottom up.

    cbExtTotal = 0;
    for (i = 0; i < cExt; i++)
    {
	// BER_OBJECT_ID: Extension OID

	cb = EncodeObjId(NULL, aExt[i].pszObjId);
	if (-1 == cb)
	{
	    _JumpError(-1, error, "EncodeObjId");
	}
	acbExt[i] = cb;

	if (aExt[i].fCritical)
	{
	    // BER_BOOL: fCritical

	    acbExt[i] += 1 + EncodeLength(NULL, 1);
	    acbExt[i]++;			// boolean value
	}

	// BER_OCTET_STRING: Extension octet string value
	
	acbExt[i] += 1 + EncodeLength(NULL, aExt[i].Value.cbData);
	acbExt[i] += aExt[i].Value.cbData;	// octet string

	// BER_SEQUENCE: Extension Sequence

	cbExtTotal += 1 + EncodeLength(NULL, acbExt[i]);
	cbExtTotal += acbExt[i];
    }

    // BER_SEQUENCE: Extension Array Sequence

    acbLen[2] = cbExtTotal;
    cbExtTotal += 1 + EncodeLength(NULL, cbExtTotal);

    // BER_SET: Attribute Value

    acbLen[1] = cbExtTotal;
    cbExtTotal += 1 + EncodeLength(NULL, cbExtTotal);

    // BER_OBJECT_ID: Attribute OID

    cb = EncodeObjId(NULL, szOID_CERT_EXTENSIONS);
    if (-1 == cb)
    {
	_JumpError(-1, error, "EncodeObjId");
    }
    cbExtTotal += cb;

    // BER_SEQUENCE: Attribute Array Sequence

    acbLen[0] = cbExtTotal;
    cbExtTotal += 1 + EncodeLength(NULL, cbExtTotal);

    // Allocate memory and encode the extensions

    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cbExtTotal);
    if (NULL == pb)
    {
	cbExtTotal = -1;
	_JumpError(-1, error, "LocalAlloc");
    }
    *ppbExtensions = pb;

    *pb++ = BER_SEQUENCE;		// Attribute Array Sequence
    pb += EncodeLength(pb, acbLen[0]);

    pb += EncodeObjId(pb, szOID_CERT_EXTENSIONS);

    *pb++ = BER_SET;			// Attribute Value
    pb += EncodeLength(pb, acbLen[1]);

    *pb++ = BER_SEQUENCE;		// Extension Array Sequence
    pb += EncodeLength(pb, acbLen[2]);

    CSASSERT(*ppbExtensions + cbExtTotal >= pb);

    for (i = 0; i < cExt; i++)
    {
	CSASSERT(*ppbExtensions + cbExtTotal > pb);

	*pb++ = BER_SEQUENCE;		// Extension Sequence
	pb += EncodeLength(pb, acbExt[i]);

	// BER_OBJECT_ID: Extension OID

	pb += EncodeObjId(pb, aExt[i].pszObjId);

	if (aExt[i].fCritical)
	{
	    *pb++ = BER_BOOL;		// fCritical
	    pb += EncodeLength(pb, 1);
	    *pb++ = 0xff;
	}

	*pb++ = BER_OCTET_STRING;	// Extension octet string value
	pb += EncodeLength(pb, aExt[i].Value.cbData);

	CopyMemory(pb, aExt[i].Value.pbData, aExt[i].Value.cbData);
	pb += aExt[i].Value.cbData;
    }
    CSASSERT(*ppbExtensions + cbExtTotal == pb);

error:
    if (NULL != acbExt)
    {
	LocalFree(acbExt);
    }
    return(cbExtTotal);
}


long
EncodeExtensions(
    IN WCHAR const *pwszCertType,
    OUT BYTE **ppbExtensions)
{
    LONG cbExt;
    BYTE *pbExt = NULL;
    CERT_EXTENSION aExt[1];
    DWORD cExt = 0;
    DWORD i;

    // Allocate memory and construct the CertType extension:

    aExt[cExt].pszObjId = szOID_ENROLL_CERTTYPE_EXTENSION;
    aExt[cExt].fCritical = FALSE;
    aExt[cExt].Value.cbData = AllocEncodeUnicodeString(
						pwszCertType,
						&aExt[cExt].Value.pbData);
    //DumpHex(aExt[cExt].Value.pbData, aExt[cExt].Value.cbData);
    cExt++;


    cbExt = AllocEncodeExtensionArray(cExt, aExt, ppbExtensions);
    if (-1 == cbExt)
    {
	_JumpError(-1, error, "AllocEncodeExtensionArray");
    }

error:
    for (i = 0; i < cExt; i++)
    {
	if (NULL != aExt[i].Value.pbData)
	{
	    LocalFree(aExt[i].Value.pbData);
	}
    }
    return(cbExt);
}


HRESULT
EncodeRequest(
    IN PctPrivateKey const *pKey,
    IN NAMETABLE const *pNameTable,
    OUT BYTE **ppbRequest,
    OUT DWORD *pcbRequest)
{
    HRESULT hr;
    BYTE *pbRequest0Alloc = NULL;
    BYTE *pbRequest1Alloc = NULL;
    BYTE *pbSigAlloc = NULL;

    BYTE *pbRequest0;

    BYTE *pbSave;
    BYTE *pbEncoded;

    BYTE *pbExt;
    LONG cbExt;

    LONG cbResult;
    LONG cbEncoded;
    BYTE bZero;
    LONG cbDN;
    DWORD cbRequest0;
    DWORD cbRequest1;
    LONG cbLenRequest;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *) pKey->pKey;

    cbExt = EncodeExtensions(L"User", &pbExt);
    if (-1 == cbExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeExtensions");
    }
    //DumpHex(pbExt, cbExt);

    cbDN = EncodeDN(NULL, pNameTable);
    if (-1 == cbDN)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeDN");
    }
    cbRequest0 = pk->datalen + 32 + cbDN + 16 + cbExt + 3;
    pbRequest0Alloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest0);
    if (NULL == pbRequest0Alloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pbRequest0 = pbRequest0Alloc;
    pbEncoded = pbRequest0;

    // Encode BER_SEQUENCE: Version+Subject+Key+Attributes Sequence

    cbLenRequest = EncodeHeader(pbEncoded, cbRequest0);
    pbEncoded += cbLenRequest;

    pbSave = pbEncoded;		// Save pointer past sequence length

    // Encode integer 0: Version 1 PKCS10

    bZero = (BYTE) CERT_REQUEST_V1;
    pbEncoded += EncodeInteger(pbEncoded, &bZero, sizeof(bZero));

    // Encode sequence of names

    cbResult = EncodeDN(pbEncoded, pNameTable);
    if (0 > cbResult)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeDN");
    }
    pbEncoded += cbResult;

    cbResult = EncodeSubjectPubKeyInfo(pKey, pbEncoded);
    if (0 > cbResult)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "EncodeSubjectPubKeyInfo");
    }
    pbEncoded += cbResult;

    // Encode attributes:
    // BER_OPTIONAL | 0: Attribute Field

    cbResult = EncodeAttributeHeader(pbEncoded, cbExt);
    pbEncoded += cbResult;
    CopyMemory(pbEncoded, pbExt, cbExt);
    pbEncoded += cbExt;

    // Encode BER_SEQUENCE: Version+Subject+Key+Attributes Sequence (again)

    cbEncoded = SAFE_SUBTRACT_POINTERS(pbEncoded, pbSave);
    cbResult = EncodeHeader(pbRequest0, cbEncoded);

    // If the header sequence length takes up less space than we anticipated,
    // add the difference to the base pointer and encode the header again,
    // right before the encoded data.

    if (cbResult != cbLenRequest)
    {
        CSASSERT(cbResult < cbLenRequest);
	pbRequest0 += cbLenRequest - cbResult;

	// Encode BER_SEQUENCE: Version+Subject+Key+Attributes Sequence (again)

	cbResult = EncodeHeader(pbRequest0, cbEncoded);
    }

    cbRequest0 = cbResult + SAFE_SUBTRACT_POINTERS(pbEncoded, pbSave);
    //DumpHex(pbRequest0, cbRequest0);

    // How much space do we need?

    cbRequest1 = cbRequest0 + pk->datalen + 32;
    pbRequest1Alloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest1);
    if (NULL == pbRequest1Alloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pbEncoded = pbRequest1Alloc;

    // Encode BER_SEQUENCE: outer Request Sequence

    cbLenRequest = EncodeHeader(pbEncoded, cbRequest1);
    pbEncoded += cbLenRequest;

    pbSave = pbEncoded;		// Save pointer past outer sequence length

    CopyMemory(pbEncoded, pbRequest0, cbRequest0);

    pbEncoded += cbRequest0;

    cbResult = EncodeAlgorithm(pbEncoded, ALGTYPE_SIG_RSA_MD5);
    pbEncoded += cbResult;

    //DumpHex(pbRequest1Alloc, cbRequest1);

    cbResult = pk->datalen + 16;
    pbSigAlloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbResult);
    if (NULL == pbSigAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!SigRSAMD5Sign(
	    pbRequest0,
	    cbRequest0,
	    pbSigAlloc,
	    (DWORD *) &cbResult,
	    pKey))
    {
	hr = E_FAIL;
	_JumpError(hr, error, "SigRSAMD5Sign");
    }

    pbEncoded += EncodeBitString(pbEncoded, pbSigAlloc, cbResult);

    cbEncoded = SAFE_SUBTRACT_POINTERS(pbEncoded, pbSave);
    cbResult = EncodeHeader(pbRequest1Alloc, cbEncoded);
    cbRequest1 = cbResult + cbEncoded;

    if (cbResult != cbLenRequest)
    {
        if (cbResult > cbLenRequest)
        {
	    // The chunk has actually grown from the estimate.

            BYTE *pbT;
	    
            pbT = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest1);
            if (NULL == pbT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

	    EncodeHeader(pbT, cbEncoded);
	    CopyMemory(
		    pbT + cbResult,
		    pbSave,
		    cbEncoded);

	    LocalFree(pbRequest1Alloc);
	    pbRequest1Alloc = pbT;
        }
        else
        {
	    cbResult = EncodeHeader(pbRequest1Alloc, cbEncoded);
            MoveMemory(
		pbRequest1Alloc + cbResult,
		pbRequest1Alloc + cbLenRequest,
		cbEncoded);
        }
    }
    *ppbRequest = pbRequest1Alloc;
    *pcbRequest = cbRequest1;
    pbRequest1Alloc = NULL;
    //DumpHex(*ppbRequest, *pcbRequest);
    hr = S_OK;

error:
    if (NULL != pbSigAlloc)
    {
	LocalFree(pbSigAlloc);
    }
    if (NULL != pbRequest1Alloc)
    {
	LocalFree(pbRequest1Alloc);
    }
    if (NULL != pbRequest0Alloc)
    {
	LocalFree(pbRequest0Alloc);
    }
    if (NULL != pbExt)
    {
	LocalFree(pbExt);
    }
    return(hr);
}


HRESULT
GetAndCompareProperty(
    CERT_NAME_INFO *pNameInfo,
    char const *pszObjId,
    char const *pszValue,
    BYTE **pbProp,
    DWORD *pcbProp,
    BOOL *pfMatch)
{
    HRESULT hr;
    CERT_RDN_ATTR *prdnaT;
    CERT_RDN *prdn;
    CERT_RDN *prdnEnd;

    *pfMatch = FALSE;
    prdnaT = NULL;
    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    if (0 == strcmp(prdna->pszObjId, pszObjId))
	    {
		prdnaT = prdna;

		if (prdnaT->Value.cbData == strlen(pszValue) &&
		    0 == memcmp(pszValue, prdnaT->Value.pbData, prdnaT->Value.cbData))
		{
		    *pfMatch = TRUE;
		}
		else if (g_fAllowDups)
		{
		    continue;
		}
		prdn = prdnEnd;	// exit outer for loop, too.
		break;
	    }
	}
    }
    if (NULL == prdnaT)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "Missing Property", CERTSRV_E_PROPERTY_EMPTY);
    }
    *pbProp = prdnaT->Value.pbData;
    *pcbProp = prdnaT->Value.cbData;
    hr = S_OK;

error:
    return(hr);

}


HRESULT
CheckProperties(
    DWORD ReqId,
    NAMETABLE *pNameTable,
    DWORD CertNumber,
    CERT_NAME_INFO *pNameInfo)
{
    HRESULT hr;
    BYTE *pbProp;
    DWORD cbProp;
    DWORD i;
    DWORD dwCount = 0;
    BOOL fMatch;

    if (g_fPrintProperties)
    {
        wprintf(
	    L"Properties for Certificate %u, RequestId %u:\n",
	    CertNumber,
	    ReqId);
    }

    for (i = 0; i < pNameTable->cnt; i++)
    {
	NAMEENTRY *pNameEntry;
	RDNENTRY *prdn;

	pNameEntry = &pNameTable->pNameEntry[i];
	prdn = &g_ardnSubject[pNameEntry->iRDN];

        hr = GetAndCompareProperty(
		    pNameInfo,
		    prdn->pszObjId,
		    (char const *) pNameEntry->pbData,
		    &pbProp,
		    &cbProp,
		    &fMatch);

        if (CERTSRV_E_PROPERTY_EMPTY == hr)
        {
	    //_PrintError(hr, "GetAndCompareProperty");
	    pbProp = NULL;
            hr = S_OK;
        }
	_JumpIfError(hr, error, "GetAndCompareProperty");

        if (NULL != pbProp && !fMatch)
        {
	    wprintf(
		L"Property doesn't match: Expected %hs=\"%hs\", pbProp = \"%hs\"\n",
		prdn->pszShortName,
		pNameEntry->pbData,
		pbProp);

            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "GetAndCompareProperty: no match");
        }

        if (g_fPrintProperties)
        {
	    DWORD ccol;

#define CCOL_OID 10
	    ccol = strlen(prdn->pszObjId) + 1;
	    if (ccol < CCOL_OID)
	    {
		ccol = CCOL_OID - ccol;
	    }
	    else
	    {
		ccol = 0;
	    }
            wprintf(
		L"  %u: %hs: %*s%hs=%hs%hs%hs\n",
		i,
		prdn->pszObjId,
		ccol,
		"",
		prdn->pszShortName,
		NULL == pbProp? "" : "\"",
		NULL == pbProp? " -- MISSING --" : (char const *) pbProp,
		NULL == pbProp? "" : "\"");
        }
    }
    if (g_fPrintProperties)
    {
        wprintf(L"\n");
    }
    hr = S_OK;

error:
    return(hr);

}


HRESULT
EncodeRenewal(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OUT BYTE **ppbRenewal,
    OUT DWORD *pcbRenewal)
{
    HRESULT hr;

    *ppbRenewal = (BYTE *) LocalAlloc(LMEM_FIXED, cbRequest);
    if (NULL == *ppbRenewal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppbRenewal, pbRequest, cbRequest);
    *pcbRenewal = cbRequest;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
SubmitRequest(
    OPTIONAL IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszConfig,
    OUT DWORD *pRequestIdOut,
    OUT DWORD *pDisposition,
    OUT HRESULT *phrLastStatus,
    OUT WCHAR **ppwszDisposition,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert)
{
    HRESULT hr;
    WCHAR *pwszRequest = NULL;
    BSTR strCert = NULL;
    BSTR strCertChain = NULL;
    BSTR strDisposition = NULL;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    BYTE const *pbChain;
    DWORD cbChain;
    CERTSERVERENROLL *pcsEnroll = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszAuthority = NULL;
    WCHAR *pwszDisposition;

    *phrLastStatus = S_OK;
    *ppwszDisposition = NULL;
    *ppbCert = NULL;
    *pRequestIdOut = 0;

    if (NULL == pdiRequest)
    {
	hr = mySplitConfigString(pwszConfig, &pwszServer, &pwszAuthority);
	_JumpIfError(hr, error, "mySplitConfigString");

	// CertServerSubmitRequest can only handle binary requests;
	// pass the request in binary form, and pass Flags to so indicate.

	hr = CertServerSubmitRequest(
				CR_IN_BINARY | Flags,
				pbRequest,
				cbRequest,
				pwszAttributes,
				pwszServer,
				pwszAuthority,
				&pcsEnroll);
	_JumpIfError(hr, error, "CertServerSubmitRequest");

	*phrLastStatus = pcsEnroll->hrLastStatus;
	_PrintIfError2(
		*phrLastStatus,
		"pcsEnroll->hrLastStatus Real Status",
		HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

	pwszDisposition = pcsEnroll->pwszDispositionMessage;
	*pDisposition = pcsEnroll->Disposition;
	*pRequestIdOut = pcsEnroll->RequestId;
    }
    else
    {
	hr = myCryptBinaryToString(
			    pbRequest,
			    cbRequest,
			    CRYPT_STRING_BASE64REQUESTHEADER,
			    &pwszRequest);
	_JumpIfError(hr, error, "myCryptBinaryToString");

	if (g_fRPC)
	{
	    Flags |= CR_IN_RPC;
	}
	hr = Request_Submit(
			pdiRequest,
			CR_IN_BASE64HEADER | Flags,
			pwszRequest,
			sizeof(WCHAR) * wcslen(pwszRequest),
			pwszAttributes,
			pwszConfig,
			(LONG *) pDisposition);
	if (S_OK != hr)
	{
	    _PrintError2(
		    hr,
		    "Request_Submit",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

	    // Collect the RequestId for potential error reporting:
	    Request_GetRequestId(pdiRequest, (LONG *) pRequestIdOut);

	    hr = Request_GetLastStatus(pdiRequest, phrLastStatus);
	    _JumpIfError(hr, error, "Request_GetLastStatus");

	    if (FAILED(*phrLastStatus))
	    {
		hr = *phrLastStatus;
	    }
	    _JumpError2(
		    hr,
		    error,
		    "Request_GetLastStatus Real Status",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	}
	hr = Request_GetLastStatus(pdiRequest, phrLastStatus);
	_JumpIfError(hr, error, "Request_GetLastStatus");

	_PrintIfError(*phrLastStatus, "Request_GetLastStatus Real Status");

	hr = Request_GetDispositionMessage(pdiRequest, &strDisposition);
	_JumpIfError(hr, error, "Request_GetDispositionMessage");

	hr = Request_GetRequestId(pdiRequest, (LONG *) pRequestIdOut);
	_JumpIfError(hr, error, "Request_GetrequestId");

	pwszDisposition = strDisposition;
    }

    if (CR_DISP_ISSUED == *pDisposition)
    {
	if (NULL == pdiRequest)
	{
	    cbCert = pcsEnroll->cbCert;
	    pbCert = (BYTE *) LocalAlloc(LMEM_FIXED, cbCert);
	    if (NULL == pbCert)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pbCert, pcsEnroll->pbCert, cbCert);
	}
	else
	{
	    hr = Request_GetCertificate(
				    pdiRequest,
				    CR_OUT_BASE64HEADER,
				    &strCert);
	    _JumpIfError(hr, error, "Request_GetCertificate");

	    hr = myCryptStringToBinary(
				strCert,
				wcslen(strCert),
				CRYPT_STRING_BASE64HEADER,
				&pbCert,
				&cbCert,
				NULL,
				NULL);
	    _JumpIfError(hr, error, "myCryptStringToBinary");
	}

	if (g_fSave)
	{
	    hr = EncodeToFileW(
			L"test.crt",
			pbCert,
			cbCert,
			DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
	    _JumpIfError(hr, error, "EncodeToFileW");

	    if (NULL == pdiRequest)
	    {
		pbChain = pcsEnroll->pbCertChain;
		cbChain = pcsEnroll->cbCertChain;
	    }
	    else
	    {
		hr = Request_GetCertificate(
					pdiRequest,
					CR_OUT_BINARY | CR_OUT_CHAIN,
					&strCertChain);
		_JumpIfError(hr, error, "Request_GetCertificate");

		pbChain = (BYTE const *) strCertChain;
		cbChain = SysStringByteLen(strCertChain);
	    }
	    hr = EncodeToFileW(
			L"testchain.crt",
			pbChain,
			cbChain,
			DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
	    _JumpIfError(hr, error, "EncodeToFileW");
	}
    }

    if (NULL != pwszDisposition)
    {
	*ppwszDisposition = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(pwszDisposition) + 1) * sizeof(WCHAR));
	if (NULL == *ppwszDisposition)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(*ppwszDisposition, pwszDisposition);
    }
    *pcbCert = cbCert;
    *ppbCert = pbCert;
    pbCert = NULL;
    hr = S_OK;

error:
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszAuthority)
    {
	LocalFree(pwszAuthority);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pcsEnroll)
    {
	CertServerFreeMemory(pcsEnroll);
    }
    if (NULL != strCertChain)
    {
	SysFreeString(strCertChain);
    }
    if (NULL != strCert)
    {
	SysFreeString(strCert);
    }
    if (NULL != strDisposition)
    {
	SysFreeString(strDisposition);
    }
    if (NULL != pwszRequest)
    {
	LocalFree(pwszRequest);
    }
    return(hr);
}


HRESULT
TestOneRequest(
    IN PctPrivateKey const *pKey,
    OPTIONAL IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN DWORD CertNumber,
    OUT DWORD *pRequestId,
    OUT DWORD *pTimeOneRequest)
{
    HRESULT hr;
    HRESULT hrLastStatus;
    NAMETABLE NameTable;
    BOOL fTableAllocated;
    BYTE *pbRequest;
    DWORD cbRequest;
    BYTE *pbCert;
    DWORD cbCert;
    CERT_CONTEXT const *pCertContext;
    DWORD RequestIdOut = 0;
    DWORD Disposition;
    WCHAR *pwszDisposition = NULL;
    CERT_NAME_INFO *pNameInfo;
    DWORD cbNameInfo;
    CERT_INFO const *pCertInfo;
    LONG Flags;
    WCHAR wszAttributes[MAX_PATH];

    fTableAllocated = FALSE;
    pbRequest = NULL;
    pbCert = NULL;
    pCertContext = NULL;
    pNameInfo = NULL;

    if (g_fDebug)
    {
	hr = GenerateTestNameTable(&NameTable);
	_JumpIfError(hr, error, "GenerateTestNameTable");
    }
    else
    {
	hr = GenerateNameTable(&NameTable);
	_JumpIfError(hr, error, "GenerateNameTable");
    }

    fTableAllocated = TRUE;

    hr = EncodeRequest(pKey, &NameTable, &pbRequest, &cbRequest);
    _JumpIfError(hr, error, "EncodeRequest");

    Flags = CR_IN_PKCS10;

    if (g_fRenewal)
    {
	BYTE *pbTmp;

	hr = EncodeRenewal(pbRequest, cbRequest, &pbTmp, &cbRequest);
	_JumpIfError(hr, error, "EncodeRenewal");

	LocalFree(pbRequest);
	pbRequest = pbTmp;
	Flags = CR_IN_PKCS7;
    }

    if (g_fSave)
    {
	hr = EncodeToFileW(
		    L"test.req",
		    pbRequest,
		    cbRequest,
		    DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
	_JumpIfError(hr, error, "EncodeToFileW");
    }

    *pTimeOneRequest = 0 - GetTickCount();

    wsprintf(
	wszAttributes,
	L"\n"
	    L" attrib 1 end : value 1 end \t\r\n"
	    L"\tattrib 2 end:value_2_end\n"
	    L" \tattrib3:value-3-end\r\n"
	    L"Version:3\n"
	    L"RequestType:CertGen\n"
	    L"CertGenSequence:%u\n",
	CertNumber);

    hr = SubmitRequest(
		    pdiRequest,
		    Flags,
		    pbRequest,
		    cbRequest,
		    wszAttributes,
		    pwszConfig,
		    &RequestIdOut,
		    &Disposition,
		    &hrLastStatus,
		    &pwszDisposition,
		    &pbCert,
		    &cbCert);

    *pTimeOneRequest += GetTickCount();

    if (S_OK != hr)
    {
	_JumpError2(
		hr,
		error,
		"SubmitRequest",
		HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }
    if (CR_DISP_ISSUED != Disposition)
    {
	hr = hrLastStatus;
	if (S_OK == hr)
	{
	    hr = E_FAIL;
	}
	wprintf(
	    L"SubmitRequest disposition=%x hr=%x (%ws)\n",
	    Disposition,
	    hr,
	    NULL == pwszDisposition? L"???" : pwszDisposition);

	if (g_fIgnoreError)
	{
	    hr = S_OK;
	}
	if (CR_DISP_DENIED == Disposition && g_fIgnoreAccessDenied)
	{
	    hr = S_OK;
	}
	_JumpError(hr, error, "Cert not issued!");
    }

    pCertContext = CertCreateCertificateContext(
					    X509_ASN_ENCODING,
					    pbCert,
					    cbCert);
    if (NULL == pCertContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    pCertInfo = pCertContext->pCertInfo;

    if (!myDecodeName(
		    X509_ASN_ENCODING,
		    X509_NAME,
		    pCertInfo->Subject.pbData,
		    pCertInfo->Subject.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    &pNameInfo,
		    &cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    hr = CheckProperties(RequestIdOut, &NameTable, CertNumber, pNameInfo);
    _JumpIfError(hr, error, "CheckProperties");

error:
    *pRequestId = RequestIdOut;
    if (NULL != pwszDisposition)
    {
	LocalFree(pwszDisposition);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pCertContext)
    {
	CertFreeCertificateContext(pCertContext);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pbRequest)
    {
	LocalFree(pbRequest);
    }
    if (fTableAllocated)
    {
	FreeLocalMemory(&NameTable);
    }
    return(hr);
}


HRESULT
TestMain()
{
    HRESULT hr;
    PctPrivateKey *pKey = NULL;
    DWORD TimeStartTest;
    DWORD TimeStartLastN;
    DWORD TimeRequestTotal = 0;
    DWORD TimeRequestLastN = 0;
    DWORD TimeElapsedTotal;
    DWORD TotalCount = 0;
    DISPATCHINTERFACE diRequest;
    DISPATCHINTERFACE *pdiRequest = NULL;
    BOOL fCoInit = FALSE;
    DWORD RequestId = 0;
    WCHAR const *pwszConfig;
    BSTR strConfig = NULL;

    g_crdnMax = g_crdnSubject;
    hr = GetPrivateKeyStuff(&pKey);
    _JumpIfError(hr, error, "GetPrivateKeyStuff");

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    if (1 >= g_fRPC)
    {
	hr = Request_Init(g_DispatchFlags, &diRequest);
	_JumpIfError(hr, error, "Request_Init");

	pdiRequest = &diRequest;
    }
    pwszConfig = g_pwszConfig;
    if (NULL == pwszConfig)
    {
	hr = ConfigGetConfig(g_DispatchFlags, CC_LOCALACTIVECONFIG, &strConfig);
	_JumpIfError(hr, error, "ConfigGetConfig");

	pwszConfig = strConfig;
    }


    TimeStartLastN = TimeStartTest = GetTickCount();
    while (TotalCount < g_MaximumCount)
    {
	DWORD TimeOneRequest;
	DWORD TimeRequestEnd;
	DWORD TimeElapsedLastN;

	hr = TestOneRequest(
			pKey,
			pdiRequest,
			pwszConfig,
			TotalCount + 1,
			&RequestId,
			&TimeOneRequest);
	if (S_OK != hr)
	{
	    WCHAR const *pwszMsg;

	    pwszMsg = myGetErrorMessageText(hr, TRUE);

	    CONSOLEPRINT3((
		    DBG_SS_CERTREQ,
		    "RequestId %u: %hs%ws\n",
		    RequestId,
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr?
			"Ignoring 7f length encoding: " : "",
		    NULL != pwszMsg? pwszMsg : L"Message retrieval Error"));
	    if (NULL != pwszMsg)
	    {
		LocalFree(const_cast<WCHAR *>(pwszMsg));
	    }
	}
	if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) != hr || !g_fIgnoreError)
	{
	    _JumpIfError(hr, error, "TestOneRequest");
	}

	TimeRequestEnd = GetTickCount();

	TimeRequestTotal += TimeOneRequest;
	TimeRequestLastN += TimeOneRequest;
	TimeElapsedTotal = TimeRequestEnd - TimeStartTest;
	TimeElapsedLastN = TimeRequestEnd - TimeStartLastN;

        TotalCount++;

	if (g_fTime)
	{
	    if (0 == g_IntervalCount || 0 == (TotalCount % g_IntervalCount))
	    {
		DWORD count;
		
		count = g_IntervalCount;
		if (0 == count)
		{
		    count = TotalCount;
		}

		TimeElapsedLastN = TimeRequestEnd - TimeStartLastN;

		wprintf(
		    L"RequestId %u: %u/%u Certs in %u/%u seconds (ave=%u/%u ms)\n",
		    RequestId,
		    count,
		    TotalCount,
		    MSTOSEC(TimeElapsedLastN),
		    MSTOSEC(TimeElapsedTotal),
		    TimeElapsedLastN/count,
		    TimeElapsedTotal/TotalCount);
		if (0 != g_IntervalCount)
		{
		    TimeRequestLastN = 0;
		    TimeStartLastN = GetTickCount();
		}
	    }
	}
    }

error:
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (NULL != g_pRSAPublicKey)
    {
	LocalFree(g_pRSAPublicKey);
    }
    if (NULL != pdiRequest)
    {
	Request_Release(pdiRequest);
    }
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (fCoInit)
    {
	CoUninitialize();
    }

    if (0 != TotalCount)
    {
	wprintf(
	    L"\n%u Total Certificates in %u/%u seconds (request/elapsed time)\n",
	    TotalCount,
	    MSTOSEC(TimeRequestTotal),
	    MSTOSEC(TimeElapsedTotal));
	wprintf(
	    L"Certificates required average of %u/%u milliseconds "
		L"(request/elapsed time)\n",
	    TimeRequestTotal/TotalCount,
	    TimeElapsedTotal/TotalCount);
    }
    return(hr);
}


void
Usage(TCHAR *pwszError)
{
    wprintf(L"%ws\n", pwszError);
    wprintf(L"%ws\n", wszUsage);
    exit(1);
}


extern "C" int __cdecl
wmain(int argc, WCHAR *argv[])
{
    HRESULT hr;

    while (1 < argc && ('-' == argv[1][0] || '/' == argv[1][0]))
    {
	WCHAR *pwsz = argv[1];

	while (NULL != pwsz && *++pwsz != '\0')
	{
	    switch (*pwsz)
	    {
		case 'a':
		case 'A':
		    g_fIgnoreAccessDenied++;
		    break;

		case 'c':
		case 'C':
		    if (0 == lstrcmpi(pwsz, L"config"))
		    {
			if (1 >= argc)
			{
			    Usage(TEXT("Missing -config argument"));
			}
			g_pwszConfig = argv[2];
		    }
		    else
		    {
			if (2 >= argc || !iswdigit(argv[2][0]) || '\0' != pwsz[1])
			{
			    Usage(TEXT("Missing numeric -c argument"));
			}
			g_MaximumCount = _wtoi(argv[2]);
		    }
		    argc--;
		    argv++;
		    pwsz = NULL;
		    break;

		case 'd':
		case 'D':
		    g_fDebug++;
		    break;

		case 'i':
		case 'I':
		    g_fIgnoreError++;
		    break;

		case 'r':
		case 'R':
		    if (0 == lstrcmpi(pwsz, L"renewal"))
		    {
			g_fRenewal++;
			pwsz = NULL;
		    }
		    else
		    if (0 == lstrcmpi(pwsz, L"rpc"))
		    {
			g_fRPC++;
			if (0 == lstrcmp(pwsz, L"RPC"))
			{
			    g_fRPC++;
			}
			pwsz = NULL;
		    }
		    else
		    {
			g_fSave++;
		    }
		    break;

		case 'p':
		case 'P':
		    g_fPrintProperties++;
		    break;

		case 't':
		case 'T':
		    g_fTime++;
		    g_IntervalCount = 10;
		    if (2 < argc && iswdigit(argv[2][0]))
		    {
			if ('\0' != pwsz[1])
			{
			    Usage(TEXT("Missing numeric -t argument"));
			}
			g_IntervalCount = _wtoi(argv[2]);
			argc--;
			argv++;
			pwsz = NULL;
		    }
		    break;

		case 'z':
		case 'Z':
		    g_fAllowDups++;
		    g_crdnMax *= 5;
		    break;

		case 'm':
		case 'M':
		    g_fShowTime++;
		    break;

		case 'h':
		case 'H':
		default:
		    Usage(TEXT("CertGen Usage"));
	    }
	}
	argc--;
	argv++;
    }
    if (argc != 1)
    {
	Usage(TEXT("Extra arguments"));
    }

    if (g_fShowTime)
    {
        SYSTEMTIME st;
        GetSystemTime(&st);
        wprintf(L"Start time: %2i:%2i:%2i:%i\n", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    }

    hr = TestMain();

    if (g_fShowTime)
    {
        SYSTEMTIME st;

        GetSystemTime(&st);
        wprintf(L"End time: %2i:%2i:%2i:%i\n", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

        wprintf(L"type any key to finish->");
        _getch();
        wprintf(L"\n");
    }
    myRegisterMemDump();
    return((int) hr);
}


// We need this to include RSA library
extern "C" BOOL
GenRandom(ULONG huid, BYTE *pbBuffer, size_t dwLength)
{
    wprintf(L"Error GenRandom called\n");
    ExitProcess(0);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\enc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       enc.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "encode.h"


OIDTRANSLATE const *
LookupOidTranslate(
    IN CHAR const *pszObjId)
{
    DWORD i;
    OIDTRANSLATE const *pOid = NULL;

    for (i = 0; i < g_cOidTranslate; i++)
    {
	if (0 == strcmp(pszObjId, g_aOidTranslate[i].pszObjId))
	{
	    pOid = &g_aOidTranslate[i];
	    break;
	}
    }
    CSASSERT(NULL != pOid);
    return(pOid);
}


long
EncodeObjId(
    OPTIONAL OUT BYTE *pbEncoded,
    IN CHAR const *pszObjId)
{
    OIDTRANSLATE const *pOid;
    long cbLength;

    pOid = LookupOidTranslate(pszObjId);

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_OBJECT_ID;
    }
    cbLength = EncodeLength(pbEncoded, pOid->cbOIDEncoded);

    if (NULL != pbEncoded)
    {
        CopyMemory(
		pbEncoded + cbLength,
		pOid->abOIDEncoded,
		pOid->cbOIDEncoded);
    }
    return(1 + cbLength + pOid->cbOIDEncoded);
}


//+*************************************************************************
// EncodeLength ASN1 encodes a length field.  The parameter
// dwLen is the length to be encoded, it is a DWORD and    
// therefore may be no larger than 2^32.  The pbEncoded    
// parameter is the encoded result, and memory must be     
// allocated for it by the caller.  The pbEncoded parameter
// indicates if the result is to be written to the pbEncoded
// parameter.  The function cannot fail and returns the    
// number of total bytes in the encoded length.            
// encoded length.                                         
//**************************************************************************

// Notes:	Encodes 0x0000 to 0x007f as <lobyte>
//		Encodes 0x0080 to 0x00ff as <81>, <lobyte>
//		Encodes 0x0100 to 0xffff as <82>, <hibyte>, <lobyte>

long
EncodeLength(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    // length is between 2^8 and 2^16 - 1

    if (dwLen > 0xff)
    {
	if (NULL != pbEncoded)
        {
            pbEncoded[0] = 0x82;
            pbEncoded[1] = (BYTE) (dwLen >> 8);
            pbEncoded[2] = (BYTE) dwLen;
        }
        return(3);
    }

    // length is between 2^7 and 2^8 - 1

    if (dwLen > 0x7f)
    {
	if (NULL != pbEncoded)
        {
            pbEncoded[0] = 0x81;
            pbEncoded[1] = (BYTE) dwLen;
        }
        return(2);
    }

    // length is between 0 and 2^7 - 1

    if (NULL != pbEncoded)
    {
	pbEncoded[0] = (BYTE) dwLen;
    }
    return(1);
}


long
EncodeNull(
    OPTIONAL OUT BYTE *pbEncoded)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_NULL;
        *pbEncoded = 0;
    }
    return(2);
}


//+*************************************************************************
// EncodeAlgid ASN1 encodes an algorithm identifier. The   
// parameter Algid is the algorithm identifier as an ALG_ID
// type.  pbEncoded is the parameter used to pass back the 
// encoded result, and memory must be allocated for it by  
// the caller.  The pbEncoded parameter indicates if the   
// result is to be written to the pbEncoded parameter      
// The function returns a -1 if it fails and otherwise     
// returns the number of total bytes in the encoded        
// algorithm identifier.                                   
//**************************************************************************

long
EncodeAlgid(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD Algid)
{
    DWORD i;
    LONG cb = -1;

    // determine the algorithm id which is to be encoded and
    // copy the appropriate encoded algid into the destination

    for (i = 0; i < g_cAlgIdTranslate; i++)
    {
        if (Algid == g_aAlgIdTranslate[i].AlgId)
        {
	    cb = EncodeObjId(pbEncoded, g_aAlgIdTranslate[i].pszObjId);
	    break;
        }
    }
    return(cb);
}


long
EncodeAlgorithm(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD AlgId)
{
    BYTE abTemp[32];
    long cbResult;
    BYTE *pb;

    pb = abTemp;

    // Take a guess at the total length:

    pb += EncodeHeader(pb, sizeof(abTemp));

    cbResult = EncodeAlgid(pb, AlgId);
    if (cbResult == -1)
    {
	return(-1);
    }
    pb += cbResult;

    cbResult += EncodeNull(pb);

    // Fix up the total length:

    cbResult += EncodeHeader(abTemp, cbResult);

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded, abTemp, cbResult);
    }
    return(cbResult);

}


//+*************************************************************************
// EncodeInteger ASN1 encodes an integer.  The pbInt parameter 
// is the integer as an array of bytes, and dwLen is the number
// of bytes in the array.  The least significant byte of the   
// integer is the zeroth byte of the array.  The encoded result
// is passed back in the pbEncoded parameter.  The pbEncoded   
// indicates if the result is to be written to the pbEncoded   
// parameter. The function cannot fail and returns the number  
// of total bytes in the encoded integer.                      
// This implementation will only deal with positive integers.  
//**************************************************************************

long
EncodeInteger(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbInt,
    IN DWORD dwLen)
{
    DWORD iInt;
    long j;			// Must be signed!
    LONG cbResult;
    LONG cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_INTEGER;
    }
    cbResult = 1;

    // find the most significant non-zero byte

    for (iInt = dwLen - 1; pbInt[iInt] == 0; iInt--)
    {
	if (iInt == 0)	// if the integer value is 0
	{
	    if (NULL != pbEncoded)
	    {
		*pbEncoded++ = 0x01;
		*pbEncoded++ = 0x00;
	    }
	    return(cbResult + 2);
	}
    }

    // if the most significant bit of the most significant byte is set then add
    // a 0 byte to the beginning.

    if (pbInt[iInt] > 0x7f)
    {
	// encode the length

	cbLength = EncodeLength(pbEncoded, iInt + 2);

	// set the first byte of the integer to 0 and increment pointer

	if (NULL != pbEncoded)
	{
	    pbEncoded += cbLength;
	    *pbEncoded++ = 0;
	}
	cbResult++;
    }
    else
    {
	// encode the length

	cbLength = EncodeLength(pbEncoded, iInt + 1);
	if (NULL != pbEncoded)
	{
	    pbEncoded += cbLength;
	}
    }
    cbResult += cbLength;

    // copy the integer bytes into the encoded buffer

    if (NULL != pbEncoded)
    {
	// copy the integer bytes into the encoded buffer

	for (j = iInt; j >= 0; j--)
	{
	    *pbEncoded++ = pbInt[j];
	}
    }
    cbResult += iInt + 1;
    return(cbResult);
}


long
EncodeUnicodeString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN WCHAR const *pwsz)
{
    long cbLength;
    long cbData = wcslen(pwsz) * sizeof(WCHAR);

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_UNICODE_STRING;
    }
    cbLength = EncodeLength(pbEncoded, cbData);

    if (NULL != pbEncoded)
    {
        pbEncoded += cbLength;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    *pbEncoded++ = (BYTE) (*pwsz >> 8);
	    *pbEncoded++ = (BYTE) *pwsz;
	}
    }
    return(1 + cbLength + cbData);
}


//+*************************************************************************
// EncodeIA5String ASN1 encodes a character string.  The pbStr    
// parameter is the string as an array of characters, and dwLen
// is the number of characters in the array.  The encoded result
// is passed back in the pbEncoded parameter.  The pbEncoded   
// indicates if the result is to be written to the pbEncoded   
// parameter. The function cannot fail and returns the number  
// of total bytes in the encoded string.                       
//**************************************************************************

long
EncodeIA5String(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen)
{
    long cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_IA5_STRING;
    }
    cbLength = EncodeLength(pbEncoded, dwLen);

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded + cbLength, pbStr, dwLen);
    }
    return(1 + cbLength + dwLen);
}


//+*************************************************************************
// EncodeOctetString ASN1 encodes a string of hex valued       
// characters. The pbStr parameter is an array of characters,  
// and dwLen is the number of characters in the array.  The    
// encoded result is passed back in the pbEncoded parameter. The
// pbEncoded parameter indicates if the result is to be written
// to the pbEncoded parameter. The function cannot fail and    
// returns the number of total bytes in the encoded octet string
//**************************************************************************

long
EncodeOctetString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen)
{
    long cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_OCTET_STRING;
    }
    cbLength = EncodeLength(pbEncoded, dwLen);

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded + cbLength, pbStr, dwLen);
    }
    return(1 + cbLength + dwLen);
}


//+*************************************************************************
// EncodeBitString ASN1 encodes a string of bit characters. The
// pbStr parameter is an array of characters (bits), and dwLen 
// is the number of characters in the array.  The encoded result
// is passed back in the pbEncoded parameter.  The pbEncoded   
// indicates if the result is to be written to the pbEncoded   
// parameter. The function cannot fail and returns the number  
// of total bytes in the encoded string.  This function uses   
// the DER.                                                    
//**************************************************************************

long
EncodeBitString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen)
{
    long cbLength;

    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_BIT_STRING;
    }
    cbLength = EncodeLength(pbEncoded, dwLen + 1);

    if (NULL != pbEncoded)
    {
	pbEncoded += cbLength;

        // the next byte tells how many unused bits there are in the last byte,
        // but this will always be zero in this implementation (DER)

        *pbEncoded++ = 0;
        CopyMemory(pbEncoded, pbStr, dwLen);
    }
    return(1 + cbLength + 1 + dwLen);
}


//+---------------------------------------------------------------------------
//
//  Function:   EncodeFileTime
//
//  Synopsis:   Encodes a FILETIME to a ASN.1 format time string.
//
//  Arguments:  [pbEncoded] --
//              [Time]      --
//              [UTC]       -- Indicate Time is UTC (true) or local (false)
//              [WriteFlag] --
//
//  History:    8-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
long
EncodeFileTime(
    OPTIONAL OUT BYTE *pbEncoded,
    IN FILETIME Time,
    IN BOOL UTC)
{
    if (NULL != pbEncoded)
    {
	SYSTEMTIME st;
	FILETIME ft;
	int count;

	if (UTC)
	{
	    ft = Time;
	}
	else
	{
	    LocalFileTimeToFileTime(&Time, &ft);
	}

	FileTimeToSystemTime(&ft, &st);

	*pbEncoded++ = BER_UTC_TIME;

	count = EncodeLength(pbEncoded, 13);

	// NOTE ON Y2K COMPLIANCE: This is test tool.  WE WILL NOT FIX THIS
	// CODE!  It is only used to encode current dates, anyway,

	pbEncoded++;
	st.wYear %= 100;

	*pbEncoded++ = (BYTE) ((st.wYear / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wYear % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wMonth / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wMonth % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wDay / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wDay % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wHour / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wHour % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wMinute / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wMinute % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wSecond / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wSecond % 10) + '0');

	*pbEncoded = 'Z';
    }

    // Tag(1) + Len(1) + Year(2) + Month(2) + Day(2) +
    // Hour(2) + Min(2) + Sec(2) + 'Z'(1) --> 15

    return(15);
}


//+*************************************************************************
// EncodeHeader ASN1 encodes a header for a sequence type. The 
// dwLen is the length of the encoded information in the       
// sequence.  The pbEncoded indicates if the result is to be   
// written to the pbEncoded parameter.  The function cannot    
// fail and returns the number of total bytes in the encoded   
// header.                                                     
//**************************************************************************

// Notes:	Encodes header as <BER_SEQUENCE>, <length>

long
EncodeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_SEQUENCE;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


//+*************************************************************************
// EncodeSetOfHeader ASN1 encodes a header for a set of type.  
// The dwLen is the length of the encoded information in the   
// set of.  The pbEncoded indicates if the result is to be     
// written to the pbEncoded parameter.  The function cannot    
// fail and returns the number of total bytes in the encoded   
// header.                                                     
//**************************************************************************

// Notes:	Encodes header as <SET_OF_TAG>, <length>

long
EncodeSetOfHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_SET_RAW;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


// Notes:	Encodes header as <BER_OPTIONAL | 0>, <length>

long
EncodeAttributeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_OPTIONAL | 0;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


// Notes:	Encodes header as <BER_SET>, <length>

long
EncodeSetHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen)
{
    if (NULL != pbEncoded)
    {
        *pbEncoded++ = BER_SET;
    }
    return(1 + EncodeLength(pbEncoded, dwLen));
}


//+*************************************************************************
// EncodeName ASN1 encodes a Name type. The pbName parameter is
// the name and dwLen is the length of the name in bytes.      
// The pbEncoded indicates if the result is to be written to   
// the pbEncoded parameter.  The function cannot fail and      
// returns the number of total bytes in the encoded name.
//**************************************************************************

long
EncodeName(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbName,
    IN DWORD dwLen)
{
    BYTE Type[MAXOBJIDLEN];
    long TypeLen;
    BYTE Value[MAXNAMEVALUELEN+MINHEADERLEN];
    long ValueLen;
    BYTE Attribute[MAXNAMELEN];
    long AttributeLen;
    BYTE SetHdr[MINHEADERLEN];
    long HdrLen;
    long NameLen;

    // encode the name value
    ValueLen = EncodeIA5String(Value, pbName, dwLen);

    // encode the attribute type, this is an object identifier and here it
    // is a fake encoding
    Type[0] = 0x06;
    Type[1] = 0x01;
    Type[2] = 0x00;

    TypeLen = 3;

    // encode the header for the attribute
    AttributeLen = EncodeHeader(Attribute, ValueLen + TypeLen);

    // copy the attribute type and value into the attribute

    CopyMemory(Attribute + AttributeLen, Type, TypeLen);
    AttributeLen += TypeLen;

    CopyMemory(Attribute + AttributeLen, Value, ValueLen);
    AttributeLen += ValueLen;

    // encode set of header

    HdrLen = EncodeSetOfHeader(SetHdr, AttributeLen);

    // encode Name header

    NameLen = EncodeHeader(pbEncoded, HdrLen + AttributeLen);
    if (NULL != pbEncoded)
    {
	CopyMemory(pbEncoded + NameLen, SetHdr, HdrLen);
    }

    NameLen += HdrLen;
    if (NULL != pbEncoded)
    {
	CopyMemory(pbEncoded + NameLen, Attribute, AttributeLen);
    }

    return(NameLen + AttributeLen);
}


long
EncodeRDN(
    OPTIONAL OUT BYTE *pbEncoded,
    IN NAMEENTRY const *pNameEntry)
{
    LONG cbResult;
    LONG Length;
    DWORD cbOIDandData;
    DWORD cbSequence;
    OIDTRANSLATE const *pOidName;

    // Compute the size of the encoded OID and RDN string, with BER encoding
    // tags and lengths.
   
    pOidName = LookupOidTranslate(pNameEntry->pszObjId);
    cbOIDandData =
	    1 +
	    EncodeLength(NULL, pOidName->cbOIDEncoded) +
	    pOidName->cbOIDEncoded +
	    1 +
	    EncodeLength(NULL, pNameEntry->cbData) +
	    pNameEntry->cbData;

    cbSequence = 1 + EncodeLength(NULL, cbOIDandData) + cbOIDandData;

    Length = EncodeSetHeader(pbEncoded, cbSequence);
    if (NULL != pbEncoded)
    {
	pbEncoded += Length;
    }

    cbResult = EncodeHeader(pbEncoded, cbOIDandData);
    if (NULL != pbEncoded)
    {
	pbEncoded += cbResult;
        *pbEncoded++ = BER_OBJECT_ID;
    }
    Length += cbResult + 1;

    cbResult = EncodeLength(pbEncoded, pOidName->cbOIDEncoded);
    if (NULL != pbEncoded)
    {
	pbEncoded += cbResult;
	CopyMemory(pbEncoded, pOidName->abOIDEncoded, pOidName->cbOIDEncoded);
	pbEncoded += pOidName->cbOIDEncoded;

	*pbEncoded++ = pNameEntry->BerTag;
    }
    Length += cbResult + pOidName->cbOIDEncoded + 1;

    cbResult = EncodeLength(pbEncoded, pNameEntry->cbData);
    Length += cbResult;

    if (NULL != pbEncoded)
    {
        CopyMemory(pbEncoded + cbResult, pNameEntry->pbData, pNameEntry->cbData);
    }
    return(Length + pNameEntry->cbData);
}


long
EncodeDN(
    OPTIONAL OUT BYTE *pbEncoded,
    IN NAMETABLE const *pNameTable)
{
    CHAR *pszNext;
    CHAR *pszRDN;
    long Result;
    long Length;
    long SaveResult;
    NAMEENTRY const *pNameEntry;
    DWORD i;

    SaveResult = 0;		 // force one full iteration
    pNameEntry = pNameTable->pNameEntry;
    Length = 0;
    for (i = 0; i < pNameTable->cnt; i++)
    {
        Length += 9 + pNameEntry->cbData;
	pNameEntry++;
    }

    while (TRUE)
    {
	BYTE *pb;

	pb = pbEncoded;

	Result = EncodeHeader(pb, Length);
	if (SaveResult == Result)
	{
	    break;
	}
	if (NULL != pb)
	{
	    pb += Result;
	}
	SaveResult = Result;

	Length = 0;
        pNameEntry = pNameTable->pNameEntry;
	for (i = 0; i < pNameTable->cnt; i++)
        {
	    Result = EncodeRDN(pb, pNameEntry);

	    if (Result < 0)
	    {
		Length = 0;
		goto error;	// return(-1)
	    }
	    if (NULL != pb)
	    {
		pb += Result;
	    }
	    Length += Result;
            pNameEntry++;
	}
    }
error:
    return(Result + Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"genreq"

#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <windows.h>

#define DBG_CERTSRV_DEBUG_PRINT
#include "certlib.h"	            // debug allocator

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\filter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Contents:	Functions for scanning strings for impermissible characters
//
//  File:       filter.cpp
//
//  History:	10-14-96	JerryK	Created
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>

//+-------------------------------------------------------------------------
//
//  Function:	IsCharPrintableString()
//
//  Synopsis:   Determine if a character is a valid PrintableString
//	        character in the sense of the X.520 specification with
//		the additional proviso that commas, which are acceptable
//		in the definition, are not accepted here as they eventually
//		create problems with the comma-separated certsrv.txt 
//		that mkroot produces.  (See X.680 pp. 46)
//
//  Effects:    
//
//  Arguments:  [chChar]
//
//  Returns:	TRUE/FALSE
//
//  History:	10-21-96	JerryK	Added
//
//  Notes:	Note the exclusion of commas referred to above and that
//		this deviates slightly from the PrintableString definition.
//
//--------------------------------------------------------------------------
BOOL
IsCharPrintableString(TCHAR chChar)
{
    BOOL	fRetVal=FALSE;

    if(_istascii(chChar))
    {
	if(_istalnum(chChar))
	{
	    fRetVal = TRUE;
	}
	else
	{
	    switch(chChar)
	    {
	        case TEXT(' '):
	        case TEXT('\''):
	        case TEXT('('):
	        case TEXT(')'):
	        case TEXT('+'):
      	        case TEXT('-'):
	        case TEXT('.'):
	        case TEXT('/'):
      	        case TEXT(':'):
	        case TEXT('='):
	        case TEXT('?'):
		    fRetVal = TRUE;	
		    break;
	    }
	}
    }

    return fRetVal;
}



//+-------------------------------------------------------------------------
//
//  Function:	CheckStringForNonPrintables
//
//  Synopsis:   Checks a string for characters that aren't valid for
//		PrintableStrings (plus the comma).
//
//  Arguments:  [pszStr]  --	String to scan
//
//  Returns:	TEXT('\0') if string is a PrintableString;
//		Otherwise returns the value of the first TCHAR
//		to violate the modified PrintableString definition.
//
//  History:	10-21-96	JerryK	Added
//
//--------------------------------------------------------------------------
TCHAR
CheckStringForNonPrintables(LPTSTR pszStr)
{
    int		i=0;
    TCHAR	chResult=TEXT('\0');

    // @@ Assert that the argument wasn't NULL

    while(TEXT('\0') != pszStr[i])
    {
	if(!IsCharPrintableString(pszStr[i]))
	{
	    chResult = pszStr[i];
	    break;
	}

	i++;
    }

    return chResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

#define IDI_APP                         201
#define IDI_PRODUCT                     202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\encode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       encode.h
//
//--------------------------------------------------------------------------

#ifndef _ENCODE_H_
#define _ENCODE_H_

#include <wtypes.h>
#include "csber.h"


// definitions of maximum lengths needed for the ASN.1 encoded form of some of
// the common fields in a certificate

#define MAXVALIDITYLEN		0x24
#define MAXKEYINFOLEN		0x40
#define MAXALGIDLEN		0x0a
#define MAXOBJIDLEN		20
#define MAXNAMEVALUELEN		0x40
#define UTCTIMELEN		0x0f
#define MAXPUBKEYDATALEN	0x30
#define VERSIONLEN		0x03
#define MAXENCODEDSIGLEN	0x30
#define MAXHEADERLEN		0x08
#define MINHEADERLEN		0x03
#define MAXTIMELEN		0x20
#define MAXNAMELEN		0x40


// definitions for scrubbing memory

#define ALLBITSOFF		0x00
#define ALLBITSON		0xff

typedef struct _PctPrivateKey {
    DWORD Type;
    DWORD cbKey;
    BYTE  pKey[1];
} PctPrivateKey, *PPctPrivateKey;


typedef struct _OIDTRANSLATE {
    char const *pszObjId;
    BYTE        abOIDEncoded[MAXOBJIDLEN];	// ASN.1 encoded OID
    BYTE	cbOIDEncoded;			// ASN.1 encoded OID length
} OIDTRANSLATE;


typedef struct _ALGIDTRANSLATE {
    DWORD       AlgId;
    char const *pszObjId;
} ALGIDTRANSLATE;


typedef struct _RDNENTRY {
    char const *pszObjId;
    char const *pszShortName;
    BYTE        BerTag;				// ASN.1 type of string
    DWORD       cbMaxString;
    DWORD       cbMaxConcatenated;
    DWORD	cbRemain;
} RDNENTRY;


typedef struct _NAMEENTRY {
    char const *pszObjId;
    BYTE         BerTag;			// ASN.1 type of string
    DWORD	 cbData;
    BYTE	*pbData;
    DWORD	 iRDN;
} NAMEENTRY;

typedef struct _NAMETABLE {
    DWORD        cnt;
    NAMEENTRY   *pNameEntry;
} NAMETABLE;


extern const ALGIDTRANSLATE g_aAlgIdTranslate[];
extern const DWORD g_cAlgIdTranslate;

extern const OIDTRANSLATE g_aOidTranslate[];
extern const DWORD g_cOidTranslate;

extern RDNENTRY g_ardnSubject[];
extern const DWORD g_crdnSubject;


// prototypes for the functions in enc.cpp:

OIDTRANSLATE const *
LookupOidTranslate(
    IN CHAR const *pszObjId);

long
EncodeObjId(
    OPTIONAL OUT BYTE *pbEncoded,
    IN CHAR const *pszObjId);

long
EncodeLength(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeAlgid(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD Algid);

long
EncodeInteger(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbInt,
    IN DWORD dwLen);

long
EncodeUnicodeString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN WCHAR const *pwsz);

long
EncodeIA5String(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen);

long
EncodeOctetString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen);

long
EncodeBitString(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbStr,
    IN DWORD dwLen);

long
EncodeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeSetHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeAttributeHeader(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD dwLen);

long
EncodeName(
    OPTIONAL OUT BYTE *pbEncoded,
    IN BYTE const *pbName,
    IN DWORD dwLen);

long
EncodeAlgorithm(
    OPTIONAL OUT BYTE *pbEncoded,
    IN DWORD AlgId);

#define ALGTYPE_SIG_RSA_MD5	0x01
#define ALGTYPE_KEYEXCH_RSA_MD5	0x02
#define ALGTYPE_CIPHER_RC4_MD5	0x03

long
EncodeDN(
    OPTIONAL OUT BYTE *pbEncoded,
    IN NAMETABLE const *pNameTable);

long
EncodeFileTime(
    OPTIONAL OUT BYTE *pbEncoded,
    IN FILETIME Time,
    IN BOOL UTC);

#endif  // _ENCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\sigmsrsa.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1999
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <rsa.h>
#include <md2.h>
#include <md5.h>


#ifdef __cplusplus
}
#endif


static unsigned char MD5_PRELUDE[] = {
  0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10
};

static unsigned char MD2_PRELUDE[] = {
  0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x02, 0x02, 0x05, 0x00, 0x04, 0x10
};

static VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    do
    {
        *p-- = *Source++;
    } while (p >= Dest);
}

BOOL
WINAPI
SigRSAMD2Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI
SigRSAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI SigRSASHAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI SigRSAMD2Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);

BOOL
WINAPI SigRSAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);

BOOL
WINAPI SigRSASHAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);


#define ADVAPI32_PATH TEXT("advapi32.dll")
#define CRYPT_CREATE_HASH_NAME TEXT("CryptCreateHash")
#define CRYPT_HASH_DATA_NAME TEXT("CryptHashData")
#define CRYPT_SIGN_HASH_NAMEA TEXT("CryptSignHashA")
#define CRYPT_SIGN_HASH_NAMEW TEXT("CryptSignHashW")
#define CRYPT_DESTROY_HASH_NAME TEXT("CryptDestroyHash")
#define CRYPT_SET_HASH_PARAM_NAME TEXT("CryptSetHashParam")


typedef BOOL
( WINAPI * CRYPT_CREATE_HASH_FN)(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);


typedef BOOL
( WINAPI * CRYPT_HASH_DATA_FN)(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

typedef BOOL
( WINAPI * CRYPT_DESTROY_HASH_FN) (
    HCRYPTHASH hHash);

typedef BOOL
( WINAPI * CRYPT_SIGN_HASH_FNA)(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

typedef BOOL
( WINAPI * CRYPT_SIGN_HASH_FNW)(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

typedef BOOL
( WINAPI * CRYPT_SET_HASH_PARAM_FN)(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);


HINSTANCE g_hAdvapi32 = NULL;
CRYPT_CREATE_HASH_FN g_CryptCreateHash = NULL;
CRYPT_HASH_DATA_FN   g_CryptHashData = NULL;
CRYPT_DESTROY_HASH_FN g_CryptDestroyHash = NULL;
CRYPT_SIGN_HASH_FNA g_CryptSignHashA = NULL;
CRYPT_SIGN_HASH_FNW g_CryptSignHashW = NULL;
CRYPT_SET_HASH_PARAM_FN g_CryptSetHashParam = NULL;


SignatureSystem sigRSAMD2 = { SP_SIG_RSA_MD2, SigRSAMD2Sign, SigRSAMD2Verify};
SignatureSystem sigRSAMD5 = { SP_SIG_RSA_MD5, SigRSAMD5Sign, SigRSAMD5Verify};
SignatureSystem sigRSASHAMD5 = { SP_SIG_RSA_SHAMD5, SigRSASHAMD5Sign, SigRSASHAMD5Verify};


BOOL
WINAPI capiCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptCreateHash)
    {
        g_CryptCreateHash = (CRYPT_CREATE_HASH_FN)GetProcAddress(g_hAdvapi32, CRYPT_CREATE_HASH_NAME);
        if(!g_CryptCreateHash)
        {
            return FALSE;
        }
    }
    return g_CryptCreateHash(hProv, Algid, hKey, dwFlags, phHash);
}


BOOL
WINAPI capiCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptHashData)
    {
        g_CryptHashData = (CRYPT_HASH_DATA_FN)GetProcAddress(g_hAdvapi32, CRYPT_HASH_DATA_NAME);
        if(!g_CryptHashData)
        {
            return FALSE;
        }
    }
    return g_CryptHashData(hHash, pbData, dwDataLen, dwFlags);
}


BOOL
WINAPI capiCryptDestroyHash(
    HCRYPTHASH hHash)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptDestroyHash)
    {
        g_CryptDestroyHash = (CRYPT_DESTROY_HASH_FN)GetProcAddress(g_hAdvapi32, CRYPT_DESTROY_HASH_NAME);
        if(!g_CryptDestroyHash)
        {
            return FALSE;
        }
    }
    return g_CryptDestroyHash(hHash);
}

BOOL
WINAPI capiCryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptSignHashA)
    {
        g_CryptSignHashA = (CRYPT_SIGN_HASH_FNA)GetProcAddress(g_hAdvapi32, CRYPT_SIGN_HASH_NAMEA);
        if(!g_CryptSignHashA)
        {
            return FALSE;
        }
    }
    return g_CryptSignHashA(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
}


BOOL
WINAPI capiCryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptSignHashW)
    {
        g_CryptSignHashW = (CRYPT_SIGN_HASH_FNW)GetProcAddress(g_hAdvapi32, CRYPT_SIGN_HASH_NAMEW);
        if(!g_CryptSignHashW)
        {
            return FALSE;
        }
    }
    return g_CryptSignHashW(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
}

BOOL
WINAPI capiCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    if(!g_hAdvapi32)
    {
        g_hAdvapi32 = LoadLibrary(ADVAPI32_PATH);
        if(!g_hAdvapi32) 
        {
            return FALSE;
        }
    }

    
    if(!g_CryptSetHashParam)
    {
        g_CryptSetHashParam = (CRYPT_SET_HASH_PARAM_FN)GetProcAddress(g_hAdvapi32, CRYPT_SET_HASH_PARAM_NAME);
        if(!g_CryptSetHashParam)
        {
            return FALSE;
        }
    }
    return g_CryptSetHashParam(hHash, dwParam, pbData, dwFlags);
}

#ifdef UNICODE
#define capiCryptSignHash  capiCryptSignHashW
#else
#define capiCryptSignHash  capiCryptSignHashA
#endif // !UNICODE


BOOL
WINAPI
SigRSAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;
    UCHAR LocalBuffer[300];
    UCHAR LocalOutput[300];

    unsigned int cbSize;

    if(pk->magic != RSA2 && pKey->cbKey == sizeof(HCRYPTPROV))
    {
        // This isn't a bsafe key, and it's the right size, so it must be a
	// CAPI key.  This a heuristic.

        HCRYPTHASH hHash;
        DWORD cbSigned;
        HCRYPTPROV hProv = *((HCRYPTPROV *)pKey->pKey);

        if(!capiCryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
        {
            return FALSE;
        }
        if(!capiCryptHashData(hHash, pData, cbData, 0))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        cbSigned = sizeof(LocalOutput);
       
        if(!capiCryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, LocalOutput, &cbSigned))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        capiCryptDestroyHash(hHash);
        ReverseMemCopy(pSigned, LocalOutput, cbSigned);
        *pcbSigned = cbSigned;
        return TRUE;
    }
    else if(pk->magic != RSA2)
    {
        // This isn't a bsafe key or a CAPI key, so it must be a WinSock 2 
        // LSP key.
        SSLSIGNATUREFUNC pSignHook;
        LPVOID pSignArg;

        /* Generate the checksum */
        MD5Init(&DigCtx);
        MD5Update(&DigCtx, pData, cbData);
        MD5Final(&DigCtx);

        // Get the prelude data and the hash value.
        CopyMemory(LocalBuffer, MD5_PRELUDE, sizeof(MD5_PRELUDE));
        CopyMemory(LocalBuffer + sizeof(MD5_PRELUDE), DigCtx.digest, MD5DIGESTLEN);
        
        // Get pointer to callback function.
        pSignHook = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pSignatureHookFunc;
        pSignArg  = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pSignatureHookArg;

        // Invoke the callback function.
        if(pSignHook)
        {
            if(pSignHook(SSL_SIGN_RSA,
                         pSignArg,
                         LocalBuffer,
                         sizeof(MD5_PRELUDE) + MD5DIGESTLEN,
                         0,
                         pSigned,
                         pcbSigned) != SSL_ERR_OKAY) 
            {
                return FALSE;
            } 
        }
        else
        {
            DebugLog((DEB_ERROR, "Null signature callback function!\n"));
        }

        // Return success.
        return TRUE;
    }

    cbSize = sizeof(MD5_PRELUDE)+16;
    if(pk->datalen > sizeof(LocalBuffer)) 
    {
        return FALSE;
    }

    /* Generate the checksum */
    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pData, cbData);
    MD5Final(&DigCtx);

    FillMemory(LocalBuffer, pk->keylen, 0);

    ReverseMemCopy(LocalBuffer, DigCtx.digest, 16);
    ReverseMemCopy(LocalBuffer+16, MD5_PRELUDE, sizeof(MD5_PRELUDE));
    LocalBuffer[cbSize++]=0;
    while(cbSize < pk->datalen-1) {
        LocalBuffer[cbSize++] = 0xff;
    }

    /* Make into pkcs block type 1 */
    LocalBuffer[pk->datalen-1] = 1;

    *pcbSigned = pk->datalen+1;

    if(!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return FALSE;
    }
    ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);
    return TRUE;
}

BOOL
WINAPI
SigRSAMD2Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey)
{
    MD2_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;
    UCHAR LocalBuffer[500];
    UCHAR LocalOutput[500];

    unsigned int cbSize;
    if(pk->magic != RSA2)
    {
        // This is not a bsafe key, so it must be a CAPI
        // key.
        HCRYPTHASH hHash;
        DWORD cbSigned;
        HCRYPTPROV hProv = *((HCRYPTPROV *)pKey->pKey);

        if(!capiCryptCreateHash(hProv, CALG_MD2, 0, 0, &hHash))
        {
            return FALSE;
        }
        if(!capiCryptHashData(hHash, pData, cbData, 0))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        cbSigned = sizeof(LocalOutput);
        if(!capiCryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, LocalOutput, &cbSigned))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        capiCryptDestroyHash(hHash);
        ReverseMemCopy(pSigned, LocalOutput, cbSigned);
        *pcbSigned = cbSigned;
        return TRUE;
    }


    cbSize = sizeof(MD2_PRELUDE)+16;
    if(pk->datalen > sizeof(LocalBuffer))
    {
        return FALSE;
    }

    //MD2Init(&DigCtx);
    FillMemory( &DigCtx, sizeof( DigCtx ), 0 );

    MD2Update(&DigCtx, pData, cbData);
    MD2Final(&DigCtx);
    FillMemory(LocalBuffer, pk->keylen, 0);
    ReverseMemCopy(LocalBuffer, DigCtx.state, 16);
    ReverseMemCopy(LocalBuffer+16, MD2_PRELUDE, sizeof(MD2_PRELUDE));
    LocalBuffer[cbSize++]=0;
    while(cbSize < pk->datalen-1) {
        LocalBuffer[cbSize++] = 0xff;
    }

    /* Make into pkcs block type 1 */
    LocalBuffer[pk->datalen-1] = 1;

    *pcbSigned = pk->datalen+1;

    if(!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return FALSE;
    }
    ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);
    return TRUE;
}


BOOL
WINAPI
SigRSAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if(pk->datalen > sizeof(Buffer) || cbSigned != pk->datalen+1) 
    {
        return FALSE;
    }

    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pData, cbData);
    MD5Final(&DigCtx);

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    if(!BSafeEncPublic(pk, SigBuffer, Buffer))
    {
        return FALSE;
    }

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1) 
    {
        return FALSE;
    }

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ ){
        if(!SigBuffer[iLoc]) 
        {
            break;
        }
        if(SigBuffer[iLoc] != 0xff) 
        {
            return FALSE;
        }
    }

    if(iLoc == pk->datalen) return FALSE;

    iLoc++; /* skip past separator */


    if(memcmp(&SigBuffer[iLoc], MD5_PRELUDE, sizeof(MD5_PRELUDE))   != 0) 
    {
        return FALSE;
    }

    iLoc += sizeof(MD5_PRELUDE);
    if(memcmp(&SigBuffer[iLoc],  DigCtx.digest, 16) != 0) 
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
SigRSAMD2Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    MD2_CTX DigCtx;
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if ((pk->datalen > sizeof(Buffer)) ||
        (cbSigned != pk->datalen + 1))
    {
        return FALSE;
    }

    // MD2Init(&DigCtx);

    FillMemory( &DigCtx, sizeof( DigCtx ), 0 );

    MD2Update(&DigCtx, pData, cbData);

    MD2Final(&DigCtx);

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    if(!BSafeEncPublic(pk, SigBuffer, Buffer))
    {
        return FALSE;
    }

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1) 
    {
        return FALSE;
    }

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ )
    {
        if(!SigBuffer[iLoc]) 
        {
            break;
        }

        if(SigBuffer[iLoc] != 0xff) 
        {
            return FALSE;
        }
    }

    if(iLoc == pk->datalen) 
    {
        return FALSE;
    }

    iLoc++; /* skip past separator */


    if(memcmp(&SigBuffer[iLoc], MD2_PRELUDE, sizeof(MD2_PRELUDE))   != 0) 
    {
        return FALSE;
    }
    iLoc += sizeof(MD2_PRELUDE);
    if(memcmp(&SigBuffer[iLoc],  DigCtx.state, 16)  != 0) 
    {
        return FALSE;
    }



    return TRUE;
}

BOOL
WINAPI
SigRSASHAMD5Sign(
    PUCHAR          pData,          // pointer to hash value
    DWORD           cbData,         // always 36
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey   *pKey)
{
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;

    if(pk->magic == RSA2)
    {
        // BSAFE key
        UCHAR LocalBuffer[500];
        UCHAR LocalOutput[500];

      pk = (BSAFE_PRV_KEY *)pKey;
      if(pk->keylen > sizeof(LocalBuffer))
        {
            return FALSE;
        }

        FillMemory(LocalBuffer, pk->keylen, 0);
        ReverseMemCopy(LocalBuffer, pData, cbData);

        LocalBuffer[cbData++] = 0;

        while(cbData < pk->datalen-1) {
            LocalBuffer[cbData++] = 0xff;
        }

        /* Make into pkcs block type 1 */
        LocalBuffer[pk->datalen-1] = 1;

        *pcbSigned = pk->datalen+1;

        BSafeDecPrivate(pk, LocalBuffer, LocalOutput);
        ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);

        return TRUE;
    }
    else
    {
        // capiCryptoAPI key
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        DWORD dwAlgid;
        DWORD i;
        DWORD dwT;

        // get handle to CSP
        hProv = *((HCRYPTPROV *)pKey->pKey);

        // create hash object
        dwAlgid = ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5;
        if(RCRYPT_FAILED(capiCryptCreateHash(hProv, dwAlgid, 0, 0, &hHash)))
        {
            return FALSE;
        }

        // set hash value
        if(RCRYPT_FAILED(capiCryptSetHashParam(hHash, HP_HASHVAL, pData, 0)))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }

        // sign hash
        if(RCRYPT_FAILED(capiCryptSignHash(hHash,
                                       AT_KEYEXCHANGE,
                                       NULL,
                                       0,
                                       pSigned,
                                       pcbSigned)))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }

        // free hash object
        capiCryptDestroyHash(hHash);

        //Convert to Big-endian
        dwT = *pcbSigned;
        for( i = 0 ; i < dwT/2 ; i++)
        {
            BYTE bT = pSigned[i];
            
            pSigned[i] = pSigned[dwT-1-i];
            pSigned[dwT-1-i] = bT;
        }
        return TRUE;
    }
}

BOOL
WINAPI
SigRSASHAMD5Verify(
    PUCHAR          pData,          // pointer to hash value
    DWORD           cbData,         // always 36
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if(pk->keylen > sizeof(Buffer) || cbSigned != pk->datalen + 1)
    {
        return FALSE;
    }

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    BSafeEncPublic(pk, SigBuffer, Buffer);

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1) return FALSE;

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ ){
        if(!SigBuffer[iLoc]) break;
        if(SigBuffer[iLoc] != 0xff) return FALSE;
    }

    if(iLoc == pk->datalen) return FALSE;

    iLoc++; /* skip past separator */

    if(memcmp(&SigBuffer[iLoc], pData, cbData) != 0) return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\genreq\table.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       table.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "encode.h"


#define iso_member	0x2a			// iso(1) memberbody(2)
#define us		0x86, 0x48		// us(840)
#define rsadsi		0x86, 0xf7, 0x0d	// rsadsi(113549)
#define pkcs		0x01			// pkcs(1)

#define rsa_dsi			iso_member, us, rsadsi
#define rsa_dsi_len		6

#define pkcs_1			iso_member, us, rsadsi, pkcs
#define pkcs_len		7

#define prefix311		0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37
#define prefix311Length		7

#define prefix19200300		0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c
#define prefix19200300Length	7


#define joint_iso_ccitt_ds	0x55
#define attributetype		0x04

#define attributeType		joint_iso_ccitt_ds, attributetype
#define attributeLength		3


const ALGIDTRANSLATE g_aAlgIdTranslate[] =
{
    {
	ALGTYPE_SIG_RSA_MD5,
	szOID_RSA_MD5RSA,		// "1.2.840.113549.1.1.4"
    },
    {
	ALGTYPE_KEYEXCH_RSA_MD5,
	szOID_RSA_RSA,			// "1.2.840.113549.1.1.1"
    },
    {
	ALGTYPE_CIPHER_RC4_MD5,
	szOID_RSA_RC4,			// "1.2.840.113549.3.4"
    }
};

const DWORD g_cAlgIdTranslate = ARRAYSIZE(g_aAlgIdTranslate);


const OIDTRANSLATE g_aOidTranslate[] =
{
    // Subject RDN OIDs:

    {
	szOID_COUNTRY_NAME,		// "2.5.4.6"
	{ attributeType, 6 },		// 0x55, 0x04, 0x06
	attributeLength,
    },
    {
	szOID_ORGANIZATION_NAME,	// "2.5.4.10"
	{ attributeType, 10 },		// 0x55, 0x04, 0x0a
	attributeLength,
    },
    {
	szOID_ORGANIZATIONAL_UNIT_NAME,	// "2.5.4.11"
	{ attributeType, 11 },		// 0x55, 0x04, 0x0b
	attributeLength,
    },
    {
	szOID_COMMON_NAME,		// "2.5.4.3"
	{ attributeType, 3 },		// 0x55, 0x04, 0x03
	attributeLength,
    },
    {
	szOID_LOCALITY_NAME,		// "2.5.4.7"
	{ attributeType, 7 },		// 0x55, 0x04, 0x07
	attributeLength,
    },
    {
	szOID_STATE_OR_PROVINCE_NAME,	// "2.5.4.8"
	{ attributeType, 8 },		// 0x55, 0x04, 0x08
	attributeLength,
    },
    {
	szOID_TITLE,			// "2.5.4.12"
	{ attributeType, 12 },		// 0x55, 0x04, 0x0c
	attributeLength,
    },
    {
	szOID_GIVEN_NAME,		// "2.5.4.42"
	{ attributeType, 42 },		// 0x55, 0x04, 0x02a
	attributeLength,
    },
    {
	szOID_INITIALS,			// "2.5.4.43"
	{ attributeType, 43 },		// 0x55, 0x04, 0x2b
	attributeLength,
    },
    {
	szOID_SUR_NAME,			// "2.5.4.4"
	{ attributeType, 4 },		// 0x55, 0x04, 0x04
	attributeLength,
    },
    {
	szOID_DOMAIN_COMPONENT,		// "0.9.2342.19200300.100.1.25"
	{ prefix19200300, 100, 1, 25 },
		// 0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19
	prefix19200300Length + 3,
    },
    {
	szOID_RSA_emailAddr,		// "1.2.840.113549.1.9.1"
	{ pkcs_1, 9, 1 },
	pkcs_len + 2,
    },
    {
	szOID_STREET_ADDRESS,		// "2.5.4.9"
	{ attributeType, 9 },		// 0x55, 0x04, 0x09
	attributeLength,
    },
    {
	szOID_RSA_unstructName,		// "1.2.840.113549.1.9.2"
	{ pkcs_1, 9, 2 },
	pkcs_len + 2,
    },
    {
	szOID_RSA_unstructAddr,		// "1.2.840.113549.1.9.8"
	{ pkcs_1, 9, 8 },
	pkcs_len + 2,
    },
    {
	szOID_DEVICE_SERIAL_NUMBER,	// "2.5.4.5"
	{ attributeType, 5 },		// 0x55, 0x04, 0x05
	attributeLength,
    },

    // Non-Subject RDN OIDs:

    {
	szOID_CERT_EXTENSIONS,		// "1.3.6.1.4.1.311.2.1.14"
	{ prefix311, 2, 1, 14 },
	prefix311Length + 3,
    },
    {
	szOID_ENROLL_CERTTYPE_EXTENSION, // "1.3.6.1.4.1.311.20.2"
	{ prefix311, 20, 2 },
	prefix311Length + 2,
    },
    {
	szOID_RSA_MD5RSA,		// "1.2.840.113549.1.1.4"
	{ pkcs_1, 1, 4 },
	pkcs_len + 2
    },
    {
	szOID_RSA_RSA,			// "1.2.840.113549.1.1.1"
	{ pkcs_1, 1, 1 },
	pkcs_len + 2
    },
    {
	szOID_RSA_RC4,			// "1.2.840.113549.3.4"
	{ rsa_dsi, 3, 4 },
	rsa_dsi_len + 2
    },
};

const DWORD g_cOidTranslate = ARRAYSIZE(g_aOidTranslate);


// Limit strings to cch???MAX chars, not including the trailing '\0'

RDNENTRY g_ardnSubject[] =
{
    {
	szOID_COUNTRY_NAME,		// "2.5.4.6"
	"C",
	BER_PRINTABLE_STRING,
	cchCOUNTRYNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_ORGANIZATION_NAME,	// "2.5.4.10"
	"O",
	BER_PRINTABLE_STRING,
	cchORGANIZATIONNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_ORGANIZATIONAL_UNIT_NAME,	// "2.5.4.11"
	"OU",
	BER_PRINTABLE_STRING,
	cchORGANIZATIONALUNITNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_COMMON_NAME,		// "2.5.4.3"
	"CN",
	BER_TELETEX_STRING,
	cchCOMMONNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_LOCALITY_NAME,		// "2.5.4.7"
	"L",
	BER_PRINTABLE_STRING,
	cchLOCALITYMANAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_STATE_OR_PROVINCE_NAME,	// "2.5.4.8"
	"S",
	BER_PRINTABLE_STRING,
	cchSTATEORPROVINCENAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_TITLE,			// "2.5.4.12"
	"T",
	BER_PRINTABLE_STRING,
	cchTITLEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_GIVEN_NAME,		// "2.5.4.42"
	"G",
	BER_PRINTABLE_STRING,
	cchGIVENNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_INITIALS,			// "2.5.4.43"
	"I",
	BER_PRINTABLE_STRING,
	cchINITIALSMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_SUR_NAME,			// "2.5.4.4"
	"SN",
	BER_PRINTABLE_STRING,
	cchSURNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_DOMAIN_COMPONENT,		// "0.9.2342.19200300.100.1.25"
	"DC",
	BER_PRINTABLE_STRING,
	cchDOMAINCOMPONENTMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_RSA_emailAddr,		// "1.2.840.113549.1.9.1"
	"E",
	BER_IA5_STRING,
	cchEMAILMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_STREET_ADDRESS,		// "2.5.4.9"
	"STREET",
	BER_PRINTABLE_STRING,
	cchSTREETADDRESSMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_RSA_unstructName,		// "1.2.840.113549.1.9.2"
	"UnstructuredName",
	BER_PRINTABLE_STRING,
	cchUNSTRUCTUREDNAMEMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_RSA_unstructAddr,		// "1.2.840.113549.1.9.8"
	"UnstructuredAddress",
	BER_PRINTABLE_STRING,
	cchUNSTRUCTUREDADDRESSMAX,
	CCH_DBMAXTEXT_RDN,
    },
    {
	szOID_DEVICE_SERIAL_NUMBER,	// "2.5.4.5"
	"DeviceSerialNumber",
	BER_PRINTABLE_STRING,
	cchDEVICESERIALNUMBERMAX,
	CCH_DBMAXTEXT_RDN,
    },
};

const DWORD g_crdnSubject = ARRAYSIZE(g_ardnSubject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\hdrs\classhdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       classhdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Class:
//
//  Purpose:
//
//  History:
//
//  Notes:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\idl\com\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

RPC_SOURCE_DIR=..\rpc\$(O)
DCOM_SOURCE_DIR=..\dcom\$(O)

$(RPC_NTTARGETFILE1):	$(RPC_SOURCE_DIR)\$(@F)
    copy $(RPC_SOURCE_DIR)\$(@F) $@

$(DCOM_NTTARGETFILE1):	$(DCOM_SOURCE_DIR)\$(@F)
    copy $(DCOM_SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\hdrs\funchdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       funchdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//  
//  Derivation:
//
//  Algorithm:
// 
//  History:
// 
//  Notes:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\hdrs\methhdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       methhdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//  
//  Derivation:
//
//  Algorithm:
// 
//  History:
// 
//  Notes:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\idl\tlb\certadml\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\certadml.res:    ..\..\com\$(O)\certadm.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\hdrs\filehdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       filehdr.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:
// 
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\idl\tlb\dummy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dummy.cpp
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\idl\tlb\certclil\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\certclil.res:    ..\..\com\$(O)\certcli.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\idl\tlb\certencl\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\certencl.res:    ..\..\com\$(O)\certenc.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\causages.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       causages.h
//
//--------------------------------------------------------------------------

// CAUsages.h: interface for the CCAUsages class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CAUSAGES_H__1E54779E_5C56_11D1_931E_00C04FB93209__INCLUDED_)
#define AFX_CAUSAGES_H__1E54779E_5C56_11D1_931E_00C04FB93209__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CCAUsages  
{
public:
	HRESULT Import(BSTR bstr);
	BSTR Export();
	CCAUsages();
	virtual ~CCAUsages();

	operator PSECURITY_DESCRIPTOR ()
    {
        return m_pSD;
    }

    operator CERT_ENHKEY_USAGE *()
    {
        return &m_sEnhKeyUsage;
    }

    operator WCHAR *()
    {
        return m_bstrCertType;
    }



    HRESULT SetSD(PSECURITY_DESCRIPTOR pSD);
    HRESULT SetEnhKeyUsage(CERT_ENHKEY_USAGE *pEnhKey);
    HRESULT SetCertType(WCHAR *m_wszCertType);




protected:
    CERT_ENHKEY_USAGE       m_sEnhKeyUsage;

	BSTR                    m_bstrCertType;

	PSECURITY_DESCRIPTOR    m_pSD;
};

#endif // !defined(AFX_CAUSAGES_H__1E54779E_5C56_11D1_931E_00C04FB93209__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\cainfop.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfop.h
//
// Contents:    Private definitions for CA Info
//
// History:     12-dec-97  petesk  created
//
//---------------------------------------------------------------------------

#ifndef __CAINFOP_H__

#define __CAINFOP_H__

#include <winldap.h>


#define SYSTEM_CN TEXT("System")
#define PUBLIC_KEY_SERVICES_CN TEXT("Public Key Services")
#define CAS_CN TEXT("CAs") 

VOID CACleanup();

DWORD
DNStoRFC1779Name(
    WCHAR *rfcDomain,
    ULONG *rfcDomainLength,
    LPCWSTR dnsDomain);

DWORD
myGetSidFromDomain(
    IN LPWSTR wszDomain, 
    OUT PSID *ppDomainSid);

DWORD
myGetEnterpriseDnsName(
    OUT LPWSTR *pwszDomain);

BOOL
myNetLogonUser(
    LPTSTR UserName,
    LPTSTR DomainName,
    LPTSTR Password,
    PHANDLE phToken);

#ifndef DNS_MAX_NAME_LENGTH
#define DNS_MAX_NAME_LENGTH 255
#endif

typedef WCHAR *CERTSTR; 

//
// CAGetAuthoritativeDomainDn - retrieve the Domain root DN for this
// domain.  This retrieves config info from the DS for the default domain.
//


HRESULT 
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CERTSTR *DomainDn,
    OUT CERTSTR *ConfigDN);

// 
// CASCreateCADSEntry - This creates a CA entry in the DS for this CA,
// and sets the appropriate entries for name, DN, certificate, dnsname.
// It is for use by setup.
// It creates the CA entry at the location 
// CN=bstrCAName,CN=CAs,CN=PublicKeyServices,CN=System,DC....root dc path...
// 

HRESULT 
CASCreateCADSEntry(
    IN CERTSTR bstrCAName,		// Name of the CA
    IN PCCERT_CONTEXT pCertificate);	// Certificate of the CA

HRESULT
GetCertAuthorityDSLocation(
    IN LDAP *LdapHandle,
    CERTSTR bstrCAName, 
    CERTSTR bstrDomainDN, 
    CERTSTR *bstrDSLocation);


class CCAProperty
{
public:
    CCAProperty(LPCWSTR wszName);


    HRESULT Find(LPCWSTR wszName, CCAProperty **ppCAProp);

static HRESULT Append(CCAProperty **ppCAPropChain, CCAProperty *pNewProp);

static HRESULT DeleteChain(CCAProperty **ppCAProp);


    HRESULT SetValue(LPWSTR * awszProperties);

    HRESULT GetValue(LPWSTR ** pawszProperties);
    HRESULT LoadFromRegValue(HKEY hkReg, LPCWSTR wszValue);
    HRESULT UpdateToRegValue(HKEY hkReg, LPCWSTR wszValue);


protected:


    // Only call via DeleteChain
    ~CCAProperty();
    HRESULT _Cleanup();


    WCHAR ** m_awszValues;
    CERTSTR   m_wszName;

    CCAProperty *m_pNext;

private:
};



HRESULT CertFreeString(CERTSTR cstrString);
CERTSTR CertAllocString(LPCWSTR wszString);
CERTSTR CertAllocStringLen(LPCWSTR wszString, UINT len);
CERTSTR CertAllocStringByteLen(LPCSTR szString, UINT len);
UINT    CertStringLen(CERTSTR cstrString);
UINT    CertStringByteLen(CERTSTR cstrString);

HRESULT
myRobustLdapBind(
    OUT LDAP **ppldap,
    IN BOOL fGC);

HRESULT
myRobustLdapBindEx(
    IN BOOL fGC,
    IN BOOL fRediscover,
    IN ULONG uVersion,
    OPTIONAL IN WCHAR const *pwszDomainName,
    OUT LDAP **ppldap,
    OPTIONAL OUT WCHAR **ppwszForestDNSName);

HRESULT
CAAccessCheckp(
    HANDLE ClientToken,
    PSECURITY_DESCRIPTOR pSD);

HRESULT
CAAccessCheckpEx(
    IN HANDLE ClientToken,
    IN PSECURITY_DESCRIPTOR pSD,
    IN DWORD dwOption);


#endif // __CAINFOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\audit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999 - 2000
//
// File:        audit.h
//
// Contents:    Cert Server audit classes
//
//---------------------------------------------------------------------------
#ifndef __AUDIT_H__
#define __AUDIT_H__

#include <ntsecapi.h>
#include <authzi.h>

#define AUDIT_FILTER_STARTSTOP      0x00000001
#define AUDIT_FILTER_BACKUPRESTORE  0x00000002
#define AUDIT_FILTER_CERTIFICATE    0x00000004
#define AUDIT_FILTER_CERTREVOCATION 0x00000008
#define AUDIT_FILTER_CASECURITY     0x00000010
#define AUDIT_FILTER_KEYAARCHIVAL   0x00000020
#define AUDIT_FILTER_CACONFIG       0x00000040

#define CA_ACCESS_ALLREADROLES  \
    CA_ACCESS_ADMIN   |         \
    CA_ACCESS_OFFICER |         \
    CA_ACCESS_AUDITOR |         \
    CA_ACCESS_OPERATOR|         \
    CA_ACCESS_READ

namespace CertSrv
{

static const LPCWSTR cAuditString_UnknownDataType = L"?";

// define event

class CAuditEvent
{
public:

    static const DWORD m_gcAuditSuccessOrFailure = 0;
    static const DWORD m_gcNoAuditSuccess = 1;
    static const DWORD m_gcNoAuditFailure = 2;

    CAuditEvent(ULONG ulEventID = 0L, DWORD dwFilter = 0);
    ~CAuditEvent();

    void SetEventID(ULONG ulEventID);

    HRESULT AddData(DWORD dwValue);
    HRESULT AddData(PBYTE pData, DWORD dwDataLen);
    HRESULT AddData(bool fData);
    HRESULT AddData(LPCWSTR pcwszData);
    HRESULT AddData(LPCWSTR *ppcwszData);    
    HRESULT AddData(FILETIME time);
    HRESULT AddData(const VARIANT *pvar, bool fDoublePercentInString);
    void    DeleteLastData() 
    { delete m_pEventDataList[--m_cEventData]; }

    HRESULT Report(bool fSuccess = true);
    HRESULT SaveFilter(LPCWSTR pcwszSanitizedName);
    HRESULT LoadFilter(LPCWSTR pcwszSanitizedName);
    DWORD   GetFilter() {return m_dwFilter;}
    HRESULT AccessCheck(
        ACCESS_MASK Mask,
        DWORD dwAuditFlags,
        handle_t hRpc = NULL,
        HANDLE *phToken = NULL);
    HRESULT CachedGenerateAudit();
    void FreeCachedHandles();

    HRESULT GetMyRoles(DWORD *pdwRoles);

    bool IsEventEnabled();

    HRESULT Impersonate();
    HRESULT RevertToSelf();
    HANDLE  GetClientToken();

    // role separation 
    void EventRoleSeparationEnable(bool fEnable) 
        {m_fRoleSeparationEnabled = fEnable;};

    static void RoleSeparationEnable(bool fEnable) 
        {m_gfRoleSeparationEnabled = fEnable;};
    static bool RoleSeparationIsEnabled() {return m_gfRoleSeparationEnabled;}
    static HRESULT RoleSeparationFlagSave(LPCWSTR pcwszSanitizedName);
    static HRESULT RoleSeparationFlagLoad(LPCWSTR pcwszSanitizedName);
    static void CleanupAuditEventTypeHandles();

    struct AUDIT_CATEGORIES
    {
        ULONG ulAuditID;
        DWORD dwFilter;
        DWORD dwParamCount;
        bool fRoleSeparationEnabled;
        AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType;
    };

private:

    bool IsEventValid();
    bool IsEventRoleSeparationEnabled();

    CAuditEvent(const CAuditEvent&);
    const CAuditEvent& operator=(const CAuditEvent&);

    struct EventData
    {
        EventData() : m_fDoublePercentsInStrings(false)
        {
            PropVariantInit(&m_vtData);
        };
        ~EventData() 
        {
            PropVariantClear(&m_vtData);
        };
        HRESULT ConvertToStringI2I4(
            LONG lVal,
            LPWSTR *ppwszOut);
        HRESULT ConvertToStringUI2UI4(
            ULONG ulVal,
            LPWSTR *ppwszOut);
        HRESULT ConvertToStringWSZ(
            LPCWSTR pcwszVal,
            LPWSTR *ppwszOut);
        HRESULT ConvertToStringBOOL(
            BOOL fVal,
            LPWSTR *ppwszOut);
        HRESULT ConvertToStringArrayUI1(
            LPSAFEARRAY psa,
            LPWSTR *ppwszOut);
        HRESULT ConvertToStringArrayBSTR(
            LPSAFEARRAY psa,
            LPWSTR *ppwszOut);
        HRESULT DoublePercentsInString(
            LPCWSTR pcwszIn,
            LPWSTR *ppwszOut);

        HRESULT ConvertToString(LPWSTR *pwszData);
        PROPVARIANT m_vtData;
        bool m_fDoublePercentsInStrings; // Insertion strings containing %number get
                                         // displayed incorrectly in the event log.
                                         // If this value is set, we double % chars.

    };// struct EventData

    PROPVARIANT *CreateNewEventData();
    EventData   *CreateNewEventData1();
    HRESULT BuildAuditParamArray(PAUDIT_PARAM& rpParamArray);
    void FreeAuditParamArray(PAUDIT_PARAM pParamArray);
    HRESULT GetPrivilegeRoles(PDWORD pdwRoles);
    HRESULT GetUserPrivilegeRoles(
                LSA_HANDLE lsah,
                PSID_AND_ATTRIBUTES pSA, 
                PDWORD pdwRoles);

    HRESULT BuildPrivilegeSecurityDescriptor(
                DWORD dwRoles);

    DWORD GetBitCount(DWORD dwBits)
    {
        DWORD dwCount = 0;
        for(DWORD dwSize = 0; dwSize<sizeof(DWORD); dwSize++, dwBits>>=1)
        {
            dwCount += dwBits&1;
        }
        return dwCount;
    }

    HRESULT DoublePercentsInString(
        LPCWSTR pcwszIn,
        LPCWSTR *ppcwszOut);

    ULONG m_ulEventID;
    enum {m_EventDataMaxSize=10};
    EventData* m_pEventDataList[m_EventDataMaxSize];
    DWORD m_cEventData;
    DWORD m_cRequiredEventData; // expected number of audit parameters
    DWORD m_dwFilter;
    bool m_fRoleSeparationEnabled;

    // free these
    IServerSecurity *m_pISS;
    HANDLE m_hClientToken;
    PSECURITY_DESCRIPTOR m_pCASD;
    AUTHZ_CLIENT_CONTEXT_HANDLE m_ClientContext;
    AUTHZ_ACCESS_CHECK_RESULTS_HANDLE m_AuthzHandle;
    PSECURITY_DESCRIPTOR m_pSDPrivileges;
    PACL m_pDaclPrivileges;

    // no free
    handle_t m_hRpc;
    DWORD m_Error;
    DWORD m_SaclEval;
    ACCESS_MASK m_MaskAllowed;
    AUTHZ_ACCESS_REQUEST m_Request;
    AUTHZ_ACCESS_REPLY m_Reply;
    DWORD m_crtGUID;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE m_hAuditEventType;

    PSID m_pUserSid;

    static AUDIT_CATEGORIES *m_gAuditCategories;
    static DWORD m_gdwAuditCategoriesSize;
    static bool m_gfRoleSeparationEnabled;

    static const DWORD AuditorRoleBit;
    static const DWORD OperatorRoleBit;
    static const DWORD CAAdminRoleBit;
    static const DWORD OfficerRoleBit;
    static const DWORD dwMaskRoles;

}; // class CAuditEvent
} // namespace CertSrv

#endif //__AUDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certbcli.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certbcli.h
//
// Contents:    Cert Server backup client APIs
//
//---------------------------------------------------------------------------

#ifdef _CERTBCLI_TYPECHECK
#undef __CERTBCLI_H__	// allow redundant include
#endif

#ifndef __CERTBCLI_H__
#define __CERTBCLI_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef	MIDL_PASS
#define	RPC_STRING [string]
#else
#define	RPC_STRING
#endif

#define IN
#define OUT
#define OPTIONAL
#define VOID		void

#define CERTBCLI_CALL	__stdcall

#ifndef _CERTBCLI_DEFINED
#define CERTBCLI_API __declspec(dllimport) CERTBCLI_CALL
#else
#define CERTBCLI_API
#endif

#define szBACKUPANNOTATION   "Cert Server Backup Interface"
#define wszBACKUPANNOTATION  TEXT(szBACKUPANNOTATION)

#define szRESTOREANNOTATION  "Cert Server Restore Interface"
#define wszRESTOREANNOTATION TEXT(szRESTOREANNOTATION)


// Type of Backup passed to CertSrvBackupPrepare:
// CSBACKUP_TYPE_FULL: Requesting backup of the complete DB (DB & Log files)
// CSBACKUP_TYPE_LOGS_ONLY: Requesting backup of only the log files
// CSBACKUP_TYPE_INCREMENTAL: Requesting incremental backup

// CertSrvBackupPrepare flags:
#define CSBACKUP_TYPE_FULL		0x00000001
#define CSBACKUP_TYPE_LOGS_ONLY		0x00000002
//#define CSBACKUP_TYPE_INCREMENTAL	0x00000004	// not yet supported
#define CSBACKUP_TYPE_MASK		0x00000003	// valid flags

// Type of Restore passed to CertSrvRestorePrepare:
// CSRESTORE_TYPE_FULL: Requesting restore of the complete DB (DB & Log files)
// CSRESTORE_TYPE_ONLINE: Restoration is done when Cert Server is online.

#define CSRESTORE_TYPE_FULL		0x00000001	// else incremental
#define CSRESTORE_TYPE_ONLINE		0x00000002	// not yet supported
#define CSRESTORE_TYPE_CATCHUP		0x00000004	// not yet supported
#define CSRESTORE_TYPE_MASK		0x00000005	// valid flags


// Setting the current log # to this value would disable incremental backup
#define CSBACKUP_DISABLE_INCREMENTAL  0xffffffff


// BFT is the bit flag used to represent file types (directory/dit/logfile/etc.)
// We keep them as a character so that we can append/prepend them to the actual
// file path. The code in the Backup API's rely on the fact that values 0-256
// in 8 bit ascii map to the values 0-256 in unicode.

typedef WCHAR CSBFT;


// Bit flags:
//  CSBFT_DIRECTORY               - path specified is a directory
//  CSBFT_DATABASE_DIRECTORY      - that file goes into database directory
//  CSBFT_LOG_DIRECTORY           - that the file goes into log directory

#define	CSBFT_DIRECTORY		    0x80
#define CSBFT_DATABASE_DIRECTORY    0x40
#define	CSBFT_LOG_DIRECTORY	    0x20

// Following combinations are defined for easy use of the filetype and the
// directory into into which it goes

#define	CSBFT_LOG		  ((CSBFT) (TEXT('\x01') | CSBFT_LOG_DIRECTORY))
#define	CSBFT_LOG_DIR		  ((CSBFT) (TEXT('\x02') | CSBFT_DIRECTORY))
#define	CSBFT_CHECKPOINT_DIR	  ((CSBFT) (TEXT('\x03') | CSBFT_DIRECTORY))
#define	CSBFT_CERTSERVER_DATABASE ((CSBFT) (TEXT('\x04') | CSBFT_DATABASE_DIRECTORY))
#define	CSBFT_PATCH_FILE	  ((CSBFT) (TEXT('\x05') | CSBFT_LOG_DIRECTORY))
#define	CSBFT_UNKNOWN		  ((CSBFT) (TEXT('\x0f')))


// Backup Context Handle
typedef void *HCSBC;

#ifndef CSEDB_RSTMAP
typedef struct tagCSEDB_RSTMAPW {
    RPC_STRING WCHAR *pwszDatabaseName;
    RPC_STRING WCHAR *pwszNewDatabaseName;
} CSEDB_RSTMAPW;

#define CSEDB_RSTMAP CSEDB_RSTMAPW
#endif // CSEDB_RSTMAP


// For all the functions in this interface that have at least one string
// parameter, provide macros to invoke the appropriate version of the
// corresponding function.

#define CertSrvIsServerOnline		CertSrvIsServerOnlineW
#define CertSrvBackupGetDynamicFileList	CertSrvBackupGetDynamicFileListW
#define CertSrvBackupPrepare		CertSrvBackupPrepareW
#define CertSrvBackupGetDatabaseNames	CertSrvBackupGetDatabaseNamesW
#define CertSrvBackupOpenFile		CertSrvBackupOpenFileW
#define CertSrvBackupGetBackupLogs	CertSrvBackupGetBackupLogsW

#define CertSrvRestoreGetDatabaseLocations CertSrvRestoreGetDatabaseLocationsW
#define CertSrvRestorePrepare		CertSrvRestorePrepareW
#define CertSrvRestoreRegister		CertSrvRestoreRegisterW

#define CertSrvServerControl		CertSrvServerControlW


//+--------------------------------------------------------------------------
// CertSrvIsServerOnline -- check to see if the Cert Server is Online on the
//	given server. This call is guaranteed to return quickly.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server to check
//	[out] pfServerOnline - pointer to receive the bool result
//		(TRUE if Cert Server is online; FALSE, otherwise)
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//+--------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVISSERVERONLINEW)(
    IN  WCHAR const *pwszServerName,
    OUT BOOL *pfServerOnline);

HRESULT
CERTBCLI_API
CertSrvIsServerOnlineW(
    IN  WCHAR const *pwszServerName,
    OUT BOOL *pfServerOnline);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVISSERVERONLINEW *pfnCertSrvIsServerOnline = CertSrvIsServerOnline;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupGetDynamicFileList -- return the list of dynamic files that
//	need to be backed up in addition to database files.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzFileList - pointer to receive the pointer to the file list;
//		allocated memory should be freed using CertSrvBackupFree() API
//		by the caller when it is no longer needed; The file list info
//		is an array of null-terminated filenames and the list is
//		terminated by two L'\0's.
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPGETDYNAMICFILELISTW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvBackupGetDynamicFileListW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPGETDYNAMICFILELISTW *pfnCertSrvBackupGetDynamicFileList = CertSrvBackupGetDynamicFileList;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupPrepare -- prepare the DB for the online backup and return a
//	Backup Context Handle to be used for subsequent calls to backup
//	functions.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server to check
//	[in]  grbitJet - flag to be passed to jet while backing up dbs
//	[in]  dwBackupFlags - CSBACKUP_TYPE_FULL or CSBACKUP_TYPE_LOGS_ONLY
//	[out] phbc - pointer that will receive the backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPPREPAREW)(
    IN  WCHAR const *pwszServerName,
    IN  ULONG grbitJet,
    IN  ULONG dwBackupFlags,	// CSBACKUP_TYPE_*
    OUT HCSBC *phbc);

HRESULT
CERTBCLI_API
CertSrvBackupPrepareW(
    IN  WCHAR const *pwszServerName,
    IN  ULONG grbitJet,
    IN  ULONG dwBackupFlags,	// CSBACKUP_TYPE_*
    OUT HCSBC *phbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPPREPAREW *pfnCertSrvBackupPrepare = CertSrvBackupPrepare;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupGetDatabaseNames -- return the list of data bases that need to
//	be backed up for the given backup context
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzAttachmentInformation - pointer to receive the pointer to
//		the attachment info; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; Attachment info is an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPGETDATABASENAMESW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzAttachmentInformation,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvBackupGetDatabaseNamesW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzAttachmentInformation,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPGETDATABASENAMESW *pfnCertSrvBackupGetDatabaseNames = CertSrvBackupGetDatabaseNames;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupOpenFile -- open the given attachment for read.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[in]  pwszAttachmentName - name of the attachment to be opened for read
//	[in]  cbReadHintSize - suggested size in bytes that might be used
//		during the subsequent reads on this attachment
//	[out] pliFileSize - pointer to a large integer that would receive the
//		size in bytes of the given attachment
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPOPENFILEW)(
    IN  HCSBC hbc,
    IN  WCHAR const *pwszAttachmentName,
    IN  DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize);

HRESULT
CERTBCLI_API
CertSrvBackupOpenFileW(
    IN  HCSBC hbc,
    IN  WCHAR const *pwszAttachmentName,
    IN  DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPOPENFILEW *pfnCertSrvBackupOpenFile = CertSrvBackupOpenFile;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupRead -- read the currently open attachment bytes into the given
//	buffer.  The client application is expected to call this function
//	repeatedly until it gets the entire file (the application would have
//	received the file size through the CertSrvBackupOpenFile call before.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] pvBuffer - pointer to the buffer that would receive the read data.
//	[in]  cbBuffer - specifies the size of the above buffer
//	[out] pcbRead - pointer to receive the actual number of bytes read.
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPREAD)(
    IN  HCSBC hbc,
    OUT VOID *pvBuffer,
    IN  DWORD cbBuffer,
    OUT DWORD *pcbRead);

HRESULT
CERTBCLI_API
CertSrvBackupRead(
    IN  HCSBC hbc,
    OUT VOID *pvBuffer,
    IN  DWORD cbBuffer,
    OUT DWORD *pcbRead);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPREAD *pfnCertSrvBackupRead = CertSrvBackupRead;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupClose -- called by the application after it completes reading all
//	the data in the currently opened attachement.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPCLOSE)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvBackupClose(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPCLOSE *pfnCertSrvBackupClose = CertSrvBackupClose;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupGetBackupLogs -- return the list of log files that need to be
//	backed up for the given backup context
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] pwszzBackupLogFiles - pointer that will receive the pointer to
//		the list of log files; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no
//		longer needed; Log files are returned in an array of
//		null-terminated filenames and the list is terminated by two
//		L'\0's
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPGETBACKUPLOGSW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzBackupLogFiles,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvBackupGetBackupLogsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzBackupLogFiles,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPGETBACKUPLOGSW *pfnCertSrvBackupGetBackupLogs = CertSrvBackupGetBackupLogs;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupTruncateLogs -- called to truncate the already read backup logs.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPTRUNCATELOGS)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvBackupTruncateLogs(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPTRUNCATELOGS *pfnCertSrvBackupTruncateLogs = CertSrvBackupTruncateLogs;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupEnd -- called to end the current backup session.
//
// Parameters:
//	[in] hbc - backup context handle of the backup session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVBACKUPEND)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvBackupEnd(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPEND *pfnCertSrvBackupEnd = CertSrvBackupEnd;
#endif


//+--------------------------------------------------------------------------
// CertSrvBackupFree -- free any buffer allocated by certbcli.dll APIs.
//
// Parameters:
//	[in] pv - pointer to the buffer that is to be freed.
//
// Returns:
//	None.
//---------------------------------------------------------------------------

typedef VOID (CERTBCLI_CALL FNCERTSRVBACKUPFREE)(
    IN VOID *pv);

VOID
CERTBCLI_API
CertSrvBackupFree(
    IN VOID *pv);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVBACKUPFREE *pfnCertSrvBackupFree = CertSrvBackupFree;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreGetDatabaseLocations -- called both at backup time as well as
//	at restorate time to get data base locations for different types of
//	files.
//
// Parameters:
//	[in]  hbc - backup context handle which would have been obtained
//		through CertSrvBackupPrepare in the backup case and through
//		CertSrvRestorePrepare in the restore case.
//	[out] ppwszzDatabaseLocationList - pointer that will receive the
//		pointer to the list of database locations; allocated memory
//		should be freed using CertSrvBackupFree() API by the caller
//		when it is no longer needed; locations are returned in an array
//		of null-terminated names and and the list is terminated by
//		two L'\0's.  The first character of each name is the BFT
//		character that indicates the type of the file and the rest of
//		the name tells gives the path into which that particular type
//		of file should be restored.
//	[out] pcbSize - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREGETDATABASELOCATIONSW)(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzDatabaseLocationList,
    OUT DWORD *pcbSize);

HRESULT
CERTBCLI_API
CertSrvRestoreGetDatabaseLocationsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzDatabaseLocationList,
    OUT DWORD *pcbSize);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREGETDATABASELOCATIONSW *pfnCertSrvRestoreGetDatabaseLocations = CertSrvRestoreGetDatabaseLocations;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestorePrepare -- indicate beginning of a restore session.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server into which
//		the restore operation is going to be performed.
//	[in]  dwRestoreFlags -  Or'ed combination of CSRESTORE_TYPE_* flags;
//		0 if no special flags are to be specified
//	[out] phbc - pointer to receive the backup context handle which is to
//		be passed to the subsequent restore APIs
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREPREPAREW)(
    IN  WCHAR const *pwszServerName,
    IN  ULONG dwRestoreFlags,
    OUT HCSBC *phbc);

HRESULT
CERTBCLI_API
CertSrvRestorePrepareW(
    IN  WCHAR const *pwszServerName,
    IN  ULONG dwRestoreFlags,		// CSRESTORE_TYPE_*
    OUT HCSBC *phbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREPREPAREW *pfnCertSrvRestorePrepare = CertSrvRestorePrepare;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreRegister -- register a restore operation. It will interlock
//	all subsequent restore operations, and will prevent the restore target
//	from starting until the call to CertSrvRestoreRegisterComplete is made.
//
// Parameters:
//	[in] hbc - backup context handle for the restore session.
//	[in] pwszCheckPointFilePath - path to restore the check point files
//	[in] pwszLogPath - path where the log files are restored
//	[in] rgrstmap - restore map
//	[in] crstmap - tells if there is a new restore map
//	[in] pwszBackupLogPath - path where the backup logs are located
//	[in] genLow - Lowest log# that was restored in this restore session
//	[in] genHigh - Highest log# that was restored in this restore session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREREGISTERW)(
    OPTIONAL IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh);

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterW(
    OPTIONAL IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh);

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterThroughFile(
    IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREREGISTERW *pfnCertSrvRestoreRegister = CertSrvRestoreRegister;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreRegisterComplete -- indicate that a previously registered
//	restore is complete.
//
// Parameters:
//	[in] hbc - backup context handle
//	[in] hrRestoreState - success code if the restore was successful
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREREGISTERCOMPLETE)(
    OPTIONAL IN HCSBC hbc,
    IN HRESULT hrRestoreState);

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterComplete(
    OPTIONAL IN HCSBC hbc,
    IN HRESULT hrRestoreState);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREREGISTERCOMPLETE *pfnCertSrvRestoreRegisterComplete = CertSrvRestoreRegisterComplete;
#endif


//+--------------------------------------------------------------------------
// CertSrvRestoreEnd -- end a restore session
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

typedef HRESULT (CERTBCLI_CALL FNCERTSRVRESTOREEND)(
    IN HCSBC hbc);

HRESULT
CERTBCLI_API
CertSrvRestoreEnd(
    IN HCSBC hbc);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVRESTOREEND *pfnCertSrvRestoreEnd = CertSrvRestoreEnd;
#endif


//+--------------------------------------------------------------------------
// CertSrvServerControl -- send a control command to the cert server.
//
// Parameters:
//	[in]  pwszServerName - name or config string of the server to control
//	[in]  dwControlFlags - control command and flags
//	[out] pcbOut - pointer to receive the size of command output data
//	[out] ppbOut - pointer to receive command output data.  Use the
//		CertSrvBackupFree() API to free the buffer.
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

#define CSCONTROL_SHUTDOWN	    0x000000001
#define CSCONTROL_SUSPEND	    0x000000002
#define CSCONTROL_RESTART	    0x000000003

typedef HRESULT (CERTBCLI_CALL FNCERTSRVSERVERCONTROLW)(
    IN WCHAR const *pwszServerName,
    IN DWORD dwControlFlags,
    OPTIONAL OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE **ppbOut);

HRESULT
CERTBCLI_API
CertSrvServerControlW(
    IN WCHAR const *pwszServerName,
    IN DWORD dwControlFlags,
    OPTIONAL OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE **ppbOut);

#ifdef _CERTBCLI_TYPECHECK
FNCERTSRVSERVERCONTROLW *pfnCertSrvServerControl = CertSrvServerControl;
#endif


#ifdef __cplusplus
}
#endif

#endif // __CERTBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\celib.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       celib.h
//
//  Contents:   helper functions
//
//--------------------------------------------------------------------------

#ifndef __CELIB_H__
#define __CELIB_H__

#include <stdio.h>


#define CENCODEMAX	(64 * 1024)

// Bitmap manipulation routines.  Fetch or set a bit, given a base and index.
#define GETBIT(pb, i)	((pb)[(i) / 8] & (1 << ((i) % 8)))
#define SETBIT(pb, i)	((pb)[(i) / 8] |= (1 << ((i) % 8)))
#define CLEARBIT(pb, i)	((pb)[(i) / 8] &= ~(1 << ((i) % 8)))

#define BITSTOBYTES(b)	((int)(((b) + 7) / 8))

// Size of a fixed array:
#define ARRAYSIZE(a)		(sizeof(a)/sizeof((a)[0]))

// wcslen of a static string:
#define WSZARRAYSIZE(a)		((sizeof(a)/sizeof((a)[0])) - 1)

#define wszCERTENROLLSHAREPATH	L"CertSrv\\CertEnroll"

#define cwcHRESULTSTRING	40

#define SAFE_SUBTRACT_POINTERS(p1, p2) \
    (assert(sizeof((*p1)) == sizeof(*(p2))), (DWORD)((p1) - (p2)))

#define printf	Use_wprintf_Instead_Of_printf

#define _LeaveError(hr, pszMessage) \
	_LeaveErrorStr2((hr), (pszMessage), NULL, S_OK)

#define _LeaveError2(hr, pszMessage, hr2) \
	_LeaveErrorStr2((hr), (pszMessage), NULL, (hr2))

#define _LeaveErrorStr(hr, pszMessage, pwszData) \
	_LeaveErrorStr2((hr), (pszMessage), (pwszData), S_OK)

#define _LeaveErrorStr2(hr, pszMessage, pwszData, hr2) \
    { \
	ceERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	__leave; \
    }

#define _LeaveIfError(hr, pszMessage) \
	_LeaveIfErrorStr2((hr), (pszMessage), NULL, S_OK)

#define _LeaveIfError2(hr, pszMessage, hr2) \
	_LeaveIfErrorStr2((hr), (pszMessage), NULL, (hr2))

#define _LeaveIfErrorStr(hr, pszMessage, pwszData) \
	_LeaveIfErrorStr2((hr), (pszMessage), (pwszData), S_OK)

#define _LeaveIfErrorStr2(hr, pszMessage, pwszData, hr2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    ceERRORPRINTLINESTR((pszMessage), (pwszData), (hr)); \
	    __leave; \
	} \
    }

#define _PrintErrorStr(hr, pszMessage, pwsz) \
    ceERRORPRINTLINESTR((pszMessage), (pwsz), (hr))

#define _PrintErrorStr2(hr, pszMessage, pwsz, hr2) \
    _PrintErrorStr((hr), (pszMessage), (pwsz))

#define _PrintError2(hr, pszMessage, hr2) \
    _PrintErrorStr((hr), (pszMessage), NULL)

#define _PrintError(hr, pszMessage) \
    _PrintErrorStr((hr), (pszMessage), NULL)


#define _PrintIfErrorStr(hr, pszMessage, pwsz) \
    { \
	if (S_OK != (hr)) \
	{ \
	    ceERRORPRINTLINESTR((pszMessage), (pwsz), (hr)); \
	} \
    }

#define _PrintIfErrorStr2(hr, pszMessage, pwsz, hr2) \
    _PrintIfErrorStr((hr), (pszMessage), (pwsz))

#define _PrintIfError2(hr, pszMessage, hr2) \
    _PrintIfErrorStr((hr), (pszMessage), NULL)

#define _PrintIfError(hr, pszMessage) \
    _PrintIfErrorStr((hr), (pszMessage), NULL)


#define _JumpErrorStr(hr, label, pszMessage, pwsz) \
    _JumpError((hr), label, (pszMessage))

#define _JumpError(hr, label, pszMessage) \
    { \
	ceERRORPRINTLINESTR((pszMessage), NULL, (hr)); \
	goto label; \
    }


#define _JumpIfErrorStr(hr, label, pszMessage, pwsz) \
    { \
	if (S_OK != (hr)) \
	{ \
	    ceERRORPRINTLINESTR((pszMessage), (pwsz), (hr)); \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr2(hr, label, pszMessage, pwsz, hr2) \
    _JumpIfErrorStr((hr), label, (pszMessage), NULL)

#define _JumpIfError2(hr, label, pszMessage, hr2) \
    _JumpIfErrorStr((hr), label, (pszMessage), NULL)

#define _JumpIfError(hr, label, pszMessage) \
    _JumpIfErrorStr((hr), label, (pszMessage), NULL)


#define ceERRORPRINTLINE(pszMessage, hr) \
	    ceErrorPrintLine(__FILE__, __LINE__, (pszMessage), NULL, (hr))

#define ceERRORPRINTLINESTR(pszMessage, pwszData, hr) \
	    ceErrorPrintLine(__FILE__, __LINE__, (pszMessage), (pwszData), (hr))

#define DBGPRINT(a)	ceDbgPrintf a

int WINAPIV ceDbgPrintf(BOOL fDebug, char const *pszfmt, ...);


VOID
ceErrorPrintLine(
    IN char const *pszFile,
    IN DWORD line,
    IN char const *pszMessage,
    IN WCHAR const *pwszData,
    IN HRESULT hr);

HRESULT
ceHLastError(VOID);

HRESULT
ceHError(
    IN HRESULT hr);

#define chLBRACE	'{'
#define chRBRACE	'}'
#define szLBRACE	"{"
#define szRBRACE	"}"
#define wcLBRACE	L'{'
#define wcRBRACE	L'}'
#define wszLBRACE	L"{"
#define wszRBRACE	L"}"

#define chLPAREN	'('
#define chRPAREN	')'
#define szLPAREN	"("
#define szRPAREN	")"
#define wcLPAREN	L'('
#define wcRPAREN	L')'
#define wszLPAREN	L"("
#define wszRPAREN	L")"

// Constants chosen to avoid DWORD overflow:

#define CVT_WEEKS	(7 * CVT_DAYS)
#define CVT_DAYS	(24 * CVT_HOURS)
#define CVT_HOURS	(60 * CVT_MINUTES)
#define CVT_MINUTES	(60 * CVT_SECONDS)
#define CVT_SECONDS	(1)
#define CVT_BASE	(1000 * 1000 * 10)


enum ENUM_PERIOD
{
    ENUM_PERIOD_INVALID = -1,
    ENUM_PERIOD_SECONDS = 0,
    ENUM_PERIOD_MINUTES,
    ENUM_PERIOD_HOURS,
    ENUM_PERIOD_DAYS,
    ENUM_PERIOD_WEEKS,
    ENUM_PERIOD_MONTHS,
    ENUM_PERIOD_YEARS
};


typedef struct _LLFILETIME
{
    union {
	LONGLONG ll;
	FILETIME ft;
    };
} LLFILETIME;


__inline VOID
ceAddToFileTime(
    IN OUT FILETIME *pft,
    IN LONGLONG ll)
{
    LLFILETIME llft;

    llft.ft = *pft;
    llft.ll += ll;
    *pft = llft.ft;
}


__inline LONGLONG
ceSubtractFileTimes(
    IN FILETIME const *pft1,
    IN FILETIME const *pft2)
{
    LLFILETIME llft1;
    LLFILETIME llft2;

    llft1.ft = *pft1;
    llft2.ft = *pft2;
    return(llft1.ll - llft2.ll);
}


HRESULT
ceMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod);

HRESULT
ceTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount);

WCHAR const *
ceGetOIDNameA(
    IN char const *pszObjId);

WCHAR const *
ceGetOIDName(
    IN WCHAR const *pwszObjId);

BOOL
ceDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN BOOL fCoTaskMemAlloc,
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo);

BOOL
ceEncodeObject(
    DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,
    IN BOOL fCoTaskMemAlloc,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

WCHAR *
ceDuplicateString(
    IN WCHAR const *pwsz);

BOOL
ceConvertWszToSz(
    OUT char **ppsz,
    IN WCHAR const *pwc,
    IN LONG cb);

BOOL
ceConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb);

BOOL
ceConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN char const *pch,
    IN LONG cch);

BOOL
ceConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch);

VOID
ceFreeBstr(
    IN OUT BSTR *pstr);

HRESULT
ceDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft);

HRESULT
ceFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate);

HRESULT
ceVerifyObjId(
    IN WCHAR const *pwszObjId);

HRESULT
ceVerifyAltNameString(
    IN LONG NameChoice,
    IN WCHAR const *pwszName);

HRESULT
ceDispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid);

VOID
ceInitErrorMessageText(
    IN HMODULE hMod,
    IN DWORD idsUnexpected,
    IN DWORD idsUnknownErrorCode);	// L"Error %ws %ws"

WCHAR *
ceGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString);

WCHAR const *
ceHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr);


#define cwcFILENAMESUFFIXMAX		20
#define cwcSUFFIXMAX	(1 + 5 + 1)	// five decimal digits plus parentheses

#define wszFCSAPARM_SERVERDNSNAME	L"%1"
#define wszFCSAPARM_SERVERSHORTNAME	L"%2"
#define wszFCSAPARM_SANITIZEDCANAME	L"%3"
#define wszFCSAPARM_CERTFILENAMESUFFIX	L"%4"
#define wszFCSAPARM_DOMAINDN		L"%5"
#define wszFCSAPARM_CONFIGDN		L"%6"
#define wszFCSAPARM_SANITIZEDCANAMEHASH	L"%7"
#define wszFCSAPARM_CRLFILENAMESUFFIX	L"%8"
#define wszFCSAPARM_CRLDELTAFILENAMESUFFIX L"%9"
#define wszFCSAPARM_DSCRLATTRIBUTE	L"%10"
#define wszFCSAPARM_DSCACERTATTRIBUTE	L"%11"


HRESULT
ceFormatCertsrvStringArray(
    IN BOOL fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7,
    IN DWORD   iCert_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6,
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut);

HRESULT
ceInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut);

int 
ceWtoI(
    IN WCHAR const *pwszDigitString,
    OUT BOOL *pfValid);

HRESULT
ceIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal);

#endif // __CELIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certacl.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certacl.h
//
// Contents:    Cert Server security defines
//
//---------------------------------------------------------------------------

#ifndef __CERTACL_H__
#define __CERTACL_H__
#include <sddl.h>
#include "clibres.h"
#include "certsd.h"

// externs
// externs
extern const GUID GUID_APPRV_REQ;
extern const GUID GUID_REVOKE;
extern const GUID GUID_ENROLL;
extern const GUID GUID_AUTOENROLL;
extern const GUID GUID_READ_DB;
//defines

#define MAX_SID_LEN 256

// !!! The SD strings below need to be in sync with certadm.idl definitions

#define WSZ_CA_ACCESS_ADMIN      L"0x00000001" // CA administrator
#define WSZ_CA_ACCESS_OFFICER    L"0x00000002" // certificate officer
#define WSZ_CA_ACCESS_AUDITOR    L"0x00000004" // auditor
#define WSZ_CA_ACCESS_OPERATOR   L"0x00000008" // backup operator
#define WSZ_CA_ACCESS_MASKROLES  L"0x000000ff" 
#define WSZ_CA_ACCESS_READ       L"0x00000100" // read only access to CA
#define WSZ_CA_ACCESS_ENROLL     L"0x00000200" // enroll access to CA
#define WSZ_CA_ACCESS_MASKALL    L"0x0000ffff"


// Important, keep enroll string GUID in sync with define in acl.cpp
#define WSZ_GUID_ENROLL           L"0e10c968-78fb-11d2-90d4-00c04f79dc55"
#define WSZ_GUID_AUTOENROLL       L"a05b8cc2-17bc-4802-a710-e7c15ab866a2"

// ca access rights define here
// note: need to keep string access and mask in sync!
// WSZ_ACTRL_CERTSRV_MANAGE =      L"CCDCLCSWRPWPDTLOCRSDRCWDWO"
#define WSZ_ACTRL_CERTSRV_MANAGE   SDDL_CREATE_CHILD \
                                   SDDL_DELETE_CHILD \
                                   SDDL_LIST_CHILDREN \
                                   SDDL_SELF_WRITE \
                                   SDDL_READ_PROPERTY \
                                   SDDL_WRITE_PROPERTY \
                                   SDDL_DELETE_TREE \
                                   SDDL_LIST_OBJECT \
                                   SDDL_CONTROL_ACCESS \
                                   SDDL_STANDARD_DELETE \
                                   SDDL_READ_CONTROL \
                                   SDDL_WRITE_DAC \
                                   SDDL_WRITE_OWNER
#define ACTRL_CERTSRV_MANAGE       (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    READ_CONTROL | \
                                    DELETE | \
                                    WRITE_DAC | \
                                    WRITE_OWNER | \
                                    ACTRL_DS_CONTROL_ACCESS | \
                                    ACTRL_DS_CREATE_CHILD | \
                                    ACTRL_DS_DELETE_CHILD | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_SELF | \
                                    ACTRL_DS_DELETE_TREE | \
                                    ACTRL_DS_LIST_OBJECT)


#define WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS \
                                   SDDL_CREATE_CHILD \
                                   SDDL_DELETE_CHILD \
                                   SDDL_LIST_CHILDREN \
                                   SDDL_SELF_WRITE \
                                   SDDL_READ_PROPERTY \
                                   SDDL_WRITE_PROPERTY \
                                   SDDL_DELETE_TREE \
                                   SDDL_LIST_OBJECT \
                                   SDDL_STANDARD_DELETE \
                                   SDDL_READ_CONTROL \
                                   SDDL_WRITE_DAC \
                                   SDDL_WRITE_OWNER

#define ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS \
                                   (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    READ_CONTROL | \
                                    DELETE | \
                                    WRITE_DAC | \
                                    WRITE_OWNER | \
                                    ACTRL_DS_CREATE_CHILD | \
                                    ACTRL_DS_DELETE_CHILD | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_SELF | \
                                    ACTRL_DS_DELETE_TREE | \
                                    ACTRL_DS_LIST_OBJECT)


// WSZ_ACTRL_CERTSRV_READ =        L"RPLCLORC"
#define WSZ_ACTRL_CERTSRV_READ     SDDL_READ_PROPERTY \
                                   SDDL_LIST_CHILDREN \
                                   SDDL_LIST_OBJECT \
                                   SDDL_READ_CONTROL
#define ACTRL_CERTSRV_READ         (READ_CONTROL | \
                                    ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_LIST_OBJECT)

// WSZ_ACTRL_CERTSRV_ENROLL =      L"WPRPCR"
#define WSZ_ACTRL_CERTSRV_ENROLL   SDDL_WRITE_PROPERTY \
                                   SDDL_READ_PROPERTY \
                                   SDDL_CONTROL_ACCESS
#define ACTRL_CERTSRV_ENROLL       (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    ACTRL_DS_CONTROL_ACCESS)

#define WSZ_ACTRL_CERTSRV_CAADMIN SDDL_CONTROL_ACCESS
#define WSZ_ACTRL_CERTSRV_OFFICER SDDL_CONTROL_ACCESS
#define WSZ_ACTRL_CERTSRV_CAREAD  SDDL_CONTROL_ACCESS
#define ACTRL_CERTSRV_CAADMIN       ACTRL_DS_CONTROL_ACCESS
#define ACTRL_CERTSRV_OFFICER       ACTRL_DS_CONTROL_ACCESS
#define ACTRL_CERTSRV_CAREAD        ACTRL_DS_CONTROL_ACCESS
            
// define all ca string security here in consistant format

//    SDDL_OWNER L":" SDDL_ENTERPRISE_ADMINS \
//    SDDL_GROUP L":" SDDL_ENTERPRISE_ADMINS \
//    SDDL_DACL  L":" SDDL_PROTECTED SDDL_AUTO_INHERITED \
//    L"(" SDDL_ACCESS_ALLOWED or SDDL_OBJECT_ACCESS_ALLOWED L";" \
//         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT or list L";" \
//         list of AccessRights L";" \
//         StringGUID L";" \
//         L";" \
//         SDDL_EVERYONE or Sid L")"
//    ...list of ace

#define CERTSRV_STD_ACE(access, sid) \
    L"(" SDDL_ACCESS_ALLOWED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT L";" \
         access L";;;" sid L")"

#define CERTSRV_INH_ACE(access, sid) \
    L"(" SDDL_ACCESS_ALLOWED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT SDDL_INHERIT_ONLY L";" \
         access L";;;" sid L")"

#define CERTSRV_OBJ_ACE(access, guid, sid) \
    L"(" SDDL_OBJECT_ACCESS_ALLOWED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT L";" \
         access L";" \
         guid L";;" sid L")"

#define CERTSRV_OBJ_ACE_DENY(access, guid, sid) \
    L"(" SDDL_OBJECT_ACCESS_DENIED L";" \
         SDDL_OBJECT_INHERIT SDDL_CONTAINER_INHERIT L";" \
         access L";" \
         guid L";;" sid L")"

#define CERTSRV_STD_OG(owner, group) \
    SDDL_OWNER L":" owner SDDL_GROUP L":" group \
    SDDL_DACL  L":" SDDL_AUTO_INHERITED

#define CERTSRV_SACL_ON \
    SDDL_SACL  L": (" SDDL_AUDIT L";" \
                      SDDL_AUDIT_SUCCESS SDDL_AUDIT_FAILURE L";" \
                      WSZ_CA_ACCESS_MASKALL L";;;" \
                      SDDL_EVERYONE L")"

#define CERTSRV_SACL_OFF \
    SDDL_SACL  L":"

#define WSZ_CERTSRV_SID_ANONYMOUS_LOGON L"S-1-5-7"
#define WSZ_CERTSRV_SID_EVERYONE L"S-1-1-0"

// Default Standalone security
// Standalone
// Owner, local administrators
// Group, local administrators
// DACL:
//  enroll  - everyone
//  caadmin - builtin\administrators
//  officer - builtin\administrators
#define WSZ_DEFAULT_CA_STD_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ENROLL,   SDDL_EVERYONE) \
    CERTSRV_SACL_ON

// Default Enterprise Security
// Owner, Enterprise Administrators
// Group, Enterprise Administrators
// DACL:
//  enroll  - authenticated users
//  caadmin - builtin\administrators
//          - domain admins
//          - enterprise admins
//  officer - builtin\administrators
//          - domain admins
//          - enterprise admins
#define WSZ_DEFAULT_CA_ENT_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ADMIN,    SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_OFFICER,  SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_CA_ACCESS_ENROLL,   SDDL_AUTHENTICATED_USERS) \
    CERTSRV_SACL_ON

// DS Container 
// (CDP/CA container)
// Owner: Enterprise Admins (overidden by installer)
// Group: Enterprise Admins (overidden by installer)
// DACL:
//   Enterprise Admins - Full Control
//   Domain Admins - Full Control
//   Cert Publishers - Full Control
//   Builtin Admins - Full Control
//   Everyone - Read
#define WSZ_DEFAULT_CA_DS_SECURITY \
    CERTSRV_STD_OG(SDDL_ENTERPRISE_ADMINS,    SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_CERT_SERV_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_EVERYONE)

// NTAuthCertificates  
//
// Owner: Enterprise Admins (overidden by installer)
// Group: Enterprise Admins (overidden by installer)
// DACL:
//   Enterprise Admins - Full Control
//   Domain Admins - Full Control
//   Builtin Admins - Full Control
//   Everyone - Read
#define WSZ_DEFAULT_NTAUTH_SECURITY \
    CERTSRV_STD_OG(SDDL_ENTERPRISE_ADMINS,    SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_EVERYONE)

//  CDP/CA
// Owner: Enterprise Admins (overidden by installer)
// Group: Enterprise Admins (overidden by installer)
// DACL:
//   Enterprise Admins - Full Control
//   Domain Admins - Full Control
//   Cert Publishers - Full Control
//   Builtin Admins- Full Control
//   Authenticated Users - Read
#define WSZ_DEFAULT_CDP_DS_SECURITY \
    CERTSRV_STD_OG(SDDL_ENTERPRISE_ADMINS, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, L"%ws") \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_EVERYONE)

// Shared Folder related security
// Owner: Local Admin
// DACL:
// Local Admin - Full Control
// LocalSystem - Full Control
// Enterprise Admins - Full Control
// Everyone - Read
#define WSZ_DEFAULT_SF_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_LOCAL_SYSTEM)

#define WSZ_DEFAULT_SF_USEDS_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_LOCAL_SYSTEM) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_ENTERPRISE_ADMINS)

#define WSZ_DEFAULT_SF_EVERYONEREAD_SECURITY \
    WSZ_DEFAULT_SF_SECURITY \
    CERTSRV_STD_ACE(SDDL_GENERIC_READ, SDDL_EVERYONE)

#define WSZ_DEFAULT_SF_USEDS_EVERYONEREAD_SECURITY \
    WSZ_DEFAULT_SF_USEDS_SECURITY \
    CERTSRV_STD_ACE(SDDL_GENERIC_READ, SDDL_EVERYONE)

// Enroll share security
// Owner: Administrators
// Group: Administrators
// DACL:
//   Everyone: read access
//   local admin: full access
#define WSZ_ACTRL_CERTSRV_SHARE_READ      SDDL_FILE_READ \
                                          SDDL_READ_CONTROL \
                                          SDDL_GENERIC_READ \
                                          SDDL_GENERIC_EXECUTE
#define WSZ_ACTRL_CERTSRV_SHARE_ALL       SDDL_FILE_ALL \
                                          SDDL_CREATE_CHILD \
                                          SDDL_STANDARD_DELETE \
                                          SDDL_READ_CONTROL \
                                          SDDL_WRITE_DAC \
                                          SDDL_WRITE_OWNER \
                                          SDDL_GENERIC_ALL
#define WSZ_DEFAULT_SHARE_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_SHARE_READ, SDDL_EVERYONE) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_SHARE_ALL,  SDDL_BUILTIN_ADMINISTRATORS)


// Service string below need to be in sync with the following
// definitions from winsvc.h
//#define SERVICE_QUERY_CONFIG           0x0001
//#define SERVICE_CHANGE_CONFIG          0x0002
//#define SERVICE_QUERY_STATUS           0x0004
//#define SERVICE_ENUMERATE_DEPENDENTS   0x0008
//#define SERVICE_START                  0x0010
//#define SERVICE_STOP                   0x0020
//#define SERVICE_PAUSE_CONTINUE         0x0040
//#define SERVICE_INTERROGATE            0x0080
//#define SERVICE_USER_DEFINED_CONTROL   0x0100

// full access to service
// STANDARD_RIGHTS_REQUIRED
// SERVICE_QUERY_CONFIG
// SERVICE_CHANGE_CONFIG
// SERVICE_QUERY_STATUS
// SERVICE_ENUMERATE_DEPENDENTS
// SERVICE_START
// SERVICE_STOP
// SERVICE_PAUSE_CONTINUE
// SERVICE_INTERROGATE
// SERVICE_USER_DEFINED_CONTROL
#define WSZ_SERVICE_ALL_ACCESS L"0x000f01ff"


// Read-only access to service
//  SERVICE_QUERY_CONFIG, 
//  SERVICE_QUERY_STATUS, 
//  SERVICE_ENUMERATE_DEPENDENTS, 
//  SERVICE_INTERROGATE
//  SERVICE_USER_DEFINED_CONTROL

#define WSZ_SERVICE_READ L"0x0000018d"

#define WSZ_SERVICE_START_STOP L"0x00000030"

// Power user and system access
// SERVICE_QUERY_CONFIG
// SERVICE_QUERY_STATUS
// SERVICE_ENUMERATE_DEPENDENTS
// SERVICE_START
// SERVICE_STOP
// SERVICE_PAUSE_CONTINUE
// SERVICE_INTERROGATE
// SERVICE_USER_DEFINED_CONTROL
#define WSZ_SERVICE_POWER_USER L"0x000001fd"

#define CERTSRV_SERVICE_SACL_ON \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    SDDL_SACL  L": (" SDDL_AUDIT L";" \
                      SDDL_AUDIT_SUCCESS SDDL_AUDIT_FAILURE L";" \
                      WSZ_SERVICE_START_STOP L";;;" \
                      SDDL_EVERYONE L")"

#define CERTSRV_SERVICE_SACL_OFF \
    SDDL_SACL L":"

// Certsrv service default security
#define WSZ_DEFAULT_SERVICE_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_SERVICE_READ, SDDL_AUTHENTICATED_USERS) \
    CERTSRV_STD_ACE(WSZ_SERVICE_POWER_USER, SDDL_POWER_USERS) \
    CERTSRV_STD_ACE(WSZ_SERVICE_POWER_USER, SDDL_LOCAL_SYSTEM) \
    CERTSRV_STD_ACE(WSZ_SERVICE_ALL_ACCESS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_SERVICE_ALL_ACCESS, SDDL_SERVER_OPERATORS)

// DS pKIEnrollmentService default security
#define WSZ_DEFAULT_DSENROLLMENT_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS, SDDL_DOMAIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS, SDDL_ENTERPRISE_ADMINS) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS, SDDL_LOCAL_SYSTEM) \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS, L"%ws") \
    CERTSRV_STD_ACE(WSZ_ACTRL_CERTSRV_READ,   SDDL_AUTHENTICATED_USERS)

// Key Conatiner security
// Owner: local admin
// Group: local admin
// DACL:
// Local Admin - Full Control
// LocalSystem - Full Control
#define WSZ_DEFAULT_KEYCONTAINER_SECURITY \
    CERTSRV_STD_OG(SDDL_BUILTIN_ADMINISTRATORS, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_BUILTIN_ADMINISTRATORS) \
    CERTSRV_STD_ACE(SDDL_GENERIC_ALL, SDDL_LOCAL_SYSTEM)

// upgrade security
// DACL:
// Local Admin - Full Control
// Everyone - read
#define WSZ_DEFAULT_UPGRADE_SECURITY \
    CERTSRV_STD_ACE(SDDL_FILE_READ, SDDL_EVERYONE) \
    CERTSRV_STD_ACE(SDDL_FILE_ALL, SDDL_BUILTIN_ADMINISTRATORS)


// following defines certsrv security editing access

#define GUID_CERTSRV         GUID_NULL
#define ACTRL_CERTSRV_OBJ    ACTRL_DS_CONTROL_ACCESS
#define CS_GEN_SIAE(access, ids) \
            {&GUID_CERTSRV, (access), MAKEINTRESOURCE((ids)), \
             SI_ACCESS_GENERAL}
#define CS_SPE_SIAE(access, ids) \
            {&GUID_CERTSRV, (access), MAKEINTRESOURCE((ids)), \
             SI_ACCESS_SPECIFIC}
#define OBJ_GEN_SIAE(guid, access, ids) \
            {&(guid), (access), MAKEINTRESOURCE((ids)), \
             SI_ACCESS_GENERAL|SI_ACCESS_SPECIFIC}
#define OBJ_SPE_SIAE(guid, ids) \
            {&(guid), ACTRL_CERTSRV_OBJ, MAKEINTRESOURCE((ids)), \
             SI_ACCESS_SPECIFIC}
#define OBJ_SPE_SIAE_OICI(guid, ids) \
            {&(guid), ACTRL_CERTSRV_OBJ, MAKEINTRESOURCE((ids)), \
             SI_ACCESS_SPECIFIC | OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE }

#define CERTSRV_SI_ACCESS_LIST \
    CS_GEN_SIAE(CA_ACCESS_READ,     IDS_ACTRL_CAREAD), \
    CS_GEN_SIAE(CA_ACCESS_OFFICER,  IDS_ACTRL_OFFICER), \
    CS_GEN_SIAE(CA_ACCESS_ADMIN,    IDS_ACTRL_CAADMIN), \
    CS_GEN_SIAE(CA_ACCESS_ENROLL,   IDS_ACTRL_ENROLL), \
// disabled for beta1   CS_GEN_SIAE(CA_ACCESS_AUDITOR,  IDS_ACTRL_AUDITOR), 
// disabled for beta1   CS_GEN_SIAE(CA_ACCESS_OPERATOR,  IDS_ACTRL_OPERATOR), 
HRESULT
myGetSDFromTemplate(
    IN WCHAR const           *pwszStringSD,
    IN OPTIONAL WCHAR const  *pwszReplace,
    OUT PSECURITY_DESCRIPTOR *ppSD);

HRESULT
CertSrvMapAndSetSecurity(
    OPTIONAL IN WCHAR const *pwszSanitizedName, 
    IN WCHAR const *pwszKeyContainerName, 
    IN BOOL         fSetDsSecurity,
    IN SECURITY_INFORMATION si,
    IN PSECURITY_DESCRIPTOR pSD);

HRESULT
SetCAKeySecurity(
    IN SECURITY_INFORMATION          si,
    IN WCHAR const                  *pwszSanitizedName, 
    IN WCHAR const                  *pwszKeyContainerName, 
    IN OPTIONAL PSECURITY_DESCRIPTOR pSD);

HRESULT 
myMergeSD(
    IN PSECURITY_DESCRIPTOR   pSDOld,
    IN PSECURITY_DESCRIPTOR   pSDMerge, 
    IN SECURITY_INFORMATION   si,
    OUT PSECURITY_DESCRIPTOR *ppSDNew);

HRESULT
UpdateServiceSacl(bool fTurnOnAuditing);

#endif // __CERTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certmsg.h
//
//--------------------------------------------------------------------------

#ifndef __CERTMSG_H__
#define __CERTMSG_H__

#define CMB_NOERRFROMSYS         0x10000000L
#define CMB_REPEATWIZPREFIX      0x20000000L

int
CertMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN  UINT uType,
    IN OPTIONAL  const WCHAR * pwszCustomMsg
);


int
CertInfoMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN OPTIONAL const WCHAR * pwszCustomMsg
);

int
CertErrorMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg
);

int
CertWarningMessageBox
(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg
);


typedef VOID (FNLOGMESSAGEBOX)(
    IN HRESULT hrMsg,
    IN UINT idMsg,
    IN WCHAR const *pwszTitle,
    IN WCHAR const *pwszMessage);

VOID
CertLogMessageBoxInit(
    IN FNLOGMESSAGEBOX *pfnLogMessagBox);

#endif //__CERTMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certreq.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certreq.h
//
// Contents:    ICertRequest definitions
//
// History:     03-Jan-97       vich created
//
//---------------------------------------------------------------------------

#ifndef __CERTREQ_H__
#define __CERTREQ_H__

#ifdef __cplusplus
extern "C" {
#endif


// begin_certsrv

//+--------------------------------------------------------------------------
// Known request Attribute names and Value strings

// RequestType attribute name:
#define wszCERT_TYPE		L"RequestType"	// attribute name

// RequestType attribute values:
// Not specified: 				// Non-specific certificate
#define wszCERT_TYPE_CLIENT	L"Client"	// Client authentication cert
#define wszCERT_TYPE_SERVER	L"Server"	// Server authentication cert
#define wszCERT_TYPE_CODESIGN	L"CodeSign"	// Code signing certificate
#define wszCERT_TYPE_CUSTOMER	L"SetCustomer"	// SET Customer certificate
#define wszCERT_TYPE_MERCHANT	L"SetMerchant"	// SET Merchant certificate
#define wszCERT_TYPE_PAYMENT	L"SetPayment"	// SET Payment certificate


// Version attribute name:
#define wszCERT_VERSION		L"Version"	// attribute name

// Version attribute values:
// Not specified: 				// Whetever is current
#define wszCERT_VERSION_1	L"1"		// Version one certificate
#define wszCERT_VERSION_2	L"2"		// Version two certificate
#define wszCERT_VERSION_3	L"3"		// Version three certificate

// end_certsrv

#ifdef __cplusplus
}
#endif
#endif // __CERTREQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certimp.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    certimp.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "certimp.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <winbase.h>
#include <lmcons.h>
#define	_INC_WINDOWS
#include <winsock.h>
#include <certbcli.h>

#ifdef MIDL_PASS
#define BOOL DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certca.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        certca.h
//
// Contents:    Definition of the CA Info API
//
// History:     12-dec-97       petesk  created
//              28-Jan-2000     xiaohs  updated
//
//---------------------------------------------------------------------------


#ifndef __CERTCA_H__
#define __CERTCA_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"{
#endif


#include <wincrypt.h>

#if !defined(_CERTCLI_)
#define CERTCLIAPI DECLSPEC_IMPORT
#else
#define CERTCLIAPI
#endif


typedef VOID *  HCAINFO;

typedef VOID *  HCERTTYPE;

typedef VOID *  HCERTTYPEQUERY;

//*****************************************************************************
//
// Flags used by CAFindByName, CAFindByCertType, CAFindByIssuerDN and
// CAEnumFirstCA
//
// See comments on each API for a list of applicable flags
//
//*****************************************************************************
//the wszScope supplied is a domain location in the DNS format
#define CA_FLAG_SCOPE_DNS               0x00000001

// include untrusted CA
#define CA_FIND_INCLUDE_UNTRUSTED       0x00000010

// running as local system.  Used to verify CA certificate chain
#define CA_FIND_LOCAL_SYSTEM            0x00000020

// Include CAs that do not support templates
#define CA_FIND_INCLUDE_NON_TEMPLATE_CA 0x00000040

// The value passed in for scope is the LDAP binding handle to use during finds
#define CA_FLAG_SCOPE_IS_LDAP_HANDLE    0x00000800


//*****************************************************************************
//
// Flags used by CAEnumCertTypesForCA, CAEnumCertTypes,
// CAFindCertTypeByName, CAEnumCertTypesForCAEx, and CAEnumCertTypesEx.
//
// See comments on each API for a list of applicable flags
//
//*****************************************************************************
//  Instead of enumerating the certificate types supported by the CA, enumerate
// ALL certificate types which the CA may choose to support.
#define CA_FLAG_ENUM_ALL_TYPES          0x00000004

// running as local system.  Used to find cached information in the registry.
#define CT_FIND_LOCAL_SYSTEM            CA_FIND_LOCAL_SYSTEM

// Return machine types, as opposed to user types
#define CT_ENUM_MACHINE_TYPES           0x00000040

// Return user types, as opposed to user types
#define CT_ENUM_USER_TYPES              0x00000080

// Find the certificate type by its OID, instead of its name
#define CT_FIND_BY_OID                  0x00000200

// Disable the cache expiration check
#define CT_FLAG_NO_CACHE_LOOKUP         0x00000400

// The value passed in for scope is the LDAP binding handle to use during finds
#define CT_FLAG_SCOPE_IS_LDAP_HANDLE    CA_FLAG_SCOPE_IS_LDAP_HANDLE



//*****************************************************************************
//
// Certification Authority manipulation APIs
//
//*****************************************************************************


// CAFindByName
//
// Given the Name of a CA (CN), find the CA within the given domain and return
// the given phCAInfo structure.
//
// wszCAName    - Common name of the CA
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain.
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE
//
// phCAInfo     - Handle to the returned CA.
//
// Return:        Returns S_OK if CA was found.
//

CERTCLIAPI
HRESULT
WINAPI
CAFindByName(
    IN  LPCWSTR     wszCAName,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    );

//
// CAFindByCertType
//
// Given the Name of a Cert Type, find all the CAs within the given domain and
// return the given phCAInfo structure.
//
// wszCertType  - Common Name of the cert type
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain.
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE
//
// phCAInfo     - Handle to enumeration of CAs supporting the specified cert
//		  type.
//
// Return:        Returns S_OK on success.
//                Will return S_OK if none are found.
//                *phCAInfo will contain NULL
//

CERTCLIAPI
HRESULT
WINAPI
CAFindByCertType(
    IN  LPCWSTR     wszCertType,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    );


//
// CAFindByIssuerDN
// Given the DN of a CA, find the CA within the given domain and return the
// given phCAInfo handle.
//
// pIssuerDN    - a cert name blob from the CA's certificate.
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain.
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE 
//
//
// Return:      Returns S_OK if CA was found.
//


CERTCLIAPI
HRESULT
WINAPI
CAFindByIssuerDN(
    IN  CERT_NAME_BLOB const *  pIssuerDN,
    IN  LPCWSTR                 wszScope,
    IN  DWORD                   dwFlags,
    OUT HCAINFO *               phCAInfo
    );


//
// CAEnumFirstCA
// Enumerate the CAs in a scope
//
// wszScope     - The distinguished name (DN) of the entry at which to start
//		  the search.  Equivalent of the "base" parameter of the
//		  ldap_search_sxxx APIs.
//                NULL if use the current domain. 
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//                If CA_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		  binding handle to use during finds.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//                CA_FIND_INCLUDE_UNTRUSTED
//                CA_FIND_LOCAL_SYSTEM
//                CA_FIND_INCLUDE_NON_TEMPLATE_CA
//                CA_FLAG_SCOPE_IS_LDAP_HANDLE 
//
// phCAInfo     - Handle to enumeration of CAs supporting the specified cert
//		  type.
//
//
// Return:        Returns S_OK on success.
//                Will return S_OK if none are found.
//                *phCAInfo will contain NULL
//

CERTCLIAPI
HRESULT
WINAPI
CAEnumFirstCA(
    IN  LPCWSTR          wszScope,
    IN  DWORD            dwFlags,
    OUT HCAINFO *        phCAInfo
    );


//
// CAEnumNextCA
// Find the Next CA in an enumeration.
//
// hPrevCA      - Current CA in an enumeration.
//
// phCAInfo     - next CA in an enumeration.
//
// Return:        Returns S_OK on success.
//                Will return S_OK if none are found.
//                *phCAInfo will contain NULL
//

CERTCLIAPI
HRESULT
WINAPI
CAEnumNextCA(
    IN  HCAINFO          hPrevCA,
    OUT HCAINFO *        phCAInfo
    );

//
// CACreateNewCA
// Create a new CA of given name.
//
// wszCAName    - Common name of the CA
//
// wszScope     - The distinguished name (DN) of the entry at which to create
//		  the CA object.  We will add the "CN=...,..,CN=Services" after
//		  the DN.
//                NULL if use the current domain. 
//                If CA_FLAG_SCOPE_DNS is set, wszScope is in the DNS format.
//
// dwFlags      - Oring of the following flags:
//                CA_FLAG_SCOPE_DNS
//
// phCAInfo     - Handle to the returned CA.
//
// See above for other parameter definitions
//
// Return:        Returns S_OK if CA was created.
//
// NOTE:  Actual updates to the CA object may not occur until CAUpdateCA is
//	  called.  In order to successfully update a created CA, the
//	  Certificate must be set, as well as the Certificate Types property.
//

CERTCLIAPI
HRESULT
WINAPI
CACreateNewCA(
    IN  LPCWSTR     wszCAName,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    );

//
// CAUpdateCA
// Write any changes made to the CA back to the CA object.
//
// hCAInfo      - Handle to an open CA object.
//

CERTCLIAPI
HRESULT
WINAPI
CAUpdateCA(
    IN HCAINFO    hCAInfo
    );

//
// CADeleteCA
// Delete the CA object from the DS.
//
// hCAInfo      - Handle to an open CA object.
//

CERTCLIAPI
HRESULT
WINAPI
CADeleteCA(
    IN HCAINFO    hCAInfo
    );

//
// CACountCAs
// return the number of CAs in this enumeration
//

CERTCLIAPI
DWORD
WINAPI
CACountCAs(
    IN  HCAINFO  hCAInfo
    );

//
// CAGetDN
// returns the DN of the associated DS object
//

CERTCLIAPI
LPCWSTR
WINAPI
CAGetDN(
    IN HCAINFO hCAInfo
    );


//
// CACloseCA
// Close an open CA handle
//
// hCAInfo      - Handle to an open CA object.
//

CERTCLIAPI
HRESULT
WINAPI
CACloseCA(
    IN HCAINFO hCA
    );



//
// CAGetCAProperty - Given a property name, retrieve a
// property from a CAInfo.
//
// hCAInfo              - Handle to an open CA object.
//
// wszPropertyName      - Name of the CA property
//
// pawszPropertyValue   - A pointer into which an array of WCHAR strings is
//			  written, containing the values of the property.  The
//			  last element of the array points to NULL.
//                        If the property is single valued, then the array
//			  returned contains 2 elements, the first pointing to
//			  the value, the second pointing to NULL.  This pointer
//			  must be freed by CAFreeCAProperty.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue
    );


//
// CAFreeProperty
// Frees a previously retrieved property value.
//
// hCAInfo              - Handle to an open CA object.
//
// awszPropertyValue    - pointer to the previously retrieved property value.
//

CERTCLIAPI
HRESULT
WINAPI
CAFreeCAProperty(
    IN  HCAINFO     hCAInfo,
    LPWSTR *        awszPropertyValue
    );


//
// CASetCAProperty - Given a property name, set its value.
//
// hCAInfo              - Handle to an open CA object.
//
// wszPropertyName      - Name of the CA property
//
// awszPropertyValue    - An array of values to set for this property.  The
//			  last element of this - array should be NULL.
//                        For single valued properties, the values beyond the
//                        first will be ignored upon update.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCAProperty(
    IN HCAINFO      hCAInfo,
    IN LPCWSTR      wszPropertyName,
    IN LPWSTR *     awszPropertyValue
    );


//*****************************************************************************
///
// CA Properties
//
//*****************************************************************************

// simple name of the CA
#define CA_PROP_NAME                    L"cn"

// display name of the CA object
#define CA_PROP_DISPLAY_NAME            L"displayName"

// dns name of the machine
#define CA_PROP_DNSNAME                 L"dNSHostName"

// DS Location of CA object (DN)
#define CA_PROP_DSLOCATION              L"distinguishedName"

// Supported cert types
#define CA_PROP_CERT_TYPES              L"certificateTemplates"

// Supported signature algs
#define CA_PROP_SIGNATURE_ALGS          L"signatureAlgorithms"

// DN of the CA's cert
#define CA_PROP_CERT_DN                 L"cACertificateDN"

#define CA_PROP_ENROLLMENT_PROVIDERS    L"enrollmentProviders"

// CA's description
#define CA_PROP_DESCRIPTION		        L"Description"

//
// CAGetCACertificate - Return the current certificate for
// this CA.
//
// hCAInfo      - Handle to an open CA object.
//
// ppCert       - Pointer into which a certificate is written.  This
//		  certificate must be freed via CertFreeCertificateContext.
//                This value will be NULL if no certificate is set for this CA.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCAFlags(
    IN HCAINFO  hCAInfo,
    OUT DWORD  *pdwFlags
    );

//*****************************************************************************
//
// CA Flags
//
//*****************************************************************************

// The CA supports certificate templates
#define CA_FLAG_NO_TEMPLATE_SUPPORT                 0x00000001

// The CA supports NT authentication for requests
#define CA_FLAG_SUPPORTS_NT_AUTHENTICATION          0x00000002

// The cert requests may be pended
#define CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION   0x00000004

// The cert requests may be pended
#define CA_FLAG_CA_SERVERTYPE_ADVANCED              0x00000008

#define CA_MASK_SETTABLE_FLAGS                      0x0000ffff


//
// CASetCAFlags
// Sets the Flags of a cert type
//
// hCertType    - handle to the CertType
//
// dwFlags      - Flags to be set
//

CERTCLIAPI
HRESULT
WINAPI
CASetCAFlags(
    IN HCAINFO             hCAInfo,
    IN DWORD               dwFlags
    );

CERTCLIAPI
HRESULT
WINAPI
CAGetCACertificate(
    IN  HCAINFO     hCAInfo,
    OUT PCCERT_CONTEXT *ppCert
    );


//
// CASetCACertificate - Set the certificate for a CA this CA.
//
// hCAInfo      - Handle to an open CA object.
//
// pCert        - Pointer to a certificate to set as the CA's certificate.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCACertificate(
    IN  HCAINFO     hCAInfo,
    IN PCCERT_CONTEXT pCert
    );


//
// CAGetCAExpiration
// Get the expirations period for a CA.
//
// hCAInfo              - Handle to an open CA handle.
//
// pdwExpiration        - expiration period in dwUnits time
//
// pdwUnits             - Units identifier
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCAExpiration(
    HCAINFO hCAInfo,
    DWORD * pdwExpiration,
    DWORD * pdwUnits
    );

#define CA_UNITS_DAYS   1
#define CA_UNITS_WEEKS  2
#define CA_UNITS_MONTHS 3
#define CA_UNITS_YEARS  4


//
// CASetCAExpiration
// Set the expirations period for a CA.
//
// hCAInfo              - Handle to an open CA handle.
//
// dwExpiration         - expiration period in dwUnits time
//
// dwUnits              - Units identifier
//

CERTCLIAPI
HRESULT
WINAPI
CASetCAExpiration(
    HCAINFO hCAInfo,
    DWORD dwExpiration,
    DWORD dwUnits
    );

//
// CASetCASecurity
// Set the list of Users, Groups, and Machines allowed to access this CA.
//
// hCAInfo      - Handle to an open CA handle.
//
// pSD          - Security descriptor for this CA
//

CERTCLIAPI
HRESULT
WINAPI
CASetCASecurity(
    IN HCAINFO                 hCAInfo,
    IN PSECURITY_DESCRIPTOR    pSD
    );

//
// CAGetCASecurity
// Get the list of Users, Groups, and Machines allowed to access this CA.
//
// hCAInfo      - Handle to an open CA handle.
//
// ppSD         - Pointer to a location receiving the pointer to the security
//		  descriptor.  Free via LocalFree.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCASecurity(
    IN  HCAINFO                    hCAInfo,
    OUT PSECURITY_DESCRIPTOR *     ppSD
    );

//
// CAAccessCheck
// Determine whether the principal specified by
// ClientToken can get a cert from the CA.
//
// hCAInfo      - Handle to the CA
//
// ClientToken  - Handle to an impersonation token that represents the client
//		  attempting request this cert type.  The handle must have
//		  TOKEN_QUERY access to the token; otherwise, the function
//		  fails with ERROR_ACCESS_DENIED.
//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CAAccessCheck(
    IN HCAINFO      hCAInfo,
    IN HANDLE       ClientToken
    );

//
// CAAccessCheckEx
// Determine whether the principal specified by
// ClientToken can get a cert from the CA.
//
// hCAInfo      - Handle to the CA
//
// ClientToken  - Handle to an impersonation token that represents the client
//		  attempting request this cert type.  The handle must have
//		  TOKEN_QUERY access to the token; otherwise, the function
//		  fails with ERROR_ACCESS_DENIED.
//
// dwOption     - Can be one of the following:
//                        CERTTYPE_ACCESS_CHECK_ENROLL

//                  dwOption can be CERTTYPE_ACCESS_CHECK_NO_MAPPING to 
//                  disallow default mapping of client token

//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CAAccessCheckEx(
    IN HCAINFO      hCAInfo,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    );


//
// CAEnumCertTypesForCA - Given a HCAINFO, retrieve handle to the cert types
// supported or known by this CA.  CAEnumNextCertType can be used to enumerate
// through the cert types.
//
// hCAInfo      - Handle to an open CA handle or NULL if CT_FLAG_ENUM_ALL_TYPES
//		  is set in dwFlags.
//
// dwFlags      - The following flags may be or'd together
//                CA_FLAG_ENUM_ALL_TYPES 
//                CT_FIND_LOCAL_SYSTEM
//                CT_ENUM_MACHINE_TYPES
//                CT_ENUM_USER_TYPES
//                CT_FLAG_NO_CACHE_LOOKUP  
//
// phCertType   - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypesForCA(
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );

//
// CAEnumCertTypesForCAEx - Given a HCAINFO, retrieve handle to the cert types
// supported or known by this CA.  CAEnumNextCertTypeEx can be used to enumerate
// through the cert types.  It optional takes a LDAP handle.
//
// hCAInfo      - Handle to an open CA handle or NULL if CT_FLAG_ENUM_ALL_TYPES
//		          is set in dwFlags.
//
// wszScope     - NULL if use the current domain.
//                      If CT_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		                binding handle to use during finds.
//
// dwFlags      - The following flags may be or'd together
//                CA_FLAG_ENUM_ALL_TYPES 
//                CT_FIND_LOCAL_SYSTEM
//                CT_ENUM_MACHINE_TYPES
//                CT_ENUM_USER_TYPES
//                CT_FLAG_NO_CACHE_LOOKUP  
//                CT_FLAG_SCOPE_IS_LDAP_HANDLE 
// 
// phCertType   - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypesForCAEx(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//
// CAAddCACertificateType
// Add a certificate type to a CA.  If the cert type has already been added to
// the CA, it will not be added again.
//
// hCAInfo      - Handle to an open CA.
//
// hCertType    - Cert type to add to CA.
//

CERTCLIAPI
HRESULT
WINAPI
CAAddCACertificateType(
    HCAINFO hCAInfo,
    HCERTTYPE hCertType
    );


//
// CADeleteCACertificateType
// Remove a certificate type from a CA.  If the CA does not include this cert
// type, this call does nothing.
//
// hCAInfo      - Handle to an open CA.
//
// hCertType    - Cert type to delete from CA.
//

CERTCLIAPI
HRESULT
WINAPI
CARemoveCACertificateType(
    HCAINFO hCAInfo,
    HCERTTYPE hCertType
    );




//*****************************************************************************
//
// Certificate Type APIs
//
//*****************************************************************************

//
// CAEnumCertTypes - Retrieve a handle to all known cert types
// CAEnumNextCertType can be used to enumerate through the cert types.
//
// dwFlags              - an oring of the following:
//                        CT_FIND_LOCAL_SYSTEM
//                        CT_ENUM_MACHINE_TYPES
//                        CT_ENUM_USER_TYPES
//                        CT_FLAG_NO_CACHE_LOOKUP  
//
// phCertType           - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypes(
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//
// CAEnumCertTypesEx - Retrieve a handle to all known cert types
// CAEnumNextCertType can be used to enumerate through the cert types.
//
// wszScope            - NULL if use the current domain.
//                        If CT_FLAG_SCOPE_IS_LDAP_HANDLE is set, wszScope is the LDAP
//		                  binding handle to use during finds.
//
// dwFlags              - an oring of the following:
//                        CT_FIND_LOCAL_SYSTEM
//                        CT_ENUM_MACHINE_TYPES
//                        CT_ENUM_USER_TYPES
//                        CT_FLAG_NO_CACHE_LOOKUP
//                        CT_FLAG_SCOPE_IS_LDAP_HANDLE  
//
// phCertType           - Enumeration of certificate types.
//


CERTCLIAPI
HRESULT
WINAPI
CAEnumCertTypesEx(
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//
// CAFindCertTypeByName
// Find a cert type given a Name.
//
// wszCertType  - Name of the cert type if CT_FIND_BY_OID is not set in dwFlags
//                The OID of the cert type if CT_FIND_BY_OID is set in dwFlags
//
// hCAInfo      - NULL unless CT_FLAG_SCOPE_IS_LDAP_HANDLE is set in dwFlags
//
// dwFlags      - an oring of the following
//                CT_FIND_LOCAL_SYSTEM
//                CT_ENUM_MACHINE_TYPES
//                CT_ENUM_USER_TYPES
//                CT_FLAG_NO_CACHE_LOOKUP  
//                CT_FIND_BY_OID
//                CT_FLAG_SCOPE_IS_LDAP_HANDLE -- If this flag is set, hCAInfo
//						  is the LDAP handle to use
//						  during finds.
// phCertType   - Pointer to a cert type in which result is returned.
//

CERTCLIAPI
HRESULT
WINAPI
CAFindCertTypeByName(
    IN  LPCWSTR     wszCertType,
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    );


//*****************************************************************************
//
// Default cert type names
//
//*****************************************************************************

#define wszCERTTYPE_USER                    L"User"
#define wszCERTTYPE_USER_SIGNATURE          L"UserSignature"
#define wszCERTTYPE_SMARTCARD_USER          L"SmartcardUser"
#define wszCERTTYPE_USER_AS                 L"ClientAuth"
#define wszCERTTYPE_USER_SMARTCARD_LOGON    L"SmartcardLogon"
#define wszCERTTYPE_EFS                     L"EFS"
#define wszCERTTYPE_ADMIN                   L"Administrator"
#define wszCERTTYPE_EFS_RECOVERY            L"EFSRecovery"
#define wszCERTTYPE_CODE_SIGNING            L"CodeSigning"
#define wszCERTTYPE_CTL_SIGNING             L"CTLSigning"
#define wszCERTTYPE_ENROLLMENT_AGENT        L"EnrollmentAgent"


#define wszCERTTYPE_MACHINE                 L"Machine"
#define wszCERTTYPE_DC                      L"DomainController"
#define wszCERTTYPE_WEBSERVER               L"WebServer"
#define wszCERTTYPE_KDC                     L"KDC"
#define wszCERTTYPE_CA                      L"CA"
#define wszCERTTYPE_SUBORDINATE_CA          L"SubCA"
#define wszCERTTYPE_CROSS_CA				L"CrossCA"
#define wszCERTTYPE_KEY_RECOVERY_AGENT      L"KeyRecoveryAgent"
#define wszCERTTYPE_CA_EXCHANGE             L"CAExchange"
#define wszCERTTYPE_DC_AUTH                 L"DomainControllerAuthentication"
#define wszCERTTYPE_DS_EMAIL_REPLICATION    L"DirectoryEmailReplication"


#define wszCERTTYPE_IPSEC_ENDENTITY_ONLINE      L"IPSECEndEntityOnline"
#define wszCERTTYPE_IPSEC_ENDENTITY_OFFLINE     L"IPSECEndEntityOffline"
#define wszCERTTYPE_IPSEC_INTERMEDIATE_ONLINE   L"IPSECIntermediateOnline"
#define wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE  L"IPSECIntermediateOffline"

#define wszCERTTYPE_ROUTER_OFFLINE              L"OfflineRouter"
#define wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE    L"EnrollmentAgentOffline"
#define wszCERTTYPE_EXCHANGE_USER               L"ExchangeUser"
#define wszCERTTYPE_EXCHANGE_USER_SIGNATURE     L"ExchangeUserSignature"
#define wszCERTTYPE_MACHINE_ENROLLMENT_AGENT    L"MachineEnrollmentAgent"
#define wszCERTTYPE_CEP_ENCRYPTION              L"CEPEncryption"

//
// CAUpdateCertType
// Write any changes made to the cert type back to the type store
//
CERTCLIAPI
HRESULT
WINAPI
CAUpdateCertType(
    IN HCERTTYPE           hCertType
    );


//
// CADeleteCertType
// Delete a CertType
//
// hCertType    - Cert type to delete.
//
// NOTE:  If this is called for a default cert type, it will revert back to its
// default attributes (if it has been modified)
//
CERTCLIAPI
HRESULT
WINAPI
CADeleteCertType(
    IN HCERTTYPE            hCertType
    );



//
// CACloneCertType
//
// Clone a certificate type.  The returned certificate type is a clone of the 
// input certificate type, with the new cert type name and display name.  By default,
// if the input template is a template for machines, all 
// CT_FLAG_SUBJECT_REQUIRE_XXXX bits in the subject name flag are turned off.  
//                                   
// hCertType        - Cert type to be cloned.
// wszCertType      - Name of the new cert type.
// wszFriendlyName  - Friendly name of the new cert type.  Could be NULL.
// pvldap           - The LDAP handle (LDAP *) to the directory.  Could be NULL.
// dwFlags          - Can be an ORing of the following flags:
//
//                      CT_CLONE_KEEP_AUTOENROLLMENT_SETTING
//                      CT_CLONE_KEEP_SUBJECT_NAME_SETTING
//
CERTCLIAPI
HRESULT
WINAPI
CACloneCertType(
    IN  HCERTTYPE            hCertType,
    IN  LPCWSTR              wszCertType,
    IN  LPCWSTR              wszFriendlyName,
    IN  LPVOID               pvldap,
    IN  DWORD                dwFlags,
    OUT HCERTTYPE *          phCertType
    );


#define  CT_CLONE_KEEP_AUTOENROLLMENT_SETTING       0x01
#define  CT_CLONE_KEEP_SUBJECT_NAME_SETTING         0x02  


//
// CACreateCertType
// Create a new cert type
//
// wszCertType  - Name of the cert type
//
// wszScope     - reserved.  Must set to NULL.
//
// dwFlags      - reserved.  Must set to NULL.
//
// phCertType   - returned cert type
//
CERTCLIAPI
HRESULT
WINAPI
CACreateCertType(
    IN  LPCWSTR             wszCertType,
    IN  LPCWSTR             wszScope,
    IN  DWORD               dwFlags,
    OUT HCERTTYPE *         phCertType
    );


//
// CAEnumNextCertType
// Find the Next Cert Type in an enumeration.
//
// hPrevCertType        - Previous cert type in enumeration
//
// phCertType           - Pointer to a handle into which result is placed.
//			  NULL if there are no more cert types in enumeration.
//

CERTCLIAPI
HRESULT
WINAPI
CAEnumNextCertType(
    IN  HCERTTYPE          hPrevCertType,
    OUT HCERTTYPE *        phCertType
    );


//
// CACountCertTypes
// return the number of cert types in this enumeration
//

CERTCLIAPI
DWORD
WINAPI
CACountCertTypes(
    IN  HCERTTYPE  hCertType
    );


//
// CACloseCertType
// Close an open CertType handle
//

CERTCLIAPI
HRESULT
WINAPI
CACloseCertType(
    IN HCERTTYPE hCertType
    );


//
// CAGetCertTypeProperty
// Retrieve a property from a certificate type.   This function is obsolete.
// Caller should use CAGetCertTypePropertyEx instead
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property.
//
// pawszPropertyValue   - A pointer into which an array of WCHAR strings is
//			  written, containing the values of the property.  The
//			  last element of the array points to NULL.  If the
//			  property is single valued, then the array returned
//			  contains 2 elements, the first pointing to the value,
//			  the second pointing to NULL.  This pointer must be
//                        freed by CAFreeCertTypeProperty.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue);

//
// CAGetCertTypePropertyEx
// Retrieve a property from a certificate type.
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property
//
// pPropertyValue       - Depending on the value of wszPropertyName,
//			  pPropertyValue is either DWORD * or LPWSTR **.  
// 
//                        It is a DWORD * for:
//                          CERTTYPE_PROP_REVISION              
//                          CERTTYPE_PROP_SCHEMA_VERSION		
//                          CERTTYPE_PROP_MINOR_REVISION        
//                          CERTTYPE_PROP_RA_SIGNATURE			
//                          CERTTYPE_PROP_MIN_KEY_SIZE	
//		
//                        It is a LPWSTR ** for:
//                          CERTTYPE_PROP_CN                    
//                          CERTTYPE_PROP_DN                    
//                          CERTTYPE_PROP_FRIENDLY_NAME         
//                          CERTTYPE_PROP_EXTENDED_KEY_USAGE    
//                          CERTTYPE_PROP_CSP_LIST              
//                          CERTTYPE_PROP_CRITICAL_EXTENSIONS   
//                          CERTTYPE_PROP_OID					
//                          CERTTYPE_PROP_SUPERSEDE				
//                          CERTTYPE_PROP_RA_POLICY				
//                          CERTTYPE_PROP_POLICY
//                          CERTTYPE_PROP_DESCRIPTION
//				
//                        A pointer into which an array of WCHAR strings is
//			  written, containing the values of the property.  The
//			  last element of the array points to NULL.  If the
// 			  property is single valued, then the array returned
//			  contains 2 elements, the first pointing to the value,
//			  the second pointing to NULL. This pointer must be
//                        freed by CAFreeCertTypeProperty.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPVOID      pPropertyValue);


//*****************************************************************************
//
// Certificate Type properties
// 
//*****************************************************************************

//*****************************************************************************
//
//  The schema version one properties
//
//*****************************************************************************

// Common name of the certificate type
#define CERTTYPE_PROP_CN                    L"cn"

// The common name of the certificate type.  Same as CERTTYPE_PROP_CN
// This property is not settable.
#define CERTTYPE_PROP_DN                    L"distinguishedName"

// The display name of a cert type
#define CERTTYPE_PROP_FRIENDLY_NAME         L"displayName"

// An array of extended key usage OIDs for a cert type
// NOTE: This property can also be set by setting
// the Extended Key Usage extension.
#define CERTTYPE_PROP_EXTENDED_KEY_USAGE    L"pKIExtendedKeyUsage"

// The list of default CSPs for this cert type
#define CERTTYPE_PROP_CSP_LIST              L"pKIDefaultCSPs"

// The list of critical extensions
#define CERTTYPE_PROP_CRITICAL_EXTENSIONS   L"pKICriticalExtensions"

// The major version of the templates
#define CERTTYPE_PROP_REVISION              L"revision"

// The description of the templates
#define CERTTYPE_PROP_DESCRIPTION           L"templateDescription"

//*****************************************************************************
//
//  The schema version two properties
//
//*****************************************************************************
// The schema version of the templates
// This property is not settable
#define CERTTYPE_PROP_SCHEMA_VERSION	    L"msPKI-Template-Schema-Version"

// The minor version of the templates
#define CERTTYPE_PROP_MINOR_REVISION        L"msPKI-Template-Minor-Revision"

// The number of RA signatures required on a request referencing this template.
#define CERTTYPE_PROP_RA_SIGNATURE	    L"msPKI-RA-Signature"

// The minimal key size required
#define CERTTYPE_PROP_MIN_KEY_SIZE	    L"msPKI-Minimal-Key-Size"

// The OID of this template
#define CERTTYPE_PROP_OID		    L"msPKI-Cert-Template-OID"

// The OID of the template that this template supersedes
#define CERTTYPE_PROP_SUPERSEDE		    L"msPKI-Supersede-Templates"

// The RA issuer policy OIDs required in certs used to sign a request.
// Each signing cert's szOID_CERT_POLICIES extensions must contain at least one
// of the OIDs listed in the msPKI-RA-Policies property.
// Each OID listed must appear in the szOID_CERT_POLICIES extension of at least
// one signing cert.
#define CERTTYPE_PROP_RA_POLICY		    L"msPKI-RA-Policies"

// The RA application policy OIDs required in certs used to sign a request.
// Each signing cert's szOID_APPLICATION_CERT_POLICIES extensions must contain
// all of the OIDs listed in the msPKI-RA-Application-Policies property.
#define CERTTYPE_PROP_RA_APPLICATION_POLICY L"msPKI-RA-Application-Policies"

// The certificate issuer policy OIDs are placed in the szOID_CERT_POLICIES
// extension by the policy module.
#define CERTTYPE_PROP_POLICY		    L"msPKI-Certificate-Policy"

// The certificate application policy OIDs are placed in the
// szOID_APPLICATION_CERT_POLICIES extension by the policy module.
#define CERTTYPE_PROP_APPLICATION_POLICY    L"msPKI-Certificate-Application-Policy"


#define CERTTYPE_SCHEMA_VERSION_1	1	
#define CERTTYPE_SCHEMA_VERSION_2	(CERTTYPE_SCHEMA_VERSION_1 + 1)


//
// CASetCertTypeProperty
// Set a property of a CertType.  This function is obsolete.  
// Use CASetCertTypePropertyEx.
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property
//
// awszPropertyValue    - An array of values to set for this property.  The
//			  last element of this array should be NULL.  For
//			  single valued properties, the values beyond the first
//			  will be ignored upon update.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPWSTR *    awszPropertyValue
    );

//
// CASetCertTypePropertyEx
// Set a property of a CertType
//
// hCertType            - Handle to an open CertType object.
//
// wszPropertyName      - Name of the CertType property
//
// pPropertyValue       - Depending on the value of wszPropertyName,
//			  pPropertyValue is either DWORD * or LPWSTR *. 
// 
//                        It is a DWORD * for:
//                          CERTTYPE_PROP_REVISION              
//                          CERTTYPE_PROP_MINOR_REVISION        
//                          CERTTYPE_PROP_RA_SIGNATURE			
//                          CERTTYPE_PROP_MIN_KEY_SIZE	
//
//                        It is a LPWSTR * for:
//                          CERTTYPE_PROP_FRIENDLY_NAME         
//                          CERTTYPE_PROP_EXTENDED_KEY_USAGE    
//                          CERTTYPE_PROP_CSP_LIST              
//                          CERTTYPE_PROP_CRITICAL_EXTENSIONS   
//                          CERTTYPE_PROP_OID					
//                          CERTTYPE_PROP_SUPERSEDE				
//                          CERTTYPE_PROP_RA_POLICY				
//                          CERTTYPE_PROP_POLICY
//				
//                      - An array of values to set for this property.  The
//			  last element of this array should be NULL.  For
//			  single valued properties, the values beyond the first
//			  will be ignored upon update.
//
//      
//                      - CertType of V1 schema can only set V1 properties.
//
// Returns              - S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPVOID      pPropertyValue
    );


//
// CAFreeCertTypeProperty
// Frees a previously retrieved property value.
//
// hCertType            - Handle to an open CertType object.
//
// awszPropertyValue     - The values to be freed.
//
CERTCLIAPI
HRESULT
WINAPI
CAFreeCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPWSTR *    awszPropertyValue
    );


//
// CAGetCertTypeExtensions
// Retrieves the extensions associated with this CertType.
//
// hCertType            - Handle to an open CertType object.
// ppCertExtensions     - Pointer to a PCERT_EXTENSIONS to receive the result
//			  of this call.  Should be freed via a
//			  CAFreeCertTypeExtensions call.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    );


//
// CAGetCertTypeExtensionsEx
// Retrieves the extensions associated with this CertType.
//
// hCertType            - Handle to an open CertType object.
// dwFlags              - Indicate which extension to be returned.
//                        Can be an ORing of following flags:
//                          
//                          CT_EXTENSION_TEMPLATE
//                          CT_EXTENSION_KEY_USAGE
//                          CT_EXTENSION_EKU
//                          CT_EXTENSION_BASIC_CONTRAINTS
//                          CT_EXTENSION_APPLICATION_POLICY (Version 2 template only)
//                          CT_EXTENSION_ISSUANCE_POLICY  (Version 2 template only)
//
//                        0 means all avaiable extension for this CertType.
//
// pParam               - Reserved.  Must be NULL.
// ppCertExtensions     - Pointer to a PCERT_EXTENSIONS to receive the result
//			  of this call.  Should be freed via a
//			  CAFreeCertTypeExtensions call.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeExtensionsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwFlags,
    IN  LPVOID              pParam,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    );


#define     CT_EXTENSION_TEMPLATE               0x01
#define     CT_EXTENSION_KEY_USAGE              0x02
#define     CT_EXTENSION_EKU                    0x04
#define     CT_EXTENSION_BASIC_CONTRAINTS       0x08
#define     CT_EXTENSION_APPLICATION_POLICY     0x10
#define     CT_EXTENSION_ISSUANCE_POLICY        0x20



//
// CAFreeCertTypeExtensions
// Free a PCERT_EXTENSIONS allocated by CAGetCertTypeExtensions
//
CERTCLIAPI
HRESULT
WINAPI
CAFreeCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    IN  PCERT_EXTENSIONS    pCertExtensions
    );

//
// CASetCertTypeExtension
// Set the value of an extension for this
// cert type.
//
// hCertType            - handle to the CertType
//
// wszExtensionId       - OID for the extension
//
// dwFlags              - Mark the extension critical
//
// pExtension           - pointer to the appropriate extension structure
//
// Supported extensions/structures
//
// szOID_ENHANCED_KEY_USAGE     CERT_ENHKEY_USAGE
// szOID_KEY_USAGE              CRYPT_BIT_BLOB
// szOID_BASIC_CONSTRAINTS2     CERT_BASIC_CONSTRAINTS2_INFO
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeExtension(
    IN HCERTTYPE   hCertType,
    IN LPCWSTR wszExtensionId,
    IN DWORD   dwFlags,
    IN LPVOID pExtension
    );

#define CA_EXT_FLAG_CRITICAL   0x00000001



//
// CAGetCertTypeFlags
// Retrieve cert type flags.  
// This function is obsolete.  Use CAGetCertTypeFlagsEx.
//
// hCertType            - handle to the CertType
//
// pdwFlags             - pointer to DWORD receiving flags
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeFlags(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwFlags
    );

//
// CAGetCertTypeFlagsEx
// Retrieve cert type flags
//
// hCertType            - handle to the CertType
//
// dwOption             - Which flag to set
//                        Can be one of the following:
//                        CERTTYPE_ENROLLMENT_FLAG
//                        CERTTYPE_SUBJECT_NAME_FLAG
//                        CERTTYPE_PRIVATE_KEY_FLAG
//                        CERTTYPE_GENERAL_FLAG
//
// pdwFlags             - pointer to DWORD receiving flags
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeFlagsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwOption,
    OUT DWORD *             pdwFlags
    );


//*****************************************************************************
//
// Cert Type Flags
//
// The CertType flags are grouped into 4 categories:
//  1. Enrollment Flags (CERTTYPE_ENROLLMENT_FLAG)     
//	2. Certificate Subject Name Flags (CERTTYPE_SUBJECT_NAME_FLAG)  
//	3. Private Key Flags (CERTTYPE_PRIVATE_KEY_FLAG)    
//	4. General Flags (CERTTYPE_GENERAL_FLAG)        
//*****************************************************************************

//Enrollment Flags
#define CERTTYPE_ENROLLMENT_FLAG            0x01

//Certificate Subject Name Flags
#define CERTTYPE_SUBJECT_NAME_FLAG          0x02

//Private Key Flags
#define CERTTYPE_PRIVATE_KEY_FLAG           0x03

//General Flags
#define CERTTYPE_GENERAL_FLAG               0x04

//*****************************************************************************
//
// Enrollment Flags:
//
//*****************************************************************************
// Include the symmetric algorithms in the requests
#define CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS			0x00000001

// All certificate requests are pended
#define CT_FLAG_PEND_ALL_REQUESTS				0x00000002

// Publish the certificate to the KRA (key recovery agent container) on the DS
#define CT_FLAG_PUBLISH_TO_KRA_CONTAINER			0x00000004
		
// Publish the resultant cert to the userCertificate property in the DS
#define CT_FLAG_PUBLISH_TO_DS					0x00000008

// The autoenrollment will not enroll for new certificate if user has a certificate
// published on the DS with the same template name
#define CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE       0x00000010

// This cert is appropriate for auto-enrollment
#define CT_FLAG_AUTO_ENROLLMENT					0x00000020

// A previously issued certificate will valid subsequent enrollment requests
#define CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT         0x00000040

// Domain authentication is not required.  
#define CT_FLAG_DOMAIN_AUTHENTICATION_NOT_REQUIRED              0x00000080

// User interaction is required to enroll
#define CT_FLAG_USER_INTERACTION_REQUIRED                       0x00000100

// Add szOID_CERTTYPE_EXTENSION (template name) extension
// This flag will ONLY be set on V1 certificate templates for W2K CA only.
#define CT_FLAG_ADD_TEMPLATE_NAME		                0x00000200

// Remove invalid (expired or revoked) certificate from personal store
#define CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE  0x00000400



//*****************************************************************************
//
// Certificate Subject Name Flags:
//
//*****************************************************************************

// The enrolling application must supply the subject name.
#define CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT			0x00000001

// The enrolling application must supply the subjectAltName in request
#define CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME		0x00010000

// Subject name should be full DN
#define CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH			0x80000000

// Subject name should be the common name
#define CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME			0x40000000

// Subject name includes the e-mail name
#define CT_FLAG_SUBJECT_REQUIRE_EMAIL				0x20000000

// Subject name includes the DNS name as the common name
#define CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN			0x10000000

// Subject alt name includes DNS name
#define CT_FLAG_SUBJECT_ALT_REQUIRE_DNS				0x08000000

// Subject alt name includes email name
#define CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL			0x04000000

// Subject alt name requires UPN
#define CT_FLAG_SUBJECT_ALT_REQUIRE_UPN				0x02000000

// Subject alt name requires directory GUID
#define CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID		0x01000000

// Subject alt name requires SPN
#define CT_FLAG_SUBJECT_ALT_REQUIRE_SPN                         0x00800000


//
// Obsolete name	
// The following flags are obsolete.  They are used by V1 templates in the
// general flags
//
#define CT_FLAG_IS_SUBJECT_REQ      CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT

// The e-mail name of the principal will be added to the cert
#define CT_FLAG_ADD_EMAIL					0x00000002

// Add the object GUID for this principal
#define CT_FLAG_ADD_OBJ_GUID					0x00000004

// Add DS Name (full DN) to szOID_SUBJECT_ALT_NAME2 (Subj Alt Name 2) extension
// This flag is not SET in any of the V1 templates and is of no interests to
// V2 templates since it is not present on the UI and will never be set.
#define CT_FLAG_ADD_DIRECTORY_PATH				0x00000100


//*****************************************************************************
//
// Private Key Flags:
//
//*****************************************************************************

// Archival of the private key is allowed
#define CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL	0x00000001

#define CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL	CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL

// Make the key for this cert exportable.
#define CT_FLAG_EXPORTABLE_KEY			0x00000010

// Require the strong key protection UI when a new key is generated
#define CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED					0x00000020

//*****************************************************************************
//
// General Flags
//
//	More flags should start from 0x00000400
//
//*****************************************************************************
// This is a machine cert type
#define CT_FLAG_MACHINE_TYPE                0x00000040

// This is a CA	cert type
#define CT_FLAG_IS_CA                       0x00000080

// This is a cross CA cert type 
#define CT_FLAG_IS_CROSS_CA                 0x00000800

// The type is a default cert type (cannot be set).  This flag will be set on
// all V1 templates.  The templates can not be edited or deleted.
#define CT_FLAG_IS_DEFAULT                  0x00010000

// The type has been modified, if it is default (cannot be set)
#define CT_FLAG_IS_MODIFIED                 0x00020000

// settable flags for general flags
#define CT_MASK_SETTABLE_FLAGS              0x0000ffff

//
// CASetCertTypeFlags
// Sets the General Flags of a cert type.
// This function is obsolete.  Use CASetCertTypeFlagsEx.
//
// hCertType            - handle to the CertType
//
// dwFlags              - Flags to be set
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeFlags(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwFlags
    );

//
// CASetCertTypeFlagsEx
// Sets the Flags of a cert type
//
// hCertType            - handle to the CertType
//
// dwOption             - Which flag to set
//                        Can be one of the following:
//                        CERTTYPE_ENROLLMENT_FLAG
//                        CERTTYPE_SUBJECT_NAME_FLAG
//                        CERTTYPE_PRIVATE_KEY_FLAG
//                        CERTTYPE_GENERAL_FLAG
//
// dwFlags              - Value to be set
//          

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeFlagsEx(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwOption,
    IN DWORD               dwFlags
    );

//
// CAGetCertTypeKeySpec
// Retrieve the CAPI Key Spec for this cert type
//
// hCertType            - handle to the CertType
//
// pdwKeySpec           - pointer to DWORD receiving key spec
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeKeySpec(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwKeySpec
    );

//
// CACertTypeSetKeySpec
// Sets the CAPI1 Key Spec of a cert type
//
// hCertType            - handle to the CertType
//
// dwKeySpec            - KeySpec to be set
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeKeySpec(
    IN HCERTTYPE            hCertType,
    IN DWORD                dwKeySpec
    );

//
// CAGetCertTypeExpiration
// Retrieve the Expiration Info for this cert type
//
// pftExpiration        - pointer to the FILETIME structure receiving
//                        the expiration period for this cert type.
//
// pftOverlap           - pointer to the FILETIME structure receiving the
//			  suggested renewal overlap period for this cert type.
//

CERTCLIAPI
HRESULT
WINAPI
CAGetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    OUT OPTIONAL FILETIME * pftExpiration,
    OUT OPTIONAL FILETIME * pftOverlap
    );

//
// CASetCertTypeExpiration
// Set the Expiration Info for this cert type
//
// pftExpiration        - pointer to the FILETIME structure containing
//                        the expiration period for this cert type.
//
// pftOverlap           - pointer to the FILETIME structure containing the
//			  suggested renewal overlap period for this cert type.
//

CERTCLIAPI
HRESULT
WINAPI
CASetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    IN OPTIONAL FILETIME  * pftExpiration,
    IN OPTIONAL FILETIME  * pftOverlap
    );
//
// CACertTypeSetSecurity
// Set the list of Users, Groups, and Machines allowed
// to access this cert type.
//
// hCertType            - handle to the CertType
//
// pSD                  - Security descriptor for this cert type
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeSetSecurity(
    IN HCERTTYPE               hCertType,
    IN PSECURITY_DESCRIPTOR    pSD
    );


//
// CACertTypeGetSecurity
// Get the list of Users, Groups, and Machines allowed
// to access this cert type.
//
// hCertType            - handle to the CertType
//
// ppaSidList           - Pointer to a location receiving the pointer to the
//			  security descriptor.  Free via LocalFree.
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeGetSecurity(
    IN  HCERTTYPE                  hCertType,
    OUT PSECURITY_DESCRIPTOR *     ppSD
    );

//
//
// CACertTypeAccessCheck
// Determine whether the principal specified by
// ClientToken can be issued this cert type.
//
// hCertType            - handle to the CertType
//
// ClientToken          - Handle to an impersonation token that represents the
//			  client attempting to request this cert type.  The
//			  handle must have TOKEN_QUERY access to the token;
//                        otherwise, the call fails with ERROR_ACCESS_DENIED.
//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeAccessCheck(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken
    );

//
//
// CACertTypeAccessCheckEx
// Determine whether the principal specified by
// ClientToken can be issued this cert type.
//
// hCertType            - handle to the CertType
//
// ClientToken          - Handle to an impersonation token that represents the
//			  client attempting to request this cert type.  The
//			  handle must have TOKEN_QUERY access to the token;
//                        otherwise, the call fails with ERROR_ACCESS_DENIED.
//
// dwOption             - Can be one of the following:
//                        CERTTYPE_ACCESS_CHECK_ENROLL
//                        CERTTYPE_ACCESS_CHECK_AUTO_ENROLL
//                      
//                      dwOption can be ORed with CERTTYPE_ACCESS_CHECK_NO_MAPPING
//                      to disallow default mapping of client token
//
// Return: S_OK on success
//

CERTCLIAPI
HRESULT
WINAPI
CACertTypeAccessCheckEx(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    );


#define CERTTYPE_ACCESS_CHECK_ENROLL        0x01
#define CERTTYPE_ACCESS_CHECK_AUTO_ENROLL   0x02

#define CERTTYPE_ACCESS_CHECK_NO_MAPPING    0x00010000

//
//
// CAInstallDefaultCertType
//
// Install default certificate types on the enterprise.  
//
// dwFlags            - Reserved.  Must be 0 for now
//
//
// Return: S_OK on success
//
CERTCLIAPI
HRESULT
WINAPI
CAInstallDefaultCertType(
    IN DWORD dwFlags
    );


//
//
// CAIsCertTypeCurrent
//
// Check if the certificate type on the DS is up to date 
//
// dwFlags            - Reserved.  Must be 0 for now
// wszCertType        - The name for the certificate type
//
// Return: TRUE if the cert type is update to date
//
CERTCLIAPI
BOOL
WINAPI
CAIsCertTypeCurrent(
    IN DWORD    dwFlags,
    IN LPWSTR   wszCertType   
    );

//*****************************************************************************
//
//  OID management APIs
//
//*****************************************************************************
//
// CAOIDCreateNew
// Create a new OID based on the enterprise base
//
// dwType                - Can be one of the following:
//                        CERT_OID_TYPE_TEMPLATE			
//                        CERT_OID_TYPE_ISSUER_POLICY
//                        CERT_OID_TYPE_APPLICATION_POLICY
//
// dwFlag               - Reserved.  Must be 0.
//
// ppwszOID             - Return the new OID.  Free memory via LocalFree().
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDCreateNew(
    IN	DWORD   dwType,
    IN  DWORD   dwFlag,
    OUT LPWSTR	*ppwszOID);


#define CERT_OID_TYPE_TEMPLATE			0x01
#define CERT_OID_TYPE_ISSUER_POLICY		0x02
#define CERT_OID_TYPE_APPLICATION_POLICY	0x03

//
// CAOIDAdd
// Add an OID to the DS repository
//
// dwType               - Can be one of the following:
//                        CERT_OID_TYPE_TEMPLATE			
//                        CERT_OID_TYPE_ISSUER_POLICY
//                        CERT_OID_TYPE_APPLICATION_POLICY
//
// dwFlag               - Reserved.  Must be 0.
//
// pwszOID              - The OID to add.
//
// Returns S_OK if successful.
// Returns CRYPT_E_EXISTS if the OID alreay exits in the DS repository
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDAdd(
    IN	DWORD       dwType,
    IN  DWORD       dwFlag,
    IN  LPCWSTR	    pwszOID);


//
// CAOIDDelete
// Delete the OID from the DS repository
//
// pwszOID              - The OID to delete.
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDDelete(
    IN LPCWSTR	pwszOID);

//
// CAOIDSetProperty
// Set a property on an OID.  
//
// pwszOID              - The OID whose value is set
// dwProperty           - The property name.  Can be one of the following:
//                        CERT_OID_PROPERTY_DISPLAY_NAME
//                        CERT_OID_PROPERTY_CPS
//
// pPropValue           - The value of the property.
//                        If dwProperty is CERT_OID_PROPERTY_DISPLAY_NAME,
//                        pPropValue is LPWSTR. 
//                        if dwProperty is CERT_OID_PROPERTY_CPS,
//                        pPropValue is LPWSTR.  
//                        NULL will remove the property
//
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDSetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    IN  LPVOID  pPropValue);



#define CERT_OID_PROPERTY_DISPLAY_NAME      0x01
#define CERT_OID_PROPERTY_CPS               0x02
#define CERT_OID_PROPERTY_TYPE              0x03

//
// CAOIDGetProperty
// Get a property on an OID.  
//
// pwszOID              - The OID whose value is queried
// dwProperty           - The property name.  Can be one of the following:
//                        CERT_OID_PROPERTY_DISPLAY_NAME
//                        CERT_OID_PROPERTY_CPS
//                        CERT_OID_PROPERTY_TYPE
//
// pPropValue           - The value of the property.
//                        If dwProperty is CERT_OID_PROPERTY_DISPLAY_NAME,
//                        pPropValue is LPWSTR *.  
//                        if dwProperty is CERT_OID_PROPERTY_CPS, pPropValue is
//			  LPWSTR *. 
//
//                        Free the above properties via CAOIDFreeProperty().
//
//                        If dwProperty is CERT_OID_PROPERTY_TYPE, pPropValue
//			  is DWORD *. 
//
// Returns S_OK if successful.
//
CERTCLIAPI
HRESULT
WINAPI
CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue);


//
// CAOIDFreeProperty
// Free a property returned from CAOIDGetProperty  
//
// pPropValue           - The value of the property.
//
// Returns S_OK if successful.
//

CERTCLIAPI
HRESULT
WINAPI
CAOIDFreeProperty(
    IN LPVOID  pPropValue);

//
// CAOIDGetLdapURL
// 
// Return the LDAP URL for OID repository.  In the format of 
// LDAP:///DN of the Repository/all attributes?one?filter.  The filter
// is determined by dwType.
//
// dwType               - Can be one of the following:
//                        CERT_OID_TYPE_TEMPLATE			
//                        CERT_OID_TYPE_ISSUER_POLICY
//                        CERT_OID_TYPE_APPLICATION_POLICY
//                        CERT_OID_TYPE_ALL
//
// dwFlag               - Reserved.  Must be 0.
//
// ppwszURL             - Return the URL.  Free memory via CAOIDFreeLdapURL.
//
// Returns S_OK if successful.
//
CERTCLIAPI
HRESULT
WINAPI
CAOIDGetLdapURL(
    IN  DWORD   dwType,
    IN  DWORD   dwFlag,
    OUT LPWSTR  *ppwszURL);

#define CERT_OID_TYPE_ALL           0x0

//
// CAOIDFreeLDAPURL
// Free the URL returned from CAOIDGetLdapURL
//
// pwszURL      - The URL returned from CAOIDGetLdapURL
//
// Returns S_OK if successful.
//
CERTCLIAPI
HRESULT
WINAPI
CAOIDFreeLdapURL(
    IN LPCWSTR      pwszURL);


//the LDAP properties for OID class
#define OID_PROP_TYPE                   L"flags"
#define OID_PROP_OID                    L"msPKI-Cert-Template-OID"
#define OID_PROP_DISPLAY_NAME           L"displayName"
#define OID_PROP_CPS                    L"msPKI-OID-CPS"
#define OID_PROP_LOCALIZED_NAME         L"msPKI-OIDLocalizedName"


//*****************************************************************************
//
//  Cert Type Change Query APIS
//
//*****************************************************************************
//
// CACertTypeRegisterQuery
// 
//      Regiser the calling thread to query if any modification has happened
//  to cert type information on the directory
//
//
// dwFlag               - Reserved.  Must be 0.
//
// pvldap               - The LDAP handle to the directory (LDAP *).  Optional input.
//                        If pvldap is not NULL, then the caller has to call
//                        CACertTypeUnregisterQuery before unbind the pldap.
//
// pHCertTypeQuery      - Receive the HCERTTYPEQUERY handle upon success.
//
// Returns S_OK if successful.
//
//
CERTCLIAPI
HRESULT
WINAPI
CACertTypeRegisterQuery(
    IN	DWORD               dwFlag,
    IN  LPVOID              pvldap,
    OUT HCERTTYPEQUERY      *phCertTypeQuery);



//
// CACertTypeQuery
// 
//      Returns a change sequence number which is incremented by 1 whenever
// cert type information on the directory is changed.     
//
// hCertTypeQuery               -  The hCertTypeQuery returned from previous
//                                  CACertTypeRegisterQuery  calls.
//
// *pdwChangeSequence           -  Returns a DWORD, which is incremented by 1 
//                                  whenever any changes has happened to cert type 
//                                  information on the directory since the last 
//                                  call to CACertTypeRegisterQuery or CACertTypeQuery.
//
//
//
// Returns S_OK if successful.
//
//
CERTCLIAPI
HRESULT
WINAPI
CACertTypeQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery,
    OUT DWORD           *pdwChangeSequence);



//
// CACertTypeUnregisterQuery
// 
//      Unregister the calling thread to query if any modification has happened
//  to cert type information on the directory
//
//
// hCertTypeQuery               -  The hCertTypeQuery returned from previous
//                                  CACertTypeRegisterQuery calls.
//
// Returns S_OK if successful.
//
//
CERTCLIAPI
HRESULT
WINAPI
CACertTypeUnregisterQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery);


//*****************************************************************************
//
//  Autoenrollment APIs
//
//*****************************************************************************

//
// CACreateLocalAutoEnrollmentObject
// Create an auto-enrollment object on the local machine.
//
// pwszCertType - The name of the certificate type for which to create the
//		  auto-enrollment object
//
// awszCAs      - The list of CAs to add to the auto-enrollment object with the
//		  last entry in the list being NULL.  If the list is NULL or
//		  empty, then it create an auto-enrollment object which
//		  instructs the system to enroll for a cert at any CA
//		  supporting the requested certificate type.
//
// pSignerInfo  - not used, must be NULL.
//
// dwFlags      - can be CERT_SYSTEM_STORE_CURRENT_USER or
//		  CERT_SYSTEM_STORE_LOCAL_MACHINE, indicating auto-enrollment
//		  store in which the auto-enrollment object is created.
//
// Return:      S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CACreateLocalAutoEnrollmentObject(
    IN LPCWSTR                              pwszCertType,
    IN OPTIONAL WCHAR **                    awszCAs,
    IN OPTIONAL PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN DWORD                                dwFlags);

//
// CADeleteLocalAutoEnrollmentObject
// Delete an auto-enrollment object on the local machine.
//
// pwszCertType - The name of the certificate type for which to delete the
//		  auto-enrollment object
//
// awszCAs      - not used. must be NULL.  All callers to CACreateLocalAutoEnrollmentObject
//                have supplied NULL.
//
// pSignerInfo  - not used, must be NULL.
//
// dwFlags      - can be CERT_SYSTEM_STORE_CURRENT_USER or
//		  CERT_SYSTEM_STORE_LOCAL_MACHINE, indicating auto-enrollment
//		  store in which the auto-enrollment object is deleted.
//
// Return:      S_OK on success.
//

CERTCLIAPI
HRESULT
WINAPI
CADeleteLocalAutoEnrollmentObject(
    IN LPCWSTR                              pwszCertType,
    IN OPTIONAL WCHAR **                    awszCAs,
    IN OPTIONAL PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN DWORD                                dwFlags);


//
// CACreateAutoEnrollmentObjectEx
// Create an auto-enrollment object in the indicated store.
//
// pwszCertType - The name of the certificate type for which to create the
//		  auto-enrollment object
//
// pwszObjectID - An identifying string for this autoenrollment object.  NULL
//		  may be passed if this object is simply to be identified by
//		  its certificate template.  An autoenrollment object is
//		  identified by a combination of its object id and its cert
//		  type name.
//
// awszCAs      - The list of CAs to add to the auto-enrollment object, with
//		  the last entry in the list being NULL.  If the list is NULL
//		  or empty, then it create an auto-enrollment object which
//		  instructs the system to enroll for a cert at any CA
//		  supporting the requested certificate type.
//
// pSignerInfo  - not used, must be NULL.
//
// StoreProvider - see CertOpenStore
//
// dwFlags      - see CertOpenStore
//
// pvPara       - see CertOpenStore
//
// Return:      S_OK on success.
//
//

CERTCLIAPI
HRESULT
WINAPI
CACreateAutoEnrollmentObjectEx(
    IN LPCWSTR                     pwszCertType,
    IN LPCWSTR                     wszObjectID,
    IN WCHAR **                    awszCAs,
    IN PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN LPCSTR                      StoreProvider,
    IN DWORD                       dwFlags,
    IN const void *                pvPara);


typedef struct _CERTSERVERENROLL
{
    DWORD   Disposition;
    HRESULT hrLastStatus;
    DWORD   RequestId;
    BYTE   *pbCert;
    DWORD   cbCert;
    BYTE   *pbCertChain;
    DWORD   cbCertChain;
    WCHAR  *pwszDispositionMessage;
} CERTSERVERENROLL;


//*****************************************************************************
//
// Cert Server RPC interfaces:
//
//*****************************************************************************

CERTCLIAPI
HRESULT
WINAPI
CertServerSubmitRequest(
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll); // free via CertServerFreeMemory

CERTCLIAPI
HRESULT
WINAPI
CertServerRetrievePending(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll); // free via CertServerFreeMemory

CERTCLIAPI
VOID
WINAPI
CertServerFreeMemory(
    IN VOID *pv);


enum ENUM_PERIOD
{
    ENUM_PERIOD_INVALID = -1,
    ENUM_PERIOD_SECONDS = 0,
    ENUM_PERIOD_MINUTES,
    ENUM_PERIOD_HOURS,
    ENUM_PERIOD_DAYS,
    ENUM_PERIOD_WEEKS,
    ENUM_PERIOD_MONTHS,
    ENUM_PERIOD_YEARS
};

typedef struct _PERIODUNITS
{
    LONG             lCount;
    enum ENUM_PERIOD enumPeriod;
} PERIODUNITS;


HRESULT
caTranslateFileTimePeriodToPeriodUnits(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT DWORD *pcPeriodUnits,
    OUT PERIODUNITS **prgPeriodUnits);


#ifdef __cplusplus
}
#endif
#endif //__CERTCA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certsd.h ===
//+--------------------------------------------------------------------------
// File:        certsd.h
// Contents:    CA's security descriptor class declaration
//---------------------------------------------------------------------------
#ifndef __CERTSD_H__
#define __CERTSD_H__

namespace CertSrv
{

typedef struct _SID_LIST
{
    DWORD dwSidCount;
    DWORD SidListStart[ANYSIZE_ARRAY];

} SID_LIST, *PSID_LIST;

HRESULT GetWellKnownSID(
    PSID *ppSid,
    SID_IDENTIFIER_AUTHORITY *pAuth,
    BYTE  SubauthorityCount,
    DWORD SubAuthority1,
    DWORD SubAuthority2=0,
    DWORD SubAuthority3=0,
    DWORD SubAuthority4=0,
    DWORD SubAuthority5=0,
    DWORD SubAuthority6=0,
    DWORD SubAuthority7=0,
    DWORD SubAuthority8=0);

// caller is responsible for LocalFree'ing PSID
HRESULT GetEveryoneSID(PSID *ppSid);
HRESULT GetLocalSystemSID(PSID *ppSid);
HRESULT GetBuiltinAdministratorsSID(PSID *ppSid);

// This class wraps a SD with single writer multiple reader access control on
// it. Allows any number of threads to LockGet() the pointer to the SD if no
// thread is in the middle of a Set(). Set() is blocked until all threads
// that already retrieved the SD released it (calling Unlock)
//
// Also provides the support for persistently saving/loading the SD to registy

class CProtectedSecurityDescriptor
{
public:

    CProtectedSecurityDescriptor() :
        m_pSD(NULL),
        m_fInitialized(false),
        m_cReaders(0),
        m_hevtNoReaders(NULL),
        m_pcwszSanitizedName(NULL),
        m_pcwszPersistRegVal(NULL)
        {};
   ~CProtectedSecurityDescriptor()
    {
       Uninitialize();
    }

    void Uninitialize()
    {
       if(m_pSD)
       {
           LocalFree(m_pSD);
           m_pSD = NULL;
       }
       if(m_hevtNoReaders)
       {
           CloseHandle(m_hevtNoReaders);
           m_hevtNoReaders = NULL;
       }
       m_pcwszSanitizedName = NULL;
       m_fInitialized = false;
       m_cReaders = 0;
       if(IsInitialized())
       {
           DeleteCriticalSection(&m_csWrite);
       }
    }

    BOOL IsInitialized() const { return m_fInitialized;}

    // init, loading SD from the registry
    HRESULT Initialize(LPCWSTR pwszSanitizedName);
    // init from supplied SD
    HRESULT Initialize(const PSECURITY_DESCRIPTOR pSD, LPCWSTR pwszSanitizedName);

    HRESULT InitializeFromTemplate(LPCWSTR pcwszTemplate, LPCWSTR pwszSanitizedName);

    HRESULT Set(const PSECURITY_DESCRIPTOR pSD);
    HRESULT LockGet(PSECURITY_DESCRIPTOR *ppSD);
    HRESULT Unlock();

    PSECURITY_DESCRIPTOR Get() { return m_pSD; };

    // load SD from registry
    HRESULT Load();
    // save SD to registry
    HRESULT Save();
    // delete SD from registry
    HRESULT Delete();

    LPCWSTR GetPersistRegistryVal() { return m_pcwszPersistRegVal;}

    void ImportResourceStrings(LPCWSTR *pcwszStrings) 
    {m_pcwszResources = pcwszStrings;};

protected:

    HRESULT Init(LPCWSTR pwszSanitizedName);
    HRESULT SetSD(PSECURITY_DESCRIPTOR pSD);
    
    PSECURITY_DESCRIPTOR m_pSD;
    bool m_fInitialized;
    LONG m_cReaders;
    HANDLE m_hevtNoReaders;
    CRITICAL_SECTION m_csWrite;
    LPCWSTR m_pcwszSanitizedName; // no free
    LPCWSTR m_pcwszPersistRegVal; // no free

    static LPCWSTR const *m_pcwszResources; // no free

}; //class CProtectedSecurityDescriptor



// The class stores a list of officers/groups and the principals they are
// allowed to manage certificates for:
//
// officerSID1 -> clientSID1, clientSID2...
// officerSID2 -> clientSID3, clientSID4...
//
// The information is stored as a DACL containing callback ACEs .
// The officer SID is stored as in the ACE's SID and the list of client 
// SIDs are stored in the custom data space following the officer SID 
// (see definition of _ACCESS_*_CALLBACK_ACE)
//
// The DACL will be used to AccessCheck if an officer is allowed to perform
// an action over a certificate.
//
// The SD contains only the officer DACL, SACL or other data is not used.

class COfficerRightsSD : public CProtectedSecurityDescriptor
{
public:

    COfficerRightsSD() : m_fEnabled(FALSE) 
    { m_pcwszPersistRegVal = wszREGOFFICERRIGHTS; }

    HRESULT InitializeEmpty();
    HRESULT Initialize(LPCWSTR pwszSanitizedName);

    // The officer rights have to be in sync with the CA security descriptor.
    // An officer ACE for a certain SID can exist only if the principal is
    // an officer as defined by the CA SD. 
    // Merge sets the internal officer DACL making sure it's in sync 
    // with the CA SD:
    // - removes any ACE found in the officer DACL which is not present as an
    //   allow ACE in the CA DACL
    // - add an Everyone ACE in the officer DACL for each allow ACE in CA DACL
    //   that is not already present
    HRESULT Merge(
        PSECURITY_DESCRIPTOR pOfficerSD,
        PSECURITY_DESCRIPTOR pCASD);

    // Same as above but using the internal officer SD. Used to generate the
    // initial officer SD and to update it when CA SD changes
    HRESULT Adjust(
        PSECURITY_DESCRIPTOR pCASD);

    BOOL IsEnabled() { return m_fEnabled; }
    void SetEnable(BOOL fEnable) { m_fEnabled = fEnable;}
    HRESULT Save();
    HRESULT Load();
    HRESULT Validate() { return S_OK; }

    static HRESULT ConvertToString(
        IN PSECURITY_DESCRIPTOR pSD,
        OUT LPWSTR& rpwszSD);

protected:

    static HRESULT ConvertAceToString(
        IN PACCESS_ALLOWED_CALLBACK_ACE pAce,
        OUT OPTIONAL PDWORD pdwSize,
        IN OUT OPTIONAL LPWSTR pwszSD);


    BOOL m_fEnabled;
}; // class COfficerRightsSD

class CCertificateAuthoritySD : public CProtectedSecurityDescriptor
{
public:

    CCertificateAuthoritySD() : 
        m_pDefaultDSSD(NULL),
        m_pDefaultServiceSD(NULL),
        m_pDefaultDSAcl(NULL),
        m_pDefaultServiceAcl(NULL),
        m_pwszComputerSID(NULL)
    { m_pcwszPersistRegVal = wszREGCASECURITY; }

    ~CCertificateAuthoritySD()
    {
        if(m_pDefaultDSSD)
            LocalFree(m_pDefaultDSSD);
        if(m_pDefaultServiceSD)
            LocalFree(m_pDefaultServiceSD);
        if(m_pwszComputerSID)
            LocalFree(m_pwszComputerSID);
    }

    // Sets a new CA SD. Uses the new DACL but keeps the old owner, group and
    // SACL.
    // Also rebuilds the DACL for objects CA owns (eg DS pKIEnrollmentService, 
    // service). The new DACL contains a default DACL plus additional aces 
    // depending on the object:
    // DS - add an enroll ace for each enroll ace found in CA DACL
    // Service - add a full control ace for each CA admin ace
    HRESULT Set(const PSECURITY_DESCRIPTOR pSD, bool fSetDSSecurity);
    static HRESULT Validate(const PSECURITY_DESCRIPTOR pSD);
    HRESULT ResetSACL();
    HRESULT MapAndSetDaclOnObjects(bool fSetDSSecurity);

    // Upgrade SD from Win2k.
    HRESULT UpgradeWin2k(bool fUseEnterpriseAcl);

    static HRESULT ConvertToString(
        IN PSECURITY_DESCRIPTOR pSD,
        OUT LPWSTR& rpwszSD);

protected:

    enum ObjType
    {
        ObjType_DS,
        ObjType_Service,
    };

    HRESULT MapAclGetSize(PVOID pAce, ObjType type, DWORD& dwSize);
    HRESULT MapAclAddAce(PACL pAcl, ObjType type, PVOID pAce);
    HRESULT SetDefaultAcl(ObjType type);
    HRESULT SetComputerSID();
    HRESULT MapAclSetOnDS(const PACL pAcl);
    HRESULT MapAclSetOnService(const PACL pAcl);

    DWORD GetUpgradeAceSizeAndType(PVOID pAce, DWORD *pdwType, PSID *ppSid);

    static HRESULT ConvertAceToString(
        IN PACCESS_ALLOWED_ACE pAce,
        OUT OPTIONAL PDWORD pdwSize,
        IN OUT OPTIONAL LPWSTR pwszSD);


    PSECURITY_DESCRIPTOR m_pDefaultDSSD;
    PSECURITY_DESCRIPTOR m_pDefaultServiceSD;
    PACL m_pDefaultDSAcl; // no free
    PACL m_pDefaultServiceAcl; // no free
    LPWSTR m_pwszComputerSID;
};

} // namespace CertSrv

#endif //__CERTSD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certsrv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       CertSrv.h
//  Contents:   Main Certificate Server header
//              Also includes .h files for the COM interfaces
//
//----------------------------------------------------------------------------

#if !defined( _CERTSRV_H_ )
#define _CERTSRV_H_

#include <certadm.h>
#include <certbcli.h>
#include <certcli.h>
#include <certenc.h>
#include <certexit.h>
#include <certif.h>
#include <certpol.h>
#include <certmod.h>
#include <certview.h>

#ifndef DBG_CERTSRV
# if defined(_DEBUG)
#  define DBG_CERTSRV     1
# elif defined(DBG)
#  define DBG_CERTSRV     DBG
# else
#  define DBG_CERTSRV     0
# endif
#endif

#define wszSERVICE_NAME		TEXT("CertSvc")

#define wszREGKEYNOSYSTEMCERTSVCPATH \
				TEXT("CurrentControlSet\\Services\\") \
				wszSERVICE_NAME

#define wszREGKEYCERTSVCPATH	TEXT("SYSTEM\\") wszREGKEYNOSYSTEMCERTSVCPATH
#define wszREGKEYBASE		wszREGKEYCERTSVCPATH	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\":
#define wszREGKEYCONFIGPATH	wszREGKEYCERTSVCPATH TEXT("\\") wszREGKEYCONFIG
#define wszREGKEYCONFIGPATH_BS	wszREGKEYCONFIGPATH TEXT("\\")
#define wszREGKEYCONFIGCANAME	wszREGKEYCONFIGPATH_BS	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\RestoreInProgress":
#define wszREGKEYCONFIGRESTORE wszREGKEYCONFIGPATH_BS wszREGKEYRESTOREINPROGRESS

//======================================================================
// Key Under "CertSvc":
#define wszREGKEYCONFIG		TEXT("Configuration")

//======================================================================
// Values Under "CertSvc\Configuration":
#define wszREGACTIVE		      TEXT("Active")
#define wszREGDIRECTORY		      TEXT("ConfigurationDirectory")
#define wszREGDBDIRECTORY             TEXT("DBDirectory")
#define wszREGDBLOGDIRECTORY          TEXT("DBLogDirectory")
#define wszREGDBSYSDIRECTORY          TEXT("DBSystemDirectory")
#define wszREGDBTEMPDIRECTORY         TEXT("DBTempDirectory")
#define wszREGDBSESSIONCOUNT	      TEXT("DBSessionCount")
#define wszREGDBLASTFULLBACKUP	      TEXT("DBLastFullBackup")
#define wszREGDBLASTINCREMENTALBACKUP TEXT("DBLastIncrementalBackup")
#define wszREGDBLASTRECOVERY	      TEXT("DBLastRecovery")
#define wszREGWEBCLIENTCAMACHINE      TEXT("WebClientCAMachine")
#define wszREGVERSION		      TEXT("Version")
#define wszREGWEBCLIENTCANAME         TEXT("WebClientCAName")
#define wszREGWEBCLIENTCATYPE         TEXT("WebClientCAType")
#define wszREGDBOPTIONALFLAGS         TEXT("DBOptionalFlags")


// Default value for wszREGDBSESSIONCOUNT
#define DBSESSIONCOUNTDEFAULT	     20

// Default value for wszREGMAXINCOMINGMESSAGESIZE
#define MAXINCOMINGMESSAGESIZEDEFAULT	     (64 * 1024)

// Value for wszREGVERSION:
#define CSVER_MAJOR		     2	// high 16 bits
#define CSVER_MINOR		     1	// low 16 bits

// stamp, for all time,the whistler version:
#define CSVER_WHISTLER               ((2<<16)|(1))

// Keys Under "CertSvc\Configuration":
#define wszREGKEYRESTOREINPROGRESS   TEXT("RestoreInProgress")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>":
#define wszREGCADESCRIPTION          TEXT("CADescription")
#define wszREGCACERTHASH	     TEXT("CACertHash")
#define wszREGCASERIALNUMBER	     TEXT("CACertSerialNumber")
#define wszREGCAXCHGCERTHASH	     TEXT("CAXchgCertHash")
#define wszREGKRACERTHASH	     TEXT("KRACertHash")
#define wszREGKRACERTCOUNT	     TEXT("KRACertCount")
#define wszREGKRAFLAGS		     TEXT("KRAFlags")
#define wszREGCATYPE		     TEXT("CAType")
#define wszREGCERTENROLLCOMPATIBLE   TEXT("CertEnrollCompatible")
#define wszREGENFORCEX500NAMELENGTHS TEXT("EnforceX500NameLengths")
#define wszREGCOMMONNAME	     TEXT("CommonName")
#define wszREGCLOCKSKEWMINUTES	     TEXT("ClockSkewMinutes")

#define wszREGCRLNEXTPUBLISH         TEXT("CRLNextPublish")
#define wszREGCRLPERIODSTRING	     TEXT("CRLPeriod")
#define wszREGCRLPERIODCOUNT	     TEXT("CRLPeriodUnits")
#define wszREGCRLOVERLAPPERIODSTRING TEXT("CRLOverlapPeriod")
#define wszREGCRLOVERLAPPERIODCOUNT  TEXT("CRLOverlapUnits")

#define wszREGCRLDELTANEXTPUBLISH    TEXT("CRLDeltaNextPublish")
#define wszREGCRLDELTAPERIODSTRING   TEXT("CRLDeltaPeriod")
#define wszREGCRLDELTAPERIODCOUNT    TEXT("CRLDeltaPeriodUnits")
#define wszREGCRLDELTAOVERLAPPERIODSTRING TEXT("CRLDeltaOverlapPeriod")
#define wszREGCRLDELTAOVERLAPPERIODCOUNT  TEXT("CRLDeltaOverlapUnits")

#define wszREGCRLPUBLICATIONURLS     TEXT("CRLPublicationURLs")
#define wszREGCACERTPUBLICATIONURLS  TEXT("CACertPublicationURLs")

#define wszREGCAXCHGVALIDITYPERIODSTRING  TEXT("CAXchgValidityPeriod")
#define wszREGCAXCHGVALIDITYPERIODCOUNT   TEXT("CAXchgValidityPeriodUnits")
#define wszREGCAXCHGOVERLAPPERIODSTRING   TEXT("CAXchgOverlapPeriod")
#define wszREGCAXCHGOVERLAPPERIODCOUNT    TEXT("CAXchgOverlapPeriodUnits")

#define wszREGCRLPATH_OLD            TEXT("CRLPath")
#define wszREGCRLEDITFLAGS	     TEXT("CRLEditFlags")
#define wszREGCRLFLAGS		     TEXT("CRLFlags")
#define wszREGCRLATTEMPTREPUBLISH    TEXT("CRLAttemptRepublish")
#define wszREGENABLED		     TEXT("Enabled")
#define wszREGFORCETELETEX           TEXT("ForceTeletex")
#define wszREGLOGLEVEL		     TEXT("LogLevel")
#define wszREGHIGHSERIAL	     TEXT("HighSerial")
#define wszREGPOLICYFLAGS	     TEXT("PolicyFlags")
#define wszREGNAMESEPARATOR          TEXT("SubjectNameSeparator")
#define wszREGSUBJECTTEMPLATE	     TEXT("SubjectTemplate")
#define wszREGCAUSEDS		     TEXT("UseDS")
#define wszREGVALIDITYPERIODSTRING   TEXT("ValidityPeriod")
#define wszREGVALIDITYPERIODCOUNT    TEXT("ValidityPeriodUnits")
#define wszREGPARENTCAMACHINE        TEXT("ParentCAMachine")
#define wszREGPARENTCANAME           TEXT("ParentCAName")
#define wszREGREQUESTFILENAME        TEXT("RequestFileName")
#define wszREGREQUESTID              TEXT("RequestId")
#define wszREGREQUESTKEYCONTAINER    TEXT("RequestKeyContainer")
#define wszREGREQUESTKEYINDEX        TEXT("RequestKeyIndex")
#define wszREGCASERVERNAME           TEXT("CAServerName")
#define wszREGCACERTFILENAME         TEXT("CACertFileName")
#define wszREGCASECURITY             TEXT("Security")
#define wszREGAUDITFILTER            TEXT("AuditFilter")
#define wszREGOFFICERRIGHTS          TEXT("OfficerRights")
#define wszREGMAXINCOMINGMESSAGESIZE TEXT("MaxIncomingMessageSize")
#define wszREGROLESEPARATIONENABLED  TEXT("RoleSeparationEnabled")

#define wszREGSETUPSTATUS            TEXT("SetupStatus")
#define wszLOCKICERTREQUEST          TEXT("LockICertRequest")    
#define wszREGDSCONFIGDN	     TEXT("DSConfigDN")    
#define wszREGDSDOMAINDN	     TEXT("DSDomainDN")    

#define wszPFXFILENAMEEXT	     TEXT(".p12")
#define wszDATFILENAMEEXT	     TEXT(".dat")
#define wszLOGFILENAMEEXT	     TEXT(".log")
#define wszPATFILENAMEEXT	     TEXT(".pat")
#define wszDBFILENAMEEXT	     TEXT(".edb")
#define szDBBASENAMEPARM	     "edb"
#define wszDBBASENAMEPARM	     TEXT(szDBBASENAMEPARM)
#define wszLOGPATH		     TEXT("CertLog")
#define wszDBBACKUPSUBDIR	     TEXT("DataBase")
#define wszDBBACKUPCERTBACKDAT	     TEXT("certbkxp.dat")

#ifndef __ENUM_CATYPES__
#define __ENUM_CATYPES__

// Values for wszREGCATYPE:
typedef enum {
    ENUM_ENTERPRISE_ROOTCA = 0,
    ENUM_ENTERPRISE_SUBCA = 1,
    //ENUM_UNUSED2 = 2,
    ENUM_STANDALONE_ROOTCA = 3,
    ENUM_STANDALONE_SUBCA = 4,
    ENUM_UNKNOWN_CA = 5,
} ENUM_CATYPES;

#endif __ENUM_CATYPES__

// Default value for wszREGCLOCKSKEWMINUTES
#define CCLOCKSKEWMINUTESDEFAULT	      10

// Default validity period for ROOT CA certs:
#define dwVALIDITYPERIODCOUNTDEFAULT_ROOT	5

// Default validity periods for certs issued by a CA:
#define dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE	2
#define dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE	1
#define dwVALIDITYPERIODENUMDEFAULT	      ENUM_PERIOD_YEARS
#define wszVALIDITYPERIODSTRINGDEFAULT	      wszPERIODYEARS

#define dwCAXCHGVALIDITYPERIODCOUNTDEFAULT    1
#define dwCAXCHGVALIDITYPERIODENUMDEFAULT     ENUM_PERIOD_WEEKS
#define wszCAXCHGVALIDITYPERIODSTRINGDEFAULT  wszPERIODWEEKS

#define dwCAXCHGOVERLAPPERIODCOUNTDEFAULT     1
#define dwCAXCHGOVERLAPPERIODENUMDEFAULT      ENUM_PERIOD_DAYS
#define wszCAXCHGOVERLAPPERIODSTRINGDEFAULT   wszPERIODDAYS

#define dwCRLPERIODCOUNTDEFAULT		      1
#define wszCRLPERIODSTRINGDEFAULT	      wszPERIODWEEKS

#define dwCRLOVERLAPPERIODCOUNTDEFAULT	      0		// 0 --> disabled
#define wszCRLOVERLAPPERIODSTRINGDEFAULT      wszPERIODHOURS

#define dwCRLDELTAPERIODCOUNTDEFAULT          1
#define wszCRLDELTAPERIODSTRINGDEFAULT        wszPERIODDAYS

#define dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT   0		// 0 --> disabled
#define wszCRLDELTAOVERLAPPERIODSTRINGDEFAULT wszPERIODMINUTES


// Values for wszREGLOGLEVEL:
#define CERTLOG_MINIMAL		(DWORD) 0
#define CERTLOG_TERSE		(DWORD) 1
#define CERTLOG_ERROR		(DWORD) 2
#define CERTLOG_WARNING		(DWORD) 3
#define CERTLOG_VERBOSE		(DWORD) 4


// Values for wszREGSETUPSTATUS:
#define SETUP_SERVER_FLAG		0x00000001	// server installed
#define SETUP_CLIENT_FLAG		0x00000002	// client installed
#define SETUP_SUSPEND_FLAG		0x00000004	// incomplete install
#define SETUP_REQUEST_FLAG		0x00000008	// new cert requested
#define SETUP_ONLINE_FLAG		0x00000010	// requested online
#define SETUP_DENIED_FLAG		0x00000020	// request denied
#define SETUP_CREATEDB_FLAG		0x00000040	// create new DB
#define SETUP_ATTEMPT_VROOT_CREATE	0x00000080	// try to create vroots
#define SETUP_FORCECRL_FLAG		     0x00000100	// force new CRL(s)
#define SETUP_UPDATE_CAOBJECT_SVRTYPE	     0x00000200	// add server type to CA DS object "flags" attr
#define SETUP_SERVER_UPGRADED_FLAG	     0x00000400	// server was upgraded
#define SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG 0x00000800 // still need to upgrade security

// Values for wszREGCRLFLAGS:
#define CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE	0x00000001 // use oldest base:
// else use newest base CRL that satisfies base CRL propagation delay

#define CRLF_DELETE_EXPIRED_CRLS		0x00000002
#define CRLF_CRLNUMBER_CRITICAL			0x00000004
#define CRLF_REVCHECK_IGNORE_OFFLINE		0x00000008
#define CRLF_IGNORE_INVALID_POLICIES		0x00000010
#define CRLF_REBUILD_MODIFIED_SUBJECT_ONLY	0x00000020
#define CRLF_SAVE_FAILED_CERTS			0x00000040
#define CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES	0x00000080
#define CRLF_ACCEPT_OLDRFC_CMC			0x00000100
#define CRLF_PUBLISH_EXPIRED_CERT_CRLS		0x00000200

// Values for wszREGKRAFLAGS:
#define KRAF_ENABLEFOREIGN	0x00000001 // allow foreign cert, key archival
#define KRAF_SAVEBADREQUESTKEY	0x00000002 // save failed request w/archived key

// Values for numeric prefixes for
// wszREGCRLPUBLICATIONURLS and wszREGCACERTPUBLICATIONURLS:
//
// URL publication template Flags values, encoded as a decimal prefix for URL
// publication templates in the registry:
//   "1:c:\winnt\System32\CertSrv\CertEnroll\MyCA.crl"
//   "2:http:\//MyServer.MyDomain.com/CertEnroll\MyCA.crl"

#define CSURL_SERVERPUBLISH	0x00000001
#define CSURL_ADDTOCERTCDP	0x00000002
#define CSURL_ADDTOFRESHESTCRL	0x00000004
#define CSURL_ADDTOCRLCDP	0x00000008
#define CSURL_PUBLISHRETRY	0x00000010
#define CSURL_ADDTOCERTOCSP	0x00000020
//======================================================================
// Keys Under "CertSvc\Configuration\<CAName>":
#define wszREGKEYCSP			TEXT("CSP")
#define wszREGKEYENCRYPTIONCSP		TEXT("EncryptionCSP")
#define wszREGKEYEXITMODULES		TEXT("ExitModules")
#define wszREGKEYPOLICYMODULES	        TEXT("PolicyModules")
#define wszSECUREDATTRIBUTES		TEXT("SignedAttributes")

#define wszzDEFAULTSIGNEDATTRIBUTES     TEXT("RequesterName\0")

//======================================================================
// Values Under "CertSvc\Configuration\RestoreInProgress":
#define wszREGBACKUPLOGDIRECTORY	TEXT("BackupLogDirectory")
#define wszREGCHECKPOINTFILE		TEXT("CheckPointFile")
#define wszREGHIGHLOGNUMBER		TEXT("HighLogNumber")
#define wszREGLOWLOGNUMBER		TEXT("LowLogNumber")
#define wszREGLOGPATH			TEXT("LogPath")
#define wszREGRESTOREMAPCOUNT		TEXT("RestoreMapCount")
#define wszREGRESTOREMAP		TEXT("RestoreMap")
#define wszREGDATABASERECOVERED		TEXT("DatabaseRecovered")
#define wszREGRESTORESTATUS		TEXT("RestoreStatus")

// values under \Configuration\PolicyModules in nt5 beta 2
#define wszREGB2ICERTMANAGEMODULE   TEXT("ICertManageModule")
// values under \Configuration in nt4 sp4
#define wszREGSP4DEFAULTCONFIGURATION  TEXT("DefaultConfiguration")
// values under ca in nt4 sp4
#define wszREGSP4KEYSETNAME            TEXT("KeySetName")
#define wszREGSP4SUBJECTNAMESEPARATOR  TEXT("SubjectNameSeparator")
#define wszREGSP4NAMES                 TEXT("Names")
#define wszREGSP4QUERIES               TEXT("Queries")
// both nt4 sp4 and nt5 beta 2
#define wszREGNETSCAPECERTTYPE         TEXT("NetscapeCertType")
#define wszNETSCAPEREVOCATIONTYPE      TEXT("Netscape")


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\CSP":
// and "CertSvc\Configuration\<CAName>\EncryptionCSP":
#define wszREGPROVIDERTYPE     TEXT("ProviderType")
#define wszREGPROVIDER         TEXT("Provider")
#define wszHASHALGORITHM       TEXT("HashAlgorithm")
#define wszENCRYPTIONALGORITHM TEXT("EncryptionAlgorithm")
#define wszMACHINEKEYSET       TEXT("MachineKeyset")
#define wszREGKEYSIZE	       TEXT("KeySize")


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\SubjectNameSeparator":
#define szNAMESEPARATORDEFAULT   "\n"
#define wszNAMESEPARATORDEFAULT   TEXT(szNAMESEPARATORDEFAULT)


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\ValidityPeriod", etc.:
#define wszPERIODYEARS		TEXT("Years")
#define wszPERIODMONTHS		TEXT("Months")
#define wszPERIODWEEKS		TEXT("Weeks")
#define wszPERIODDAYS		TEXT("Days")
#define wszPERIODHOURS		TEXT("Hours")
#define wszPERIODMINUTES	TEXT("Minutes")
#define wszPERIODSECONDS	TEXT("Seconds")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\PolicyModules\<ProgId>":
#define wszREGISSUERCERTURLFLAGS    TEXT("IssuerCertURLFlags")
#define wszREGEDITFLAGS		    TEXT("EditFlags")
#define wszREGSUBJECTALTNAME	    TEXT("SubjectAltName")
#define wszREGSUBJECTALTNAME2	    TEXT("SubjectAltName2")
#define wszREGREQUESTDISPOSITION    TEXT("RequestDisposition")
#define wszREGCAPATHLENGTH	    TEXT("CAPathLength")
#define wszREGREVOCATIONTYPE	    TEXT("RevocationType")

#define wszREGLDAPREVOCATIONCRLURL_OLD	TEXT("LDAPRevocationCRLURL")
#define wszREGREVOCATIONCRLURL_OLD	TEXT("RevocationCRLURL")
#define wszREGFTPREVOCATIONCRLURL_OLD	TEXT("FTPRevocationCRLURL")
#define wszREGFILEREVOCATIONCRLURL_OLD	TEXT("FileRevocationCRLURL")

#define wszREGREVOCATIONURL		TEXT("RevocationURL")

#define wszREGLDAPISSUERCERTURL_OLD	TEXT("LDAPIssuerCertURL")
#define wszREGISSUERCERTURL_OLD		TEXT("IssuerCertURL")
#define wszREGFTPISSUERCERTURL_OLD	TEXT("FTPIssuerCertURL")
#define wszREGFILEISSUERCERTURL_OLD	TEXT("FileIssuerCertURL")

#define wszREGENABLEREQUESTEXTENSIONLIST  TEXT("EnableRequestExtensionList")
#define wszREGDISABLEEXTENSIONLIST  TEXT("DisableExtensionList")

#define wszREGDEFAULTSMIME		TEXT("DefaultSMIME")

// wszREGCAPATHLENGTH Values:
#define CAPATHLENGTH_INFINITE		0xffffffff

// wszREGREQUESTDISPOSITION Values:
#define REQDISP_PENDING			0x00000000
#define REQDISP_ISSUE			0x00000001
#define REQDISP_DENY			0x00000002
#define REQDISP_USEREQUESTATTRIBUTE	0x00000003
#define REQDISP_MASK			0x000000ff
#define REQDISP_PENDINGFIRST		0x00000100
#define REQDISP_DEFAULT_STANDALONE	(REQDISP_PENDINGFIRST | REQDISP_ISSUE)
#define REQDISP_DEFAULT_ENTERPRISE	(REQDISP_ISSUE)

// wszREGREVOCATIONTYPE Values:
#define REVEXT_CDPLDAPURL_OLD		0x00000001
#define REVEXT_CDPHTTPURL_OLD		0x00000002
#define REVEXT_CDPFTPURL_OLD		0x00000004
#define REVEXT_CDPFILEURL_OLD		0x00000008
#define REVEXT_CDPURLMASK_OLD		0x000000ff
#define REVEXT_CDPENABLE		0x00000100
#define REVEXT_ASPENABLE		0x00000200

#define REVEXT_DEFAULT_NODS		(REVEXT_CDPENABLE)
#define REVEXT_DEFAULT_DS		(REVEXT_CDPENABLE)

// wszREGISSUERCERTURLFLAGS Values:
#define ISSCERT_LDAPURL_OLD		0x00000001
#define ISSCERT_HTTPURL_OLD		0x00000002
#define ISSCERT_FTPURL_OLD		0x00000004
#define ISSCERT_FILEURL_OLD		0x00000008
#define ISSCERT_URLMASK_OLD		0x000000ff
#define ISSCERT_ENABLE			0x00000100

#define ISSCERT_DEFAULT_NODS		(ISSCERT_ENABLE)
#define ISSCERT_DEFAULT_DS		(ISSCERT_ENABLE)

// wszREGEDITFLAGS Values:				   Defaults:
// Under CA key: wszREGCRLEDITFLAGS Values (EDITF_ENABLEAKI* only):
#define EDITF_ENABLEREQUESTEXTENSIONS	0x00000001	// neither
#define EDITF_REQUESTEXTENSIONLIST	0x00000002	// Standalone
#define EDITF_DISABLEEXTENSIONLIST	0x00000004	// both
#define EDITF_ADDOLDKEYUSAGE		0x00000008	// both
#define EDITF_ADDOLDCERTTYPE		0x00000010	// neither
#define EDITF_ATTRIBUTEENDDATE		0x00000020	// Standalone
#define EDITF_BASICCONSTRAINTSCRITICAL	0x00000040	// Standalone
#define EDITF_BASICCONSTRAINTSCA	0x00000080	// Standalone
#define EDITF_ENABLEAKIKEYID		0x00000100	// both
#define EDITF_ATTRIBUTECA		0x00000200	// Standalone
#define EDITF_IGNOREREQUESTERGROUP      0x00000400	// Standalone
#define EDITF_ENABLEAKIISSUERNAME	0x00000800	// both
#define EDITF_ENABLEAKIISSUERSERIAL	0x00001000	// both
#define EDITF_ENABLEAKICRITICAL		0x00002000	// both
#define EDITF_SERVERUPGRADED		0x00004000	// neither
#define EDITF_ATTRIBUTEEKU		0x00008000	// Standalone
#define EDITF_ENABLEDEFAULTSMIME	0x00010000	// Enterprise

#define EDITF_DEFAULT_STANDALONE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
					 EDITF_ATTRIBUTEENDDATE | \
					 EDITF_BASICCONSTRAINTSCRITICAL | \
					 EDITF_BASICCONSTRAINTSCA | \
					 EDITF_ENABLEAKIKEYID | \
					 EDITF_ATTRIBUTECA | \
					 EDITF_ATTRIBUTEEKU)

#define EDITF_DEFAULT_ENTERPRISE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
                                         EDITF_BASICCONSTRAINTSCRITICAL | \
                                         EDITF_ENABLEAKIKEYID | \
					 EDITF_ADDOLDKEYUSAGE | \
					 EDITF_ENABLEDEFAULTSMIME)


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\<ProgId>":

// LDAP based CRL and URL issuance
#define wszREGLDAPREVOCATIONDN_OLD	   TEXT("LDAPRevocationDN")
#define wszREGLDAPREVOCATIONDNTEMPLATE_OLD TEXT("LDAPRevocationDNTemplate")
#define wszCRLPUBLISHRETRYCOUNT    TEXT("CRLPublishRetryCount")
#define wszREGCERTPUBLISHFLAGS     TEXT("PublishCertFlags")

// wszREGCERTPUBLISHFLAGS Values:
#define EXITPUB_FILE			0x00000001
#define EXITPUB_ACTIVEDIRECTORY		0x00000002
#define EXITPUB_EMAILNOTIFYALL		0x00000004
#define EXITPUB_EMAILNOTIFYSMARTCARD	0x00000008
#define EXITPUB_REMOVEOLDCERTS		0x00000010

#define EXITPUB_DEFAULT_ENTERPRISE	EXITPUB_ACTIVEDIRECTORY

#define EXITPUB_DEFAULT_STANDALONE	EXITPUB_FILE


#define wszCLASS_CERTADMIN	  TEXT("CertificateAuthority.Admin")
#define wszCLASS_CERTCONFIG	  TEXT("CertificateAuthority.Config")
#define wszCLASS_CERTGETCONFIG	  TEXT("CertificateAuthority.GetConfig")
#define wszCLASS_CERTENCODE	  TEXT("CertificateAuthority.Encode")
#define wszCLASS_CERTREQUEST	  TEXT("CertificateAuthority.Request")
#define wszCLASS_CERTSERVEREXIT   TEXT("CertificateAuthority.ServerExit")
#define wszCLASS_CERTSERVERPOLICY TEXT("CertificateAuthority.ServerPolicy")
#define wszCLASS_CERTVIEW	  TEXT("CertificateAuthority.View")

// class name templates
#define wszMICROSOFTCERTMODULE_PREFIX  TEXT("CertificateAuthority_MicrosoftDefault") 
#define wszCERTEXITMODULE_POSTFIX	TEXT(".Exit")
#define wszCERTMANAGEEXIT_POSTFIX	TEXT(".ExitManage")
#define wszCERTPOLICYMODULE_POSTFIX	TEXT(".Policy")
#define wszCERTMANAGEPOLICY_POSTFIX	TEXT(".PolicyManage")

// actual policy/exit manage class names
#define wszCLASS_CERTMANAGEEXITMODULE   wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEEXIT_POSTFIX 

#define wszCLASS_CERTMANAGEPOLICYMODULE wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEPOLICY_POSTFIX 

// actual policy/exit class names
#define wszCLASS_CERTEXIT	wszMICROSOFTCERTMODULE_PREFIX wszCERTEXITMODULE_POSTFIX

#define wszCLASS_CERTPOLICY	wszMICROSOFTCERTMODULE_PREFIX wszCERTPOLICYMODULE_POSTFIX


#define wszCAPOLICYFILE			L"CAPolicy.inf"

#define wszINFSECTION_CDP		L"CRLDistributionPoint"
#define wszINFSECTION_AIA		L"AuthorityInformationAccess"
#define wszINFSECTION_EKU		L"EnhancedKeyUsageExtension"
#define wszINFSECTION_CCDP		L"CrossCertificateDistributionPointsExtension"

#define wszINFSECTION_CERTSERVER	L"certsrv_server"
#define wszINFKEY_RENEWALKEYLENGTH	L"RenewalKeyLength"
#define wszINFKEY_RENEWALVALIDITYPERIODSTRING	L"RenewalValidityPeriod"
#define wszINFKEY_RENEWALVALIDITYPERIODCOUNT	L"RenewalValidityPeriodUnits"
#define wszINFKEY_UTF8			L"UTF8"
#define wszINFKEY_CRLPERIODSTRING	wszREGCRLPERIODSTRING
#define wszINFKEY_CRLPERIODCOUNT	wszREGCRLPERIODCOUNT
#define wszINFKEY_CRLDELTAPERIODSTRING	wszREGCRLDELTAPERIODSTRING
#define wszINFKEY_CRLDELTAPERIODCOUNT	wszREGCRLDELTAPERIODCOUNT

#define wszINFKEY_CRITICAL		L"Critical"
#define wszINFKEY_EMPTY			L"Empty"

#define wszINFKEY_CCDPSYNCDELTATIME	L"SyncDeltaTime"

#define wszINFSECTION_CAPOLICY		L"CAPolicy"
#define wszINFSECTION_POLICYSTATEMENT	L"PolicyStatementExtension"
#define wszINFSECTION_APPLICATIONPOLICYSTATEMENT	L"ApplicationPolicyStatementExtension"
#define wszINFKEY_POLICIES		L"Policies"
#define wszINFKEY_OID			L"OID"
#define wszINFKEY_NOTICE		L"Notice"

#define wszINFSECTION_REQUESTATTRIBUTES	L"RequestAttributes"

#define wszINFSECTION_NAMECONSTRAINTS	L"NameConstraintsExtension"
#define wszINFKEY_INCLUDE		L"Include"
#define wszINFKEY_EXCLUDE		L"Exclude"

#define wszINFKEY_UPN			L"UPN"
#define wszINFKEY_EMAIL			L"EMail"
#define wszINFKEY_DNS			L"DNS"
#define wszINFKEY_DIRECTORYNAME		L"DirectoryName"
#define wszINFKEY_URL			L"URL"
#define wszINFKEY_IPADDRESS		L"IPAddress"
#define wszINFKEY_REGISTEREDID		L"RegisteredId"

#define wszINFSECTION_POLICYMAPPINGS	L"PolicyMappingsExtension"
#define wszINFSECTION_APPLICATIONPOLICYMAPPINGS	L"ApplicationPolicyMappingsExtension"

#define wszINFSECTION_POLICYCONSTRAINTS	L"PolicyConstraintsExtension"
#define wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS	L"ApplicationPolicyConstraintsExtension"
#define wszINFKEY_REQUIREEXPLICITPOLICY	L"RequireExplicitPolicy"
#define wszINFKEY_INHIBITPOLICYMAPPING	L"InhibitPolicyMapping"

#define wszINFSECTION_BASICCONSTRAINTS	L"BasicConstraintsExtension"
#define wszINFKEY_PATHLENGTH		L"PathLength"


// exit module mail support
#define wszREGEXITSMTPKEY		L"SMTP"
#define wszREGEXITSMTPFROM		L"From"
#define wszREGEXITSMTPCC		L"CC"
#define wszREGEXITSMTPSUBJECT		L"Subject"


//+--------------------------------------------------------------------------
// Name properties:

#define wszPROPDISTINGUISHEDNAME   TEXT("DistinguishedName")
#define wszPROPRAWNAME             TEXT("RawName")

#define wszPROPCOUNTRY             TEXT("Country")
#define wszPROPORGANIZATION        TEXT("Organization")
#define wszPROPORGUNIT             TEXT("OrgUnit")
#define wszPROPCOMMONNAME          TEXT("CommonName")
#define wszPROPLOCALITY            TEXT("Locality")
#define wszPROPSTATE               TEXT("State")
#define wszPROPTITLE               TEXT("Title")
#define wszPROPGIVENNAME           TEXT("GivenName")
#define wszPROPINITIALS            TEXT("Initials")
#define wszPROPSURNAME             TEXT("SurName")
#define wszPROPDOMAINCOMPONENT     TEXT("DomainComponent")
#define wszPROPEMAIL               TEXT("EMail")
#define wszPROPSTREETADDRESS       TEXT("StreetAddress")
#define wszPROPUNSTRUCTUREDNAME    TEXT("UnstructuredName")
#define wszPROPUNSTRUCTUREDADDRESS TEXT("UnstructuredAddress")
#define wszPROPDEVICESERIALNUMBER  TEXT("DeviceSerialNumber")

//+--------------------------------------------------------------------------
// Subject Name properties:

#define wszPROPSUBJECTDOT	    TEXT("Subject.")
#define wszPROPSUBJECTDISTINGUISHEDNAME \
				    wszPROPSUBJECTDOT wszPROPDISTINGUISHEDNAME
#define wszPROPSUBJECTRAWNAME       wszPROPSUBJECTDOT wszPROPRAWNAME

#define wszPROPSUBJECTCOUNTRY       wszPROPSUBJECTDOT wszPROPCOUNTRY
#define wszPROPSUBJECTORGANIZATION  wszPROPSUBJECTDOT wszPROPORGANIZATION
#define wszPROPSUBJECTORGUNIT       wszPROPSUBJECTDOT wszPROPORGUNIT
#define wszPROPSUBJECTCOMMONNAME    wszPROPSUBJECTDOT wszPROPCOMMONNAME
#define wszPROPSUBJECTLOCALITY      wszPROPSUBJECTDOT wszPROPLOCALITY
#define wszPROPSUBJECTSTATE         wszPROPSUBJECTDOT wszPROPSTATE
#define wszPROPSUBJECTTITLE	    wszPROPSUBJECTDOT wszPROPTITLE
#define wszPROPSUBJECTGIVENNAME	    wszPROPSUBJECTDOT wszPROPGIVENNAME
#define wszPROPSUBJECTINITIALS	    wszPROPSUBJECTDOT wszPROPINITIALS
#define wszPROPSUBJECTSURNAME	    wszPROPSUBJECTDOT wszPROPSURNAME
#define wszPROPSUBJECTDOMAINCOMPONENT wszPROPSUBJECTDOT wszPROPDOMAINCOMPONENT
#define wszPROPSUBJECTEMAIL	    wszPROPSUBJECTDOT wszPROPEMAIL
#define wszPROPSUBJECTSTREETADDRESS wszPROPSUBJECTDOT wszPROPSTREETADDRESS
#define wszPROPSUBJECTUNSTRUCTUREDNAME wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDNAME
#define wszPROPSUBJECTUNSTRUCTUREDADDRESS wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDADDRESS
#define wszPROPSUBJECTDEVICESERIALNUMBER wszPROPSUBJECTDOT wszPROPDEVICESERIALNUMBER


//+--------------------------------------------------------------------------
// Request properties:
#define wszPROPREQUESTDOT	            TEXT("Request.")

#define wszPROPREQUESTREQUESTID		    TEXT("RequestID")
#define wszPROPREQUESTRAWREQUEST	    TEXT("RawRequest")
#define wszPROPREQUESTRAWARCHIVEDKEY	    TEXT("RawArchivedKey")
#define wszPROPREQUESTKEYRECOVERYHASHES	    TEXT("KeyRecoveryHashes")
#define wszPROPREQUESTRAWOLDCERTIFICATE	    TEXT("RawOldCertificate")
#define wszPROPREQUESTATTRIBUTES	    TEXT("RequestAttributes")
#define wszPROPREQUESTTYPE		    TEXT("RequestType")
#define wszPROPREQUESTFLAGS		    TEXT("RequestFlags")
#define wszPROPREQUESTSTATUSCODE	    TEXT("StatusCode")
#define wszPROPREQUESTDISPOSITION	    TEXT("Disposition")
#define wszPROPREQUESTDISPOSITIONMESSAGE    TEXT("DispositionMessage")
#define wszPROPREQUESTSUBMITTEDWHEN	    TEXT("SubmittedWhen")
#define wszPROPREQUESTRESOLVEDWHEN	    TEXT("ResolvedWhen")
#define wszPROPREQUESTREVOKEDWHEN	    TEXT("RevokedWhen")
#define wszPROPREQUESTREVOKEDEFFECTIVEWHEN  TEXT("RevokedEffectiveWhen")
#define wszPROPREQUESTREVOKEDREASON	    TEXT("RevokedReason")
#define wszPROPREQUESTERNAME		    TEXT("RequesterName")
#define wszPROPCALLERNAME		    TEXT("CallerName")
#define wszPROPSIGNERPOLICIES		    TEXT("SignerPolicies")
#define wszPROPSIGNERAPPLICATIONPOLICIES    TEXT("SignerApplicationPolicies")

//+--------------------------------------------------------------------------
// Request attribute properties:

#define wszPROPCHALLENGE		TEXT("Challenge")
#define wszPROPEXPECTEDCHALLENGE	TEXT("ExpectedChallenge")

#define wszPROPDISPOSITION		TEXT("Disposition")
#define wszPROPDISPOSITIONDENY		TEXT("Deny")
#define wszPROPDISPOSITIONPENDING	TEXT("Pending")

#define wszPROPVALIDITYPERIODSTRING	TEXT("ValidityPeriod")
#define wszPROPVALIDITYPERIODCOUNT	TEXT("ValidityPeriodUnits")

#define wszPROPCERTTYPE			TEXT("CertType")
#define wszPROPCERTTEMPLATE		TEXT("CertificateTemplate")
#define wszPROPCERTUSAGE		TEXT("CertificateUsage")

#define wszPROPREQUESTOSVERSION		TEXT("RequestOSVersion")
#define wszPROPREQUESTCSPPROVIDER       TEXT("RequestCSPProvider")

#define wszPROPEXITCERTFILE		TEXT("CertFile")
#define wszPROPCLIENTBROWSERMACHINE	TEXT("cbm")
#define wszPROPCERTCLIENTMACHINE	TEXT("ccm")


//+--------------------------------------------------------------------------
// "System" properties
// ".#" means ".0", ".1", ".2" ... may be appended to the property name to
// collect context specific values.  For some properties, the suffix selects
// the CA certificate context.  For others, it selects the the CA CRL context.

#define wszPROPCATYPE                   TEXT("CAType")
#define wszPROPSANITIZEDCANAME          TEXT("SanitizedCAName")
#define wszPROPSANITIZEDSHORTNAME       TEXT("SanitizedShortName")
#define wszPROPMACHINEDNSNAME           TEXT("MachineDNSName")
#define wszPROPMODULEREGLOC             TEXT("ModuleRegistryLocation")
#define wszPROPUSEDS                    TEXT("fUseDS")
#define wszPROPSERVERUPGRADED           TEXT("fServerUpgraded")
#define wszPROPCONFIGDN			TEXT("ConfigDN")
#define wszPROPDOMAINDN			TEXT("DomainDN")
#define wszPROPLOGLEVEL			TEXT("LogLevel")

// Request Context properties:

#define wszPROPREQUESTERCAACCESS	TEXT("RequesterCAAccess")
#define wszPROPUSERDN			TEXT("UserDN")
#define wszPROPTEMPLATECHANGESEQUENCENUMBER     TEXT("TemplateChangeSequenceNumber")


// CA Certificate properties: (all ".#" extensible except wszPROPCERTCOUNT)

#define wszPROPCERTCOUNT                TEXT("CertCount")
#define wszPROPRAWCACERTIFICATE         TEXT("RawCACertificate")
#define wszPROPCERTSTATE                TEXT("CertState")
#define wszPROPCERTSUFFIX               TEXT("CertSuffix")

// CA CRL properties: (all ".#" extensible)

#define wszPROPRAWCRL                   TEXT("RawCRL")
#define wszPROPRAWDELTACRL              TEXT("RawDeltaCRL")
#define wszPROPCRLINDEX                 TEXT("CRLIndex")
#define wszPROPCRLSTATE                 TEXT("CRLState")
#define wszPROPCRLSUFFIX                TEXT("CRLSuffix")

// Values for wszPROPCERTSTATE (see certadm.h):
//   CA_DISP_REVOKED    // This Cert has been revoked.
//   CA_DISP_VALID      // This Cert is still valid
//   CA_DISP_INVALID    // This Cert has expired.
//   CA_DISP_ERROR      // Cert unavailable (placehholder in registry?)

// Values for wszPROPCRLSTATE (see certadm.h):
//   CA_DISP_REVOKED	// All unexpired certs using this Cert's CRL have been
//			// revoked.
//   CA_DISP_VALID	// This Cert is still publishing CRLs as needed.
//   CA_DISP_INVALID    // All certs using this Cert's CRL are expired.
//   CA_DISP_ERROR      // This Cert's CRL is managed by another Cert.

// "Settable" system properties:
#define wszPROPEVENTLOGTERSE		TEXT("EventLogTerse")
#define wszPROPEVENTLOGERROR		TEXT("EventLogError")
#define wszPROPEVENTLOGWARNING		TEXT("EventLogWarning")
#define wszPROPEVENTLOGVERBOSE		TEXT("EventLogVerbose")

//+--------------------------------------------------------------------------
// Certificate properties:

#define wszPROPCERTIFICATEREQUESTID	       TEXT("RequestID")
#define wszPROPRAWCERTIFICATE		       TEXT("RawCertificate")
#define wszPROPCERTIFICATEHASH		       TEXT("CertificateHash")
#define wszPROPCERTIFICATETEMPLATE	       TEXT("CertificateTemplate")
#define wszPROPCERTIFICATEENROLLMENTFLAGS      TEXT("EnrollmentFlags")
#define wszPROPCERTIFICATEGENERALFLAGS         TEXT("GeneralFlags")
#define wszPROPCERTIFICATESERIALNUMBER	       TEXT("SerialNumber")
#define wszPROPCERTIFICATENOTBEFOREDATE	       TEXT("NotBefore")
#define wszPROPCERTIFICATENOTAFTERDATE	       TEXT("NotAfter")
#define wszPROPCERTIFICATESUBJECTKEYIDENTIFIER TEXT("SubjectKeyIdentifier")
#define wszPROPCERTIFICATERAWPUBLICKEY	       TEXT("RawPublicKey")
#define wszPROPCERTIFICATEPUBLICKEYLENGTH      TEXT("PublicKeyLength")
#define wszPROPCERTIFICATEPUBLICKEYALGORITHM   TEXT("PublicKeyAlgorithm")
#define wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS \
    TEXT("RawPublicKeyAlgorithmParameters")
#define wszPROPCERTIFICATEUPN		       TEXT("UPN")

// Obsolete:
#define wszPROPCERTIFICATETYPE		       TEXT("CertificateType")
#define wszPROPCERTIFICATERAWSMIMECAPABILITIES TEXT("RawSMIMECapabilities")
#define wszPROPNAMETYPE			       TEXT("NameType")

//+--------------------------------------------------------------------------
// Certificate extension properties:

#define EXTENSION_CRITICAL_FLAG	      0x00000001
#define EXTENSION_DISABLE_FLAG	      0x00000002
#define EXTENSION_POLICY_MASK	      0x0000ffff // Settable by admin+policy

#define EXTENSION_ORIGIN_REQUEST      0x00010000
#define EXTENSION_ORIGIN_POLICY	      0x00020000
#define EXTENSION_ORIGIN_ADMIN	      0x00030000
#define EXTENSION_ORIGIN_SERVER	      0x00040000
#define EXTENSION_ORIGIN_RENEWALCERT  0x00050000
#define EXTENSION_ORIGIN_IMPORTEDCERT 0x00060000
#define EXTENSION_ORIGIN_PKCS7	      0x00070000
#define EXTENSION_ORIGIN_CMC	      0x00080000
#define EXTENSION_ORIGIN_MASK	      0x000f0000

//+--------------------------------------------------------------------------
// Extension properties:

#define wszPROPEXTREQUESTID		TEXT("ExtensionRequestId")
#define wszPROPEXTNAME			TEXT("ExtensionName")
#define wszPROPEXTFLAGS			TEXT("ExtensionFlags")
#define wszPROPEXTRAWVALUE		TEXT("ExtensionRawValue")

//+--------------------------------------------------------------------------
// Attribute properties:

#define wszPROPATTRIBREQUESTID		TEXT("AttributeRequestId")
#define wszPROPATTRIBNAME		TEXT("AttributeName")
#define wszPROPATTRIBVALUE		TEXT("AttributeValue")

//+--------------------------------------------------------------------------
// CRL properties:

#define wszPROPCRLROWID			TEXT("CRLRowId")
#define wszPROPCRLNUMBER		TEXT("CRLNumber")
#define wszPROPCRLMINBASE		TEXT("CRLMinBase") // Delta CRLs only
#define wszPROPCRLNAMEID		TEXT("CRLNameId")
#define wszPROPCRLCOUNT			TEXT("CRLCount")
#define wszPROPCRLTHISUPDATE		TEXT("CRLThisUpdate")
#define wszPROPCRLNEXTUPDATE		TEXT("CRLNextUpdate")
#define wszPROPCRLTHISPUBLISH		TEXT("CRLThisPublish")
#define wszPROPCRLNEXTPUBLISH		TEXT("CRLNextPublish")
#define wszPROPCRLEFFECTIVE		TEXT("CRLEffective")
#define wszPROPCRLPROPAGATIONCOMPLETE	TEXT("CRLPropagationComplete")
#define wszPROPCRLLASTPUBLISHED		TEXT("CRLLastPublished")
#define wszPROPCRLPUBLISHATTEMPTS	TEXT("CRLPublishAttempts")
#define wszPROPCRLPUBLISHFLAGS		TEXT("CRLPublishFlags")
#define wszPROPCRLPUBLISHSTATUSCODE	TEXT("CRLPublishStatusCode")
#define wszPROPCRLPUBLISHERROR		TEXT("CRLPublishError")
#define wszPROPCRLRAWCRL		TEXT("CRLRawCRL")

//+--------------------------------------------------------------------------
// CRL Published Flags:

#define CPF_BASE		0x00000001
#define CPF_DELTA		0x00000002
#define CPF_COMPLETE		0x00000004
#define CPF_SHADOW		0x00000008
#define CPF_CASTORE_ERROR	0x00000010
#define CPF_BADURL_ERROR	0x00000020
#define CPF_MANUAL		0x00000040
#define CPF_LDAP_ERROR		0x00000100
#define CPF_FILE_ERROR		0x00000200
#define CPF_FTP_ERROR		0x00000400
#define CPF_HTTP_ERROR		0x00000800

//+--------------------------------------------------------------------------
// GetProperty/SetProperty Flags:
//
// Choose one Type

#define PROPTYPE_LONG		 0x00000001	// Signed long
#define PROPTYPE_DATE		 0x00000002	// Date+Time
#define PROPTYPE_BINARY		 0x00000003	// Binary data
#define PROPTYPE_STRING		 0x00000004	// Unicode String
#define PROPTYPE_MASK		 0x000000ff

// Choose one Caller:

#define PROPCALLER_SERVER	 0x00000100
#define PROPCALLER_POLICY	 0x00000200
#define PROPCALLER_EXIT		 0x00000300
#define PROPCALLER_ADMIN	 0x00000400
#define PROPCALLER_REQUEST	 0x00000500
#define PROPCALLER_MASK		 0x00000f00
#define PROPFLAGS_INDEXED	 0x00010000	

// RequestFlags definitions:

#define CR_FLG_FORCETELETEX	 0x00000001
#define CR_FLG_RENEWAL		 0x00000002
#define CR_FLG_FORCEUTF8	 0x00000004
#define CR_FLG_CAXCHGCERT	 0x00000008
#define CR_FLG_ENROLLONBEHALFOF	 0x00000010
#define CR_FLG_SUBJECTUNMODIFIED 0x00000020
#define CR_FLG_OLDRFCCMC	 0x40000000	// BUGBUG: temporary!!!
#define CR_FLG_PUBLISHERROR	 0x80000000

// Disposition property values:

// Disposition values for requests in the queue:
#define DB_DISP_ACTIVE	        8	// being processed
#define DB_DISP_PENDING		9	// taken under submission
#define DB_DISP_QUEUE_MAX	9	// max disposition value for queue view

#define DB_DISP_FOREIGN		12	// archived foreign cert

#define DB_DISP_CA_CERT		15	// CA cert
#define DB_DISP_CA_CERT_CHAIN	16	// CA cert chain
#define DB_DISP_KRA_CERT	17	// KRA cert

// Disposition values for requests in the log:
#define DB_DISP_LOG_MIN		20	// min disposition value for log view
#define DB_DISP_ISSUED		20	// cert issued
#define DB_DISP_REVOKED	        21	// issued and revoked

// Disposition values for failed requests in the log:
#define DB_DISP_LOG_FAILED_MIN	30	// min disposition value for log view
#define DB_DISP_ERROR		30	// request failed
#define DB_DISP_DENIED		31	// request denied


// VerifyRequest() return values

#define VR_PENDING	0	 // request will be accepted or denied later
#define VR_INSTANT_OK	1	 // request was accepted
#define VR_INSTANT_BAD	2	 // request was rejected


//+--------------------------------------------------------------------------
// Known request Attribute names and Value strings

// RequestType attribute name:
#define wszCERT_TYPE		L"RequestType"	// attribute name

// RequestType attribute values:
// Not specified: 				// Non-specific certificate
#define wszCERT_TYPE_CLIENT	L"Client"	// Client authentication cert
#define wszCERT_TYPE_SERVER	L"Server"	// Server authentication cert
#define wszCERT_TYPE_CODESIGN	L"CodeSign"	// Code signing certificate
#define wszCERT_TYPE_CUSTOMER	L"SetCustomer"	// SET Customer certificate
#define wszCERT_TYPE_MERCHANT	L"SetMerchant"	// SET Merchant certificate
#define wszCERT_TYPE_PAYMENT	L"SetPayment"	// SET Payment certificate


// Version attribute name:
#define wszCERT_VERSION		L"Version"	// attribute name

// Version attribute values:
// Not specified: 				// Whetever is current
#define wszCERT_VERSION_1	L"1"		// Version one certificate
#define wszCERT_VERSION_2	L"2"		// Version two certificate
#define wszCERT_VERSION_3	L"3"		// Version three certificate

#endif // _CERTSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certlib.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certlib.h
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#ifndef __CERTLIB_H__
#define __CERTLIB_H__

#include <wintrust.h>	// for spc_xxxx
#include <cryptui.h>	// for CRYPTUI_CA_CONTEXT
#include <setupapi.h>	// for HINF
#include <stdio.h>	// for wprintf -- include before cs.h
#include "cs.h"         // for CSASSERT
#include <xelib.h>	// for CERTLIB_ALLOCATOR
#include "csregstr.h"	// for ENUM_CATYPES
#include "csfile.h"	// for __dwFILE__
#include "csauto.h"     // self cleaning pointers

#ifndef CERTREQUEST_CLIENT_CERTREQ	// moved to xelib.h
#define SECURITY_WIN32
#include <security.h>	// for EXTENDED_NAME_FORMAT
#define DWORDROUND(cb)	(((cb) + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1))
#define POINTERROUND(cb) (((cb) + (sizeof(VOID *) - 1)) & ~(sizeof(VOID *) - 1))
#endif

#define myCASIGN_KEY_USAGE \
	    (CERT_KEY_CERT_SIGN_KEY_USAGE | \
	     CERT_CRL_SIGN_KEY_USAGE)

// "flags" property values for DS CA object
// CN=CAName,CN=Certification Authorities
#define CA_SERVER_TYPE_UNKNOWN          0x0
#define CA_SERVER_TYPE_SERVER           0x1
#define CA_SERVER_TYPE_ADVANCEDSERVER   0x2

#ifndef CSM_GLOBALDESTRUCTOR		// if old xelib.h
# define CSM_GLOBALDESTRUCTOR	0x200
#endif

#define _16BITMASK			((1 << 16) - 1)
#define MAKECANAMEID(iCert, iKey)	(((iKey) << 16) | (iCert))
#define CANAMEIDTOIKEY(NameId)		((NameId) >> 16)
#define CANAMEIDTOICERT(NameId)		(_16BITMASK & (NameId))


typedef struct _CAINFO
{
    DWORD   cbSize;
    ENUM_CATYPES CAType;
    DWORD   cCASignatureCerts;
    DWORD   cCAExchangeCerts;
    DWORD   cExitModules;
    LONG    lPropIdMax;
    LONG    lRoleSeparationEnabled;
    DWORD   cKRACertUsedCount;
    DWORD   cKRACertCount;
    DWORD   fAdvancedServer;   
} CAINFO;


#define cwcHRESULTSTRING	40
#define cwcDWORDSPRINTF		(1 + 10 + 1)	// DWORD "%d" w/sign & '\0'

#define GETCERT_CAXCHGCERT	   TRUE
#define GETCERT_CASIGCERT	   FALSE
#define GETCERT_CHAIN		   0x80000000	// internal use only
#define GETCERT_CRLS		   0x00800000	// internal use only

#define GETCERT_FILEVERSION	   0x66696c65	// "file"
#define GETCERT_PRODUCTVERSION	   0x70726f64	// "prod"
#define GETCERT_POLICYVERSION	   0x706f6c69	// "poli"
#define GETCERT_CANAME		   0x6e616d65	// "name"

#define GETCERT_SANITIZEDCANAME	   0x73616e69	// "sani"
#define GETCERT_SHAREDFOLDER	   0x73686172	// "shar"
#define GETCERT_ERRORTEXT1	   0x65727231	// "err1"
#define GETCERT_ERRORTEXT2	   0x65727232	// "err2"

#define GETCERT_CATYPE		   0x74797065	// "type"
#define GETCERT_CAINFO		   0x696e666f	// "info"
#define GETCERT_PARENTCONFIG	   0x70617265	// "pare"

#define GETCERT_CURRENTCRL	   0x6363726c	// "ccrl"
#define GETCERT_CACERTBYINDEX	   0x63740000	// "ct??" + 0 based index
#define GETCERT_CACERTSTATEBYINDEX 0x73740000	// "st??" + 0 based index
#define GETCERT_CRLBYINDEX	   0x636c0000	// "cl??" + 0 based index
#define GETCERT_CRLSTATEBYINDEX	   0x736c0000	// "sl??" + 0 based index
#define GETCERT_EXITVERSIONBYINDEX 0x65780000	// "ex??" + 0 based index
#define GETCERT_BYINDEXMASK	   0x7f7f0000	// mask for fetch by index
#define GETCERT_INDEXVALUEMASK	   0x0000ffff	// mask for index extraction

#define GETCERT_VERSIONMASK	   0x7f7f7f7f	// mask for above

#define CSREG_UPGRADE    0x00000001
#define CSREG_APPEND     0x00000002
#define CSREG_REPLACE    0x00000004
#define CSREG_MERGE      0x00000008

#define wszCERTENROLLSHARENAME	L"CertEnroll"
#define wszCERTENROLLSHAREPATH	L"CertSrv\\CertEnroll"

#define wszCERTCONFIGSHARENAME  L"CertConfig"


// Constants chosen to avoid DWORD overflow:

#define CVT_WEEKS	(7 * CVT_DAYS)
#define CVT_DAYS	(24 * CVT_HOURS)
#define CVT_HOURS	(60 * CVT_MINUTES)
#define CVT_MINUTES	(60 * CVT_SECONDS)
#define CVT_SECONDS	(1)
#define CVT_BASE	(1000 * 1000 * 10)


#define chLBRACKET	'['
#define chRBRACKET	']'
#define szLBRACKET	"["
#define szRBRACKET	"]"
#define wcLBRACKET	L'['
#define wcRBRACKET	L']'
#define wszLBRACKET	L"["
#define wszRBRACKET	L"]"

#define chLBRACE	'{'
#define chRBRACE	'}'
#define szLBRACE	"{"
#define szRBRACE	"}"
#define wcLBRACE	L'{'
#define wcRBRACE	L'}'
#define wszLBRACE	L"{"
#define wszRBRACE	L"}"

#define chLPAREN	'('
#define chRPAREN	')'
#define szLPAREN	"("
#define szRPAREN	")"
#define wcLPAREN	L'('
#define wcRPAREN	L')'
#define wszLPAREN	L"("
#define wszRPAREN	L")"


typedef struct _CSURLTEMPLATE
{
    DWORD  Flags;
    WCHAR *pwszURL;
} CSURLTEMPLATE;


WCHAR const *
myHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr);

WCHAR const *
myHResultToStringRaw(
    IN OUT WCHAR *awchr,
    IN HRESULT hr);

WCHAR const *
myGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString);

WCHAR const *
myGetErrorMessageText1(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const *pwszInsertionText);

WCHAR const *
myGetErrorMessageTextEx(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const * const *papwszInsertionText);

HRESULT
myJetHResult(IN HRESULT hr);

BOOL
myIsDelayLoadHResult(IN HRESULT hr);

#define CBMAX_CRYPT_HASH_LEN	20

BOOL
myCryptSignMessage(
    IN CRYPT_SIGN_MESSAGE_PARA const *pcsmp,
    IN BYTE const *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSignedBlob,   // CoTaskMem*
    OUT DWORD *pcbSignedBlob);


HRESULT
myCryptMsgGetParam(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT VOID **ppvData,
    OUT DWORD *pcbData);

BOOL
myEncodeCert(
    IN DWORD dwEncodingType,
    IN CERT_SIGNED_CONTENT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeName(
    IN DWORD dwEncodingType,
    IN CERT_NAME_INFO const *pInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyAttributes(
    IN DWORD dwEncodingType,
    IN CERT_KEY_ATTRIBUTES_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyUsage(
    IN DWORD dwEncodingType,
    IN CRYPT_BIT_BLOB const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyAuthority(
    IN DWORD dwEncodingType,
    IN CERT_AUTHORITY_KEY_ID_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN CERT_AUTHORITY_KEY_ID2_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myEncodeToBeSigned(
    DWORD dwEncodingType,
    CERT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded);

BOOL
myDecodeName(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_NAME_INFO **ppNameInfo,
    OUT DWORD *pcbNameInfo);


HRESULT
myDecodeCSPProviderAttribute(
    IN BYTE const *pbCSPEncoded,
    IN DWORD cbCSPEncoded,
    OUT CRYPT_CSP_PROVIDER **ppccp);

BOOL
myDecodeKeyGenRequest(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_KEYGEN_REQUEST_INFO **ppKeyGenRequest,
    OUT DWORD *pcbKeyGenRequest);

BOOL
myDecodeExtensions(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_EXTENSIONS **ppInfo,
    OUT DWORD *pcbInfo);

BOOL
myDecodeKeyAuthority(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID_INFO const **ppInfo,
    OUT DWORD *pcbInfo);

BOOL
myDecodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID2_INFO const **ppInfo,
    OUT DWORD *pcbInfo);

BOOL
myCertGetCertificateContextProperty(
    IN CERT_CONTEXT const *pCertContext,
    IN DWORD dwPropId,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData);

HRESULT
myCryptEncrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted);

HRESULT
myCryptDecrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted);

HRESULT
myCryptEncryptMessage(
    IN ALG_ID algId,
    IN DWORD cCertRecipient,
    IN CERT_CONTEXT const **rgCertRecipient,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OPTIONAL HCRYPTPROV hCryptProv,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted);

HRESULT
myCryptDecryptMessage(
    IN HCERTSTORE hStoreCA,
    IN BYTE const *pbEncrypted,
    IN DWORD cbEncrypted,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted);

HRESULT
myGetInnerPKCS10(
    IN HCRYPTMSG hMsg,
    IN char const *pszInnerContentObjId,
    OUT CERT_REQUEST_INFO **ppRequest);

BOOL
myDecodeNameValuePair(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CRYPT_ENROLLMENT_NAME_VALUE_PAIR **ppInfo,
    OUT DWORD *pcbInfo);

HRESULT
myEncodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myDecodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myGenerateKeys(
    IN WCHAR const *pwszContainer,
    OPTIONAL IN WCHAR const *pwszProvName,
    IN BOOL fMachineKeySet,
    IN DWORD dwKeySpec,
    IN DWORD dwProvType,
    IN DWORD dwKeySize,
    OUT HCRYPTPROV *phProv);

HRESULT
myCryptExportKey(
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hKeyExp,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey);

HRESULT
myCertGetNameString(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwType,
    OUT WCHAR **ppwszSimpleName);

#define CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT	0x00000001
#define CA_VERIFY_FLAGS_IGNORE_OFFLINE		0x00000002
#define CA_VERIFY_FLAGS_NO_REVOCATION		0x00000004
#define CA_VERIFY_FLAGS_NT_AUTH			0x00000008
#define CA_VERIFY_FLAGS_DUMP_CHAIN		0x40000000
#define CA_VERIFY_FLAGS_SAVE_CHAIN		0x80000000

HRESULT
myVerifyCertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer);

HRESULT
myVerifyCertContextEx(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN FILETIME const *pft,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer,
    OPTIONAL OUT WCHAR **ppwszzIssuancePolicies,
    OPTIONAL OUT WCHAR **ppwszzApplicationPolicies);

HRESULT
myVerifyKRACertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags);

HRESULT
myCertStrToName(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppszError);

HRESULT
myCertNameToStr(
    IN DWORD dwCertEncodingType,
    IN CERT_NAME_BLOB const *pName,
    IN DWORD dwStrType,
    OUT WCHAR **ppwszName);

HRESULT
myCryptStringToBinaryA(
    IN     LPCSTR    pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags);  // OPTIONAL

HRESULT
myCryptStringToBinary(
    IN     LPCWSTR   pwszString,
    IN     DWORD     cwcString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags);  // OPTIONAL

HRESULT
myCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPSTR       *ppszString);

HRESULT
myCryptBinaryToString(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPWSTR      *ppwszString);

HRESULT
myIsFirstSigner(
    IN CERT_NAME_BLOB const *pNameBlob,
    OUT BOOL *pfDummy);

HRESULT
myCopyKeys(
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN WCHAR const *pwszOldContainer,
    IN WCHAR const *pwszNewContainer,
    IN BOOL fOldUserKey,
    IN BOOL fNewUserKey,
    IN BOOL fForceOverWrite);

HRESULT
mySaveChainAndKeys(
    IN CERT_SIMPLE_CHAIN const *pSimpleChain,
    IN WCHAR const *pwszStore,
    IN DWORD dwStoreFlags,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    OPTIONAL OUT CERT_CONTEXT const **ppCert);

HCERTSTORE
myPFXImportCertStore(
    IN CRYPT_DATA_BLOB *ppfx,
    OPTIONAL IN WCHAR const *pwszPassword,
    IN DWORD dwFlags);

HRESULT
myPFXExportCertStore(
    IN HCERTSTORE hStore,
    OUT CRYPT_DATA_BLOB *ppfx,
    IN WCHAR const *pwszPassword,
    IN DWORD dwFlags);

HRESULT
myAddChainToMemoryStore(
    IN HCERTSTORE hMemoryStore,
    IN CERT_CONTEXT const *pCertContext);


typedef struct _RESTORECHAIN
{
    CERT_CHAIN_CONTEXT const *pChain;
    DWORD		      NameId;
} RESTORECHAIN;

HRESULT
myGetChainArrayFromStore(
    IN HCERTSTORE hStore,
    IN BOOL fCAChain,
    IN BOOL fUserStore,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    IN OUT DWORD *pcRestoreChain,
    OPTIONAL OUT RESTORECHAIN *paRestoreChain);

#ifndef CERTREQUEST_CLIENT_CERTREQ	// moved to xelib.h
HRESULT
myGetUserNameEx(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszUserName);
#endif

HRESULT
myGetComputerObjectName(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszDnsName);

HRESULT
myGetComputerNames(
    OUT WCHAR **ppwszDnsName,
    OUT WCHAR **ppwszOldName);

#ifndef CERTREQUEST_CLIENT_CERTREQ	// moved to xelib.h
HRESULT
myGetMachineDnsName(
    OUT WCHAR **ppwszDnsName);
#endif

LANGID
mySetThreadUILanguage(
    IN WORD wReserved);

BOOL
myConvertStringSecurityDescriptorToSecurityDescriptor(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PULONG SecurityDescriptorSize OPTIONAL);

BOOL
myConvertSidToStringSid(
    IN  PSID    Sid,
    OUT LPWSTR *StringSid);

BOOL
myConvertStringSidToSid(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid);


#define DH_INDENTMASK	0x000000ff
#define DH_MULTIADDRESS	0x00000100	// add address to multi-line output only
#define DH_NOADDRESS	0x00000200
#define DH_NOASCIIHEX	0x00000400
#define DH_NOTABPREFIX	0x00000800	// double space after addr if displayed

VOID
DumpHex(
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb);

DWORD
myGetDisplayLength(
    IN WCHAR const *pwsz);

LONG
myConsolePrintString(
    IN DWORD ccolMin,
    IN WCHAR const *pwszString);

BOOL
myConsolePrintfDisable(
    IN BOOL fDisable);

int __cdecl
myConsolePrintf(
    IN WCHAR const *pwszFmt,
    ...);

//+==============================
// Date/Time conversion routines:

HRESULT
myDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft);

HRESULT
myFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate);

HRESULT
myFileTimePeriodToWszTimePeriod(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT WCHAR **ppwszTimePeriod);

HRESULT
myTranslateUnlocalizedPeriodString(
    IN enum ENUM_PERIOD enumPeriod,
    OUT WCHAR const **ppwszPeriodString);

HRESULT
myGMTFileTimeToWszLocalTime(
    IN FILETIME const *pftGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime);

HRESULT
myFileTimeToWszTime(
    IN FILETIME const *pftGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszGMTTime);

HRESULT
myGMTDateToWszLocalTime(
    IN DATE const *pDateGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime);

HRESULT
myWszLocalTimeToGMTDate(
    IN WCHAR const *pwszLocalTime,
    OUT DATE *pDateGMT);

HRESULT
myWszLocalTimeToGMTFileTime(
    IN WCHAR const *pwszLocalTime,
    OUT FILETIME *pftGMT);

HRESULT
mySystemTimeToGMTSystemTime(
    IN OUT SYSTEMTIME *pSys);


enum ENUM_FORCETELETEX
{
    ENUM_TELETEX_OFF = 0,
    ENUM_TELETEX_ON = 1,
    ENUM_TELETEX_AUTO = 2,
    ENUM_TELETEX_MASK = 0xf,
    ENUM_TELETEX_UTF8 = 0x10
};


typedef struct _LLFILETIME
{
    union {
	LONGLONG ll;
	FILETIME ft;
    };
} LLFILETIME;


__inline VOID
myAddToFileTime(
    IN OUT FILETIME *pft,
    IN LONGLONG ll)
{
    LLFILETIME llft;

    llft.ft = *pft;
    llft.ll += ll;
    *pft = llft.ft;
}


__inline LONGLONG
mySubtractFileTimes(
    IN FILETIME const *pft1,
    IN FILETIME const *pft2)
{
    LLFILETIME llft1;
    LLFILETIME llft2;

    llft1.ft = *pft1;
    llft2.ft = *pft2;
    return(llft1.ll - llft2.ll);
}


HRESULT
myMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod);

HRESULT
myTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount);

HRESULT
myDupString(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut);

HRESULT
myDupStringA(
    IN CHAR const *pszIn,
    OUT CHAR **ppszOut);

HRESULT
myUnmarshalVariant(
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue);

HRESULT
myUnmarshalFormattedVariant(
    IN DWORD Flags,
    IN DWORD PropId,
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue);

HRESULT
myMarshalVariant(
    IN VARIANT const *pvarPropertyValue,
    IN DWORD PropType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop);

// Output values for myCheck7f's *pState parameter:

#define CHECK7F_NONE			0x0000
#define CHECK7F_OTHER			0x0001
#define CHECK7F_ISSUER			0x0002
#define CHECK7F_ISSUER_RDN		0x0003
#define CHECK7F_ISSUER_RDN_ATTRIBUTE	0x0004
#define CHECK7F_ISSUER_RDN_STRING	0x0005
#define CHECK7F_SUBJECT			0x0006
#define CHECK7F_SUBJECT_RDN		0x0007
#define CHECK7F_SUBJECT_RDN_ATTRIBUTE	0x0008
#define CHECK7F_SUBJECT_RDN_STRING	0x0009
#define CHECK7F_EXTENSIONS		0x000a
#define CHECK7F_EXTENSION_ARRAY		0x000b
#define CHECK7F_EXTENSION		0x000c
#define CHECK7F_EXTENSION_VALUE		0x000d
#define CHECK7F_EXTENSION_VALUE_RAW	0x000e
#define CHECK7F_COUNT			0x000f

HRESULT
myCheck7f(
    IN const BYTE *pbCert,
    IN DWORD cbCert,
    IN BOOL fVerbose,
    OUT DWORD *pState,
    OPTIONAL OUT DWORD *pIndex1,
    OPTIONAL OUT DWORD *pIndex2,
    OPTIONAL IN OUT DWORD *pcwcField,
    OPTIONAL OUT WCHAR *pwszField,
    OPTIONAL IN OUT DWORD *pcwcObjectId,
    OPTIONAL OUT WCHAR *pwszObjectId,
    OPTIONAL OUT WCHAR const **ppwszObjectIdDescription); // Static: don't free!

HRESULT
myVerifyObjIdA(
    IN char const *pszObjId);

HRESULT
myVerifyObjId(
    IN WCHAR const *pwszObjId);

WCHAR const *
myGetOIDNameA(
    IN char const *pszObjId);

WCHAR const *
myGetOIDName(
    IN WCHAR const *pwszObjId);

BOOL
myIsCharSanitized(
    IN WCHAR wc);

HRESULT
mySanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

HRESULT
myRevertSanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

HRESULT
mySanitizedNameToDSName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

HRESULT
myDecodeCMCRegInfo(
    IN BYTE const *pbOctet,
    IN DWORD cbOctet,
    OUT WCHAR **ppwszOut);

HRESULT
mySplitConfigString(
    IN WCHAR const *pwszConfig,
    OUT WCHAR **ppwszServer,
    OUT WCHAR **ppwszAuthority);

HRESULT
myCLSIDToWsz(
    IN CLSID const *pclsid,
    OUT WCHAR **ppwsz);

interface ICertAdminD2;
interface ICertRequestD2;

HRESULT
myOpenAdminDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertAdminD2 **ppICertAdminD);

HRESULT
myOpenRequestDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OPTIONAL OUT BOOL *pfNewConnection,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertRequestD2 **ppICertRequestD);

VOID
myCloseDComConnection(
    OPTIONAL IN OUT IUnknown **ppUnknown,
    OPTIONAL IN OUT WCHAR **ppwszServerName);

HRESULT
myPingCertSrv(
    IN WCHAR const *pwszCAName,
    OPTIONAL IN WCHAR const *pwszMachineName,
    OPTIONAL OUT WCHAR **ppwszzCANames,
    OPTIONAL OUT WCHAR **ppwszSharedFolder,
    OPTIONAL OUT CAINFO **ppCAInfo,
    OPTIONAL OUT DWORD *pdwServerVersion,
    OPTIONAL OUT WCHAR **ppwszCADnsName);

DWORD
myGetCertNameProperty(
    IN CERT_NAME_INFO const *pNameInfo,
    IN char const *pszObjId,
    OUT WCHAR const **ppwszName);

HRESULT
mySetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszFileName);

HRESULT
myGetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    OUT WCHAR **ppwszFileName);


#define CSRH_CASIGCERT	0
#define CSRH_CAXCHGCERT	1
#define CSRH_CAKRACERT	2

HRESULT
mySetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    IN CERT_CONTEXT const *pCert);

HRESULT
myGetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OUT BYTE **ppbHash,
    OUT DWORD *pcbHash);

HRESULT
myGetCARegHashCount(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    OUT DWORD *pCount);

HRESULT myShrinkCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index);

HRESULT
myGetNameId(
    IN CERT_CONTEXT const *pCACert,
    OUT DWORD *pdwNameId);

HRESULT
myFindCACertByHash(
    IN HCERTSTORE hStore,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT OPTIONAL DWORD *pdwNameId,
    OUT CERT_CONTEXT const **ppCACert);

HRESULT
myFindCACertByHashIndex(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OPTIONAL OUT DWORD *pdwNameId,
    OUT CERT_CONTEXT const **ppCACert);

BOOL
myAreBlobsSame(
    IN BYTE const *pbData1,
    IN DWORD cbData1,
    IN BYTE const *pbData2,
    IN DWORD cbData2);

BOOL
myAreSerialNumberBlobsSame(
    IN CRYPT_INTEGER_BLOB const *pBlob1,
    IN CRYPT_INTEGER_BLOB const *pBlob2);

VOID
myGenerateGuidSerialNumber(
    OUT GUID *pguidSerialNumber);


#define CSRF_INSTALLCACERT	0x00000000
#define CSRF_RENEWCACERT	0x00000001
#define CSRF_NEWKEYS		0x00000002
#define CSRF_UNATTENDED		0x40000000
#define CSRF_OVERWRITE		0x80000000

HRESULT
CertServerRequestCACertificateAndComplete(
    IN HINSTANCE             hInstance,
    IN HWND                  hwnd,
    IN DWORD                 Flags,
    IN WCHAR const          *pwszCAName,
    OPTIONAL IN WCHAR const *pwszParentMachine,
    OPTIONAL IN WCHAR const *pwszParentCA,
    OPTIONAL IN WCHAR const *pwszCAChainFile,
    OPTIONAL OUT WCHAR     **ppwszRequestFile);

HRESULT
myBuildPathAndExt(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile,
    OPTIONAL IN WCHAR const *pwszExt,
    OUT WCHAR **ppwszPath);

HRESULT
myCreateBackupDir(
    IN WCHAR const *pwszDir,
    IN BOOL fForceOverWrite);

typedef struct _DBBACKUPPROGRESS
{
    DWORD dwDBPercentComplete;
    DWORD dwLogPercentComplete;
    DWORD dwTruncateLogPercentComplete;
} DBBACKUPPROGRESS;

#define CDBBACKUP_INCREMENTAL	0x00000001  // else full backup
#define CDBBACKUP_KEEPOLDLOGS	0x00000002  // else truncate logs
#define CDBBACKUP_OVERWRITE	    0x00000100  // for myBackupDB only
#define CDBBACKUP_VERIFYONLY	0x00000200  // for myBackupDB and myRestoreDB

#define CDBBACKUP_BACKUPVALID	(CDBBACKUP_INCREMENTAL | \
				 CDBBACKUP_KEEPOLDLOGS | \
				 CDBBACKUP_OVERWRITE | \
                 CDBBACKUP_VERIFYONLY)

#define CDBBACKUP_RESTOREVALID	(CDBBACKUP_INCREMENTAL | \
				 CDBBACKUP_KEEPOLDLOGS | \
				 CDBBACKUP_VERIFYONLY)

HRESULT
myBackupDB(
    OPTIONAL IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp);

HRESULT
myRestoreDB(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszBackupDir,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp);

HRESULT
myDeleteDBFilesInDir(
    IN WCHAR const *pwszDir);

HRESULT
myDoDBFilesExist(
    IN WCHAR const *pwszSanitizedName,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse);

HRESULT
myDoDBFilesExistInDir(
    IN WCHAR const *pwszDir,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse);

HRESULT
myIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal);

HRESULT
myIsConfigLocal2(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OUT BOOL *pfLocal);

HRESULT
myGetConfig(
    IN DWORD dwUIFlag,
    OUT WCHAR **ppwszConfig);

HRESULT
myConvertLocalPathToUNC(
    OPTIONAL IN WCHAR const *pwszServer,
    IN WCHAR const *pwszFile,
    OUT WCHAR **ppwszFileUNC);

HRESULT
myConvertUNCPathToLocal(
    IN WCHAR const *pwszUNCPath,
    OUT WCHAR **ppwszLocalPath);

ULONG
myLocalPathwcslen(
    IN WCHAR const *pwsz);

VOID
myLocalPathwcscpy(
    OUT WCHAR *pwszOut,
    IN WCHAR const *pwszIn);

HRESULT
myCertServerExportPFX(
    IN WCHAR const *pwszCAName,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszPassword,
    IN BOOL fForceOverWrite,
    IN BOOL fMustExportPrivateKeys,
    OPTIONAL OUT WCHAR **ppwszPFXFile);

HRESULT
myCertServerImportPFX(
    IN WCHAR const *pwszBackupDirOrPFXFile,
    IN WCHAR const *pwszPassword,
    IN BOOL fForceOverWrite,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    OPTIONAL OUT WCHAR **ppwszPFXFile,
    OPTIONAL OUT CERT_CONTEXT const **ppSavedLeafCert);

HRESULT
myDeleteGuidKeys(
    IN HCERTSTORE hStorePFX,
    IN BOOL fMachineKeySet);

#define IsHrSkipPrivateKey(hresult) \
    (NTE_BAD_KEY_STATE == (hresult) || \
     CRYPT_E_NO_KEY_PROPERTY == (hresult) || \
     E_HANDLE == (hresult))

HRESULT
myCryptExportPrivateKey(
    IN HCRYPTKEY hKey,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey);

HRESULT
myCertGetKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    OUT CRYPT_KEY_PROV_INFO **ppkpi);

HRESULT
myRepairCertKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    IN BOOL fForceMachineKey,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi);

HRESULT
myVerifyPublicKey(
    IN OPTIONAL CERT_CONTEXT const *pCert,
    IN BOOL fV1Cert,
    IN OPTIONAL CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pSubjectPublicKeyInfo,
    OPTIONAL OUT BOOL *pfMatchingKey);

HRESULT
myValidateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN BOOL fV1Cert,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO *pkpi);

BOOL
myCertComparePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN BOOL fV1Cert,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKey1,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKey2);

BOOL
myIsDirectory(
    IN WCHAR const *pwszDirectoryPath);

BOOL
myIsDirEmpty(
    IN WCHAR const *pwszDir);

HRESULT
myIsDirWriteable(
    IN WCHAR const *pwszPath,
    IN BOOL fFilePath);

BOOL
myIsFileInUse(
    IN WCHAR const *pwszFile);

__inline BOOL
myDoesFileExist(
    IN WCHAR const *pwszFile)
{
    // Allow Ansi subdirectory builds, use GetFileAttributesW

    return(-1 != GetFileAttributesW(pwszFile));
}



WCHAR const *
myLoadResourceString(
    IN DWORD ResourceId);

VOID
myFreeResourceStrings(
    IN char const *pszModule);

HRESULT
myDoesDSExist(
    IN BOOL fRetry);


HRESULT
myGetConfigFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN  BOOL                       fUseDS,
    IN  BOOL                       fCountOnly,
    OUT DWORD                     *pdwCACount,
    OUT CRYPTUI_CA_CONTEXT const **ppCAContext);

HRESULT
myGetConfigStringFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN  BOOL                       fUseDS,
    OUT WCHAR                    **ppwszConfig);

HRESULT
myDeleteCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN BOOL                  fAbsolutePath);

HRESULT
myDeleteCertRegValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName);

HRESULT
myDeleteCertRegKeyEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel);

HRESULT
myDeleteCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3);

HRESULT
myCreateCertRegKeyEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3);

HRESULT
myCreateCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3);

HRESULT
mySetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath);

HRESULT
mySetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath);

HRESULT
myGetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,		// free using LocalFree
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType);

HRESULT
myGetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType);

HRESULT
mySetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszzValue);

HRESULT
myGetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    OUT WCHAR               **ppwszzValue);

HRESULT
mySetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    IN WCHAR const          *pwszValue);

HRESULT
mySetCertRegStrValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszValue);

HRESULT
mySetCertRegMultiStrValueEx(
    IN DWORD                 dwFlags, //CSREG_UPGRADE | CSREG_APPEND
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszzValue);

HRESULT
mySetAbsRegMultiStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszzValue);

HRESULT
mySetAbsRegStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszValue);

HRESULT
mySetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    IN DWORD const           dwValue);

HRESULT
mySetCertRegDWValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValue);

HRESULT
myGetCertRegBinaryValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbValue);

HRESULT
myGetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT WCHAR               **ppwszValue);	// free using LocalFree


HRESULT
myGetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT DWORD               *pdwValue);

HRESULT
myCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr);

HRESULT
myMoveCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr);

HRESULT
myMoveOrCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr,
    IN BOOL                  fMove);

HRESULT
SetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    IN const DWORD  dwFlag,
    IN const BOOL   fComplete);

HRESULT
GetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *pdwStatus);

HRESULT
myGetCASerialNumber(
    IN  WCHAR const *pwszSanitizedCAName,
    OUT BYTE      **ppbSerialNumber,
    OUT DWORD      *cbSerialNumber);

HRESULT
myGetColumnDisplayName(
    IN  WCHAR const  *pwszColumnName,
    OUT WCHAR const **ppwszDisplayName);

HRESULT
myGetColumnName(
    IN  DWORD         Index,
    IN  BOOL          fDisplayName,
    OUT WCHAR const **ppwszName);

VOID
myFreeColumnDisplayNames(VOID);


typedef struct _CAPROP
{
    LONG         lPropId;
    LONG         lPropFlags;
    WCHAR const *pwszDisplayName;
} CAPROP;

HRESULT
myCAPropGetDisplayName(
    IN  LONG          lPropId,
    OUT WCHAR const **ppwszDisplayName);

HRESULT
myCAPropInfoUnmarshal(
    IN OUT CAPROP *pCAPropInfo,
    IN LONG cCAPropInfo,
    IN DWORD cbCAPropInfo);

HRESULT
myCAPropInfoLookup(
    IN CAPROP const *pCAPropInfo,
    IN LONG cCAPropInfo,
    IN LONG lPropId,
    OUT CAPROP const **ppcap);


// active modules
HRESULT
myGetActiveModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OUT CLSID *pclsidModule);

// active manage module
HRESULT
myGetActiveManageModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OUT LPOLESTR *ppwszProgIdManageModule,   // CoTaskMem*
    OUT CLSID *pclsidManageModule);

HRESULT
myFormConfigString(
    IN WCHAR const  *pwszServer,
    IN WCHAR const  *pwszCAName,
    OUT WCHAR      **ppwszConfig);

HRESULT
myLoadRCString(
    IN HINSTANCE hInstance,
    IN int       iRCId,
    OUT WCHAR  **ppwsz);


#define RORKF_FULLPATH		0x00000001
#define RORKF_CREATESUBKEYS	0x00000002
#define RORKF_USERKEY		0x00000004

HRESULT
myRegOpenRelativeKey(
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszRegName,
    IN DWORD Flags,		// RORKF_*
    OUT WCHAR **ppwszPath,
    OUT OPTIONAL WCHAR **ppwszName,
    OUT OPTIONAL HKEY *phkey);

HRESULT
myFixupRCFilterString(
    IN WCHAR *pwszFilter);


// NOTE: disappears in release builds
#define ASSERTVALIDCATYPE(__CATYPE__) \
   CSASSERT( (\
     ENUM_ENTERPRISE_SUBCA == (__CATYPE__) || \
     ENUM_ENTERPRISE_ROOTCA == (__CATYPE__) || \
     ENUM_UNKNOWN_CA == (__CATYPE__) || \
     ENUM_STANDALONE_SUBCA == (__CATYPE__) || \
     ENUM_STANDALONE_ROOTCA == (__CATYPE__) ))


__inline BOOL
IsEnterpriseCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_ENTERPRISE_SUBCA == CAType || ENUM_ENTERPRISE_ROOTCA == CAType);
}

__inline BOOL
IsStandaloneCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_STANDALONE_SUBCA == CAType || ENUM_STANDALONE_ROOTCA == CAType);
}

__inline BOOL
IsRootCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_STANDALONE_ROOTCA == CAType || ENUM_ENTERPRISE_ROOTCA == CAType);
}

__inline BOOL
IsSubordinateCA(
    IN ENUM_CATYPES CAType)
{
    // assert we're a valid type
    ASSERTVALIDCATYPE(CAType);

    return(ENUM_ENTERPRISE_SUBCA == CAType || ENUM_STANDALONE_SUBCA == CAType);
}



HRESULT
myEnablePrivilege(
    IN LPCTSTR szPrivilege,
    IN BOOL fEnable);


HRESULT
myDeleteFilePattern(
    IN WCHAR const *pwszDir,
    OPTIONAL IN WCHAR const *pwszPattern,	// defaults to L"*.*"
    IN BOOL fRecurse);

HRESULT
myRemoveFilesAndDirectory(
    IN WCHAR const *pwszPath,
    IN BOOL fRecurse);

HRESULT
myCreateNestedDirectories(
    WCHAR const *pwszDirectory);


#define VFF_CREATEVROOTS	0x00000001
#define VFF_CREATEFILESHARES	0x00000002
#define VFF_DELETEVROOTS	0x00000004
#define VFF_DELETEFILESHARES	0x00000008

#define VFF_SETREGFLAGFIRST	0x00000010
#define VFF_CHECKREGFLAGFIRST	0x00000020
#define VFF_CLEARREGFLAGFIRST	0x00000040

#define VFF_CLEARREGFLAGIFOK	0x00000100
#define VFF_SETRUNONCEIFERROR	0x00000200


#define VFCSEC_TIMEOUT	5	// Recommended timeout in seconds

#define VFD_NOACTION		0
#define VFD_CREATED		1
#define VFD_DELETED		2
#define VFD_EXISTS		3
#define VFD_NOTFOUND		4
#define VFD_CREATEERROR		5
#define VFD_DELETEERROR		6
#define VFD_NOTSUPPORTED	7

HRESULT
myModifyVirtualRootsAndFileShares(
    IN DWORD Flags,		// VFF_*: Create/Delete VRoots and/or Shares
    IN ENUM_CATYPES CAType,	// CA Type
    IN BOOL fAsynchronous,      // block during call?
    IN DWORD csecTimeOut,	// 0 implies synchronous call
    OPTIONAL OUT DWORD *pVRootDisposition,  // VFD_*
    OPTIONAL OUT DWORD *pShareDisposition); // VFD_*

HRESULT
myAddShare(
    IN LPCWSTR szShareName,
    IN LPCWSTR szShareDescr,
    IN LPCWSTR szSharePath,
    IN BOOL fOverwrite,
    OPTIONAL OUT BOOL *pfCreated);


typedef struct {
    HINSTANCE hInstance;         // instance handle
    HWND      hDlg;              // dialog handle
    HWND      hwndComputerEdit;  // control handle of computer edit
    HWND      hwndCAList;  // control handle of ca list control
    WNDPROC   pfnUICASelectionComputerWndProcs; // computer edit win procs

    // info on selected CA
    ENUM_CATYPES CAType;
    bool fWebProxySetup;

} CERTSRVUICASELECTION;

LRESULT CALLBACK
myUICASelectionComputerEditFilterHook(
    HWND hwndComputer,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam);

#define   UNC_PATH    1
#define   LOCAL_PATH  2

BOOL
myIsFullPath(
    IN WCHAR const *pwszPath,
    OUT DWORD      *pdwFlag);

HRESULT
myUICAHandleCABrowseButton(
    CERTSRVUICASELECTION *pData,
    IN BOOL               fUseDS,
    OPTIONAL IN int       idsPickerTitle,
    OPTIONAL IN int       idsPickerSubTitle,
    OPTIONAL OUT WCHAR   **ppwszSharedFolder);

HRESULT
myUICAHandleCAListDropdown(
    IN int                       iNotification,
    IN OUT CERTSRVUICASELECTION *pData,
    IN OUT BOOL                 *pfComputerChange);

HRESULT
myUICASelectionValidation(
    CERTSRVUICASELECTION *pData,
    BOOL                 *pfValidate);

HRESULT
myInitUICASelectionControls(
    IN OUT CERTSRVUICASELECTION *pUICASelection,
    IN HINSTANCE                 hInstance,
    IN HWND                      hDlg,
    IN HWND                      hwndBrowseButton,
    IN HWND                      hwndComputerEdit,
    IN HWND                      hwndCAList,
    IN BOOL                      fDSCA,
    OUT BOOL			*pfCAsExist);

char PrintableChar(char ch);

HRESULT
myGetMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR **ppwszProfileName,
    OUT WCHAR **ppwszLogonName,
    OUT WCHAR **ppwszPassword);

HRESULT
mySaveMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR const *pwszProfileName,
    OUT WCHAR const *pwszLogonName,
    OUT WCHAR const *pwszPassword);


#define cwcFILENAMESUFFIXMAX		20
#define cwcSUFFIXMAX	(1 + 5 + 1)	// five decimal digits plus parentheses

#define wszFCSAPARM_SERVERDNSNAME		L"%1"
#define wszFCSAPARM_SERVERSHORTNAME		L"%2"
#define wszFCSAPARM_SANITIZEDCANAME		L"%3"
#define wszFCSAPARM_CERTFILENAMESUFFIX		L"%4"
#define wszFCSAPARM_DOMAINDN			L"%5"
#define wszFCSAPARM_CONFIGDN			L"%6"
#define wszFCSAPARM_SANITIZEDCANAMEHASH		L"%7"
#define wszFCSAPARM_CRLFILENAMESUFFIX		L"%8"
#define wszFCSAPARM_CRLDELTAFILENAMESUFFIX	L"%9"
#define wszFCSAPARM_DSCRLATTRIBUTE		L"%10"
#define wszFCSAPARM_DSCACERTATTRIBUTE		L"%11"
#define wszFCSAPARM_DSUSERCERTATTRIBUTE		L"%12"
#define wszFCSAPARM_DSKRACERTATTRIBUTE		L"%13"
#define wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE	L"%14"


HRESULT
myFormatCertsrvStringArray(
    IN BOOL fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7,
    IN DWORD   iCert_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6,
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut);

HRESULT
myUncanonicalizeURLParm(
    IN WCHAR const *pwszParmIn,
    OUT WCHAR **ppwszParmOut);

HRESULT
myAllocIndexedName(
    IN WCHAR const *pwszName,
    IN DWORD Index,
    OUT WCHAR **ppwszIndexedName);

HRESULT
myUIGetWindowText(
    IN HWND     hwndCtrl,
    OUT WCHAR **ppwszText);

HRESULT
myGetSaveFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

HRESULT
myGetOpenFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

HRESULT
myGetSaveFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

HRESULT
myGetOpenFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags, //see OPENFILENAME Flags
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile);

int
myWtoI(
    IN WCHAR const *pwszDigitString,
    OUT BOOL *pfValid);

HRESULT
myFormCertRegPath(
    IN  WCHAR const *pwszName1,
    IN  WCHAR const *pwszName2,
    IN  WCHAR const *pwszName3,
    IN  BOOL         fConfigLevel,  // from CertSrv if FALSE
    OUT WCHAR      **ppwszPath);

HRESULT
myGetEnvString(
    OUT WCHAR **ppwszOut,
    IN  WCHAR const *pwszVariable);


typedef HRESULT (FNMYINFGETEXTENSION)(
    IN  HINF hInf,
    OUT CERT_EXTENSION *pext);

FNMYINFGETEXTENSION myInfGetPolicyConstraintsExtension;
FNMYINFGETEXTENSION myInfGetPolicyMappingExtension;
FNMYINFGETEXTENSION myInfGetPolicyStatementExtension;
FNMYINFGETEXTENSION myInfGetApplicationPolicyConstraintsExtension;
FNMYINFGETEXTENSION myInfGetApplicationPolicyMappingExtension;
FNMYINFGETEXTENSION myInfGetApplicationPolicyStatementExtension;
FNMYINFGETEXTENSION myInfGetNameConstraintsExtension;
FNMYINFGETEXTENSION myInfGetEnhancedKeyUsageExtension;
FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtension;
FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtensionOrDefault;
FNMYINFGETEXTENSION myInfGetCrossCertDistributionPointsExtension;

WCHAR *
myInfGetError();

VOID
myInfClearError();

HRESULT
myInfOpenFile(
    OPTIONAL IN WCHAR const *pwszfnPolicy,
    OUT HINF *phInf,
    OUT DWORD *pErrorLine);

VOID
myInfCloseFile(
    IN HINF hInf);

HRESULT
myInfGetCRLDistributionPoints(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz);

HRESULT
myInfGetAuthorityInformationAccess(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz);

HRESULT
myInfGetEnhancedKeyUsage(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz);

HRESULT
myInfGetValidityPeriod(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *pwszValidityPeriodCount,
    OPTIONAL IN WCHAR const *pwszValidityPeriodString,
    OUT DWORD *pdwValidityPeriodCount,
    OUT ENUM_PERIOD *penumValidityPeriod,
    OPTIONAL OUT BOOL *pfSwap);

HRESULT
myinfGetCRLPublicationParams(
   IN HINF hInf,
   IN LPCWSTR szInfSection_CRLPeriod,
   IN LPCWSTR szInfSection_CRLCount,
   OUT LPWSTR* ppwszCRLPeriod, 
   OUT DWORD* pdwCRLCount);

HRESULT
myInfGetKeyLength(
    IN HINF hInf,
    OUT DWORD *pdwKeyLength);

HRESULT
myInfParseBooleanValue(
    IN WCHAR const *pwszValue,
    OUT BOOL *pfValue);

HRESULT
myInfGetNumericKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    OUT DWORD *pdwValue);

HRESULT
myInfGetBooleanValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN BOOL fIgnoreMissingKey,
    OUT BOOL *pfValue);

HRESULT
myInfGetKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    OUT WCHAR **ppwszValue);

HRESULT
myInfGetKeyList(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz);


typedef struct _INFVALUES
{
    WCHAR *pwszKey;
    DWORD cValues;
    WCHAR **rgpwszValues;
} INFVALUES;

HRESULT
myInfGetSectionValues(
    IN  HINF hInf,
    IN  WCHAR const *pwszSection,
    OUT DWORD *pcInfValues,
    OUT INFVALUES **prgInfValues);

VOID
myInfFreeSectionValues(
    IN DWORD cInfValues,
    IN OUT INFVALUES *rgInfValues);

HRESULT
myInfGetRequestAttributes(
    IN HINF hInf,
    OUT DWORD *pcAttribute,
    OUT CRYPT_ATTR_BLOB **ppaAttribute,
    OUT WCHAR **ppwszTemplateName);

VOID
myInfFreeRequestAttributes(
    IN DWORD cAttribute,
    IN OUT CRYPT_ATTR_BLOB *paAttribute);

HRESULT
myBuildOSVersionAttribute(
    OUT BYTE **ppbVersion,
    OUT DWORD *pcbVersion);

HRESULT
myBuildCertTypeExtension(
    IN WCHAR const *pwszCertType,
    OUT CERT_EXTENSION *pExt);

HRESULT
myParseNextAttribute(
    IN OUT WCHAR **ppwszBuf,
    IN BOOL fURL,
    OUT WCHAR const **ppwszName,
    OUT WCHAR const **ppwszValue);

#define CUCS_MYSTORE		0x00000001
#define CUCS_CASTORE		0x00000002
#define CUCS_KRASTORE		0x00000004
#define CUCS_ROOTSTORE		0x00000008

#define CUCS_MACHINESTORE	0x00010000
#define CUCS_USERSTORE		0x00020000
#define CUCS_DSSTORE		0x00040000

#define CUCS_ARCHIVED		0x10000000
#define CUCS_USAGEREQUIRED      0x20000000
#define CUCS_SILENT             0x40000000
#define CUCS_PRIVATEKEYREQUIRED 0x80000000

HRESULT
myGetCertificateFromPicker(
    OPTIONAL IN HINSTANCE           hInstance,
    OPTIONAL IN HWND                hwndParent,
    OPTIONAL IN int                 idTitle,
    OPTIONAL IN int                 idSubTitle,
    IN DWORD                        dwFlags,	// CUCS_*
    OPTIONAL IN WCHAR const        *pwszCommonName,
    OPTIONAL IN DWORD               cStore,
    OPTIONAL IN HCERTSTORE         *rghStore,
    IN DWORD		            cpszObjId,
    OPTIONAL IN CHAR const * const *apszObjId,
    OUT CERT_CONTEXT const        **ppCert);

HRESULT
myGetKRACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fUseDS,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert);

HRESULT
myGetERACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert);

HRESULT
myMakeSerialBstr(
    IN WCHAR const *pwszSerialNumber,
    OUT BSTR *pstrSerialNumber);

HRESULT
myNameBlobMatch(
    IN CERT_NAME_BLOB const *pSubject,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OUT BOOL *pfMatch);

HRESULT
mySerialNumberMatch(
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch);

HRESULT
myCertHashMatch(
    IN CERT_CONTEXT const *pCert,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch);

HRESULT
myCertMatch(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch);

HRESULT
myCRLHashMatch(
    IN CRL_CONTEXT const *pCRL,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch);

HRESULT
myCRLMatch(
    IN CRL_CONTEXT const *pCRL,
    IN WCHAR const *pwszCRLName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch);

HRESULT
myCTLMatch(
    IN CTL_CONTEXT const *pCTL,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch);

HRESULT
myLoadPrivateKey(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD dwFlags,		// CUCS_*
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv);

HRESULT
myLoadPrivateKeyFromCertStores(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD cStore,
    IN HCERTSTORE *rghStore,
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv);

HRESULT
myOpenCertStores(
    IN DWORD dwFlags,		// CUCS_*
    OUT DWORD *pcStore,
    OUT HCERTSTORE **prghStore);

VOID
myCloseCertStores(
    IN DWORD cStore,
    IN HCERTSTORE *rghStore);


#define DECF_FORCEOVERWRITE		0x00000100

HRESULT
DecodeFileW(
    IN WCHAR const *pwszfn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN DWORD Flags);

HRESULT
EncodeToFileW(
    IN WCHAR const *pwszfn,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags);

HRESULT
DecodeCertString(
    IN BSTR const bstrIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
EncodeCertString(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT BSTR *pbstrOut);

HRESULT
WszToMultiByteIntegerBuf(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE const *pbOut);

HRESULT
WszToMultiByteInteger(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    OUT DWORD *pcbOut,
    OUT BYTE **ppbOut);

HRESULT
myGetSecurityDescriptorDacl(
    IN PSECURITY_DESCRIPTOR   pSD,
    OUT PACL                 *ppDacl); // no free

HRESULT 
myRegValueToVariant(
    IN DWORD dwType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pVar);

HRESULT
myVariantToRegValue(
    IN VARIANT const *pvarPropertyValue,
    OUT DWORD *pdwType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop);

// are we the Whistler version?
BOOL IsWhistler(VOID);

// should we run advanced functionality?
BOOL FIsAdvancedServer(VOID);

// should we be running at all?
BOOL FIsServer(VOID);

HRESULT
myAddLogSourceToRegistry(
    IN LPWSTR   pwszMsgDLL,
    IN LPWSTR   pwszApp);


#define LOCAL_FREE(ptr) \
    if(NULL != ptr) \
        LocalFree(ptr)

inline bool EmptyString(LPCWSTR pwszString) 
{
    return((NULL == pwszString || L'\0' == *pwszString)? true : false);
}

HRESULT
myOIDHashOIDToString(
    IN WCHAR const *pwszOID,
    OUT WCHAR **ppwsz);

LPCWSTR
myCAGetDN(
    IN HCAINFO hCAInfo);

HRESULT IsCurrentUserBuiltinAdmin(OUT bool* pfIsMember);

HRESULT
SetRegistryLocalPathString(
    IN HKEY hkey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszUNCPath);

HRESULT
LocalMachineIsDomainMember(OUT bool* fIsDomainMember);

HRESULT ComputeMAC(
    LPCWSTR pcwsFileName,
    LPWSTR* ppwszMAC);

HRESULT CertNameToHashString(
    const CERT_NAME_BLOB *pCertName, 
    LPWSTR* ppwszHash);

using namespace CertSrv;

#endif // __CERTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certsrv2.h ===
#endif // _CERTSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certsrv0.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       CertSrv.h
//  Contents:   Main Certificate Server header
//              Also includes .h files for the COM interfaces
//
//----------------------------------------------------------------------------

#if !defined( _CERTSRV_H_ )
#define _CERTSRV_H_

#include <certadm.h>
#include <certbcli.h>
#include <certcli.h>
#include <certenc.h>
#include <certexit.h>
#include <certif.h>
#include <certpol.h>
#include <certmod.h>
#include <certview.h>

#ifndef DBG_CERTSRV
# if defined(_DEBUG)
#  define DBG_CERTSRV     1
# elif defined(DBG)
#  define DBG_CERTSRV     DBG
# else
#  define DBG_CERTSRV     0
# endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\certtype.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certtype.h
//
// Contents:    Declaration of CCertTypeInfo
//
// History:     16-dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "cainfop.h"
#include <certca.h>
#include <gpedit.h>
#include <userenv.h>


//ACLs for templates
#define USER_GROUP_SD L"O:%1-512G:%1-512D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-513)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define ADMIN_GROUP_SD L"O:%1-512G:%1-512D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define MACHINE_GROUP_SD L"O:%1-512G:%1-512D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-515)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define DOMAIN_CONTROLLERS_GROUP_SD L"O:%1-512G:%1-512D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;S-1-5-9)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define IPSEC_GROUP_SD L"O:%1-512G:%1-512D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-515)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"

#define V2_DOMAIN_CONTROLLERS_GROUP_SD L"O:%1-512G:%1-512D:P(A;;RPLCLORC;;;AU)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-512)(A;;CCDCLCSWRPWPDTLOSDRCWDWO;;;%1-519)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_AUTOENROLL L";;%1-516)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;S-1-5-9)(OA;;WPRPCR;" WSZ_GUID_AUTOENROLL L";;S-1-5-9)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-512)(OA;;WPRPCR;" WSZ_GUID_ENROLL L";;%1-519)"



//for defining default certificate types
#define OVERLAP_TWO_WEEKS 60*60*24*14
#define OVERLAP_SIX_WEEKS 60*60*24*42
#define EXPIRATION_ONE_YEAR 60*60*24*365
#define EXPIRATION_TWO_YEARS 60*60*24*365*2
#define EXPIRATION_FIVE_YEARS 60*60*24*365*5
#define EXPIRATION_THREE_MONTHS 60*60*24*92

/////////////////////////////////////////////////////////////////////////////
// description property for certificate template

#define CERT_TYPE_GENERAL_FILTER   (CT_FLAG_MACHINE_TYPE | CT_FLAG_IS_CA | CT_FLAG_IS_CROSS_CA)
#define CERT_TYPE_ENROLL_FILTER    (CT_FLAG_PUBLISH_TO_KRA_CONTAINER)
#define CERT_TYPE_NAME_FILTER      (CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID)

typedef struct _CERT_TYPE_DESCRIPTION
{
    DWORD   dwGeneralValue;
    DWORD   dwEnrollValue;
    DWORD   dwNameValue;
    UINT    idsDescription;
}CERT_TYPE_DESCRIPTION;


/////////////////////////////////////////////////////////////////////////////
// certcli

typedef struct _CERT_TYPE_DEFAULT
{
	WCHAR *wszName;
	UINT  idFriendlyName;
	WCHAR *wszSD;
	WCHAR *wszCSPs;
	WCHAR *wszEKU;
	SHORT bKU;
	BOOL  dwFlags;
	DWORD dwKeySpec;
	DWORD dwDepth;
	WCHAR *wszCriticalExt;
	DWORD dwExpiration;
	DWORD dwOverlap;
	DWORD dwRevision;
    DWORD dwMinorRevision;
	DWORD dwEnrollmentFlags;			
	DWORD dwPrivateKeyFlags;			
	DWORD dwCertificateNameFlags;	
	DWORD dwMinimalKeySize;				
	DWORD dwRASignature;				
	DWORD dwSchemaVersion;			
	WCHAR *wszOID;						
	WCHAR *wszSupersedeTemplates;		
	WCHAR *wszRAPolicy;				
	WCHAR *wszCertificatePolicy;
    WCHAR *wszRAAppPolicy;
    WCHAR *wszCertificateAppPolicy;

} CERT_TYPE_DEFAULT, *PCERT_TYPE_DEFAULT;

//
//  Default OID to install during certificate template installation
//
typedef struct _CERT_DEFAULT_OID_INFO
{
    LPWSTR  pwszOID;
    LPWSTR  pwszName;
    DWORD   dwType;
}CERT_DEFAULT_OID_INFO;


#define CERTTYPE_VERSION_BASE      0     // for w2k, 0
#define CERTTYPE_VERSION_NEXT    100     // for w2k+1.  This is the starting point
										 // for the major version.

#define CERTTYPE_MINIMAL_KEY			1024
#define CERTTYPE_2K_KEY			        2048

#define CERTTYPE_MINIMAL_KEY_SMART_CARD	512


#define MAX_SID_COUNT					5
#define MAX_DEFAULT_STRING_COUNT		20
#define MAX_DEFAULT_CSP_COUNT			10
#define MAX_DEFAULT_FRIENDLY_NAME		255

extern CERT_TYPE_DEFAULT g_aDefaultCertTypes[];
extern DWORD g_cDefaultCertTypes;

#define FILETIME_TICKS_PER_SECOND  10000000
#define DEFAULT_EXPIRATION         60*60*24*365   // 1 year
#define DEFAULT_OVERLAP            60*60*24*14    // 2 weeks

HANDLE
myEnterCriticalPolicySection(
    IN BOOL bMachine);

BOOL
myLeaveCriticalPolicySection(
    IN HANDLE hSection);

class CCertTypeInfo
{
public:
    CCertTypeInfo()
    {
        m_cRef = 1;
        m_pNext = NULL;
        m_pLast = NULL;
        m_dwFlags = 0;
        m_pProperties = NULL;
        m_BasicConstraints.fCA = FALSE;
        m_BasicConstraints.fPathLenConstraint = FALSE;
        m_BasicConstraints.dwPathLenConstraint = 0;
        m_KeyUsage.pbData = NULL;
        m_KeyUsage.cbData = NULL;
		m_dwMinorRevision = 0;
        m_dwEnrollmentFlags = 0;			
		m_dwPrivateKeyFlags = 0;			
		m_dwCertificateNameFlags = 0;	
		m_dwMinimalKeySize = 0;				
		m_dwRASignature = 0;				
		m_dwSchemaVersion=0;			

        m_bstrType = NULL;
        m_pSD = NULL;
        m_fLocalSystemCache = FALSE;

        m_fNew = TRUE;
        m_Revision = CERTTYPE_VERSION_BASE;



        ((LARGE_INTEGER *)&m_ftExpiration)->QuadPart = Int32x32To64(FILETIME_TICKS_PER_SECOND, DEFAULT_EXPIRATION);
        ((LARGE_INTEGER *)&m_ftOverlap)->QuadPart = Int32x32To64(FILETIME_TICKS_PER_SECOND, DEFAULT_OVERLAP);
    }

    ~CCertTypeInfo();

    DWORD Release();


static HRESULT Enum(
                    LPCWSTR                 wszScope , 
                    DWORD                   dwFlags,
                    CCertTypeInfo **        ppCertTypeInfo
                    );

static HRESULT FindByNames(
                           LPCWSTR *        awszNames,
                           LPCWSTR          wszScope, 
                           DWORD            dwFlags,
                           CCertTypeInfo ** ppCertTypeInfo
                           );

static HRESULT Create(
                      LPCWSTR               wszName, 
                      LPCWSTR                wszScope, 
                      CCertTypeInfo **      ppCTInfo
                      );

static HRESULT InstallDefaultTypes(VOID);


    HRESULT Update(VOID);

    HRESULT Delete(VOID);

    HRESULT Next(CCertTypeInfo **ppCertTypeInfo);

    DWORD Count()
    {
        if(m_pNext)
        {
            return m_pNext->Count()+1;
        }
        return 1;
    }

    HRESULT GetProperty(LPCWSTR wszPropertyName, LPWSTR **pawszProperties);
    HRESULT SetProperty(LPCWSTR wszPropertyName, LPWSTR *awszProperties);
    HRESULT GetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue);
    HRESULT SetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue);
    HRESULT FreeProperty(LPWSTR *pawszProperties);


    HRESULT GetExtensions(IN  DWORD               dwFlags,
                          IN  LPVOID              pParam,
                          OUT PCERT_EXTENSIONS *  ppCertExtensions);

    HRESULT FreeExtensions(PCERT_EXTENSIONS pCertExtensions) 
    {
        LocalFree(pCertExtensions);
        return S_OK;
    }

    HRESULT SetExtension(   IN LPCWSTR wszExtensionName,
                            IN LPVOID pExtension,
                            IN DWORD  dwFlags);


    HRESULT AccessCheck(
        IN HANDLE       ClientToken,
        IN DWORD        dwOption
        );

    HRESULT SetSecurity(IN PSECURITY_DESCRIPTOR         pSD);
    HRESULT GetSecurity(OUT PSECURITY_DESCRIPTOR *     ppSD);


    DWORD GetFlags(DWORD    dwOption);

    HRESULT  SetFlags(DWORD    dwOption, DWORD dwFlags);

    DWORD GetKeySpec(VOID)
    {
        return m_dwKeySpec;
    }

    VOID SetKeySpec(DWORD dwKeySpec)
    {
        m_dwKeySpec = dwKeySpec;
    }

    HRESULT SetExpiration(IN OPTIONAL FILETIME  * pftExpiration,
                          IN OPTIONAL FILETIME  * pftOverlap);

    HRESULT GetExpiration(OUT OPTIONAL FILETIME  * pftExpiration,
                          OUT OPTIONAL FILETIME  * pftOverlap);


    static CCertTypeInfo * _Append(CCertTypeInfo **ppCertTypeInfo, CCertTypeInfo *pInfo);



protected:

    static HRESULT _EnumFromDSCache(DWORD                   dwFlags,                            
                                    CCertTypeInfo **        ppCTInfo);

    static HRESULT _HasDSCacheExpired(  DWORD               dwFlags);
    static HRESULT _EnumScopeFromDS(
                                        LDAP *              pld,
                                        DWORD               dwFlags,
                                        LPCWSTR             wszScope,
                                        CCertTypeInfo **    ppCTInfo);                 
    static HRESULT _EnumFromDS(
                    LDAP *              pld,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    );

    static HRESULT _FindInDS(
                             LDAP *              pld,
                             LPCWSTR *           wszNames,
                             DWORD               dwFlags,
                             CCertTypeInfo **    ppCTInfo
                             );


    static CCertTypeInfo * _FilterByFlags(CCertTypeInfo **ppCertTypeInfo, 
                                          DWORD dwFlags);

    static  HRESULT _UpdateDSCache(
                        DWORD               dwFlags,
                        CCertTypeInfo *     pCTInfo
                        );
    
    HRESULT _Cleanup();

    DWORD AddRef();
    HRESULT _GetTypeExtensionValue(IN BOOL fCheckVersion, OUT CERTSTR *  bstrValue);

    HRESULT _GetEKUValue(OUT CERTSTR *  bstrValue);

    HRESULT _GetKUValue(OUT CERTSTR *  bstrValue);

    HRESULT _GetBasicConstraintsValue(OUT CERTSTR *  bstrValue);

    HRESULT _GetPoliciesValue(IN LPCWSTR pwszPropertyName, OUT CERTSTR *  bstrValue);

    BOOL _IsCritical(IN LPCWSTR wszExtId, LPCWSTR *awszCriticalExtensions);

    HRESULT _LoadFromRegBase(LPCWSTR wszType, HKEY hCertTypes);

    HRESULT _LoadCachedCTFromReg(LPCWSTR wszType, HKEY hRoot);

    HRESULT _BaseUpdateToReg(HKEY hKey);
    HRESULT _UpdateToDS(VOID);


    HRESULT _SetWszzProperty(
		    IN WCHAR const *pwszPropertyName,
		    OPTIONAL IN WCHAR const *pwszzPropertyValue);

    HRESULT _LoadFromDefaults(PCERT_TYPE_DEFAULT pDefault,
                              LPWSTR            wszDomain);

    HRESULT _LoadFromDSEntry(LDAP *pld, LDAPMessage *Entry);


    HRESULT _BuildDefaultSecurity(PCERT_TYPE_DEFAULT pDefault);


    LONG                    m_cRef;
    CERTSTR                 m_bstrType;

    CERT_BASIC_CONSTRAINTS2_INFO m_BasicConstraints;
    CRYPT_BIT_BLOB          m_KeyUsage;


    DWORD                   m_dwFlags;

    DWORD                   m_dwKeySpec;
    DWORD                   m_dwMinorRevision;
	DWORD					m_dwEnrollmentFlags;			
	DWORD					m_dwPrivateKeyFlags;			
	DWORD					m_dwCertificateNameFlags;	
	DWORD					m_dwMinimalKeySize;				
	DWORD					m_dwRASignature;				
	DWORD					m_dwSchemaVersion;			


    CCAProperty             *m_pProperties;

    FILETIME                m_ftExpiration;
    FILETIME                m_ftOverlap;

    BOOL                    m_fNew;
    BOOL                    m_fLocalSystemCache;

    PSECURITY_DESCRIPTOR    m_pSD;
    DWORD                   m_Revision;

    CCertTypeInfo *m_pNext;
    CCertTypeInfo *m_pLast;

private:
};

#define m_dwCritical


// These are additional LDAP attribute names that define cert type data, that are not included in the
// primary cert type property list

// flags
// 
#define CERTTYPE_PROP_FLAGS                 L"flags"
#define CERTTYPE_PROP_DEFAULT_KEYSPEC       L"pKIDefaultKeySpec"
#define CERTTYPE_SECURITY_DESCRIPTOR_NAME   L"NTSecurityDescriptor"
#define CERTTYPE_PROP_KU                    L"pKIKeyUsage"
#define CERTTYPE_PROP_MAX_DEPTH             L"pKIMaxIssuingDepth"
#define CERTTYPE_PROP_EXPIRATION            L"pKIExpirationPeriod"
#define CERTTYPE_PROP_OVERLAP               L"pKIOverlapPeriod"
//begining of V2 template attributes
#define CERTTYPE_RPOP_ENROLLMENT_FLAG		L"msPKI-Enrollment-Flag"
#define CERTTYPE_PROP_PRIVATE_KEY_FLAG		L"msPKI-Private-Key-Flag"
#define CERTTYPE_PROP_NAME_FLAG				L"msPKI-Certificate-Name-Flag"

//
//
#define CERTTYPE_REFRESH_PERIOD  60*10 // 10 minutes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\clibres.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:			clibres.h
//
// Contents:			Cert Server certclib resource definitions
//
//---------------------------------------------------------------------------

#ifndef __CLIBRES_H__
#define __CLIBRES_H__

// Default cert type friendly names

// Important, use only 900-999 range to avoid conflict

#define IDS_CERTTYPE_USER			900
#define IDS_CERTTYPE_USER_AS			901
#define IDS_CERTTYPE_USER_SMARTCARD_LOGON	902
#define IDS_CERTTYPE_EFS			903
#define IDS_CERTTYPE_ADMIN			904
#define IDS_CERTTYPE_EFS_RECOVERY		905
#define IDS_CERTTYPE_CODE_SIGNING		906
#define IDS_CERTTYPE_CTL_SIGNING		907
#define IDS_CERTTYPE_MACHINE			908
#define IDS_CERTTYPE_DC				909

#define IDS_CERTTYPE_WEBSERVER			910
#define IDS_CERTTYPE_KDC			911
#define IDS_CERTTYPE_ROOT_CA			912
#define IDS_CERTTYPE_SUBORDINATE_CA		913
#define IDS_CERTTYPE_ENROLLMENT_AGENT		914
#define IDS_CERTTYPE_SMARTCARD_USER		915
//#define IDS_UNUSED				916
#define IDS_CERTTYPE_USER_SIGNATURE		917
//#define IDS_UNUSED				918
#define IDS_ILOG_BAD_NUMERICFIELD		919

// progress dlg

#define IDD_PROGRESS_BAR			920
#define IDC_JOB_DESCRIPTION			921
#define IDD_PROGRESS_BOX			922

#define IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE	923
#define IDS_ILOG_BAD_VALIDITY_COUNT		924
#define IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE	925
#define IDS_ILOG_BAD_VALIDITY_STRING		926
#define IDS_CERTTYPE_ROUTER_OFFLINE		927
#define IDS_REQUEST_FILE_DEFEXT			928
#define IDS_REQUEST_OPEN_TITLE			929

#define IDS_REQUEST_FILE_FILTER			930
#define IDS_WRN_COMPUTERNAME_EMPTY		931
#define IDS_WRN_CANAME_EMPTY			932
#define IDS_WRN_CANAME_NOT_MATCH		933
#define IDS_WRN_PINGCA_FAIL			934
#define IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE	935
#define IDS_CERTTYPE_EXCHANGE_USER		936
#define IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE	937
#define IDS_WRN_CALIST_EMPTY			938
#define IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT	939

#define IDS_REQUEST_SAVE_TITLE			940
#define IDS_CERTTYPE_CEP_ENCRYPTION     	941


#define IDS_ILOG_CAPOLICY_BUILD			942
#define IDS_ILOG_CAPOLICY_ELEMENT		943
#define IDS_ILOG_CAPOLICY_EXTENSION		944
#define IDS_ILOG_CAPOLICY_NOKEY			945
#define IDS_ILOG_CAPOLICY_OPEN			946
#define IDS_ILOG_CAPOLICY_OPEN_FAILED		947
#define IDS_ILOG_BEGIN				948
#define IDS_ILOG_END				949

// description of access right defines

#define IDS_ACTRL_CAADMIN			950
#define IDS_ACTRL_OFFICER			951
#define IDS_ACTRL_AUDITOR			952
#define IDS_ACTRL_OPERATOR			953
#define IDS_ACTRL_CAREAD			954
#define IDS_ACTRL_ENROLL			955

#define IDS_ILOG_CAPOLICY_CLOSE			964
#define IDS_ILOG_MESSAGEBOX			965
#define IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND	966

#define IDS_CERTTYPE_KEY_RECOVERY_AGENT		967
#define IDS_CERTTYPE_CA_EXCHANGE		    968
#define IDS_EMPTY_FRIENDLY_NAME			    969
#define IDS_CERTTYPE_CROSS_CA			    970
#define IDS_CERTTYPE_DC_AUTH			    971
#define IDS_CERTTYPE_DS_EMAIL_REPLICATION	972


#define IDS_WARN_ENTERPRISE_REQUIREMENTS 	974
#define IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS 975
#define IDS_WRN_OLD_CA				976


#define IDS_KRA_DESCRIPTION                 1000
#define IDS_EMAIL_REPLICATION_DESCRIPTION   1001
#define IDS_CROSS_CA_DESCRIPTION            1002
#define IDS_CA_DESCRIPTION                  1003
#define IDS_MACHINE_DESCRIPTION             1004
#define IDS_END_USER_DESCRIPTION            1005
#define IDS_UNKNOWN_DESCRIPTION             1006

#define IDS_STORENAME_DS_KRA                1007
#define IDS_STORENAME_DS_AIA                1008


#endif // __CLIBRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\cs.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cs.h
//
// Contents:    Cert Server common definitions
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------


#ifndef __CS_H__
#define __CS_H__

#ifndef __CERTLIB_H__
# error -- cs.h should only be included from certlib.h!
#endif

#ifndef DBG
# if defined _DEBUG
#  define DBG 1
# else
#  define DBG 0
# endif
#endif

#ifndef DBG_CERTSRV
# define DBG_CERTSRV	DBG
#endif

// Size of a fixed array:
#define ARRAYSIZE(a)		(sizeof(a)/sizeof((a)[0]))

// _tcslen of a static string:
#define _TSZARRAYSIZE(a)	((sizeof(a)/sizeof((a)[0])) - 1)


#if DBG_CERTSRV
# ifdef DBG_CERTSRV_MESSAGE
#  pragma message("building debug extensions\n")
# endif
# define DBG_CERTSRV_DEBUG_PRINT
#endif //DBG_CERTSRV


#define DBG_SS_ERROR	 0x00000001
#define DBG_SS_ASSERT	 0x00000002
#define DBG_SS_INFO	 0x00000004	// or in with any of the below
#define DBG_SS_MODLOAD	 0x00000008
#define DBG_SS_NOQUIET	 0x00000010

#define DBG_SS_CERTHIER	 0x00000100
#define DBG_SS_CERTREQ	 0x00000200
#define DBG_SS_CERTUTIL	 0x00000400
#define DBG_SS_CERTSRV	 0x00000800

#define DBG_SS_CERTADM	 0x00001000
#define DBG_SS_CERTCLI	 0x00002000
#define DBG_SS_CERTDB	 0x00004000
#define DBG_SS_CERTENC	 0x00008000
#define DBG_SS_CERTEXIT	 0x00010000
#define DBG_SS_CERTIF	 0x00020000
#define DBG_SS_CERTMMC	 0x00040000
#define DBG_SS_CERTOCM	 0x00080000
#define DBG_SS_CERTPOL	 0x00100000
#define DBG_SS_CERTVIEW	 0x00200000
#define DBG_SS_CERTBCLI	 0x00400000
#define DBG_SS_CERTJET	 0x00800000
#define DBG_SS_CERTLIBXE 0x10000000	// same as dbgdef.h's DBG_SS_APP
#define DBG_SS_AUDIT	 0x20000000
#define DBG_SS_CERTLIB	 0x40000000

//#define DBG_SS_SIGN	 0x80000000	// don't use: strtol won't set this bit

#define DBG_SS_CERTHIERI	(DBG_SS_CERTHIER | DBG_SS_INFO)
#define DBG_SS_CERTREQI		(DBG_SS_CERTREQ | DBG_SS_INFO)
#define DBG_SS_CERTUTILI	(DBG_SS_CERTUTIL | DBG_SS_INFO)
#define DBG_SS_CERTSRVI		(DBG_SS_CERTSRV | DBG_SS_INFO)

#define DBG_SS_CERTADMI		(DBG_SS_CERTADM | DBG_SS_INFO)
#define DBG_SS_CERTCLII		(DBG_SS_CERTCLI | DBG_SS_INFO)
#define DBG_SS_CERTDBI		(DBG_SS_CERTDB | DBG_SS_INFO)
#define DBG_SS_CERTENCI		(DBG_SS_CERTENC | DBG_SS_INFO)
#define DBG_SS_CERTEXITI	(DBG_SS_CERTEXIT | DBG_SS_INFO)
#define DBG_SS_CERTIFI		(DBG_SS_CERTIF | DBG_SS_INFO)
#define DBG_SS_CERTMMCI		(DBG_SS_CERTMMC | DBG_SS_INFO)
#define DBG_SS_CERTOCMI		(DBG_SS_CERTOCM | DBG_SS_INFO)
#define DBG_SS_CERTPOLI		(DBG_SS_CERTPOL | DBG_SS_INFO)
#define DBG_SS_CERTVIEWI	(DBG_SS_CERTVIEW | DBG_SS_INFO)
#define DBG_SS_CERTBCLII	(DBG_SS_CERTBCLI | DBG_SS_INFO)
#define DBG_SS_CERTJETI		(DBG_SS_CERTJET | DBG_SS_INFO)

#define DBG_SS_CERTLIBI		(DBG_SS_CERTLIB | DBG_SS_INFO)


// begin_certsrv

// VerifyRequest() return values

#define VR_PENDING	0	 // request will be accepted or denied later
#define VR_INSTANT_OK	1	 // request was accepted
#define VR_INSTANT_BAD	2	 // request was rejected

// end_certsrv

// Certificate types:

#define CERT_TYPE_NONE	0	// cannot create certificates
#define CERT_TYPE_X509	1	// CCITT x509 certificates
#define CERT_TYPE_SDSI	2	// SDSI certificates
#define CERT_TYPE_PGP	3	// PGP certificates


#if DBG_CERTSRV
# define DBGCODE(a)	a
# define DBGPARM0(parm)  parm
# define DBGPARM(parm)   , parm
#else // DBG_CERTSRV
# define DBGCODE(a)
# define DBGPARM0(parm)
# define DBGPARM(parm)
#endif // DBG_CERTSRV

#define wprintf			myConsolePrintf
#define printf			Use_wprintf_Instead_Of_printf
#define LdapMapErrorToWin32	Use_myHLdapError_Instead_Of_LdapMapErrorToWin32

#if 0 == i386
# define IOBUNALIGNED(pf) ((sizeof(WCHAR) - 1) & (DWORD) (ULONG_PTR) (pf)->_ptr)
# define ALIGNIOB(pf) \
    { \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fflush(pf); /* fails when running as a service */ \
	} \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fprintf(pf, " "); \
	    fflush(pf); \
	} \
    }
#else
# define IOBUNALIGNED(pf) FALSE
# define ALIGNIOB(pf)
#endif

HRESULT myHExceptionCode(IN EXCEPTION_POINTERS const *pep);


#ifdef DBG_CERTSRV_DEBUG_PRINT

typedef VOID (WINAPI FNPRINTERROR)(
    IN char const *pszMessage,
    OPTIONAL IN WCHAR const *pwszData,
    IN char const *pszFile,
    IN DWORD dwLine,
    IN HRESULT hr,
    IN HRESULT hrquiet);

FNPRINTERROR CSPrintError;


typedef VOID (WINAPI FNPRINTERRORINT)(
    IN char const *pszMessage,
    IN DWORD dwData,
    IN char const *pszFile,
    IN DWORD dwLine,
    IN HRESULT hr,
    IN HRESULT hrquiet);

FNPRINTERRORINT CSPrintErrorInt;


typedef VOID (WINAPI FNPRINTASSERT)(
    IN char const *pszFailedAssertion,
    IN char const *pszFileName,
    IN DWORD dwLine,
    IN char const *pszMessage);

FNPRINTASSERT CSPrintAssert;

#define __FILEDIR__	__DIR__ "\\" __FILE__

# define CSASSERT(exp)	CSASSERTMSG(NULL, exp)

# define CSASSERTMSG(pszmsg, exp) \
    if (!(exp)) \
	CSPrintAssert(#exp, __FILEDIR__, __LINE__, (pszmsg))

# define DBGERRORPRINT(pszMessage, pwszData, dwLine, hr, hrquiet) \
    CSPrintError((pszMessage), (pwszData), __FILEDIR__, (dwLine), (hr), (hrquiet))

# define DBGERRORPRINTINT(pszMessage, dwData, dwLine, hr, hrquiet) \
    CSPrintErrorInt((pszMessage), (dwData), __FILEDIR__, (dwLine), (hr), (hrquiet))

# define myHEXCEPTIONCODE() myHExceptionCodePrint(GetExceptionInformation(), __FILEDIR__, __dwFILE__, __LINE__)

#else // DBG_CERTSRV_DEBUG_PRINT

# define CSASSERT(exp)
# define CSASSERTMSG(msg, exp)
# define DBGERRORPRINT(pszMessage, pwszData, dwLine, hr, hrquiet)
# define DBGERRORPRINTINT(pszMessage, dwData, dwLine, hr, hrquiet)
# define myHEXCEPTIONCODE() myHExceptionCodePrint(GetExceptionInformation(), NULL, __dwFILE__, __LINE__)

#endif // DBG_CERTSRV_DEBUG_PRINT

typedef VOID (FNLOGSTRING)(
    IN char const *pszString);

typedef VOID (FNLOGEXCEPTION)(
    IN HRESULT hrExcept,
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *pszFileName,
    IN DWORD dwFile,
    IN DWORD dwLine);

HRESULT myHExceptionCodePrint(
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *pszFile,
    IN DWORD dwFile,
    IN DWORD dwLine);

VOID myLogExceptionInit(
    IN FNLOGEXCEPTION *pfnLogException);

#define CBLOGMAXAPPEND	(512 * 1024)

#ifdef DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINTINIT(pszFile)	DbgPrintfInit(pszFile)
# define DBGLOGSTRINGINIT(pfnLogString) DbgLogStringInit(pfnLogString)
# define DBGPRINT(a)		DbgPrintf a
# define DBGDUMPHEX(a)		mydbgDumpHex a
# define CONSOLEPRINT0(a)	DBGPRINT(a)
# define CONSOLEPRINT1(a)	DBGPRINT(a)
# define CONSOLEPRINT2(a)	DBGPRINT(a)
# define CONSOLEPRINT3(a)	DBGPRINT(a)
# define CONSOLEPRINT4(a)	DBGPRINT(a)
# define CONSOLEPRINT5(a)	DBGPRINT(a)
# define CONSOLEPRINT6(a)	DBGPRINT(a)
# define CONSOLEPRINT7(a)	DBGPRINT(a)
# define CONSOLEPRINT8(a)	DBGPRINT(a)

  int WINAPIV DbgPrintf(DWORD dwSubSysId, char const *pszfmt, ...);
  VOID DbgPrintfInit(OPTIONAL IN CHAR const *pszFile);
  BOOL DbgIsSSActive(DWORD dwSSIn);
  VOID DbgLogStringInit(FNLOGSTRING *pfnLog);

#else
# define DBGPRINTINIT(pszFile)
# define DBGLOGSTRINGINIT(pfnLogString)
# define DBGPRINT(a)
# define DBGDUMPHEX(a)

# define CONSOLEPRINT0(a)	_CONSOLEPRINT0 a
# define CONSOLEPRINT1(a)	_CONSOLEPRINT1 a
# define CONSOLEPRINT2(a)	_CONSOLEPRINT2 a
# define CONSOLEPRINT3(a)	_CONSOLEPRINT3 a
# define CONSOLEPRINT4(a)	_CONSOLEPRINT4 a
# define CONSOLEPRINT5(a)	_CONSOLEPRINT5 a
# define CONSOLEPRINT6(a)	_CONSOLEPRINT6 a
# define CONSOLEPRINT7(a)	_CONSOLEPRINT7 a
# define CONSOLEPRINT8(a)	_CONSOLEPRINT8 a
# define _CONSOLEPRINT0(mask, fmt)  		wprintf(TEXT(fmt))
# define _CONSOLEPRINT1(mask, fmt, a1)  	wprintf(TEXT(fmt), (a1))
# define _CONSOLEPRINT2(mask, fmt, a1, a2)  	wprintf(TEXT(fmt), (a1), (a2))
# define _CONSOLEPRINT3(mask, fmt, a1, a2, a3) \
	    wprintf(TEXT(fmt), (a1), (a2), (a3))

# define _CONSOLEPRINT4(mask, fmt, a1, a2, a3, a4) \
	    wprintf(TEXT(fmt), (a1), (a2), (a3), (a4))

# define _CONSOLEPRINT5(mask, fmt, a1, a2, a3, a4, a5) \
	    wprintf(TEXT(fmt), (a1), (a2), (a3), (a4), (a5))

# define _CONSOLEPRINT6(mask, fmt, a1, a2, a3, a4, a5, a6) \
	    wprintf(TEXT(fmt), (a1), (a2), (a3), (a4), (a5), (a6))

# define _CONSOLEPRINT7(mask, fmt, a1, a2, a3, a4, a5, a6, a7) \
	    wprintf(TEXT(fmt), (a1), (a2), (a3), (a4), (a5), (a6), (a7))

# define _CONSOLEPRINT8(mask, fmt, a1, a2, a3, a4, a5, a6, a7, a8) \
	    wprintf(TEXT(fmt), (a1), (a2), (a3), (a4), (a5), (a6), (a7), (a8))
#endif

#if 1 < DBG_CERTSRV
# define DBGTRACE(a)	DbgPrintf a
#else
# define DBGTRACE(a)
#endif


#define _LeaveError(hr, pszMessage) \
	_LeaveErrorStr2((hr), (pszMessage), NULL, 0)

#define _LeaveError2(hr, pszMessage, hrquiet) \
	_LeaveErrorStr2((hr), (pszMessage), NULL, (hrquiet))

#define _LeaveErrorStr(hr, pszMessage, pwszData) \
	_LeaveErrorStr2((hr), (pszMessage), (pwszData), 0)

#define _LeaveError3(hr, pszMessage, hrquiet, hrquiet2) \
	_LeaveErrorStr3((hr), (pszMessage), NULL, (hrquiet), (hrquiet2))

#define _LeaveErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	__leave; \
    }

#define _LeaveErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if ((hrquiet2) != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
	__leave; \
    }


#define _LeaveIfError(hr, pszMessage) \
	_LeaveIfErrorStr2((hr), (pszMessage), NULL, 0)

#define _LeaveIfError2(hr, pszMessage, hrquiet) \
	_LeaveIfErrorStr2((hr), (pszMessage), NULL, (hrquiet))

#define _LeaveIfErrorStr(hr, pszMessage, pwszData) \
	_LeaveIfErrorStr2((hr), (pszMessage), (pwszData), 0)

#define _LeaveIfError3(hr, pszMessage, hrquiet, hrquiet2) \
	_LeaveIfErrorStr3((hr), (pszMessage), NULL, (hrquiet), (hrquiet2))

#define _LeaveIfErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    __leave; \
	} \
    }

#define _LeaveIfErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	    __leave; \
	} \
    }


#define _PrintError(hr, pszMessage) \
	_PrintErrorStr2((hr), (pszMessage), NULL, 0)

#define _PrintError2(hr, pszMessage, hrquiet) \
	_PrintErrorStr2((hr), (pszMessage), NULL, (hrquiet))

#define _PrintErrorStr(hr, pszMessage, pwszData) \
	_PrintErrorStr2((hr), (pszMessage), (pwszData), 0)

#define _PrintError3(hr, pszMessage, hrquiet, hrquiet2) \
	_PrintErrorStr3((hr), (pszMessage), NULL, (hrquiet), (hrquiet2))

#define _PrintErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
    }

#define _PrintErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if ((hrquiet2) != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
    }


#define _PrintIfError(hr, pszMessage) \
	_PrintIfErrorStr2((hr), (pszMessage), NULL, 0)

#define _PrintIfError2(hr, pszMessage, hrquiet) \
	_PrintIfErrorStr2((hr), (pszMessage), NULL, (hrquiet))

#define _PrintIfErrorStr(hr, pszMessage, pwszData) \
	_PrintIfErrorStr2((hr), (pszMessage), (pwszData), 0)

#define _PrintIfError3(hr, pszMessage, hrquiet, hrquiet2) \
	_PrintIfErrorStr3((hr), (pszMessage), NULL, (hrquiet), (hrquiet2))

#define _PrintIfError4(hr, pszMessage, hrquiet, hrquiet2, hrquiet3) \
	_PrintIfErrorStr4((hr), (pszMessage), NULL, (hrquiet), (hrquiet2), (hrquiet3))

#define _PrintIfErrorStr2(hr, pszMessage, pwszData, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
    }

#define _PrintIfErrorStr3(hr, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	} \
    }

#define _PrintIfErrorStr4(hr, pszMessage, pwszData, hrquiet, hrquiet2, hrquiet3) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr) && (hrquiet3) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	} \
    }



#define _JumpError(hr, label, pszMessage) \
	_JumpErrorStr2((hr), label, (pszMessage), NULL, 0)

#define _JumpError2(hr, label, pszMessage, hrquiet) \
	_JumpErrorStr2((hr), label, (pszMessage), NULL, (hrquiet))

#define _JumpErrorStr(hr, label, pszMessage, pwszData) \
	_JumpErrorStr2((hr), label, (pszMessage), (pwszData), 0)

#define _JumpErrorStr2(hr, label, pszMessage, pwszData, hrquiet) \
    { \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	goto label; \
    }

#define _JumpErrorStr3(hr, label, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if ((hrquiet2) != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	} \
	goto label; \
    }


#define _JumpIfError(hr, label, pszMessage) \
	_JumpIfErrorStr2((hr), label, (pszMessage), NULL, 0)

#define _JumpIfError2(hr, label, pszMessage, hrquiet) \
	_JumpIfErrorStr2((hr), label, (pszMessage), NULL, (hrquiet))

#define _JumpIfErrorStr(hr, label, pszMessage, pwszData) \
	_JumpIfErrorStr2((hr), label, (pszMessage), (pwszData), 0)

#define _JumpIfError3(hr, label, pszMessage, hrquiet, hrquiet2) \
	_JumpIfErrorStr3((hr), label, (pszMessage), NULL, (hrquiet), (hrquiet2))

#define _JumpIfError4(hr, label, pszMessage, hrquiet, hrquiet2, hrquiet3) \
	_JumpIfErrorStr4((hr), label, (pszMessage), NULL, (hrquiet), (hrquiet2), (hrquiet3))

#define _JumpIfErrorStr2(hr, label, pszMessage, pwszData, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr3(hr, label, pszMessage, pwszData, hrquiet, hrquiet2) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	    goto label; \
	} \
    }

#define _JumpIfErrorStr4(hr, label, pszMessage, pwszData, hrquiet, hrquiet2, hrquiet3) \
    { \
	if (S_OK != (hr)) \
	{ \
	    if ((hrquiet2) != (hr) && (hrquiet3) != (hr)) \
	    { \
		DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), (hrquiet)); \
	    } \
	    goto label; \
	} \
    }

#define _JumpIfWin32Error(err, label, pszMessage) \
    { \
	if (ERROR_SUCCESS != (err)) \
	{ \
	    hr = HRESULT_FROM_WIN32((err)); \
	    DBGERRORPRINTLINESTR2((pszMessage), NULL, hr, 0); \
	    goto label; \
	} \
    }

#define _JumpIfErrorNotSpecific(hr, label, pszMessage, hrquiet) \
    { \
	if (S_OK != (hr)) \
	{ \
	    DBGERRORPRINTLINESTR2((pszMessage), NULL, (hr), (hrquiet)); \
	    if ((hrquiet) != (hr)) \
	    { \
		goto label; \
	    } \
	} \
    }

#define _JumpIfAllocFailed(ptr, label) \
    { \
	if ((ptr) == NULL) \
	{ \
	    hr = E_OUTOFMEMORY; \
	    DBGERRORPRINTLINE("allocation error", (hr)) \
	    goto label; \
	} \
    }

#define DBGERRORPRINTLINE(pszMessage, hr) \
	DBGERRORPRINTLINESTR2((pszMessage), NULL, (hr), 0)

#define DBGERRORPRINTLINESTR(pszMessage, pwszData, hr) \
	DBGERRORPRINTLINESTR2((pszMessage), (pwszData), (hr), 0)

#define DBGERRORPRINTLINEINT(pszMessage, dwData, hr) \
	DBGERRORPRINTLINEINT2((pszMessage), (dwData), (hr), 0)

#define DBGERRORPRINTLINESTR2(pszMessage, pwszData, hr, hrquiet) \
    { \
	DBGERRORPRINT((pszMessage), (pwszData), __LINE__, (hr), (hrquiet)); \
    }

#define DBGERRORPRINTLINEINT2(pszMessage, dwData, hr, hrquiet) \
    { \
	DBGERRORPRINTINT((pszMessage), (dwData), __LINE__, (hr), (hrquiet)); \
    }


#define Add2Ptr(pb, cb)	((VOID *) ((BYTE *) (pb) + (ULONG_PTR) (cb)))


#define Add2ConstPtr(pb, cb) \
	((VOID const *) ((BYTE const *) (pb) + (ULONG_PTR) (cb)))


#define WSZARRAYSIZE(a)		csWSZARRAYSIZE(a, _TSZARRAYSIZE(a))
#define SZARRAYSIZE(a)		csSZARRAYSIZE(a, _TSZARRAYSIZE(a))

#ifdef UNICODE
#define TSZARRAYSIZE(a)		WSZARRAYSIZE(a)
#else
#define TSZARRAYSIZE(a)		SZARRAYSIZE(a)
#endif

__inline DWORD
csWSZARRAYSIZE(
    IN WCHAR const *pwsz,
    IN DWORD cwc)
{
    CSASSERT(wcslen(pwsz) == cwc);
    return(cwc);
}

__inline DWORD
csSZARRAYSIZE(
    IN CHAR const *psz,
    IN DWORD cch)
{
    CSASSERT(strlen(psz) == cch);
    return(cch);
}


//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#endif // __CS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\ciinit.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ciinit.h
//
// Contents:    Cert Server common definitions
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CIINIT_H__
#define __CIINIT_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _SERVERCALLBACKS {
    FNCIGETPROPERTY  *pfnGetProperty;
    FNCISETPROPERTY  *pfnSetProperty;
    FNCIGETEXTENSION *pfnGetExtension;
    FNCISETEXTENSION *pfnSetExtension;
    FNCIENUMSETUP    *pfnEnumSetup;
    FNCIENUMNEXT     *pfnEnumNext;
    FNCIENUMCLOSE    *pfnEnumClose;
} SERVERCALLBACKS;

DWORD WINAPI
CertificateInterfaceInit(
    IN SERVERCALLBACKS const *psb,
    IN DWORD cbsb);

#ifdef __cplusplus
}
#endif

#endif // __CIINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\config.h ===
//+--------------------------------------------------------------------------
// File:        config.h
// Contents:    CConfigStorage implements read/write to CA configuration data 
//              currently stored under HKLM\System\CCS\Services\Certsvc\
//              Configuration
//---------------------------------------------------------------------------

namespace CertSrv
{
class CConfigStorage
{
public:

    CConfigStorage() : 
      m_hRemoteHKLM(NULL),
      m_hRootConfigKey(NULL), 
      m_hCAKey(NULL),
      m_pwszMachine(NULL) {};

   ~CConfigStorage();

    HRESULT InitMachine(LPCWSTR pcwszMachine);

    HRESULT GetEntry(
        LPCWSTR pcwszAuthorityName,
        LPCWSTR pcwszRelativeNodePath,
        LPCWSTR pcwszValue,
        VARIANT *pVariant);

    HRESULT SetEntry(
        LPCWSTR pwszAuthorityName,
        LPCWSTR pcwszRelativeNodePath,
        LPCWSTR pwszEntry,
        VARIANT *pVariant);

private:

    HRESULT InitRootKey();
    HRESULT InitCAKey(LPCWSTR pcwszAuthority);
    
    HKEY m_hRemoteHKLM; // HKLM if connecting to remote machine
    HKEY m_hRootConfigKey; // HKLM\System\CCS\Services\CertSvc\Configuration
    HKEY m_hCAKey; // ...Configuration\CAName
    LPWSTR m_pwszMachine;

}; // class CConfigStorage

}; // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csauto.h ===
#pragma once

namespace CertSrv
{

typedef VOID (WINAPI* PFNAUTOCLEANUP)(VOID*);


template<class PTR, PFNAUTOCLEANUP pfn, UINT_PTR pInvalid = NULL> 
class CAutoPtr {

public:
    CAutoPtr() { m_ptr = pInvalid; }
    CAutoPtr(PTR ptr) : m_ptr(ptr) { }
   ~CAutoPtr() { Cleanup(); }

    bool IsValid()  const { return(m_ptr != pInvalid); }
    bool IsInvalid()const { return(!IsValid()); }

    PTR operator=(PTR ptr) { return Attach(ptr); }
    operator PTR() const { return m_ptr; }
    PTR* operator &() { CSASSERT(NULL==m_ptr); return &m_ptr; }
    PTR& operator *()  const { CSASSERT(NULL!=m_ptr); return *m_ptr; }
    PTR  operator ->() const { return m_ptr; }
    bool operator ==(const PTR ptr) const { return m_ptr==ptr; }
    bool operator !=(const PTR ptr) const { return m_ptr!=ptr; }
    bool operator !() const { return NULL == m_ptr; }
    
    void Cleanup() 
    { 
        if (IsValid()) 
        {
            pfn(m_ptr);
            m_ptr = pInvalid;
        }
    }

    PTR Attach(PTR ptr)
    {
        Cleanup(); 
        m_ptr = ptr;
        return(*this);  
    }

    PTR Detach()
    {
        PTR ptrTemp = m_ptr;
        m_ptr = pInvalid;
        return m_ptr;
    }
        
private:
    
    // disable default copy constructor and assignment operator for
    // CAutoPtr objects
    CAutoPtr(const CAutoPtr& src) { }
    CAutoPtr operator=(CAutoPtr p) { }

    PTR m_ptr;           // The member representing the object
};


#define DefineAutoClass(className, tData, pfnCleanup) \
   typedef CAutoPtr<tData, (PFNAUTOCLEANUP) pfnCleanup> className;

#define DefineAutoClassEx(className, tData, pfnCleanup, pInvalid) \
   typedef CAutoPtr<tData, (PFNAUTOCLEANUP) pfnCleanup, \
   pInvalid> className;


// Instances of the template C++ class for common data PTRs.
DefineAutoClass(CAutoLPWSTR,    LPWSTR, LocalFree);
DefineAutoClass(CAutoLPSTR,     LPSTR,  LocalFree);
DefineAutoClass(CAutoPBYTE,     PBYTE,  LocalFree);
DefineAutoClass(CAutoHANDLE,    HANDLE, CloseHandle);
DefineAutoClass(CAutoBSTR,      BSTR,   SysFreeString);   


}; // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csber.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       csber.h
//
//--------------------------------------------------------------------------

#ifndef __CSBER_H__
#define __CSBER_H__

// tag definitions for ASN.1 encoding decoding:

#define BER_UNIVERSAL		0x00
#define BER_APPLICATION		0x40
#define BER_CONTEXT_SPECIFIC	0x80
#define BER_PRIVATE		0xc0

#define BER_PRIMITIVE		0x00
#define BER_CONSTRUCTED		0x20

#define BER_BOOL		0x01
#define BER_INTEGER		0x02
#define BER_BIT_STRING		0x03
#define BER_OCTET_STRING	0x04
#define BER_NULL		0x05
#define BER_OBJECT_ID		0x06
#define BER_OBJECT_DESC		0x07
#define BER_EXTERNAL		0x08
#define BER_REAL		0x09
#define BER_ENUMERATED		0x0a
#define BER_EMBEDDED_VALUE	0x0b	// Embedded presentation data value
#define BER_UTF8_STRING		0x0c
//#define BER_UNKNOWN		0x0d
//#define BER_UNKNOWN		0x0e
//#define BER_UNKNOWN		0x0f

#define BER_SEQUENCE_RAW	0x10
#define BER_SEQUENCE		(BER_SEQUENCE_RAW | BER_CONSTRUCTED)	// 0x30
#define BER_SET_RAW		0x11
#define BER_SET			(BER_SET_RAW | BER_CONSTRUCTED)		// 0x31

#define BER_NUMERIC_STRING	0x12
#define BER_PRINTABLE_STRING	0x13
#define BER_TELETEX_STRING	0x14	// Teletex, or T61
#define BER_VIDEOTEX_STRING	0x15
#define BER_IA5_STRING		0x16
#define BER_UTC_TIME		0x17
#define BER_GENERALIZED_TIME	0x18
#define BER_GRAPHIC_STRING	0x19
#define BER_VISIBLE_STRING	0x1a
#define BER_GENERAL_STRING	0x1b
#define BER_UNIVERSAL_STRING	0x1c
//#define BER_UNKNOWN		0x1d
#define BER_UNICODE_STRING	0x1e	// BMP: Basic Multilingual Plane
//#define BER_UNKNOWN		0x1f

#define BER_OPTIONAL		(BER_CONTEXT_SPECIFIC | BER_CONSTRUCTED) //0xa0

#endif  // __CSBER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\cscomres.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:		cscomres.h
//
// Contents:		Cert Server COM resource definitions
//
//---------------------------------------------------------------------------

#ifndef __CSCOMRES_H__
#define __CSCOMRES_H__

// config string ids

#define IDS_CERTCONFIG_DESC		1
#define IDS_CERTGETCONFIG_DESC		2
#define IDS_CERTREQUEST_DESC		3
#define IDS_CERTADMIN_DESC		4
#define IDS_CERTSERVERPOLICY_DESC	5
#define IDS_CERTSERVEREXIT_DESC		6
#define IDS_CERTVIEW_DESC		7
#define IDS_CERTMANAGEPOLICYMODULE_DESC	8
#define IDS_LEGACYPOLICYMODULE_NAME	9
#define IDS_CERTMANAGEEXITMODULE_DESC	10
#define IDS_LEGACYEXITMODULE_NAME	11

#endif // __CSCOMRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\cscsp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cscsp.h
//
// Contents:    Cert Server CSP routines.
//
//---------------------------------------------------------------------------

#ifndef __CSCSP_H__
#define __CSCSP_H__

HRESULT
myGetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszCAName,
    OUT DWORD *pdwProvType,
    OUT WCHAR **ppwszProvName,
    OUT ALG_ID *pidAlg,
    OUT BOOL *pfMachineKeyset,
    OPTIONAL OUT DWORD *pdwKeySize);

BOOL
myCertSrvCryptAcquireContext(
    OUT HCRYPTPROV *phProv,
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvider,
    IN DWORD        dwProvType,
    IN DWORD        dwFlags,
    IN BOOL         fMachineKeyset);

HRESULT
myGetSigningOID(
    OPTIONAL IN HCRYPTPROV hProv,	// hProv OR pwszProvName & dwProvType
    OPTIONAL IN WCHAR const *pwszProvName,
    OPTIONAL IN DWORD dwProvType,
    IN ALG_ID idHashAlg,
    OUT CHAR **ppszAlgId);

HRESULT
myValidateKeyForSigning(
    IN HCRYPTPROV hProv,
    OPTIONAL IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId);

HRESULT
myValidateKeyForEncrypting(
    IN HCRYPTPROV hProv,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId);

HRESULT
myValidateHashForSigning(
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pszProvName,
    IN DWORD dwProvType,
    IN BOOL fMachineKeyset,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId);

HRESULT
myEnumProviders(
   IN DWORD dwIndex,
   IN DWORD *pdwReserved,
   IN DWORD dwFlags,
   OUT DWORD *pdwProvType,
   OUT WCHAR **ppwszProvName);

#endif // __CSCSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\cslistvw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cslistvw.h
//
//--------------------------------------------------------------------------
#ifndef __CSLISTVW_H__
#define __CSLISTVW_H__

// help is embedded in certmmc.hlp
BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);

#endif //__CSLISTVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csfile.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2001
//
// File:        csfile.h
//
// Contents:    Cert Server file number definitions
//
//---------------------------------------------------------------------------

#ifndef __CSFILE_H__
#define __CSFILE_H__

#define __dwFILE_OCMSETUP_BROWSEDI_CPP__	101
#define __dwFILE_OCMSETUP_CONFIG_CPP__		102
#define __dwFILE_OCMSETUP_CRYPTFIX_CPP__	103
#define __dwFILE_OCMSETUP_CSOCM_CPP__		104
#define __dwFILE_OCMSETUP_CSPENUM_CPP__		105
#define __dwFILE_OCMSETUP_DSSETUP_CPP__		106
#define __dwFILE_OCMSETUP_PFXIMPT_CPP__		107
#define __dwFILE_OCMSETUP_REGD_CPP__		108
#define __dwFILE_OCMSETUP_SETUPUT_CPP__		109
#define __dwFILE_OCMSETUP_UNATTEND_CPP__	110
#define __dwFILE_OCMSETUP_USECERT_CPP__		111
#define __dwFILE_OCMSETUP_WIZPAGE_CPP__		112
#define __dwFILE_OCMSETUP_REG_CPP__		113

#define __dwFILE_INITLIB_CERTHIER_CPP__		201
#define __dwFILE_INITLIB_INITLIB_CPP__		202
#define __dwFILE_INITLIB_KEYENUM_CPP__		203
//#define __dwFILE_INITLIB_LOG_CPP__		204
#define __dwFILE_INITLIB_CERTMSG_CPP__		205
#define __dwFILE_INITLIB_CERTUI_CPP__		206

#define __dwFILE_CERTUTIL_CERTUTIL_CPP__	301
#define __dwFILE_CERTUTIL_ADMIN_CPP__		302
#define __dwFILE_CERTUTIL_BACKUP_CPP__		303
#define __dwFILE_CERTUTIL_DB2_CPP__		304
#define __dwFILE_CERTUTIL_DBCNVT_CPP__		305
#define __dwFILE_CERTUTIL_DBCORE_CPP__		306
#define __dwFILE_CERTUTIL_DS_CPP__		307
#define __dwFILE_CERTUTIL_DUMP_CPP__		308
#define __dwFILE_CERTUTIL_INFO_CPP__		309
#define __dwFILE_CERTUTIL_MISC_CPP__		310
#define __dwFILE_CERTUTIL_ODBC_CPP__		311
#define __dwFILE_CERTUTIL_REG_CPP__		312
#define __dwFILE_CERTUTIL_STORE_CPP__		313
#define __dwFILE_CERTUTIL_TCAINFO_CPP__		314
#define __dwFILE_CERTUTIL_VERIFY_CPP__		315
#define __dwFILE_CERTUTIL_VIEW_CPP__		316

#define __dwFILE_CERTLIB_INF_CPP__		401
#define __dwFILE_CERTLIB_LOG_CPP__		402
//#define __dwFILE_CERTLIB_CERTMSG_CPP__	403
#define __dwFILE_CERTLIB_ACL_CPP__		404
#define __dwFILE_CERTLIB_ADMIN_CPP__		405
#define __dwFILE_CERTLIB_ADVAPI32_CPP__		406
#define __dwFILE_CERTLIB_BACKUP_CPP__		407
#define __dwFILE_CERTLIB_BASE64_CPP__		408
#define __dwFILE_CERTLIB_CASD_CPP__		409
#define __dwFILE_CERTLIB_CERTLIB_CPP__		410
#define __dwFILE_CERTLIB_CERTPICK_CPP__		411
#define __dwFILE_CERTLIB_CERTSD_CPP__		412
#define __dwFILE_CERTLIB_CHECK7F_CPP__		413
#define __dwFILE_CERTLIB_CIEXIT_CPP__		414
#define __dwFILE_CERTLIB_CIPOLICY_CPP__		415
#define __dwFILE_CERTLIB_CNFGSTG_CPP__		416
#define __dwFILE_CERTLIB_CONFIG_CPP__		417
#define __dwFILE_CERTLIB_CRFILE_CPP__		418
#define __dwFILE_CERTLIB_CRYPT_CPP__		419
#define __dwFILE_CERTLIB_CSCSP_CPP__		420
#define __dwFILE_CERTLIB_CSLISTVW_CPP__		421
#define __dwFILE_CERTLIB_CSPELOG_CPP__		422
#define __dwFILE_CERTLIB_CSW97PPG_CPP__		423
#define __dwFILE_CERTLIB_CSW97SHT_CPP__		424
#define __dwFILE_CERTLIB_DCOM_CPP__		425
#define __dwFILE_CERTLIB_DISPATCH_CPP__		426
#define __dwFILE_CERTLIB_HEX_CPP__		427
#define __dwFILE_CERTLIB_KEYGEN2_CPP__		428
#define __dwFILE_CERTLIB_LDAP_CPP__		429
#define __dwFILE_CERTLIB_MANAGE_CPP__		430
#define __dwFILE_CERTLIB_MAPI_CPP__		431
#define __dwFILE_CERTLIB_OFFICER_CPP__		432
#define __dwFILE_CERTLIB_PKIFMT_CPP__		433
#define __dwFILE_CERTLIB_PROGRESS_CPP__		434
#define __dwFILE_CERTLIB_PROP2_CPP__		435
#define __dwFILE_CERTLIB_PRVLG_CPP__		436
#define __dwFILE_CERTLIB_REG_CPP__		437
#define __dwFILE_CERTLIB_REQUEST_CPP__		438
#define __dwFILE_CERTLIB_STRING_CPP__		439
#define __dwFILE_CERTLIB_TFC_CPP__		440
#define __dwFILE_CERTLIB_TFCPROP_CPP__		441
#define __dwFILE_CERTLIB_TMPLLIST_CPP__		442
#define __dwFILE_CERTLIB_VIEW_CPP__		443
#define __dwFILE_CERTLIB_VIEWATTR_CPP__		444
#define __dwFILE_CERTLIB_VIEWCOL_CPP__		445
#define __dwFILE_CERTLIB_VIEWEXT_CPP__		446
#define __dwFILE_CERTLIB_VIEWROW_CPP__		447

#define __dwFILE_CERTSRV_ADMIN_CPP__		501
#define __dwFILE_CERTSRV_CALLBACK_CPP__		502
#define __dwFILE_CERTSRV_CERTSRV_CPP__		503
#define __dwFILE_CERTSRV_CERTSRVD_CPP__		504
#define __dwFILE_CERTSRV_CIENUM_CPP__		505
#define __dwFILE_CERTSRV_COM_CPP__		506
#define __dwFILE_CERTSRV_COMTEST_CPP__		507
#define __dwFILE_CERTSRV_CORE_CPP__		508
#define __dwFILE_CERTSRV_CRL_CPP__		509
#define __dwFILE_CERTSRV_DB3_CPP__		510
#define __dwFILE_CERTSRV_ELOG_CPP__		511
#define __dwFILE_CERTSRV_EVENT_CPP__		512
#define __dwFILE_CERTSRV_PKCS_CPP__		513
#define __dwFILE_CERTSRV_PROP_CPP__		514
#define __dwFILE_CERTSRV_REQUEST_CPP__		515
#define __dwFILE_CERTSRV_RPC_CPP__		516
#define __dwFILE_CERTSRV_SERVICE_CPP__		517

#define __dwFILE_CERTADM_ADMIN_CPP__		601
#define __dwFILE_CERTADM_ATL_CPP__		602
#define __dwFILE_CERTADM_BACKUP_CPP__		603
#define __dwFILE_CERTADM_CERTADM_CPP__		604
#define __dwFILE_CERTADM_MANAGE_CPP__		605
#define __dwFILE_CERTADM_RESTORE_CPP__		606

#define __dwFILE_CERTCLI_ATL_CPP__		701
#define __dwFILE_CERTCLI_CERTCLI_CPP__		702
#define __dwFILE_CERTCLI_COLUMN_CPP__		703
#define __dwFILE_CERTCLI_CONFIG_CPP__		704
#define __dwFILE_CERTCLI_CONFIGP_CPP__		705
#define __dwFILE_CERTCLI_CRYPT_CPP__		706
#define __dwFILE_CERTCLI_GETCONF_CPP__		707
#define __dwFILE_CERTCLI_REQUEST_CPP__		708
#define __dwFILE_CERTCLI_UWBASE64_CPP__		709
#define __dwFILE_CERTCLI_VROOT_CPP__		710

#define __dwFILE_CERTCLIB_ALLOC_CPP__		801
#define __dwFILE_CERTCLIB_ASSERT_CPP__		802
#define __dwFILE_CERTCLIB_AUTOENRL_CPP__	803
#define __dwFILE_CERTCLIB_CAINFO_CPP__		804
#define __dwFILE_CERTCLIB_CAINFOC_CPP__		805
#define __dwFILE_CERTCLIB_CAINFOP_CPP__		806
#define __dwFILE_CERTCLIB_CERTDEC_CPP__		807
#define __dwFILE_CERTCLIB_CERTTYPE_CPP__	808
#define __dwFILE_CERTCLIB_CTNOTIFY_CPP__	809
#define __dwFILE_CERTCLIB_DEBUG_CPP__		810
#define __dwFILE_CERTCLIB_DEFTYPES_CPP__	811
#define __dwFILE_CERTCLIB_DSTEST_CPP__		812
#define __dwFILE_CERTCLIB_ERROR_CPP__		813
#define __dwFILE_CERTCLIB_LOGON_CPP__		814
#define __dwFILE_CERTCLIB_OIDMGR_CPP__		815
#define __dwFILE_CERTCLIB_SERIAL_CPP__		816

#define __dwFILE_CERTMMC_ABOUT_CPP__		901
#define __dwFILE_CERTMMC_BROWSEDI_CPP__		902
#define __dwFILE_CERTMMC_CASEC_CPP__		903
#define __dwFILE_CERTMMC_CERTIF_CPP__		904
#define __dwFILE_CERTMMC_CERTWRAP_CPP__		905
#define __dwFILE_CERTMMC_CHOOSER_CPP__		906
#define __dwFILE_CERTMMC_COMPDATA_CPP__		907
#define __dwFILE_CERTMMC_CSNAPIN_CPP__		908
#define __dwFILE_CERTMMC_DATAOBJ_CPP__		909
#define __dwFILE_CERTMMC_EVENTS_CPP__		910
#define __dwFILE_CERTMMC_FOLDERS_CPP__		911
#define __dwFILE_CERTMMC_GENPAGE_CPP__		912
#define __dwFILE_CERTMMC_KRAPAGE_CPP__		913
#define __dwFILE_CERTMMC_MISC_CPP__		914
#define __dwFILE_CERTMMC_OFFICER_CPP__		915
#define __dwFILE_CERTMMC_SNAPIN_CPP__		916
#define __dwFILE_CERTMMC_URLS_CPP__		917
#define __dwFILE_CERTMMC_UUIDS_CPP__		918

#define __dwFILE_POLICY_DEFAULT_ATL_CPP__	1001
#define __dwFILE_POLICY_DEFAULT_CERTPDEF_CPP__	1002
#define __dwFILE_POLICY_DEFAULT_MODULE_CPP__	1003
#define __dwFILE_POLICY_DEFAULT_POLICY_CPP__	1004
#define __dwFILE_POLICY_DEFAULT_REQUEST_CPP__	1005
#define __dwFILE_POLICY_DEFAULT_TEMPLATE_CPP__	1006

#define __dwFILE_CERTDB_ATL_CPP__		1101
#define __dwFILE_CERTDB_BACKUP_CPP__		1102
#define __dwFILE_CERTDB_CERTDB_CPP__		1103
#define __dwFILE_CERTDB_COLUMN_CPP__		1104
#define __dwFILE_CERTDB_DB_CPP__		1105
#define __dwFILE_CERTDB_DBTABLE_CPP__		1106
#define __dwFILE_CERTDB_DBW_CPP__		1107
#define __dwFILE_CERTDB_ENUM_CPP__		1108
#define __dwFILE_CERTDB_PCH_CPP__		1109
#define __dwFILE_CERTDB_RESTORE_CPP__		1110
#define __dwFILE_CERTDB_ROW_CPP__		1111
#define __dwFILE_CERTDB_VIEW_CPP__		1112

#define __dwFILE_CERTVIEW_ATTRIB_CPP__		1201
#define __dwFILE_CERTVIEW_CERTVIEW_CPP__	1202
#define __dwFILE_CERTVIEW_COLUMN_CPP__		1203
#define __dwFILE_CERTVIEW_EXT_CPP__		1204
#define __dwFILE_CERTVIEW_PCH_CPP__		1205
#define __dwFILE_CERTVIEW_ROW_CPP__		1206
#define __dwFILE_CERTVIEW_VIEW_CPP__		1207
#define __dwFILE_CERTLIB_POLDISP_CPP__		1208
#define __dwFILE_CERTLIB_EXITDISP_CPP__		1209

#endif // __CSFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csldap.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csldap.h
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#ifndef __CSLDAP_H__
#define __CSLDAP_H__

#define csecLDAPTIMEOUT	(2 * 60)	// two minute default search timeout

#define wszDSBASECRLATTRIBUTE		L"certificateRevocationList"
#define wszDSDELTACRLATTRIBUTE		L"deltaRevocationList"
#define wszDSUSERCERTATTRIBUTE		L"userCertificate"
#define wszDSCROSSCERTPAIRATTRIBUTE	L"crossCertificatePair"
#define wszDSKRACERTATTRIBUTE		wszDSUSERCERTATTRIBUTE
#define wszDSCACERTATTRIBUTE		L"cACertificate"
#define wszDSBASECRLATTRIBUTE		L"certificateRevocationList"
#define wszDSAUTHORITYCRLATTRIBUTE	L"authorityRevocationList"
#define wszDSOBJECTCLASSATTRIBUTE	L"objectClass"
#define wszDSFLAGSATTRIBUTE		L"flags"

#define wszDSBASESEARCH		L"?base"
#define wszDSONESEARCH		L"?one"

#define wszDSTOPCLASSNAME	L"top"
#define wszDSPERSONCLASSNAME	L"person"
#define wszDSORGPERSONCLASSNAME	L"organizationalPerson"
#define wszDSUSERCLASSNAME	L"user"
#define wszDSCONTAINERCLASSNAME L"container"
#define wszDSENROLLMENTSERVICECLASSNAME L"pKIEnrollmentService"
#define wszDSMACHINECLASSNAME	L"machine"
#define wszDSTEMPLATELASSNAME	L"pKICertificateTemplate"
#define wszDSKRACLASSNAME	L"msPKI-PrivateKeyRecoveryAgent"
#define wszDSCDPCLASSNAME	L"cRLDistributionPoint"
#define wszDSOIDCLASSNAME	L"msPKI-Enterprise-Oid"
#define wszDSCACLASSNAME	L"certificationAuthority"
#define wszDSAIACLASSNAME	wszDSCACLASSNAME

#define wszDSCDPCLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSCDPCLASSNAME
#define wszDSCACLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSCACLASSNAME
#define wszDSUSERCLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=*"
#define wszDSKRACLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSKRACLASSNAME
#define wszDSAIACLASS	L"?" wszDSOBJECTCLASSATTRIBUTE L"=" wszDSAIACLASSNAME

#define wszDSSEARCHBASECRLATTRIBUTE \
    L"?" \
    wszDSBASECRLATTRIBUTE \
    wszDSBASESEARCH \
    wszDSCDPCLASS

#define wszDSSEARCHDELTACRLATTRIBUTE \
    L"?" \
    wszDSDELTACRLATTRIBUTE \
    wszDSBASESEARCH \
    wszDSCDPCLASS

#define wszDSSEARCHUSERCERTATTRIBUTE \
    L"?" \
    wszDSUSERCERTATTRIBUTE \
    wszDSBASESEARCH \
    wszDSUSERCLASS

#define wszDSSEARCHCACERTATTRIBUTE \
    L"?" \
    wszDSCACERTATTRIBUTE \
    wszDSBASESEARCH \
    wszDSCACLASS

#define wszDSSEARCHKRACERTATTRIBUTE \
    L"?" \
    wszDSUSERCERTATTRIBUTE \
    wszDSONESEARCH \
    wszDSKRACLASS

#define wszDSSEARCHCROSSCERTPAIRATTRIBUTE \
    L"?" \
    wszDSCROSSCERTPAIRATTRIBUTE \
    wszDSONESEARCH \
    wszDSAIACLASS

#define wszDSSEARCHAIACERTATTRIBUTE \
    L"?" \
    wszDSCACERTATTRIBUTE \
    wszDSONESEARCH \
    wszDSAIACLASS

#define wszDSKRAQUERYTEMPLATE		\
    L"ldap:///CN=KRA,"			\
	L"CN=Public Key Services,"	\
	L"CN=Services,"			\
	wszFCSAPARM_CONFIGDN		\
	wszDSSEARCHKRACERTATTRIBUTE

#define wszDSAIAQUERYTEMPLATE		\
    L"ldap:///CN=AIA,"			\
	L"CN=Public Key Services,"	\
	L"CN=Services,"			\
	wszFCSAPARM_CONFIGDN		\
	wszDSSEARCHAIACERTATTRIBUTE

// Default URL Template Values:

extern WCHAR const g_wszzLDAPIssuerCertURLTemplate[];
extern WCHAR const g_wszzLDAPKRACertURLTemplate[];
extern WCHAR const g_wszzLDAPRevocationURLTemplate[];
extern WCHAR const g_wszASPRevocationURLTemplate[];

extern WCHAR const g_wszLDAPNTAuthURLTemplate[];
extern WCHAR const g_wszLDAPRootTrustURLTemplate[];

extern WCHAR const g_wszCDPDNTemplate[];
extern WCHAR const g_wszAIADNTemplate[];
extern WCHAR const g_wszKRADNTemplate[];

extern WCHAR const g_wszHTTPRevocationURLTemplate[];
extern WCHAR const g_wszFILERevocationURLTemplate[];
extern WCHAR const g_wszHTTPIssuerCertURLTemplate[];
extern WCHAR const g_wszFILEIssuerCertURLTemplate[];

// Default Server Controls:

extern LDAPControl *g_rgLdapControls[];

HRESULT
myGetAuthoritativeDomainDn(
    IN LDAP *pld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN);

HRESULT
myDomainFromDn(
    IN WCHAR const *pwszDN,
    OUT WCHAR **ppwszDomainDNS);

HRESULT
myLdapOpen(
    OUT LDAP **ppld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN);

VOID
myLdapClose(
    OPTIONAL IN LDAP *pld,
    OPTIONAL IN BSTR strDomainDN,
    OPTIONAL IN BSTR strConfigDN);

BOOL
myLdapRebindRequired(
    IN ULONG ldaperrParm,
    OPTIONAL IN LDAP *pld);

HRESULT
myLdapGetDSHostName(
    IN LDAP *pld,
    OUT WCHAR **ppwszHostName);

HRESULT
myLdapCreateContainer(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN BOOL  fSkipObject,       // Does the DN contain a leaf object name
    IN DWORD cMaxLevel,         // create this many nested containers as needed
    IN PSECURITY_DESCRIPTOR pContainerSD,
    OPTIONAL OUT WCHAR **ppwszError);

#define LPC_CAOBJECT		0x00000000
#define LPC_KRAOBJECT		0x00000001
#define LPC_USEROBJECT		0x00000002
#define LPC_MACHINEOBJECT	0x00000003
#define LPC_OBJECTMASK		0x0000000f

#define LPC_CREATECONTAINER	0x00000100
#define LPC_CREATEOBJECT	0x00000200

HRESULT
myLdapPublishCertToDS(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    IN DWORD dwObjectType,	// LPC_*
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapPublishCRLToDS(
    IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateCAObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateCDPObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateUserObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    IN DWORD dwObjectType,	// LPC_* (but LPC_CREATE* is ignored)
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapCreateOIDObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN DWORD dwType,
    IN WCHAR const *pwszObjId,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myLdapOIDIsMatchingLangId(
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwLanguageId,
    OUT BOOL *pfLangIdExists);

HRESULT
myLdapAddOIDDisplayNameToAttribute(
    IN LDAP *pld,
    OPTIONAL IN WCHAR **ppwszDisplayNames,
    IN DWORD dwLanguageId,
    IN WCHAR const *pwszDisplayName,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapError(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapError2(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapError3(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    IN ULONG ldaperrParmQuiet2,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
myHLdapLastError(
    OPTIONAL IN LDAP *pld,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT
AddCertToAttribute(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

HRESULT myLDAPSetStringAttribute(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    IN WCHAR const *pwszValue,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError);

#endif // __CSLDAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csbjet.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csbjet.h
//
// Contents:    Cert Server database backup/restore APIs
//
//---------------------------------------------------------------------------

#ifndef	__CSBJET_H__
#define	__CSBJET_H__

//#include <dsjet.h>
#ifndef	MIDL_PASS
//#include <jetbak.h>
#endif
//#include <nspapi.h>

// MIDL 2.0 switched the names of the generated server interface globals (why!?).
// This hack so that we only have to change one place.
// Parameters are interface name, major and minor version numbers.
#if   (_MSC_VER > 800)
#define ServerInterface(s, vMaj, vMin)	s##_v##vMaj##_##vMin##_s_ifspec
#define ClientInterface(s, vMaj, vMin)	s##_v##vMaj##_##vMin##_c_ifspec
#else
#define ServerInterface(s, vMaj, vMin)	s##_ServerIfHandle
#define ClientInterface(s, vMaj, vMin)	s##_ClientIfHandle
#endif

#define JetBack_ClientIfHandle ClientInterface(ICertDBBackup, 1, 0)
#define JetBack_ServerIfHandle ServerInterface(s_ICertDBBackup, 1, 0)

#define JetRest_ClientIfHandle ClientInterface(ICertDBRestore, 1, 0)
#define JetRest_ServerIfHandle ServerInterface(s_ICertDBRestore, 1, 0)

#define	MAX_SOCKETS	10

#define wszRESTORE_IN_PROGRESS		L"\\Restore in Progress"
#define wszRESTORE_STATUS		L"RestoreStatus"
#define wszBACKUP_LOG_PATH		L"BackupLogPath"
#define wszCHECKPOINT_FILE_PATH		L"CheckpointFilePath"
#define wszLOG_PATH			L"LogPath"
#define wszHIGH_LOG_NUMBER		L"HighLog Number"
#define wszLOW_LOG_NUMBER		L"LowLog Number"
#define wszJET_RSTMAP_NAME		L"Certificate_Server_NTDS_RstMap"
#define wszJET_RSTMAP_SIZE		L"Certificate_Server_NTDS_RstMap Size"
#define wszJET_DATABASE_RECOVERED	L"Certificate_Server_NTDS Database recovered"
#define wszBACKUP_INFO			L"SYSTEM\\CurrentControlSet\\Services\\CertSvc\\Configuration\\BackupInformation\\"
#define wszLAST_BACKUP_LOG		L"Last Backup Log"
#define wszDISABLE_LOOPBACK		L"DisableLoopback"
#define wszENABLE_TRACE			L"Enable Trace"

// Sockets protocol value.
typedef INT PROTVAL;

#define	wszLOOPBACKED_READ_EVENT_NAME		L"Certificate Server Backup Loopbacked Read Event - %d"
#define	wszLOOPBACKED_WRITE_EVENT_NAME		L"Certificate Server Backup Loopbacked Write Event - %d"
#define	wszLOOPBACKED_CRITSEC_MUTEX_NAME	L"Certificate Server Backup Loopbacked Critical Section - %d"
#define	wszLOOPBACKED_SHARED_REGION		L"Certificate Server Backup Shared Memory Region - %d"

#define	READAHEAD_MULTIPLIER		5

#ifdef	DEBUG
#define	BACKUP_WAIT_TIMEOUT		10*60*1000
#else
#define	BACKUP_WAIT_TIMEOUT		2*60*1000
#endif

typedef volatile struct {
    DWORD   cbSharedBuffer;
    DWORD   cbPage;			// Convenient place to store page size
    DWORD   dwReadPointer;		// Read offset within shared buffer.
    DWORD   dwWritePointer;		// Write offset within buffer.
    LONG    cbReadDataAvailable;	// Number of bytes of data available.
    HRESULT hrApi;			// Status of API - used to communicate to server if client fails.
    BOOLEAN fReadBlocked;		// Read operation is blocked
    BOOLEAN fWriteBlocked;		// Write operation is blocked
} JETBACK_SHARED_HEADER;


typedef struct {
    HANDLE		   hSharedMemoryMapping;
    HANDLE		   heventRead;
    HANDLE		   heventWrite;
    HANDLE		   hmutexSection;
    JETBACK_SHARED_HEADER *pjshSection;
} JETBACK_SHARED_CONTROL;


// Client side context.

typedef struct _CSBACKUPCONTEXT {
    handle_t	hBinding;
    HCSCTX	csctx;
    BOOLEAN	fLoopbacked;
    BOOLEAN	fUseSockets;
    BOOLEAN	fUseSharedMemory;

    // Socket support.

    SOCKET	rgsockSocketHandles[MAX_SOCKETS];
    PROTVAL	rgprotvalProtocolsUsed[MAX_SOCKETS];
    LONG	cSockets;
    SOCKET	sock;
    HANDLE	hReadThread;
    DWORD	tidThreadId;
    HANDLE	hPingThread;	 // Keep alive thread for loopbacked backups.
    DWORD	tidThreadIdPing; // And thread ID for that thread.
    HRESULT	hrApiStatus;

    // Shared memory support.

    JETBACK_SHARED_CONTROL jsc;
} CSBACKUPCONTEXT;


#if 0
typedef DWORD
(*PRESTORE_DATABASE_LOCATIONS)(
	OUT CHAR rgLocationBuffer[],
	OUT PULONG pulLocationSize,
	OUT char rgRegistryBase[],
	OUT ULONG cbRegistryBase,
	OUT BOOL *pfCircularLogging);

typedef DWORD
(*PRESTORE_PERFORM_RESTORE)(
	CHAR *pszLogPath,
	CHAR *pszBackupLogPath,
	LONG crstmap,
	JET_RSTMAP rgrstmap[]);
#endif

// Server side context binding - the server context handle points to a
// structure containing this information.

typedef struct _JETBACK_SERVER_CONTEXT {
    BOOL fRestoreOperation;
    union {
	struct {
	    //JET_HANDLE	  hFile;
	    HANDLE	  hFile;
	    BOOL	  fHandleIsValid;
	    LONG	  cbReadHint;
	    SOCKET	  sockClient;
	    LARGE_INTEGER liFileSize;
	    DWORD	  dwHighestLogNumber;
	    WCHAR	 *pwszBackupAnnotation;
	    DWORD	  dwFileSystemGranularity;
	    BOOLEAN	  fUseSockets;
	    BOOLEAN	  fUseSharedMemory;
	    BOOLEAN	  fBackupIsRegistered;

	    // Client identifer used to identify the client to the server - we
	    // use this when opening the shared memory segment on local backup.

	    DWORD	  dwClientIdentifier;
	    JETBACK_SHARED_CONTROL jsc;
	} Backup;
	struct {
	    BOOL	  fJetCompleted;
	    LONG	  cUnitDone;
	    LONG	  cUnitTotal;
	} Restore;
    } u;
} JETBACK_SERVER_CONTEXT;

// Server side private routines.

VOID
GetCurrentSid(
    PSID *ppsid);

BOOL
FBackupServerAccessCheck(
    BOOL fRestoreOperation);

DWORD
ErrAdjustRestorePrivelege(
    BOOL fEnable,
    PTOKEN_PRIVILEGES ptpPrevious,
    DWORD *pcbptpPrevious);

#if 0
HRESULT
HrFromJetErr(
    JET_ERR jetError);
#endif

HRESULT
HrDestroyCxh(
    HCSCTX csctx);

BOOL
FIsAbsoluteFileName(
    CHAR *pszFileName);

HRESULT
HrAnnotateMungedFileList(
    JETBACK_SERVER_CONTEXT *pjsc,
    WCHAR *wszFileList,
    LONG cbFileList,
    WCHAR **pwszAnnotatedList,
    LONG *pcbAnnotatedList);

HRESULT
HrMungedFileNamesFromJetFileNames(
    WCHAR **ppwszMungedList,
    LONG *pcbSize,
    CHAR *pszJetAttachmentList,
    LONG cbJetSize,
    BOOL fAnnotated);

HRESULT
HrMungedFileNameFromJetFileName(
    CHAR *pszJetFileName,
    WCHAR **ppwszMungedFileName);

HRESULT
HrJetFileNameFromMungedFileName(
    WCHAR *pwszMungedList,
    CHAR **ppszJetFileName);

VOID
RestoreRundown(
    JETBACK_SERVER_CONTEXT *pjsc);


// Client side private routines.

HRESULT
HrCreateRpcBinding(
    IN LONG iszProtoseq,
    IN WCHAR const *pwszServer,
    OUT handle_t *phBinding);

HRESULT
HrJetbpConnectToBackupServer(
    WCHAR *pwszBackupServer,
    WCHAR *pwszBackupAnnotation,
    RPC_IF_HANDLE rifHandle,
    RPC_BINDING_HANDLE *prbhBinding);

BOOL
FBackupClientAccessCheck(
    BOOL fRestoreOperation);

BOOL
FIsInBackupGroup(
    BOOL fRestoreOperation);

extern WCHAR *g_apszProtSeq[];
extern long g_cProtSeq;

BOOL
FInitializeRestore();

BOOL
FUninitializeRestore();


// Sockets related APIs and prototypes.

HRESULT
HrCreateBackupSockets(
    SOCKET rgsockSocketHandles[],
    PROTVAL rgprotvalProtocolsUsed[],
    LONG *pcSocketHandles);

SOCKET
SockWaitForConnections(
    SOCKET rgsockSocketHandles[],
    LONG cSocketMax);

SOCKET
SockConnectToRemote(
    SOCKADDR rgsockaddrClient[],
    LONG cSocketMax);

HRESULT
HrSockAddrsFromSocket(
    OUT SOCKADDR sockaddr[],
    OUT LONG *pcSockets,
    IN SOCKET sock,
    IN PROTVAL protval);


BOOL
FInitializeSocketClient();

BOOL
FInitializeSocketServer();

BOOL
FUninitializeSocketClient();

BOOL
FUninitializeSocketServer();

HRESULT
I_HrRestoreW(
    HCSBC hcsbc,
    WCHAR *pwszCheckpointFilePath,
    WCHAR *pwszLogPath,
    CSEDB_RSTMAPW __RPC_FAR rgrstmap[],
    LONG crstmap,
    WCHAR *pwszBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh,
    BOOLEAN *pfRecoverJetDatabase);

HRESULT
I_HrCheckBackupLogs(
    WCHAR *wszBackupAnnotation);


BOOLEAN
FIsLoopbackedBinding(
    RPC_BINDING_HANDLE hBinding);

BOOLEAN
FCreateSharedMemorySection(
    JETBACK_SHARED_CONTROL *pjsc,
    DWORD dwClientIdentifier,
    BOOLEAN fClientOperation,
    LONG cbSharedMemory);

VOID
CloseSharedControl(
    JETBACK_SHARED_CONTROL *pjsc);

#if DBG
BOOL GetTextualSid(
    PSID pSid,		  // binary Sid
    LPTSTR TextualSid,	  // buffer for Textual representaion of Sid
    LPDWORD dwBufferLen); // required/provided TextualSid buffersize

VOID
OpenTraceLogFile(VOID);

BOOL
FInitializeTraceLog(VOID);

VOID
UninitializeTraceLog(VOID);

NET_API_STATUS
TruncateLog(VOID);
#endif // DBG

#define hrCommunicationError CO_E_REMOTE_COMMUNICATION_FAILURE
#define hrCouldNotConnect HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED)

#endif	// __CSBJET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csdisp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       csdisp.h
//
//  Contents:   IDispatch helper functions
//
//  History:    09-Dec-96   vich    created
//
//--------------------------------------------------------------------------

#ifndef __CSDISP_H__
#define __CSDISP_H__

typedef struct _DISPATCHTABLE
{
    OLECHAR **apszNames;
    DWORD     cdispid;
    DWORD     idispid;
} DISPATCHTABLE;

class DISPATCHINTERFACE
{
public:
    DISPATCHINTERFACE()
    {
	pDispatch = NULL;
	pUnknown = NULL;
	pDispatchTable = NULL;
	m_cDispatchTable = 0;
	m_fiidValid = FALSE;
	m_adispid = NULL;
	m_dwVersion = 0;
    }

    VOID SetIID(
	OPTIONAL IN IID const *piid)
    {
	if (NULL != piid)
	{
	    m_iid = *piid;
	    m_fiidValid = TRUE;
	}
    }

    IID const *GetIID() { return(m_fiidValid? &m_iid : NULL); }

    IDispatch     *pDispatch;
    IUnknown      *pUnknown;
    DISPATCHTABLE *pDispatchTable;
    DWORD          m_cDispatchTable;
    DWORD          m_cdispid;
    DISPID        *m_adispid;
    DWORD	   m_dwVersion;
    DWORD	   m_ClassContext;

private:
    IID	           m_iid;
    BOOL           m_fiidValid;
};


#define DECLARE_DISPATCH_ENTRY(apszMethod) \
    { apszMethod, ARRAYSIZE(apszMethod), },


// DispatchSetup Flags:
#define DISPSETUP_COM		0x00000000
#define DISPSETUP_IDISPATCH	0x00000001
#define DISPSETUP_COMFIRST	0x00000002	// Try COM, then IDispatch

HRESULT
DispatchInvoke(
    IN DISPATCHINTERFACE *pDispatchInterface,
    IN LONG MethodIndex,
    IN DWORD cvar,
    IN VARIANT avar[],
    IN LONG Type,
    OPTIONAL OUT VOID *pretval);

HRESULT
DispatchGetReturnValue(
    IN OUT VARIANT *pvar,
    IN LONG Type,
    OUT VOID *pretval);

HRESULT
DispatchGetIds(
    IN IDispatch *pDispatch,
    IN DWORD cDispatchTable,
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

HRESULT
DispatchSetup(
    IN DWORD Flags,
    IN DWORD ClassContext,
    OPTIONAL IN TCHAR const *pszProgID,	        // for IDispatch
    OPTIONAL IN CLSID const *pclsid,		// for COM
    OPTIONAL IN IID const *piid,		// for COM
    IN DWORD cDispatchTable,
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

HRESULT
DispatchSetup2(
    IN DWORD Flags,
    IN DWORD ClassContext,
    IN WCHAR const *pwszClass,		// wszRegKeyAdminClsid
    IN CLSID const *pclsid,
    IN DWORD cver,
    IN IID const * const *ppiid,	// cver elements
    IN DWORD const *pcDispatch,		// cver elements
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

VOID
DispatchRelease(
    IN OUT DISPATCHINTERFACE *pDispatchInterface);

HRESULT
DispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid);

// Temporary:
#define ConvertWszToBstr	myConvertWszToBstr
#define ConvertSzToBstr		myConvertSzToBstr
#define ConvertWszToSz		myConvertWszToSz
#define ConvertSzToWsz		myConvertSzToWsz

BOOL
myConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb);

BOOL
myConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch);

//+-------------------------------------------------------------------------
// ICertConfig dispatch support

HRESULT
Config_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiConfig);

VOID
Config_Release(
    IN OUT DISPATCHINTERFACE *pdiConfig);

HRESULT
Config_Reset(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Index,
    OUT LONG *pcount);

HRESULT
Config_Next(
    IN DISPATCHINTERFACE *pdiConfig,
    OUT LONG *pcount);

HRESULT
Config_GetField(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszField,
    OUT BSTR *pbstr);

HRESULT
Config_GetConfig(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Flags,
    OUT BSTR *pbstrConfig);

HRESULT
Config2_SetSharedFolder(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszSharedFolder);


HRESULT
ConfigDump(
    IN DWORD Flags,				// See DispatchSetup() Flags
    IN WCHAR const *pwszEntry,			// localized L"Entry"
    OPTIONAL IN WCHAR const *pwszLocalSuffix,	// localized L"(Local)"
    OPTIONAL IN WCHAR const *pwszMach1,
    OPTIONAL IN WCHAR const *pwszMach2);

HRESULT
ConfigDumpSetDisplayNames(
    IN WCHAR const * const *apwszFieldNames,
    IN WCHAR const * const *apwszDisplayNames,
    IN DWORD cNames);

HRESULT
ConfigDumpEntry(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszEntry,                // localized L"Entry"
    IN LONG Index,  // less than 0 skip index, entry, & suffix print
    OPTIONAL IN WCHAR const *pwszSuffix);

HRESULT
ConfigGetConfig(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN DWORD dwDefault,     		// see CC_ defines in certcli.h
    OUT BSTR *pstrConfig);


//+-------------------------------------------------------------------------
// ICertRequest dispatch support

HRESULT
Request_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiRequest);

VOID
Request_Release(
    IN OUT DISPATCHINTERFACE *pdiRequest);

HRESULT
Request_Submit(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG Flags,
    IN WCHAR const *pwszRequest,
    IN DWORD cbRequest,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition);

HRESULT
Request_RetrievePending(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG RequestId,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition);

HRESULT
Request_GetLastStatus(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pLastStatus);

HRESULT
Request_GetRequestId(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pRequestId);

HRESULT
Request_GetDispositionMessage(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT BSTR *pstrMessage);

HRESULT
Request_GetCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD Flags,
    OUT BSTR *pstrCert);

HRESULT
Request_GetCACertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG fExchangeCertificate,
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OUT BSTR *pstrCert);

HRESULT
Request2_GetIssuedCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition);

HRESULT
Request2_GetErrorMessageText(
    IN LONG hrMessage,
    IN LONG Flags,
    OUT BSTR *pstrErrorMessageText);

HRESULT
Request2_GetCAProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);

HRESULT
Request2_GetCAPropertyFlags(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags);

HRESULT
Request2_GetCAPropertyDisplayName(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName);

HRESULT
Request2_GetFullResponseProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);


//+-------------------------------------------------------------------------
// ICertServerExit dispatch support

HRESULT
CIExit_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiCIExit);

VOID
CIExit_Release(
    IN OUT DISPATCHINTERFACE *pdiCIExit);

HRESULT
CIExit_SetContext(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Context);

HRESULT
CIExit_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIExit_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue);

HRESULT
CIExit_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIExit_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue);

HRESULT
CIExit_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT LONG *pExtFlags);

HRESULT
CIExit_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags);

HRESULT
CIExit_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrExtensionName);

HRESULT
CIExit_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIExit);

HRESULT
CIExit_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags);

HRESULT
CIExit_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrAttributeName);

HRESULT
CIExit_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIExit);


//+-------------------------------------------------------------------------
// ICertServerPolicy dispatch support


HRESULT
CIPolicy_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiCIPolicy);

VOID
CIPolicy_Release(
    IN OUT DISPATCHINTERFACE *pdiCIPolicy);

HRESULT
CIPolicy_SetContext(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Context);

HRESULT
CIPolicy_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIPolicy_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue);

HRESULT
CIPolicy_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue);

HRESULT
CIPolicy_SetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    IN WCHAR const *pwszPropValue);

HRESULT
CIPolicy_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue);

HRESULT
CIPolicy_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT LONG *pExtFlags);

HRESULT
CIPolicy_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG ExtFlags,
    IN void const *pvValue);

HRESULT
CIPolicy_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags);

HRESULT
CIPolicy_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrExtensionName);

HRESULT
CIPolicy_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIPolicy);

HRESULT
CIPolicy_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags);

HRESULT
CIPolicy_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrAttributeName);

HRESULT
CIPolicy_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIPolicy);


//+-------------------------------------------------------------------------
// ICertAdmin dispatch support

HRESULT
Admin_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiAdmin);

VOID
Admin_Release(
    IN OUT DISPATCHINTERFACE *pdiAdmin);

HRESULT
Admin_IsValidCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition);

HRESULT
Admin_GetRevocationReason(
    IN DISPATCHINTERFACE *pdiAdmin,
    OUT LONG *pReason);

HRESULT
Admin_RevokeCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date);

HRESULT
Admin_SetRequestAttributes(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszAttributes);

HRESULT
Admin_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG Flags,
    IN VARIANT const *pvarValue);

HRESULT
Admin_DenyRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId);

HRESULT
Admin_ResubmitRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    OUT LONG *pDisposition);

HRESULT
Admin_PublishCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date);

HRESULT
Admin_GetCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,
    OUT BSTR *pstrCRL);

HRESULT
Admin_ImportCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszCertificate,
    IN DWORD cbCertificate,
    IN LONG dwFlags,
    OUT LONG *RequestId);

HRESULT
Admin2_PublishCRLs(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date,
    IN LONG CRLFlags);		// CA_CRL_*

HRESULT
Admin2_GetCAProperty(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);

HRESULT
Admin2_SetCAProperty(
    IN WCHAR const *pwszConfig,
    IN LONG PropId,		// CR_PROP_*
    IN LONG PropIndex,
    IN LONG PropType,		// PROPTYPE_*
    IN VARIANT *pvarPropertyValue);

HRESULT
Admin2_GetCAPropertyFlags(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags);

HRESULT
Admin2_GetCAPropertyDisplayName(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName);

HRESULT
Admin2_GetArchivedKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,		// CR_OUT_*
    OUT BSTR *pstrArchivedKey);

HRESULT
Admin2_GetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    OUT VARIANT *pvarEntry);

HRESULT
Admin2_SetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    IN VARIANT const *pvarEntry);

HRESULT
Admin2_ImportKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszCertHash,
    IN LONG Flags,
    IN WCHAR const *pwszKey,
    IN DWORD cbKey);

HRESULT
Admin2_GetMyRoles(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    OUT LONG *pRoles);		// CA_ACCESS_*

HRESULT
Admin2_DeleteRow(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,		// CDR_*
    IN DATE Date,
    IN LONG Table,		// CVRC_TABLE_*
    IN LONG RowId,
    OUT LONG *pcDeleted);

HRESULT
AdminRevokeCertificate(
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date);

//+-------------------------------------------------------------------------
// ICertView dispatch support

HRESULT
View_Init(
    IN DWORD Flags,			// See DispatchSetup() Flags
    IN OUT DISPATCHINTERFACE *pdiView);

VOID
View_Release(
    IN OUT DISPATCHINTERFACE *pdiView);

HRESULT
View_OpenConnection(
    IN DISPATCHINTERFACE *pdiView,
    IN WCHAR const *pwszConfig);

HRESULT
View_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

HRESULT
View_GetColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    OUT LONG *pcColumn);

HRESULT
View_GetColumnIndex(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    IN WCHAR const *pwszColumnName,
    OUT LONG *pColumnIndex);

HRESULT
View_SetResultColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG cResultColumn);

HRESULT
View_SetResultColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex);

HRESULT
View_SetRestriction(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex,
    IN LONG SeekOperator,
    IN LONG SortOrder,
    IN VARIANT const *pvarValue);

HRESULT
View_OpenView(
    IN DISPATCHINTERFACE *pdiView,
    IN OUT DISPATCHINTERFACE *pdiViewRow);

HRESULT
View2_SetTable(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG Table);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWCOLUMN dispatch support

interface IEnumCERTVIEWCOLUMN;

HRESULT
ViewColumn_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWCOLUMN *pEnumColumn,
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

VOID
ViewColumn_Release(
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

HRESULT
ViewColumn_Next(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndex);

HRESULT
ViewColumn_GetName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut);

HRESULT
ViewColumn_GetDisplayName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut);

HRESULT
ViewColumn_GetType(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pType);

HRESULT
ViewColumn_IsIndexed(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndexed);

HRESULT
ViewColumn_GetMaxLength(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pMaxLength);

HRESULT
ViewColumn_GetValue(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG Flags,
    IN LONG ColumnType,
    OUT VOID *pColumnValue);

HRESULT
ViewColumn_Skip(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG celt);

HRESULT
ViewColumn_Reset(
    IN DISPATCHINTERFACE *pdiViewColumn);

HRESULT
ViewColumn_Clone(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN OUT DISPATCHINTERFACE *pdiViewColumnClone);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWATTRIBUTE dispatch support

interface IEnumCERTVIEWATTRIBUTE;

HRESULT
ViewAttribute_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWATTRIBUTE *pEnumAttribute,
    IN OUT DISPATCHINTERFACE *pdiViewAttribute);

VOID
ViewAttribute_Release(
    IN OUT DISPATCHINTERFACE *pdiViewAttribute);

HRESULT
ViewAttribute_Next(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT LONG *pIndex);

HRESULT
ViewAttribute_GetName(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut);

HRESULT
ViewAttribute_GetValue(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut);

HRESULT
ViewAttribute_Skip(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    IN LONG celt);

HRESULT
ViewAttribute_Reset(
    IN DISPATCHINTERFACE *pdiViewAttribute);

HRESULT
ViewAttribute_Clone(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    IN OUT DISPATCHINTERFACE *pdiViewAttributeClone);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWEXTENSION dispatch support

interface IEnumCERTVIEWEXTENSION;

HRESULT
ViewExtension_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWEXTENSION *pEnumExtension,
    IN OUT DISPATCHINTERFACE *pdiViewExtension);

VOID
ViewExtension_Release(
    IN OUT DISPATCHINTERFACE *pdiViewExtension);

HRESULT
ViewExtension_Next(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pIndex);

HRESULT
ViewExtension_GetName(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT BSTR *pstrOut);

HRESULT
ViewExtension_GetFlags(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pFlags);

HRESULT
ViewExtension_GetValue(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG Type,
    IN LONG Flags,
    OUT VOID *pValue);

HRESULT
ViewExtension_Skip(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG celt);

HRESULT
ViewExtension_Reset(
    IN DISPATCHINTERFACE *pdiViewExtension);

HRESULT
ViewExtension_Clone(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN OUT DISPATCHINTERFACE *pdiViewExtensionClone);


//+-------------------------------------------------------------------------
// IEnumCERTVIEWROW dispatch support

interface IEnumCERTVIEWROW;

HRESULT
ViewRow_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWROW *pEnumRow,
    IN OUT DISPATCHINTERFACE *pdiViewRow);

VOID
ViewRow_Release(
    IN OUT DISPATCHINTERFACE *pdiViewRow);

HRESULT
ViewRow_Next(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex);

HRESULT
ViewRow_GetMaxIndex(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex);

HRESULT
ViewRow_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN OUT DISPATCHINTERFACE *pdiViewColumn);

HRESULT
ViewRow_EnumCertViewAttribute(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    IN OUT DISPATCHINTERFACE *pdiViewAttribute);

HRESULT
ViewRow_EnumCertViewExtension(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    IN OUT DISPATCHINTERFACE *pdiViewExtension);

HRESULT
ViewRow_Skip(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG celt);

HRESULT
ViewRow_Reset(
    IN DISPATCHINTERFACE *pdiViewRow);

HRESULT
ViewRow_Clone(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN OUT DISPATCHINTERFACE *pdiViewRowClone);

//+-------------------------------------------------------------------------
// IManageModule dispatch support
HRESULT
ManageModule_Init(
    IN DWORD Flags,
    IN WCHAR const *pszProgID,
    IN CLSID const *pclsid,		
    IN OUT DISPATCHINTERFACE *pdiManage);

HRESULT
ManageModule_Init2(
    IN BOOL fIDispatch,
    IN ICertManageModule *pManage,
    OUT DISPATCHINTERFACE *pdiManage);

VOID
ManageModule_Release(
    IN OUT DISPATCHINTERFACE *pdiManage);

HRESULT
ManageModule_GetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG PropertyType,
    OUT VOID *pProperty);
 
HRESULT
ManageModule_SetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG PropertyType,
    IN VOID *pProperty);

HRESULT 
ManageModule_Configure( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
// ICertPolicy dispatch support

#define POLICY_VERIFYREQUEST    0
#define POLICY_GETDESCRIPTION   1
#define POLICY_INITIALIZE       2
#define POLICY_SHUTDOWN         3
#define POLICY2_GETMANAGEMODULE 4

#define CPOLICYDISPATCH_V1	POLICY2_GETMANAGEMODULE
#define CPOLICYDISPATCH_V2	CPOLICYDISPATCH

extern DWORD s_acPolicyDispatch[2];
extern IID const *s_apPolicyiid[2];
extern DISPATCHTABLE g_adtPolicy[];
extern DWORD CPOLICYDISPATCH;

HRESULT
Policy_Initialize(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig);

HRESULT
Policy_ShutDown(
    IN DISPATCHINTERFACE *pdiPolicy);

HRESULT
Policy_VerifyRequest(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig,
    IN LONG Context,
    IN LONG bNewRequest,
    IN LONG Flags,
    OUT LONG *pResult);

HRESULT
Policy_GetDescription(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT BSTR *pstrDescription);

HRESULT
Policy2_GetManageModule(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT DISPATCHINTERFACE *pdiManageModule);

HRESULT
Policy_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdiCIPolicy);

VOID
Policy_Release(
    IN OUT DISPATCHINTERFACE *pdiManage);

//+-------------------------------------------------------------------------
// ICertExit dispatch support

#define EXIT_INITIALIZE         0
#define EXIT_NOTIFY             1
#define EXIT_GETDESCRIPTION     2
#define EXIT2_GETMANAGEMODULE   3

#define CEXITDISPATCH_V1	EXIT2_GETMANAGEMODULE
#define CEXITDISPATCH_V2	CEXITDISPATCH

extern DISPATCHTABLE g_adtExit[];
extern DWORD CEXITDISPATCH;
extern DWORD s_acExitDispatch[2];
extern IID const *s_apExitiid[2];

HRESULT
Exit_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdi);

VOID
Exit_Release(
    IN OUT DISPATCHINTERFACE *pdiManage);

HRESULT
Exit_Initialize(
    IN DISPATCHINTERFACE *pdiExit,
    IN BSTR strDescription,
    IN WCHAR const *pwszConfig,
    OUT LONG *pEventMask);

HRESULT
Exit_Notify(
    IN DISPATCHINTERFACE *pdiExit,
    IN BSTR strDescription,
    IN LONG ExitEvent,
    IN LONG Context);

HRESULT
Exit_GetDescription(
    IN DISPATCHINTERFACE *pdiExit,
    OUT BSTR *pstrDescription);

HRESULT
Exit2_GetManageModule(
    IN DISPATCHINTERFACE *pdiExit,
    OUT DISPATCHINTERFACE *pdiManageModule);


#endif // __CSDISP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csmmchlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       csmmchlp.h
//
//--------------------------------------------------------------------------

#define CERTMMC_HELPFILENAME L"Certmmc.hlp"

#define	IDH_CM_MODULE_LIST	70008125
#define	IDH_CRL_COMBO_PERIODSTRING	70008176
#define	IDH_CRL_DISABLE_PUBLISH	70008178
#define	IDH_CRL_EDIT_LASTUPDATE	70008177
#define	IDH_CRL_EDIT_PERIODCOUNT	70008175
#define	IDH_CRL_VIEW_CRL	70008179
#define	IDH_DQ_ADD_RESTRICTION	70008201
#define	IDH_DQ_DELETE_RESTRICTION	70008202
#define	IDH_DQ_QUERY_LIST	70008200
#define	IDH_DQ_RESET_BUTTON	70008203
#define	IDH_ED_COMBO_REASON	70008250
#define	IDH_NR_EDIT_NEWQUERY_FIELD	70008225
#define	IDH_NR_EDIT_NEWQUERY_OPERATION	70008226
#define	IDH_NR_EDIT_NEWQUERY_VALUE	70008227
#define	IDH_NR_DATEPICKER_NEWQUERY	70008228
#define IDH_NR_TIMEPICKER_NEWQUERY	70008229
#define	IDH_PP_BUTTON_DN	70008102
#define	IDH_PP_BUTTON_UP	70008101
#define	IDH_PP_CHECK1	70008075
#define	IDH_PP_EDIT_DATABASE_LOC	70008077
#define	IDH_PP_EDIT_LOG_LOC	70008078
#define	IDH_PP_EDIT_SHAREDFOLDER	70008076
#define	IDH_PP_LIST_AVAILABLE	70008100
#define	IDH_PP1_CANAME	70008000
#define	IDH_PP1_CSP_NAME	70008003
#define	IDH_PP1_DESCRIPTION	70008001
#define	IDH_PP1_HASHALG	70008004
#define	IDH_PP1_VIEW_CERT	70008002
#define	IDH_PP2_ACTIVE_MODULE	70008210
#define	IDH_PP2_CONFIGURE	70008209
#define	IDH_PP2_COPYRIGHT	70008028
#define	IDH_PP2_DESCRIPTION	70008026
#define	IDH_PP2_MODULENAME	70008025
#define	IDH_PP2_VERSION	70008027
#define	IDH_PP3_ACTIVE_MODULE	70008058
#define	IDH_PP3_ADDBUTTON1	70008051
#define	IDH_PP3_CONFIGURE	70008057
#define	IDH_PP3_COPYRIGHT	70008056
#define	IDH_PP3_DESCRIPTION	70008054
#define	IDH_PP3_EDIT1	70008050
#define	IDH_PP3_MODULENAME	70008053
#define	IDH_PP3_REMOVEBUTTON4	70008052
#define	IDH_PP3_VERSION	70008055
#define	IDH_RESTORE_DEFOK2	70008103
#define	IDH_ADDURL_EDITURL	70008400
#define	IDH_CRL_ADD	70008426
#define	IDH_CRL_LIST	70008425
#define	IDH_CRL_REMOVE	70008427
#define	IDH_EXIT_CHECK_FILE	70008451
#define	IDH_EXIT2_CHECK_DS	70008450
#define	IDH_DA_RADIO_PENDFIRST	70008500
#define	IDH_DA_RADIO_ISSUE	70008501
#define	IDH_POL2_ADD_AIA	70008529
#define	IDH_POL2_ADD_CRL	70008526
#define	IDH_POL2_AIA_LIST	70008528
#define	IDH_POL2_CRL_LIST	70008525
#define	IDH_POL2_REMOVE_AIA	70008530
#define	IDH_POL2_REMOVE_CRL	70008527
#define IDH_RADIO_REUSEKEY	70008541
#define IDH_RADIO_NEWKEY	70008542
#define IDH_RADIO_DISABLEOFFICERS	70008543
#define IDH_RADIO_ENABLEOFFICERS	70008544
#define IDH_LIST_CERTMANAGERS	70008545
#define IDH_LIST_SUBJECTS	70008546
#define IDH_ALLOWDENY		70008547
#define IDH_ADDSUBJECT		70008548
#define IDH_REMOVESUBJECT	70008549
#define IDH_AUDIT_BACKUPRESTORE	70008550
#define IDH_AUDIT_CACONFIG	70008551
#define IDH_AUDIT_CASEC		70008552
#define IDH_AUDIT_CERTIFICATE	70008553
#define IDH_AUDIT_CRL		70008554
#define IDH_AUDIT_KEYARCHIVAL	70008555
#define IDH_AUDIT_STARTSTOP	70008556
#define IDH_KRA_DISABLE		70008557
#define IDH_KRA_ENABLE		70008558
#define IDH_KRA_EDITCOUNT	70008559
#define IDH_LIST_KRA		70008560
#define IDH_KRA_ADD		70008561
#define IDH_KRA_REMOVE		70008562
#define IDH_KRA_VIEW		70008563
#define IDH_CERTIFICATE_TYPE_LIST	70008564
#define IDH_CERTIFICATE_TEMPLATE_NAME	70008565
#define IDH_PURPOSE_LIST 	70008566
#define IDH_OTHER_INFO_LIST	70008567
#define IDH_PP1_LIST_CERTS      70008568
#define IDH_PP3_EXIT_LIST      	70008569
#define IDH_EXT_SELECT		70008570
#define IDH_ADDTOCERTCDP	70008571
#define IDH_ADDTOFRESHESTCRL	70008572
#define IDH_ADDTOCRLCDP 	70008573
#define IDH_ADDTOCERTOCSP	70008574
#define IDH_SERVERPUBLISH	70008575
#define IDH_PP_LIST_ATTR        70008576
#define	IDH_PP_LIST_EXTN        70008577
#define IDH_PP_EDIT_EXTN        70008578
#define IDH_COMBO_VARIABLE      70008579
#define IDH_BUTTON_INSERTVAR    70008580
#define IDH_EDIT_VARIABLEDESCRIPTION 70008581


#if defined (_CERTMMC_)

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE1[]=
{
	IDC_HASHALG,IDH_PP1_HASHALG,
	IDC_CANAME,IDH_PP1_CANAME,
	IDC_DESCRIPTION,IDH_PP1_DESCRIPTION,
	IDC_VIEW_CERT,IDH_PP1_VIEW_CERT,
	IDC_CSP_NAME,IDH_PP1_CSP_NAME,
        IDC_LIST_CERTS, IDH_PP1_LIST_CERTS,
	0, 0
};


const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE2[]=
{
	IDC_DESCRIPTION,IDH_PP2_DESCRIPTION,
	IDC_CONFIGURE,IDH_PP2_CONFIGURE,
	IDC_MODULENAME,IDH_PP2_MODULENAME,
	IDC_COPYRIGHT,IDH_PP2_COPYRIGHT,
	IDC_VERSION,IDH_PP2_VERSION,
	IDC_ACTIVE_MODULE,IDH_PP2_ACTIVE_MODULE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE3[]=
{
	IDC_ACTIVE_MODULE,IDH_PP3_ACTIVE_MODULE,
	IDC_EDIT1,IDH_PP3_EDIT1,
	IDC_BUTTON1,IDH_PP3_ADDBUTTON1,
	IDC_DESCRIPTION,IDH_PP3_DESCRIPTION,
	IDC_VERSION,IDH_PP3_VERSION,
	IDC_COPYRIGHT,IDH_PP3_COPYRIGHT,
	IDC_CONFIGURE,IDH_PP3_CONFIGURE,
	IDC_MODULENAME,IDH_PP3_MODULENAME,
	IDC_BUTTON4,IDH_PP3_REMOVEBUTTON4,
        IDC_EXIT_LIST,IDH_PP3_EXIT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE4[]=
{
//UNDONE, need to update IDH_POL2_CRL_LIST & work with doc team to get working id
	IDC_URL_REMOVE,IDH_POL2_CRL_LIST,
//	IDC_URL_REMOVE,IDH_URL_REMOVE,
//UNDONE, need to update IDH_POL2_ADD_CRL & work with doc team to get working id
	IDC_URL_ADD,IDH_POL2_ADD_CRL,
//	IDC_URL_ADD,IDH_URL_ADD,
//UNDONE, need to update IDH_POL2_CRL_LIST & work with doc team to get working id
	IDC_URL_LIST,IDH_POL2_CRL_LIST,
//	IDC_URL_LIST,IDH_URL_LIST,
	IDC_EXT_SELECT,IDH_EXT_SELECT,
	IDC_ADDTOCERTCDP,IDH_ADDTOCERTCDP,
	IDC_ADDTOFRESHESTCRL,IDH_ADDTOFRESHESTCRL,
	IDC_ADDTOCRLCDP,IDH_ADDTOCRLCDP,
	IDC_ADDTOCERTOCSP,IDH_ADDTOCERTOCSP,
	IDC_SERVERPUBLISH,IDH_SERVERPUBLISH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE5[]=
{
	IDC_CHECK1,IDH_PP_CHECK1,
	IDC_EDIT_SHAREDFOLDER,IDH_PP_EDIT_SHAREDFOLDER,
	IDC_EDIT_LOG_LOC,IDH_PP_EDIT_LOG_LOC,
	IDC_EDIT_DATABASE_LOC,IDH_PP_EDIT_DATABASE_LOC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ATTR_PROPPAGE[] = 
{
	IDC_LIST_ATTR,IDH_PP_LIST_ATTR,
	0, 0
};

const DWORD g_aHelpIDs_IDD_EXTN_PROPPAGE[] =
{
	IDC_LIST_EXTN,IDH_PP_LIST_EXTN,
        IDC_EDIT_EXTN,IDH_PP_EDIT_EXTN,
	0, 0
};


const DWORD g_aHelpIDs_IDD_CHOOSE_COLUMNS[]=
{
	IDC_LIST_AVAILABLE,IDH_PP_LIST_AVAILABLE,
	IDC_BUTTON_UP,IDH_PP_BUTTON_UP,
	IDC_BUTTON_DN,IDH_PP_BUTTON_DN,
	IDOK2,IDH_RESTORE_DEFOK2,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CHOOSE_MODULE[]=
{
	IDC_MODULE_LIST,IDH_CM_MODULE_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CRL_PROPPAGE[]=
{
	IDC_EDIT_CRLPERIODCOUNT,IDH_CRL_EDIT_PERIODCOUNT,
	IDC_COMBO_CRLPERIODSTRING,IDH_CRL_COMBO_PERIODSTRING,
	IDC_EDIT_LASTUPDATE,IDH_CRL_EDIT_LASTUPDATE,
	IDC_DISABLE_PUBLISH,IDH_CRL_DISABLE_PUBLISH,
	IDC_VIEW_CRL,IDH_CRL_VIEW_CRL,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CRL_VIEWPAGE[]=
{
//UNDONE, need to create IDH_CRL_VIEW_LIST_CRL
//    IDC_CRL_VIEW_LIST_CRL,      IDH_CRL_VIEW_LIST_CRL,
    IDC_CRL_VIEW_LIST_CRL,      IDH_CRL_VIEW_CRL,
//UNDONE, need to create IDH_CRL_VIEW_LIST_DELTA
//    IDC_CRL_VIEW_LIST_DELTA,    IDH_CRL_VIEW_LIST_DELTA,
    IDC_CRL_VIEW_LIST_DELTA,    IDH_CRL_VIEW_CRL,
//UNDONE, need to create IDH_CRL_VIEW_BTN_VIEWCRL
//    IDC_CRL_VIEW_BTN_VIEWCRL,   IDH_CRL_VIEW_BTN_VIEWCRL,
    IDC_CRL_VIEW_BTN_VIEWCRL,   IDH_CRL_VIEW_CRL,
//UNDONE, need to create IDH_CRL_VIEW_BTN_VIEWDELTA
//    IDC_CRL_VIEW_BTN_VIEWDELTA, IDH_CRL_VIEW_BTN_VIEWDELTA,
    IDC_CRL_VIEW_BTN_VIEWDELTA, IDH_CRL_VIEW_CRL,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DEFINE_QUERY[]=
{
	IDC_RESET_BUTTON,IDH_DQ_RESET_BUTTON,
	IDC_QUERY_LIST,IDH_DQ_QUERY_LIST,
	IDC_ADD_RESTRICTION,IDH_DQ_ADD_RESTRICTION,
	IDC_DELETE_RESTRICTION,IDH_DQ_DELETE_RESTRICTION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_NEW_RESTRICTION[]=
{
	IDC_EDIT_NEWQUERY_VALUE,IDH_NR_EDIT_NEWQUERY_VALUE,
	IDC_EDIT_NEWQUERY_FIELD,IDH_NR_EDIT_NEWQUERY_FIELD,
	IDC_EDIT_NEWQUERY_OPERATION,IDH_NR_EDIT_NEWQUERY_OPERATION,
	IDC_DATEPICKER_NEWQUERY, IDH_NR_DATEPICKER_NEWQUERY,
	IDC_TIMEPICKER_NEWQUERY, IDH_NR_TIMEPICKER_NEWQUERY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REVOCATION_DIALOG[]=
{
	IDC_COMBO_REASON,IDH_ED_COMBO_REASON,
	0, 0
};


const DWORD g_aHelpIDs_IDD_RENEW_REUSEKEYS[]=
{
	IDC_RADIO_REUSEKEY,IDH_RADIO_REUSEKEY,
	IDC_RADIO_NEWKEY,IDH_RADIO_NEWKEY,
	0,0
};

const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	IDC_COMBO_VARIABLE, IDH_COMBO_VARIABLE,
	IDC_BUTTON_INSERTVAR, IDH_BUTTON_INSERTVAR,
	IDC_EDIT_VARIABLEDESCRIPTION, IDH_EDIT_VARIABLEDESCRIPTION,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE6[]=
{
	IDC_RADIO_DISABLEOFFICERS, IDH_RADIO_DISABLEOFFICERS,
	IDC_RADIO_ENABLEOFFICERS, IDH_RADIO_ENABLEOFFICERS,
	IDC_LIST_CERTMANAGERS, IDH_LIST_CERTMANAGERS,
	IDC_LIST_SUBJECTS, IDH_LIST_SUBJECTS,
	IDC_ALLOWDENY, IDH_ALLOWDENY,
	IDC_ADDSUBJECT, IDH_ADDSUBJECT,
	IDC_REMOVESUBJECT, IDH_REMOVESUBJECT,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE7[]=
{
	IDC_AUDIT_BACKUPRESTORE, IDH_AUDIT_BACKUPRESTORE,
	IDC_AUDIT_CACONFIG, IDH_AUDIT_CACONFIG,
	IDC_AUDIT_CASEC, IDH_AUDIT_CASEC,
	IDC_AUDIT_CERTIFICATE, IDH_AUDIT_CERTIFICATE,
	IDC_AUDIT_CRL, IDH_AUDIT_CRL,
	IDC_AUDIT_KEYARCHIVAL, IDH_AUDIT_KEYARCHIVAL,
	IDC_AUDIT_STARTSTOP, IDH_AUDIT_STARTSTOP,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE_CHOOSE_KRA[]=
{
	IDC_KRA_DISABLE, IDH_KRA_DISABLE,
	IDC_KRA_ENABLE, IDH_KRA_ENABLE,
	IDC_KRA_EDITCOUNT, IDH_KRA_EDITCOUNT,
	IDC_LIST_KRA, IDH_LIST_KRA,
	IDC_KRA_ADD, IDH_KRA_ADD,
	IDC_KRA_REMOVE, IDH_KRA_REMOVE,
	IDC_KRA_VIEW, IDH_KRA_VIEW,
	0,0
};

#endif // #if defined (_CERTMMC_)


#if defined (_CERTEXIT_)

//certexit.rc
const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG1[]=
{
	IDC_REMOVE_CRL, IDH_CRL_REMOVE,
	IDC_ADD_CRL, IDH_CRL_ADD,
	IDC_CRL_LIST, IDH_CRL_LIST,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG2[]=
{
	IDC_CHECK_FILE, IDH_EXIT_CHECK_FILE,
	0,0
};

#endif // #if defined (_CERTEXIT_)


#if defined (_CERTPDEF_)

//certpent.rc
const DWORD g_aHelpIDs_IDD_POLICYPG1[]=
{
	IDC_RADIO_ISSUE,IDH_DA_RADIO_ISSUE,
	IDC_RADIO_PENDFIRST,IDH_DA_RADIO_PENDFIRST,
	0,0
};


#endif // #if defined (_CERTPDEF_)


#if defined (_CAPESNPN_)

const DWORD g_aHelpIDs_IDD_SELECT_CERTIFICATE_TEMPLATE[]=
{
	IDC_CERTIFICATE_TYPE_LIST, IDH_CERTIFICATE_TYPE_LIST,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE[]=
{
	IDC_CERTIFICATE_TEMPLATE_NAME, IDH_CERTIFICATE_TEMPLATE_NAME,
	IDC_PURPOSE_LIST, IDH_PURPOSE_LIST,
	IDC_OTHER_INFO_LIST, IDH_OTHER_INFO_LIST,
	0,0
};

#endif // #if defined (_CAPESNPN_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\cspolicy.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cspolicy.h
//
// Contents:    Cert Server Policy interfaces
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CSPOLICY_H__
#define __CSPOLICY_H__

//+****************************************************
// Policy Module:

DWORD			// VR_PENDING || VR_INSTANT_OK || VR_INSTANT_BAD
PolicyVerifyRequest(
    IN DWORD ReqId);

#endif // __CSPOLICY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\cspelog.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    log.h

Abstract:

    Headers for the cert server policy module logging functions

Author:

    petesk  1-Jan-1999


Revision History:

    
--*/

BOOL
LogModuleStatus(
    IN HMODULE hModule,
    IN DWORD dwLogID,				// Resource ID of log string
    IN BOOL fPolicy, 
    IN WCHAR const *pwszSource, 
    IN WCHAR const * const *ppwszInsert);	// array of insert strings

HRESULT
LogPolicyEvent(
    IN HMODULE hModule,
    IN DWORD dwLogID,				// Resource ID of log string
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropEvent,
    IN WCHAR const * const *ppwszInsert);	// array of insert strings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csregstr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csregstr.h
//
// Contents:    Cert Server registry string definitions
//
//---------------------------------------------------------------------------

#ifndef __CSREGSTR_H__
#define __CSREGSTR_H__

#define wszROOT_CERTSTORE       TEXT("ROOT")
#define wszKRA_CERTSTORE        TEXT("KRA")
#define wszCA_CERTSTORE         TEXT("CA")
#define wszMY_CERTSTORE         TEXT("MY")
#define wszACRS_CERTSTORE	TEXT("ACRS")
#define wszREQUEST_CERTSTORE	TEXT("REQUEST")
#define wszNTAUTH_CERTSTORE     TEXT("NTAUTH")


// begin_certsrv

#define wszSERVICE_NAME		TEXT("CertSvc")

#define wszREGKEYNOSYSTEMCERTSVCPATH \
				TEXT("CurrentControlSet\\Services\\") \
				wszSERVICE_NAME

#define wszREGKEYCERTSVCPATH	TEXT("SYSTEM\\") wszREGKEYNOSYSTEMCERTSVCPATH
#define wszREGKEYBASE		wszREGKEYCERTSVCPATH	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\":
#define wszREGKEYCONFIGPATH	wszREGKEYCERTSVCPATH TEXT("\\") wszREGKEYCONFIG
#define wszREGKEYCONFIGPATH_BS	wszREGKEYCONFIGPATH TEXT("\\")
#define wszREGKEYCONFIGCANAME	wszREGKEYCONFIGPATH_BS	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\RestoreInProgress":
#define wszREGKEYCONFIGRESTORE wszREGKEYCONFIGPATH_BS wszREGKEYRESTOREINPROGRESS

//======================================================================
// Key Under "CertSvc":
#define wszREGKEYCONFIG		TEXT("Configuration")

//======================================================================
// Values Under "CertSvc\Configuration":
#define wszREGACTIVE		      TEXT("Active")
#define wszREGDIRECTORY		      TEXT("ConfigurationDirectory")
#define wszREGDBDIRECTORY             TEXT("DBDirectory")
#define wszREGDBLOGDIRECTORY          TEXT("DBLogDirectory")
#define wszREGDBSYSDIRECTORY          TEXT("DBSystemDirectory")
#define wszREGDBTEMPDIRECTORY         TEXT("DBTempDirectory")
#define wszREGDBSESSIONCOUNT	      TEXT("DBSessionCount")
#define wszREGDBLASTFULLBACKUP	      TEXT("DBLastFullBackup")
#define wszREGDBLASTINCREMENTALBACKUP TEXT("DBLastIncrementalBackup")
#define wszREGDBLASTRECOVERY	      TEXT("DBLastRecovery")
#define wszREGWEBCLIENTCAMACHINE      TEXT("WebClientCAMachine")
#define wszREGVERSION		      TEXT("Version")
#define wszREGWEBCLIENTCANAME         TEXT("WebClientCAName")
#define wszREGWEBCLIENTCATYPE         TEXT("WebClientCAType")
#define wszREGDBOPTIONALFLAGS         TEXT("DBOptionalFlags")

// end_certsrv

#define wszREGCERTSRVDEBUG	     TEXT("Debug")
#define wszREGCERTSRVMEMTRACK	     TEXT("MemTrack")

// Environment variables:
#define szCERTSRV_DEBUG		     "CERTSRV_DEBUG"
#define szCERTSRV_LOGFILE	     "CERTSRV_LOGFILE"
#define szCERTSRV_LOGMAX	     "CERTSRV_LOGMAX"
#define szCERTSRV_MEMTRACK	     "CERTSRV_MEMTRACK"

// begin_certsrv

// Default value for wszREGDBSESSIONCOUNT
#define DBSESSIONCOUNTDEFAULT	     20

// Default value for wszREGMAXINCOMINGMESSAGESIZE
#define MAXINCOMINGMESSAGESIZEDEFAULT	     (64 * 1024)

// Value for wszREGVERSION:
#define CSVER_MAJOR		     2	// high 16 bits
#define CSVER_MINOR		     1	// low 16 bits

// stamp, for all time,the whistler version:
#define CSVER_WHISTLER               ((2<<16)|(1))

// Keys Under "CertSvc\Configuration":
#define wszREGKEYRESTOREINPROGRESS   TEXT("RestoreInProgress")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>":
#define wszREGCADESCRIPTION          TEXT("CADescription")
#define wszREGCACERTHASH	     TEXT("CACertHash")
#define wszREGCASERIALNUMBER	     TEXT("CACertSerialNumber")
#define wszREGCAXCHGCERTHASH	     TEXT("CAXchgCertHash")
#define wszREGKRACERTHASH	     TEXT("KRACertHash")
#define wszREGKRACERTCOUNT	     TEXT("KRACertCount")
#define wszREGKRAFLAGS		     TEXT("KRAFlags")
#define wszREGCATYPE		     TEXT("CAType")
#define wszREGCERTENROLLCOMPATIBLE   TEXT("CertEnrollCompatible")
#define wszREGENFORCEX500NAMELENGTHS TEXT("EnforceX500NameLengths")
#define wszREGCOMMONNAME	     TEXT("CommonName")
#define wszREGCLOCKSKEWMINUTES	     TEXT("ClockSkewMinutes")

#define wszREGCRLNEXTPUBLISH         TEXT("CRLNextPublish")
#define wszREGCRLPERIODSTRING	     TEXT("CRLPeriod")
#define wszREGCRLPERIODCOUNT	     TEXT("CRLPeriodUnits")
#define wszREGCRLOVERLAPPERIODSTRING TEXT("CRLOverlapPeriod")
#define wszREGCRLOVERLAPPERIODCOUNT  TEXT("CRLOverlapUnits")

#define wszREGCRLDELTANEXTPUBLISH    TEXT("CRLDeltaNextPublish")
#define wszREGCRLDELTAPERIODSTRING   TEXT("CRLDeltaPeriod")
#define wszREGCRLDELTAPERIODCOUNT    TEXT("CRLDeltaPeriodUnits")
#define wszREGCRLDELTAOVERLAPPERIODSTRING TEXT("CRLDeltaOverlapPeriod")
#define wszREGCRLDELTAOVERLAPPERIODCOUNT  TEXT("CRLDeltaOverlapUnits")

#define wszREGCRLPUBLICATIONURLS     TEXT("CRLPublicationURLs")
#define wszREGCACERTPUBLICATIONURLS  TEXT("CACertPublicationURLs")

#define wszREGCAXCHGVALIDITYPERIODSTRING  TEXT("CAXchgValidityPeriod")
#define wszREGCAXCHGVALIDITYPERIODCOUNT   TEXT("CAXchgValidityPeriodUnits")
#define wszREGCAXCHGOVERLAPPERIODSTRING   TEXT("CAXchgOverlapPeriod")
#define wszREGCAXCHGOVERLAPPERIODCOUNT    TEXT("CAXchgOverlapPeriodUnits")

#define wszREGCRLPATH_OLD            TEXT("CRLPath")
#define wszREGCRLEDITFLAGS	     TEXT("CRLEditFlags")
#define wszREGCRLFLAGS		     TEXT("CRLFlags")
#define wszREGCRLATTEMPTREPUBLISH    TEXT("CRLAttemptRepublish")
#define wszREGENABLED		     TEXT("Enabled")
#define wszREGFORCETELETEX           TEXT("ForceTeletex")
#define wszREGLOGLEVEL		     TEXT("LogLevel")
#define wszREGHIGHSERIAL	     TEXT("HighSerial")
#define wszREGPOLICYFLAGS	     TEXT("PolicyFlags")
#define wszREGNAMESEPARATOR          TEXT("SubjectNameSeparator")
#define wszREGSUBJECTTEMPLATE	     TEXT("SubjectTemplate")
#define wszREGCAUSEDS		     TEXT("UseDS")
#define wszREGVALIDITYPERIODSTRING   TEXT("ValidityPeriod")
#define wszREGVALIDITYPERIODCOUNT    TEXT("ValidityPeriodUnits")
#define wszREGPARENTCAMACHINE        TEXT("ParentCAMachine")
#define wszREGPARENTCANAME           TEXT("ParentCAName")
#define wszREGREQUESTFILENAME        TEXT("RequestFileName")
#define wszREGREQUESTID              TEXT("RequestId")
#define wszREGREQUESTKEYCONTAINER    TEXT("RequestKeyContainer")
#define wszREGREQUESTKEYINDEX        TEXT("RequestKeyIndex")
#define wszREGCASERVERNAME           TEXT("CAServerName")
#define wszREGCACERTFILENAME         TEXT("CACertFileName")
#define wszREGCASECURITY             TEXT("Security")
#define wszREGAUDITFILTER            TEXT("AuditFilter")
#define wszREGOFFICERRIGHTS          TEXT("OfficerRights")
#define wszREGMAXINCOMINGMESSAGESIZE TEXT("MaxIncomingMessageSize")
#define wszREGROLESEPARATIONENABLED  TEXT("RoleSeparationEnabled")

#define wszREGSETUPSTATUS            TEXT("SetupStatus")
#define wszLOCKICERTREQUEST          TEXT("LockICertRequest")    
#define wszREGDSCONFIGDN	     TEXT("DSConfigDN")    
#define wszREGDSDOMAINDN	     TEXT("DSDomainDN")    

#define wszPFXFILENAMEEXT	     TEXT(".p12")
#define wszDATFILENAMEEXT	     TEXT(".dat")
#define wszLOGFILENAMEEXT	     TEXT(".log")
#define wszPATFILENAMEEXT	     TEXT(".pat")
#define wszDBFILENAMEEXT	     TEXT(".edb")
#define szDBBASENAMEPARM	     "edb"
#define wszDBBASENAMEPARM	     TEXT(szDBBASENAMEPARM)
#define wszLOGPATH		     TEXT("CertLog")
#define wszDBBACKUPSUBDIR	     TEXT("DataBase")
#define wszDBBACKUPCERTBACKDAT	     TEXT("certbkxp.dat")

#ifndef __ENUM_CATYPES__
#define __ENUM_CATYPES__

// Values for wszREGCATYPE:
typedef enum {
    ENUM_ENTERPRISE_ROOTCA = 0,
    ENUM_ENTERPRISE_SUBCA = 1,
    //ENUM_UNUSED2 = 2,
    ENUM_STANDALONE_ROOTCA = 3,
    ENUM_STANDALONE_SUBCA = 4,
    ENUM_UNKNOWN_CA = 5,
} ENUM_CATYPES;

#endif __ENUM_CATYPES__

// Default value for wszREGCLOCKSKEWMINUTES
#define CCLOCKSKEWMINUTESDEFAULT	      10

// Default validity period for ROOT CA certs:
#define dwVALIDITYPERIODCOUNTDEFAULT_ROOT	5

// Default validity periods for certs issued by a CA:
#define dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE	2
#define dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE	1
#define dwVALIDITYPERIODENUMDEFAULT	      ENUM_PERIOD_YEARS
#define wszVALIDITYPERIODSTRINGDEFAULT	      wszPERIODYEARS

#define dwCAXCHGVALIDITYPERIODCOUNTDEFAULT    1
#define dwCAXCHGVALIDITYPERIODENUMDEFAULT     ENUM_PERIOD_WEEKS
#define wszCAXCHGVALIDITYPERIODSTRINGDEFAULT  wszPERIODWEEKS

#define dwCAXCHGOVERLAPPERIODCOUNTDEFAULT     1
#define dwCAXCHGOVERLAPPERIODENUMDEFAULT      ENUM_PERIOD_DAYS
#define wszCAXCHGOVERLAPPERIODSTRINGDEFAULT   wszPERIODDAYS

#define dwCRLPERIODCOUNTDEFAULT		      1
#define wszCRLPERIODSTRINGDEFAULT	      wszPERIODWEEKS

#define dwCRLOVERLAPPERIODCOUNTDEFAULT	      0		// 0 --> disabled
#define wszCRLOVERLAPPERIODSTRINGDEFAULT      wszPERIODHOURS

#define dwCRLDELTAPERIODCOUNTDEFAULT          1
#define wszCRLDELTAPERIODSTRINGDEFAULT        wszPERIODDAYS

#define dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT   0		// 0 --> disabled
#define wszCRLDELTAOVERLAPPERIODSTRINGDEFAULT wszPERIODMINUTES


// Values for wszREGLOGLEVEL:
#define CERTLOG_MINIMAL		(DWORD) 0
#define CERTLOG_TERSE		(DWORD) 1
#define CERTLOG_ERROR		(DWORD) 2
#define CERTLOG_WARNING		(DWORD) 3
#define CERTLOG_VERBOSE		(DWORD) 4


// Values for wszREGSETUPSTATUS:
#define SETUP_SERVER_FLAG		0x00000001	// server installed
#define SETUP_CLIENT_FLAG		0x00000002	// client installed
#define SETUP_SUSPEND_FLAG		0x00000004	// incomplete install
#define SETUP_REQUEST_FLAG		0x00000008	// new cert requested
#define SETUP_ONLINE_FLAG		0x00000010	// requested online
#define SETUP_DENIED_FLAG		0x00000020	// request denied
#define SETUP_CREATEDB_FLAG		0x00000040	// create new DB
#define SETUP_ATTEMPT_VROOT_CREATE	0x00000080	// try to create vroots
#define SETUP_FORCECRL_FLAG		     0x00000100	// force new CRL(s)
#define SETUP_UPDATE_CAOBJECT_SVRTYPE	     0x00000200	// add server type to CA DS object "flags" attr
#define SETUP_SERVER_UPGRADED_FLAG	     0x00000400	// server was upgraded
#define SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG 0x00000800 // still need to upgrade security

// Values for wszREGCRLFLAGS:
#define CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE	0x00000001 // use oldest base:
// else use newest base CRL that satisfies base CRL propagation delay

#define CRLF_DELETE_EXPIRED_CRLS		0x00000002
#define CRLF_CRLNUMBER_CRITICAL			0x00000004
#define CRLF_REVCHECK_IGNORE_OFFLINE		0x00000008
#define CRLF_IGNORE_INVALID_POLICIES		0x00000010
#define CRLF_REBUILD_MODIFIED_SUBJECT_ONLY	0x00000020
#define CRLF_SAVE_FAILED_CERTS			0x00000040
#define CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES	0x00000080
#define CRLF_ACCEPT_OLDRFC_CMC			0x00000100
#define CRLF_PUBLISH_EXPIRED_CERT_CRLS		0x00000200

// Values for wszREGKRAFLAGS:
#define KRAF_ENABLEFOREIGN	0x00000001 // allow foreign cert, key archival
#define KRAF_SAVEBADREQUESTKEY	0x00000002 // save failed request w/archived key

// Values for numeric prefixes for
// wszREGCRLPUBLICATIONURLS and wszREGCACERTPUBLICATIONURLS:
//
// URL publication template Flags values, encoded as a decimal prefix for URL
// publication templates in the registry:
//   "1:c:\winnt\System32\CertSrv\CertEnroll\MyCA.crl"
//   "2:http:\//MyServer.MyDomain.com/CertEnroll\MyCA.crl"

#define CSURL_SERVERPUBLISH	0x00000001
#define CSURL_ADDTOCERTCDP	0x00000002
#define CSURL_ADDTOFRESHESTCRL	0x00000004
#define CSURL_ADDTOCRLCDP	0x00000008
#define CSURL_PUBLISHRETRY	0x00000010
#define CSURL_ADDTOCERTOCSP	0x00000020
// end_certsrv

// Initialization internal definitions -- not written to the registry:
#define CSURL_ADDSYSTEM32DIR	0x20000000
#define CSURL_NODS		0x40000000
#define CSURL_DSONLY		0x80000000
#define CSURL_INITMASK		0xf0000000

// begin_certsrv
//======================================================================
// Keys Under "CertSvc\Configuration\<CAName>":
#define wszREGKEYCSP			TEXT("CSP")
#define wszREGKEYENCRYPTIONCSP		TEXT("EncryptionCSP")
#define wszREGKEYEXITMODULES		TEXT("ExitModules")
#define wszREGKEYPOLICYMODULES	        TEXT("PolicyModules")
#define wszSECUREDATTRIBUTES		TEXT("SignedAttributes")

#define wszzDEFAULTSIGNEDATTRIBUTES     TEXT("RequesterName\0")

//======================================================================
// Values Under "CertSvc\Configuration\RestoreInProgress":
#define wszREGBACKUPLOGDIRECTORY	TEXT("BackupLogDirectory")
#define wszREGCHECKPOINTFILE		TEXT("CheckPointFile")
#define wszREGHIGHLOGNUMBER		TEXT("HighLogNumber")
#define wszREGLOWLOGNUMBER		TEXT("LowLogNumber")
#define wszREGLOGPATH			TEXT("LogPath")
#define wszREGRESTOREMAPCOUNT		TEXT("RestoreMapCount")
#define wszREGRESTOREMAP		TEXT("RestoreMap")
#define wszREGDATABASERECOVERED		TEXT("DatabaseRecovered")
#define wszREGRESTORESTATUS		TEXT("RestoreStatus")

// values under \Configuration\PolicyModules in nt5 beta 2
#define wszREGB2ICERTMANAGEMODULE   TEXT("ICertManageModule")
// values under \Configuration in nt4 sp4
#define wszREGSP4DEFAULTCONFIGURATION  TEXT("DefaultConfiguration")
// values under ca in nt4 sp4
#define wszREGSP4KEYSETNAME            TEXT("KeySetName")
#define wszREGSP4SUBJECTNAMESEPARATOR  TEXT("SubjectNameSeparator")
#define wszREGSP4NAMES                 TEXT("Names")
#define wszREGSP4QUERIES               TEXT("Queries")
// both nt4 sp4 and nt5 beta 2
#define wszREGNETSCAPECERTTYPE         TEXT("NetscapeCertType")
#define wszNETSCAPEREVOCATIONTYPE      TEXT("Netscape")

// end_certsrv


// CSPs
#define wszBASECSP     MS_STRONG_PROV_W
#define wszENHCSP      TEXT("Microsoft Enhanced Cryptographic Provider v1.0")
#define wszMITVCSP     TEXT("MITV Smart Card Crypto Provider V0.2")
#define wszBBNCSP      TEXT("BBN SafeKeyer Crypto Provider V0.1")
#define wszSLBCSP      TEXT("Schlumberger Cryptographic Service Provider v0.1")
#define wszSLBCSP2     TEXT("Schlumberger Cryptographic Service Provider")
#define wszGEMPLUS     TEXT("Gemplus GemPASS Card CSP v1.0")
#define wszGEMPLUS2    TEXT("Gemplus GemSAFE Card CSP v1.0")
#define wszDDSCSP      TEXT("Microsoft Base DSS Cryptographic Provider")

// Hash Algorithms
#define wszHashMD5     TEXT("MD5")
#define wszHashMD4     TEXT("MD4")
#define wszHashMD2     TEXT("MD2")
#define wszHashSHA1    TEXT("SHA-1")

// begin_certsrv

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\CSP":
// and "CertSvc\Configuration\<CAName>\EncryptionCSP":
#define wszREGPROVIDERTYPE     TEXT("ProviderType")
#define wszREGPROVIDER         TEXT("Provider")
#define wszHASHALGORITHM       TEXT("HashAlgorithm")
#define wszENCRYPTIONALGORITHM TEXT("EncryptionAlgorithm")
#define wszMACHINEKEYSET       TEXT("MachineKeyset")
#define wszREGKEYSIZE	       TEXT("KeySize")


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\SubjectNameSeparator":
#define szNAMESEPARATORDEFAULT   "\n"
#define wszNAMESEPARATORDEFAULT   TEXT(szNAMESEPARATORDEFAULT)


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\ValidityPeriod", etc.:
#define wszPERIODYEARS		TEXT("Years")
#define wszPERIODMONTHS		TEXT("Months")
#define wszPERIODWEEKS		TEXT("Weeks")
#define wszPERIODDAYS		TEXT("Days")
#define wszPERIODHOURS		TEXT("Hours")
#define wszPERIODMINUTES	TEXT("Minutes")
#define wszPERIODSECONDS	TEXT("Seconds")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\PolicyModules\<ProgId>":
#define wszREGISSUERCERTURLFLAGS    TEXT("IssuerCertURLFlags")
#define wszREGEDITFLAGS		    TEXT("EditFlags")
#define wszREGSUBJECTALTNAME	    TEXT("SubjectAltName")
#define wszREGSUBJECTALTNAME2	    TEXT("SubjectAltName2")
#define wszREGREQUESTDISPOSITION    TEXT("RequestDisposition")
#define wszREGCAPATHLENGTH	    TEXT("CAPathLength")
#define wszREGREVOCATIONTYPE	    TEXT("RevocationType")

#define wszREGLDAPREVOCATIONCRLURL_OLD	TEXT("LDAPRevocationCRLURL")
#define wszREGREVOCATIONCRLURL_OLD	TEXT("RevocationCRLURL")
#define wszREGFTPREVOCATIONCRLURL_OLD	TEXT("FTPRevocationCRLURL")
#define wszREGFILEREVOCATIONCRLURL_OLD	TEXT("FileRevocationCRLURL")

#define wszREGREVOCATIONURL		TEXT("RevocationURL")

#define wszREGLDAPISSUERCERTURL_OLD	TEXT("LDAPIssuerCertURL")
#define wszREGISSUERCERTURL_OLD		TEXT("IssuerCertURL")
#define wszREGFTPISSUERCERTURL_OLD	TEXT("FTPIssuerCertURL")
#define wszREGFILEISSUERCERTURL_OLD	TEXT("FileIssuerCertURL")

#define wszREGENABLEREQUESTEXTENSIONLIST  TEXT("EnableRequestExtensionList")
#define wszREGDISABLEEXTENSIONLIST  TEXT("DisableExtensionList")

#define wszREGDEFAULTSMIME		TEXT("DefaultSMIME")

// wszREGCAPATHLENGTH Values:
#define CAPATHLENGTH_INFINITE		0xffffffff

// wszREGREQUESTDISPOSITION Values:
#define REQDISP_PENDING			0x00000000
#define REQDISP_ISSUE			0x00000001
#define REQDISP_DENY			0x00000002
#define REQDISP_USEREQUESTATTRIBUTE	0x00000003
#define REQDISP_MASK			0x000000ff
#define REQDISP_PENDINGFIRST		0x00000100
#define REQDISP_DEFAULT_STANDALONE	(REQDISP_PENDINGFIRST | REQDISP_ISSUE)
#define REQDISP_DEFAULT_ENTERPRISE	(REQDISP_ISSUE)

// wszREGREVOCATIONTYPE Values:
#define REVEXT_CDPLDAPURL_OLD		0x00000001
#define REVEXT_CDPHTTPURL_OLD		0x00000002
#define REVEXT_CDPFTPURL_OLD		0x00000004
#define REVEXT_CDPFILEURL_OLD		0x00000008
#define REVEXT_CDPURLMASK_OLD		0x000000ff
#define REVEXT_CDPENABLE		0x00000100
#define REVEXT_ASPENABLE		0x00000200

#define REVEXT_DEFAULT_NODS		(REVEXT_CDPENABLE)
#define REVEXT_DEFAULT_DS		(REVEXT_CDPENABLE)

// wszREGISSUERCERTURLFLAGS Values:
#define ISSCERT_LDAPURL_OLD		0x00000001
#define ISSCERT_HTTPURL_OLD		0x00000002
#define ISSCERT_FTPURL_OLD		0x00000004
#define ISSCERT_FILEURL_OLD		0x00000008
#define ISSCERT_URLMASK_OLD		0x000000ff
#define ISSCERT_ENABLE			0x00000100

#define ISSCERT_DEFAULT_NODS		(ISSCERT_ENABLE)
#define ISSCERT_DEFAULT_DS		(ISSCERT_ENABLE)

// wszREGEDITFLAGS Values:				   Defaults:
// Under CA key: wszREGCRLEDITFLAGS Values (EDITF_ENABLEAKI* only):
#define EDITF_ENABLEREQUESTEXTENSIONS	0x00000001	// neither
#define EDITF_REQUESTEXTENSIONLIST	0x00000002	// Standalone
#define EDITF_DISABLEEXTENSIONLIST	0x00000004	// both
#define EDITF_ADDOLDKEYUSAGE		0x00000008	// both
#define EDITF_ADDOLDCERTTYPE		0x00000010	// neither
#define EDITF_ATTRIBUTEENDDATE		0x00000020	// Standalone
#define EDITF_BASICCONSTRAINTSCRITICAL	0x00000040	// Standalone
#define EDITF_BASICCONSTRAINTSCA	0x00000080	// Standalone
#define EDITF_ENABLEAKIKEYID		0x00000100	// both
#define EDITF_ATTRIBUTECA		0x00000200	// Standalone
#define EDITF_IGNOREREQUESTERGROUP      0x00000400	// Standalone
#define EDITF_ENABLEAKIISSUERNAME	0x00000800	// both
#define EDITF_ENABLEAKIISSUERSERIAL	0x00001000	// both
#define EDITF_ENABLEAKICRITICAL		0x00002000	// both
#define EDITF_SERVERUPGRADED		0x00004000	// neither
#define EDITF_ATTRIBUTEEKU		0x00008000	// Standalone
#define EDITF_ENABLEDEFAULTSMIME	0x00010000	// Enterprise

#define EDITF_DEFAULT_STANDALONE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
					 EDITF_ATTRIBUTEENDDATE | \
					 EDITF_BASICCONSTRAINTSCRITICAL | \
					 EDITF_BASICCONSTRAINTSCA | \
					 EDITF_ENABLEAKIKEYID | \
					 EDITF_ATTRIBUTECA | \
					 EDITF_ATTRIBUTEEKU)

#define EDITF_DEFAULT_ENTERPRISE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
                                         EDITF_BASICCONSTRAINTSCRITICAL | \
                                         EDITF_ENABLEAKIKEYID | \
					 EDITF_ADDOLDKEYUSAGE | \
					 EDITF_ENABLEDEFAULTSMIME)


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\<ProgId>":

// LDAP based CRL and URL issuance
#define wszREGLDAPREVOCATIONDN_OLD	   TEXT("LDAPRevocationDN")
#define wszREGLDAPREVOCATIONDNTEMPLATE_OLD TEXT("LDAPRevocationDNTemplate")
#define wszCRLPUBLISHRETRYCOUNT    TEXT("CRLPublishRetryCount")
#define wszREGCERTPUBLISHFLAGS     TEXT("PublishCertFlags")

// wszREGCERTPUBLISHFLAGS Values:
#define EXITPUB_FILE			0x00000001
#define EXITPUB_ACTIVEDIRECTORY		0x00000002
#define EXITPUB_EMAILNOTIFYALL		0x00000004
#define EXITPUB_EMAILNOTIFYSMARTCARD	0x00000008
#define EXITPUB_REMOVEOLDCERTS		0x00000010

#define EXITPUB_DEFAULT_ENTERPRISE	EXITPUB_ACTIVEDIRECTORY

#define EXITPUB_DEFAULT_STANDALONE	EXITPUB_FILE

// end_certsrv

//======================================================================
// KeysNotToRestore Registry Key:

#define wszREGKEYKEYSNOTTORESTORE	TEXT("SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\KeysNotToRestore")

// Certificate Authority = REG_MULTI_SZ "CurrentControlSet\Control\Services\CertSvc\Configuration\RestoreInProgress\\0"

#define wszREGRESTORECERTIFICATEAUTHORITY	TEXT("Certificate Authority")

#define wszzREGVALUERESTORECERTIFICATEAUTHORITY	\
					wszREGKEYNOSYSTEMCERTSVCPATH \
					TEXT("\\") \
					wszREGKEYCONFIG \
					TEXT("\\") \
					wszREGKEYRESTOREINPROGRESS \
					TEXT("\\\0")

//======================================================================
// FilesNotToRestore Registry Key:

#define wszREGKEYFILESNOTTOBACKUP	TEXT("SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup")

// Certificate Authority = REG_MULTI_SZ DBFile DBLogDir DBSysDir DBTempDir

//#define wszREGRESTORECERTIFICATEAUTHORITY	TEXT("Certificate Authority")

//======================================================================
// Key Manager Base Registry Key, value name and value string:
#define wszREGKEYKEYRING	TEXT("SOFTWARE\\Microsoft\\KeyRing\\Parameters\\Certificate Authorities\\Microsoft Certificate Server")
#define wszREGCERTGETCONFIG	TEXT("CertGetConfig")
#define wszREGCERTREQUEST	TEXT("CertRequest")

// begin_certsrv

#define wszCLASS_CERTADMIN	  TEXT("CertificateAuthority.Admin")
#define wszCLASS_CERTCONFIG	  TEXT("CertificateAuthority.Config")
#define wszCLASS_CERTGETCONFIG	  TEXT("CertificateAuthority.GetConfig")
#define wszCLASS_CERTENCODE	  TEXT("CertificateAuthority.Encode")
#define wszCLASS_CERTDB		  TEXT("CertificateAuthority.DB") // no_certsrv
#define wszCLASS_CERTDBRESTORE	  TEXT("CertificateAuthority.DBRestore") // no_certsrv
#define wszCLASS_CERTREQUEST	  TEXT("CertificateAuthority.Request")
#define wszCLASS_CERTSERVEREXIT   TEXT("CertificateAuthority.ServerExit")
#define wszCLASS_CERTSERVERPOLICY TEXT("CertificateAuthority.ServerPolicy")
#define wszCLASS_CERTVIEW	  TEXT("CertificateAuthority.View")

// class name templates
#define wszMICROSOFTCERTMODULE_PREFIX  TEXT("CertificateAuthority_MicrosoftDefault") 
#define wszCERTEXITMODULE_POSTFIX	TEXT(".Exit")
#define wszCERTMANAGEEXIT_POSTFIX	TEXT(".ExitManage")
#define wszCERTPOLICYMODULE_POSTFIX	TEXT(".Policy")
#define wszCERTMANAGEPOLICY_POSTFIX	TEXT(".PolicyManage")

// actual policy/exit manage class names
#define wszCLASS_CERTMANAGEEXITMODULE   wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEEXIT_POSTFIX 

#define wszCLASS_CERTMANAGEPOLICYMODULE wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEPOLICY_POSTFIX 

// actual policy/exit class names
#define wszCLASS_CERTEXIT	wszMICROSOFTCERTMODULE_PREFIX wszCERTEXITMODULE_POSTFIX

#define wszCLASS_CERTPOLICY	wszMICROSOFTCERTMODULE_PREFIX wszCERTPOLICYMODULE_POSTFIX


#define wszCAPOLICYFILE			L"CAPolicy.inf"

#define wszINFSECTION_CDP		L"CRLDistributionPoint"
#define wszINFSECTION_AIA		L"AuthorityInformationAccess"
#define wszINFSECTION_EKU		L"EnhancedKeyUsageExtension"
#define wszINFSECTION_CCDP		L"CrossCertificateDistributionPointsExtension"

#define wszINFSECTION_CERTSERVER	L"certsrv_server"
#define wszINFKEY_RENEWALKEYLENGTH	L"RenewalKeyLength"
#define wszINFKEY_RENEWALVALIDITYPERIODSTRING	L"RenewalValidityPeriod"
#define wszINFKEY_RENEWALVALIDITYPERIODCOUNT	L"RenewalValidityPeriodUnits"
#define wszINFKEY_UTF8			L"UTF8"
#define wszINFKEY_CRLPERIODSTRING	wszREGCRLPERIODSTRING
#define wszINFKEY_CRLPERIODCOUNT	wszREGCRLPERIODCOUNT
#define wszINFKEY_CRLDELTAPERIODSTRING	wszREGCRLDELTAPERIODSTRING
#define wszINFKEY_CRLDELTAPERIODCOUNT	wszREGCRLDELTAPERIODCOUNT

#define wszINFKEY_CRITICAL		L"Critical"
#define wszINFKEY_EMPTY			L"Empty"

#define wszINFKEY_CCDPSYNCDELTATIME	L"SyncDeltaTime"

#define wszINFSECTION_CAPOLICY		L"CAPolicy"
#define wszINFSECTION_POLICYSTATEMENT	L"PolicyStatementExtension"
#define wszINFSECTION_APPLICATIONPOLICYSTATEMENT	L"ApplicationPolicyStatementExtension"
#define wszINFKEY_POLICIES		L"Policies"
#define wszINFKEY_OID			L"OID"
#define wszINFKEY_NOTICE		L"Notice"

#define wszINFSECTION_REQUESTATTRIBUTES	L"RequestAttributes"

#define wszINFSECTION_NAMECONSTRAINTS	L"NameConstraintsExtension"
#define wszINFKEY_INCLUDE		L"Include"
#define wszINFKEY_EXCLUDE		L"Exclude"

#define wszINFKEY_UPN			L"UPN"
#define wszINFKEY_EMAIL			L"EMail"
#define wszINFKEY_DNS			L"DNS"
#define wszINFKEY_DIRECTORYNAME		L"DirectoryName"
#define wszINFKEY_URL			L"URL"
#define wszINFKEY_IPADDRESS		L"IPAddress"
#define wszINFKEY_REGISTEREDID		L"RegisteredId"

#define wszINFSECTION_POLICYMAPPINGS	L"PolicyMappingsExtension"
#define wszINFSECTION_APPLICATIONPOLICYMAPPINGS	L"ApplicationPolicyMappingsExtension"

#define wszINFSECTION_POLICYCONSTRAINTS	L"PolicyConstraintsExtension"
#define wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS	L"ApplicationPolicyConstraintsExtension"
#define wszINFKEY_REQUIREEXPLICITPOLICY	L"RequireExplicitPolicy"
#define wszINFKEY_INHIBITPOLICYMAPPING	L"InhibitPolicyMapping"

#define wszINFSECTION_BASICCONSTRAINTS	L"BasicConstraintsExtension"
#define wszINFKEY_PATHLENGTH		L"PathLength"


// exit module mail support
#define wszREGEXITSMTPKEY		L"SMTP"
#define wszREGEXITSMTPFROM		L"From"
#define wszREGEXITSMTPCC		L"CC"
#define wszREGEXITSMTPSUBJECT		L"Subject"

// end_certsrv


// begin CertSrv MMC Snapin
#define wszREGKEYMGMT                 L"Software\\Microsoft\\MMC"
#define wszREGKEYMGMTSNAPIN           wszREGKEYMGMT L"\\SnapIns"
#define wszREGKEYMGMTNODETYPES        wszREGKEYMGMT L"\\NodeTypes"
#define wszSNAPINNAMESTRING           L"NameString"
#define wszSNAPINNAMESTRINGINDIRECT   L"NameStringIndirect"
#define wszSNAPINABOUT                L"About"
#define wszSNAPINSTANDALONE           L"StandAlone"
#define wszSNAPINNODETYPES            L"NodeTypes"
#define wszSNAPINEXTENSIONS           L"Extensions"
#define wszSNAPINNAMESPACE            L"NameSpace"
#define wszSNAPINPROPERTYSHEET        L"PropertySheet"
#define wszSNAPINNAMESTRINGINDIRECT_TEMPLATE     L"@%s,-%d"	// "@dllname, -<resource id>"

// main snapin uuid
#define wszSNAPINNODETYPE_UUID1               L"{de751566-4cc6-11d1-8ca0-00c04fc297eb}"
#define wszREGKEYMGMTSNAPINUUID1              wszREGKEYMGMTSNAPIN L"\\" wszSNAPINNODETYPE_UUID1
#define wszSNAPINNODETYPE_ABOUT               L"{4653e860-4cc7-11d1-8ca0-00c04fc297eb}"
#define wszREGKEYMGMTSNAPINUUID1_STANDALONE   wszREGKEYMGMTSNAPINUUID1 L"\\" wszSNAPINSTANDALONE
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES    wszREGKEYMGMTSNAPINUUID1 L"\\" wszSNAPINNODETYPES

#define wszSNAPINNODETYPE_1   L"{89b31b94-4cc7-11d1-8ca0-00c04fc297eb}" // cNODETYPEMACHINEINSTANCE
#define wszSNAPINNODETYPE_2   L"{5d972ee4-7576-11d1-8cbe-00c04fc297eb}" // cNODETYPESERVERINSTANCE
#define wszSNAPINNODETYPE_3   L"{5946E36C-757C-11d1-8CBE-00C04FC297EB}" // cNODETYPECRLPUBLICATION
#define wszSNAPINNODETYPE_4   L"{783E4E5F-757C-11d1-8CBE-00C04FC297EB}" // cNODETYPEISSUEDCERTS
#define wszSNAPINNODETYPE_5   L"{783E4E63-757C-11d1-8CBE-00C04FC297EB}" // cNODETYPEPENDINGCERTS
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_1  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_1
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_2  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_2
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_3  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_3
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_4  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_4
#define wszREGKEYMGMTSNAPINUUID1_NODETYPES_5  wszREGKEYMGMTSNAPINUUID1_NODETYPES L"\\" wszSNAPINNODETYPE_5


// register snapin nodetypes
#define wszREGKEYMGMTSNAPIN_NODETYPES_1        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_1
#define wszREGKEYMGMTSNAPIN_NODETYPES_2        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_2
#define wszREGKEYMGMTSNAPIN_NODETYPES_3        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_3
#define wszREGKEYMGMTSNAPIN_NODETYPES_4        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_4
#define wszREGKEYMGMTSNAPIN_NODETYPES_5        wszREGKEYMGMTNODETYPES L"\\" wszSNAPINNODETYPE_5
#define wszREGCERTSNAPIN_NODETYPES_1          L"CertSvr MMC Machine Instance"
#define wszREGCERTSNAPIN_NODETYPES_2          L"CertSvr MMC Server Instance"
#define wszREGCERTSNAPIN_NODETYPES_3          L"CertSvr MMC CRL Publication"
#define wszREGCERTSNAPIN_NODETYPES_4          L"CertSvr MMC Issued Certificates"
#define wszREGCERTSNAPIN_NODETYPES_5          L"CertSvr MMC Pending Certificates"


// restore through ini file
#define wszRESTORE_FILENAME L"CertsrvRestore"
#define wszRESTORE_SECTION L"Restore"
#define wszRESTORE_NEWLOGSUFFIX L"New"

#endif // __CSREGSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csprop2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       csprop2.cpp
//
//  Contents:   ICertAdmin2 & ICertRequest2 CA Property methods
//
//--------------------------------------------------------------------------

#if defined(CCERTADMIN)

# define CCertProp	CCertAdmin
# define wszCCertProp	L"CCertAdmin"
# define m_pICertPropD	m_pICertAdminD
# define fRPCARG(fRPC)

#elif defined(CCERTREQUEST)

# define CCertProp	CCertRequest
# define wszCCertProp	L"CCertRequest"
# define m_pICertPropD	m_pICertRequestD
# define fRPCARG(fRPC)	(fRPC),

#else
# error -- CCERTADMIN or CCERTREQUEST must be defined
#endif


//+--------------------------------------------------------------------------
// CCertProp::_InitCAPropInfo -- Initialize CA Prop Info
//
// Initialize CA Prop Info member varaibles
//+--------------------------------------------------------------------------

VOID
CCertProp::_InitCAPropInfo()
{
    m_pbKRACertState = NULL;
    m_pbCACertState = NULL;
    m_pbCRLState = NULL;
    m_pCAPropInfo = NULL;
    m_pCAInfo = NULL;
}


//+--------------------------------------------------------------------------
// CCertProp::_CleanupCAPropInfo -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertProp::_CleanupCAPropInfo()
{
    // Memory returned from DCOM calls were MIDL_user_allocate'd

    if (NULL != m_pbKRACertState)
    {
        MIDL_user_free(m_pbKRACertState);
        m_pbKRACertState = NULL;
    }

    if (NULL != m_pbCACertState)
    {
        MIDL_user_free(m_pbCACertState);
	m_pbCACertState = NULL;
    }
    if (NULL != m_pbCRLState)
    {
        MIDL_user_free(m_pbCRLState);
	m_pbCRLState = NULL;
    }
    if (NULL != m_pCAInfo)
    {
	MIDL_user_free(m_pCAInfo);
	m_pCAInfo = NULL;
    }
    m_cCAPropInfo = 0;
}


//+--------------------------------------------------------------------------
// CCertProp::GetCAProperty -- Get a CA property
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::GetCAProperty(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,		// CR_PROP_*
    /* [in] */ LONG PropIndex,
    /* [in] */ LONG PropType,		// PROPTYPE_*
    /* [in] */ LONG Flags,		// CR_OUT_*
    /* [out, retval] */ VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCAProp = { 0, NULL };
    DWORD dwCAInfoOffset = MAXDWORD;
    BYTE const *pb;
    DWORD cb;
    BYTE **ppb = NULL;
    DWORD *pcb;
    DWORD dwState;

    if (NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarPropertyValue);

    hr = _OpenConnection(fRPCARG(FALSE) strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    // Check for cached data:

    switch (PropId)
    {
	case CR_PROP_CATYPE:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, CAType);
	    break;

	case CR_PROP_CASIGCERTCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cCASignatureCerts);
	    break;

	case CR_PROP_CAXCHGCERTCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cCAExchangeCerts);
	    break;

	case CR_PROP_EXITCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cExitModules);
	    break;

	case CR_PROP_CAPROPIDMAX:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, lPropIdMax);
	    break;

	case CR_PROP_CACERTSTATE:
	    ppb = &m_pbCACertState;
	    pcb = &m_cbCACertState;
	    break;

	case CR_PROP_CRLSTATE:
	    ppb = &m_pbCRLState;
	    pcb = &m_cbCRLState;
	    break;

	case CR_PROP_ROLESEPARATIONENABLED:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, lRoleSeparationEnabled);
	    break;

	case CR_PROP_KRACERTUSEDCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cKRACertUsedCount);
	    break;

	case CR_PROP_KRACERTCOUNT:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, cKRACertCount);
	    break;

	case CR_PROP_ADVANCEDSERVER:
	    dwCAInfoOffset = FIELD_OFFSET(CAINFO, fAdvancedServer);
	    break;

	case CR_PROP_KRACERTSTATE:
	    ppb = &m_pbKRACertState;
	    pcb = &m_cbKRACertState;
	    break;
    }

    // Call server if:
    //   non-cached property ||
    //   cached state is empty ||
    //   cached CAInfo is empty

    if ((NULL == ppb && MAXDWORD == dwCAInfoOffset) ||
	(NULL != ppb && NULL == *ppb) ||
	(MAXDWORD != dwCAInfoOffset && NULL == m_pCAInfo))
    {
	__try
	{
	    hr = m_pICertPropD->GetCAProperty(
					    pwszAuthority,
					    PropId,
					    PropIndex,
					    PropType,
					    &ctbCAProp);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_ERROR,
		"GetCAProperty(Propid=%x, PropIndex=%x, PropType=%x) -> %x\n",
		PropId,
		PropIndex,
		PropType,
		hr));
	}
	_JumpIfError3(
		    hr,
		    error,
		    "GetCAProperty",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
		    E_INVALIDARG);

	DBGDUMPHEX((DBG_SS_CERTLIBI, DH_NOADDRESS, ctbCAProp.pb, ctbCAProp.cb));

	if (NULL != ctbCAProp.pb)
	{
	    myRegisterMemAlloc(ctbCAProp.pb, ctbCAProp.cb, CSM_COTASKALLOC);
	}
	pb = ctbCAProp.pb;
	cb = ctbCAProp.cb;

	// populate CAInfo cache

	if (MAXDWORD != dwCAInfoOffset)
	{
	    if (CCSIZEOF_STRUCT(CAINFO, cbSize) >
		    ((CAINFO *) ctbCAProp.pb)->cbSize ||
		cb != ((CAINFO *) ctbCAProp.pb)->cbSize)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "CAINFO size");
	    }
	    m_cbCAInfo = ctbCAProp.cb;
	    m_pCAInfo = (CAINFO *) ctbCAProp.pb;
	    ctbCAProp.pb = NULL;
	}

	// populate Cert or CRL state cache

	else if (NULL != ppb)
	{
	    *pcb = ctbCAProp.cb;
	    *ppb = ctbCAProp.pb;
	    ctbCAProp.pb = NULL;
	}
    }
	
    // fetch from CAInfo cache

    if (MAXDWORD != dwCAInfoOffset)
    {
	pb = (BYTE const *) Add2Ptr(m_pCAInfo, dwCAInfoOffset);
	cb = sizeof(DWORD);

	if (dwCAInfoOffset + sizeof(DWORD) > m_cbCAInfo)
	{
	    hr = E_NOTIMPL;
	    _JumpError(hr, error, "CAINFO size");
	}
    }

    // fetch from Cert or CRL state cache

    else if (NULL != ppb)
    {
	if ((DWORD) PropIndex > *pcb)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropIndex");
	}
	dwState = *(BYTE const *) Add2Ptr(*ppb, PropIndex);
	pb = (BYTE const *) &dwState;
	cb = sizeof(dwState);
    }

    __try
    {
	hr = myUnmarshalFormattedVariant(
				    Flags,
				    PropId,
				    PropType,
				    cb,
				    pb,
				    pvarPropertyValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "myUnmarshalFormattedVariant");

error:
    if (S_OK != hr && NULL != pvarPropertyValue)
    {
	VariantClear(pvarPropertyValue);
    }
    if (NULL != ctbCAProp.pb)
    {
	MIDL_user_free(ctbCAProp.pb);
    }
    return(_SetErrorInfo(hr, wszCCertProp L"::GetCAProperty"));
}


//+--------------------------------------------------------------------------
// CCertProp::_FindCAPropInfo -- Get a CA property's CAPROP info pointer
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertProp::_FindCAPropInfo(
    IN BSTR const strConfig,
    IN LONG PropId,		// CR_PROP_*
    OUT CAPROP const **ppcap)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCAPropInfo = { 0, NULL };

    CSASSERT(NULL != ppcap);
    *ppcap = NULL;
    
    hr = _OpenConnection(fRPCARG(FALSE) strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    if (NULL == m_pCAPropInfo)
    {
	__try
	{
	    hr = m_pICertPropD->GetCAPropertyInfo(
					    pwszAuthority,
					    &m_cCAPropInfo,
					    &ctbCAPropInfo);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError(hr, error, "GetCAPropertyInfo");

	if (NULL != ctbCAPropInfo.pb)
	{
	    myRegisterMemAlloc(
			    ctbCAPropInfo.pb,
			    ctbCAPropInfo.cb,
			    CSM_COTASKALLOC);
	}
	__try
	{
	    hr = myCAPropInfoUnmarshal(
				(CAPROP *) ctbCAPropInfo.pb,
				m_cCAPropInfo,
				ctbCAPropInfo.cb);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError(hr, error, "myCAPropInfoUnmarshal");

	m_pCAPropInfo = (CAPROP *) ctbCAPropInfo.pb;
	ctbCAPropInfo.pb = NULL;
    }

    hr = myCAPropInfoLookup(m_pCAPropInfo, m_cCAPropInfo, PropId, ppcap);
    _JumpIfError(hr, error, "myCAPropInfoLookup");

error:
    if (NULL != ctbCAPropInfo.pb)
    {
	MIDL_user_free(ctbCAPropInfo.pb);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertProp::GetCAPropertyFlags -- Get a CA property's type and flags
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::GetCAPropertyFlags(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,		// CR_PROP_*
    /* [out, retval] */ LONG *pPropFlags)
{
    HRESULT hr;
    CAPROP const *pcap;

    hr = _FindCAPropInfo(strConfig, PropId, &pcap);
    _JumpIfError(hr, error, "_FindCAPropInfo");

    *pPropFlags = pcap->lPropFlags;

error:
    return(_SetErrorInfo(hr, wszCCertProp L"::GetCAPropertyFlags"));
}


//+--------------------------------------------------------------------------
// CCertProp::GetCAPropertyDisplayName -- Get a CA property's display name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::GetCAPropertyDisplayName(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,		// CR_PROP_*
    /* [out, retval] */ BSTR *pstrDisplayName)
{
    HRESULT hr;
    CAPROP const *pcap;

    hr = _FindCAPropInfo(strConfig, PropId, &pcap);
    _JumpIfError(hr, error, "_FindCAPropInfo");

    if (!ConvertWszToBstr(pstrDisplayName, pcap->pwszDisplayName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    return(_SetErrorInfo(hr, wszCCertProp L"::GetCAPropertyDisplayName"));
}

#if defined(CCERTADMIN)
//+--------------------------------------------------------------------------
// CCertProp::SetCAProperty -- Set a CA property
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertProp::SetCAProperty(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG PropId,     // CR_PROP_*
    /* [in] */ LONG PropIndex,
    /* [in] */ LONG PropType,   // PROPTYPE_*
    /* [in] */ VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbValue;
    LONG lval;

    ctbValue.pb = NULL;

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    hr = myMarshalVariant(pvarPropertyValue, PropType, &ctbValue.cb, &ctbValue.pb);
    _JumpIfError(hr, error, "myMarshalVariant");

    __try
    {
        hr = m_pICertAdminD->SetCAProperty(
                pwszAuthority,
                PropId,
                PropIndex,
                PropType,
                &ctbValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "SetCAProperty");

error:
    if (NULL != ctbValue.pb)
    {
        LocalFree(ctbValue.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetCAProperty"));
}
#endif // defined(CCERTADMIN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csprop.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csprop.h
//
// Contents:    Cert Server Property interfaces
//
// History:     31-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CSPROP_H__
#define __CSPROP_H__

#include "certdb.h"

// begin_certsrv

//+--------------------------------------------------------------------------
// Name properties:

#define wszPROPDISTINGUISHEDNAME   TEXT("DistinguishedName")
#define wszPROPRAWNAME             TEXT("RawName")

#define wszPROPCOUNTRY             TEXT("Country")
#define wszPROPORGANIZATION        TEXT("Organization")
#define wszPROPORGUNIT             TEXT("OrgUnit")
#define wszPROPCOMMONNAME          TEXT("CommonName")
#define wszPROPLOCALITY            TEXT("Locality")
#define wszPROPSTATE               TEXT("State")
#define wszPROPTITLE               TEXT("Title")
#define wszPROPGIVENNAME           TEXT("GivenName")
#define wszPROPINITIALS            TEXT("Initials")
#define wszPROPSURNAME             TEXT("SurName")
#define wszPROPDOMAINCOMPONENT     TEXT("DomainComponent")
#define wszPROPEMAIL               TEXT("EMail")
#define wszPROPSTREETADDRESS       TEXT("StreetAddress")
#define wszPROPUNSTRUCTUREDNAME    TEXT("UnstructuredName")
#define wszPROPUNSTRUCTUREDADDRESS TEXT("UnstructuredAddress")
#define wszPROPDEVICESERIALNUMBER  TEXT("DeviceSerialNumber")

//+--------------------------------------------------------------------------
// Subject Name properties:

#define wszPROPSUBJECTDOT	    TEXT("Subject.")
#define wszPROPSUBJECTDISTINGUISHEDNAME \
				    wszPROPSUBJECTDOT wszPROPDISTINGUISHEDNAME
#define wszPROPSUBJECTRAWNAME       wszPROPSUBJECTDOT wszPROPRAWNAME

#define wszPROPSUBJECTCOUNTRY       wszPROPSUBJECTDOT wszPROPCOUNTRY
#define wszPROPSUBJECTORGANIZATION  wszPROPSUBJECTDOT wszPROPORGANIZATION
#define wszPROPSUBJECTORGUNIT       wszPROPSUBJECTDOT wszPROPORGUNIT
#define wszPROPSUBJECTCOMMONNAME    wszPROPSUBJECTDOT wszPROPCOMMONNAME
#define wszPROPSUBJECTLOCALITY      wszPROPSUBJECTDOT wszPROPLOCALITY
#define wszPROPSUBJECTSTATE         wszPROPSUBJECTDOT wszPROPSTATE
#define wszPROPSUBJECTTITLE	    wszPROPSUBJECTDOT wszPROPTITLE
#define wszPROPSUBJECTGIVENNAME	    wszPROPSUBJECTDOT wszPROPGIVENNAME
#define wszPROPSUBJECTINITIALS	    wszPROPSUBJECTDOT wszPROPINITIALS
#define wszPROPSUBJECTSURNAME	    wszPROPSUBJECTDOT wszPROPSURNAME
#define wszPROPSUBJECTDOMAINCOMPONENT wszPROPSUBJECTDOT wszPROPDOMAINCOMPONENT
#define wszPROPSUBJECTEMAIL	    wszPROPSUBJECTDOT wszPROPEMAIL
#define wszPROPSUBJECTSTREETADDRESS wszPROPSUBJECTDOT wszPROPSTREETADDRESS
#define wszPROPSUBJECTUNSTRUCTUREDNAME wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDNAME
#define wszPROPSUBJECTUNSTRUCTUREDADDRESS wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDADDRESS
#define wszPROPSUBJECTDEVICESERIALNUMBER wszPROPSUBJECTDOT wszPROPDEVICESERIALNUMBER

// end_certsrv

//+--------------------------------------------------------------------------
// Issuer Name properties:

#define wszPROPISSUERDOT	    TEXT("Issuer.")
#define wszPROPISSUERDISTINGUISHEDNAME \
				    wszPROPISSUERDOT wszPROPDISTINGUISHEDNAME
#define wszPROPISSUERRAWNAME        wszPROPISSUERDOT wszPROPRAWNAME

#define wszPROPISSUERCOUNTRY        wszPROPISSUERDOT wszPROPCOUNTRY
#define wszPROPISSUERORGANIZATION   wszPROPISSUERDOT wszPROPORGANIZATION
#define wszPROPISSUERORGUNIT        wszPROPISSUERDOT wszPROPORGUNIT
#define wszPROPISSUERCOMMONNAME     wszPROPISSUERDOT wszPROPCOMMONNAME
#define wszPROPISSUERLOCALITY       wszPROPISSUERDOT wszPROPLOCALITY
#define wszPROPISSUERSTATE          wszPROPISSUERDOT wszPROPSTATE
#define wszPROPISSUERTITLE	    wszPROPISSUERDOT wszPROPTITLE
#define wszPROPISSUERGIVENNAME	    wszPROPISSUERDOT wszPROPGIVENNAME
#define wszPROPISSUERINITIALS	    wszPROPISSUERDOT wszPROPINITIALS
#define wszPROPISSUERSURNAME	    wszPROPISSUERDOT wszPROPSURNAME
#define wszPROPISSUERDOMAINCOMPONENT wszPROPISSUERDOT wszPROPDOMAINCOMPONENT
#define wszPROPISSUEREMAIL	    wszPROPISSUERDOT wszPROPEMAIL
#define wszPROPISSUERSTREETADDRESS  wszPROPISSUERDOT wszPROPSTREETADDRESS
#define wszPROPISSUERUNSTRUCTUREDNAME wszPROPISSUERDOT wszPROPUNSTRUCTUREDNAME
#define wszPROPISSUERUNSTRUCTUREDADDRESS wszPROPISSUERDOT wszPROPUNSTRUCTUREDADDRESS
#define wszPROPISSUERDEVICESERIALNUMBER wszPROPISSUERDOT wszPROPDEVICESERIALNUMBER

#define wszPROPISSUERCOUNTRYOBJID \
    wszPROPISSUERDOT TEXT(szOID_COUNTRY_NAME)

#define wszPROPISSUERORGANIZATIONOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATION_NAME)

#define wszPROPISSUERORGUNITOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATIONAL_UNIT_NAME)

#define wszPROPISSUERCOMMONNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_COMMON_NAME)

#define wszPROPISSUERLOCALITYOBJID \
    wszPROPISSUERDOT TEXT(szOID_LOCALITY_NAME)

#define wszPROPISSUERSTATEOBJID \
    wszPROPISSUERDOT TEXT(szOID_STATE_OR_PROVINCE_NAME)

#define wszPROPISSUERTITLEOBJID \
    wszPROPISSUERDOT TEXT(szOID_TITLE)

#define wszPROPISSUERGIVENNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_GIVEN_NAME)

#define wszPROPISSUERINITIALSOBJID \
    wszPROPISSUERDOT TEXT(szOID_INITIALS)

#define wszPROPISSUERSURNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_SUR_NAME)

#define wszPROPISSUERDOMAINCOMPONENTOBJID \
    wszPROPISSUERDOT TEXT(szOID_DOMAIN_COMPONENT)

#define wszPROPISSUEREMAILOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_emailAddr)

#define wszPROPISSUERSTREETADDRESSOBJID \
    wszPROPISSUERDOT TEXT(szOID_STREET_ADDRESS)

#define wszPROPISSUERUNSTRUCTUREDNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_unstructName)

#define wszPROPISSUERUNSTRUCTUREDADDRESSOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_unstructAddr)

#define wszPROPISSUERDEVICESERIALNUMBEROBJID \
    wszPROPISSUERDOT TEXT(szOID_DEVICE_SERIAL_NUMBER)


//+--------------------------------------------------------------------------
// For mapping request attribute names to internal property names:

// Map to wszPROPSUBJECTCOUNTRY:
#define wszATTRCOUNTRY1			TEXT("C")
#define wszATTRCOUNTRY2			TEXT("Country")

// Map to wszPROPSUBJECTORGANIZATION:
#define wszATTRORG1			TEXT("O")
#define wszATTRORG2			TEXT("Org")
#define wszATTRORG3			TEXT("Organization")

// Map to wszPROPSUBJECTORGUNIT:
#define wszATTRORGUNIT1			TEXT("OU")
#define wszATTRORGUNIT2			TEXT("OrgUnit")
#define wszATTRORGUNIT3			TEXT("OrganizationUnit")
#define wszATTRORGUNIT4			TEXT("OrganizationalUnit")

// Map to wszPROPSUBJECTCOMMONNAME:
#define wszATTRCOMMONNAME1		TEXT("CN")
#define wszATTRCOMMONNAME2		TEXT("CommonName")

// Map to wszPROPSUBJECTLOCALITY:
#define wszATTRLOCALITY1		TEXT("L")
#define wszATTRLOCALITY2		TEXT("Locality")

// Map to wszPROPSUBJECTSTATE:
#define wszATTRSTATE1			TEXT("S")
#define wszATTRSTATE2			TEXT("ST")
#define wszATTRSTATE3			TEXT("State")

// Map to wszPROPSUBJECTTITLE:
#define wszATTRTITLE1			TEXT("T")
#define wszATTRTITLE2			TEXT("Title")

// Map to wszPROPSUBJECTGIVENNAME:
#define wszATTRGIVENNAME1		TEXT("G")
#define wszATTRGIVENNAME2		TEXT("GivenName")

// Map to wszPROPSUBJECTINITIALS:
#define wszATTRINITIALS1		TEXT("I")
#define wszATTRINITIALS2		TEXT("Initials")

// Map to wszPROPSUBJECTSURNAME:
#define wszATTRSURNAME1			TEXT("SN")
#define wszATTRSURNAME2			TEXT("SurName")

// Map to wszPROPSUBJECTDOMAINCOMPONENT:
#define wszATTRDOMAINCOMPONENT1		TEXT("DC")
#define wszATTRDOMAINCOMPONENT2		TEXT("DomainComponent")

// Map to wszPROPSUBJECTEMAIL:
#define wszATTREMAIL1			TEXT("E")
#define wszATTREMAIL2			TEXT("EMail")

// Map to wszPROPSUBJECTSTREETADDRESS:
#define wszATTRSTREETADDRESS1		TEXT("Street")
#define wszATTRSTREETADDRESS2		TEXT("StreetAddress")

// Map to wszPROPSUBJECTUNSTRUCTUREDNAME:
#define wszATTRUNSTRUCTUREDNAME1	TEXT("UnstructuredName")

// Map to wszPROPSUBJECTUNSTRUCTUREDADDRESS:
#define wszATTRUNSTRUCTUREDADDRESS1	TEXT("UnstructuredAddress")

// Map to wszPROPSUBJECTDEVICESERIALNUMBER:
#define wszATTRDEVICESERIALNUMBER1	TEXT("DeviceSerialNumber")


// begin_certsrv

//+--------------------------------------------------------------------------
// Request properties:
#define wszPROPREQUESTDOT	            TEXT("Request.")

#define wszPROPREQUESTREQUESTID		    TEXT("RequestID")
#define wszPROPREQUESTRAWREQUEST	    TEXT("RawRequest")
#define wszPROPREQUESTRAWARCHIVEDKEY	    TEXT("RawArchivedKey")
#define wszPROPREQUESTKEYRECOVERYHASHES	    TEXT("KeyRecoveryHashes")
#define wszPROPREQUESTRAWOLDCERTIFICATE	    TEXT("RawOldCertificate")
#define wszPROPREQUESTATTRIBUTES	    TEXT("RequestAttributes")
#define wszPROPREQUESTTYPE		    TEXT("RequestType")
#define wszPROPREQUESTFLAGS		    TEXT("RequestFlags")
#define wszPROPREQUESTSTATUSCODE	    TEXT("StatusCode")
#define wszPROPREQUESTDISPOSITION	    TEXT("Disposition")
#define wszPROPREQUESTDISPOSITIONMESSAGE    TEXT("DispositionMessage")
#define wszPROPREQUESTSUBMITTEDWHEN	    TEXT("SubmittedWhen")
#define wszPROPREQUESTRESOLVEDWHEN	    TEXT("ResolvedWhen")
#define wszPROPREQUESTREVOKEDWHEN	    TEXT("RevokedWhen")
#define wszPROPREQUESTREVOKEDEFFECTIVEWHEN  TEXT("RevokedEffectiveWhen")
#define wszPROPREQUESTREVOKEDREASON	    TEXT("RevokedReason")
#define wszPROPREQUESTERNAME		    TEXT("RequesterName")
#define wszPROPCALLERNAME		    TEXT("CallerName")
#define wszPROPREQUESTERADDRESS		    TEXT("RequesterAddress") // no_certsrv
#define wszPROPSIGNERPOLICIES		    TEXT("SignerPolicies")
#define wszPROPSIGNERAPPLICATIONPOLICIES    TEXT("SignerApplicationPolicies")

//+--------------------------------------------------------------------------
// Request attribute properties:

#define wszPROPCHALLENGE		TEXT("Challenge")
#define wszPROPEXPECTEDCHALLENGE	TEXT("ExpectedChallenge")

#define wszPROPDISPOSITION		TEXT("Disposition")
#define wszPROPDISPOSITIONDENY		TEXT("Deny")
#define wszPROPDISPOSITIONPENDING	TEXT("Pending")

#define wszPROPVALIDITYPERIODSTRING	TEXT("ValidityPeriod")
#define wszPROPVALIDITYPERIODCOUNT	TEXT("ValidityPeriodUnits")

#define wszPROPCERTTYPE			TEXT("CertType")
#define wszPROPCERTTEMPLATE		TEXT("CertificateTemplate")
#define wszPROPCERTUSAGE		TEXT("CertificateUsage")

#define wszPROPREQUESTOSVERSION		TEXT("RequestOSVersion")
#define wszPROPREQUESTCSPPROVIDER       TEXT("RequestCSPProvider")

#define wszPROPEXITCERTFILE		TEXT("CertFile")
#define wszPROPCLIENTBROWSERMACHINE	TEXT("cbm")
#define wszPROPCERTCLIENTMACHINE	TEXT("ccm")


//+--------------------------------------------------------------------------
// "System" properties
// ".#" means ".0", ".1", ".2" ... may be appended to the property name to
// collect context specific values.  For some properties, the suffix selects
// the CA certificate context.  For others, it selects the the CA CRL context.

#define wszPROPCATYPE                   TEXT("CAType")
#define wszPROPSANITIZEDCANAME          TEXT("SanitizedCAName")
#define wszPROPSANITIZEDSHORTNAME       TEXT("SanitizedShortName")
#define wszPROPMACHINEDNSNAME           TEXT("MachineDNSName")
#define wszPROPMODULEREGLOC             TEXT("ModuleRegistryLocation")
#define wszPROPUSEDS                    TEXT("fUseDS")
#define wszPROPSERVERUPGRADED           TEXT("fServerUpgraded")
#define wszPROPCONFIGDN			TEXT("ConfigDN")
#define wszPROPDOMAINDN			TEXT("DomainDN")
#define wszPROPLOGLEVEL			TEXT("LogLevel")

// Request Context properties:

#define wszPROPREQUESTERTOKEN		TEXT("RequesterToken") // no_certsrv
#define wszPROPREQUESTERCAACCESS	TEXT("RequesterCAAccess")
#define wszPROPUSERDN			TEXT("UserDN")
#define wszPROPTEMPLATECHANGESEQUENCENUMBER     TEXT("TemplateChangeSequenceNumber")


// CA Certificate properties: (all ".#" extensible except wszPROPCERTCOUNT)

#define wszPROPCERTCOUNT                TEXT("CertCount")
#define wszPROPRAWCACERTIFICATE         TEXT("RawCACertificate")
#define wszPROPCERTSTATE                TEXT("CertState")
#define wszPROPCERTSUFFIX               TEXT("CertSuffix")

// CA CRL properties: (all ".#" extensible)

#define wszPROPRAWCRL                   TEXT("RawCRL")
#define wszPROPRAWDELTACRL              TEXT("RawDeltaCRL")
#define wszPROPCRLINDEX                 TEXT("CRLIndex")
#define wszPROPCRLSTATE                 TEXT("CRLState")
#define wszPROPCRLSUFFIX                TEXT("CRLSuffix")

// Values for wszPROPCERTSTATE (see certadm.h):
//   CA_DISP_REVOKED    // This Cert has been revoked.
//   CA_DISP_VALID      // This Cert is still valid
//   CA_DISP_INVALID    // This Cert has expired.
//   CA_DISP_ERROR      // Cert unavailable (placehholder in registry?)

// Values for wszPROPCRLSTATE (see certadm.h):
//   CA_DISP_REVOKED	// All unexpired certs using this Cert's CRL have been
//			// revoked.
//   CA_DISP_VALID	// This Cert is still publishing CRLs as needed.
//   CA_DISP_INVALID    // All certs using this Cert's CRL are expired.
//   CA_DISP_ERROR      // This Cert's CRL is managed by another Cert.

// "Settable" system properties:
#define wszPROPEVENTLOGTERSE		TEXT("EventLogTerse")
#define wszPROPEVENTLOGERROR		TEXT("EventLogError")
#define wszPROPEVENTLOGWARNING		TEXT("EventLogWarning")
#define wszPROPEVENTLOGVERBOSE		TEXT("EventLogVerbose")

//+--------------------------------------------------------------------------
// Certificate properties:

#define wszPROPCERTIFICATEREQUESTID	       TEXT("RequestID")
#define wszPROPRAWCERTIFICATE		       TEXT("RawCertificate")
#define wszPROPCERTIFICATEHASH		       TEXT("CertificateHash")
#define wszPROPCERTIFICATETEMPLATE	       TEXT("CertificateTemplate")
#define wszPROPCERTIFICATEENROLLMENTFLAGS      TEXT("EnrollmentFlags")
#define wszPROPCERTIFICATEGENERALFLAGS         TEXT("GeneralFlags")
#define wszPROPCERTIFICATESERIALNUMBER	       TEXT("SerialNumber")
#define wszPROPCERTIFICATEISSUERNAMEID	       TEXT("IssuerNameID")//no_certsrv
#define wszPROPCERTIFICATENOTBEFOREDATE	       TEXT("NotBefore")
#define wszPROPCERTIFICATENOTAFTERDATE	       TEXT("NotAfter")
#define wszPROPCERTIFICATESUBJECTKEYIDENTIFIER TEXT("SubjectKeyIdentifier")
#define wszPROPCERTIFICATERAWPUBLICKEY	       TEXT("RawPublicKey")
#define wszPROPCERTIFICATEPUBLICKEYLENGTH      TEXT("PublicKeyLength")
#define wszPROPCERTIFICATEPUBLICKEYALGORITHM   TEXT("PublicKeyAlgorithm")
#define wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS \
    TEXT("RawPublicKeyAlgorithmParameters")
#define wszPROPCERTIFICATEUPN		       TEXT("UPN")

// Obsolete:
#define wszPROPCERTIFICATETYPE		       TEXT("CertificateType")
#define wszPROPCERTIFICATERAWSMIMECAPABILITIES TEXT("RawSMIMECapabilities")
#define wszPROPNAMETYPE			       TEXT("NameType")

//+--------------------------------------------------------------------------
// Certificate extension properties:

#define EXTENSION_CRITICAL_FLAG	      0x00000001
#define EXTENSION_DISABLE_FLAG	      0x00000002
#define EXTENSION_POLICY_MASK	      0x0000ffff // Settable by admin+policy

#define EXTENSION_ORIGIN_REQUEST      0x00010000
#define EXTENSION_ORIGIN_POLICY	      0x00020000
#define EXTENSION_ORIGIN_ADMIN	      0x00030000
#define EXTENSION_ORIGIN_SERVER	      0x00040000
#define EXTENSION_ORIGIN_RENEWALCERT  0x00050000
#define EXTENSION_ORIGIN_IMPORTEDCERT 0x00060000
#define EXTENSION_ORIGIN_PKCS7	      0x00070000
#define EXTENSION_ORIGIN_CMC	      0x00080000
#define EXTENSION_ORIGIN_MASK	      0x000f0000

//+--------------------------------------------------------------------------
// Extension properties:

#define wszPROPEXTREQUESTID		TEXT("ExtensionRequestId")
#define wszPROPEXTNAME			TEXT("ExtensionName")
#define wszPROPEXTFLAGS			TEXT("ExtensionFlags")
#define wszPROPEXTRAWVALUE		TEXT("ExtensionRawValue")

//+--------------------------------------------------------------------------
// Attribute properties:

#define wszPROPATTRIBREQUESTID		TEXT("AttributeRequestId")
#define wszPROPATTRIBNAME		TEXT("AttributeName")
#define wszPROPATTRIBVALUE		TEXT("AttributeValue")

//+--------------------------------------------------------------------------
// CRL properties:

#define wszPROPCRLROWID			TEXT("CRLRowId")
#define wszPROPCRLNUMBER		TEXT("CRLNumber")
#define wszPROPCRLMINBASE		TEXT("CRLMinBase") // Delta CRLs only
#define wszPROPCRLNAMEID		TEXT("CRLNameId")
#define wszPROPCRLCOUNT			TEXT("CRLCount")
#define wszPROPCRLTHISUPDATE		TEXT("CRLThisUpdate")
#define wszPROPCRLNEXTUPDATE		TEXT("CRLNextUpdate")
#define wszPROPCRLTHISPUBLISH		TEXT("CRLThisPublish")
#define wszPROPCRLNEXTPUBLISH		TEXT("CRLNextPublish")
#define wszPROPCRLEFFECTIVE		TEXT("CRLEffective")
#define wszPROPCRLPROPAGATIONCOMPLETE	TEXT("CRLPropagationComplete")
#define wszPROPCRLLASTPUBLISHED		TEXT("CRLLastPublished")
#define wszPROPCRLPUBLISHATTEMPTS	TEXT("CRLPublishAttempts")
#define wszPROPCRLPUBLISHFLAGS		TEXT("CRLPublishFlags")
#define wszPROPCRLPUBLISHSTATUSCODE	TEXT("CRLPublishStatusCode")
#define wszPROPCRLPUBLISHERROR		TEXT("CRLPublishError")
#define wszPROPCRLRAWCRL		TEXT("CRLRawCRL")

//+--------------------------------------------------------------------------
// CRL Published Flags:

#define CPF_BASE		0x00000001
#define CPF_DELTA		0x00000002
#define CPF_COMPLETE		0x00000004
#define CPF_SHADOW		0x00000008
#define CPF_CASTORE_ERROR	0x00000010
#define CPF_BADURL_ERROR	0x00000020
#define CPF_MANUAL		0x00000040
#define CPF_LDAP_ERROR		0x00000100
#define CPF_FILE_ERROR		0x00000200
#define CPF_FTP_ERROR		0x00000400
#define CPF_HTTP_ERROR		0x00000800

//+--------------------------------------------------------------------------
// GetProperty/SetProperty Flags:
//
// Choose one Type

#define PROPTYPE_LONG		 0x00000001	// Signed long
#define PROPTYPE_DATE		 0x00000002	// Date+Time
#define PROPTYPE_BINARY		 0x00000003	// Binary data
#define PROPTYPE_STRING		 0x00000004	// Unicode String
#define PROPTYPE_MASK		 0x000000ff

// Choose one Caller:

#define PROPCALLER_SERVER	 0x00000100
#define PROPCALLER_POLICY	 0x00000200
#define PROPCALLER_EXIT		 0x00000300
#define PROPCALLER_ADMIN	 0x00000400
#define PROPCALLER_REQUEST	 0x00000500
#define PROPCALLER_MASK		 0x00000f00
// end_certsrv

// Choose one Table:

#define PROPTABLE_REQCERT	 0x00000000	// OpenRow only
#define PROPTABLE_REQUEST	 0x00001000
#define PROPTABLE_CERTIFICATE	 0x00002000
#define PROPTABLE_EXTENSION	 0x00003000
#define PROPTABLE_ATTRIBUTE      0x00004000
#define PROPTABLE_CRL		 0x00005000
#define PROPTABLE_MASK		 0x0000f000

#define PROPFLAGS_INDEXED	 0x00010000	// add_certsrv
#define PROPFLAGS_MASK		 0x000f0000

#define PROPMARSHAL_LOCALSTRING	 0x00100000
#define PROPMARSHAL_NULLBSTROK	 0x00200000

#define PROPOPEN_READONLY	 0x00400000	// OpenRow only
#define PROPOPEN_DELETE	 	 0x00800000	// OpenRow only
#define PROPOPEN_CERTHASH 	 0x01000000	// OpenRow only


// begin_certsrv

// RequestFlags definitions:

#define CR_FLG_FORCETELETEX	 0x00000001
#define CR_FLG_RENEWAL		 0x00000002
#define CR_FLG_FORCEUTF8	 0x00000004
#define CR_FLG_CAXCHGCERT	 0x00000008
#define CR_FLG_ENROLLONBEHALFOF	 0x00000010
#define CR_FLG_SUBJECTUNMODIFIED 0x00000020
#define CR_FLG_OLDRFCCMC	 0x40000000	// BUGBUG: temporary!!!
#define CR_FLG_PUBLISHERROR	 0x80000000
// end_certsrv


#define CB_DBMAXBINARY            (4 * 1024)
#define CB_DBMAXRAWCERTIFICATE    (16 * 1024)
#define CB_DBMAXRAWREQUEST        (64 * 1024)
#define CB_DBMAXRAWCRL		  (512 * 1024 * 1024)	// 512mb

#define CCH_DBMAXTEXT_MAXINTERNAL (255 / sizeof(WCHAR))    // 127 chars!
#define CB_DBMAXTEXT_MAXINTERNAL  (CCH_DBMAXTEXT_MAXINTERNAL * sizeof(WCHAR))

#define CCH_DBMAXTEXT_SHORT       1024
#define CB_DBMAXTEXT_SHORT        (CCH_DBMAXTEXT_SHORT * sizeof(WCHAR))

#define CCH_DBMAXTEXT_MEDIUM      (4 * 1024)
#define CB_DBMAXTEXT_MEDIUM       (CCH_DBMAXTEXT_MEDIUM * sizeof(WCHAR))

#define CCH_DBMAXTEXT_LONG        (16 * 1024)
#define CB_DBMAXTEXT_LONG         (CCH_DBMAXTEXT_LONG * sizeof(WCHAR))

#define CCH_DBMAXTEXT_OID         CCH_DBMAXTEXT_MAXINTERNAL
#define CB_DBMAXTEXT_OID          CB_DBMAXTEXT_MAXINTERNAL

#define CCH_DBMAXTEXT_REQUESTNAME CCH_DBMAXTEXT_SHORT
#define CB_DBMAXTEXT_REQUESTNAME  CB_DBMAXTEXT_SHORT

#define CCH_DBMAXTEXT_DISPSTRING  CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_DISPSTRING   CB_DBMAXTEXT_MEDIUM


#define CCH_DBMAXTEXT_RDN         CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_RDN          CB_DBMAXTEXT_MEDIUM

#define CCH_DBMAXTEXT_DN          CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_DN           CB_DBMAXTEXT_MEDIUM


#define CCH_DBMAXTEXT_ATTRNAME    CCH_DBMAXTEXT_MAXINTERNAL
#define CB_DBMAXTEXT_ATTRNAME     CB_DBMAXTEXT_MAXINTERNAL

#define CCH_DBMAXTEXT_ATTRVALUE   CCH_DBMAXTEXT_MEDIUM
#define CB_DBMAXTEXT_ATTRVALUE    CB_DBMAXTEXT_MEDIUM

#define CCH_DBMAXTEXT_ATTRSTRING  CCH_DBMAXTEXT_LONG
#define CB_DBMAXTEXT_ATTRSTRING   CB_DBMAXTEXT_LONG


#define cchHASHMAX			64
#define cchSERIALNUMBERMAX		64

#define cchUNSTRUCTUREDNAMEMAX		CCH_DBMAXTEXT_SHORT
#define cchUNSTRUCTUREDADDRESSMAX	CCH_DBMAXTEXT_SHORT
#define cchDEVICESERIALNUMBERMAX	CCH_DBMAXTEXT_SHORT

// Subject RDN string length limits from PKIX Part 1 doc:

#define cchCOUNTRYNAMEMAX		2
#define cchORGANIZATIONNAMEMAX		64
#define cchORGANIZATIONALUNITNAMEMAX	64
#define cchCOMMONNAMEMAX		64
#define cchLOCALITYMANAMEMAX		128
#define cchSTATEORPROVINCENAMEMAX	128
#define cchTITLEMAX			64
#define cchGIVENNAMEMAX			16
#define cchINITIALSMAX			5
#define cchSURNAMEMAX			40
#define cchDOMAINCOMPONENTMAX		128
#define cchEMAILMAX			128
#define cchSTREETADDRESSMAX		30

#ifdef cchCOMMONNAMEMAX_XELIB
# if cchCOMMONNAMEMAX_XELIB != cchCOMMONNAMEMAX
#  error cchCOMMONNAMEMAX_XELIB != cchCOMMONNAMEMAX
# endif
#endif



// begin_certsrv

// Disposition property values:

// Disposition values for requests in the queue:
#define DB_DISP_ACTIVE	        8	// being processed
#define DB_DISP_PENDING		9	// taken under submission
#define DB_DISP_QUEUE_MAX	9	// max disposition value for queue view

#define DB_DISP_FOREIGN		12	// archived foreign cert

#define DB_DISP_CA_CERT		15	// CA cert
#define DB_DISP_CA_CERT_CHAIN	16	// CA cert chain
#define DB_DISP_KRA_CERT	17	// KRA cert

// Disposition values for requests in the log:
#define DB_DISP_LOG_MIN		20	// min disposition value for log view
#define DB_DISP_ISSUED		20	// cert issued
#define DB_DISP_REVOKED	        21	// issued and revoked

// Disposition values for failed requests in the log:
#define DB_DISP_LOG_FAILED_MIN	30	// min disposition value for log view
#define DB_DISP_ERROR		30	// request failed
#define DB_DISP_DENIED		31	// request denied

// end_certsrv


// CertIF property callback support:

typedef HRESULT (WINAPI FNCIGETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue);

FNCIGETPROPERTY PropCIGetProperty;


typedef HRESULT (WINAPI FNCISETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN VARIANT const *pvarPropertyValue);

FNCISETPROPERTY PropCISetProperty;


typedef HRESULT (WINAPI FNCIGETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT VARIANT *pvarValue);

FNCIGETEXTENSION PropCIGetExtension;


typedef HRESULT (WINAPI FNCISETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN VARIANT const *pvarValue);

FNCISETEXTENSION PropCISetExtension;



// CertIF property enumeration callback support:

#define CIE_OBJECTID	     0x00000001	// return object ids for names
#define CIE_RESET            0x00000002

#define CIE_TABLE_EXTENSIONS 0x00000010
#define CIE_TABLE_ATTRIBUTES 0x00000020
#define CIE_TABLE_MASK       0x000000f0

#define CIE_CALLER_POLICY    0x00000200
#define CIE_CALLER_EXIT	     0x00000300
#define CIE_CALLER_MASK	     0x00000f00


class CIENUM {
public:
    CIENUM() { m_penum = NULL; }

    HRESULT EnumSetup(IN DWORD RequestId, IN LONG Context, IN DWORD Flags);
    HRESULT EnumNext(OUT BSTR *pstrPropertyName);
    HRESULT EnumClose();

    LONG GetContext() { return(m_Context); }
    DWORD GetFlags() { return(m_Flags); }

private:
    IEnumCERTDBNAME *m_penum;
    LONG             m_Context;
    DWORD            m_Flags;
};

typedef HRESULT (WINAPI FNCIENUMSETUP)(
    IN LONG Context,
    IN LONG Flags,
    IN OUT CIENUM *pciEnum);

FNCIENUMSETUP PropCIEnumSetup;


typedef HRESULT (WINAPI FNCIENUMNEXT)(
    IN OUT CIENUM *pciEnum,
    OUT BSTR *pstrPropertyName);

FNCIENUMNEXT PropCIEnumNext;


typedef HRESULT (WINAPI FNCIENUMCLOSE)(
    IN OUT CIENUM *pciEnum);

FNCIENUMCLOSE PropCIEnumClose;


#endif // __CSPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csresstr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csresstr.h
//
// Contents:    Cert Server resource verification support
//
//---------------------------------------------------------------------------


// Build a local resstr.h, include this include file in one compiland, and
// invoke myVerifyResourceStrings() to verify all resources are present.

#if DBG
#define myVerifyResourceStrings(h)	_myVerifyResourceStrings(h)
#else
#define myVerifyResourceStrings(h)	S_OK
#endif


#if DBG
typedef struct _RESSTRING
{
    WCHAR const *pwszSymbol;
    DWORD IdString;
} RESSTRING;

#define RESSTR(id)		{ L#id, id }

RESSTRING g_aResString[] = {
#include "resstr.h"
    { NULL, 0 }
};


//+------------------------------------------------------------------------
//  Function:   _myVerifyResourceStrings
//
//  Synopsis:   Load and verify all resource strings are present
//
//-------------------------------------------------------------------------

HRESULT
_myVerifyResourceStrings(
    HINSTANCE hInstance)
{
    HRESULT hr = S_OK;
    BOOL fDump;
    int i;
    int cFail;
    CAutoLPWSTR wszStrBuf;
    WCHAR const *pwsz;

    wszStrBuf = (LPWSTR)LocalAlloc(LMEM_FIXED, 2048);
    _JumpIfAllocFailed(wszStrBuf, error);

    fDump = NULL != getenv("CertSrv_DumpStrings");

    cFail = 0;
    for (i = 0; NULL != g_aResString[i].pwszSymbol; i++)
    {
	if (!LoadString(
		    hInstance,
		    g_aResString[i].IdString,
		    wszStrBuf,
		    sizeof(wszStrBuf)/sizeof(WCHAR)))
	{
	    hr = myHLastError();
	    if (S_OK == hr)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    }
	    _PrintErrorStr(hr, "LoadString", g_aResString[i].pwszSymbol);
	    cFail++;
	    wcscpy(wszStrBuf, L"-- MISSING");
	}
	if (fDump)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"Resource(%ws: %ws)\n",
		g_aResString[i].pwszSymbol,
		wszStrBuf));
	}
    }
    if (!GetModuleFileName(hInstance, wszStrBuf, ARRAYSIZE(wszStrBuf)))
    {
	HRESULT hr2 = myHLastError();

	_PrintError(hr2, "GetModuleFileName");
	wcscpy(wszStrBuf, L"UNKNOWN MODULE");
    }
    if (0 == cFail)
    {
	if (fDump)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"%ws: Resource strings all present\n",
		wszStrBuf));
	}
    }
    else
    {
	DBGPRINT((
	    DBG_SS_ERROR,
	    "%ws: %u Resource strings missing\n",
	    wszStrBuf,
	    cFail));
    }

error:
    return(hr);
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csw97sht.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97sht.h
//
//--------------------------------------------------------------------------

// csw97sht.h: interface for the CWizard97PropertySheet class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "tfc.h"
#include "tfcprop.h"

#define NUM_PAGES 10

class CWizard97PropertyPage; // Forward definition

class CWizard97PropertySheet  
{
public:
    void AddPage(CWizard97PropertyPage *pPage);

    CWizard97PropertySheet(
		    HINSTANCE hInstance,
		    UINT nIDCaption,
		    UINT nIDWaterMark,
		    UINT nIDBanner,
		    BOOL fWizard);
    virtual ~CWizard97PropertySheet();

    BOOL DoWizard(HWND hParent);

private:
    CString m_title;

    PROPSHEETHEADER		m_psh;
    HPROPSHEETPAGE		m_pPageArr[NUM_PAGES];
    CWizard97PropertyPage*	m_pPagePtr[NUM_PAGES];
    int				m_nPageCount;
    HWND			m_hWnd;
};

#endif // !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\csw97ppg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97ppg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "csw97sht.h"

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage dialog

#define CSW97PG_IDLARGEFONTNAME	0
#define CSW97PG_IDLARGEFONTSIZE	1
#define CSW97PG_IDSMALLFONTNAME	2
#define CSW97PG_IDSMALLFONTSIZE	3
#define CSW97PG_COUNT		4

class CWizard97PropertyPage : public PropertyPage
{
// Construction
public:
    PROPSHEETPAGE		 m_psp97;
    CString			 m_szHeaderTitle;
    CString			 m_szHeaderSubTitle;
    CWizard97PropertySheet	*m_pWiz;

    void InitWizard97(bool bHideHeader);
    CWizard97PropertyPage();
    CWizard97PropertyPage(
	HINSTANCE hInstance,
	UINT nIDTemplate,
	UINT rgnIDFont[CSW97PG_COUNT]);
    virtual ~CWizard97PropertyPage();

// Dialog Data


// Overrides

// Implementation
protected:
    virtual BOOL OnInitDialog();

    BOOL SetupFonts();
    HFONT GetBigBoldFont();
    HFONT GetBoldFont();

    CFont m_boldFont;
    CFont m_bigBoldFont;
    HINSTANCE m_hInstance;
    UINT m_rgnIDFont[CSW97PG_COUNT];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\progress.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       progress.h
//
//--------------------------------------------------------------------------


// progress bar on MMC window
HANDLE
StartProgressDlg(
    HINSTANCE hInstance,
    HWND      hwndParent,
    DWORD     dwTickerSeconds,
    DWORD     dwTimeoutSeconds,
    UINT      iRscJobDescription);

BOOL FProgressDlgRunning();
void EndProgressDlg(HANDLE hThread);


HANDLE
StartPercentCompleteDlg(
    HINSTANCE  hInstance,
    HWND       hwndParent,
    UINT       iRscJobDescription,
    DBBACKUPPROGRESS *pdbp);

void EndPercentCompleteDlg(HANDLE hProgressThread);



inline 
HANDLE StartProgressDlg(HINSTANCE hInstance, HWND hwndParent, DWORD dwTickerSeconds, DWORD dwTimeoutSeconds)
{ return StartProgressDlg(hInstance, hwndParent, dwTickerSeconds, dwTimeoutSeconds, 0);  }

inline 
HANDLE
StartPercentCompleteDlg(
    HINSTANCE  hInstance,
    HWND       hwndParent,
    DBBACKUPPROGRESS *pdbp)
{ return StartPercentCompleteDlg(hInstance, hwndParent, 0, pdbp); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\polreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       polreg.h
//
//  Contents:   NT Enterprise CA Policy registry locations
//
//--------------------------------------------------------------------------

#ifndef _POLREG_H_
#define _POLREG_H_

/*
 *[HKEY_LOCAL_MACHINE]
 *   [Software]
 *       [Microsoft]
 *           [Cryptography]
 *              [CertificateTemplates]
 *                  [<CertType>] (Name)
 *
 *                       DisplayName:   REG_SZ:     - Display name of this cert type
 *                       SupportedCSPs: REG_MULTI_SZ - Supported CSP's
 *                       KeyUsage:      REG_BINARY: - KeyUsage bitfield
 *                       ExtKeyUsageSyntax: REG_SZ: - ExtKeyUsage OID's (comma separated)
 *                       BasicContraintsCA:REG_DWORD: - CA flag
 *                       BasicConstraintsLen:REG_DWORD: - Path Len
 *                       Flags:REG_DWORD:  - Flags
 *                       KeySpec:REG_DWORD:  - Key Spec
 */

// Policy root
// Cert Types
#define wszCERTTYPECACHE        TEXT("SOFTWARE\\Microsoft\\Cryptography\\CertificateTemplateCache")


// Values under each cert type
#define wszSECURITY         TEXT("Security")
#define wszDISPNAME         TEXT("DisplayName")
#define wszCSPLIST          TEXT("SupportedCSPs")
#define wszKEYUSAGE         TEXT("KeyUsage")
#define wszEXTKEYUSAGE      TEXT("ExtKeyUsageSyntax")
#define wszBASICCONSTCA     TEXT("IsCA")
#define wszBASICCONSTLEN    TEXT("PathLen")
#define wszCTFLAGS          TEXT("Flags")
#define wszCTREVISION       TEXT("Revision")
#define wszCTKEYSPEC        TEXT("KeySpec")

#define wszCRITICALEXTENSIONS TEXT("CriticalExtensions")
#define wszEXPIRATION      TEXT("ValidityPeriod")
#define wszOVERLAP         TEXT("RenewalOverlap")
/* Key Names */

#define wszTIMESTAMP     TEXT("Timestamp")

#endif // _POLREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\initcert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       initcert.h
//
//--------------------------------------------------------------------------

#ifndef __INITCERT_H__
#define __INITCERT_H__


typedef enum {
    CS_UPGRADE_UNKNOWN = 0,
    CS_UPGRADE_NO,        // install

    //CS_UPGRADE_NT4SP4 =2,    // upgrade from NT4 certsrv v10 or SP4 with certsrv   // upg unsupported
    //CS_UPGRADE_NT5BETA2 =3,  // upgrade from NT5 Beta 2                            // upg unsupported
    //CS_UPGRADE_NT5BETA3 =4,  // upgrade from NT5 Beta 3                            // upg unsupported

    CS_UPGRADE_WIN2000 =5,     // upgrade from Win2K
    CS_UPGRADE_UNSUPPORTED,    // upgrade is not supported
    CS_UPGRADE_WHISTLER,       // upgrade from build to build

} CS_ENUM_UPGRADE;

typedef enum {
    ENUM_WIZ_UNKNOWN = 0,
    ENUM_WIZ_OCM,
    ENUM_WIZ_CATYPE,
    ENUM_WIZ_ADVANCE,
    ENUM_WIZ_IDINFO,
    ENUM_WIZ_KEYGEN,
    ENUM_WIZ_STORE,
    ENUM_WIZ_REQUEST,
} ENUM_WIZPAGE;

typedef struct csp_hash_tag
{
    ALG_ID               idAlg;
    WCHAR               *pwszName;
    struct csp_hash_tag *next;
    struct csp_hash_tag *last;
} CSP_HASH;

typedef struct csp_info_tag {
    DWORD                dwProvType;
    WCHAR               *pwszProvName;
    BOOL                 fMachineKeyset;
    struct csp_info_tag *next;
    struct csp_info_tag *last;
    CSP_HASH            *pHashList;
} CSP_INFO;
    
typedef struct key_list_tag
{
    WCHAR    *pwszName;
    struct key_list_tag    *next;
    struct key_list_tag    *last;
} KEY_LIST;

typedef struct tagCAServerSetupInfo
{
    // setup attributes
// 0x0000
    ENUM_CATYPES          CAType;
    WCHAR                *pwszCACommonName;

// 0x0020
    BOOL                  fAdvance;
    CSP_INFO             *pCSPInfo;	// currently selected CSP
    CSP_HASH             *pHashInfo;	// currently selected hash algorithm
    DWORD                 dwKeyLength;
    ENUM_PERIOD           enumValidityPeriod;
    DWORD                 dwValidityPeriodCount;
    BOOL                  fUseDS;

// 0x0040
    WCHAR                *pwszSharedFolder;
    WCHAR                *pwszDBDirectory;
    WCHAR                *pwszLogDirectory;
    BOOL                  fSaveRequestAsFile;
    BOOL                  fCAsExist;
    WCHAR                *pwszRequestFile;
    WCHAR                *pwszParentCAMachine;
    WCHAR                *pwszParentCAName;

// 0x0060
    BOOL                  fPreserveDB;
    BOOL                  fInteractiveService; // allow service to interact
                                               // with the desktop

    // setup intermediate attributes
    ENUM_WIZPAGE          LastWiz;
    WCHAR                *pwszSanitizedName;
    CSP_INFO             *pCSPInfoList;		// list of all available CSPs
    CSP_INFO             *pDefaultCSPInfo;	// obj representing default CSP,
						// not a CSP in pCSPInfoList
    CSP_HASH             *pDefaultHashInfo;	// object representing default
						// hash algorithm, not a hash
						// algorighm in the currently
						// selected CSP
    KEY_LIST             *pKeyList;		// list of key containers for

// 0x0080
    DWORD                 dwKeyLenMin;		// minumum key length for the
						// currently selected CSP

    DWORD                 dwKeyLenMax;		// maximum key length for the
						// currently selected CSP
    WCHAR                *pwszValidityPeriodCount;
    LONG                  lExistingValidity;
    WCHAR                *pwszCACertFile;
    HCERTSTORE            hMyStore;
    CHAR                 *pszAlgId;
    BOOL                  fCertSrvWasRunning;

// 0x00a0
    FILETIME              NotBefore;
    FILETIME              NotAfter;
    DWORD                 dwRevocationFlags;

    // setup intermediate attributes for unattended

    WCHAR                *pwszCAType;
    WCHAR                *pwszValidityPeriodString;
    WCHAR                *pwszHashAlgorithm;

// 0x00c0
    WCHAR                *pwszKeyLength;
    BOOL                  fValidatedHashAndKey;
    WCHAR                *pwszUseExistingCert;
    WCHAR                *pwszPreserveDB;
    WCHAR                *pwszPFXFile;
    WCHAR                *pwszPFXPassword;
    WCHAR                *pwszInteractiveService;

    // upgrade attributes
    DWORD                 dwUpgradeEditFlags;
// 0x00e0
    DWORD                 dwUpgradeRevFlags;
    BOOL                  fSavedCAInDS;
    BOOL                  fCreatedShare;
    WCHAR                *pwszCustomPolicy;
    WCHAR                *pwszzCustomExit;

    // * The following 2 variables replace these 5 variables:
    //   fCreatedKey,
    //   pwszRevertKey,
    //   pwszImportKey,
    //   pwszExistingKey,
    //   fUseExistingKey
    //
    // * Invariant: fUseExistingKey == (NULL != pwszKeyContainerName)
    //
    // * pwszKeyContainerName should always contains the name of an existing
    //   key container, or be NULL if a new key container needs to be created.
    //   Once the new container is created, the variable holds the name of the
    //   container.
    //
    // * Always use SetKeyContainerName() and ClearKeyContainerName() to modify
    //   these variables. This makes sure that pwszDesanitizedKeyContainerName
    //   is always in sync.

    WCHAR                *pwszKeyContainerName;	// exact name of the container
						// used by the CSP

    WCHAR                *pwszDesanitizedKeyContainerName; // name displayed
							   // to the user

    BOOL                  fDeletableNewKey;	// TRUE iff the

// 0x0100
						// KeyContainerName points to a
						// key container that we should
						// delete if we don't use.

    BOOL                  fKeyGenFailed;	// TRUE if KeyGen failed

    // * The following 1 variable replace these 4 variables:
    //   fUseExistingCert,
    //   fFoundMatchedCertInStore,
    //   fMatchedCertType,
    //   pSCertContextFromStore
    //
    // * Invariant: fUseExistingCert==(NULL!=pccExistingCert)
    //
    // * pccExistingCert should always be a pointer to an existing cert context,
    //   or be NULL if we are not using an existing cert
    //
    // * Always use SetExistingCertToUse() and ClearExistingCertToUse() to
    //   modify these variables. This makes sure that pccExistingCert is
    //   properly freed.

    CERT_CONTEXT const   *pccExistingCert;	// an open cert context
    CERT_CONTEXT const   *pccUpgradeCert;	// CA Cert context for upgrade
    DWORD                 dwCertNameId;		// CA Cert NameId
    BOOL                  fUNCPathNotFound; // flag for default shared folder
// 0x0114
    WCHAR                *pwszDNSuffix;        // CN=%1, DC=x, DC=y, DC=z -- dynamically generated template
    WCHAR                *pwszFullCADN;

} CASERVERSETUPINFO;

typedef struct tagCAWebClientSetupInfo
{
    WCHAR                *pwszWebCAMachine;
    WCHAR                *pwszWebCAName;
    WCHAR                *pwszSanitizedWebCAName;
    BOOL                  fUseDS;
    WCHAR                *pwszSharedFolder;
    ENUM_CATYPES          WebCAType;
} CAWEBCLIENTSETUPINFO;

typedef struct tagCASetupInfo
{
    CASERVERSETUPINFO    *pServer;
    CAWEBCLIENTSETUPINFO *pClient;
} CASETUPINFO;

typedef struct _PER_COMPONENT_DATA 
{
    // component generic
    WCHAR    *pwszComponent;	// Component name from OCM
    HINF      MyInfHandle;	// Open inf handle to per-component inf
    DWORDLONG Flags;		// Operation flags from SETUP_DATA structure
    OCMANAGER_ROUTINES HelperRoutines;

    // setup related
    HINSTANCE hInstance;
    HRESULT   hrContinue;   // set code if fatal error
    WCHAR    *pwszCustomMessage;
    int       iErrMsg;      // set msg id for fatal error pop up
    BOOL      fShownErr;    // set to TRUE if pop up earlier so avoid double
    BOOL      fUnattended;
    BOOL      fPostBase;
    WCHAR    *pwszUnattendedFile;
    WCHAR    *pwszServerName;
    WCHAR    *pwszServerNameOld;
    WCHAR    *pwszSystem32;

    // CA related
    DWORD     dwInstallStatus;
    CASETUPINFO  CA;
    CS_ENUM_UPGRADE UpgradeFlag;
    BOOL            fCreatedVRoot;
} PER_COMPONENT_DATA;


//+--------------------------------------------------------------------------
// Prototypes:

HRESULT
csiGetKeyList(
    IN DWORD        dwProvType,
    IN WCHAR const *pwszProvName,
    IN BOOL         fMachineKeySet,
    IN BOOL         fSilent,
    OUT KEY_LIST  **ppKeyList);

VOID
csiFreeKeyList(
    IN OUT KEY_LIST *pKeyList);

HRESULT
csiBuildRequest(
    OPTIONAL IN HINF hInf,
    OPTIONAL IN CERT_CONTEXT const *pccPrevious,
    IN BYTE const *pbSubjectEncoded,
    IN DWORD cbSubjectEncoded,
    IN char const *pszAlgId,
    IN BOOL fNewKey,
    IN DWORD iCert,
    IN DWORD iKey,
    IN HCRYPTPROV hProv,
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT BYTE **ppbEncode,
    OUT DWORD *pcbEncode);

HRESULT
csiBuildFileName(
    IN WCHAR const *pwszDirPath,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszExt,
    IN DWORD iCert,
    OUT WCHAR **ppszOut,
    HINSTANCE hInstance,
    BOOL fUnattended,
    IN HWND hwnd);

HRESULT
csiBuildCACertFileName(
    IN HINSTANCE hInstance,
    IN HWND hwnd,
    IN BOOL fUnattended,
    OPTIONAL IN WCHAR const *pwszSharedFolder,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszExt,
    IN DWORD iCert,
    OUT WCHAR **ppwszCACertFile);

HRESULT
csiGetCARequestFileName(
    IN HINSTANCE hInstance,
    IN HWND hwnd,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD iCertNew,
    IN DWORD iKey,
    OUT WCHAR **ppwszRequestFile);

BOOL
csiWriteDERToFile(
    IN WCHAR const *pwszFileName,
    IN BYTE const *pbDER,
    IN DWORD cbDER,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);

HRESULT
csiBuildAndWriteCert(
    IN HCRYPTPROV hCryptProv,
    IN CASERVERSETUPINFO const *pServer,
    OPTIONAL IN WCHAR const *pwszFile,
    IN WCHAR const *pwszEnrollFile,
    OPTIONAL IN CERT_CONTEXT const *pCertContextFromStore,
    OPTIONAL OUT CERT_CONTEXT const **ppCertContextOut,
    IN WCHAR const *pwszCAType,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);

VOID
csiFreeCertNameInfo(
    IN OUT CERT_NAME_INFO *pNameInfo);

HRESULT
csiGetCRLPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz);

HRESULT
csiGetCACertPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz);

HRESULT
csiSetupCAInDS(
    IN HWND                hwnd,
    IN WCHAR const        *pwszCAServer,
    IN WCHAR const        *pwszSanitizedCAName,
    IN WCHAR const        *pwszCADisplayName,
    IN WCHAR const        *pwszCADescription,
    IN ENUM_CATYPES        caType,
    IN DWORD               iCert,
    IN DWORD               iCRL,
    IN BOOL                fRenew,
    IN CERT_CONTEXT const *pCert);

HRESULT
csiFillKeyProvInfo(
    IN WCHAR const          *pwszContainerName,
    IN WCHAR const          *pwszProvName,
    IN DWORD		     dwProvType,
    IN BOOL  const           fMachineKeyset,
    OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo);

VOID
csiFreeKeyProvInfo(
    IN OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo);

BOOL
csiIsAnyDSCAAvailable(VOID);

HRESULT
csiSubmitCARequest(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN BOOL          fRenew,
    IN BOOL          fRetrievePending,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszParentCAMachine,
    IN WCHAR const  *pwszParentCAName,
    IN BYTE const   *pbRequest,
    IN DWORD         cbRequest,
    OUT BSTR        *pbStrChain);

HRESULT
csiFinishInstallationFromPKCS7(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszCACommonName,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN ENUM_CATYPES  CAType,
    IN DWORD         iCert,
    IN DWORD         iCRL,
    IN BOOL          fUseDS,
    IN BOOL          fRenew,
    IN WCHAR const  *pwszServerName,
    IN BYTE const   *pbChainOrCert,
    IN DWORD         cbChainOrCert,
    OPTIONAL IN WCHAR const *pwszCACertFile);

HRESULT
csiSaveCertAndKeys(
    IN CERT_CONTEXT const *pCert,
    IN HCERTSTORE hAdditionalStore,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN ENUM_CATYPES CAType);

HRESULT 
csiInitializeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    IN BOOL         fUseEnterpriseACL,   // which ACL to use
    IN BOOL         fSetDsSecurity);     // whether to set DS security

HRESULT
csiGenerateCAKeys(
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvName,
    IN DWORD        dwProvType,
    IN BOOL         fMachineKeyset,
    IN DWORD        dwKeyLength,
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND         hwnd,
    OUT BOOL       *pfKeyGenFailed);

HRESULT
csiGenerateKeysOnly(
    IN  WCHAR const *pwszContainer,
    IN  WCHAR const *pwszProvName,
    IN  DWORD 	     dwProvType,
    IN  BOOL  	     fMachineKeyset,
    IN  DWORD 	     dwKeyLength,
    IN  BOOL  	     fUnattended,
    OUT HCRYPTPROV  *phProv,
    OUT int         *piMsg);

HRESULT
csiSetKeyContainerSecurity(
    IN HCRYPTPROV hProv);

HRESULT
csiSetAdminOnlyFolderSecurity(
    IN LPCWSTR    szFolderPath,
    IN BOOL       fAllowEveryoneRead,
    IN BOOL       fUseDS);

VOID
csiLogOpen(
    IN char const *pszFile);

VOID
csiLogClose();

VOID
csiLog(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN HRESULT hrMsg,
    IN UINT idMsg,
    OPTIONAL IN WCHAR const *pwsz1,
    OPTIONAL IN WCHAR const *pwsz2,
    OPTIONAL IN DWORD const *pdw);

VOID
csiLogTime(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg);

VOID
csiLogDWord(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg,
    IN DWORD dwVal);

HRESULT
csiGetProviderTypeFromProviderName(
    IN WCHAR const *pwszName,
    OUT DWORD      *pdwType);

HRESULT
csiUpgradeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    BOOL            fUseEnterpriseACL, // which ACL to use
    BOOL            fSetDsSecurity,    // whether to set security on DS object
    CS_ENUM_UPGRADE UpgradeType);

HRESULT
csiGetCRLPublicationParams(
    BOOL fBase,
    WCHAR** ppwszCRLPeriod,
    DWORD* pdwCRLCount);

HRESULT AddCNAndEncode(
    LPCWSTR pcwszName,
    LPCWSTR pcwszDNSuffix,
    BYTE** ppbEncodedDN,
    DWORD *pcbEncodedDN);


HRESULT
AddCAMachineToCertPublishers(VOID);
                   
HRESULT 
RemoveCAMachineFromCertPublishers(VOID);


#define CSILOG(hr, idMsg, pwsz1, pwsz2, pdw) \
    csiLog(__dwFILE__, __LINE__, (hr), (idMsg), (pwsz1), (pwsz2), (pdw))

#define CSILOGTIME(idMsg) \
    csiLogTime(__dwFILE__, __LINE__, (idMsg))

#define CSILOGDWORD(idMsg, dw) \
    csiLogDWord(__dwFILE__, __LINE__, (idMsg), (dw))

#endif //__INITCERT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\setupids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       setupids.h
//
//--------------------------------------------------------------------------

#ifndef __SETUPIDS_H__
#define __SETUPIDS_H__

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by initlib.lib, shared by certocm.dll, certmmc.dll and certutil.exe
// Shared range: 200-299

#define IDS_CAHIER_CERTFILE_FILTER			211
#define IDS_CAHIER_INSTALL_TITLE			212
#define IDS_ILOG_MISSING_PROVIDER          		213
#define IDS_ERR_INCOMPLETECHAIN				214
#define IDS_ERR_INVALIDCHAIN				215
#define IDS_ERR_RETRIEVE_PENDING			216
#define IDS_ILOG_GETCANAME				217
#define IDS_ILOG_SELECTCA				218

#define IDS_ILOG_SAVECERTANDKEYS			230
#define IDS_ILOG_RETRIEVECERT				231
#define IDS_ILOG_FINISHSUSPENDEDSETUP			232
#define IDS_ERR_NOTCACERT		             	233
#define IDS_ILOG_SETUPCOMPLETE				234
#define IDS_ILOG_RETRIEVEPENDING			235
#define IDS_ILOG_KEYINDEX				236
#define IDS_ILOG_LOADOLDCERT				237
#define IDS_ILOG_CLONECERT				238
#define IDS_ILOG_BUILDREQUEST				239
#define IDS_ILOG_RENEWOLDKEY				240
#define IDS_ILOG_INSTALLCERT				241
#define IDS_ILOG_RENEWNEWKEY				242
#define IDS_ILOG_BUILDCERT				243
#define IDS_ILOG_SAVECHAINANDKEYS			244
#define IDS_REQUEST_HELPTEXT				245
#define IDS_ILOG_CREATECDP				246
#define IDS_ILOG_CREATENTAUTHTRUST			247
#define IDS_ILOG_CREATEROOTTRUST			248
#define IDS_ILOG_PUBLISHCA				249
#define IDS_ILOG_SUBMITREQUEST				250
#define IDS_ERR_BADCSP                                  251
#define IDS_ERR_BAD_CA_CERT_7F                          252
#define IDS_ERR_RENEWEDCERTCAVERSION			253
#define IDS_ERR_UNTRUSTEDROOT				254
#define IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE	255
#define IDS_ERR_CERTCREATECERTIFICATECONTEXT            256
//#define IDS_UNUSED					257
#define IDS_ILOG_SETSECURITY				258
#define IDS_ERR_CREATEFILE                              259
#define IDS_ERR_DELETEKEY                               260
#define IDS_ERR_ENCODEKEYATTR                           261
#define IDS_ERR_ENCODETOBESIGNED                        262
#define IDS_ERR_ENV_NOT_SET                             263
#define IDS_ERR_FULL_TOKEN                              264
#define IDS_ERR_GENKEYFAIL                              265
#define IDS_ERR_GETCOMPUTERNAME                         266
#define IDS_ERR_KEYSECURITY                             267
#define IDS_ERR_MYDECODENAME                            268
#define IDS_ERR_NOT_ENTERPRISE_USER                     269
#define IDS_ERR_NOT_MATCH_NAME                          270
#define IDS_ILOG_GENERATEKEYS				271
#define IDS_ERR_REPEATWIZPREFIX                         272
#define IDS_ERR_REQUEST_DENIED                          273
#define IDS_ERR_REQUEST_ERROR                           274
#define IDS_ERR_REQUEST_INCOMPLETE                      275
#define IDS_ERR_REQUEST_OUTOFBAND                       276
#define IDS_ERR_REQUEST_PENDING                         277
#define IDS_ERR_REQUEST_REVOKED                         278
#define IDS_ERR_SETKEYPROVIDER                          279
#define IDS_ERR_SUBMIT_REQUEST                          280
#define IDS_ERR_SUBMIT_REQUEST_FAIL                     281
//#define IDS_UNUSED					282
//#define IDS_UNUSED					283
#define IDS_CAHIER_INSTALL_MISIINGCERT_TITLE		284
#define IDS_ERR_WRITEDERTOFILE                          285
#define IDS_ERR_WRITEFILE                               286
//#define IDS_UNUSED					287
#define IDS_ILOG_SETKEYSECURITY				288
#define IDS_MSG_PARENTCA_CONFIG                         289
#define IDS_MSG_REQUEST_ID                              290
#define IDS_MSG_TITLE                                   291
#define IDS_ILOG_SETADMINONLYFOLDERSECURITY             292
//#define IDS_UNUSED					293
//#define IDS_UNUSED					294
//#define IDS_UNUSED					295
//#define IDS_UNUSED					296
//#define IDS_UNUSED					297
//#define IDS_UNUSED					298
#define IDS_ERR_NO_KEY_ACCESS               		299
// **NOTE** hit high end of the limited range

#define IDC_STATIC					(-1)

// dialogs
#define IDD_COMPLETE_DIALOG				4000
#define IDC_PARENT_COMPUTER_NAME			4001
#define IDC_PARENT_CA_NAME				4002
#define IDC_BROWSE_CA					4003
#define IDC_REQUEST_HELPTEXT			4004

#define IDS_CA_PICKER_TITLE				4050
#define IDS_CA_PICKER_PROMPT				4051

#endif // __SETUPIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\sid.h ===
//+--------------------------------------------------------------------------
// File:        sid.h
// Contents:    class incapsulating a SID
//---------------------------------------------------------------------------
#ifndef __CERTSRV_CSID__
#define __CERTSRV_CSID__

#include <sddl.h>

namespace CertSrv 
{
class CSid
{
public:
    CSid() {Init();}
    CSid(PSID pSid)    {Init(); CopySid(pSid);}
    CSid(const CSid &copySid) {Init(); CopySid(copySid.m_pSid);}
    CSid(LPCWSTR pcwszSid) {Init(); CopySid(pcwszSid);}
    ~CSid()
    {
        if(m_pSid) 
            LocalFree(m_pSid);
        if(m_pwszSid) 
            LocalFree(m_pwszSid);
        if(m_pwszName) 
            LocalFree(m_pwszName);
    }
    operator LPCWSTR()
    {
        return GetStringSid();
    }
    operator PSID() {return m_pSid;}

    LPCWSTR GetName()
    {
        // attemp to map sid to name only once
        if(m_fCantResolveName ||
           S_OK!=MapSidToName())
        {   
            m_fCantResolveName = TRUE;
            return GetStringSid();
        }
        return m_pwszName;
    }

    PSID GetSid() { return m_pSid;}

protected:
    void Init() 
    {
        m_pSid = NULL; 
        m_pwszSid = NULL; 
        m_pwszName = NULL;
        m_fCantResolveName = FALSE;
    }
    void SetStringSid()
    {
        if(m_pSid)
            myConvertSidToStringSid(m_pSid, &m_pwszSid);
    }
    LPCWSTR GetStringSid()
    {
        if(!m_pwszSid)
            SetStringSid();
        return m_pwszSid?m_pwszSid:L"";
    }

    void CopySid(PSID pSid)
    {
        ULONG cbSid = GetLengthSid(pSid);
        m_pSid = (BYTE *) LocalAlloc(LMEM_FIXED, cbSid);
        if(m_pSid && !::CopySid(cbSid, m_pSid, pSid))
        {
            LocalFree(m_pSid);
            m_pSid = NULL;
        }
    }

    void CopySid(LPCWSTR pcwszSid)
    {
        if(pcwszSid)
            myConvertStringSidToSid(pcwszSid, &m_pSid);
    }

    HRESULT MapSidToName()
    {
        if(m_pwszName)
            return S_OK;
        WCHAR wszDummyBuffer[2];
        DWORD cchName = 0, cchDomain = 0;
        SID_NAME_USE use;
        LookupAccountSid(
            NULL,
            m_pSid,
            NULL,
            &cchName,
            NULL,
            &cchDomain,
            &use);
        if(ERROR_INSUFFICIENT_BUFFER!=GetLastError())
        {
            DWORD err = GetLastError();
            return HRESULT_FROM_WIN32(GetLastError());
        }
        // build the full name "Domain\Name"
        m_pwszName = (LPWSTR) LocalAlloc(
            LMEM_FIXED, 
            sizeof(WCHAR)*(cchName+cchDomain+2));
        if(!m_pwszName)
        {
            return E_OUTOFMEMORY;
        }
        // special case for Everyone, LookupAccountSid returns empty domain name for it
        if(!LookupAccountSid(
                NULL,
                m_pSid,
                m_pwszName+((1==cchDomain)?0:cchDomain), 
                &cchName,
                (1==cchDomain)?wszDummyBuffer:m_pwszName,
                &cchDomain,
                &use))
        {
            LocalFree(m_pwszName);
            m_pwszName = NULL;
            return HRESULT_FROM_WIN32(GetLastError());
        }
        if(cchDomain>1)
        {
            m_pwszName[cchDomain] = L'\\';
        }
        return S_OK;
    }

    CSid operator=(const CSid& sid); //protect callers from using it

    PSID m_pSid;
    LPWSTR  m_pwszSid;
    LPWSTR m_pwszName;
    BOOL m_fCantResolveName;
};

};//namespace CertSrv

#endif //__CERTSRV_CSID__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\resstr0.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\tfcprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfcprop.h
//
//--------------------------------------------------------------------------

#ifndef _TFCPROP_H_
#define _TFCPROP_H_

class PropertyPage
{
protected:
    PropertyPage() { ASSERT(0); }  // default, should never be called}
    PropertyPage(UINT uIDD);
    virtual ~PropertyPage();
    
public:
    // dlg notifications
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL UpdateData(BOOL fSuckFromDlg = TRUE);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
    virtual void OnDestroy();

    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual void OnOK();
    virtual BOOL OnWizardFinish();
    virtual LRESULT OnWizardNext();
    virtual LRESULT OnWizardBack();

    virtual void OnHelp(LPHELPINFO lpHelp);
    virtual void OnContextHelp(HWND hwnd);


public:
    HWND m_hWnd;
    PROPSHEETPAGE m_psp;

    HWND GetDlgItem(UINT uIDD) { return ::GetDlgItem(m_hWnd, uIDD); }
    HWND GetDlgItem(HWND hWnd, UINT uIDD) { return ::GetDlgItem(hWnd, uIDD); }

    LRESULT SendDlgItemMessage(
        int nIDDlgItem, 
        UINT uMsg,
        WPARAM wParam=0,  
        LPARAM lParam=0)
    {
        return ::SendDlgItemMessage(m_hWnd, nIDDlgItem, uMsg, wParam, lParam);
    }

    void SetModified(BOOL fModified = TRUE) 
    {   
        if (fModified)
            PropSheet_Changed( ::GetParent(m_hWnd), m_hWnd); 
        else
            PropSheet_UnChanged( ::GetParent(m_hWnd), m_hWnd); 
    }

    HWND GetParent() { return ::GetParent(m_hWnd); }

};


INT_PTR CALLBACK
    dlgProcPropPage(
      HWND hwndDlg,  
      UINT uMsg,     
      WPARAM wParam, 
      LPARAM lParam  );

#endif //_TFCPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\tfc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfc.h
//
//--------------------------------------------------------------------------

#ifndef _CSTRING_H_
#define _CSTRING_H_

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#define  AFX_MANAGE_STATE(__XX__) ((void)0)
#define AfxGetInstanceHandle() g_hInstance
#define AfxGetResourceHandle() g_hInstance

#define afx_msg
#define DECLARE_MESSAGE_MAP()
#define DECLARE_DYNCREATE(__XX__) 



#ifndef ASSERT

#ifdef _DEBUG
BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine); 
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && AssertFailedLine(__FILE__, __LINE__)) \
		DebugBreak(); \
	} while (0)
#else // _DEBUG
#define ASSERT(f)          ((void)0)
#endif // _DEBUG

#endif // ASSERT


#ifdef _DEBUG
#define VERIFY(f)          ASSERT(f)
#else   // _DEBUG
#define VERIFY(f)          ((void)(f))
#endif // !_DEBUG


extern const WCHAR* wszNull;

class CString
{
public:
    // empty constructor
    CString(); 
    // copy constructor
    CString(const CString& stringSrc);
	// from an ANSI string (converts to WCHAR)
	CString(LPCSTR lpsz);
	// from a UNICODE string (converts to WCHAR)
	CString(LPCWSTR lpsz);
    
    
    ~CString(); 

private:	
    // data members
    LPWSTR szData;
    DWORD  dwDataLen;
    
public:
    void Init();
    void Empty(); 
    BOOL IsEmpty() const; 
    LPWSTR GetBuffer(DWORD x=0);

    DWORD GetLength() const; 
    void ReleaseBuffer() {}


    // warning: insertion strings cannot exceed MAX_PATH chars
    void Format(LPCWSTR lpszFormat, ...);

    BSTR AllocSysString() const;

    // resource helpers    
    BOOL LoadString(UINT iRsc);
    BOOL FromWindow(HWND hWnd);
    BOOL ToWindow(HWND hWnd);

    void SetAt(int nIndex, WCHAR ch);

    // operators
    operator LPCWSTR ( ) const 
        { 
            if (szData) 
                return (LPCWSTR)szData; 
            else
                return (LPCWSTR)wszNull;
        }
    
    // test
    BOOL IsEqual(LPCWSTR sz); 

    // assignmt
    const CString& operator=(const CString& stringSrc) ;
   

    
    // W 
    const CString& operator=(LPCWSTR lpsz);
    const CString& operator=(LPWSTR lpsz);

    // A 
    const CString& operator=(LPCSTR lpsz);
    const CString& operator=(LPSTR lpsz);

    // concat
    const CString& operator+=(LPCWSTR lpsz);
    const CString& operator+=(const CString& string);
};


class CBitmap
{
private:
    HBITMAP m_hBmp;

public:
    CBitmap();
    ~CBitmap();
    
    HBITMAP LoadBitmap(UINT iRsc);

    // operators
    operator HBITMAP ( ) const { return m_hBmp; }
};


typedef struct _ELT_PTR
{
    _ELT_PTR* pNext;

    // other data
    void* pData;
} ELT_PTR, *PELT_PTR;


struct __POSITION { };
typedef __POSITION* POSITION;

template<class TYPE, class ARG_TYPE>
class CList
{
private:
    PELT_PTR m_pHead;

public:
    CList() {m_pHead = NULL;}
    ~CList() { Init();}
    
    void Init() 
    {
        RemoveAll();
        m_pHead = NULL;
    }
    
    TYPE  GetHead() { return (TYPE) m_pHead->pData; }
    TYPE  GetNext(POSITION& pos)
    { 
        POSITION poslast = pos;
        pos = (POSITION)((PELT_PTR)pos)->pNext; 
        return (TYPE) ( ((PELT_PTR)poslast)->pData); 
    }

    TYPE GetAt(POSITION pos) 
    { 
        return (TYPE)((PELT_PTR)pos)->pData;
    }


    POSITION GetHeadPosition() { return (POSITION)m_pHead; }
    POSITION GetTailPosition()
    {
        PELT_PTR p = m_pHead;
        PELT_PTR pPrev = NULL;
        while(p)
        {
            pPrev = p;
            p = p->pNext;
        }
        return (POSITION)pPrev;
    }
    POSITION AddHead(ARG_TYPE typeNewElt)
    {
        PELT_PTR p = (PELT_PTR)LocalAlloc(LMEM_FIXED, sizeof(ELT_PTR));
        if (p)
        {
            p->pData = (void*)typeNewElt;
            p->pNext = m_pHead;
            m_pHead = p;
        }
        return (POSITION)p;
    }

    POSITION AddTail(ARG_TYPE typeNewElt)
    {
        PELT_PTR ptail = (PELT_PTR)GetTailPosition();
        PELT_PTR p = (PELT_PTR)LocalAlloc(LMEM_FIXED, sizeof(ELT_PTR));
        if (p)
        {
            p->pData = (void*)typeNewElt; 
            p->pNext = NULL;
        }
        
        if (ptail)
        {
            ptail->pNext = p;
        }
        else
        {
            m_pHead = p;
        }

        return (POSITION)p;
    }

    void RemoveAt(POSITION pos)
    {
        PELT_PTR p = m_pHead;
        PELT_PTR pPrev = NULL;
        while (p && (p != (PELT_PTR)pos))
        {
            pPrev = p;                  // keep tabs on prev elt
            p = p->pNext;               // inc cur elt
        }

        if (p) // found
        {
            if (pPrev)
            {
                pPrev->pNext = p->pNext;    // pull out of list
            }
            else
            {
                m_pHead = p->pNext;         // pull out of head of list
            }

            LocalFree(p);               // free it
        }
    }

    void RemoveAll()
    {
        PELT_PTR p;
        while (m_pHead)
        {
            p = m_pHead;
            m_pHead = m_pHead->pNext;
            LocalFree(p);
        }
        ASSERT(m_pHead == NULL);
    }

};

template<class TYPE, class ARG_TYPE>
class CArray
{
private:
    TYPE* rgtypeArray;
    int iArraySize;

public:
    CArray() {iArraySize = 0; rgtypeArray=NULL;}
    ~CArray() { Init(); }

    void Init() 
    {
        if (rgtypeArray) 
        { 
            LocalFree(rgtypeArray); 
            rgtypeArray = NULL; 
            iArraySize = 0; 
        } 
    }

    // operators
    TYPE operator [](int i) { return GetAt(i); }


    int GetSize() { return iArraySize; }
    int GetUpperBound() { return iArraySize -1; }
    TYPE GetAt(int i) 
    { 
        ASSERT (i < iArraySize);
        return rgtypeArray[i];
    }

    int Add(ARG_TYPE arg)
    {
        TYPE* p;
        if (rgtypeArray)
            p = (TYPE*)LocalReAlloc(rgtypeArray, (iArraySize+1) * sizeof(TYPE), LMEM_MOVEABLE);
        else
            p = (TYPE*)LocalAlloc(LMEM_FIXED, sizeof(TYPE));
        if (p == NULL)
            return -1;

        rgtypeArray = p;
        rgtypeArray[iArraySize] = arg;
        iArraySize++;
        
        return iArraySize-1;
    }

    void RemoveAt(int idx, int nCount = 1)
    {
        // make sure idx is in our range AND
        // we're not asked to remove elts past end of our array
        ASSERT(GetUpperBound() >= idx);

        // IF idx is within bounds
        if (GetUpperBound() >= idx)
        {
            // truncate if we hit the end
            if (GetSize() < (idx + nCount))
                nCount = GetSize() - idx;

            MoveMemory(&rgtypeArray[idx], &rgtypeArray[idx+nCount], ((GetSize() - idx) - nCount)*sizeof(TYPE));
            iArraySize -= nCount;        
        }
    }

    const TYPE* GetData() { return rgtypeArray; }
};


class CComboBox
{
private:
    HWND m_hWnd;

public:
    CComboBox() { m_hWnd = NULL; }
    ~CComboBox() {}

    void Init(HWND hWnd); 

    void ResetContent()    ; 
    int SetItemData(int idx, DWORD dwData) ; 
    DWORD GetItemData(int idx)  ; 
    int AddString(LPWSTR sz)    ; 
    int AddString(LPCWSTR sz)   ; 
    int GetCurSel()             ; 
    int SetCurSel(int iSel)     ; 
    int SelectString(int nAfter, LPCWSTR szItem) ; 
};


class CFont
{
private:
    HFONT m_hFont;

public:
    CFont() {m_hFont = NULL;}
    ~CFont() {if (m_hFont)  DeleteObject(m_hFont);}

    operator HFONT () const { ASSERT(m_hFont); return m_hFont; }

    BOOL CreateFontIndirect(const LOGFONT* pFont) 
    { 
        if (m_hFont) 
            DeleteObject(m_hFont); 
        m_hFont = ::CreateFontIndirect(pFont); 
        return (m_hFont!=NULL); 
    }
};

class CWaitCursor
{
private:
    HCURSOR hPrevCur;
public:
    CWaitCursor() { hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));};
    ~CWaitCursor() { SetCursor(hPrevCur); };
};


// ListView helpers
int     ListView_NewItem(HWND hList, int iIndex, LPCWSTR szText, LPARAM lParam = NULL, int iImage=-1);
int     ListView_NewColumn(HWND hwndListView, int iCol, int cx, LPCWSTR szHeading=NULL, int fmt=0 /*LVCFMT_LEFT*/);
LPARAM  ListView_GetItemData(HWND hListView, int iItem);
int     ListView_GetCurSel(HWND hwndList);
void
ListView_SetItemFiletime(
    IN HWND hwndList,
    IN int  iItem,
    IN int  iColumn,
    IN FILETIME const *pft);

#define AfxMessageBox(__XX__)  MessageBox(NULL, __XX__, _TEXT("Debug Message"), MB_OK)

//
// Iterates through a 0 based safe array
//
template <class CElemType>
class SafeArrayEnum
{
public:
    SafeArrayEnum(SAFEARRAY* psa) :
        m_psa(psa),
        m_nIndex(0) {}

    void Reset() {m_nIndex = 0;}
    HRESULT Next(CElemType& elem)
    {
        HRESULT hr = S_OK;
        hr = SafeArrayGetElement(
            m_psa,
            &m_nIndex,
            &elem);
        if(S_OK==hr)
            m_nIndex++;
        return hr;
    }
    
    HRESULT GetAt(LONG nIndex, CElemType& elem)
    {
        return SafeArrayGetElement(
            m_psa,
            &nIndex,
            &elem);
    }

    LONG GetCount()
    {
        LONG lCount = -1;
        SafeArrayGetUBound(
            m_psa,
            1,
            &lCount);
        return lCount;
    }

    // test if one dimension and zero based
    bool IsValid()
    {
        if(1!=SafeArrayGetDim(m_psa))
            return false;

        LONG lCount = -1;
        SafeArrayGetLBound(
            m_psa,
            1,
            &lCount);
        return 0==lCount;
    }

protected:
    
    SAFEARRAY* m_psa;
    LONG m_nIndex;
};


#endif // #ifndef _CSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\tmpllist.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999 - 2000
//
// File:        tmpllist.h
//
// Contents:    certificate template list class
//
//---------------------------------------------------------------------------
#ifndef __TMPLLIST_H__
#define __TMPLLIST_H__

#include <tptrlist.h>

namespace CertSrv
{
class CTemplateInfo
{
public:

    CTemplateInfo() : 
        m_pwszTemplateName(NULL),
        m_pwszTemplateOID(NULL),
        m_hCertType(NULL){};
    ~CTemplateInfo()
    {
        if(m_pwszTemplateName)
            LocalFree(m_pwszTemplateName);
        if(m_pwszTemplateOID)
            LocalFree(m_pwszTemplateOID);
        // no free needed for m_hCertType
    };

    HRESULT SetInfo(
        LPCWSTR pcwszTemplateName,
        LPCWSTR pcwszTemplateOID);

    HRESULT SetInfo(HCERTTYPE hCertType) 
    { m_hCertType = hCertType; return S_OK;}

    LPCWSTR GetName();
    LPCWSTR GetOID();

    HCERTTYPE GetCertType() { return m_hCertType; }

    DWORD GetMarshalBufferSize()
    {
        return sizeof(WCHAR)*
            (2 + // trailing separators
             (GetName()?wcslen(GetName()):0) +
             (GetOID() ?wcslen(GetOID()) :0));
    }

    void FillInfoFromProperty(LPWSTR& pwszProp, LPCWSTR pcwszPropName);

    bool operator==(CTemplateInfo& rh);

protected:
    LPWSTR m_pwszTemplateName;
    LPWSTR m_pwszTemplateOID;
    HCERTTYPE m_hCertType;
}; // class CTemplateInfo

typedef LPCWSTR (CTemplateInfo::* GetIdentifierFunc) ();

class CTemplateList : public TPtrList<CTemplateInfo>
{
public:

    static const WCHAR m_gcchSeparator = L'\n';

    HRESULT Marshal(BYTE*& rpBuffer, DWORD& rcBuffer) const;
    HRESULT Unmarshal(const BYTE *pBuffer, DWORD cBuffer);
    HRESULT ValidateMarshalBuffer(const BYTE *pBuffer, DWORD cBuffer) const;
    HRESULT AddTemplateInfo(
        LPCWSTR pcwszTemplateName,
        LPCWSTR pcwszTemplateOID);

    HRESULT AddTemplateInfo(HCERTTYPE hCertType);
    HRESULT RemoveTemplateInfo(HCERTTYPE hCertType);

    bool TemplateExistsOID(LPCWSTR pcwszOID) const
    {
        return TemplateExists(pcwszOID, &CTemplateInfo::GetOID);
    }
    bool TemplateExistsName(LPCWSTR pcwszName) const
    {
        return TemplateExists(pcwszName, &CTemplateInfo::GetName);
    }

protected:
    DWORD GetMarshalBufferSize() const;

    bool TemplateExists(LPCWSTR pcwszOIDorName, GetIdentifierFunc func) const
    {
        TPtrListEnum<CTemplateInfo> listenum(*this);
        CTemplateInfo *pInfo;

        for(pInfo=listenum.Next();
            pInfo;
            pInfo=listenum.Next())
        {
            if(0 == _wcsicmp((pInfo->*func)(), pcwszOIDorName))
                return true;
        }
        return false;
    }

}; // class CTemplateList

typedef TPtrListEnum<CTemplateInfo> CTemplateListEnum;
} // namespace CertSrv

#endif //__TMPLLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\initlib\certhier.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhier.h
//
//--------------------------------------------------------------------------

HRESULT
CreateRevocationExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    IN DWORD dwRevocationFlags,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

HRESULT
CreateAuthorityInformationAccessExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

HRESULT
EncodeCertAndSign(
    IN HCRYPTPROV hProv,
    IN CERT_INFO *pCert,
    IN char const *pszAlgId,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);

BOOL
CreateKeyUsageExtension(
    IN BYTE bIntendedKeyUsage,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\include\tptrlist.h ===
namespace CertSrv
{
template <class C> class TPtrListEnum;

template <class C> class TPtrList
{
public:
    TPtrList() : m_pHead(NULL), m_dwCount(0) {}
    ~TPtrList(){ Cleanup(); }
    bool AddHead(C* pData);
    bool AddTail(C* pData);
    void Cleanup();
    DWORD GetCount() const { return m_dwCount;}
    bool IsEmpty() const {return NULL==m_pHead;}
    bool InsertAt(C* pData, DWORD dwIndex);
    bool RemoveAt(DWORD dwIndex);
    C* GetAt(DWORD dwIndex);
    C* Find(C& Data);
    DWORD FindIndex(C& Data);

    friend class TPtrListEnum<C>;

protected:
    struct TPtrListNode
    {
        TPtrListNode(C* pData) :
        m_pData(pData), m_pNext(NULL) {}
        ~TPtrListNode() { delete m_pData;}
        C* m_pData;
        TPtrListNode* m_pNext;
    };
    typedef TPtrListNode* TNODEPTR;
    typedef TPtrListNode  TNODE;

    TNODEPTR m_pHead;
    DWORD m_dwCount;
};

template <class C> class TPtrListEnum
{
public:
    TPtrListEnum(const TPtrList<C>& List) { Set(List);}
    void Set(const TPtrList<C>& List) { m_pList = &List; Reset(); }
    void Reset() { m_pCrt = m_pList->m_pHead; }
    C*   Next();

protected:
    const TPtrList<C> *m_pList;
    TPtrList<C>::TNODEPTR m_pCrt;
};

template <class C> C* TPtrListEnum<C>::Next()
{
    if(!m_pCrt)
        return NULL;
    C* pResult = m_pCrt->m_pData;
    m_pCrt = m_pCrt->m_pNext;
    return pResult;
}

template <class C> void TPtrList<C>::Cleanup()
{
    TNODEPTR pCrt, pNext;
    for(pCrt = m_pHead; pCrt; pCrt=pNext)
    {
        pNext = pCrt->m_pNext;
        delete pCrt;
    }
    m_pHead = NULL;
    m_dwCount = 0;
}

template <class C> bool TPtrList<C>::AddHead(C* pData)
{
    TNODEPTR pNew = new TNODE(pData);
    if(!pNew)
        return false;
    pNew->m_pNext = m_pHead;
    m_pHead = pNew;
    m_dwCount++;
    return true;
}


template <class C> bool TPtrList<C>::AddTail(C* pData)
{
    TNODEPTR pNew =  new TNODE(pData);
    if(!pNew)
        return false;
    for(TNODEPTR *ppCrt = &m_pHead; *ppCrt; ppCrt = &(*ppCrt)->m_pNext)
        NULL;
    *ppCrt = pNew;
    m_dwCount++;
    return true;
}

template <class C> C* TPtrList<C>::Find(C& Data)
{
    TPtrListEnum<C> ListEnum(*this);
    for(C* pResult = ListEnum.Next(); pResult; pResult= ListEnum.Next())
    {
        if(*pResult == Data)
            return pResult;
    }
    return NULL;
}

#define DWORD_MAX 0xffffffff
template <class C> DWORD TPtrList<C>::FindIndex(C& Data)
{
    DWORD dwIndex = 0;
    TPtrListEnum<C> ListEnum(*this);
    for(C* pResult = ListEnum.Next();
        pResult;
        pResult= ListEnum.Next(), dwIndex++)
    {
        if(*pResult == Data)
            return dwIndex;
    }
    return DWORD_MAX;
}

template <class C> bool TPtrList<C>::InsertAt(C* pData, DWORD dwIndex)
{
    DWORD dwCrt;
    TNODEPTR *ppCrt;
    TNODEPTR pNew =  new TNODE(pData);
    if(!pNew)
        return false;
    for(ppCrt = &m_pHead, dwCrt=0;
        NULL!=*ppCrt && (dwCrt<dwIndex);
        ppCrt = &(*ppCrt)->m_pNext, dwCrt++)
        NULL;
    pNew->m_pNext = *ppCrt;
    *ppCrt = pNew;
    m_dwCount++;
    return true;
}
template <class C> bool TPtrList<C>::RemoveAt(DWORD dwIndex)
{
    DWORD dwCrt;
    TNODEPTR *ppCrt, pDel;
    for(ppCrt = &m_pHead, dwCrt=0;
        NULL!=*ppCrt && (dwCrt<dwIndex);
        ppCrt = &(*ppCrt)->m_pNext, dwCrt++)
        NULL;
    if(!*ppCrt)
        return false;
    pDel = *ppCrt;
    *ppCrt = (*ppCrt)->m_pNext;
    delete pDel;
    m_dwCount--;
    return true;
}

template <class C> C* TPtrList<C>::GetAt(DWORD dwIndex)
{
    DWORD dwCrt;
    TNODEPTR pCrt;
    for(pCrt = m_pHead, dwCrt=0;
        NULL!=pCrt && (dwCrt<dwIndex);
        pCrt = pCrt->m_pNext, dwCrt++)
        NULL;
    return pCrt?pCrt->m_pData:NULL;
}

} // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\initlib\certhier.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhier.cpp
//
//  Contents:   Install cert server hierarchical
//
//  History:    09-26-96
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

// C Run-Time Includes
#include <stdlib.h>
#include <string.h>
#include <memory.h>


// Windows System Includes
#include <winsvc.h>
#include <rpc.h>
#include <tchar.h>
#include <csdisp.h>
#include <certca.h>

// Application Includes
#include "cscsp.h"
#include "certmsg.h"
#include "certhier.h"
#include "setupids.h"

#include "tfc.h"

#define __dwFILE__	__dwFILE_INITLIB_CERTHIER_CPP__

// following veriables are extern in initlib, bad.
LPSTR pszObjIdSignatureAlgorithm = szOID_OIWSEC_sha1RSASign;


HRESULT
csiFillKeyProvInfo(
    IN WCHAR const          *pwszContainerName,
    IN WCHAR const          *pwszProvName,
    IN DWORD		     dwProvType,
    IN BOOL		     fMachineKeyset,
    OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo) // call csiFreeKeyProvInfo to free
{
    HRESULT hr;
    WCHAR *pwszContainerNameT = NULL;
    WCHAR *pwszProvNameT = NULL;

    ZeroMemory(pKeyProvInfo, sizeof(*pKeyProvInfo));

    hr = myDupString(pwszContainerName, &pwszContainerNameT);
    _JumpIfError(hr, error, "myDupString");

    hr = myDupString(pwszProvName, &pwszProvNameT);
    _JumpIfError(hr, error, "myDupString");

    pKeyProvInfo->pwszContainerName = pwszContainerNameT;
    pKeyProvInfo->pwszProvName = pwszProvNameT;
    pKeyProvInfo->dwProvType = dwProvType;
    if (fMachineKeyset)
    {
       pKeyProvInfo->dwFlags = CRYPT_MACHINE_KEYSET;
    }
    pKeyProvInfo->dwKeySpec = AT_SIGNATURE;
    pwszContainerNameT = NULL;
    pwszProvNameT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszContainerNameT)
    {
	LocalFree(pwszContainerNameT);
    }
    if (NULL != pwszProvNameT)
    {
	LocalFree(pwszProvNameT);
    }
    return(hr);
}


VOID
csiFreeKeyProvInfo(
    IN OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo)
{
    if (NULL != pKeyProvInfo->pwszProvName)
    {
	LocalFree(pKeyProvInfo->pwszProvName);
	pKeyProvInfo->pwszProvName = NULL;
    }
    if (NULL != pKeyProvInfo->pwszContainerName)
    {
	LocalFree(pKeyProvInfo->pwszContainerName);
	pKeyProvInfo->pwszContainerName = NULL;
    }
}


HRESULT
GetCertServerKeyProviderInfo(
    IN WCHAR const          *pwszSanitizedCAName,
    IN WCHAR const          *pwszKeyContainerName,
    OUT ALG_ID		    *pidAlg,
    OUT BOOL		    *pfMachineKeyset,
    OUT CRYPT_KEY_PROV_INFO *pKeyProvInfo) // call csiFreeKeyProvInfo to free
{
    HRESULT hr;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;

    ZeroMemory(pKeyProvInfo, sizeof(*pKeyProvInfo));

    // get CSP info

    hr = myGetCertSrvCSP(
		    FALSE,		// fEncryptionCSP
		    pwszSanitizedCAName,
		    &dwProvType,
		    &pwszProvName,
		    pidAlg,
		    pfMachineKeyset,
		    NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    hr = csiFillKeyProvInfo(
		    pwszKeyContainerName,
		    pwszProvName,
		    dwProvType,
		    *pfMachineKeyset,
		    pKeyProvInfo);
    _JumpIfError(hr, error, "csiFillKeyProvInfo");

error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
mySetCertRegKeyIndexAndContainer(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD iKey,
    IN WCHAR const *pwszKeyContainer)
{
    HRESULT hr;
    
    hr = mySetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGREQUESTKEYINDEX,
			iKey);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValue", wszREGREQUESTKEYINDEX);

    hr = mySetCertRegStrValue(
			 pwszSanitizedCAName,
			 NULL,
			 NULL,
			 wszREGREQUESTKEYCONTAINER,
			 pwszKeyContainer);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGREQUESTKEYCONTAINER);

error:
    return(hr);
}


HRESULT
myGetCertRegKeyIndexAndContainer(
    IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *piKey,
    OUT WCHAR **ppwszKeyContainer)
{
    HRESULT hr;
    
    *ppwszKeyContainer = NULL;

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGREQUESTKEYINDEX,
			piKey);
    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
	{
	    _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGREQUESTKEYINDEX);
	}
	*piKey = 0;
    }

    hr = myGetCertRegStrValue(
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszREGREQUESTKEYCONTAINER,
		    ppwszKeyContainer);
    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
	{
	    _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGREQUESTKEYCONTAINER);
	}
	hr = myDupString(pwszSanitizedCAName, ppwszKeyContainer);
	_JumpIfError(hr, error, "myDupString");
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


HRESULT
FinishSuspendedSetupFromPKCS7(
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND         hwnd,
    IN WCHAR const *pwszSanitizedCAName,
    IN OPTIONAL WCHAR const *pwszKeyContainer,
    IN DWORD        iKey,
    IN BOOL         fRenew,
    IN BYTE const  *pbChain,
    IN DWORD        cbChain)
{
    HRESULT  hr;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszServerName = NULL;
    WCHAR *pwszCertFile = NULL;
    WCHAR *pwszKeyContainerReg = NULL;
    ENUM_CATYPES CAType;
    DWORD iCertNew;
    BOOL fUseDS;
    ALG_ID idAlg;
    BOOL fMachineKeyset;

    ZeroMemory(&KeyProvInfo, sizeof(KeyProvInfo));

    hr = myGetCARegHashCount(pwszSanitizedCAName, CSRH_CASIGCERT, &iCertNew);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    if (NULL == pwszKeyContainer)
    {
	// get Key Index and Container name from registry

	hr = myGetCertRegKeyIndexAndContainer(
			    pwszSanitizedCAName,
			    &iKey,
			    &pwszKeyContainerReg);
	_JumpIfError(hr, error, "myGetCertRegKeyIndexAndContainer");

	pwszKeyContainer = pwszKeyContainerReg;
    }

    // get CSP info
    hr = GetCertServerKeyProviderInfo(
			    pwszSanitizedCAName,
			    pwszKeyContainer,
			    &idAlg,
			    &fMachineKeyset,
			    &KeyProvInfo);
    _JumpIfError(hr, error, "GetCertServerKeyProviderInfo");

    // get common name
    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCOMMONNAME,
			&pwszCommonName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCOMMONNAME);

    // get ca type

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCATYPE,
			(DWORD *) &CAType);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCATYPE);

    // use DS or not

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCAUSEDS,
			(DWORD *) &fUseDS);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCAUSEDS);

    // server name

    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCASERVERNAME,
			&pwszServerName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCASERVERNAME);

    hr = myGetCARegFileNameTemplate(
			wszREGCACERTFILENAME,
			pwszServerName,
			pwszSanitizedCAName,
			iCertNew,
			iKey,
			&pwszCertFile);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfError(hr, error, "myGetCARegFileNameTemplate");
    }

    hr = csiFinishInstallationFromPKCS7(
			    hInstance,
			    fUnattended,
			    hwnd,
			    pwszSanitizedCAName,
			    pwszCommonName,
			    &KeyProvInfo,
			    CAType,
			    iCertNew,
			    iKey,
			    fUseDS,
			    fRenew,
			    pwszServerName,
			    pbChain,
			    cbChain,
			    pwszCertFile);
    _JumpIfError(hr, error, "csiFinishInstallationFromPKCS7");

error:
    if (NULL != pwszKeyContainerReg)
    {
        LocalFree(pwszKeyContainerReg);
    }
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    if (NULL != pwszCertFile)
    {
        LocalFree(pwszCertFile);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    csiFreeKeyProvInfo(&KeyProvInfo);
    CSILOG(hr, IDS_ILOG_FINISHSUSPENDEDSETUP, NULL, NULL, NULL);
    return(hr);
}


typedef struct _CERTHIERINFO
{
    HINSTANCE   hInstance;
    BOOL        fUnattended;
    WCHAR      *pwszSanitizedCAName;
    WCHAR      *pwszParentMachine;
    WCHAR      *pwszParentCA;
    WCHAR      *pwszParentMachineDefault;
    WCHAR      *pwszParentCADefault;
    DWORD       iCertNew;
    DWORD       iKey;
} CERTHIERINFO;


VOID
FreeCertHierInfo(
    IN OUT CERTHIERINFO *pCertHierInfo)
{
    if (NULL != pCertHierInfo->pwszSanitizedCAName)
    {
        LocalFree(pCertHierInfo->pwszSanitizedCAName);
    }
    if (NULL != pCertHierInfo->pwszParentMachine)
    {
        LocalFree(pCertHierInfo->pwszParentMachine);
    }
    if (NULL != pCertHierInfo->pwszParentCA)
    {
        LocalFree(pCertHierInfo->pwszParentCA);
    }
    if (NULL != pCertHierInfo->pwszParentMachineDefault)
    {
        LocalFree(pCertHierInfo->pwszParentMachineDefault);
    }
    if (NULL != pCertHierInfo->pwszParentCADefault)
    {
        LocalFree(pCertHierInfo->pwszParentCADefault);
    }
}


CERTSRVUICASELECTION g_CertHierCARequestUICASelection =
                         {NULL, NULL, NULL, NULL, NULL, ENUM_UNKNOWN_CA, false};

HRESULT
csiGetCARequestFileName(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD        iCertNew,
    IN DWORD        iKey,
    OUT WCHAR     **ppwszRequestFile)
{
    HRESULT  hr;
    WCHAR   *pwszServerName = NULL;
    WCHAR   *pwszRequestFile = NULL;
    WCHAR   *pwszSharedFolder = NULL;

    // init
    *ppwszRequestFile = NULL;

    // get server name
    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGCASERVERNAME,
			&pwszServerName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCASERVERNAME);

    hr = myGetCARegFileNameTemplate(
                        wszREGREQUESTFILENAME,
                        pwszServerName,
                        pwszSanitizedCAName,
                        iCertNew,
                        iKey,
                        &pwszRequestFile);
    if (S_OK != hr)
    {
        hr = myGetCertRegStrValue(
                        NULL,
                        NULL,
                        NULL,
                        wszREGDIRECTORY,
                        &pwszSharedFolder);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszSharedFolder);
        }

        hr = csiBuildCACertFileName(
				    hInstance,
				    hwnd,
				    TRUE, 		// fUnattended
				    pwszSharedFolder,
				    pwszSanitizedCAName,
				    L".req",
				    0,			// iCertNew == 0!
				    &pwszRequestFile);
        _JumpIfError(hr, error, "csiBuildCACertFileName");

        hr = mySetCARegFileNameTemplate(
				wszREGREQUESTFILENAME,
				pwszServerName,
				pwszSanitizedCAName,
				pwszRequestFile);
        _JumpIfError(hr, error, "mySetCARegFileNameTemplate");

        LocalFree(pwszRequestFile);
        pwszRequestFile = NULL;

        hr = csiBuildCACertFileName(
				    hInstance,
				    hwnd,
				    TRUE, 		// fUnattended
				    pwszSharedFolder,
				    pwszSanitizedCAName,
				    L".req",
				    iCertNew,
				    &pwszRequestFile);
        _JumpIfError(hr, error, "csiBuildCACertFileName");
    }

    *ppwszRequestFile = pwszRequestFile;
    pwszRequestFile = NULL;

    hr = S_OK;
error:
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    if (NULL != pwszSharedFolder)
    {
        LocalFree(pwszSharedFolder);
    }
    return hr;
}

HRESULT
InitCertHierControls(
    HWND          hDlg,
    CERTHIERINFO *pCertHierInfo)
{
    HRESULT hr;
    BOOL fCAsExist;
    WCHAR *pwszHelpText = NULL;
    WCHAR *pwszRequestFile = NULL;
    WCHAR *pwszExpandedHelpText = NULL;

    if (NULL != pCertHierInfo->pwszParentMachineDefault)
    {
        SetWindowText(
		GetDlgItem(hDlg, IDC_PARENT_COMPUTER_NAME),
		pCertHierInfo->pwszParentMachineDefault);

	if (NULL != pCertHierInfo->pwszParentCADefault)
	{
	    SetWindowText(
		    GetDlgItem(hDlg, IDC_PARENT_CA_NAME),
		    pCertHierInfo->pwszParentCADefault);
	}
    }

    // load formatted help string
    hr = myLoadRCString(
             pCertHierInfo->hInstance,
             IDS_REQUEST_HELPTEXT,
             &pwszHelpText);
    _JumpIfError(hr, error, "myLoadRCString");

    // get request file name
    hr = csiGetCARequestFileName(
                         pCertHierInfo->hInstance,
                         hDlg,
                         pCertHierInfo->pwszSanitizedCAName,
                         pCertHierInfo->iCertNew,
                         pCertHierInfo->iKey,
                         &pwszRequestFile);
    _JumpIfError(hr, error, "csiGetCARequestFileName");

    // replace %1
    if (!FormatMessage(
                 FORMAT_MESSAGE_ALLOCATE_BUFFER |
                 FORMAT_MESSAGE_FROM_STRING |
                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                 pwszHelpText,
                 0,
                 0,
                 reinterpret_cast<WCHAR *>(&pwszExpandedHelpText),
                 0,
                 reinterpret_cast<va_list *>
                     (const_cast<WCHAR **>(&pwszRequestFile))) )
    {
        hr = myHLastError();
        _JumpError(hr, error, "FormatMessage");
    }

    // set help text
    SetWindowText(GetDlgItem(hDlg, IDC_REQUEST_HELPTEXT), pwszExpandedHelpText);

    hr = myInitUICASelectionControls(
			    &g_CertHierCARequestUICASelection,
			    pCertHierInfo->hInstance,
			    hDlg,
			    GetDlgItem(hDlg, IDC_BROWSE_CA),
			    GetDlgItem(hDlg, IDC_PARENT_COMPUTER_NAME),
			    GetDlgItem(hDlg, IDC_PARENT_CA_NAME),
			    csiIsAnyDSCAAvailable(),
			    &fCAsExist);
    _JumpIfError(hr, error, "myInitUICASelectionControls");

error:
    if (NULL != pwszHelpText)
    {
        LocalFree(pwszHelpText);
    }
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszExpandedHelpText)
    {
        LocalFree(pwszExpandedHelpText);
    }
    return(hr);
}


HRESULT
HandleOKButton(
    HWND          hDlg,
    CERTHIERINFO *pCertHierInfo,
    BOOL         *pfLeave)
{
    HRESULT   hr;
    WCHAR    *pwszParentMachine = NULL;
    WCHAR    *pwszParentCA = NULL;

    hr = myUICASelectionValidation(&g_CertHierCARequestUICASelection, pfLeave);
    _JumpIfError(hr, error, "myUICASelectionValidation");
    if (!*pfLeave)
    {
        goto error;
    }
    
    // get parent ca info
    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_PARENT_COMPUTER_NAME),
                           &pwszParentMachine);
    _JumpIfError(hr, error, "myUIGetWindowText");

    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_PARENT_CA_NAME),
                           &pwszParentCA);
    _JumpIfError(hr, error, "myUIGetWindowText");

    pCertHierInfo->pwszParentMachine = pwszParentMachine;
    pwszParentMachine = NULL;
    pCertHierInfo->pwszParentCA = pwszParentCA;
    pwszParentCA = NULL;

    hr = S_OK;
error:
    if (NULL != pwszParentMachine)
    {
        LocalFree(pwszParentMachine);
    }
    if (NULL != pwszParentCA)
    {
        LocalFree(pwszParentCA);
    }
    return(hr);
}


INT_PTR CALLBACK
CertHierProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    HRESULT hr;
    BOOL  ret = FALSE;
    BOOL  fLeave;
    static CERTHIERINFO *s_pCertHierInfo = NULL;
    static BOOL s_fComputerChange = FALSE;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            s_pCertHierInfo = (CERTHIERINFO *) lParam;

            hr = InitCertHierControls(hDlg, s_pCertHierInfo);
            _JumpIfError(hr, error, "InitCertHierControls");

            ret = TRUE;
	    break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
	    {
                case IDC_BROWSE_CA:
                    ret = TRUE;
                    hr = myUICAHandleCABrowseButton(
                              &g_CertHierCARequestUICASelection,
                              csiIsAnyDSCAAvailable(),
                              IDS_CA_PICKER_TITLE,
                              IDS_CA_PICKER_PROMPT,
                              NULL);
                    _JumpIfError(hr, error, "myUICAHandleCABrowseButton");
		    break;

                case IDC_PARENT_CA_NAME:
                    hr = myUICAHandleCAListDropdown(
                                (int)HIWORD(wParam),
                                &g_CertHierCARequestUICASelection,
                                &s_fComputerChange);
                    _PrintIfError(hr, "myUICAHandleCAListDropdown");
                    break;

                case IDC_PARENT_COMPUTER_NAME:
                    switch ((int)HIWORD(wParam))
                    {
                        case EN_CHANGE: // edit change
                            s_fComputerChange = TRUE;
                        break;
                    }
                    break;

                case IDOK:
                    ret = TRUE;
                    hr = HandleOKButton(hDlg, s_pCertHierInfo, &fLeave);
                    _PrintIfError(hr, "HandleOKButton");
                    if (fLeave)
                    {
                        // update return status
                        ret = EndDialog(hDlg, IDOK);
                        goto error; //done;
                    }
		    break;

                case IDCANCEL:
                    ret = EndDialog(hDlg, IDCANCEL);
		    break;
            }
	    break;
    }

error:
    return(ret);
}


VOID
MarkSetupComplete(
    IN WCHAR const *pwszSanitizedCAName)
{
    HRESULT hr;
    
    // Clear pending/denied flags:

    hr = SetSetupStatus(
		pwszSanitizedCAName,
		SETUP_SUSPEND_FLAG |
		    SETUP_ONLINE_FLAG |
		    SETUP_REQUEST_FLAG |
		    SETUP_DENIED_FLAG,
		FALSE);
    _PrintIfError(hr, "SetSetupStatus");

    // Force new CRL generation on startup:
    
    hr = SetSetupStatus(pwszSanitizedCAName, SETUP_FORCECRL_FLAG, TRUE);
    _PrintIfError(hr, "SetSetupStatus");

    CSILOG(hr, IDS_ILOG_SETUPCOMPLETE, NULL, NULL, NULL);
}


HRESULT
FindKeyIndex(
    IN HCERTSTORE hMyStore,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fUnattended,
    IN BOOL fMachineKeyset,
    IN DWORD cCert,
    CRYPT_KEY_PROV_INFO *pKeyMatch,
    OUT DWORD *piKey)
{
    HRESULT hr;
    DWORD i;
    CERT_CONTEXT const *pccCert = NULL;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    HCRYPTPROV hProv = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKeyMatch = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cb;
    DWORD NameId;

    *piKey = MAXDWORD;

    // get CSP handle

    if (!myCertSrvCryptAcquireContext(
			    &hProv,
			    pKeyMatch->pwszContainerName,
			    pKeyMatch->pwszProvName,
			    pKeyMatch->dwProvType,
			    fUnattended? CRYPT_SILENT : 0,
			    fMachineKeyset))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }
    if (hProv == NULL)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKeyMatch,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }
    CryptReleaseContext(hProv, 0);
    hProv = NULL;

    for (i = 0; ; i++)
    {
	if (i >= cCert)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "old key not found");
	}
	hr = myFindCACertByHashIndex(
				hMyStore,
				pwszSanitizedCAName,
				CSRH_CASIGCERT,
				i,
				&NameId,
				&pccCert);
	if (S_FALSE == hr)
	{
	    continue;
	}
	_JumpIfError(hr, error, "myFindCACertByHashIndex");

	// get the key provider info

	if (!myCertGetCertificateContextProperty(
					pccCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &pKey,
					&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}

	// get CSP handle

	if (!myCertSrvCryptAcquireContext(
				&hProv,
				pKey->pwszContainerName,
				pKey->pwszProvName,
				pKey->dwProvType,
				fUnattended? CRYPT_SILENT : 0,
				fMachineKeyset))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myCertSrvCryptAcquireContext");
	}
	if (hProv == NULL)
	{
	    hr = E_HANDLE;
	    _JumpError(hr, error, "myCertSrvCryptAcquireContext");
	}

	if (!myCryptExportPublicKeyInfo(
				    hProv,
				    AT_SIGNATURE,
				    CERTLIB_USE_LOCALALLOC,
				    &pPubKey,
				    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myCryptExportPublicKeyInfo");
	}

	// by design, CertComparePublicKeyInfo doesn't set last error!

	if (CertComparePublicKeyInfo(X509_ASN_ENCODING, pPubKey, pPubKeyMatch))
	{
	    hr = myGetNameId(pccCert, &NameId);
	    if (S_OK != hr)
	    {
		*piKey = i;
	    }
	    else
	    {
		*piKey = CANAMEIDTOIKEY(NameId);
	    }
	    break;
	}

        LocalFree(pPubKey);
        pPubKey = NULL;

	CryptReleaseContext(hProv, 0);
	hProv = NULL;

        LocalFree(pKey);
	pKey = NULL;

	CertFreeCertificateContext(pccCert);
	pccCert = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pPubKeyMatch)
    {
        LocalFree(pPubKeyMatch);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pKey)
    {
        LocalFree(pKey);
    }
    if (NULL != pccCert)
    {
	CertFreeCertificateContext(pccCert);
    }
    CSILOG(hr, IDS_ILOG_KEYINDEX, NULL, NULL, piKey);
    return(hr);
}


HRESULT
LoadCurrentCACertAndKeyInfo(
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fNewKey,
    IN BOOL fUnattended,
    IN BOOL fMachineKeyset,
    IN DWORD iCertNew,
    OUT DWORD *piKey,
    OUT WCHAR **ppwszKeyContainer,
    OUT CERT_CONTEXT const **ppccCertOld)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD cbKey;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    WCHAR *pwszKeyContainer = NULL;
    DWORD NameId;

    *ppwszKeyContainer = NULL;
    *ppccCertOld = NULL;
    *piKey = MAXDWORD;

    // open MY store
    hMyStore = CertOpenStore(
		       CERT_STORE_PROV_SYSTEM_W,
		       X509_ASN_ENCODING,
		       NULL,			// hProv
		       CERT_SYSTEM_STORE_LOCAL_MACHINE |
               CERT_STORE_MAXIMUM_ALLOWED_FLAG,
		       wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedCAName,
			    CSRH_CASIGCERT,
			    iCertNew - 1,
			    &NameId,
			    ppccCertOld);
    _JumpIfError(hr, error, "myFindCACertByHashIndex");

    if (fNewKey)
    {
	*piKey = iCertNew;	// New key: iKey set to iCert

	hr = myAllocIndexedName(
			pwszSanitizedCAName,
			*piKey,
			&pwszKeyContainer);
	_JumpIfError(hr, error, "myAllocIndexedName");
    }
    else
    {
	// get the key provider info
	if (!myCertGetCertificateContextProperty(
					*ppccCertOld,
					CERT_KEY_PROV_INFO_PROP_ID,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &pKey,
					&cbKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}
	hr = myDupString(pKey->pwszContainerName, &pwszKeyContainer);
	_JumpIfError(hr, error, "myDupString");

	// Reuse key: iKey set to match oldest iCert using this key:

	hr = FindKeyIndex(
		    hMyStore,
		    pwszSanitizedCAName,
		    fUnattended,
		    fMachineKeyset,
		    iCertNew,
		    pKey,
		    piKey);
	_JumpIfError(hr, error, "FindKeyIndex");

	CSASSERT(MAXDWORD != *piKey);
    }
    *ppwszKeyContainer = pwszKeyContainer;
    pwszKeyContainer = NULL;
    CSASSERT(S_OK == hr);

error:
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pKey)
    {
        LocalFree(pKey);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    CSILOG(hr, IDS_ILOG_LOADOLDCERT, *ppwszKeyContainer, NULL, piKey);
    return(hr);
}


HRESULT
ReplaceExtension(
    IN CERT_EXTENSION const *pExtension,
    IN OUT DWORD *pcExtension,
    IN OUT CERT_EXTENSION *rgExtension)
{
    DWORD i;

    CSASSERT(NULL != pExtension->pszObjId);
    for (i = 0; ; i++)
    {
	if (i == *pcExtension)
	{
	    if (NULL != pExtension->Value.pbData)
	    {
		(*pcExtension)++;	// not found: append to array
	    }
	    break;
	}
	CSASSERT(i < *pcExtension);
	if (0 == strcmp(pExtension->pszObjId, rgExtension[i].pszObjId))
	{
	    if (NULL == pExtension->Value.pbData)
	    {
		// remove extension: copy last extension on top of this one
		// and decrement extension count

		(*pcExtension)--;
		pExtension = &rgExtension[*pcExtension];
	    }
	    break;
	}
    }
    rgExtension[i] = *pExtension;	// append or overwrite extension
    return(S_OK);
}


HRESULT
GetMinimumCertValidityPeriod(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD cCert,
    OUT LONGLONG *pTimeDelta)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD NameId;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fFirst = TRUE;
    DWORD i;

    // open MY store
    hMyStore = CertOpenStore(
		       CERT_STORE_PROV_SYSTEM_W,
		       X509_ASN_ENCODING,
		       NULL,			// hProv
		       CERT_SYSTEM_STORE_LOCAL_MACHINE |
               CERT_STORE_MAXIMUM_ALLOWED_FLAG, 
		       wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    for (i = 0; i < cCert; i++)
    {
	LONGLONG TimeDelta;

	hr = myFindCACertByHashIndex(
				hMyStore,
				pwszSanitizedCAName,
				CSRH_CASIGCERT,
				i,
				&NameId,
				&pcc);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myFindCACertByHashIndex");
	    continue;
	}

	TimeDelta = mySubtractFileTimes(
					&pcc->pCertInfo->NotAfter,
					&pcc->pCertInfo->NotBefore);

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "iCert=%u TimeDelta=%x:%x\n",
	    i,
	    (DWORD) (TimeDelta >> 32),
	    (DWORD) TimeDelta));

	if (fFirst || *pTimeDelta > TimeDelta)
	{
	    *pTimeDelta = TimeDelta;
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"iCert=%u *pTimeDelta=%x:%x\n",
		i,
		(DWORD) (*pTimeDelta >> 32),
		(DWORD) *pTimeDelta));
	    fFirst = FALSE;
	}

	CertFreeCertificateContext(pcc);
	pcc = NULL;
    }
    if (fFirst)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "no old Certs");
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
GetCertHashExtension(
    IN CERT_CONTEXT const *pCert,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    CRYPT_DATA_BLOB Blob;
    DWORD cbHash;

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
			pCert,
			CERT_HASH_PROP_ID,
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    Blob.cbData = cbHash;
    Blob.pbData = abHash;
    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_OCTET_STRING,
		&Blob,
		0,
		CERTLIB_USE_LOCALALLOC,
		ppbData,
		pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CloneRootCert(
    IN HINF hInf,
    IN CERT_CONTEXT const *pccCertOld,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN HCRYPTPROV hProv,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD iCert,
    IN DWORD iKey,
    IN BOOL fUseDS,
    IN BOOL fNewKey,
    IN DWORD dwRevocationFlags,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert)
{
    HRESULT hr;
    CERT_INFO Cert;
    GUID guidSerialNumber;
    LONGLONG TimeDelta;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    DWORD NameId;
    CERT_EXTENSION *paext = NULL;
    FILETIME ftNotAfterMin;
    DWORD dwValidityPeriodCount;
    ENUM_PERIOD enumValidityPeriod;
    CERT_EXTENSION *pext;

#define CEXT_REPLACED	9

    CERT_EXTENSION extBasicConstraints = 
                        { NULL,        			    FALSE, 0, NULL};
    CERT_EXTENSION extSKI = 
                        { szOID_SUBJECT_KEY_IDENTIFIER,     FALSE, 0, NULL };
    CERT_EXTENSION extCDP = 
                        { szOID_CRL_DIST_POINTS,            FALSE, 0, NULL };
    CERT_EXTENSION extVersion = 
                        { szOID_CERTSRV_CA_VERSION,         FALSE, 0, NULL };
    CERT_EXTENSION extPreviousHash = 
                        { szOID_CERTSRV_PREVIOUS_CERT_HASH, FALSE, 0, NULL };
    CERT_EXTENSION extPolicy = 
                        { szOID_CERT_POLICIES,		    FALSE, 0, NULL };
    CERT_EXTENSION extCross = 
                        { szOID_CROSS_CERT_DIST_POINTS,	    FALSE, 0, NULL };
    CERT_EXTENSION extAIA = 
                        { szOID_AUTHORITY_INFO_ACCESS,      FALSE, 0, NULL };
    CERT_EXTENSION extEKU =
			{ NULL,				    FALSE, 0, NULL};

    *ppbCert = NULL;

    CopyMemory(&Cert, pccCertOld->pCertInfo, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    myGenerateGuidSerialNumber(&guidSerialNumber);

    Cert.SerialNumber.pbData = (BYTE *) &guidSerialNumber;
    Cert.SerialNumber.cbData = sizeof(guidSerialNumber);
    if (!myAreBlobsSame(
		Cert.Issuer.pbData,
		Cert.Issuer.cbData,
		Cert.Subject.pbData,
		Cert.Subject.cbData))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "non-Root Cert");
    }

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    Cert.SubjectPublicKeyInfo = *pPubKey;	// Structure assignment

    // make new cert expire at least 1 minute after old cert.

    ftNotAfterMin = Cert.NotAfter;
    myMakeExprDateTime(&ftNotAfterMin, 1, ENUM_PERIOD_MINUTES);

    GetSystemTimeAsFileTime(&Cert.NotBefore);

    hr = myInfGetValidityPeriod(
			hInf,
			NULL,		// pwszValidityPeriodCount
			NULL,		// pwszValidityPeriodString
			&dwValidityPeriodCount,
			&enumValidityPeriod,
			NULL);		// pfSwap
    if (S_OK == hr)
    {
	Cert.NotAfter = Cert.NotBefore;
	myMakeExprDateTime(
		    &Cert.NotAfter,
		    dwValidityPeriodCount,
		    enumValidityPeriod);
	TimeDelta = 0;
    }
    else
    {
	hr = GetMinimumCertValidityPeriod(
				    pwszSanitizedCAName,
				    iCert,
				    &TimeDelta);
	_JumpIfError(hr, error, "GetMinimumCertValidityPeriod");

	CSASSERT(0 != TimeDelta);
    }
    myMakeExprDateTime(
		&Cert.NotBefore,
		-CCLOCKSKEWMINUTESDEFAULT,
		ENUM_PERIOD_MINUTES);
    if (0 != TimeDelta)
    {
	Cert.NotAfter = Cert.NotBefore;
	myAddToFileTime(&Cert.NotAfter, TimeDelta);
    }

    // make new cert expire at least 1 minute after old cert.

    if (0 > CompareFileTime(&Cert.NotAfter, &ftNotAfterMin))
    {
	Cert.NotAfter = ftNotAfterMin;
    }

    if (!fNewKey)
    {
	Cert.NotBefore = pccCertOld->pCertInfo->NotBefore;
    }

    paext = (CERT_EXTENSION *) LocalAlloc(
			LMEM_FIXED,
			(Cert.cExtension + CEXT_REPLACED) * sizeof(paext[0]));
    if (NULL == paext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(paext, Cert.rgExtension, Cert.cExtension * sizeof(paext[0]));
    Cert.rgExtension = paext;

    // Basic constraints extension:

    hr = myInfGetBasicConstraints2CAExtensionOrDefault(hInf, &extBasicConstraints);
    _JumpIfError(hr, error, "myInfGetBasicConstraints2CAExtensionOrDefault");

    ReplaceExtension(&extBasicConstraints, &Cert.cExtension, Cert.rgExtension);

    // Subject Key Identifier extension:
    // If we're reusing the old key, reuse the old SKI -- even if it's "wrong".

    pext = NULL;
    if (!fNewKey)
    {
	pext = CertFindExtension(
			    szOID_SUBJECT_KEY_IDENTIFIER,
			    Cert.cExtension,
			    Cert.rgExtension);
    }
    if (NULL == pext)
    {
	hr = myCreateSubjectKeyIdentifierExtension(
					pPubKey,
					&extSKI.Value.pbData,
					&extSKI.Value.cbData);
	_JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");

	ReplaceExtension(&extSKI, &Cert.cExtension, Cert.rgExtension);
    }

    hr = CreateRevocationExtension(
			    hInf,
			    pwszSanitizedCAName,
			    iCert,
			    iKey,
			    fUseDS,
			    dwRevocationFlags,
			    &extCDP.fCritical,
			    &extCDP.Value.pbData,
			    &extCDP.Value.cbData);
    _PrintIfError2(hr, "CreateRevocationExtension", S_FALSE);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extCDP, &Cert.cExtension, Cert.rgExtension);
    }

    // Build the CA Version extension

    NameId = MAKECANAMEID(iCert, iKey);

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_INTEGER,
		&NameId,
		0,
		CERTLIB_USE_LOCALALLOC,
		&extVersion.Value.pbData,
		&extVersion.Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    ReplaceExtension(&extVersion, &Cert.cExtension, Cert.rgExtension);


    // Build the previous CA cert hash extension

    hr = GetCertHashExtension(
			pccCertOld,
			&extPreviousHash.Value.pbData,
			&extPreviousHash.Value.cbData);
    _JumpIfError(hr, error, "GetCertHashExtension");

    ReplaceExtension(&extPreviousHash, &Cert.cExtension, Cert.rgExtension);


    // Build the Policy Statement extension

    hr = myInfGetPolicyStatementExtension(hInf, &extPolicy);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extPolicy, &Cert.cExtension, Cert.rgExtension);
    }


    // Build the Cross Cert Dist Points extension

    hr = myInfGetCrossCertDistributionPointsExtension(hInf, &extCross);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extCross, &Cert.cExtension, Cert.rgExtension);
    }


    // Build the Authority Information Access extension

    hr = CreateAuthorityInformationAccessExtension(
				hInf,
				pwszSanitizedCAName,
				iCert,
				iKey,
				fUseDS,
				&extAIA.fCritical,
				&extAIA.Value.pbData,
				&extAIA.Value.cbData);
    _PrintIfError3(
	    hr,
	    "CreateAuthorityInformationAccessExtension",
	    E_HANDLE,
	    S_FALSE);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extAIA, &Cert.cExtension, Cert.rgExtension);
    }


    // Build the Enhanced Key Usage extension

    hr = myInfGetEnhancedKeyUsageExtension(hInf, &extEKU);
    if (S_OK == hr || S_FALSE == hr)
    {
	ReplaceExtension(&extEKU, &Cert.cExtension, Cert.rgExtension);
    }

    hr = EncodeCertAndSign(
		    hProv,
		    &Cert,
		    Cert.SignatureAlgorithm.pszObjId,
		    ppbCert,
		    pcbCert,
		    hInstance,
		    fUnattended,
		    hwnd);
    _JumpIfError(hr, error, "EncodeCertAndSign");

error:
    if (NULL != extBasicConstraints.Value.pbData)
    {
	LocalFree(extBasicConstraints.Value.pbData);
    }
    if (NULL != extSKI.Value.pbData)
    {
	LocalFree(extSKI.Value.pbData);
    }
    if (NULL != extCDP.Value.pbData)
    {
	LocalFree(extCDP.Value.pbData);
    }
    if (NULL != extVersion.Value.pbData)
    {
	LocalFree(extVersion.Value.pbData);
    }
    if (NULL != extPreviousHash.Value.pbData)
    {
	LocalFree(extPreviousHash.Value.pbData);
    }
    if (NULL != extPolicy.Value.pbData)
    {
	LocalFree(extPolicy.Value.pbData);
    }
    if (NULL != extCross.Value.pbData)
    {
	LocalFree(extCross.Value.pbData);
    }
    if (NULL != extAIA.Value.pbData)
    {
	LocalFree(extAIA.Value.pbData);
    }
    if (NULL != extEKU.Value.pbData)
    {
	LocalFree(extEKU.Value.pbData);
    }
    if (NULL != paext)
    {
        LocalFree(paext);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    CSILOG(hr, IDS_ILOG_CLONECERT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiBuildRequest(
    OPTIONAL IN HINF hInf,
    OPTIONAL IN CERT_CONTEXT const *pccPrevious,
    IN BYTE const *pbSubjectEncoded,
    IN DWORD cbSubjectEncoded,
    IN char const *pszAlgId,
    IN BOOL fNewKey,
    IN DWORD iCert,
    IN DWORD iKey,
    IN HCRYPTPROV hProv,
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT BYTE **ppbEncode,
    OUT DWORD *pcbEncode)
{
    HRESULT hr;
    CERT_PUBLIC_KEY_INFO  *pInfo = NULL;
    DWORD                  cbInfo = 0;
    BYTE                  *pbEncode = NULL;
    DWORD                  cbEncode;
    CERT_REQUEST_INFO      CertRequestInfo;
    CRYPT_ALGORITHM_IDENTIFIER AlgId;
    HCERTTYPE              hCertType = NULL;
    CRYPT_ATTR_BLOB        ExtBlob;
    CRYPT_ATTR_BLOB        VersionBlob;
    CRYPT_ATTRIBUTE        aAttrib[2];
    CERT_EXTENSIONS       *pExtensions = NULL;
    CERT_EXTENSIONS Extensions;
    CERT_EXTENSION aext[8];
    CERT_EXTENSION *paext = NULL;
    DWORD i;
    DWORD NameId = MAKECANAMEID(iCert, iKey);
    DWORD cExtCommon = 0;
    CERT_EXTENSION *pext;
    DWORD cAttribute = 0;
    CRYPT_ATTR_BLOB *paAttribute = NULL;
    WCHAR *pwszTemplateName;
    WCHAR *pwszTemplateNameInf = NULL;

    ExtBlob.pbData = NULL;
    VersionBlob.pbData = NULL;

    if (!CryptExportPublicKeyInfo(
                hProv,
                AT_SIGNATURE,
                X509_ASN_ENCODING,
                NULL,
                &cbInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo");
    }

    pInfo = (CERT_PUBLIC_KEY_INFO *) LocalAlloc(LMEM_FIXED, cbInfo);
    if (NULL == pInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportPublicKeyInfo(
                    hProv,
                    AT_SIGNATURE,
                    X509_ASN_ENCODING,
                    pInfo,
                    &cbInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo");
    }

    CertRequestInfo.dwVersion = CERT_REQUEST_V1;
    CertRequestInfo.Subject.pbData = const_cast<BYTE *>(pbSubjectEncoded);
    CertRequestInfo.Subject.cbData = cbSubjectEncoded;
    CertRequestInfo.SubjectPublicKeyInfo = *pInfo;

    // Build the CA Version extension

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_INTEGER,
		&NameId,
		0,
		CERTLIB_USE_LOCALALLOC,
		&aext[cExtCommon].Value.pbData,
		&aext[cExtCommon].Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    aext[cExtCommon].pszObjId = szOID_CERTSRV_CA_VERSION;
    aext[cExtCommon].fCritical = FALSE;
    cExtCommon++;

    // Build the previous CA cert hash extension

    if (0 != iCert && NULL != pccPrevious)
    {
	hr = GetCertHashExtension(
			    pccPrevious,
			    &aext[cExtCommon].Value.pbData,
			    &aext[cExtCommon].Value.cbData);
	_JumpIfError(hr, error, "GetCertHashExtension");

	aext[cExtCommon].pszObjId = szOID_CERTSRV_PREVIOUS_CERT_HASH;
	aext[cExtCommon].fCritical = FALSE;
	cExtCommon++;
    }

    // Subject Key Identifier extension:
    // If we're reusing the old key, reuse the old SKI -- even if it's "wrong".

    pext = NULL;
    if (0 != iCert && NULL != pccPrevious && !fNewKey)
    {
	pext = CertFindExtension(
			szOID_SUBJECT_KEY_IDENTIFIER,
			pccPrevious->pCertInfo->cExtension,
			pccPrevious->pCertInfo->rgExtension);
    }
    if (NULL != pext)
    {
	aext[cExtCommon].Value.cbData = pext->Value.cbData;
	aext[cExtCommon].Value.pbData = (BYTE *) LocalAlloc(
						LMEM_FIXED,
						pext->Value.cbData);
	if (NULL == aext[cExtCommon].Value.pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(
		aext[cExtCommon].Value.pbData,
		pext->Value.pbData,
		pext->Value.cbData);
    }
    else
    {
	hr = myCreateSubjectKeyIdentifierExtension(
					&CertRequestInfo.SubjectPublicKeyInfo,
					&aext[cExtCommon].Value.pbData,
					&aext[cExtCommon].Value.cbData);
	_JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");
    }

    aext[cExtCommon].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
    aext[cExtCommon].fCritical = FALSE;
    cExtCommon++;

    hr = myInfGetPolicyStatementExtension(hInf, &aext[cExtCommon]);
    _PrintIfError(hr, "myInfGetPolicyStatementExtension");
    if (S_OK == hr)
    {
	aext[cExtCommon].pszObjId = szOID_CERT_POLICIES;
	cExtCommon++;
    }

    hr = myInfGetCrossCertDistributionPointsExtension(hInf, &aext[cExtCommon]);
    _PrintIfError(hr, "myInfGetCrossCertDistributionPointsExtension");
    if (S_OK == hr)
    {
	aext[cExtCommon].pszObjId = szOID_CROSS_CERT_DIST_POINTS;
	cExtCommon++;
    }

    hr = myInfGetRequestAttributes(
			hInf,
			&cAttribute,
			&paAttribute,
			&pwszTemplateNameInf);
    _PrintIfError(hr, "myInfGetRequestAttributes");

    pwszTemplateName = pwszTemplateNameInf;
    if (NULL == pwszTemplateName)
    {
	pwszTemplateName = wszCERTTYPE_SUBORDINATE_CA;
    }

    // Build the attribute containing the appropriate cert type info

    hr = CAFindCertTypeByName(
                pwszTemplateName,
                NULL,
                CT_FIND_LOCAL_SYSTEM |
		    CT_ENUM_MACHINE_TYPES |
		    CT_ENUM_USER_TYPES,
                &hCertType);
    if (S_OK == hr)
    {
        hr = CAGetCertTypeExtensions(hCertType, &pExtensions);
        _JumpIfError(hr, error, "CAGetCertTypeExtensions");

	paext = (CERT_EXTENSION *) LocalAlloc(
		    LMEM_FIXED,
		    (pExtensions->cExtension + cExtCommon) * sizeof(paext[0]));
	if (NULL == paext)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(&paext[0], &aext[0], cExtCommon * sizeof(paext[0]));
	CopyMemory(
		&paext[cExtCommon],
		pExtensions->rgExtension,
		pExtensions->cExtension * sizeof(paext[0]));

        Extensions.cExtension = cExtCommon + pExtensions->cExtension;
        Extensions.rgExtension = paext;
    }
    else
    {
        DBGERRORPRINTLINE("CAFindCertTypeByName", hr);

        // standard extensions are not available from CAGetCertTypeExtensions;
        // construct them manually.

	// Build the Cert Template extension

	hr = myBuildCertTypeExtension(pwszTemplateName, &aext[cExtCommon]);
	_JumpIfError(hr, error, "myBuildCertTypeExtension");

	cExtCommon++;

        if (!CreateKeyUsageExtension(
		myCASIGN_KEY_USAGE,
                &aext[cExtCommon].Value.pbData,
                &aext[cExtCommon].Value.cbData,
                hInstance,
                fUnattended,
                hwnd))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateKeyUsageExtension");
        }
	aext[cExtCommon].pszObjId = szOID_KEY_USAGE;
	aext[cExtCommon].fCritical = FALSE;
	cExtCommon++;

        hr = myInfGetBasicConstraints2CAExtensionOrDefault(
					hInf,
					&aext[cExtCommon]);
	_JumpIfError(hr, error, "myInfGetBasicConstraints2CAExtensionOrDefault");

	cExtCommon++;

	CSASSERT(ARRAYSIZE(aext) >= cExtCommon);

        Extensions.cExtension = cExtCommon;
        Extensions.rgExtension = aext;
    }

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_EXTENSIONS,
		&Extensions,
		0,
		CERTLIB_USE_LOCALALLOC,
		&ExtBlob.pbData,
		&ExtBlob.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    // get the OS Version

    hr = myBuildOSVersionAttribute(&VersionBlob.pbData, &VersionBlob.cbData);
    _JumpIfError(hr, error, "myBuildOSVersionAttribute");

    aAttrib[0].pszObjId = szOID_RSA_certExtensions;
    aAttrib[0].cValue = 1;
    aAttrib[0].rgValue = &ExtBlob;

    aAttrib[1].pszObjId = szOID_OS_VERSION;
    aAttrib[1].cValue = 1;
    aAttrib[1].rgValue = &VersionBlob;

    CertRequestInfo.cAttribute = ARRAYSIZE(aAttrib);
    CertRequestInfo.rgAttribute = aAttrib;

    AlgId.pszObjId = const_cast<char *>(pszAlgId);
    AlgId.Parameters.cbData = 0;
    AlgId.Parameters.pbData = NULL;

    if (!CryptSignAndEncodeCertificate(
                    hProv,
                    AT_SIGNATURE,
                    X509_ASN_ENCODING,
                    X509_CERT_REQUEST_TO_BE_SIGNED,
                    &CertRequestInfo,
                    &AlgId,
                    NULL,
                    NULL,
                    &cbEncode))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignAndEncodeCertificate");
    }

    pbEncode = (BYTE *) LocalAlloc(LMEM_FIXED, cbEncode);
    if (NULL == pbEncode)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptSignAndEncodeCertificate(
                hProv,
                AT_SIGNATURE,
                X509_ASN_ENCODING,
                X509_CERT_REQUEST_TO_BE_SIGNED,
                &CertRequestInfo,
                &AlgId,
                NULL,
                pbEncode,
                &cbEncode))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignAndEncodeCertificate");
    }

    // return value
    *ppbEncode = pbEncode;
    *pcbEncode = cbEncode;
    hr = S_OK;

error:
    if (NULL != pwszTemplateNameInf)
    {
        LocalFree(pwszTemplateNameInf);
    }
    if (NULL != paAttribute)
    {
	myInfFreeRequestAttributes(cAttribute, paAttribute);
    }
    for (i = 0; i < cExtCommon; i++)
    {
        if (NULL != aext[i].Value.pbData)
        {
            LocalFree(aext[i].Value.pbData);
        }
    }
    if (NULL != paext)
    {
        LocalFree(paext);
    }
    if (NULL != ExtBlob.pbData)
    {
        LocalFree(ExtBlob.pbData);
    }
    if (NULL != VersionBlob.pbData)
    {
        LocalFree(VersionBlob.pbData);
    }
    if (NULL != pInfo)
    {
        LocalFree(pInfo);
    }
    if (NULL != hCertType)
    {
        if (NULL != pExtensions && &Extensions != pExtensions)
        {
            CAFreeCertTypeExtensions(hCertType, pExtensions);
        }
        CACloseCertType(hCertType);
    }
    CSILOG(hr, IDS_ILOG_BUILDREQUEST, NULL, NULL, &NameId);
    return(hr);
}


//+-------------------------------------------------------------------------
// CertServerRequestCACertificateAndComplete -- implements the following:
//	MMC snapin's RenewCert and InstallCert verbs
//	certutil -InstallCert & -RenewCert
//+-------------------------------------------------------------------------

HRESULT
CertServerRequestCACertificateAndComplete(
    IN HINSTANCE             hInstance,
    IN HWND                  hwnd,
    IN DWORD                 Flags,
    IN WCHAR const          *pwszCAName,
    OPTIONAL IN WCHAR const *pwszParentMachine,
    OPTIONAL IN WCHAR const *pwszParentCA,
    OPTIONAL IN WCHAR const *pwszCAChainFile,
    OPTIONAL OUT WCHAR     **ppwszRequestFile)
{
    HRESULT hr;
    DWORD dwSetupStatus;
    WCHAR const *pwszFinalParentMachine = pwszParentMachine;
    WCHAR const *pwszFinalParentCA = pwszParentCA;
    WCHAR *pwszRequestFile = NULL;
    WCHAR *pwszCertFile = NULL;
    BYTE *pbRequest = NULL;
    DWORD cbRequest;
    BSTR strChain = NULL;
    BYTE *pbChain = NULL;
    DWORD cbChain;
    WCHAR *pwszKeyContainer = NULL;
    WCHAR *pwszServerName = NULL;
    WCHAR *pwsz;
    CERTHIERINFO CertHierInfo;
    ENUM_CATYPES CAType;
    BOOL fUseDS;
    DWORD dwRevocationFlags;
    DWORD iCertNew;
    DWORD iKey;
    CERT_CONTEXT const *pccCertOld = NULL;
    HCRYPTPROV hProv = NULL;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    ALG_ID idAlg;
    BOOL fMachineKeyset;
    BOOL fKeyGenFailed;
    CHAR *pszAlgId = NULL;
    BOOL fUnattended = (CSRF_UNATTENDED & Flags)? TRUE : FALSE;
    BOOL fRenew = (CSRF_RENEWCACERT & Flags)? TRUE : FALSE;
    BOOL fNewKey = (CSRF_NEWKEYS & Flags)? TRUE : FALSE;
    UINT idMsg;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    
    idMsg = IDS_ILOG_INSTALLCERT;
    if (fRenew)
    {
        idMsg = fNewKey? IDS_ILOG_RENEWNEWKEY : IDS_ILOG_RENEWOLDKEY;
    }
    
    ZeroMemory(&CertHierInfo, sizeof(CertHierInfo));
    ZeroMemory(&KeyProvInfo, sizeof(KeyProvInfo));
    
    if (NULL != ppwszRequestFile)
    {
        *ppwszRequestFile = NULL;
    }
    
    if (NULL == pwszCAName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL CA Name");
    }
    
    hr = mySanitizeName(pwszCAName, &CertHierInfo.pwszSanitizedCAName);
    _JumpIfError(hr, error, "mySanitizeName");
    
    hr = GetSetupStatus(CertHierInfo.pwszSanitizedCAName, &dwSetupStatus);
    _JumpIfError(hr, error, "GetSetupStatus");
    
    hr = myGetCertRegDWValue(
        CertHierInfo.pwszSanitizedCAName,
        NULL,
        NULL,
        wszREGCATYPE,
        (DWORD *) &CAType);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCATYPE);
    
    // use DS or not
    hr = myGetCertRegDWValue(
        CertHierInfo.pwszSanitizedCAName,
        NULL,
        NULL,
        wszREGCAUSEDS,
        (DWORD *) &fUseDS);
    _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszREGCAUSEDS);
    
    hr = myGetCertRegStrValue(
        CertHierInfo.pwszSanitizedCAName,
        NULL,
        NULL,
        wszREGCASERVERNAME,
        &pwszServerName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCASERVERNAME);
    
    hr = myGetCertRegDWValue(
        CertHierInfo.pwszSanitizedCAName,
        wszREGKEYPOLICYMODULES,
        wszCLASS_CERTPOLICY,
        wszREGREVOCATIONTYPE,
        &dwRevocationFlags);
    if (S_OK != hr)
    {
        dwRevocationFlags = fUseDS? REVEXT_DEFAULT_DS : REVEXT_DEFAULT_NODS;
    }
    
    // Current Hash count is the same as the next iCert
    
    hr = myGetCARegHashCount(
			CertHierInfo.pwszSanitizedCAName,
			CSRH_CASIGCERT,
			&iCertNew);
    _JumpIfError(hr, error, "myGetCARegHashCount");
    
    if (fRenew)
    {
        // We're renewing the CA cert, so the initial setup should be complete.
        
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
        if (0 == iCertNew || (SETUP_SUSPEND_FLAG & dwSetupStatus))
        {
            _JumpError(hr, error, "not fully installed");
        }
        if (SETUP_REQUEST_FLAG & dwSetupStatus)
        {
            if (0 == (CSRF_OVERWRITE & Flags))
            {
                _JumpError(hr, error, "Renewal already in progress");
            }
            _PrintError(hr, "Ignoring renewal already in progress");
        }

        hr = myGetCertSrvCSP(
		    FALSE,		// fEncryptionCSP
		    CertHierInfo.pwszSanitizedCAName,
		    &dwProvType,
		    &pwszProvName,
		    &idAlg,
		    &fMachineKeyset,
		    NULL);		// pdwKeySize
        _JumpIfError(hr, error, "myGetCertSrvCSP");

        hr = LoadCurrentCACertAndKeyInfo(
	    CertHierInfo.pwszSanitizedCAName,
            fNewKey,
            fUnattended,
            fMachineKeyset,
            iCertNew,
            &iKey,
            &pwszKeyContainer,
            &pccCertOld);
        _JumpIfError(hr, error, "LoadCurrentCACertAndKeyInfo");
        
        CSASSERT(MAXDWORD != iKey);
        
        hr = csiFillKeyProvInfo(
		    pwszKeyContainer,
		    pwszProvName,
		    dwProvType,
		    fMachineKeyset,
		    &KeyProvInfo);
        _JumpIfError(hr, error, "csiFillKeyProvInfo");

        hr = GetCertServerKeyProviderInfo(
            CertHierInfo.pwszSanitizedCAName,
            pwszKeyContainer,
            &idAlg,
            &fMachineKeyset,
            &KeyProvInfo);
        _JumpIfError(hr, error, "GetCertServerKeyProviderInfo");
        
	hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
	_PrintIfError2(
		hr,
		"myInfOpenFile",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

        if (fNewKey)
        {
            CWaitCursor cwait;
            DWORD cbitKey;
            
            hr = myInfGetKeyLength(hInf, &cbitKey);
            if (S_OK != hr)
            {
                cbitKey = CertGetPublicKeyLength(
                    X509_ASN_ENCODING,
                    &pccCertOld->pCertInfo->SubjectPublicKeyInfo);
                if (0 == cbitKey || 512 == cbitKey)
                {
                    if (0 == cbitKey)
                    {
                        hr = myHLastError();
                        _PrintError(hr, "CertGetPublicKeyLength");
                    }
                    cbitKey = 1024;
                }
            }
            hr = csiGenerateCAKeys(
                KeyProvInfo.pwszContainerName,
                KeyProvInfo.pwszProvName,
                KeyProvInfo.dwProvType,
                fMachineKeyset,
                cbitKey,	// dwKeyLength,
                hInstance,
                fUnattended,
                hwnd,
                &fKeyGenFailed);
            _JumpIfError(hr, error, "csiGenerateCAKeys");
        }
        
        // get CSP handle
        
        if (!myCertSrvCryptAcquireContext(
            &hProv,
            KeyProvInfo.pwszContainerName,
            KeyProvInfo.pwszProvName,
            KeyProvInfo.dwProvType,
            fUnattended? CRYPT_SILENT : 0,
            fMachineKeyset))
        {
            hr = myHLastError();
            _JumpError(hr, error, "myCertSrvCryptAcquireContext");
        }
        if (hProv == NULL)
        {
            hr = E_HANDLE;
            _JumpError(hr, error, "myCertSrvCryptAcquireContext");
        }
        
        if (IsRootCA(CAType))
        {
            hr = CloneRootCert(
                hInf,
		pccCertOld,
                &KeyProvInfo,
                hProv,
                CertHierInfo.pwszSanitizedCAName,
                iCertNew,
                iKey,
                fUseDS,
                fNewKey,
                dwRevocationFlags,
                hInstance,
                fUnattended,
                hwnd,
                &pbChain,
                &cbChain);
            _JumpIfError(hr, error, "CloneRootCert");
        }
        else
        {
            // get request file name
            hr = csiGetCARequestFileName(
                hInstance,
                hwnd,
                CertHierInfo.pwszSanitizedCAName,
                iCertNew,
                iKey,
                &pwszRequestFile);
            _JumpIfError(hr, error, "csiGetCARequestFileName");
            
            
            hr = myGetSigningOID(
			    NULL,	// hProv
			    KeyProvInfo.pwszProvName,
			    KeyProvInfo.dwProvType,
			    idAlg,
			    &pszAlgId);
            _JumpIfError(hr, error, "myGetSigningOID");
            
            hr = csiBuildRequest(
			    hInf,
			    pccCertOld,
			    pccCertOld->pCertInfo->Subject.pbData,
			    pccCertOld->pCertInfo->Subject.cbData,
			    pszAlgId,
			    fNewKey,
			    iCertNew,
			    iKey,
			    hProv,
			    hwnd,
			    hInstance,
			    fUnattended,
			    &pbRequest,
			    &cbRequest);
            _JumpIfError(hr, error, "csiBuildRequest");
            
            hr = EncodeToFileW(
                pwszRequestFile,
                pbRequest,
                cbRequest,
                DECF_FORCEOVERWRITE | CRYPT_STRING_BASE64REQUESTHEADER);
            _JumpIfError(hr, error, "EncodeToFileW");
            
            hr = mySetCertRegKeyIndexAndContainer(
                CertHierInfo.pwszSanitizedCAName,
                iKey,
                pwszKeyContainer);
            _JumpIfError(hr, error, "mySetCertRegKeyIndexAndContainer");
            
            hr = SetSetupStatus(
                CertHierInfo.pwszSanitizedCAName,
                SETUP_REQUEST_FLAG,
                TRUE);
            _JumpIfError(hr, error, "SetSetupStatus");
            
            if (NULL != ppwszRequestFile)
            {
                *ppwszRequestFile = pwszRequestFile;
                pwszRequestFile = NULL;
                CSASSERT(S_OK == hr);
            }
        }
    }
    else
    {
        // We're not renewing the CA cert, so this had better be an incomplete
        // renewal or initial setup; we're waiting for the new cert or chain.
        
        if (IsRootCA(CAType) || 0 == (SETUP_REQUEST_FLAG & dwSetupStatus))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
            _JumpIfError(hr, error, "no outstanding request");
        }
        
        hr = myGetCertRegKeyIndexAndContainer(
            CertHierInfo.pwszSanitizedCAName,
            &iKey,
            &pwszKeyContainer);
        _JumpIfError(hr, error, "myGetCertRegKeyIndexAndContainer");
        
        if (NULL == pwszCAChainFile)
        {
            // pop up open dlg
            hr = myGetOpenFileName(
                hwnd,
                hInstance,
                IDS_CAHIER_INSTALL_TITLE,
                IDS_CAHIER_CERTFILE_FILTER,
                0,		// no def ext
                OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
                NULL,	// no default file
                &pwszCertFile);
            if (S_OK == hr && NULL != pwszCertFile)
            {
                pwszCAChainFile = pwszCertFile;
            }
        }
        if (NULL != pwszCAChainFile)
        {
            hr = DecodeFileW(pwszCAChainFile, &pbChain, &cbChain, CRYPT_STRING_ANY);
            _JumpIfErrorStr(hr, error, "DecodeFileW", pwszCAChainFile);
        }
    }
    
    if (!IsRootCA(CAType) && NULL == pbChain)
    {
        // if we haven't created the request, grab it from a file for resubmission
        if (pbRequest == NULL)
        {
            hr = myGetCARegFileNameTemplate(
                wszREGREQUESTFILENAME,
                pwszServerName,
                CertHierInfo.pwszSanitizedCAName,
                iCertNew,
                iKey,
                &pwszRequestFile);
            _JumpIfError(hr, error, "myGetCARegFileNameTemplate");
            
            hr = DecodeFileW(pwszRequestFile, &pbRequest, &cbRequest, CRYPT_STRING_ANY);
            _JumpIfErrorStr(hr, error, "DecodeFileW", pwszRequestFile);
        }
        
        if (NULL == pwszParentMachine || NULL == pwszParentCA)
        {
            CertHierInfo.hInstance = hInstance;
            CertHierInfo.fUnattended = fUnattended;
            CertHierInfo.iCertNew = iCertNew;
            CertHierInfo.iKey = iKey;
            
            // get parent ca info
            hr = myGetCertRegStrValue(
                CertHierInfo.pwszSanitizedCAName,
                NULL,
                NULL,
                wszREGPARENTCAMACHINE,
                &CertHierInfo.pwszParentMachineDefault);
            _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGPARENTCAMACHINE);
            
            hr = myGetCertRegStrValue(
                CertHierInfo.pwszSanitizedCAName,
                NULL,
                NULL,
                wszREGPARENTCANAME,
                &CertHierInfo.pwszParentCADefault);
            _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGPARENTCANAME);
            
            // invoke parent ca dialog to select
            if (IDOK != (int) DialogBoxParam(
                hInstance,
                MAKEINTRESOURCE(IDD_COMPLETE_DIALOG),
                hwnd,
                CertHierProc,
                (LPARAM) &CertHierInfo))
            {
                // cancel
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                _JumpError(hr, error, "cancel");
            }
            pwszFinalParentMachine = CertHierInfo.pwszParentMachine;
            pwszFinalParentCA = CertHierInfo.pwszParentCA;
        }
        
        BOOL fRetrievePending =
            (SETUP_REQUEST_FLAG & dwSetupStatus) &&
            (SETUP_ONLINE_FLAG & dwSetupStatus) &&
            NULL != CertHierInfo.pwszParentMachineDefault &&
            NULL != CertHierInfo.pwszParentCADefault &&
            0 == lstrcmpi(
            pwszFinalParentMachine,
            CertHierInfo.pwszParentMachineDefault) &&
            0 == lstrcmpi(
            pwszFinalParentCA,
            CertHierInfo.pwszParentCADefault);
        
        // submit to parent ca
        hr = csiSubmitCARequest(
            hInstance,
            fUnattended,
            hwnd,
            fRenew,
            fRetrievePending,
            CertHierInfo.pwszSanitizedCAName,
            pwszFinalParentMachine,
            pwszFinalParentCA,
            pbRequest,
            cbRequest,
            &strChain);
        _JumpIfError(hr, error, "csiSubmitCARequest");
        
        cbChain = SysStringByteLen(strChain);
    }
    
    hr = FinishSuspendedSetupFromPKCS7(
        hInstance,
        fUnattended,
        hwnd,
        CertHierInfo.pwszSanitizedCAName,
        pwszKeyContainer,
        iKey,
	fRenew || 0 != iCertNew,
        NULL != pbChain? pbChain : (BYTE *) strChain,
        cbChain);
    _JumpIfError(hr, error, "FinishSuspendedSetupFromPKCS7");
    
    MarkSetupComplete(CertHierInfo.pwszSanitizedCAName);
    CSASSERT(S_OK == hr);
    
error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    FreeCertHierInfo(&CertHierInfo);
    csiFreeKeyProvInfo(&KeyProvInfo);
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pszAlgId)
    {
        LocalFree(pszAlgId);
    }
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pccCertOld)
    {
        CertFreeCertificateContext(pccCertOld);
    }
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszCertFile)
    {
        LocalFree(pwszCertFile);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    if (NULL != pbRequest)
    {
        LocalFree(pbRequest);
    }
    if (NULL != pbChain)
    {
        LocalFree(pbChain);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != strChain)
    {
        SysFreeString(strChain);
    }
    CSILOG(hr, idMsg, pwszCAName, NULL, NULL);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\initlib\certmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certmsg.cpp
//
//--------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  File:       certmsg.cpp
// 
//  Contents:   message display APIs
//
//  History:    11/97   xtan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Application Includes
#include "setupids.h"
#include "certmsg.h"


#define __dwFILE__	__dwFILE_CERTLIB_CERTMSG_CPP__

extern FNLOGMESSAGEBOX *g_pfnLogMessagBox;


//--------------------------------------------------------------------
// Throw up a dialog with the format "<Prefix><UserMsg><SysErrorMsg>".
//   <Prefix> is basically "An error was detected...run the 
//       wizard again..." and is prepended if CMB_REPEATWIZPREFIX
//       is specified.
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg. if dwMsgId is 0, 
//       pwszCustomMsg is used instead.
//   <SysErrorMsg> is the system message for hrCode. It can be
//       suppressed if CMB_NOERRFROMSYS is specified.
int
CertMessageBox(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hWnd,
    IN DWORD dwMsgId,
    IN HRESULT hrCode,
    IN UINT uType,
    IN OPTIONAL const WCHAR * pwszCustomMsg)
{
    HRESULT hr;
    int nMsgBoxRetVal = -1;
    DWORD nMsgChars = 0;
    WCHAR szEmergency[36];

    // variables that must be cleaned up
    WCHAR * pwszTitle = NULL;
    WCHAR * pwszPrefix = NULL;
    WCHAR * pwszUserMsg = NULL;
    WCHAR * pwszExpandedUserMsg = NULL;
    WCHAR const *pwszSysMsg = NULL;
    WCHAR * pwszFinalMsg = NULL;

    // mask off CMB defines
    BOOL fRepeatWizPrefix = uType & CMB_REPEATWIZPREFIX;
    BOOL fNoErrFromSys    = uType & CMB_NOERRFROMSYS;
    uType &= ~(CMB_NOERRFROMSYS | CMB_REPEATWIZPREFIX);

    // load title
    hr=myLoadRCString(hInstance, IDS_MSG_TITLE, &pwszTitle);
    _JumpIfError(hr, error, "myLoadRCString");

    // load the "this wizard will need to be run again" prefix, if necessary
    if (fRepeatWizPrefix) {
        hr=myLoadRCString(hInstance, IDS_ERR_REPEATWIZPREFIX, &pwszPrefix);
        _JumpIfError(hr, error, "myLoadRCString");
        nMsgChars+=wcslen(pwszPrefix);
    }

    // get the system message for this error, if necessary
    if (!fNoErrFromSys) {
        pwszSysMsg = myGetErrorMessageText1(hrCode, TRUE, pwszCustomMsg);
        nMsgChars += wcslen(pwszSysMsg) + 1;
    }

    if (0!=dwMsgId) {
        // load requested message from resource
        hr=myLoadRCString(hInstance, dwMsgId, &pwszUserMsg);
        _JumpIfError(hr, error, "myLoadRCString");

        // perform substitution if necessary
        if (NULL==pwszCustomMsg) {
            // no substitution necessary
            CSASSERT(NULL==wcsstr(pwszUserMsg, L"%1")); // were we expecting a substitution?
        } else {
            // perform a substitution
            CSASSERT(NULL!=wcsstr(pwszUserMsg, L"%1")); // were we not expecting a substitution?
            if (!FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |                 // flags
                            FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        pwszUserMsg,                                     // source
                        0,                                               // message id
                        0,                                               // language id
                        reinterpret_cast<WCHAR *>(&pwszExpandedUserMsg), // output buffer
                        0,                                               // min size
                        reinterpret_cast<va_list *>(
                            const_cast<WCHAR **>(&pwszCustomMsg))))      // pointer to array of pointers
            {
                hr=myHLastError();
                _JumpError(hr, error, "FormatMessage");
            }

            // use the expanded message instead of the unexpanded message
            LocalFree(pwszUserMsg);
            pwszUserMsg=pwszExpandedUserMsg;
            pwszExpandedUserMsg = NULL;
        }

    } 
    else if (NULL != pwszCustomMsg)
    {

        // use pwszCustomMsg instead
        CSASSERT(NULL!=pwszCustomMsg);
        pwszUserMsg=const_cast<WCHAR *>(pwszCustomMsg);
    }
    else
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Invalid NULL param");
    }

    nMsgChars+=wcslen(pwszUserMsg);

    // allocate buffer to hold everything
    pwszFinalMsg=(WCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (nMsgChars+1)*sizeof(WCHAR));
    if (NULL == pwszFinalMsg)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // build the message
    if (NULL!=pwszPrefix) {
        wcscat(pwszFinalMsg, pwszPrefix);
    }
    wcscat(pwszFinalMsg, pwszUserMsg);
    if (NULL!=pwszSysMsg) {
        wcscat(pwszFinalMsg, L" ");
        wcscat(pwszFinalMsg, pwszSysMsg);
    }
    CSASSERT(wcslen(pwszFinalMsg) <= nMsgChars);

    // finally show message
    DBGPRINT((DBG_SS_CERTLIB, "MessageBox: %ws: %ws\n", pwszTitle, pwszFinalMsg));
    if (NULL != g_pfnLogMessagBox)
    {
	(*g_pfnLogMessagBox)(hrCode, dwMsgId, pwszTitle, pwszFinalMsg);
    }
    if (fUnattended)
    {
	nMsgBoxRetVal = IDYES;
    }
    else
    {
        nMsgBoxRetVal=MessageBox(hWnd, pwszFinalMsg, pwszTitle, uType | MB_SETFOREGROUND);
    }
    if (NULL != g_pfnLogMessagBox)
    {
	_snwprintf(szEmergency, ARRAYSIZE(szEmergency), L"%d", nMsgBoxRetVal);
	(*g_pfnLogMessagBox)(S_OK, dwMsgId, pwszTitle, szEmergency);
    }

    // skip error handling
    goto done;

error:
    // we had an error, but we really need to show something
    // build a non-localized desperation dialog: "Fatal: 0xNNNNNNNN  MsgId:0xNNNNNNNN"
    _snwprintf(szEmergency, ARRAYSIZE(szEmergency), L"Fatal: 0x%8X  MsgId: 0x%8X", hr, dwMsgId);
    DBGPRINT((DBG_SS_CERTLIB, "EmergencyMessageBox: %ws\n", szEmergency));
    if (NULL != g_pfnLogMessagBox)
    {
	(*g_pfnLogMessagBox)(hrCode, dwMsgId, L"EmergencyMessageBox", szEmergency);
    }
    if (!fUnattended) {
        // The message box with these flags is guaranteed to display
        MessageBox(hWnd, szEmergency, NULL, MB_ICONHAND | MB_SYSTEMMODAL);
    }

done:
    if (NULL!=pwszTitle) {
        LocalFree(pwszTitle);
    }
    if (NULL!=pwszPrefix) {
        LocalFree(pwszPrefix);
    }
    if (NULL!=pwszUserMsg && pwszUserMsg!=pwszCustomMsg) {
        LocalFree(pwszUserMsg);
    }
    if (NULL!=pwszExpandedUserMsg) {
        LocalFree(pwszExpandedUserMsg);
    }
    if (NULL!=pwszSysMsg) {
        LocalFree(const_cast<WCHAR *>(pwszSysMsg));
    }
    if (NULL!=pwszFinalMsg) {
        LocalFree(pwszFinalMsg);
    }

    return nMsgBoxRetVal;
}


//--------------------------------------------------------------------
// Throw up a dialog with the format "<UserMsg>".
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg.
int
CertInfoMessageBox(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN OPTIONAL const WCHAR * pwszCustomMsg)
{
    return CertMessageBox(
               hInstance,
               fUnattended,
               hWnd,
               dwMsgId,
               0,
               MB_OK | MB_ICONINFORMATION | CMB_NOERRFROMSYS,
               pwszCustomMsg);
}

//--------------------------------------------------------------------
// Throw up a dialog with the format "<Prefix><UserMsg><SysErrorMsg>".
//   <Prefix> is basically "An error was detected...run the 
//       wizard again..." .
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg.
//   <SysErrorMsg> is the system message for hrCode.
int
CertErrorMessageBox(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg)
{
    return CertMessageBox(
               hInstance,
               fUnattended,
               hWnd,
               dwMsgId,
               hrCode,
               MB_OK | MB_ICONERROR | CMB_REPEATWIZPREFIX,
               pwszCustomMsg);
}

//--------------------------------------------------------------------
// Throw up a dialog with the format "<UserMsg><SysErrorMsg>".
//   <UserMsg> is specified by dwMsgId and can contain "%1" which
//       will be replaced with pwszCustomMsg.
//   <SysErrorMsg> is the system message for hrCode. It is
//       suppressed if a successful hrCode is specified.
int
CertWarningMessageBox(
    IN  HINSTANCE hInstance,
    IN  BOOL fUnattended,
    IN  HWND hWnd,
    IN  DWORD dwMsgId,
    IN  HRESULT hrCode,
    IN OPTIONAL  const WCHAR * pwszCustomMsg)
{
    UINT uType=MB_OK | MB_ICONWARNING;

    if (SUCCEEDED(hrCode)) {
        uType |= CMB_NOERRFROMSYS;
    }

    return CertMessageBox(
               hInstance,
               fUnattended,
               hWnd,
               dwMsgId,
               hrCode,
               uType,
               pwszCustomMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\initlib\initlib.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       initlib.cpp
//
//  Contents:   Install cert server
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

// C Run-Time Includes
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <winldap.h>
#include <ntldap.h>

// Windows System Includes
#include <winsvc.h>
#include <rpc.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmwksta.h>
#include <csdisp.h>
#include <wincrypt.h>
#include <objbase.h>
#include <initguid.h>
#include <userenv.h>
#include <cainfop.h>


#define SECURITY_WIN32
#include <security.h>

#include <lmerr.h>

// Application Includes
#include "setupids.h"
#include "certmsg.h"
#include "certca.h"
#include "certhier.h"
#include "tfc.h"
#include "cscsp.h"
#include "csldap.h"
#include "certacl.h"

#define __dwFILE__	__dwFILE_INITLIB_INITLIB_CPP__

WCHAR const g_szSlash[] = L"\\";
DWORD g_dwNameEncodeFlags = CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;

#define MAX_COMPUTER_DNS_NAME  256

using namespace CertSrv;


//+=====================================================================
// DS DNs:
//
// DomainDN Example (no longer used for Cert server DS objects):
//	DC=pksdom2,DC=nttest,DC=microsoft,DC=com
//
// ConfigDN Example:
//	CN=Configuration,DC=pksdom2,DC=nttest,DC=microsoft,DC=com
//
// Cert server DS objects reside in Public Key Services container under
// the Configuraton container:
//	CN=Public Key Services,CN=Services,<ConfigDN>
//
//
// In the Public Key Services container:
//
// Root Trust container:
//  Each Root CA creates a Root Trust object in this container to store trusted 
//  Root CA certificates downloaded by all DS clients.
//  Renewed CAs and CAs on multiple machines using the same CA name may use the
//  same Root Trust object, because certs are always added -- they are never
//  removed.
//
//  CN=Certification Authorities
//	CN=CA foo
//	CN=CA bar
//	...
//
//
// Authority Information Access container:
//  Each CA creates an AIA object in this container to store CA certs for chain
//  building.  Renewed CAs and CAs on multiple machines using the same CA name
//  may use the same AIA object, because certs are always added -- they are
//  never removed.
//
//  CN=AIA
//	CN=CA foo
//	CN=CA bar
//	...
//
//
// CRL Distribution Point containers:
//  Each CA creates a CDP object in this container for each unique CA key to
//  store CRLs for revocation checking.  Only one base CRL and zero or one
//  delta CRL are stored in each CDP object, due to potential size constraints,
//  and because the attribute is single valued.  When a CA is renewed and a new
//  CA key is generated during the renewal, a new CDP object is created with
//  the CA's key index (in parentheses) appended to the CN.  A nested container
//  is created for each machine with the CN set to the short machine name
//  (first component of the machine's full DNS name).
//
//  CN=CDP
//      CN=<CA foo's MachineName>
//	    CN=CA foo
//	    CN=CA foo(1)
//	    CN=CA foo(3)
//      CN=<CA bar's MachineName>
//	    CN=CA bar
//	    CN=CA bar(1)
//
//
// Enrollment Services container:
//  Each CA creates an Enrollment Services object in this container.  A flags
//  attribute indicates whether the CA supports autoenrollment (an Enterprise
//  CA) or not (Standalone CA).  The Enrollment Services object publishes the
//  existence of the CA to all DS clients.  Enrollment Services objects are
//  created and managed by the certca.h CA APIs.
//
//  CN=Enrollment Services
//	CN=CA foo
//	CN=CA bar
//	...
//
// Enterprise Trust object:
//  A single Enterprise Trust object contains certificates for all
//  autoenrollment-enabled CAs (root and subordinate Entrprise CAs).
//
//  CN=NTAuthCertificates
//
//======================================================================


WCHAR const s_wszRootCAs[] =
    L","
    L"CN=Certification Authorities,"
    L"CN=Public Key Services,"
    L"CN=Services,";

WCHAR const s_wszEnterpriseCAs[] =
    L"CN=NTAuthCertificates,"
    L"CN=Public Key Services,"
    L"CN=Services,";


//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------

BOOL
csiWriteDERToFile(
    IN WCHAR const *pwszFileName,
    IN BYTE const *pbDER,
    IN DWORD cbDER,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    BOOL fResult = FALSE;
    HRESULT hr;
    HANDLE hLocalFile;
    DWORD dwBytesWritten;

    do
    {
	// Write the Encoded Blob to the file
	hLocalFile = CreateFile(
			    pwszFileName,
			    GENERIC_WRITE,
			    0,
			    NULL,
			    CREATE_ALWAYS,
			    0,
			    0);
	if (INVALID_HANDLE_VALUE == hLocalFile)
	{
	    hr = myHLastError();
	    CertErrorMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_CREATEFILE,
			hr,
			pwszFileName);
	    break;
	}

	if (!WriteFile(hLocalFile, pbDER, cbDER, &dwBytesWritten, NULL))
	{
	    hr = myHLastError();
	    CertErrorMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_WRITEFILE,
			hr,
			pwszFileName);
	    break;
	}
	fResult = TRUE;
    } while (FALSE);

    if (INVALID_HANDLE_VALUE != hLocalFile)
    {
	CloseHandle(hLocalFile);
    }
    if (!fResult)
    {
	SetLastError(hr);
    }
    return(fResult);
}


BOOL
CreateKeyUsageExtension(
    BYTE bIntendedKeyUsage,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded,
    HINSTANCE hInstance,
    BOOL fUnattended,
    HWND hwnd)
{
    BOOL fResult = FALSE;
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_BIT_BLOB KeyUsage;

    KeyUsage.pbData = &bIntendedKeyUsage;
    KeyUsage.cbData = 1;
    KeyUsage.cUnusedBits = 0;

    if (!myEncodeKeyUsage(
		    X509_ASN_ENCODING,
		    &KeyUsage,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
        hr = myHLastError();
        CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_ENCODEKEYATTR,
		    hr,
		    NULL);
        goto error;
    }
    fResult = TRUE;

error:
    if (!fResult)
    {
	SetLastError(hr);
    }
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return(fResult);
}


#ifdef USE_NETSCAPE_TYPE_EXTENSION
BOOL
CreateNetscapeTypeExtension(
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    BOOL fResult = FALSE;
    CRYPT_BIT_BLOB NetscapeType;
    BYTE temp = NETSCAPE_SSL_CA_CERT_TYPE | NETSCAPE_SMIME_CA_CERT_TYPE;

    NetscapeType.pbData = &temp;
    NetscapeType.cbData = 1;
    NetscapeType.cUnusedBits = 0;
    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_BITS,
		    &NetscapeType,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
	goto exit;
    }
    fResult = TRUE;

exit:
    return(fResult);
}
#endif


HRESULT
GetRegCRLDistributionPoints(
    IN WCHAR const *pwszSanitizedName,
    IN BOOL fUseDS,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *pwszz = NULL;
    WCHAR *pwsz;
    WCHAR *pwszzCopy;
    DWORD cwc;
    DWORD Flags;
    WCHAR *pwszT;

    *ppwszz = NULL;
    hr = myGetCertRegMultiStrValue(
                        pwszSanitizedName,
                        NULL,
                        NULL,
			wszREGCRLPUBLICATIONURLS,
                        &pwszz);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
	goto error;
    }
    _JumpIfErrorStr(
		hr,
		error,
		"myGetCertRegMultiStrValue",
		wszREGCRLPUBLICATIONURLS);
    cwc = 0;
    for (pwsz = pwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	Flags = _wtoi(pwsz);
	if (CSURL_ADDTOCERTCDP & Flags)
	{
	    pwszT = pwsz;
	    while (iswdigit(*pwszT))
	    {
		pwszT++;
	    }
	    if (pwszT > pwsz && L':' == *pwszT)
	    {
		pwszT++;
		cwc += wcslen(pwszT) + 1;
	    }
	}
    }
    if (0 == cwc)
    {
        hr = S_OK;
	goto error;
    }

    pwszzCopy = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszzCopy)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppwszz = pwszzCopy;

    for (pwsz = pwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	Flags = _wtoi(pwsz);
	if (CSURL_ADDTOCERTCDP & Flags)
	{
	    pwszT = pwsz;
	    while (iswdigit(*pwszT))
	    {
		pwszT++;
	    }
	    if (pwszT > pwsz && L':' == *pwszT)
	    {
		pwszT++;
		wcscpy(pwszzCopy, pwszT);
		pwszzCopy += wcslen(pwszT) + 1;
	    }
	}
    }
    *pwszzCopy = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwszzCopy, *ppwszz) == cwc);

error:
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(hr);
}


HRESULT
FormatTemplateURLs(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    IN WCHAR const *pwszzIn,
    OUT DWORD *pcpwsz,
    OUT WCHAR ***ppapwszOut)
{
    HRESULT hr;
    DWORD i;
    WCHAR const **papwszTemplate = NULL;
    WCHAR const *pwsz;
    WCHAR **papwszOut = NULL;
    DWORD cpwsz = 0;
    WCHAR *pwszServerName = NULL;
    LDAP *pld = NULL;
    BSTR strConfigDN = NULL;
    BSTR strDomainDN = NULL;

    *pcpwsz = 0;
    *ppapwszOut = NULL;

    cpwsz = 0;
    if (NULL != pwszzIn)
    {
	for (pwsz = pwszzIn; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    cpwsz++;
        }
    }
    if (0 == cpwsz)
    {
        hr = S_FALSE;
        goto error;
    }

    papwszTemplate = (WCHAR const **) LocalAlloc(
				    LMEM_FIXED,
				    cpwsz * sizeof(papwszTemplate[0]));
    if (NULL == papwszTemplate)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    i = 0;
    for (pwsz = pwszzIn; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	papwszTemplate[i++] = pwsz;
    }
    CSASSERT(i == cpwsz);

    papwszOut = (WCHAR **) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cpwsz * sizeof(papwszOut[0]));
    if (NULL == papwszOut)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = myGetMachineDnsName(&pwszServerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");

    if (fUseDS)
    {
	// bind to ds

        hr = myRobustLdapBind(&pld, FALSE);
	_JumpIfError(hr, error, "myRobustLdapBind");

        hr = myGetAuthoritativeDomainDn(pld, &strDomainDN, &strConfigDN);
        if (S_OK != hr)
        {
            hr = HRESULT_FROM_WIN32(hr);
            _JumpError(hr, error, "myGetAuthoritativeDomainDn");
        }
    }
    else
    {
        strDomainDN = SysAllocString(L"");
	strConfigDN = SysAllocString(L"");
	if (NULL == strDomainDN || NULL == strConfigDN)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocString");
	}
    }
    hr = myFormatCertsrvStringArray(
			    TRUE,		// fURL
			    pwszServerName,	// pwszServerName_p1_2
			    pwszSanitizedName,	// pwszSanitizedName_p3_7
			    iCert,		// iCert_p4
			    strDomainDN,	// pwszDomainDN_p5
			    strConfigDN, 	// pwszConfigDN_p6
			    iCRL,		// iCRL_p8
			    FALSE,		// fDeltaCRL_p9
			    TRUE,		// fDSAttrib_p10_11
			    cpwsz,		// cStrings
			    papwszTemplate,	// apwszStringsIn
			    papwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    *pcpwsz = cpwsz;
    *ppapwszOut = papwszOut;
    papwszOut = NULL;

error:
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    if (NULL != strConfigDN)
    {
        SysFreeString(strConfigDN);
    }
    if (NULL != strDomainDN)
    {
        SysFreeString(strDomainDN);
    }
    if (NULL != papwszTemplate)
    {
        LocalFree(papwszTemplate);
    }
    if (NULL != papwszOut)
    {
        for (i = 0; i < cpwsz; i++)
        {
            if (papwszOut[i])
            {
                LocalFree(papwszOut[i]);
            }
        }
        LocalFree(papwszOut);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CreateRevocationExtension
//
// Return S_OK if extension has been constructed.
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//+--------------------------------------------------------------------------

HRESULT
CreateRevocationExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    IN DWORD dwRevocationFlags,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzCDP = NULL;
    WCHAR **papwszURL = NULL;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    CRL_DIST_POINT CRLDistPoint;
    CERT_ALT_NAME_INFO *pAltInfo;

    ZeroMemory(&CRLDistPoint, sizeof(CRLDistPoint));
    pAltInfo = &CRLDistPoint.DistPointName.FullName;

    *ppbEncoded = NULL;
    *pcbEncoded = 0;

    hr = E_HANDLE;
    if (INVALID_HANDLE_VALUE != hInf)
    {
	hr = myInfGetCRLDistributionPoints(hInf, pfCritical, &pwszzCDP);
    }
    if (S_OK != hr)
    {
	if (S_FALSE == hr)
	{
	    _JumpError2(hr, error, "myInfGetCRLDistributionPoints", hr);
	}
	hr = GetRegCRLDistributionPoints(
				pwszSanitizedName,
				fUseDS,
				&pwszzCDP);
	_JumpIfError(hr, error, "GetRegCRLDistributionPoints");
    }

    if (0 == (REVEXT_CDPENABLE & dwRevocationFlags))
    {
        hr = S_OK;
        goto error;
    }
    hr = FormatTemplateURLs(
		    pwszSanitizedName,
		    iCert,
		    iCRL,
		    fUseDS,
		    pwszzCDP,
		    &pAltInfo->cAltEntry,
		    &papwszURL);
    _JumpIfError(hr, error, "FormatTemplateURLs");

    CRLDistInfo.cDistPoint = 1;
    CRLDistInfo.rgDistPoint = &CRLDistPoint;

    CRLDistPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;

    pAltInfo->rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			pAltInfo->cAltEntry * sizeof(pAltInfo->rgAltEntry[0]));
    if (NULL == pAltInfo->rgAltEntry)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (i = 0; i < pAltInfo->cAltEntry; i++)
    {
        pAltInfo->rgAltEntry[i].pwszURL = papwszURL[i];
        pAltInfo->rgAltEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;

	DBGPRINT((DBG_SS_CERTLIB, "CDP[%u] = '%ws'\n", i, papwszURL[i]));
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pAltInfo->rgAltEntry)
    {
        LocalFree(pAltInfo->rgAltEntry);
    }
    if (NULL != papwszURL)
    {
        for (i = 0; i < pAltInfo->cAltEntry; i++)
        {
            if (NULL != papwszURL[i])
            {
                LocalFree(papwszURL[i]);
            }
        }
        LocalFree(papwszURL);
    }
    if (NULL != pwszzCDP)
    {
	LocalFree(pwszzCDP);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CreateAuthorityInformationAccessExtension
//
// Return S_OK if extension has been constructed.
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//+--------------------------------------------------------------------------

HRESULT
CreateAuthorityInformationAccessExtension(
    IN HINF hInf,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fUseDS,
    OUT BOOL *pfCritical,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzAIA = NULL;
    WCHAR **papwszURL = NULL;
    CERT_AUTHORITY_INFO_ACCESS caio;

    caio.cAccDescr = 0;
    caio.rgAccDescr = NULL;

    *ppbEncoded = NULL;
    *pcbEncoded = 0;

    hr = E_HANDLE;
    if (INVALID_HANDLE_VALUE != hInf)
    {
	hr = myInfGetAuthorityInformationAccess(hInf, pfCritical, &pwszzAIA);
    }
    _JumpIfError3(
	    hr,
	    error,
	    "myInfGetAuthorityInformationAccess",
	    E_HANDLE,
	    S_FALSE);

    hr = FormatTemplateURLs(
		    pwszSanitizedName,
		    iCert,
		    iCRL,
		    fUseDS,
		    pwszzAIA,
		    &caio.cAccDescr,
		    &papwszURL);
    _JumpIfError(hr, error, "FormatTemplateURLs");

    caio.rgAccDescr = (CERT_ACCESS_DESCRIPTION *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			caio.cAccDescr * sizeof(CERT_ACCESS_DESCRIPTION));
    if (NULL == caio.rgAccDescr)
    {
        hr = E_OUTOFMEMORY;
	_JumpIfError(hr, error, "LocalAlloc");
    }

    for (i = 0; i < caio.cAccDescr; i++)
    {
	caio.rgAccDescr[i].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
	caio.rgAccDescr[i].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
	caio.rgAccDescr[i].AccessLocation.pwszURL = papwszURL[i];

	DBGPRINT((DBG_SS_CERTLIB, "AIA[%u] = '%ws'\n", i, papwszURL[i]));
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbEncoded,
		    pcbEncoded))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }

error:
    if (NULL != caio.rgAccDescr)
    {
	LocalFree(caio.rgAccDescr);
    }
    if (NULL != papwszURL)
    {
        for (i = 0; i < caio.cAccDescr; i++)
        {
            if (NULL != papwszURL[i])
            {
                LocalFree(papwszURL[i]);
            }
        }
        LocalFree(papwszURL);
    }
    if (NULL != pwszzAIA)
    {
	LocalFree(pwszzAIA);
    }
    return(hr);
}


HRESULT
FillRDN(
    IN char const *pszObjId,
    IN WCHAR const *pwszRDN,
    IN OUT CERT_RDN *prgRDN)
{
    HRESULT hr;
    CERT_RDN_ATTR *prgAttr = NULL;

    prgAttr = (CERT_RDN_ATTR *) LocalAlloc(LMEM_FIXED, sizeof(*prgAttr));
    if (NULL == prgAttr)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    prgAttr->pszObjId = const_cast<char *>(pszObjId);
    prgAttr->dwValueType = 0;
    prgAttr->Value.pbData = (BYTE *) pwszRDN;
    prgAttr->Value.cbData = 0;

    prgRDN->cRDNAttr = 1;
    prgRDN->rgRDNAttr = prgAttr;

    hr = S_OK;

error:
    return(hr);
}


VOID
csiFreeCertNameInfo(
    CERT_NAME_INFO *pNameInfo)
{
    DWORD iRDN;

    if (NULL != pNameInfo)
    {
        if (NULL != pNameInfo->rgRDN)
        {
            for (iRDN = 0; iRDN < pNameInfo->cRDN; ++iRDN)
            {
                if (NULL != pNameInfo->rgRDN[iRDN].rgRDNAttr)
                {
                    LocalFree(pNameInfo->rgRDN[iRDN].rgRDNAttr);
                }
            }
            LocalFree(pNameInfo->rgRDN);
        }
        LocalFree(pNameInfo);
    }
}





HRESULT
FillExtension(
   IN OUT CERT_EXTENSION  *pDesExt,
   IN OUT DWORD           *pdwIndex,
   IN     CERT_EXTENSION  *pSrcExt)
{
   CSASSERT(NULL != pDesExt && NULL != pSrcExt);

   if (NULL != pSrcExt->Value.pbData && 0 != pSrcExt->Value.cbData)
   {
        pDesExt[*pdwIndex].pszObjId = pSrcExt->pszObjId;
        pDesExt[*pdwIndex].fCritical = pSrcExt->fCritical;
        pDesExt[*pdwIndex].Value = pSrcExt->Value;
        ++(*pdwIndex);
   }
   return(S_OK);
}


HRESULT
EncodeCertAndSign(
    IN HCRYPTPROV hProv,
    IN CERT_INFO *pCert,
    IN char const *pszAlgId,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    
    *ppbSigned = NULL;
    if (!myEncodeToBeSigned(
		    X509_ASN_ENCODING,
		    pCert,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
        hr = myHLastError();
        CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_ENCODETOBESIGNED,
		    hr,
		    NULL);
	_JumpError(hr, error, "myEncodeToBeSigned");
    }

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszAlgId,
			pbEncoded,
			cbEncoded,
			CERTLIB_USE_LOCALALLOC,
			ppbSigned,
			pcbSigned);
    _JumpIfError(hr, error, "myEncodeSignedContent");

error:
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    return(hr);
}


HRESULT
EncodeCACert(
    IN CASERVERSETUPINFO const *pSetupInfo,
    IN HCRYPTPROV hProv,
    IN const WCHAR *pwszCAType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    HRESULT hr = E_FAIL;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded = 0;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded = 0;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;

    CERT_EXTENSIONS     *pStdExts = NULL;
    CERT_EXTENSION      *pAllExts = NULL;
    CERT_EXTENSION      extKeyUsage = 
                        {szOID_KEY_USAGE,                 FALSE, 0, NULL};
    CERT_EXTENSION      extBasicConstraints = 
                        {NULL,        			  FALSE, 0, NULL};
    CERT_EXTENSION      extAKI = 
                        {szOID_AUTHORITY_KEY_IDENTIFIER2, FALSE, 0, NULL};
    CERT_EXTENSION      extSKI = 
                        {szOID_SUBJECT_KEY_IDENTIFIER,    FALSE, 0, NULL};
    CERT_EXTENSION      extCDP = 
                        {szOID_CRL_DIST_POINTS,           FALSE, 0, NULL};
    CERT_EXTENSION      extCCDP = 
			{szOID_CROSS_CERT_DIST_POINTS,    FALSE, 0, NULL};
    CERT_EXTENSION      extVersion = 
                        {szOID_CERTSRV_CA_VERSION,        FALSE, 0, NULL};
    CERT_EXTENSION      extPolicy = 
                        {szOID_CERT_POLICIES,		  FALSE, 0, NULL};
    CERT_EXTENSION      extAIA = 
                        {szOID_AUTHORITY_INFO_ACCESS,     FALSE, 0, NULL};
    CERT_EXTENSION      extEKU = 
                        {NULL,				  FALSE, 0, NULL};
#ifdef USE_NETSCAPE_TYPE_EXTENSION
    CERT_EXTENSION      extNetscape = 
                        {szOID_NETSCAPE_CERT_TYPE,        FALSE, 0, NULL};
#endif
    DWORD               cExtension;
    HCERTTYPE           hCertType = NULL;
    DWORD               i;
    DWORD               j;

    GUID guidSerialNumber;
    CERT_INFO Cert;

    *ppbEncoded = NULL;
    LPCWSTR pszErrorPtr;

    hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
    _PrintIfError2(
	    hr,
	    "myInfOpenFile",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (INVALID_HANDLE_VALUE != hInf)
    {
	BOOL fUTF8;
	
	hr = myInfGetBooleanValue(
			hInf,
			wszINFSECTION_CERTSERVER,
			wszINFKEY_UTF8,
			TRUE,
			&fUTF8);
	if (S_OK == hr)
	{
	    g_dwNameEncodeFlags = fUTF8? CERT_RDN_ENABLE_UTF8_UNICODE_FLAG : 0;
	}
    }

    // SUBJECT

    hr = AddCNAndEncode(
        pSetupInfo->pwszCACommonName,
        pSetupInfo->pwszDNSuffix,
        &pbSubjectEncoded,
        &cbSubjectEncoded);
    _JumpIfError(hr, error, "AddCNAndEncodeCertStrToName");

    // ISSUER

    hr = AddCNAndEncode(
        pSetupInfo->pwszCACommonName,
        pSetupInfo->pwszDNSuffix,
        &pbIssuerEncoded,
        &cbIssuerEncoded);
    _JumpIfError(hr, error, "AddCNAndEncodeCertStrToName");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    // get cert type
    hr = CAFindCertTypeByName(
			    pwszCAType, 
                            NULL, 
                            CT_FIND_LOCAL_SYSTEM |
				CT_ENUM_MACHINE_TYPES |
				CT_ENUM_USER_TYPES, 
                            &hCertType);
    if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
    {
	hr = CAFindCertTypeByName(
			    pwszCAType,
			    NULL,
                            CT_FIND_LOCAL_SYSTEM |
				CT_ENUM_MACHINE_TYPES |
				CT_ENUM_USER_TYPES |
				CT_FIND_BY_OID,
			    &hCertType);
    }
    if (S_OK == hr)
    {
        // get cert type standard extensions

        hr = CAGetCertTypeExtensions(hCertType, &pStdExts);
        _JumpIfErrorStr(hr, error, "CAGetCertTypeExtensions", pwszCAType);

        cExtension = pStdExts->cExtension;
    }
    else
    {
        cExtension = 0;
        DBGERRORPRINTLINE("CAFindCertTypeByName", hr);
    }

    if (NULL == pStdExts)
    {
        // standard extensions not available from CAGetCertTypeExtensions
        if (!CreateKeyUsageExtension(
			    myCASIGN_KEY_USAGE,
			    &extKeyUsage.Value.pbData,
			    &extKeyUsage.Value.cbData,
			    hInstance,
			    fUnattended,
			    hwnd))
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "CreateKeyUsageExtension");
        }
        ++cExtension;
    }

    hr = myInfGetBasicConstraints2CAExtensionOrDefault(hInf, &extBasicConstraints);
    _JumpIfError(hr, error, "myInfGetBasicConstraints2CAExtensionOrDefault");
    ++cExtension;

    // Subject Key Identifier extension:

    hr = myCreateSubjectKeyIdentifierExtension(
				    pPubKey,
				    &extSKI.Value.pbData,
				    &extSKI.Value.cbData);
    _JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");

    ++cExtension;

    hr = CreateRevocationExtension(
			    hInf,
			    pSetupInfo->pwszSanitizedName,
			    0,			// iCert
			    0,			// iCRL
			    pSetupInfo->fUseDS,
			    pSetupInfo->dwRevocationFlags,
			    &extCDP.fCritical,
			    &extCDP.Value.pbData,
			    &extCDP.Value.cbData);
    _PrintIfError(hr, "CreateRevocationExtension");
    CSASSERT((NULL == extCDP.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    hr = myInfGetCrossCertDistributionPointsExtension(hInf, &extCCDP);
    _PrintIfError(hr, "myInfGetCrossCertDistributionPointsExtension");
    CSASSERT((NULL == extCCDP.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    // Build the CA Version extension

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_INTEGER,
		&pSetupInfo->dwCertNameId,
		0,
		CERTLIB_USE_LOCALALLOC,
		&extVersion.Value.pbData,
		&extVersion.Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    ++cExtension;

    hr = myInfGetPolicyStatementExtension(hInf, &extPolicy);
    _PrintIfError(hr, "myInfCreatePolicyStatementExtension");
    CSASSERT((NULL == extPolicy.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    hr = CreateAuthorityInformationAccessExtension(
			    hInf,
			    pSetupInfo->pwszSanitizedName,
			    0,			// iCert
			    0,			// iCRL
			    pSetupInfo->fUseDS,
			    &extAIA.fCritical,
			    &extAIA.Value.pbData,
			    &extAIA.Value.cbData);
    _PrintIfError(hr, "CreateAuthorityInformationAccessExtension");
    CSASSERT((NULL == extAIA.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

    hr = myInfGetEnhancedKeyUsageExtension(hInf, &extEKU);
    _PrintIfError(hr, "myInfGetEnhancedKeyUsageExtension");
    CSASSERT((NULL == extEKU.Value.pbData) ^ (S_OK == hr));
    if (S_OK == hr)
    {
	++cExtension;
    }

#ifdef USE_NETSCAPE_TYPE_EXTENSION
    // Netscape Cert Type extension:
    if (!CreateNetscapeTypeExtension(
		    &extNetscape.Value.pbData,
		    &extNetscape.Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateNetscapeTypeExtension");
    }
    ++cExtension;
#endif


    // put all extensions together

    pAllExts = (CERT_EXTENSION*)LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cExtension * sizeof(CERT_EXTENSION));
    if (NULL == pAllExts)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    i = 0;
    if (NULL != pStdExts)
    {
        for (j = 0 ; j < pStdExts->cExtension; j++)
        {
	    if (0 == strcmp(szOID_BASIC_CONSTRAINTS2, pStdExts->rgExtension[j].pszObjId))
	    {
		continue;
	    }
            pAllExts[i].pszObjId = pStdExts->rgExtension[j].pszObjId;
            pAllExts[i].fCritical = pStdExts->rgExtension[j].fCritical;
            pAllExts[i].Value = pStdExts->rgExtension[j].Value;
	    i++;
        }
    }

    FillExtension(pAllExts, &i, &extKeyUsage);
    FillExtension(pAllExts, &i, &extBasicConstraints);
    FillExtension(pAllExts, &i, &extAKI);
    FillExtension(pAllExts, &i, &extSKI);
    FillExtension(pAllExts, &i, &extCDP);
    FillExtension(pAllExts, &i, &extCCDP);
    FillExtension(pAllExts, &i, &extVersion);
    FillExtension(pAllExts, &i, &extPolicy);
    FillExtension(pAllExts, &i, &extAIA);
    FillExtension(pAllExts, &i, &extEKU);

#ifdef USE_NETSCAPE_TYPE_EXTENSION
    FillExtension(pAllExts, &i, &extKeyNetscape);
#endif
    CSASSERT(i <= cExtension);

    // CERT
    ZeroMemory(&Cert, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    myGenerateGuidSerialNumber(&guidSerialNumber);

    Cert.SerialNumber.pbData = (BYTE *) &guidSerialNumber;
    Cert.SerialNumber.cbData = sizeof(guidSerialNumber);
    Cert.SignatureAlgorithm.pszObjId = pSetupInfo->pszAlgId;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    GetSystemTimeAsFileTime(&Cert.NotBefore);
    myMakeExprDateTime(
		&Cert.NotBefore,
		-CCLOCKSKEWMINUTESDEFAULT,
		ENUM_PERIOD_MINUTES);
    if (0 < CompareFileTime(&Cert.NotBefore, &pSetupInfo->NotBefore))
    {
	Cert.NotBefore = pSetupInfo->NotBefore;
    }
    Cert.NotAfter = pSetupInfo->NotAfter;

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pPubKey;	// Structure assignment

    Cert.cExtension = i;
    Cert.rgExtension = pAllExts;

    hr = EncodeCertAndSign(
		    hProv,
		    &Cert,
		    pSetupInfo->pszAlgId,
		    ppbEncoded,
		    pcbEncoded,
		    hInstance,
		    fUnattended,
		    hwnd);
    _JumpIfError(hr, error, "EncodeCertAndSign");

error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    if (NULL != extKeyUsage.Value.pbData)
    {
        LocalFree(extKeyUsage.Value.pbData);
    }
    if (NULL != extBasicConstraints.Value.pbData)
    {
        LocalFree(extBasicConstraints.Value.pbData);
    }
    if (NULL != extAKI.Value.pbData)
    {
        LocalFree(extAKI.Value.pbData);
    }
    if (NULL != extSKI.Value.pbData)
    {
        LocalFree(extSKI.Value.pbData);
    }
    if (NULL != extCDP.Value.pbData)
    {
        LocalFree(extCDP.Value.pbData);
    }
    if (NULL != extCCDP.Value.pbData)
    {
        LocalFree(extCCDP.Value.pbData);
    }
    if (NULL != extVersion.Value.pbData)
    {
        LocalFree(extVersion.Value.pbData);
    }
    if (NULL != extPolicy.Value.pbData)
    {
        LocalFree(extPolicy.Value.pbData);
    }
    if (NULL != extAIA.Value.pbData)
    {
        LocalFree(extAIA.Value.pbData);
    }
    if (NULL != extEKU.Value.pbData)
    {
        LocalFree(extEKU.Value.pbData);
    }
#ifdef USE_NETSCAPE_TYPE_EXTENSION
    if (NULL != extKeyNetscape.Value.pbData)
    {
        LocalFree(extKeyNetscape.Value.pbData);
    }
#endif
    if (NULL != hCertType)
    {
        if (NULL != pStdExts)
        {
            CAFreeCertTypeExtensions(hCertType, pStdExts);
        }
        CACloseCertType(hCertType);
    }
    if (NULL != pAllExts)
    {
        LocalFree(pAllExts);
    }
    if (NULL != pbSubjectEncoded)
    {
        LocalFree(pbSubjectEncoded);
    }
    if (NULL != pbIssuerEncoded)
    {
        LocalFree(pbIssuerEncoded);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    CSILOG(hr, IDS_ILOG_BUILDCERT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiGetCRLPublicationParams(
    BOOL fBase,
    WCHAR** ppwszCRLPeriod,
    DWORD* pdwCRLCount)
{
    HRESULT hr;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;

    hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
    _JumpIfError2(
	    hr,
            error,
	    "myInfOpenFile",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));


    if (INVALID_HANDLE_VALUE != hInf)
    {
    hr = myinfGetCRLPublicationParams(
        hInf,
        fBase? wszINFKEY_CRLPERIODSTRING : wszINFKEY_CRLDELTAPERIODSTRING,
        fBase? wszINFKEY_CRLPERIODCOUNT : wszINFKEY_CRLDELTAPERIODCOUNT,
        ppwszCRLPeriod, 
        pdwCRLCount);
    _JumpIfError(hr, error, "myinfGetCRLPublicationParams");

    } 
error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    return hr;
}


HRESULT
csiBuildFileName(
    IN WCHAR const *pwszDirPath,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszExt,
    IN DWORD iCert,
    OUT WCHAR **ppwszOut,
    HINSTANCE hInstance,
    BOOL fUnattended,
    IN HWND hwnd)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszServerName = NULL;
    WCHAR wszIndex[cwcFILENAMESUFFIXMAX];	// L"(%u)"

    *ppwszOut = NULL;
    wszIndex[0] = L'\0';
    if (0 != iCert)
    {
	wsprintf(wszIndex, L"(%u)", iCert);
    }

    hr = myGetMachineDnsName(&pwszServerName);
    if (S_OK != hr)
    {
	CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_GETCOMPUTERNAME,
		    hr,
		    NULL);
	_JumpError(hr, error, "myGetMachineDnsName");
    }

    cwc = wcslen(pwszDirPath) + 
		    WSZARRAYSIZE(g_szSlash) + 
		    wcslen(pwszServerName) + 
		    WSZARRAYSIZE(L"_") + 
		    wcslen(pwszSanitizedName) + 
		    wcslen(wszIndex) + 
		    wcslen(pwszExt) +
		    1;	// NULL term

    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
	
    wcscpy(*ppwszOut, pwszDirPath);
    wcscat(*ppwszOut, g_szSlash);
    wcscat(*ppwszOut, pwszServerName);
    wcscat(*ppwszOut, L"_");
    wcscat(*ppwszOut, pwszSanitizedName);
    wcscat(*ppwszOut, wszIndex);
    wcscat(*ppwszOut, pwszExt);

    hr = S_OK;

error:
    if (NULL != pwszServerName)
    {
	LocalFree(pwszServerName);
    }
    return(hr);
}


HRESULT
csiBuildCACertFileName(
    IN HINSTANCE             hInstance,
    IN HWND                  hwnd,
    IN BOOL                  fUnattended,
    OPTIONAL IN WCHAR const *pwszSharedFolder,
    IN WCHAR const          *pwszSanitizedName,
    IN WCHAR const          *pwszExt,
    IN DWORD 	             iCert,
    OUT WCHAR              **ppwszCACertFile)
{
    HRESULT   hr;
    WCHAR *pwszCACertFile = NULL;
    WCHAR const *pwszDir = pwszSharedFolder;
    WCHAR *pwszDirAlloc = NULL;

    CSASSERT(NULL != ppwszCACertFile);
    *ppwszCACertFile = NULL;

    if (NULL == pwszDir)
    {
        // no shared folder, go system drive
        hr = myGetEnvString(&pwszDirAlloc, L"SystemDrive");
        _JumpIfError(hr, error, "myGetEnvString");

	pwszDir = pwszDirAlloc;
    }
    // build ca cert file name here
    hr = csiBuildFileName(
		pwszDir,
		pwszSanitizedName,
		pwszExt,
		iCert,
		&pwszCACertFile,
		hInstance,
		fUnattended,
		hwnd);
    _JumpIfError(hr, error, "csiBuildFileName");

    CSASSERT(NULL != pwszCACertFile);

    *ppwszCACertFile = pwszCACertFile;
    hr = S_OK;

error:
    if (NULL != pwszDirAlloc)
    {
        LocalFree(pwszDirAlloc);
    }
    return(hr);
}


HRESULT
csiBuildAndWriteCert(
    IN HCRYPTPROV hCryptProv,
    IN CASERVERSETUPINFO const *pServer,
    OPTIONAL IN WCHAR const *pwszFile,
    IN WCHAR const *pwszEnrollFile,
    OPTIONAL IN CERT_CONTEXT const *pCertContextFromStore,
    OPTIONAL OUT CERT_CONTEXT const **ppCertContextOut,
    IN WCHAR const *pwszCAType,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_CONTEXT const *pccCA = NULL;
    HRESULT hr;

    if (NULL != ppCertContextOut)
    {
	*ppCertContextOut = NULL;
    }
    if (NULL == pCertContextFromStore)
    {
        // create cert
        hr = EncodeCACert(
		    pServer,
		    hCryptProv, 
		    pwszCAType,
		    &pbEncoded,
		    &cbEncoded,
		    hInstance,
		    fUnattended,
		    hwnd);
        _JumpIfError(hr, error, "EncodeCACert");

        pccCA = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbEncoded,
					cbEncoded);
        if (NULL == pccCA)
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
        }
    }
    else
    {
	pccCA = CertDuplicateCertificateContext(pCertContextFromStore);
	if (NULL == pccCA)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDuplicateCertificateContext");
	}
    }

    if (NULL != pwszFile && !csiWriteDERToFile(
				    pwszFile,
				    pccCA->pbCertEncoded,
				    pccCA->cbCertEncoded,
				    hInstance,
				    fUnattended,
				    hwnd))
    {
	hr = myHLastError();
	_JumpError(hr, error, "csiWriteDERToFile");
    }

    if (!csiWriteDERToFile(
		pwszEnrollFile,
		pccCA->pbCertEncoded,
		pccCA->cbCertEncoded,
		hInstance,
		fUnattended,
		hwnd))
    {
	hr = myHLastError();
	_JumpError(hr, error, "csiWriteDERToFile(enroll)");
    }

    if (NULL != ppCertContextOut)
    {
	*ppCertContextOut = pccCA;
	pccCA = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pccCA)
    {
	if (!CertFreeCertificateContext(pccCA))
	{
	    HRESULT hr2;

	    hr2 = myHLastError();
	    _PrintError(hr2, "CertFreeCertificateContext");
	    CSASSERT(S_OK == hr2);
	}
    }

    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}


HRESULT
IsCACert(
    IN HINSTANCE           hInstance,
    IN BOOL                fUnattended,
    IN HWND                hwnd,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    BOOL fCA;
    CERT_EXTENSION *pExt;
    DWORD cb;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;

    fCA = FALSE;
    pExt = CertFindExtension(
			szOID_BASIC_CONSTRAINTS2,
			pCert->pCertInfo->cExtension,
			pCert->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_PrintError(hr, "CertFindExtension");
    }
    else
    {
	cb = sizeof(Constraints);
	if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_BASIC_CONSTRAINTS2,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    &Constraints,
			    &cb))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptDecodeObject");
	}
	else
	{
	    fCA = Constraints.fCA;
	    if (!fCA)
	    {
		hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
		_PrintError(hr, "fCA not set");
	    }
	}
    }
    if (!fCA)
    {
	CertMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_NOTCACERT,
		    S_OK,
		    MB_OK | MB_ICONERROR | CMB_NOERRFROMSYS,
		    NULL);
	_JumpError(hr, error, "not a CA cert");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ExtractCACertFromPKCS7(
    IN WCHAR const                   *pwszCommonName,
    IN BYTE const                    *pbPKCS7,
    IN DWORD                          cbPKCS7,
    OPTIONAL OUT CERT_CONTEXT const **ppccCA)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    HCERTSTORE hChainStore = NULL;
    CRYPT_DATA_BLOB chainBlob;
    CERT_RDN_ATTR rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE, };
    CERT_RDN rdn = { 1, &rdnAttr };
    CERT_CHAIN_PARA ChainPara;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    CERT_CHAIN_CONTEXT const *pLongestChainContext = NULL;
    
    *ppccCA = NULL;
    if (NULL == pbPKCS7 || 0 == cbPKCS7)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid input parameters");
    }
    
    chainBlob.pbData = const_cast<BYTE *>(pbPKCS7);
    chainBlob.cbData = cbPKCS7;
    hChainStore = CertOpenStore(
			    CERT_STORE_PROV_PKCS7,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    NULL,		// hProv
			    0,
			    (const void*) &chainBlob);
    if (NULL == hChainStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    
    rdnAttr.Value.pbData = (BYTE *) pwszCommonName;
    rdnAttr.Value.cbData = 0;
    
    // Find the longest chain in the passed PKCS7 with a leaf CA cert that
    // matches the passed common name
    
    while (TRUE)
    {
        pCert = CertFindCertificateInStore(
				hChainStore,
				X509_ASN_ENCODING,
				CERT_UNICODE_IS_RDN_ATTRS_FLAG |
				    CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG,
				CERT_FIND_SUBJECT_ATTR,
				&rdn,
				pCert);
        if (NULL == pCert)
        {
            if (NULL == pLongestChainContext)
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "can't find matched cert in chain");
            }
            break;	// most common case, done here
        }

	ZeroMemory(&ChainPara, sizeof(ChainPara));
	ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
	ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
	//ChainPara.RequestedUsage.Usage.cUsageIdentifier = 0;
	//ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;
    
        if (!CertGetCertificateChain(
				HCCE_LOCAL_MACHINE,
				pCert,
				NULL,
				hChainStore,
				&ChainPara,
				0,
				NULL,
				&pChainContext))
        {
            // couldn't get the chain
            
            if (NULL == pLongestChainContext)
            {
                // fail to find a chain
                hr = myHLastError();
                _JumpError(hr, error, "CertGetCertificateChain");
            }
            break;	// done with it
        }

        // we have assumed each chain context contains
        // only one simple chain, ie. pChainContext->cChain = 1
        CSASSERT(1 == pChainContext->cChain);
            
        if (NULL == pLongestChainContext ||
            pChainContext->rgpChain[0]->cElement >
		pLongestChainContext->rgpChain[0]->cElement)
        {
            if (NULL != pLongestChainContext)
            {
                CertFreeCertificateChain(pLongestChainContext);
            }
            
            // save pointer to this chain

            pLongestChainContext = pChainContext;
        }
        else
        {
            CertFreeCertificateChain(pChainContext);
        }
    }
    CSASSERT(NULL == pCert);
    if (NULL != pLongestChainContext &&
	0 < pLongestChainContext->rgpChain[0]->cElement)
    {
	*ppccCA = CertDuplicateCertificateContext(
	    pLongestChainContext->rgpChain[0]->rgpElement[0]->pCertContext);
	if (NULL == *ppccCA)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDuplicateCertificateContext");
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != pLongestChainContext)
    {
        CertFreeCertificateChain(pLongestChainContext);
    }
    if (hChainStore)
    {
        CertCloseStore(hChainStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    CSILOG(hr, IDS_ILOG_SAVECHAINANDKEYS, pwszCommonName, NULL, NULL);
    return(hr);
}


#define ENTERPRISECATEMPLATELIST \
    wszCERTTYPE_ADMIN, \
    wszCERTTYPE_SUBORDINATE_CA, \
    wszCERTTYPE_USER, \
    wszCERTTYPE_MACHINE, \
    wszCERTTYPE_WEBSERVER, \
    wszCERTTYPE_DC, \
    wszCERTTYPE_EFS, \
    wszCERTTYPE_EFS_RECOVERY

WCHAR *s_apwszCertTypeServer[] =
{
    ENTERPRISECATEMPLATELIST,
    NULL
};

WCHAR *s_apwszCertTypeAdvancedServer[] =
{
    ENTERPRISECATEMPLATELIST,
    wszCERTTYPE_DC_AUTH,
    wszCERTTYPE_DS_EMAIL_REPLICATION,
    NULL
};


HRESULT
CreateCDPAndAIAAndKRAEntry(
    IN WCHAR const *pwszSanitizedCAName,
    IN WCHAR const *pwszSanitizedDSName,
    IN WCHAR const *pwszServerName,
    IN DWORD iCert,
    IN DWORD iCRL,
    IN BOOL fRenew,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    IN PSECURITY_DESCRIPTOR pContainerSD)
{
    HRESULT hr;
    LDAP *pld = NULL;
    BSTR strConfigDN = NULL;
    BSTR strDomainDN = NULL;
    WCHAR *pwszCDPDN = NULL;
    WCHAR *pwszAIADN;
    WCHAR *pwszKRADN;
    WCHAR const *apwszIn[3];
    WCHAR *apwszOut[3];
    DWORD i;
    DWORD dwDisp;
    WCHAR *pwszError = NULL;

    ZeroMemory(apwszOut, sizeof(apwszOut));

    hr = myRobustLdapBind(&pld, FALSE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    hr = myGetAuthoritativeDomainDn(pld, &strDomainDN, &strConfigDN);
    if (S_OK != hr)
    {
	hr = myHError(hr);
        _JumpError(hr, error, "myGetAuthoritativeDomainDn");
    }

    DBGPRINT((DBG_SS_CERTLIBI, "DomainDN='%ws'\n", strDomainDN));
    DBGPRINT((DBG_SS_CERTLIBI, "ConfigDN='%ws'\n", strConfigDN));

    apwszIn[0] = g_wszCDPDNTemplate;
    apwszIn[1] = g_wszAIADNTemplate;
    apwszIn[2] = g_wszKRADNTemplate;

    // Format the CDP and AIA templates into real names

    hr = myFormatCertsrvStringArray(
		    FALSE,			// fURL
		    pwszServerName,		// pwszServerName_p1_2
		    pwszSanitizedCAName,	// pwszSanitizedName_p3_7
		    iCert,			// iCert_p4
		    strDomainDN,		// pwszDomainDN_p5
		    strConfigDN,		// pwszConfigDN_p6
		    iCRL,			// iCRL_p8
		    FALSE,			// fDeltaCRL_p9
		    FALSE,			// fDSAttrib_p10_11
		    ARRAYSIZE(apwszIn),		// cStrings
		    (LPCWSTR *) apwszIn,	// apwszStringsIn
		    apwszOut);			// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    pwszCDPDN = apwszOut[0];
    pwszAIADN = apwszOut[1];
    pwszKRADN = apwszOut[2];

    DBGPRINT((DBG_SS_CERTLIBI, "CDPDN='%ws'\n", pwszCDPDN));
    DBGPRINT((DBG_SS_CERTLIBI, "AIADN='%ws'\n", pwszAIADN));
    DBGPRINT((DBG_SS_CERTLIBI, "KRADN='%ws'\n", pwszKRADN));


    //+=====================================================================
    // Create the CDP container and object:

    hr = myLdapCreateContainer(
			pld,
			pwszCDPDN,
			TRUE,
			1,
			pContainerSD,
			&pwszError);
    _JumpIfError(hr, error, "myLdapCreateContainer");

    CSASSERT(NULL == pwszError);

    hr = myLdapCreateCDPObject(pld, pwszCDPDN, pSD, &dwDisp, &pwszError);
    _JumpIfErrorStr(hr, error, "myLdapCreateCDPObject", pwszCDPDN);

    CSASSERT(NULL == pwszError);


    //+=====================================================================
    // Create the container and AIA object:

    hr = myLdapCreateContainer(
			pld,
			pwszAIADN,
			TRUE,
			0,
			pContainerSD,
			&pwszError);
    _JumpIfError(hr, error, "myLdapCreateContainer");

    CSASSERT(NULL == pwszError);

    hr = myLdapCreateCAObject(
			pld,
			pwszAIADN,
			pbCert,
			cbCert,
			pSD,
			&dwDisp,
			&pwszError);
    _JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszAIADN);

    CSASSERT(NULL == pwszError);


    //+=====================================================================
    // Create the KRA container and object:

    hr = myLdapCreateContainer(
			pld,
			pwszKRADN,
			TRUE,
			0,
			pContainerSD,
			&pwszError);
    _JumpIfError(hr, error, "myLdapCreateContainer");

    CSASSERT(NULL == pwszError);

    hr = myLdapCreateUserObject(
			    pld,
			    pwszKRADN,
			    NULL,
			    0,
			    pSD,
			    LPC_KRAOBJECT,
			    &dwDisp,
			    &pwszError);
    //_JumpIfErrorStr(hr, error, "myLdapCreateUserObject", pwszKRADN);
    _PrintIfErrorStr(hr, "myLdapCreateUserObject", pwszKRADN);
    CSASSERT(S_OK == hr || NULL == pwszError);
    hr = S_OK;

error:
    CSILOG(hr, IDS_ILOG_CREATECDP, pwszCDPDN, pwszError, NULL);
    if (NULL != pwszError)
    {
        LocalFree(pwszError);
    }
    for (i = 0; i < ARRAYSIZE(apwszOut); i++)
    {
	if (NULL != apwszOut[i])
	{
	    LocalFree(apwszOut[i]);
	}
    }
    if (NULL != strConfigDN)
    {
        SysFreeString(strConfigDN);
    }
    if (NULL != strDomainDN)
    {
        SysFreeString(strDomainDN);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}


HRESULT
CreateEnterpriseAndRootEntry(
    IN WCHAR const *pwszSanitizedDSName,
    IN CERT_CONTEXT const *pccPublish,
    IN ENUM_CATYPES caType,
    IN PSECURITY_DESCRIPTOR pSD,
    IN PSECURITY_DESCRIPTOR pContainerSD)
{
    HRESULT hr;
    LDAP *pld = NULL;
    BSTR strConfig = NULL;
    BSTR strDomainDN = NULL;
    WCHAR *pwszRootDN = NULL;
    WCHAR *pwszEnterpriseDN = NULL;
    PSECURITY_DESCRIPTOR pNTAuthSD = NULL;
    DWORD cwc;
    DWORD dwDisp;
    WCHAR *pwszError = NULL;

    if (!IsEnterpriseCA(caType) && !IsRootCA(caType))
    {
        hr = S_OK;
	goto error;
    }

    hr = myRobustLdapBind(&pld, FALSE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    hr = myGetAuthoritativeDomainDn(pld, &strDomainDN, &strConfig);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "myGetAuthoritativeDomainDn");
    }

    cwc = WSZARRAYSIZE(L"CN=") +
	     wcslen(pwszSanitizedDSName) +
	     WSZARRAYSIZE(s_wszRootCAs) +
	     wcslen(strConfig);
    pwszRootDN = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (pwszRootDN == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszRootDN, L"CN=");
    wcscat(pwszRootDN, pwszSanitizedDSName);
    wcscat(pwszRootDN, s_wszRootCAs);
    wcscat(pwszRootDN, strConfig);
    CSASSERT(wcslen(pwszRootDN) == cwc);

    cwc = wcslen(s_wszEnterpriseCAs) + wcslen(strConfig) ;
    pwszEnterpriseDN = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (pwszEnterpriseDN == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszEnterpriseDN, s_wszEnterpriseCAs);
    wcscat(pwszEnterpriseDN, strConfig);
    CSASSERT(wcslen(pwszEnterpriseDN) == cwc);

    //+=====================================================================
    // Create the root trust CA container and entry (Root only):

    if (IsRootCA(caType))
    {
	DBGPRINT((DBG_SS_CERTLIBI, "Creating Services Containers: '%ws'\n", pwszRootDN));
	hr = myLdapCreateContainer(
			    pld,
			    pwszRootDN,
			    TRUE,
			    1,
			    pContainerSD,
			    &pwszError);
	_JumpIfError(hr, error, "myLdapCreateContainer");

	CSASSERT(NULL == pwszError);

	DBGPRINT((DBG_SS_CERTLIBI, "Creating DS Root Trust: '%ws'\n", pwszRootDN));
	hr = myLdapCreateCAObject(
			    pld,
			    pwszRootDN,
			    pccPublish->pbCertEncoded,
			    pccPublish->cbCertEncoded,
			    pSD,
			    &dwDisp,
			    &pwszError);
	_JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszRootDN);
    }

    //+=====================================================================
    // Create the NTAuth trust entry (Enterprise only):

    if (IsEnterpriseCA(caType))
    {
        DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "Creating DS Enterprise Trust: '%ws'\n",
	    pwszEnterpriseDN));

        hr = myGetSDFromTemplate(WSZ_DEFAULT_NTAUTH_SECURITY, NULL, &pNTAuthSD);
        _JumpIfError(hr, error, "myGetSDFromTemplate");

	hr = myLdapCreateCAObject(
			    pld,
			    pwszEnterpriseDN,
			    NULL,
			    0,
			    pNTAuthSD,
			    &dwDisp,
			    &pwszError);
	_JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszEnterpriseDN);

	hr = AddCertToAttribute(
			    pld,
			    pccPublish,
			    pwszEnterpriseDN,
			    wszDSCACERTATTRIBUTE,
			    &dwDisp,
			    &pwszError);
	_JumpIfErrorStr(hr, error, "AddCertToAttribute", pwszEnterpriseDN);

        CSILOG(S_OK, IDS_ILOG_CREATENTAUTHTRUST, pwszEnterpriseDN, NULL, NULL);
    }

error:
    CSILOG(hr, IDS_ILOG_CREATEROOTTRUST, pwszRootDN, pwszError, NULL);
    if (NULL != pwszError)
    {
        LocalFree(pwszError);
    }
    if (NULL != pwszEnterpriseDN)
    {
        LocalFree(pwszEnterpriseDN);
    }
    if (NULL != pwszRootDN)
    {
        LocalFree(pwszRootDN);
    }
    if (NULL != strConfig)
    {
        SysFreeString(strConfig);
    }
    if (NULL != strDomainDN)
    {
        SysFreeString(strDomainDN);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    if (NULL != pNTAuthSD)
    {
        LocalFree(pNTAuthSD);
    }
    return(hr);
}


#define wszCOLON	L":"

// Suppress FILE URLs if a DS is available, as LDAP access within the
// enterprise should suffice, and http: should work outside the enterprise.
// Certs with too many URLs don't always fit on smart cards.

#define wszCRLPATHDEFAULT \
		wszCERTENROLLSHAREPATH \
		L"\\" \
		wszFCSAPARM_SANITIZEDCANAME \
		wszFCSAPARM_CRLFILENAMESUFFIX \
		wszFCSAPARM_CRLDELTAFILENAMESUFFIX \
		L".crl"

CSURLTEMPLATE const s_aRevURL[] = {
    {
	CSURL_SERVERPUBLISH | CSURL_ADDSYSTEM32DIR,
	wszCRLPATHDEFAULT,
    },
    {
	CSURL_SERVERPUBLISH | CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszzLDAPRevocationURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP,
	const_cast<WCHAR *>(g_wszHTTPRevocationURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP | CSURL_NODS,
	const_cast<WCHAR *>(g_wszFILERevocationURLTemplate),
    },
#if 0
    {
	CSURL_SERVERPUBLISH | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszCDPDNTemplate),
    },
#endif
    { 0, NULL }
};


#define wszCACERTPATHDEFAULT \
		wszCERTENROLLSHAREPATH \
		L"\\" \
		wszFCSAPARM_SERVERDNSNAME \
		L"_" \
		wszFCSAPARM_SANITIZEDCANAME \
		wszFCSAPARM_CERTFILENAMESUFFIX \
		L".crt"

CSURLTEMPLATE const s_aCACertURL[] = {
    {
	CSURL_SERVERPUBLISH | CSURL_ADDSYSTEM32DIR,
	wszCACERTPATHDEFAULT,
    },
    {
	CSURL_SERVERPUBLISH | CSURL_ADDTOCERTCDP | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszzLDAPIssuerCertURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP,
	const_cast<WCHAR *>(g_wszHTTPIssuerCertURLTemplate),
    },
    {
	CSURL_ADDTOCERTCDP | CSURL_NODS,
	const_cast<WCHAR *>(g_wszFILEIssuerCertURLTemplate),
    },
#if 0
    {
	CSURL_SERVERPUBLISH | CSURL_DSONLY,
	const_cast<WCHAR *>(g_wszAIADNTemplate),
    },
#endif
    { 0, NULL }
};

#define CSURL_DSDEPENDENT (CSURL_SERVERPUBLISH | CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL)


HRESULT
GetPublicationURLTemplates(
    IN CSURLTEMPLATE const *aTemplate,
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *pwszz;
    DWORD cwc;
    CSURLTEMPLATE const *pTemplate;
    WCHAR awc[22];
    DWORD Flags;

    *ppwszz = NULL;
    cwc = 1;	// final trailing L'\0'

    for (pTemplate = aTemplate; NULL != pTemplate->pwszURL; pTemplate++)
    {
	Flags = ~CSURL_INITMASK & pTemplate->Flags;
	if ((!fUseDS && (CSURL_DSONLY & pTemplate->Flags)) ||
	    (fUseDS && (CSURL_NODS & pTemplate->Flags)))
	{
	    Flags &= ~CSURL_DSDEPENDENT;
	}
	cwc += wsprintf(awc, L"%u", Flags);
	cwc += WSZARRAYSIZE(wszCOLON);
	if (CSURL_ADDSYSTEM32DIR & pTemplate->Flags)
	{
	    cwc += wcslen(pwszSystem32);
	}
	cwc += wcslen(pTemplate->pwszURL);
	cwc += 1;	// trailing L'\0'
    }

    pwszz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppwszz = pwszz;

    for (pTemplate = aTemplate; NULL != pTemplate->pwszURL; pTemplate++)
    {
	Flags = ~CSURL_INITMASK & pTemplate->Flags;
	if ((!fUseDS && (CSURL_DSONLY & pTemplate->Flags)) ||
	    (fUseDS && (CSURL_NODS & pTemplate->Flags)))
	{
	    Flags &= ~CSURL_DSDEPENDENT;
	}
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "URL Template: %x %x:%ws\n",
	    Flags,
	    pTemplate->Flags,
	    pTemplate->pwszURL));

	wsprintf(pwszz, L"%u", Flags);
	wcscat(pwszz, wszCOLON);
	if (CSURL_ADDSYSTEM32DIR & pTemplate->Flags)
	{
	    wcscat(pwszz, pwszSystem32);
	}
	wcscat(pwszz, pTemplate->pwszURL);
	pwszz += wcslen(pwszz) + 1; // skip L'\0'
    }

    *pwszz = L'\0';
    CSASSERT(cwc == (DWORD) (pwszz - *ppwszz + 1));

#ifdef DBG_CERTSRV_DEBUG_PRINT
    {
	DWORD i = 0;
	WCHAR const *pwsz;
	
	for (pwsz = *ppwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"URL Template[%u]: %ws\n",
		i,
		pwsz));
	    i++;
	}
    }
#endif // DBG_CERTSRV_DEBUG_PRINT
    hr = S_OK;

error:
    return(hr);
}


HRESULT
csiGetCRLPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;

    hr = GetPublicationURLTemplates(s_aRevURL, fUseDS, pwszSystem32, ppwszz);
    _JumpIfError(hr, error, "GetPublicationURLTemplates");

error:
    return(hr);
}


HRESULT
csiGetCACertPublicationURLTemplates(
    IN BOOL fUseDS,
    IN WCHAR const *pwszSystem32,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;

    hr = GetPublicationURLTemplates(s_aCACertURL, fUseDS, pwszSystem32, ppwszz);
    _JumpIfError(hr, error, "GetPublicationURLTemplates");

error:
    return(hr);
}


HRESULT
csiSetupCAInDS(
    IN HWND                hwnd,
    IN WCHAR const        *pwszCAServer,
    IN WCHAR const        *pwszSanitizedCAName,
    IN WCHAR const        *pwszCADisplayName,
    IN WCHAR const        *pwszCADescription,
    IN ENUM_CATYPES        caType,
    IN DWORD               iCert,
    IN DWORD               iCRL,
    IN BOOL                fRenew,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT      hr;
    HCAINFO      hCAInfo = NULL;
    WCHAR       *pCAProp[2];
    WCHAR       *pCertSubjectString = NULL;
    
    WCHAR        wszNameBuffer[MAX_COMPUTER_DNS_NAME + 1];
    DWORD        cNameBuffer;
    WCHAR        wszDomainNameBuffer[MAX_PATH];
    DWORD        cDomainNameBuffer;
    DWORD        cbSid;
    BYTE         pSid[MAX_SID_LEN];
    SID_NAME_USE SidUse;
    WCHAR       *pwszStringSid = NULL;
    PSECURITY_DESCRIPTOR pContainerSD = NULL;
    PSECURITY_DESCRIPTOR pCDPSD = NULL;

    CERT_CONTEXT const *pCertForDS = NULL;
    WCHAR *pwszSanitizedDSName = NULL;

    hr = mySanitizedNameToDSName(pwszSanitizedCAName, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    // Get the SID of the local machine.
    cNameBuffer = ARRAYSIZE(wszNameBuffer);
    if (!GetComputerObjectName(NameSamCompatible, wszNameBuffer, &cNameBuffer))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetComputerObjectName");
    }
    DBGPRINT((DBG_SS_CERTLIB, "GetComputerObjectName: '%ws'\n", wszNameBuffer));

    cbSid = sizeof(pSid);
    cDomainNameBuffer = ARRAYSIZE(wszDomainNameBuffer);

    if (!LookupAccountName(NULL,
                          wszNameBuffer,
                          pSid,
                          &cbSid,
                          wszDomainNameBuffer,
                          &cDomainNameBuffer,
                          &SidUse))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "LookupAccountName", wszNameBuffer);
    }

    if (!myConvertSidToStringSid(pSid, &pwszStringSid))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myConvertSidToStringSid");
    }

    // get default DS CDP security descriptor
    hr = myGetSDFromTemplate(WSZ_DEFAULT_CDP_DS_SECURITY,
                             pwszStringSid,
                             &pCDPSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    // get default DS AIA security descriptor
    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY,
                             NULL,
                             &pContainerSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = CreateEnterpriseAndRootEntry(
				pwszSanitizedDSName,
				pCert,
				caType,
				pContainerSD, 
				pContainerSD);
    _JumpIfError(hr, error, "CreateEnterpriseAndRootEntry");


    hr = CreateCDPAndAIAAndKRAEntry(
			pwszSanitizedCAName,
			pwszSanitizedDSName,
			pwszCAServer,
			iCert,
			iCRL,
			fRenew,
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			pCDPSD,
			pContainerSD);
    _JumpIfError(hr, error, "CreateCDPAndAIAAndKRAEntry");


    // Add enterprise
    // service publish entry

    hr = CAFindByName(
		pwszSanitizedDSName,
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCAInfo);
    if (S_OK != hr || NULL == hCAInfo)
    {
        hCAInfo = NULL;
	fRenew = FALSE;		// recreate security settings, etc.

        hr = CACreateNewCA(pwszSanitizedDSName, NULL, NULL, &hCAInfo);
	_JumpIfError(hr, error, "CACreateNewCA");

        if (NULL == hCAInfo)
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "hCAInfo(NULL)");
        }
    }

    if (!fRenew)
    {
	pCAProp[0] = const_cast<WCHAR *>(pwszCAServer);
	pCAProp[1] = NULL;
	hr = CASetCAProperty(hCAInfo, CA_PROP_DNSNAME, pCAProp);
	_JumpIfError(hr, error, "CASetCAProperty(CA_PROP_DNSNAME)");

	pCAProp[0] = const_cast<WCHAR *>(pwszCADisplayName);
	pCAProp[1] = NULL;
	hr = CASetCAProperty(hCAInfo, CA_PROP_DISPLAY_NAME, pCAProp);
	_JumpIfError(hr, error, "CASetCAProperty(CA_PROP_DISPLAY_NAME)");

	if (NULL != pwszCADescription)
	{
	    pCAProp[0] = const_cast<WCHAR *>(pwszCADescription);
	    pCAProp[1] = NULL;
	    hr = CASetCAProperty(hCAInfo, CA_PROP_DESCRIPTION, pCAProp);
	    _JumpIfError(hr, error, "CASetCAProperty(CA_PROP_DESCRIPTION)");
	}

	hr = myCertNameToStr(
			X509_ASN_ENCODING,
			&pCert->pCertInfo->Subject,
			CERT_X500_NAME_STR | CERT_NAME_STR_NO_QUOTING_FLAG,
			&pCertSubjectString);
	_JumpIfError(hr, error, "myCertNameToStr");

	pCAProp[0] = pCertSubjectString;
	pCAProp[1] = NULL;
	hr = CASetCAProperty(hCAInfo, CA_PROP_CERT_DN, pCAProp);
	_JumpIfError(hr, error, "CASetCAProperty(CA_PROP_CERT_DN)");

	switch (caType)
	{
	    case ENUM_ENTERPRISE_ROOTCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_SUPPORTS_NT_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");

		break;

	    case ENUM_ENTERPRISE_SUBCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_SUPPORTS_NT_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");

		break;

	    case ENUM_STANDALONE_ROOTCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_NO_TEMPLATE_SUPPORT | CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");
		break;

	    case ENUM_STANDALONE_SUBCA:
		hr = CASetCAFlags(hCAInfo, CA_FLAG_NO_TEMPLATE_SUPPORT | CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION);
		_JumpIfError(hr, error, "CASetCAFlags");
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Invalid CA Type");
	}
	if (IsEnterpriseCA(caType))
	{
	    hr = CASetCAProperty(
			    hCAInfo,
			    CA_PROP_CERT_TYPES,
			    FIsAdvancedServer()?
				s_apwszCertTypeAdvancedServer :
				s_apwszCertTypeServer);
	    _JumpIfError(hr, error, "CASetCAProperty(CA_PROP_CERT_TYPES)");
	}
    }

    // create a new cert context without key prov info
    pCertForDS = CertCreateCertificateContext(X509_ASN_ENCODING,
                     pCert->pbCertEncoded,
                     pCert->cbCertEncoded);
    if (NULL == pCertForDS)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertCreateCertificateContext");
    }

    hr = CASetCACertificate(hCAInfo, pCertForDS);
    _JumpIfError(hr, error, "CASetCACertificate");

    if (!fRenew)
    {
	hr = CASetCASecurity(hCAInfo, pCDPSD);
	_JumpIfError(hr, error, "CASetCASecurity");
    }
    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");
    
error:
    if (NULL != pwszStringSid)
    {
        LocalFree(pwszStringSid);
    }
    if (NULL != pwszSanitizedDSName)
    {
        LocalFree(pwszSanitizedDSName);
    }
    if (NULL != pCertSubjectString)
    {
        LocalFree(pCertSubjectString);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    if (NULL != pCDPSD)
    {
        LocalFree(pCDPSD);
    }
    if (NULL != pContainerSD)
    {
        LocalFree(pContainerSD);
    }
    if (NULL != pCertForDS)
    {
        CertFreeCertificateContext(pCertForDS);
    }
    CSILOG(hr, IDS_ILOG_PUBLISHCA, NULL, NULL, NULL);
    return(hr);
}


BOOL
csiIsAnyDSCAAvailable(VOID)
{
    // this is an expensive call; cache result
    static BOOL    available = FALSE;           // static inits to FALSE
    static BOOL    fKnowAvailable = FALSE;      // static inits to FALSE

    HCAINFO hCAInfo = NULL;

    if (!fKnowAvailable)
    {
        HRESULT hr;
        
        fKnowAvailable = TRUE;

        hr = CAEnumFirstCA(
		    NULL,
		    CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		    &hCAInfo);
        _JumpIfError(hr, error, "CAEnumFirstCA");

        if (NULL == hCAInfo)
        {
            goto error;
        }
        available = TRUE;
    }

error:
    if (NULL != hCAInfo)
        CACloseCA(hCAInfo);

    return available;
}


HRESULT
csiSetKeyContainerSecurity(
    IN HCRYPTPROV hProv)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;

    hr = myGetSDFromTemplate(WSZ_DEFAULT_KEYCONTAINER_SECURITY, NULL, &pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    // apply the security descriptor to the key container
    if (!CryptSetProvParam(
			hProv,
			PP_KEYSET_SEC_DESCR,
			(BYTE *) pSD,
			(DWORD) DACL_SECURITY_INFORMATION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSetProvParam");
    }
    hr = S_OK;

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    CSILOG(hr, IDS_ILOG_SETKEYSECURITY, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiSetAdminOnlyFolderSecurity(
    IN LPCWSTR    szFolderPath,
    IN BOOL       fAllowEveryoneRead,
    IN BOOL       fUseDS)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;

    // choose which access we want to allow
    LPCWSTR pwszDescriptor;
    if (fUseDS)
        if (fAllowEveryoneRead)
            pwszDescriptor = WSZ_DEFAULT_SF_USEDS_EVERYONEREAD_SECURITY;
        else
            pwszDescriptor = WSZ_DEFAULT_SF_USEDS_SECURITY;
    else
        if (fAllowEveryoneRead)
            pwszDescriptor = WSZ_DEFAULT_SF_EVERYONEREAD_SECURITY;
        else
            pwszDescriptor = WSZ_DEFAULT_SF_SECURITY;

    hr = myGetSDFromTemplate(pwszDescriptor, NULL, &pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    if (!SetFileSecurity(
        szFolderPath,
        DACL_SECURITY_INFORMATION,
        pSD))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetFileSecurity");
    }

    hr = S_OK;

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    CSILOG(hr, IDS_ILOG_SETADMINONLYFOLDERSECURITY, szFolderPath, NULL, NULL);
    return(hr);
}


HRESULT
csiSaveCertAndKeys(
    IN CERT_CONTEXT const *pCert,
    IN HCERTSTORE hAdditionalStore,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN ENUM_CATYPES CAType)
{
    HRESULT hr;
    DWORD i;
    CERT_CHAIN_CONTEXT const *pCertChain = NULL;
    CERT_CHAIN_PARA CertChainPara;
    HCERTSTORE hNTAuthStore = NULL;

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pCert,
			    NULL,
			    hAdditionalStore,
			    &CertChainPara,
			    0,
			    NULL,
			    &pCertChain))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChain->cChain)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        _JumpError(hr, error, "pCertChain->cChain");
    }

    hr = mySaveChainAndKeys(
			pCertChain->rgpChain[0],
			wszMY_CERTSTORE,
			CERT_SYSTEM_STORE_LOCAL_MACHINE,
			pkpi,
			NULL);
    _JumpIfError(hr, error, "mySaveChainAndKeys");

    if(ENUM_ENTERPRISE_ROOTCA==CAType)
    {
        hNTAuthStore = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			    X509_ASN_ENCODING,
			    NULL,		// hProv
			    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
			    wszNTAUTH_CERTSTORE);
        if (NULL == hNTAuthStore)
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "CertOpenStore", wszNTAUTH_CERTSTORE);
        }

        if (!CertAddEncodedCertificateToStore(
		        hNTAuthStore ,
		        X509_ASN_ENCODING,
		        pCert->pbCertEncoded,
		        pCert->cbCertEncoded,
			    CERT_STORE_ADD_REPLACE_EXISTING,
		        NULL))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertAddEncodedCertificateToStore");
        }
    }

error:
    if (pCertChain != NULL)
    {
	CertFreeCertificateChain(pCertChain);
    }
    if (NULL != hNTAuthStore)
    {
        CertCloseStore(hNTAuthStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
AddCertBlobToStore(
    IN OUT HCERTSTORE hStore,
    IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;

    pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
    if (NULL == pCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    if (!CertAddCertificateContextToStore(
				    hStore,
				    pCert,
				    CERT_STORE_ADD_REPLACE_EXISTING,
				    NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
LoadMissingCertBlob(
    IN OUT HCERTSTORE hStore,
    IN BYTE const    *pb,
    IN DWORD          cb)
{
    HRESULT hr;
    BYTE *pbDecoded = NULL;
    DWORD cbDecoded;
    CERT_CONTEXT const *pCert = NULL;
    HCERTSTORE hStorePKCS7 = NULL;
    BOOL fTryPKCS7 = TRUE;

    if (myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    pb,
		    cb,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cbDecoded))
    {
	hr = AddCertBlobToStore(hStore, pb, cb);
	_JumpIfError(hr, error, "AddCertBlobToStore");

	fTryPKCS7 = FALSE;
    }
    else
    if (myDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
		    pb,
		    cb,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cbDecoded))
    {
	CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *pSeq;
	DWORD iCert;

	pSeq = (CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *) pbDecoded;

	if (0 == strcmp(szOID_NETSCAPE_CERT_SEQUENCE, pSeq->pszObjId))
	{
	    fTryPKCS7 = FALSE;
	    for (iCert = 0; iCert < pSeq->cValue; iCert++)
	    {
		hr = AddCertBlobToStore(
				    hStore,
				    pSeq->rgValue[iCert].pbData,
				    pSeq->rgValue[iCert].cbData);
		_JumpIfError(hr, error, "AddCertBlobToStore");
	    }
	}
    }
    if (fTryPKCS7)
    {
	CRYPT_DATA_BLOB blobPKCS7;

	blobPKCS7.pbData = const_cast<BYTE *>(pb);
	blobPKCS7.cbData = cb;

	hStorePKCS7 = CertOpenStore(
			    CERT_STORE_PROV_PKCS7,
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    NULL,		// hCryptProv
			    0,			// dwFlags
			    &blobPKCS7);
	if (NULL == hStorePKCS7)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	while (TRUE)
	{
	    pCert = CertEnumCertificatesInStore(hStorePKCS7, pCert);
	    if (NULL == pCert)
	    {
		break;
	    }
	    if (!CertAddCertificateContextToStore(
					    hStore,
					    pCert,
					    CERT_STORE_ADD_REPLACE_EXISTING,
					    NULL))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertAddCertificateContextToStore");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStorePKCS7)
    {
	CertCloseStore(hStorePKCS7, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
LoadMissingCert(
    IN HINSTANCE      hInstance,
    IN HWND           hwnd,
    IN OUT HCERTSTORE hStore,
    IN OPTIONAL WCHAR const *pwszMissingIssuer)
{
    HRESULT hr;
    WCHAR *pwszFile = NULL;
    BYTE *pb = NULL;
    DWORD cb;

    hr = myGetOpenFileNameEx(
		 hwnd,
		 hInstance,
		 IDS_CAHIER_INSTALL_MISIINGCERT_TITLE,
		 pwszMissingIssuer,
		 IDS_CAHIER_CERTFILE_FILTER,
		 0,		// no def ext
		 OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
		 NULL,	// no default file
		 &pwszFile);
    if (S_OK == hr && NULL == pwszFile)
    {
	hr = E_INVALIDARG;
    }
    _JumpIfError(hr, error, "myGetOpenFileName");

    hr = DecodeFileW(pwszFile, &pb, &cb, CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    hr = LoadMissingCertBlob(hStore, pb, cb);
    _JumpIfError(hr, error, "LoadMissingCertBlob");

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    if (NULL != pwszFile)
    {
	LocalFree(pwszFile);
    }
    return(hr);
}


HRESULT
InstallCAChain(
    IN HINSTANCE                   hInstance,
    IN BOOL                        fUnattended,
    IN HWND                        hwnd,
    IN PCCERT_CONTEXT              pCert,
    IN CRYPT_KEY_PROV_INFO const  *pKeyProvInfo,
    IN ENUM_CATYPES                CAType,
    OPTIONAL IN BYTE const       *pbChain,
    IN DWORD                      cbChain)
{
    HRESULT hr;
    WCHAR *pwszMissingIssuer = NULL;
    HCERTSTORE hTempMemoryStore = NULL;

    if (IsSubordinateCA(CAType))
    {
	hTempMemoryStore = CertOpenStore(
				    CERT_STORE_PROV_MEMORY,
				    X509_ASN_ENCODING,
				    NULL,
				    0,
				    NULL);
	if (NULL == hTempMemoryStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenSystemStore");
	}

	if (NULL != pbChain)
	{
	    hr = LoadMissingCertBlob(hTempMemoryStore, pbChain, cbChain);
	    _JumpIfError(hr, error, "LoadMissingCertBlob");
	}

	// see if CA chain can be built

	while (TRUE)
	{
	    if (NULL != pwszMissingIssuer)
	    {
		LocalFree(pwszMissingIssuer);
		pwszMissingIssuer = NULL;
	    }
	    hr = myVerifyCertContext(
				pCert,			// pCert
				0,			// dwFlags
				0,			// cUsageOids
				NULL,			// apszUsageOids
				HCCE_LOCAL_MACHINE,	// hChainEngine
				hTempMemoryStore,	// hAdditionalStore
				&pwszMissingIssuer);
	    if (S_OK != hr)
	    {
		if (NULL != pwszMissingIssuer)
		{
		    if (IDCANCEL == CertMessageBox(
					hInstance,
					fUnattended,
					hwnd,
					IDS_ERR_INCOMPLETECHAIN,
					hr,
					MB_OKCANCEL | MB_ICONWARNING,
					pwszMissingIssuer) ||
			fUnattended)
		    {
			_JumpError(hr, error, "cannot build CA chain");
		    }

		    hr = LoadMissingCert(
                     hInstance,
                     hwnd,
                     hTempMemoryStore,
                     pwszMissingIssuer);
		    _PrintIfError(hr, "LoadMissingCert");
		    continue;
		}
		else
		{
		    // recommend not continue

		    if (IDCANCEL == CertMessageBox(
					hInstance,
					fUnattended,
					hwnd,
					CERT_E_UNTRUSTEDROOT == hr?
					    IDS_ERR_UNTRUSTEDROOT :
					    IDS_ERR_INVALIDCHAIN,
					hr,
					MB_OKCANCEL | MB_ICONWARNING,
					NULL))
		    {
			_JumpError(hr, error, "cannot verify CA chain");
		    }
		    break;
		}
	    }
	    break;
	}
    }

    hr = csiSaveCertAndKeys(pCert, hTempMemoryStore, pKeyProvInfo, CAType);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE,
                        hr,
                        NULL);
	_JumpError(hr, error, "csiSaveCertAndKeys");
    }

error:
    if (NULL != pwszMissingIssuer)
    {
	LocalFree(pwszMissingIssuer);
    }
    if (NULL != hTempMemoryStore)
    {
	CertCloseStore(hTempMemoryStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
BuildCAChainFromCert(
    IN HINSTANCE                  hInstance,
    IN BOOL                       fUnattended,
    IN HWND                       hwnd,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN WCHAR const               *pwszCommonName,
    IN const ENUM_CATYPES         CAType,
    OPTIONAL IN BYTE const       *pbChain,
    IN DWORD                      cbChain,
    IN CERT_CONTEXT const        *pCert)
{
    HRESULT hr;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    WCHAR const *pwszCN;

    // make sure the cert file matches current ca name

    if (!myDecodeName(
                  X509_ASN_ENCODING,
                  X509_UNICODE_NAME,
                  pCert->pCertInfo->Subject.pbData,
                  pCert->pCertInfo->Subject.cbData,
                  CERTLIB_USE_LOCALALLOC,
                  &pNameInfo,
                  &cbNameInfo))
    {
        hr = myHLastError();
        CertErrorMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_MYDECODENAME,
                        hr,
                        NULL);
        _JumpError(hr, error, "myDecodeName");
    }

    hr = myGetCertNameProperty(pNameInfo, szOID_COMMON_NAME, &pwszCN);
    _PrintIfError(hr, "myGetCertNameProperty");

    if (S_OK == hr && 0 != lstrcmp(pwszCommonName, pwszCN))
    {
        hr = E_INVALIDARG;
    }
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_NOT_MATCH_NAME,
                        hr,
                        NULL);
        _JumpError(hr, error, "common name in cert not match");
    }

    hr = IsCACert(hInstance, fUnattended, hwnd, pCert);
    _JumpIfError(hr, error, "IsCACert");

    hr = InstallCAChain(
		    hInstance,
		    fUnattended,
		    hwnd,
		    pCert,
		    pKeyProvInfo,
		    CAType,
		    pbChain,
		    cbChain);
    _JumpIfError(hr, error, "InstallCAChain");

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    CSILOG(hr, IDS_ILOG_SAVECERTANDKEYS, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiFinishInstallationFromPKCS7(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszCACommonName,
    IN CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN ENUM_CATYPES  CAType,
    IN DWORD	     iCert,
    IN DWORD	     iCRL,
    IN BOOL          fUseDS,
    IN BOOL          fRenew,
    IN WCHAR const  *pwszServerName,
    IN BYTE const   *pbChainOrCert,
    IN DWORD         cbChainOrCert,
    OPTIONAL IN WCHAR const *pwszCACertFile)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    WCHAR *pwszWebCACertFile = NULL;
    WCHAR *pwszKeyContainer = NULL;
    WCHAR wszTemp[MAX_PATH];
    WCHAR wszBuffer[MAX_PATH];
    DWORD NameId;
    WCHAR *pwszRequestFile = NULL;

    hr = E_FAIL;
    if (!IsRootCA(CAType))	// skip PKCS7 code for known raw X509 root cert
    {
	hr = ExtractCACertFromPKCS7(
			    pwszCACommonName,
			    pbChainOrCert,
			    cbChainOrCert,
			    &pCert);
	_PrintIfError(hr, "ExtractCACertFromPKCS7");
    }

    if (NULL == pCert)
    {
	pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    pbChainOrCert,
				    cbChainOrCert);
	if (NULL == pCert)
	{
	    hr = myHLastError();
	    CertErrorMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_CERTCREATECERTIFICATECONTEXT,
			hr,
			NULL);
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
	pbChainOrCert = NULL;	// Don't need to process this cert any further
    }

    hr = myGetNameId(pCert, &NameId);
    _PrintIfError(hr, "myGetNameId");
    if (S_OK == hr && MAKECANAMEID(iCert, iCRL) != NameId)
    {
	// get request file name

	hr = csiGetCARequestFileName(
			    hInstance,
			    hwnd,
			    pwszSanitizedCAName,
			    iCert,
			    iCRL,
			    &pwszRequestFile);
	_PrintIfError(hr, "csiGetCARequestFileName");

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	CertErrorMessageBox(
		    hInstance,
		    fUnattended,
		    hwnd,
		    IDS_ERR_RENEWEDCERTCAVERSION,
		    hr,
		    pwszRequestFile);
	_JumpError(hr, error, "CA Version");
    }

    // build a chain and install it

    hr = BuildCAChainFromCert(
		    hInstance,
		    fUnattended,
		    hwnd,
		    pKeyProvInfo,
		    pwszCACommonName,
		    CAType,
		    pbChainOrCert,
		    cbChainOrCert,
		    pCert);
    _JumpIfError(hr, error, "BuildCAChainFromCert");

    if (fUseDS)
    {
        // save in ds
        hr = csiSetupCAInDS(
		    hwnd,
		    pwszServerName,
		    pwszSanitizedCAName,
		    pwszCACommonName,
		    NULL,		// pwszCADescription
		    CAType,
		    iCert,
		    iCRL,
		    fRenew,
		    pCert);
    	_JumpIfError(hr, error, "csiSetupCAInDS");
    }

    // store CA cert hash

    hr = mySetCARegHash(pwszSanitizedCAName, CSRH_CASIGCERT, iCert, pCert);
    _JumpIfError(hr, error, "mySetCARegHash");

    if (NULL != pwszCACertFile)
    {
	// write this CA cert into shared folder
	if (!DeleteFile(pwszCACertFile))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
	    {
		_JumpError(hr, error, "DeleteFile");
	    }
	}
	if (!csiWriteDERToFile(
			pwszCACertFile,
			(BYTE *) pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			hInstance,
			fUnattended,
			hwnd))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "csiWriteDERToFile");
	}
    }

    // write cert file for web pages

    if (0 == GetEnvironmentVariable(L"SystemRoot", wszTemp, MAX_PATH))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        CertErrorMessageBox(
		hInstance,
		fUnattended,
		hwnd,
		IDS_ERR_ENV_NOT_SET,
		hr,
		NULL);
        _JumpError(hr, error, "GetEnvironmentVariable");
    }

    if(ARRAYSIZE(wszBuffer)<wcslen(wszTemp)+wcslen(L"\\System32\\")+
       wcslen(wszCERTENROLLSHAREPATH)+1)
    {
        hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
        _JumpError(hr, error, "file name too long");
    }

    wcscpy(wszBuffer, wszTemp);
    wcscat(wszBuffer, L"\\System32\\" wszCERTENROLLSHAREPATH);

    hr = csiBuildFileName(
		wszBuffer,
		pwszSanitizedCAName,
		L".crt",
		iCert,
		&pwszWebCACertFile, 
		hInstance,
		fUnattended,
		NULL);
    _JumpIfError(hr, error, "csiBuildFileName");

    hr = EncodeToFileW(
		pwszWebCACertFile,
		pCert->pbCertEncoded,
		pCert->cbCertEncoded,
		DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_WRITEDERTOFILE,
			hr,
			pwszWebCACertFile);
        _JumpError(hr, error, "EncodeToFileW");
    }

    // Set the security on the ds/registry/files etc.

    if (!fRenew)
    {
	hr = myAllocIndexedName(
			pwszSanitizedCAName,
			iCRL,
			&pwszKeyContainer);
	_JumpIfError(hr, error, "myAllocIndexedName");

    hr = csiInitializeCertSrvSecurity(
            pwszSanitizedCAName,
            fUseDS, 
            fUseDS);    // set DS security if using DS
	_JumpIfError(hr, error, "csiInitializeCertSrvSecurity");
    }

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszKeyContainer)
    {
        LocalFree(pwszKeyContainer);
    }
    if (NULL != pwszWebCACertFile)
    {
        LocalFree(pwszWebCACertFile);
    }
    return(hr);
}


HRESULT
FormRequestHelpMessage(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN LONG          lRequestId,
    IN BSTR          bStrMsgFromServer,
    IN WCHAR const  *pwszParentConfig,
    OUT WCHAR      **ppwszHelpMsg)
{

#define wszHELPNEWLINE  L"\n"
#define wszCOMMASPACE   L", "

    HRESULT  hr;
    WCHAR    wszRequestIdValue[16];
    WCHAR   *pwszMsgConfigPrefix = NULL;
    WCHAR   *pwszMsgRequestIdPrefix = NULL;
    WCHAR   *pwszHelpMsg = NULL;
    DWORD cwc;

    *ppwszHelpMsg = NULL;

    // load some format strings in help msg
    hr = myLoadRCString(hInstance, IDS_MSG_PARENTCA_CONFIG, &pwszMsgConfigPrefix);
    _JumpIfError(hr, error, "myLoadRCString");

    hr = myLoadRCString(hInstance, IDS_MSG_REQUEST_ID, &pwszMsgRequestIdPrefix);
    _JumpIfError(hr, error, "myLoadRCString");

    swprintf(wszRequestIdValue, L"%ld", lRequestId);

    cwc = wcslen(pwszMsgConfigPrefix) +
	    wcslen(pwszParentConfig) +
	    WSZARRAYSIZE(wszCOMMASPACE) +
	    wcslen(pwszMsgRequestIdPrefix) +
	    wcslen(wszRequestIdValue) +
	    1;
    if (NULL != bStrMsgFromServer)
    {
	cwc += SysStringLen(bStrMsgFromServer) + WSZARRAYSIZE(wszHELPNEWLINE);
    }

    pwszHelpMsg = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszHelpMsg)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // form help message

    pwszHelpMsg[0] = L'\0';
    if (NULL != bStrMsgFromServer)
    {
        wcscpy(pwszHelpMsg, bStrMsgFromServer);
        wcscat(pwszHelpMsg, wszHELPNEWLINE);
    }
    wcscat(pwszHelpMsg, pwszMsgConfigPrefix);
    wcscat(pwszHelpMsg, pwszParentConfig);
    wcscat(pwszHelpMsg, wszCOMMASPACE);
    wcscat(pwszHelpMsg, pwszMsgRequestIdPrefix);
    wcscat(pwszHelpMsg, wszRequestIdValue);

    CSASSERT(wcslen(pwszHelpMsg) + 1 == cwc);

    *ppwszHelpMsg = pwszHelpMsg;
    pwszHelpMsg = NULL;
    hr = S_OK;

error:
    if (NULL != pwszMsgConfigPrefix)
    {
        LocalFree(pwszMsgConfigPrefix);
    }
    if (NULL != pwszMsgRequestIdPrefix)
    {
        LocalFree(pwszMsgRequestIdPrefix);
    }
    if (NULL != pwszHelpMsg)
    {
        LocalFree(pwszHelpMsg);
    }
    return(hr);
}


HRESULT
HandleSubmitOrRetrieveNotIssued(
    IN HWND          hwnd,
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszParentCAConfig,
    IN ICertRequest *pICertRequest,
    IN LONG          disposition,
    IN BSTR	     strDispositionMessage,
    IN BOOL          fRenew,
    IN LONG          requestId,
    IN HRESULT       hrSubmit,
    IN HRESULT       hrLastStatus,
    IN int           iMsgId)
{
    HRESULT    hr;
    WCHAR     *pwszHelpMsg = NULL;
    DWORD      dwStatusDisable;
    DWORD      dwStatusEnable;
    BOOL       fPopup = FALSE;

    CSASSERT(NULL != pICertRequest);

    // form custom message

    hr = FormRequestHelpMessage(
			 hInstance,
			 fUnattended,
			 hwnd,
			 requestId,
			 strDispositionMessage,
			 pwszParentCAConfig,
			 &pwszHelpMsg);
    _JumpIfError(hr, error, "FromRequestHelpMessage");


    // Assume suspended install, denied request:

    dwStatusEnable = SETUP_DENIED_FLAG | SETUP_REQUEST_FLAG;
    if (!fRenew)
    {
	dwStatusEnable |= SETUP_SUSPEND_FLAG;
    }

    // Assume the pending request is denied, don't use online parent any more

    dwStatusDisable = SETUP_ONLINE_FLAG;

    // now handle disposition

    switch (disposition)
    {
        case CR_DISP_UNDER_SUBMISSION:
	    // the online request is pending, not denied

	    dwStatusEnable &= ~SETUP_DENIED_FLAG;
	    dwStatusEnable |= SETUP_ONLINE_FLAG;

	    // online is still enabled

	    dwStatusDisable &= ~SETUP_ONLINE_FLAG;

            iMsgId = IDS_ERR_REQUEST_PENDING;
            break;

        case CR_DISP_DENIED:
            // request id is no good any more

            hr = myDeleteCertRegValue(
                                pwszSanitizedCAName,
                                NULL,
                                NULL,
                                wszREGREQUESTID);
            _PrintIfErrorStr(hr, "myDeleteCertRegValue", wszREGREQUESTID);

	    if (0 == iMsgId)
	    {
		iMsgId = IDS_ERR_REQUEST_DENIED;
	    }
            break;

        case CR_DISP_INCOMPLETE:
            iMsgId = IDS_ERR_REQUEST_INCOMPLETE;
            break;

        case CR_DISP_ERROR:
            iMsgId = IDS_ERR_REQUEST_ERROR;
            break;

        case CR_DISP_ISSUED_OUT_OF_BAND:

            // same as pending request, but not denied

            dwStatusEnable &= ~SETUP_DENIED_FLAG;

            iMsgId = IDS_ERR_REQUEST_OUTOFBAND;
            break;

        case CR_DISP_REVOKED:
            iMsgId = IDS_ERR_REQUEST_REVOKED;
            break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error");
    }

    if (0 != dwStatusDisable)
    {
        // fix status, unset

        hr = SetSetupStatus(pwszSanitizedCAName, dwStatusDisable, FALSE);
        _JumpIfError(hr, error, "SetSetupStatus");
    }
    if (0 != dwStatusEnable)
    {
        // fix status, set

        hr = SetSetupStatus(pwszSanitizedCAName, dwStatusEnable, TRUE);
        _JumpIfError(hr, error, "SetSetupStatus");
    }

    // pop up a warning for generic error
    CertWarningMessageBox(
                    hInstance,
                    fUnattended,
                    hwnd,
                    iMsgId,
                    hrLastStatus,
                    pwszHelpMsg);
    fPopup = TRUE;

    // use proper error code

    if (S_OK == hrSubmit)
    {
        // for any disposition, use not ready as error

        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }
    else
    {
        // use submit error

        hr = hrSubmit;
    }

    // note, never return S_OK

error:
    if (!fPopup)
    {
        // a generic one because we won't have any popup later
        CertWarningMessageBox(
                        hInstance,
                        fUnattended,
                        hwnd,
                        IDS_ERR_SUBMIT_REQUEST_FAIL,
                        hr,
                        L"");
    }
    if (NULL != pwszHelpMsg)
    {
        LocalFree(pwszHelpMsg);
    }
    CSILOG(hr, IDS_ILOG_RETRIEVECERT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiSubmitCARequest(
    IN HINSTANCE     hInstance,
    IN BOOL          fUnattended,
    IN HWND          hwnd,
    IN BOOL          fRenew,
    IN BOOL	     fRetrievePending,
    IN WCHAR const  *pwszSanitizedCAName,
    IN WCHAR const  *pwszParentCAMachine,
    IN WCHAR const  *pwszParentCAName,
    IN BYTE const   *pbRequest,
    IN DWORD         cbRequest,
    OUT BSTR        *pbStrChain)
{
    HRESULT             hr;
    HRESULT             hrSubmit;
    HRESULT             hrLastStatus;
    WCHAR              *pwszParentCAConfig = NULL;
    LONG                disposition = CR_DISP_INCOMPLETE;
    LONG                requestId = 0;
    int                 iMsgId;
    ICertRequest       *pICertRequest = NULL;
    BOOL                fCoInit = FALSE;
    BSTR                bstrConfig = NULL;
    BSTR                bstrRequest = NULL;
    BSTR		strDispositionMessage = NULL;

    // register parent ca config
    hr = mySetCertRegStrValue(
			 pwszSanitizedCAName,
			 NULL,
			 NULL,
			 wszREGPARENTCAMACHINE,
			 pwszParentCAMachine);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGPARENTCAMACHINE);

    hr = mySetCertRegStrValue(
			 pwszSanitizedCAName,
			 NULL,
			 NULL,
			 wszREGPARENTCANAME,
			 pwszParentCAName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGPARENTCANAME);
    
    if (fRetrievePending)
    {
	// get request id

	hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGREQUESTID,
			(DWORD *) &requestId);
	if (S_OK != hr)
	{
	    fRetrievePending = FALSE;
	    requestId = 0;
	}
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
		    CLSID_CCertRequest,
		    NULL,
		    CLSCTX_INPROC_SERVER,
		    IID_ICertRequest,
		    (VOID **) &pICertRequest);
    _JumpIfError(hr, error, "CoCreateInstance");

    // get config string

    hr = myFormConfigString(
			pwszParentCAMachine,
			pwszParentCAName,
			&pwszParentCAConfig);
    _JumpIfError(hr, error, "myFormConfigString");

    // to bstr

    bstrConfig = SysAllocString(pwszParentCAConfig);
    if (NULL == bstrConfig)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // request to bstr

    bstrRequest = SysAllocStringByteLen((CHAR *) pbRequest, cbRequest);
    if (NULL == bstrRequest)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    myDeleteCertRegValue(pwszSanitizedCAName, NULL, NULL, wszREGREQUESTID);

    {
        CWaitCursor cwait;

	if (fRetrievePending)
	{
	    // retrieve the request
	    hr = pICertRequest->RetrievePending(
					requestId,
					bstrConfig,
					&disposition);
	}
	else
	{
	    hr = pICertRequest->Submit(
				CR_IN_BINARY | CR_IN_PKCS10,
				bstrRequest,
				NULL,
				bstrConfig,
				&disposition);
	}
	hrSubmit = hr;
	hrLastStatus = hr;
    }

    hr = pICertRequest->GetDispositionMessage(&strDispositionMessage);
    _PrintIfError(hr, "pICertRequest->GetDispositionMessage");

    if (S_OK == hrSubmit)
    {
	hr = pICertRequest->GetLastStatus(&hrLastStatus);
	_PrintIfError(hr, "pICertRequest->GetLastStatus");
    }

    CSILOG(
	hrLastStatus,
	fRetrievePending? IDS_ILOG_RETRIEVEPENDING : IDS_ILOG_SUBMITREQUEST,
	bstrConfig,
	strDispositionMessage,
	(DWORD const *) &disposition);

    iMsgId = 0;
    if (S_OK != hrSubmit)
    {
        // default to a generic message

        iMsgId = fRetrievePending?
		    IDS_ERR_RETRIEVE_PENDING : IDS_ERR_SUBMIT_REQUEST_FAIL;

        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) == hrSubmit)
        {
            iMsgId = IDS_ERR_NOT_ENTERPRISE_USER;
        }

        // if failed, treat as denied

        disposition = CR_DISP_DENIED;
    }

    if (CR_DISP_ISSUED != disposition)
    {
	if (!fRetrievePending)
	{
	    pICertRequest->GetRequestId(&requestId);
	}
	hr = mySetCertRegDWValue(
			    pwszSanitizedCAName,
			    NULL,
			    NULL,
			    wszREGREQUESTID,
			    requestId);
	_JumpIfErrorStr(hr, error, "mySetCertRegDWValue", wszREGREQUESTID);

        hr = HandleSubmitOrRetrieveNotIssued(
				    hwnd,
				    hInstance,
				    fUnattended,
				    pwszSanitizedCAName,
				    pwszParentCAConfig,
				    pICertRequest,
				    disposition,
				    strDispositionMessage,
				    fRenew,
				    requestId,
				    hrSubmit,
				    hrLastStatus,
				    iMsgId);

	// not issued, always exit with error

        _JumpError(hr, error, "Cert is not issued");
    }

    // get pkcs7 chain

    hr = pICertRequest->GetCertificate(
			    CR_OUT_CHAIN | CR_OUT_BINARY,
			    pbStrChain);
    _JumpIfError(hr, error, "pICertRequest->GetCertificate");

error:
    if (NULL != strDispositionMessage)
    {
        SysFreeString(strDispositionMessage);
    }
    if (NULL != pwszParentCAConfig)
    {
        LocalFree(pwszParentCAConfig);
    }
    if (NULL != bstrConfig)
    {
        SysFreeString(bstrConfig);
    }
    if (NULL != bstrRequest)
    {
        SysFreeString(bstrRequest);
    }
    if (NULL != pICertRequest)
    {
        pICertRequest->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    CSILOG(
	hr,
	fRetrievePending? IDS_ILOG_RETRIEVEPENDING : IDS_ILOG_SUBMITREQUEST,
	pwszParentCAMachine,
	pwszParentCAName,
	(DWORD const *) &disposition);
    return(hr);
}


HRESULT
csiInitializeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    BOOL            fUseEnterpriseACL, // which ACL to use
    BOOL            fSetDsSecurity)    // whether to set security on DS object
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD   cbLength;
    CCertificateAuthoritySD CASD;

    hr = CASD.InitializeFromTemplate(
            fUseEnterpriseACL?
            WSZ_DEFAULT_CA_ENT_SECURITY :
            WSZ_DEFAULT_CA_STD_SECURITY,
            pwszSanitizedCAName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::InitializeFromTemplate");

    hr = CASD.Save();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");

    hr = CASD.MapAndSetDaclOnObjects(fSetDsSecurity?true:false);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::MapAndSetDaclOnObjects");

error:
    if (pSD)
    {
        LocalFree(pSD);
    }
    CSILOG(hr, IDS_ILOG_SETSECURITY, NULL, NULL, NULL);
    return(hr);
}


HRESULT
csiGenerateKeysOnly(
    IN  WCHAR const   *pwszContainer,
    IN  WCHAR const   *pwszProvName,
    IN  DWORD          dwProvType,
    IN  BOOL           fMachineKeyset,
    IN  DWORD          dwKeyLength,
    IN  BOOL           fUnattended,
    OUT HCRYPTPROV    *phProv,
    OUT int           *piMsg)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;
    DWORD dwKeyGenFlags;
    DWORD dwAcquireFlags;
    BOOL fExists;

    *phProv = NULL;
    *piMsg = 0;

    // see if the container already exists

    dwAcquireFlags = 0;
    if (fMachineKeyset)
    {
	dwAcquireFlags |= CRYPT_MACHINE_KEYSET;
    }
    if (fUnattended)
    {
	dwAcquireFlags |= CRYPT_SILENT;
    }
    fExists = CryptAcquireContext(
			    phProv,
			    pwszContainer,
			    pwszProvName,
			    dwProvType,
			    CRYPT_SILENT | dwAcquireFlags);
    if (NULL != *phProv)
    {
        CryptReleaseContext(*phProv, 0);
        *phProv = NULL;
    }
    if (fExists)
    {
        // container exists, but we did not choose to reuse keys,
        // so remove old keys and generate new ones.

        if (!CryptAcquireContext(
			    phProv,
			    pwszContainer,
			    pwszProvName,
			    dwProvType,
			    CRYPT_DELETEKEYSET | dwAcquireFlags))
        {
            hr = myHLastError();
            *piMsg = IDS_ERR_DELETEKEY;
            _JumpError(hr, error, "CryptAcquireContext");
        }
    }

    // create new container

    if (!CryptAcquireContext(
		    phProv,
		    pwszContainer,
		    pwszProvName,
		    dwProvType,
		    CRYPT_NEWKEYSET | dwAcquireFlags)) // force new container
    {
        hr = myHLastError();

        if (NTE_TOKEN_KEYSET_STORAGE_FULL == hr)
        {
            // Smart cards can only hold a limited number of keys
            // The user must pick an existing key or use a blank card

            *piMsg = IDS_ERR_FULL_TOKEN;
            _JumpError(hr, error, "CryptAcquireContext");
        }
        else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
        {
            // user must have clicked cancel on a smart card dialog.
            // go to previous page, and display no error message

            _JumpError(hr, error, "CryptAcquireContext");
        }
        else if (NTE_EXISTS == hr)
        {
            // since fExists shows NOT, it is likely the current user
            // doesn't have access permission for this existing key
            *piMsg = IDS_ERR_NO_KEY_ACCESS;
            _JumpError(hr, error, "CryptAcquireContext");
        }
        else
        {
            // Unexpected error in CryptAcquireContext.
            *piMsg = IDS_ERR_BADCSP;
            _JumpError(hr, error, "CryptAcquireContext");
        }
    }
 
    // set key length

    dwKeyGenFlags = (dwKeyLength << 16) | CRYPT_EXPORTABLE;

    // create signature keys 

    if (!CryptGenKey(*phProv, AT_SIGNATURE, dwKeyGenFlags, &hKey))
    {
        hr = myHLastError();
        *piMsg = IDS_ERR_GENKEYFAIL;
        _JumpError(hr, error, "CryptGenKey");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    CSILOG(hr, IDS_ILOG_GENERATEKEYS, pwszContainer, pwszProvName, &dwKeyLength);
    return(hr);
}


HRESULT
csiGenerateCAKeys(
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvName,
    IN DWORD        dwProvType,
    IN BOOL         fMachineKeyset,
    IN DWORD        dwKeyLength,
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND         hwnd,
    OUT BOOL       *pfKeyGenFailed)
{
    HRESULT    hr;
    HCRYPTPROV hProv = NULL;
    int        iMsg;

    // generate key first
    hr = csiGenerateKeysOnly(
		    pwszContainer,
		    pwszProvName,
		    dwProvType,
		    fMachineKeyset,
		    dwKeyLength,
		    fUnattended,
		    &hProv,
		    &iMsg);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			iMsg,
			hr,
			pwszContainer);
        *pfKeyGenFailed = TRUE;
        _JumpError(hr, error, "csiGenerateKeysOnly");
    }
    *pfKeyGenFailed = FALSE;

    // now apply acl on key
    // BUG, this is not necessary, CertSrvSetSecurity will reset
    hr = csiSetKeyContainerSecurity(hProv);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
			hInstance,
			fUnattended,
			hwnd,
			IDS_ERR_KEYSECURITY,
			hr,
			pwszContainer);
        _PrintError(hr, "csiSetKeyContainerSecurity");
    }
    hr = S_OK;

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
csiGetProviderTypeFromProviderName(
    IN WCHAR const *pwszName,
    OUT DWORD      *pdwType)
{
    HRESULT  hr;
    DWORD i;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;

    // Provider name should not be null.  This could be changed to ...
    CSASSERT(NULL != pwszName); 

    *pdwType = 0;
    dwProvType = 0;

    for (i = 0; ; i++)
    {
	// get provider name

	hr = myEnumProviders(i, NULL, 0, &dwProvType, &pwszProvName);
	if (S_OK != hr)
	{
	    hr = myHLastError();
	    CSASSERT(
		HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr);

	    if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr)
	    {
		// no more providers, terminate loop

		hr = E_INVALIDARG;
		CSILOG(
		    hr,
		    IDS_ILOG_MISSING_PROVIDER,
		    pwszName,
		    NULL,
		    NULL);
		_JumpErrorStr(hr, error, "not found", pwszName);
            }
	}
	else
	{
	    CSASSERT(NULL != pwszProvName);
	    if (0 == lstrcmpi(pwszName, pwszProvName))
	    {
		break;	// found it
	    }
	    LocalFree(pwszProvName);
	    pwszProvName = NULL;
	}
    }
    *pdwType = dwProvType;
    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    return(hr);
}

HRESULT
csiUpgradeCertSrvSecurity(
    IN WCHAR const *pwszSanitizedCAName, 
    BOOL            fUseEnterpriseACL, // which ACL to use
    BOOL            fSetDsSecurity,    // whether to set security on DS object
    CS_ENUM_UPGRADE UpgradeType) 
{
    HRESULT hr = S_OK;
    CertSrv::CCertificateAuthoritySD CASD;
    PSECURITY_DESCRIPTOR pDefaultSD = NULL;

    hr = CASD.Initialize(pwszSanitizedCAName);
    _PrintIfError(hr, "CASD.Initialize");
    if(S_OK==hr)
    {
        if(CS_UPGRADE_WHISTLER==UpgradeType)
        {
            // validate the SD
            hr = CASD.Validate(CASD.Get());
            _PrintIfError(hr, "CASD.Validate");
        }
        else // win2k
        {
            hr = CASD.UpgradeWin2k(fUseEnterpriseACL?true:false);
            _PrintIfError(hr, "CASD.UpgradeWin2k");
        }
    }

    // never fail, fall back to a default SD

    if(S_OK!=hr)
    {
        CASD.Uninitialize();

        hr = CASD.InitializeFromTemplate(
                    fUseEnterpriseACL?
                    WSZ_DEFAULT_CA_ENT_SECURITY :
                    WSZ_DEFAULT_CA_STD_SECURITY,
                    pwszSanitizedCAName);
        _JumpIfError(hr, error, 
                "CProtectedSecurityDescriptor::InitializeFromTemplate");
    }

    hr = CASD.Save();
    _JumpIfError(hr, error, "CASD.Save");

    hr = CASD.MapAndSetDaclOnObjects(fSetDsSecurity? true:false);
    _PrintIfError(hr, "CASD::MapAndSetDaclOnObjects");

    if ((hr != S_OK) && fSetDsSecurity && (UpgradeType != CS_UPGRADE_NO))
    {
        // if asked to set security on DS and this is UPGRADE, we can't touch DS. 
        // Leave security changes to the certsrv snapin 

        // set a flag so certmmc knows to do something
        hr = SetSetupStatus(pwszSanitizedCAName, SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG, TRUE);
        _JumpIfError(hr, error, "SetSetupStatus");      

        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        _PrintError(hr, "DS unavailable");
    }
    else
    {
        // make sure this bit is cleared
        hr = SetSetupStatus(pwszSanitizedCAName, SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG, FALSE);
        _JumpIfError(hr, error, "SetSetupStatus");      
    }

error:
    LOCAL_FREE(pDefaultSD);
    return hr;
}

DefineAutoClass(CAutoPCERT_NAME_INFO, PCERT_NAME_INFO, LocalFree);
DefineAutoClass(CAutoPCERT_RDN, PCERT_RDN, LocalFree);

HRESULT AddCNAndEncode(
    LPCWSTR pcwszName,
    LPCWSTR pcwszDNSuffix,
    BYTE** ppbEncodedDN,
    DWORD *pcbEncodedDN)
{
    HRESULT hr;
    CAutoPBYTE pbDNSuffix;
    DWORD cbDNSuffix;
    CAutoPCERT_NAME_INFO pCertNameInfo;
    DWORD cbCertNameInfo;
    CAutoPCERT_RDN pCertRDN;
    CERT_RDN_ATTR attrDN;
    CAutoPBYTE pbEncodedDN;
    DWORD cbEncodedDN;

    attrDN.pszObjId = szOID_COMMON_NAME;
    attrDN.dwValueType = CERT_RDN_ANY_TYPE;
    attrDN.Value.cbData = 0;
    attrDN.Value.pbData = (PBYTE)pcwszName;

    hr = myCertStrToName(
        X509_ASN_ENCODING,
        pcwszDNSuffix,
        CERT_X500_NAME_STR | 
        CERT_NAME_STR_COMMA_FLAG | 
        CERT_NAME_STR_REVERSE_FLAG |
        ((g_dwNameEncodeFlags&CERT_RDN_ENABLE_UTF8_UNICODE_FLAG)?
        CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG:0), 
        NULL,
        &pbEncodedDN,
        &cbEncodedDN,
        NULL);
    _JumpIfError(hr, error, "myCertStrToName");

    if (!myDecodeName(
            X509_ASN_ENCODING,
            X509_UNICODE_NAME,
            pbEncodedDN,
            cbEncodedDN,
            CERTLIB_USE_LOCALALLOC,
            &pCertNameInfo,
            &cbCertNameInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myDecodeName");
    }

    pCertRDN = (PCERT_RDN)LocalAlloc(
        LMEM_FIXED, 
        (pCertNameInfo->cRDN+1)*sizeof(CERT_RDN));
    _JumpIfAllocFailed(pCertRDN, error);

    CopyMemory(
        pCertRDN, 
        pCertNameInfo->rgRDN, 
        pCertNameInfo->cRDN*sizeof(CERT_RDN));

    pCertRDN[pCertNameInfo->cRDN].cRDNAttr = 1;
    pCertRDN[pCertNameInfo->cRDN].rgRDNAttr = &attrDN;

    pCertNameInfo->cRDN++;
    pCertNameInfo->rgRDN = pCertRDN;

    if (!myEncodeName(
		X509_ASN_ENCODING,
		pCertNameInfo,
		g_dwNameEncodeFlags,
		CERTLIB_USE_LOCALALLOC,
		ppbEncodedDN,
		pcbEncodedDN))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myEncodeName");
    }

error:
    return hr;
}


/*
 * Add/remove computer account to the Cert Publishers group for the forest
 */

HRESULT
AddOrRemoveCAMachineToCertPublishers(bool fAdd)
{
    HRESULT hr = S_OK;
    LPWSTR pwszComputerDN = NULL;
    LDAP *pld = NULL;
    LPWSTR pcwszComputerDomainDN; // no free
    LPWSTR pcwszCertPublishersFilter = 
        L"(&(objectClass=group)(CN=Cert Publishers))";
    LDAPMessage* pResult = NULL;
    LDAPMessage *pEntry;
    LPWSTR pwszAttrArray[2];
    BerElement *pber;
    LPWSTR pwszDNAttr = L"distinguishedName";
    LPWSTR pwszMemberAttr = L"member";
    LPWSTR* pwszCertPublishersDN = NULL;
    LDAPMod *mods[2];
    LDAPMod member;
    LPWSTR memberVals[2];
    
    hr = myGetComputerObjectName(
        NameFullyQualifiedDN,
        &pwszComputerDN);
    _JumpIfError(hr, error, "myGetComputerObjectName");

    pcwszComputerDomainDN = wcsstr(pwszComputerDN, L"DC=");
    pwszAttrArray[0] = pwszDNAttr;
    pwszAttrArray[1] = NULL;

    hr = myRobustLdapBind(
        &pld,
        FALSE); // no GC
    _JumpIfError(hr, error, "myRobustLdapBind");

    hr = ldap_search_s(
                    pld,
                    pcwszComputerDomainDN,
                    LDAP_SCOPE_SUBTREE,
                    pcwszCertPublishersFilter,
                    pwszAttrArray,
                    FALSE,
                    &pResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_sW");

    pEntry = ldap_first_entry(pld, pResult);
    if (NULL == pEntry)
    {
	hr = myHLdapLastError(pld, NULL);
        _JumpError(hr, error, "ldap_first_entry");
    }

    pwszCertPublishersDN = ldap_get_values(
                            pld,
                            pEntry,
                            pwszDNAttr);

    if (NULL == pwszCertPublishersDN || NULL==*pwszCertPublishersDN)
    {
	hr = myHLdapLastError(pld, NULL);
        _JumpError(hr, error, "ldap_get_values");
    }

    memberVals[0] = pwszComputerDN;
    memberVals[1] = NULL;
    member.mod_op = fAdd?LDAP_MOD_ADD:LDAP_MOD_DELETE;
    member.mod_type = pwszMemberAttr;
    member.mod_values = memberVals;
    mods[0] = &member;
    mods[1] = NULL;

    hr = ldap_modify_ext_s(
                    pld,
                    *pwszCertPublishersDN,
                    mods,
                    NULL,
                    NULL);
    // don't fail if already member of cert publishers
    if(((HRESULT)LDAP_ALREADY_EXISTS)==hr)
        hr = LDAP_SUCCESS;

    hr = myHLdapError(pld, hr, NULL);
    _JumpIfErrorStr(hr, error, "ldap_modify_exts", *pwszCertPublishersDN);

error:

    LOCAL_FREE(pwszComputerDN);

    if(pwszCertPublishersDN)
    {
        ldap_value_free(pwszCertPublishersDN);
    }

    if (NULL != pResult)
    {
        ldap_msgfree(pResult);
    }
    
    if (pld)
        ldap_unbind(pld);
    return hr;
}

HRESULT
AddCAMachineToCertPublishers(VOID)
{
    return AddOrRemoveCAMachineToCertPublishers(true);
}
                   
HRESULT 

RemoveCAMachineFromCertPublishers(VOID)
{
    return AddOrRemoveCAMachineToCertPublishers(false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\initlib\keyenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       keyenum.cpp
//
//--------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  File:       keyenum.cpp
// 
//  Contents:   key container and cert store operations
//
//  History:    08/97   xtan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "cscsp.h"
#include "csdisp.h"

#define __dwFILE__	__dwFILE_INITLIB_KEYENUM_CPP__


// Key Enumeration
// move point to top
KEY_LIST* 
topKeyList(KEY_LIST *pKeyList)
{
    while (pKeyList->last)
    {
        pKeyList = pKeyList->last;
    }
    return pKeyList;
}


// move point to end
KEY_LIST* 
endKeyList(KEY_LIST *pKeyList)
{
    while (pKeyList->next)
    {
        pKeyList = pKeyList->next;
    }
    return pKeyList;
}


// add to end
void 
addKeyList(KEY_LIST **ppKeyList, KEY_LIST *pKey)
{
    KEY_LIST *pKeyList = *ppKeyList;

    if (NULL == pKeyList)
    {
	*ppKeyList = pKey;
    }
    else
    {
	// go to end
	pKeyList = endKeyList(pKeyList);
	// add
	pKeyList->next = pKey;
	pKey->last = pKeyList;
    }
}


KEY_LIST *
newKey(
    CHAR    *pszName)
{
    HRESULT hr = S_OK;
    KEY_LIST *pKey = NULL;

    if (NULL != pszName)
    {
        pKey = (KEY_LIST *) LocalAlloc(LMEM_FIXED, sizeof(*pKey));
        if (NULL == pKey)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
	if (!myConvertSzToWsz(&pKey->pwszName, pszName, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz");
	}
	pKey->last = NULL;
	pKey->next = NULL;
    }

error:
    if (S_OK != hr)
    {
	if (NULL != pKey)
	{
	    LocalFree(pKey);
	    pKey = NULL;
	}
	SetLastError(hr);
    }
    return(pKey);
}


void 
freeKey(KEY_LIST *pKey)
{
    if (pKey)
    {
        if (pKey->pwszName)
        {
            LocalFree(pKey->pwszName);
        }
        LocalFree(pKey);
    }
}


VOID
csiFreeKeyList(
    IN OUT KEY_LIST *pKeyList)
{
    KEY_LIST *pNext;

    if (pKeyList)
    {
        // go top
        pKeyList = topKeyList(pKeyList);
        do
        {
            pNext = pKeyList->next;
            freeKey(pKeyList);
            pKeyList = pNext;
        } while (pKeyList);
    }
}

HRESULT
csiGetKeyList(
    IN DWORD        dwProvType,
    IN WCHAR const *pwszProvName,
    IN BOOL         fMachineKeySet,
    IN BOOL         fSilent,
    OUT KEY_LIST  **ppKeyList)
{
    HCRYPTPROV    hProv = NULL;
    BYTE          *pbData = NULL;
    DWORD         cbData;
    DWORD         cb;
    DWORD         dwFirstKeyFlag;
    HRESULT       hr;

    BOOL bRetVal;
    KEY_LIST * pklTravel;
    BOOL fFoundDefaultKey;
    DWORD dwSilent = fSilent? CRYPT_SILENT : 0;
    DWORD dwFlags;

    KEY_LIST      *pKeyList = NULL;
    KEY_LIST      *pKey = NULL;

    *ppKeyList = NULL;
    if (NULL == pwszProvName)
    {
        // explicitly disallowed because NULL is valid for CryptAcquireContext

        hr = E_INVALIDARG;
	_JumpError(hr, error, "NULL parm");
    }

    // get a prov handle for key enum

    dwFlags = CRYPT_VERIFYCONTEXT;

    while (TRUE)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "myCertSrvCryptAcquireContext(%ws, f=%x, m=%x)\n",
	    pwszProvName,
	    dwFlags | dwSilent,
	    fMachineKeySet));

	if (myCertSrvCryptAcquireContext(
				&hProv,
				NULL,
				pwszProvName,
				dwProvType,
				dwFlags | dwSilent,
				fMachineKeySet))
	{
	    break;		// Success!
	}

	hr = myHLastError();
	_PrintErrorStr2(hr, "myCertSrvCryptAcquireContext", pwszProvName, hr);

	// MITVcsp can't support a verify context, create a dummy container

	if ((CRYPT_VERIFYCONTEXT & dwFlags) &&
	    0 == wcscmp(pwszProvName, L"MITV Smartcard Crypto Provider V0.2"))
	{
	    dwFlags &= ~CRYPT_VERIFYCONTEXT;
	    dwFlags |= CRYPT_NEWKEYSET;
	    continue;

        }

	// Exchange can't handle fMachineKeySet or CRYPT_SILENT

	if ((fMachineKeySet || (CRYPT_SILENT & dwSilent)) &&
	    NTE_BAD_FLAGS == hr &&
	    0 == wcscmp(pwszProvName, L"Microsoft Exchange Cryptographic Provider v1.0"))
	{
	    dwSilent &= ~CRYPT_SILENT;
	    fMachineKeySet = FALSE;
	    continue;
	}
	_JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
    }

    // Enumerate a key so we can get the maximum buffer size required.
    // The first key may be a bad one, so we may have to assume a fixed buffer.

    hr = S_OK;
    cbData = 0;
    bRetVal = CryptGetProvParam(
			    hProv,
			    PP_ENUMCONTAINERS,
			    NULL,
			    &cbData,
			    CRYPT_FIRST);
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"CryptGetProvParam(%ws) -> cb=%d, bRet=%d\n",
	pwszProvName,
	cbData,
	bRetVal));
    if (!bRetVal)
    {
	// We'd like to skip the bad key (key container with long name?),
	// but we get stuck enumerating the same entry over and over again.
	// Guess at the maximum size...

	hr = myHLastError();
	_PrintErrorStr2(
		    hr,
		    "CryptGetProvParam(ignored: use 2 * MAX_PATH)",
		    pwszProvName,
		    HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) != hr)
	{
	    cbData = 0;
	    hr = S_OK;
	}
    }
    if (S_OK == hr)
    {
	if (0 == cbData)
	{
	    cbData = 2 * MAX_PATH * sizeof(CHAR);
	}

	// allocate the buffer
	pbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbData);
	if (NULL == pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}


	// enumerate all the keys for this container

	dwFirstKeyFlag = CRYPT_FIRST;
	while (TRUE)
	{
	    // get the key name

	    *pbData = '\0';
	    cb = cbData;

	    bRetVal = CryptGetProvParam(
				    hProv,
				    PP_ENUMCONTAINERS,
				    pbData,
				    &cb,
				    dwFirstKeyFlag);

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"CryptGetProvParam(pb=%x, f=%d) -> cb=%d->%d, key=%hs, bRet=%d\n",
		pbData,
		dwFirstKeyFlag,
		cbData,
		cb,
		pbData,
		bRetVal));
	    DBGDUMPHEX((
		    DBG_SS_CERTLIBI,
		    0,
		    pbData,
		    strlen((char const *) pbData)));

	    dwFirstKeyFlag = 0;

	    if (!bRetVal)
	    {
		hr = myHLastError();
		if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
		{
		    // no more keys to get
		    break;
		}
		else if (NTE_BAD_KEYSET == hr ||
			 HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr )
		{
		    // skip the bad key (key container with long name?)
		    _PrintError(hr, "bad key");
		    continue;
		}
		_JumpError(hr, error, "CryptGetProvParam");
	    }

	    pKey = newKey((CHAR *) pbData);
	    if (NULL == pKey)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    DBGDUMPHEX((
		    DBG_SS_CERTLIBI,
		    0,
		    (BYTE const *) pKey->pwszName,
		    sizeof(WCHAR) * wcslen(pKey->pwszName)));

	    addKeyList(&pKeyList, pKey);

	} // <- End of enumeration loop

	// clean up:
	// free the old buffer
	if (NULL != pbData)
	{
	    LocalFree(pbData);
	    pbData = NULL;
	}
    }

    // release the old context
    CryptReleaseContext(hProv, 0);
    hProv = NULL;

    // get the default key container and make sure it is in the key list

    if (!myCertSrvCryptAcquireContext(
			    &hProv,
			    NULL,
			    pwszProvName,
			    dwProvType,
			    dwSilent,
			    fMachineKeySet))
    {
        hr = myHLastError();
        _PrintError2(hr, "myCertSrvCryptAcquireContext", hr);
        goto done;
    }

    // find out its name
    cbData = 0;
    while (TRUE)
    {
        if (!CryptGetProvParam(hProv, PP_CONTAINER, pbData, &cbData, 0))
	{
            hr = myHLastError();
	    _PrintError2(hr, "CryptGetProvParam", hr);
	    goto done;
        }
        if (NULL != pbData)
        {
            // got it
            break;
        }
        pbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbData);
	if (NULL == pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    // create a (temporary) key structure
    pKey = newKey((CHAR *) pbData);
    if (NULL == pKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // walk the key list and see if this key is there
    fFoundDefaultKey = FALSE;
    for (pklTravel = pKeyList; NULL != pklTravel; pklTravel = pklTravel->next)
    {
        if (0 == wcscmp(pKey->pwszName, pklTravel->pwszName))
	{
            fFoundDefaultKey = TRUE;
            break;
        }
    }

    if (fFoundDefaultKey)
    {
        // we found it - delete the temp structure.

        freeKey(pKey);
    }
    else
    {
        // we didn't find it, so add the key to the list.

	addKeyList(&pKeyList, pKey);
    }

done:
    // pass list back to caller
    *ppKeyList = pKeyList;
    pKeyList = NULL;
    hr = S_OK;

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pKeyList)
    {
        csiFreeKeyList(pKeyList);
    }
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\initlib\certui.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cryptui.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certmsg.h"
#include "clibres.h"
#include "setupids.h"
#include "tfc.h"
#include "Windowsx.h"

#define __dwFILE__	__dwFILE_INITLIB_CERTUI_CPP__


HRESULT
myGetConfigStringFromPicker(
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN WCHAR const *pwszPrompt,
    OPTIONAL IN WCHAR const *pwszTitle,
    OPTIONAL IN WCHAR const *pwszSharedFolder,
    IN  BOOL                 fUseDS,
    OUT WCHAR              **ppwszConfig)
{
    HRESULT hr;
    DWORD   dwCACount;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;

    hr = myGetConfigFromPicker(
			hwndParent,
			pwszPrompt,
			pwszTitle,
			pwszSharedFolder,
			fUseDS,
			FALSE,
			&dwCACount,
			&pCAContext);
    _JumpIfError(hr, error, "myGetConfigFromPicker");

    if (NULL == pCAContext)
    {
        hr = E_INVALIDARG;
        _JumpIfError(hr, error, "Internal error: myGetConfigFromPicker");
    }

    hr = myFormConfigString(
			pCAContext->pwszCAMachineName,
			pCAContext->pwszCAName,
			ppwszConfig);
    _JumpIfError(hr, error, "myFormConfigString");

error:
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    return(hr);
}


HRESULT
myUIGetWindowText(
    IN HWND     hwndCtrl,
    OUT WCHAR **ppwszText)
{
    HRESULT  hr;
    LRESULT  len;
    DWORD    i;
    WCHAR   *pwszBegin;
    WCHAR   *pwszEnd;
    WCHAR   *pwszText = NULL;

    CSASSERT(NULL != hwndCtrl &&
             NULL != ppwszText);

    // init
    *ppwszText = NULL;

    // get text string size
    len = SendMessage(hwndCtrl, WM_GETTEXTLENGTH, 0, 0);
    if (0 < len)
    {
        pwszText = (WCHAR*)LocalAlloc(LMEM_FIXED, (UINT)((len+1) * sizeof(WCHAR)));
	if (NULL == pwszText)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
        if (len !=
            SendMessage(hwndCtrl, WM_GETTEXT, (WPARAM)len+1, (LPARAM)pwszText))
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_LENGTH);
            _JumpError(hr, error, "Internal error");
        }
    }
    else
    {
        goto done;
    }

    // trim trailing and heading blank strings
    pwszBegin = pwszText;
    pwszEnd = &pwszText[wcslen(pwszText) - 1];

    while (pwszEnd > pwszBegin && iswspace(*pwszEnd) )
    {
        *pwszEnd = L'\0';
         --pwszEnd;
    }
    while (pwszBegin <= pwszEnd &&
           L'\0' != *pwszBegin &&
           iswspace(*pwszBegin) )
    {
        ++pwszBegin;
    }

    if (pwszEnd >= pwszBegin)
    {
        MoveMemory(
	    pwszText,
	    pwszBegin,
	    (SAFE_SUBTRACT_POINTERS(pwszEnd, pwszBegin) + 2) * sizeof(WCHAR));
    }
    else
    {
        goto done;
    }

    *ppwszText = pwszText;
    pwszText = NULL;

done:
    hr = S_OK;
error:
    if (NULL != pwszText)
    {
        LocalFree(pwszText);
    }
    return hr;
}


// following code for CA selection UI control

HRESULT
UICASelectionUpdateCAList(
    HWND  hwndList,
    WCHAR const *pwszzCAList)
{
    HRESULT  hr;
    int      nItem;
    WCHAR const *pwszCA = pwszzCAList;

    // remove current list
    SendMessage(hwndList, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // add to list
    while (NULL != pwszCA && L'\0' != pwszCA[0])
    {
        nItem = (INT)SendMessage(
                    hwndList,
                    CB_ADDSTRING,
                    (WPARAM) 0,
                    (LPARAM) pwszCA);
        if (LB_ERR == nItem)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SendMessage");
        }
        pwszCA += wcslen(pwszCA) + 1;
    }

    if (NULL != pwszzCAList)
    {
        // attempt to choose the 1st one as default
        SendMessage(hwndList, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0);
    }
    hr = S_OK;

error:
    return hr;
}


LRESULT CALLBACK
myUICASelectionComputerEditFilterHook(
    HWND hwndComputer,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT  lr;
    HRESULT  hr;
    CERTSRVUICASELECTION *pData = (CERTSRVUICASELECTION*)
                 GetWindowLongPtr(hwndComputer, GWLP_USERDATA);
    CSASSERT(NULL != pData);

    switch(iMsg)
    {
        case WM_CHAR:
            // empty ca list
            hr = UICASelectionUpdateCAList(pData->hwndCAList, NULL);
            _PrintIfError(hr, "UICASelectionUpdateCAList");
        break;
    }

    lr = CallWindowProc(
		    pData->pfnUICASelectionComputerWndProcs,
		    hwndComputer,
		    iMsg,
		    wParam,
		    lParam);

//error:
    return lr;
}

HRESULT
myUICAConditionallyDisplayEnterpriseWarning(
    IN CERTSRVUICASELECTION *pData)
{
    HRESULT hr = S_OK;
    CAINFO  *pCAInfo = NULL;
    BOOL fCoInit = FALSE;
    
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, Ret, "CoInitialize");
    }
    fCoInit = TRUE;
    hr = S_OK; // don't want to return this error 
    
pData->CAType = ENUM_UNKNOWN_CA;
    
    // pinging specific CA is done in both cases -- reselect or new machine pointed at
    WCHAR szCA[MAX_PATH];
    WCHAR szComputer[MAX_PATH];
    szCA[0]=L'\0';
    szComputer[0]=L'\0';
    int iSel;
    iSel = ComboBox_GetCurSel(pData->hwndCAList);
    ComboBox_GetLBText(pData->hwndCAList, iSel, szCA);
    GetWindowText(pData->hwndComputerEdit, szComputer, MAX_PATH);
    
    if ((szCA[0]==L'\0') || (szComputer[0]==L'\0'))
    {
        ShowWindow(GetDlgItem(pData->hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_HIDE);
        goto Ret;
    }
    
    hr = myPingCertSrv(
        szCA,
        szComputer,
        NULL,
        NULL,
        &pCAInfo,
        NULL,
        NULL);
    
    if ((hr == S_OK) && (pCAInfo != NULL))
{
// copy catype into returned data
pData->CAType = pCAInfo->CAType;

 if (IsEnterpriseCA(pCAInfo->CAType))
    {
        ShowWindow(GetDlgItem(pData->hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_SHOW);
        
    }
    else
    {
        ShowWindow(GetDlgItem(pData->hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_HIDE);
    }
}

    
Ret:
    if (NULL != pCAInfo)
        LocalFree(pCAInfo);
    
    if (fCoInit)
        CoUninitialize();
    
    return hr;
}


HRESULT
myUICAHandleCAListDropdown(
    IN int                       iNotification,
    IN OUT CERTSRVUICASELECTION *pData,
    IN OUT BOOL                 *pfComputerChange)
{
    HRESULT  hr;
    WCHAR   *pwszComputer = NULL;
    WCHAR   *pwszzCAList = NULL;
    BOOL     fCoInit = FALSE;
    WCHAR   *pwszDnsName = NULL;
    DWORD   dwVersion;

    CSASSERT(NULL != pData);



    // if this isn't a focus or selection change and computer name stayed same, nothing to do
    if ((CBN_SELCHANGE != iNotification) && !*pfComputerChange) 
    {
        goto done;
    }

    ShowWindow(GetDlgItem(pData->hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_HIDE);  
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (NULL == pData->hwndComputerEdit)
    {
        // not init
        goto done;
    }

    // make sure computer edit field is not empty
    hr = myUIGetWindowText(pData->hwndComputerEdit,
                           &pwszComputer);
    _JumpIfError(hr, error, "myUIGetWindowText");
    if (NULL == pwszComputer)
    {
        goto done;
    }


if (*pfComputerChange)
{

    // ping to get ca list
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;


    // reset once ca list is updated.  Do this now to prevent recursion
    *pfComputerChange = FALSE;

    hr = myPingCertSrv(
		pwszComputer,
		NULL,
		&pwszzCAList,
		NULL,
		NULL,
		&dwVersion,
                &pwszDnsName);
    CSILOG(hr, IDS_ILOG_GETCANAME, pwszComputer, NULL, NULL);
    if (S_OK != hr)
    {
        // make sure null
        CSASSERT(NULL == pwszzCAList);

	// can't ping the ca.  Set focus now to prevent recursion
	SetFocus(pData->hwndComputerEdit);
	SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);

	CertWarningMessageBox(
		pData->hInstance,
		FALSE,
		pData->hDlg,
		IDS_WRN_PINGCA_FAIL,
		hr,
		NULL);
    }
    else if(dwVersion<2 && pData->fWebProxySetup)
    {
        //bug 262316: don't allow installing Whistler proxy to an older CA

        hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);

	if(pwszzCAList)
        {
            LocalFree(pwszzCAList);
            pwszzCAList = NULL;
        }

	SetFocus(pData->hwndComputerEdit);
	SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);

	CertWarningMessageBox(
		pData->hInstance,
		FALSE,
		pData->hDlg,
		IDS_WRN_OLD_CA,
		hr,
		NULL);
    }

    if (NULL!=pwszDnsName && 0!=wcscmp(pwszComputer, pwszDnsName)) {
	// update computer
	SendMessage(pData->hwndComputerEdit, WM_SETTEXT,
		    0, (LPARAM)pwszDnsName);
    }

    // update ca list
    hr = UICASelectionUpdateCAList(pData->hwndCAList, pwszzCAList);
    _JumpIfError(hr, error, "UICASelectionUpdateCAList");
}

// pinging specific CA is done in both cases -- reselect or new machine pointed at
    hr = myUICAConditionallyDisplayEnterpriseWarning(pData);
    _PrintIfError(hr, "myUICAConditionallyDisplayEnterpriseWarning");

done:
    hr = S_OK;

error:
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    if (fCoInit)
    {
        CoUninitialize();
    }
    if (NULL != pwszzCAList)
    {
        LocalFree(pwszzCAList);
    }
    if (NULL != pwszComputer)
    {
        LocalFree(pwszComputer);
    }
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    return hr;
}


HRESULT
myInitUICASelectionControls(
    IN OUT CERTSRVUICASELECTION *pUICASelection,
    IN HINSTANCE                 hInstance,
    IN HWND                      hDlg,
    IN HWND                      hwndBrowseButton,
    IN HWND                      hwndComputerEdit,
    IN HWND                      hwndCAList,
    IN BOOL                      fDSCA,
    OUT BOOL			*pfCAsExist)
{
    HRESULT  hr;
    PCCRYPTUI_CA_CONTEXT  pCAContext = NULL;
    DWORD          dwCACount;
    CString cstrText;

    SetCursor(LoadCursor(NULL, IDC_WAIT));
    hr = myGetConfigFromPicker(
			  hDlg,
			  NULL,
			  NULL,
			  NULL,
                          fDSCA,
			  TRUE,	// fCountOnly
			  &dwCACount,
			  &pCAContext);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    if (S_OK != hr)
    {
        dwCACount = 0;
        _PrintError(hr, "myGetConfigFromPicker");
    }

    // enable/disable
    *pfCAsExist = 0 < dwCACount;
    EnableWindow(hwndBrowseButton, *pfCAsExist);

    // set computer edit control hook
    pUICASelection->pfnUICASelectionComputerWndProcs =
        (WNDPROC)SetWindowLongPtr(hwndComputerEdit,
             GWLP_WNDPROC, (LPARAM)myUICASelectionComputerEditFilterHook);

    pUICASelection->hInstance = hInstance;
    pUICASelection->hDlg = hDlg;
    pUICASelection->hwndComputerEdit = hwndComputerEdit;
    pUICASelection->hwndCAList = hwndCAList;

    // pass data to both controls
    SetWindowLongPtr(hwndComputerEdit, GWLP_USERDATA, (ULONG_PTR)pUICASelection);
    SetWindowLongPtr(hwndCAList, GWLP_USERDATA, (ULONG_PTR)pUICASelection);

    // by default, don't show Enterprise CA warning
    cstrText.LoadString(IDS_WARN_ENTERPRISE_REQUIREMENTS);
    SetWindowText(GetDlgItem(hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), cstrText);
    ShowWindow(GetDlgItem(hDlg, IDC_CLIENT_WARN_ENTERPRISE_REQUIREMENTS), SW_HIDE);

    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }

    hr = S_OK;
//error:
    return hr;
}

HRESULT
myUICAHandleCABrowseButton(
    CERTSRVUICASELECTION *pData,
    IN BOOL               fUseDS,
    OPTIONAL IN int       idsPickerTitle,
    OPTIONAL IN int       idsPickerSubTitle,
    OPTIONAL OUT WCHAR   **ppwszSharedFolder)
{
    HRESULT   hr = S_OK;
    PCCRYPTUI_CA_CONTEXT  pCAContext = NULL;
    WCHAR         *pwszSubTitle = NULL;
    WCHAR         *pwszTitle = NULL;
    DWORD          dwCACount;
    WCHAR         *pwszzCAList = NULL;
    WCHAR         *pwszComputer = NULL;
    WCHAR         *pwszTemp = NULL;
    BOOL           fCoInit = FALSE;
    DWORD          dwVersion;

    if (NULL != ppwszSharedFolder)
    {
        *ppwszSharedFolder = NULL;
    }

    if (0 != idsPickerTitle)
    {
        hr = myLoadRCString(pData->hInstance, idsPickerTitle, &pwszTitle);
        if (S_OK != hr)
        {
            pwszTitle = NULL;
            _PrintError(hr, "myLoadRCString");
        }
    }

    if (0 != idsPickerSubTitle)
    {
        hr = myLoadRCString(pData->hInstance, idsPickerSubTitle, &pwszSubTitle);
        if (S_OK != hr)
        {
            pwszSubTitle = NULL;
            _PrintError(hr, "myLoadRCString");
        }
    }

/*
// REMOVED mattt 6/26/00: is this ever wanted: "Browse uses shared folder of machine editbox currently points at"?
// just seems to make changing away from bad machine very very slow

    // get remote shared folder if possible
    hr = myUIGetWindowText(pData->hwndComputerEdit, &pwszComputer);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL != pwszComputer)
    {
        hr = CoInitialize(NULL);
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "CoInitialize");
        }
        fCoInit = TRUE;
        // get shared folder path on remote machine here
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        hr = myPingCertSrv(pwszComputer, NULL, NULL, &pwszTemp, NULL, NULL, NULL);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszTemp);
            _JumpError(hr, localsharedfolder, "myPingCertSrv");
        }
    }

localsharedfolder:
*/
    hr = myGetConfigFromPicker(
			  pData->hDlg,
			  pwszSubTitle,
			  pwszTitle,
			  pwszTemp,
			  fUseDS,
			  FALSE,	// fCountOnly
			  &dwCACount,
			  &pCAContext);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
    {
		CSILOG(hr, IDS_ILOG_SELECTCA, NULL, NULL, NULL);
        _JumpError(hr, error, "myGetConfigFromPicker");
    }

    if (S_OK != hr)
		goto done;

	if (NULL == pCAContext)
    {
        CertWarningMessageBox(
            pData->hInstance,
            FALSE,
            pData->hDlg,
            IDS_WRN_CALIST_EMPTY,
            S_OK,
            NULL);
        SetWindowText(pData->hwndCAList, L"");
        SetFocus(pData->hwndComputerEdit);
        SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);
    }
    else
    {
        CSILOG(hr, IDS_ILOG_SELECTCA, pCAContext->pwszCAMachineName, pCAContext->pwszCAName, NULL);
        
        // update computer
        SendMessage(pData->hwndComputerEdit, WM_SETTEXT,
            0, (LPARAM)pCAContext->pwszCAMachineName);
        
        // construct a single multi string for list update
        DWORD len = wcslen(pCAContext->pwszCAName);
        pwszzCAList = (WCHAR*)LocalAlloc(LMEM_FIXED, (len+2) * sizeof(WCHAR));
        if (NULL == pwszzCAList)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(pwszzCAList, pCAContext->pwszCAName);
        pwszzCAList[len+1] = '\0';
        
        hr = UICASelectionUpdateCAList(pData->hwndCAList, pwszzCAList);
        _JumpIfError(hr, error, "UICASelectionUpdateCAList");
        LocalFree(pwszzCAList);
        pwszzCAList = NULL;

        // this thread blocks paint message, send it before ping
        UpdateWindow(pData->hDlg);
        
        // ping the computer to see if found a matched ca
        
        if (!fCoInit)
        {
            hr = CoInitialize(NULL);
            if (S_OK != hr && S_FALSE != hr)
            {
                _JumpError(hr, error, "CoInitialize");
            }
            fCoInit = TRUE;
        }
        
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        // ping to get ca list
        hr = myPingCertSrv(
            pCAContext->pwszCAMachineName,
            NULL,
            &pwszzCAList,
            NULL,
            NULL,
            &dwVersion,
            NULL);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        CSILOG(hr, IDS_ILOG_GETCANAME, pCAContext->pwszCAMachineName, NULL, NULL);
        if (S_OK == hr)
        {
            //bug 262316: don't allow installing Whistler proxy to an older CA
            if(dwVersion<2 && pData->fWebProxySetup)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
                // focus on the CA list to trigger a verification of the CA
                SetFocus(pData->hwndCAList);

            } else
            {
            // ping successful
            WCHAR const *pwszPingCA = pwszzCAList;
            
            // go through the list to see if any match
            while (NULL != pwszPingCA && L'\0' != pwszPingCA[0])
            {
                if (0 == wcscmp(pCAContext->pwszCAName, pwszPingCA))
                {
                    // found matched one
                    goto done;
                }
                pwszPingCA += wcslen(pwszPingCA) + 1;
            }
            
            // if we get here, either the CA is offline or the machine is
            // offline and another machine is using the same IP address.
            
            CertWarningMessageBox(
                pData->hInstance,
                FALSE,
                pData->hDlg,
                IDS_WRN_CANAME_NOT_MATCH,
                0,
                NULL);
            // only empty combo edit field
            SetWindowText(pData->hwndCAList, L"");
            SetFocus(pData->hwndCAList);
            }
        }
        else
        {
            // can't ping the ca, selected an estranged ca
            CertWarningMessageBox(
                pData->hInstance,
                FALSE,
                pData->hDlg,
                IDS_WRN_PINGCA_FAIL,
                hr,
                NULL);
            // empty list anyway
            hr = UICASelectionUpdateCAList(pData->hwndCAList, NULL);
            _JumpIfError(hr, error, "UICASelectionUpdateCAList");
            
            SetFocus(pData->hwndComputerEdit);
            SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);
        }
    }

done:
    hr = myUICAConditionallyDisplayEnterpriseWarning(pData);
    _PrintIfError(hr, "myUICAConditionallyDisplayEnterpriseWarning");

    if (NULL != ppwszSharedFolder)
    {
        *ppwszSharedFolder = pwszTemp;
        pwszTemp = NULL;
    }

    hr = S_OK;
error:
    if (NULL != pwszzCAList)
    {
        LocalFree(pwszzCAList);
    }
    if (NULL != pwszSubTitle)
    {
        LocalFree(pwszSubTitle);
    }
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != pwszComputer)
    {
        LocalFree(pwszComputer);
    }
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }


    return hr;
}

HRESULT
myUICASelectionValidation(
    CERTSRVUICASELECTION *pData,
    BOOL                 *pfValidate)
{
    HRESULT  hr;
    WCHAR   *pwszComputer = NULL;
    WCHAR   *pwszCA = NULL;

    CSASSERT(NULL != pData);

    *pfValidate = FALSE;

    // first, make sure not empty
    hr = myUIGetWindowText(pData->hwndComputerEdit, &pwszComputer);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL == pwszComputer)
    {
        CertWarningMessageBox(
                pData->hInstance,
                FALSE,
                pData->hDlg,
                IDS_WRN_COMPUTERNAME_EMPTY,
                0,
                NULL);
        SetFocus(pData->hwndComputerEdit);
        goto done;
    }

    hr = myUIGetWindowText(pData->hwndCAList, &pwszCA);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL == pwszCA)
    {
        CertWarningMessageBox(
                pData->hInstance,
                FALSE,
                pData->hDlg,
                IDS_WRN_CANAME_EMPTY,
                0,
                NULL);
        SetFocus(pData->hwndComputerEdit);
	SendMessage(pData->hwndComputerEdit, EM_SETSEL, 0, -1);
        goto done;
    }

    CSASSERT(pData->CAType != ENUM_UNKNOWN_CA);
    if (pData->CAType == ENUM_UNKNOWN_CA)
    {
         hr = E_UNEXPECTED;
         _JumpIfError(hr, error, "CAType not determined");
    }

    // if hit here
    *pfValidate = TRUE;

done:
    hr = S_OK;
error:
    if (NULL != pwszComputer)
    {
        LocalFree(pwszComputer);
    }
    if (NULL != pwszCA)
    {
        LocalFree(pwszCA);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\initlib\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------


#define __DIR__		"initlib"
#define VC_EXTRALEAN		// Exclude rarely-used stuff in Windows headers

#include <windows.h>

#include <setupapi.h>
#include "ocmanage.h"

#include <certsrv.h>
#include "certlib.h"
#include "initcert.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\nsrevchk\nsrevchk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       nsrevchk.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>

extern "C" void __cdecl
wmain(
    int argc,
    WCHAR *argv[])
{
    char status[2];
    unsigned long bytesRead;
    HANDLE df;
    BOOL ret;

    if (argc != 2)
    {
        MessageBox(0, L"Usage: nsrevchk filename", L"Error", MB_OK);
        exit(-1);
    }

    df = CreateFile(
		argv[1],
		GENERIC_READ,
		FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		0);
    if (INVALID_HANDLE_VALUE == df)
    {
	MessageBox(0, L"Unable to open file", L"Error", MB_OK);
	exit(-1);
    }

    ret = ReadFile(df, &status, 2, &bytesRead, 0);
    if (!ret)
    {
	MessageBox(0, L"Unable to read from file", L"Error", MB_OK);
	exit(-1);
    }

    if (bytesRead != 1)
    {
	MessageBox(0, L"Invalid file format", L"Error", MB_OK);
	exit(-1);
    }

    if (status[0] == '1')
    {
	MessageBox(0, L"Cert is Invalid", L"Certificate Status", MB_OK);
    }
    else if (status[0] == '0')
    {
	MessageBox(0, L"Cert is Valid", L"Certificate Status", MB_OK);
    }
    else
    {
	MessageBox(0, L"Unknown Certificate Status", L"Error", MB_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\config.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       config.cpp
//
//  Contents:   OC Manager component DLL for running the Certificate
//              Server setup.
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <string.h>
#include "csdisp.h"
#include "csprop.h"
#include "wizpage.h"
#include "certmsg.h"


#define __dwFILE__      __dwFILE_OCMSETUP_CONFIG_CPP__

WCHAR const g_szCertSrvDotTxt[] = L"certsrv.txt";
WCHAR const g_szCertSrvDotBak[] = L"certsrv.bak";
WCHAR const g_szSlashCertSrvDotTmp[] = L"\\certsrv.tmp";

#define wszXEnrollDllFileForVer L"CertSrv\\CertControl\\x86\\xenroll.dll"
#define wszScrdEnrlDllFileForVer L"CertSrv\\CertControl\\x86\\scrdenrl.dll"


//+-------------------------------------------------------------------------
//
//  Function:   GetBaseFileNameFromFullPath()
//
//  Synopsis:   Takes a string representing a path of the form
//              "\foo\bar\shrd\lu\basefilename"
//              and extracts the "basefilename" from the end.
//
//  Effects:    Modifies the pointer in the second argument;
//              allocates memory.
//
//  Arguments:  [pszFullPath]           -- Path to operate on
//              [pszBaseFileName]       -- Buffer to receive base name
//
//  Returns:    BOOL success/failure code.
//
//  Requires:   Assumes that pszBaseFileName is a pre-allocated buffer of
//              size sufficient to hold the filename extracted from
//              pszFullPath---NO ERROR CHECKING IS DONE ON THIS ARGUMENT;
//              IN THE CURRENT CODE BUFFERS GIVEN TO THIS ARGUMENT ARE
//              STATICALLY ALLOCATED OF SIZE MAX_PATH (OR EQUIVALENTLY
//              STRBUF_SIZE).
//
//  Modifies:   [ppszBaseFileName]
//
//  History:    10/25/96        JerryK  Created
//              11/25/96        JerryK  Code Cleanup
//
//--------------------------------------------------------------------------
BOOL
GetBaseFileNameFromFullPath(
                            IN const LPTSTR pszFullPath,
                            OUT LPTSTR pszBaseFileName)
{
    LPTSTR      pszBaseName;
    BOOL        fRetVal;
    
    // Find the last '\' character in the full path string
    if (NULL == (pszBaseName = _tcsrchr(pszFullPath,TEXT('\\'))))
    {
        // Didn't find a '\' character at all so point to start of string
        pszBaseName = pszFullPath;
    }
    else
    {
        // Found the '\' character so move to point just past it
        pszBaseName++;
    }
    
    // Copy the base file name into the result buffer
    _tcscpy(pszBaseFileName,pszBaseName);
    
    // Set up return value
    fRetVal = TRUE;
    
    return fRetVal;
}

HRESULT myStringToAnsiFile(HANDLE hFile, LPCSTR psz, DWORD cch)
{
    DWORD dwWritten;

    if (cch == -1)
        cch = lstrlenA(psz);

    if (!WriteFile(
            hFile,
            psz,
            cch,
            &dwWritten,
            NULL))
        return myHLastError();

    CSASSERT(dwWritten == cch);
    return S_OK;
}

HRESULT myStringToAnsiFile(HANDLE hFile, LPCWSTR pwsz, DWORD cch)
{
    HRESULT hr;
    LPSTR psz = NULL;

    if (!ConvertWszToSz(&psz, pwsz, cch))
    {
        hr = myHLastError();
        goto Ret;
    }
    hr = myStringToAnsiFile(hFile, psz, cch);

Ret:
    if (psz)
        LocalFree(psz);

    return hr;
}

HRESULT myStringToAnsiFile(HANDLE hFile, CHAR ch)
{
    return myStringToAnsiFile(hFile, &ch, 1);
}


HRESULT
WriteEscapedString(
                   HANDLE hConfigFile, 
                   WCHAR const *pwszIn,
                   IN BOOL fEol)
{
    BOOL fQuote = FALSE;
    DWORD i;
    HRESULT hr;
    
    if (NULL == pwszIn)
    {
        hr = myStringToAnsiFile(hConfigFile, "\"\"", 2); // write ("")
        _JumpIfError(hr, error, "myStringToAnsiFile");
    }
    else
    {
        // Quote strings that have double quotes, commas, '#' or white space,
        // or that are empty.
        
        fQuote = L'\0' != pwszIn[wcscspn(pwszIn, L"\",# \t")] || L'\0' == *pwszIn;
        
        if (fQuote)
        {
            hr = myStringToAnsiFile(hConfigFile, '"');
            _JumpIfError(hr, error, "myStringToAnsiFile");
        }
        while (TRUE)
        {
            // Find a L'\0' or L'"', and print the string UP TO that character:
            i = wcscspn(pwszIn, L"\"");
            hr = myStringToAnsiFile(hConfigFile, pwszIn, i);
            _JumpIfError(hr, error, "myStringToAnsiFile");

            
            // Point to the L'\0' or L'"', and stop at the end of the string.
            
            pwszIn += i;
            if (L'\0' == *pwszIn)
            {
                break;
            }
            
            // Skip the L'"', and print two of them to escape the embedded quote.
            
            pwszIn++;
            hr = myStringToAnsiFile(hConfigFile, "\"\"", 2); // write ("")
            _JumpIfError(hr, error, "myStringToAnsiFile");
        }
        if (fQuote)
        {
            hr = myStringToAnsiFile(hConfigFile, '"');
            _JumpIfError(hr, error, "myStringToAnsiFile");
        }
    }
    
    hr = myStringToAnsiFile(hConfigFile, fEol ? "\r\n" : ", ", 2);  // each insert string is 2 chars
    _JumpIfError(hr, error, "myStringToAnsiFile");

error:
    return hr;
}


HRESULT
WriteNewConfigEntry(
    HANDLE      hConfigFile, 
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    DWORD   i;
    WCHAR wszSelfSignFName[MAX_PATH];
    WCHAR *pwszConfig = NULL;
    CASERVERSETUPINFO *pServer = (pComp->CA).pServer;


    hr = myFormConfigString(pComp->pwszServerName,
                            pServer->pwszSanitizedName,
                            &pwszConfig);
    _JumpIfError(hr, error, "myFormConfigString");
    
    // Yank out the base filenames for the exchange and self-signed certs
    GetBaseFileNameFromFullPath(pServer->pwszCACertFile, wszSelfSignFName);
    
    hr = WriteEscapedString(hConfigFile, pServer->pwszSanitizedName, FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");


// org, ou, country, state
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");
        hr = WriteEscapedString(hConfigFile, L"", FALSE);
        _JumpIfError(hr, error, "WriteEscapedString");




    hr = WriteEscapedString(hConfigFile, L"", FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");

    hr = WriteEscapedString(hConfigFile, pwszConfig, FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");

    hr = WriteEscapedString(hConfigFile, L"", FALSE);   // dummy wszExchangeFName
    _JumpIfError(hr, error, "WriteEscapedString");

    hr = WriteEscapedString(hConfigFile, wszSelfSignFName, FALSE);
    _JumpIfError(hr, error, "WriteEscapedString");


// ca description
    hr = WriteEscapedString(hConfigFile, L"", TRUE);
    _JumpIfError(hr, error, "WriteEscapedString");

error:
    if (NULL != pwszConfig)
    {
        LocalFree(pwszConfig);
    }
    return(hr);
}

WCHAR *apwszFieldNames[] = {
        wszCONFIG_COMMONNAME,
        wszCONFIG_ORGUNIT,
        wszCONFIG_ORGANIZATION,
        wszCONFIG_LOCALITY,
        wszCONFIG_STATE,
        wszCONFIG_COUNTRY,
#define FN_CONFIG       6       // Index into apwszFieldNames & apstrFieldNames
        wszCONFIG_CONFIG,
        wszCONFIG_EXCHANGECERTIFICATE,
#define FN_CERTNAME     8       // Index into apwszFieldNames & apstrFieldNames
        wszCONFIG_SIGNATURECERTIFICATE,
#define FN_COMMENT      9       // Index into apwszFieldNames & apstrFieldNames
        wszCONFIG_DESCRIPTION,
};
#define CSTRING (sizeof(apwszFieldNames)/sizeof(apwszFieldNames[0]))

BSTR apstrFieldNames[CSTRING];


HRESULT
CopyConfigEntry(
                IN HANDLE hConfigFile, 
                IN BSTR const strConfig,
                IN ICertConfig *pConfig)
{
    HRESULT hr;
    BSTR strFieldValue = NULL;
    BSTR strComment = NULL;
    BSTR strCertName = NULL;
    DWORD i;
    
    for (i = 0; i < CSTRING; i++)
    {
        CSASSERT(NULL != apstrFieldNames[i]);
        hr = pConfig->GetField(apstrFieldNames[i], &strFieldValue);
        _JumpIfErrorNotSpecific(
            hr,
            error,
            "ICertConfig::GetField",
            CERTSRV_E_PROPERTY_EMPTY);
        
        hr = WriteEscapedString(hConfigFile, strFieldValue, ((CSTRING - 1) == i) );
        _JumpIfError(hr, error, "WriteEscapedString");
        
        switch (i)
        {
        case FN_CERTNAME:
            strCertName = strFieldValue;
            strFieldValue = NULL;
            break;
            
        case FN_COMMENT:
            strComment = strFieldValue;
            strFieldValue = NULL;
            break;
        }
    }
    
    hr = S_OK;
error:
    if (NULL != strFieldValue)
    {
        SysFreeString(strFieldValue);
    }
    if (NULL != strComment)
    {
        SysFreeString(strComment);
    }
    if (NULL != strCertName)
    {
        SysFreeString(strCertName);
    }
    return(hr);
}


HRESULT
WriteFilteredConfigEntries(
                           IN HANDLE hConfigFile, 
                           IN ICertConfig *pConfig,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr = S_OK;
    LONG Count;
    LONG Index;
    BSTR strConfig = NULL;
    BSTR strFlags = NULL;
    LONG lConfigFlags;
    WCHAR wszConfigComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR *pwsz;
    WCHAR *pwszConfigServer = NULL;
    DWORD cwcConfigServer;
    DWORD cwc;
    DWORD i;
    BOOL fValidDigitString;
    
    for (i = 0; i < CSTRING; i++)
    {
        if (!ConvertWszToBstr(&apstrFieldNames[i], apwszFieldNames[i], -1))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "ConvertWszToBstr");
        }
    }
    hr = pConfig->Reset(0, &Count);
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
        _JumpError2(hr, error, "Reset", S_FALSE);
    }
    while (Count-- > 0)
    {
        hr = pConfig->Next(&Index);
        _JumpIfError(hr, error, "Next");
        
        hr = pConfig->GetField(apstrFieldNames[FN_CONFIG], &strConfig);
        _JumpIfError(hr, error, "GetField");
        
        pwsz = wcschr(strConfig, L'\\');
        if (NULL == pwsz)
        {
            cwc = wcslen(strConfig);
        }
        else
        {
            cwc = SAFE_SUBTRACT_POINTERS(pwsz, strConfig);
        }
        if (NULL == pwszConfigServer || cwc >= cwcConfigServer)
        {
            if (NULL != pwszConfigServer)
            {
                LocalFree(pwszConfigServer);
                pwszConfigServer = NULL;
            }
            cwcConfigServer = cwc + 1;
            if (2 * MAX_COMPUTERNAME_LENGTH > cwcConfigServer)
            {
                cwcConfigServer = 2 * MAX_COMPUTERNAME_LENGTH;
            }
            pwszConfigServer = (WCHAR *) LocalAlloc(
                LMEM_FIXED,
                cwcConfigServer * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pwszConfigServer);
            
        }
        CSASSERT(cwc < cwcConfigServer);
        CopyMemory(pwszConfigServer, strConfig, cwc * sizeof(WCHAR));
        pwszConfigServer[cwc] = L'\0';
        
        hr = pConfig->GetField(wszCONFIG_FLAGS, &strFlags);
        _JumpIfError(hr, error, "GetField");

        lConfigFlags = myWtoI(strFlags, &fValidDigitString);
        
        // write everything _but_ current server
        if (0 != lstrcmpi(pwszConfigServer, pComp->pwszServerName) &&
            0 != lstrcmpi(pwszConfigServer, pComp->pwszServerNameOld) &&
            0 != (CAIF_SHAREDFOLDERENTRY & lConfigFlags) )
        {
            hr = CopyConfigEntry(
                hConfigFile,
                strConfig,
                pConfig);
            _JumpIfError(hr, error, "CopyConfigEntry");
        }
    }
    
error:
    if (NULL != pwszConfigServer)
    {
        LocalFree(pwszConfigServer);
    }
    for (i = 0; i < CSTRING; i++)
    {
        if (NULL != apstrFieldNames[i])
        {
            SysFreeString(apstrFieldNames[i]);
            apstrFieldNames[i] = NULL;
        }
    }
    if (NULL != strConfig)
    {
        SysFreeString(strConfig);
    }
    if (NULL != strFlags)
    {
        SysFreeString(strFlags);
    }
    return(hr);
}


HRESULT
CertReplaceFile(
            IN HINSTANCE hInstance,
            IN BOOL fUnattended,
            IN HWND hwnd,
            IN WCHAR const *pwszpath,
            IN WCHAR const *pwszFileNew,
            IN WCHAR const *pwszFileBackup)
{
    HRESULT hr;
    WCHAR *pwsz;
    WCHAR wszpathNew[MAX_PATH] = L"";
    WCHAR wszpathBackup[MAX_PATH] = L"";
    
    wcscpy(wszpathNew, pwszpath);
    pwsz = wcsrchr(wszpathNew, L'\\');
    CSASSERT(NULL != pwsz);
    if (NULL == pwsz)
        return E_INVALIDARG;
    else
        pwsz[1] = L'\0';
    
    wcscpy(wszpathBackup, wszpathNew);
    wcscat(wszpathNew, pwszFileNew);
    wcscat(wszpathBackup, pwszFileBackup);
    
    if (!DeleteFile(wszpathBackup))
    {
        hr = myHLastError();
        _PrintErrorStr2(
                    hr,
                    "DeleteFile",
                    wszpathBackup,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    if (!MoveFile(wszpathNew, wszpathBackup))
    {
        hr = myHLastError();
        _PrintErrorStr2(
                    hr,
                    "MoveFile",
                    wszpathNew,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    if (!MoveFile(pwszpath, wszpathNew))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "MoveFile", pwszpath);
    }

    hr = S_OK;
error:
    return(hr);
}

//--------------------------------------------------------------------
// Perform search and replace on the source string, using multiple
// replacee strings, and returns the result.
//   rgrgwszReplacement is an array of arrays of two strings:
//     rgrgwszReplacement[n][0] is the replacee,
//     rgrgwszReplacement[n][1] is the replacment.
//   No portion of any of the replacement strings is searched for a replacee string.
//   Replacement strings may be NULL.
#define REPLACEE 0
#define REPLACEMENT 1
WCHAR * MultiStringReplace(const WCHAR * pwszSource, const WCHAR *(* rgrgpwszReplacements)[2] , unsigned int nReplacements) {

    // precondition
    CSASSERT(NULL!=pwszSource);
    CSASSERT(nReplacements>0);
    CSASSERT(NULL!=rgrgpwszReplacements);

    // common variables
    unsigned int nIndex;
    BOOL bSubstFound;
    unsigned int nChosenReplacement;
    const WCHAR * pwchSubstStart;
    const WCHAR * pwchSearchStart;
    WCHAR * pwszTarget=NULL;
    WCHAR * pwchTargetStart;

    // first, calculate the length of the result string
    unsigned int nFinalStringLen=wcslen(pwszSource)+1;
    pwchSearchStart=pwszSource;
    do {
        // find the next substitution
        bSubstFound=FALSE;
        for (nIndex=0; nIndex<nReplacements; nIndex++) {
            WCHAR * pwchTempSubstStart=wcsstr(pwchSearchStart, rgrgpwszReplacements[nIndex][REPLACEE]);
            if (NULL==pwchTempSubstStart) {
                // we didn't find this replacee in the target
                //  so ignore it
            } else if (FALSE==bSubstFound) {
                // this is the first one we found
                pwchSubstStart=pwchTempSubstStart;
                bSubstFound=TRUE;
                nChosenReplacement=nIndex;
            } else if (pwchSubstStart>pwchTempSubstStart) {
                // this is one comes before the one we already found
                pwchSubstStart=pwchTempSubstStart;
                nChosenReplacement=nIndex;
            } else {
                // this is one comes after the one we already found
                //  so ignore it
            }
        } // <- end substitution finding loop

        // if no substitution has been found, exit the loop
        if (FALSE==bSubstFound) {
            break;
        }

        // update the statistics
        nFinalStringLen=nFinalStringLen
            + (NULL != rgrgpwszReplacements[nChosenReplacement][REPLACEMENT] ?
              wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEMENT]) : 0)
            -wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEE]);
        pwchSearchStart=pwchSubstStart+wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEE]);

    } while (TRUE); // <- end length-calculating loop

    // allocate the new string
    pwszTarget=(WCHAR *)LocalAlloc(LMEM_FIXED, nFinalStringLen*sizeof(WCHAR));
    if (NULL==pwszTarget) {
        _JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
    }

    // build the result
    pwchTargetStart=pwszTarget;
    pwchSearchStart=pwszSource;
    do {
        // find the next substitution
        bSubstFound=FALSE;
        for (nIndex=0; nIndex<nReplacements; nIndex++) {
            WCHAR * pwchTempSubstStart=wcsstr(pwchSearchStart, rgrgpwszReplacements[nIndex][REPLACEE]);
            if (NULL==pwchTempSubstStart) {
                // we didn't find this replacee in the target
                //  so ignore it
            } else if (FALSE==bSubstFound) {
                // this is the first one we found
                pwchSubstStart=pwchTempSubstStart;
                bSubstFound=TRUE;
                nChosenReplacement=nIndex;
            } else if (pwchSubstStart>pwchTempSubstStart) {
                // this is one comes before the one we already found
                pwchSubstStart=pwchTempSubstStart;
                nChosenReplacement=nIndex;
            } else {
                // this is one comes after the one we already found
                //  so ignore it
            }
        } // <- end substitution finding loop

        // if no substitution has been found, exit the loop
        if (FALSE==bSubstFound) {
            break;
        }

        // copy the source up to the replacee
        unsigned int nCopyLen=SAFE_SUBTRACT_POINTERS(pwchSubstStart, pwchSearchStart);
        wcsncpy(pwchTargetStart, pwchSearchStart, nCopyLen);
        pwchTargetStart+=nCopyLen;

        if (NULL != rgrgpwszReplacements[nChosenReplacement][REPLACEMENT])
        {
            // copy the replacement
            nCopyLen=wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEMENT]);
            wcsncpy(pwchTargetStart, rgrgpwszReplacements[nChosenReplacement][REPLACEMENT], nCopyLen);
            pwchTargetStart+=nCopyLen;
        }

        // skip over the replacee
        pwchSearchStart=pwchSubstStart+wcslen(rgrgpwszReplacements[nChosenReplacement][REPLACEE]);

    } while (TRUE); // <- end target string building loop

    // finish copying whatever's left, which may be just '\0'.
    wcscpy(pwchTargetStart, pwchSearchStart);

    // postcondition
    CSASSERT(wcslen(pwszTarget)+1==nFinalStringLen);

    // all done
error:
    return pwszTarget;
}

//--------------------------------------------------------------------
// Escapes any characters unsuitable for plain HTML (or VBScript)
static const WCHAR * gc_rgrgpwszHTMLSafe[4][2]={
    {L"<", L"&lt;"}, {L">", L"&gt;"}, {L"\"", L"&quot;"},  {L"&", L"&amp;"}
};
WCHAR * MakeStringHTMLSafe(const WCHAR * pwszTarget) {
    return MultiStringReplace(pwszTarget, gc_rgrgpwszHTMLSafe, ARRAYSIZE(gc_rgrgpwszHTMLSafe));
}

//--------------------------------------------------------------------
// Escapes any characters unsuitable for plain HTML (or VBScript)
static const WCHAR * gc_rgrgpwszVBScriptSafe[2][2]={
    {L"\"", L"\"\""}, {L"%>", L"%\" & \">"}
};
WCHAR * MakeStringVBScriptSafe(const WCHAR * pwszTarget) {
    return MultiStringReplace(pwszTarget, gc_rgrgpwszVBScriptSafe, ARRAYSIZE(gc_rgrgpwszVBScriptSafe));
}

//--------------------------------------------------------------------
// Perform search and replace on the source string and return the result
//   No portion of the replacement string is searched for the replacee string.
//   Simple adapter for MultiStringReplace
WCHAR * SingleStringReplace(const WCHAR * pwszSource, const WCHAR * pwszReplacee, const WCHAR * pwszReplacement) {
    const WCHAR * rgrgpwszTemp[1][2]={{pwszReplacee, pwszReplacement}};
    return MultiStringReplace(pwszSource, rgrgpwszTemp, ARRAYSIZE(rgrgpwszTemp));
}

//--------------------------------------------------------------------
// write a string to a file
//   Mostly, this is a wrapper to do UNICODE->UTF8 conversion.
HRESULT WriteString(HANDLE hTarget, const WCHAR * pwszSource) {

    // precondition
    CSASSERT(NULL!=pwszSource);
    CSASSERT(NULL!=hTarget && INVALID_HANDLE_VALUE!=hTarget);

    // common variables
    HRESULT hr=S_OK;
    char * pszMbcsBuf=NULL;

    // perform UNICODE->MBCS

    // determine size of output buffer
    DWORD dwBufByteSize=WideCharToMultiByte(CP_UTF8/*code page*/, 0/*flags*/, pwszSource,
        -1/*null-terminated*/, NULL/*out-buf*/, 0/*size of out-buf, 0->calc*/, 
        NULL/*default char*/, NULL/*used default char*/);
    if (0==dwBufByteSize) {
        hr=myHLastError();
        _JumpError(hr, error, "WideCharToMultiByte(calc)");
    }

    // allocate output buffer
    pszMbcsBuf=(char *)LocalAlloc(LMEM_FIXED, dwBufByteSize);
    _JumpIfOutOfMemory(hr, error, pszMbcsBuf);

    // do the conversion
    if (0==WideCharToMultiByte(CP_UTF8/*code page*/, 0/*flags*/, pwszSource,
        -1/*null-terminated*/, pszMbcsBuf, dwBufByteSize,
        NULL/*default char*/, NULL/*used default char*/)) {

        hr=myHLastError();
        _JumpError(hr, error, "WideCharToMultiByte(convert)");
    }

    // write to file and free the string
    dwBufByteSize--; // minus one so we don't write the terminating null
    DWORD dwBytesWritten;
    if (FALSE==WriteFile(hTarget, pszMbcsBuf, dwBufByteSize, &dwBytesWritten, NULL /*overlapped*/)) {
        hr=myHLastError();
        _JumpError(hr, error, "WriteFile");
    }

    // all done
error:
    if (NULL!=pszMbcsBuf) {
        LocalFree(pszMbcsBuf);
    }
    return hr;
}

//--------------------------------------------------------------------
// return the version string for a file in the format for a web page (comma separated)
HRESULT
GetFileWebVersionString(
    IN WCHAR const * pwszFileName,
    OUT WCHAR ** ppwszVersion)
{
    // precondition
    CSASSERT(NULL!=pwszFileName);
    CSASSERT(NULL!=ppwszVersion);

    // common variables
    HRESULT hr;
    DWORD cbData;
    DWORD dwIgnored;
    UINT uLen;
    VS_FIXEDFILEINFO * pvs;
    WCHAR wszFileVersion[64];
    int  cch;

    // variables that must be cleaned up
    VOID * pvData=NULL;

    // reset the output parameter
    *ppwszVersion=NULL;

    // determine the size of the memory block needed to store the version info
    cbData=GetFileVersionInfoSize(const_cast<WCHAR *>(pwszFileName), &dwIgnored);
    if (0==cbData) {
        hr=myHLastError();
        if (S_OK==hr) {
            hr=HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
        }
        _JumpErrorStr(hr, error, "GetFileVersionInfoSize", pwszFileName);
    }

    // allocate the block
    pvData=LocalAlloc(LMEM_FIXED, cbData);
    _JumpIfOutOfMemory(hr, error, pvData);

    // load the file version info
    if (!GetFileVersionInfo(const_cast<WCHAR *>(pwszFileName), dwIgnored, cbData, pvData)) {
        hr=myHLastError();
        _JumpErrorStr(hr, error, "GetFileVersionInfo", pwszFileName);
    }

    // get a pointer to the root block
    if (!VerQueryValue(pvData, L"\\", (VOID **) &pvs, &uLen)) {
        hr=myHLastError();
        _JumpError(hr, error, "VerQueryValue");
    }

    cch = wsprintf(wszFileVersion, L"%d,%d,%d,%d",
                    HIWORD(pvs->dwFileVersionMS),
                    LOWORD(pvs->dwFileVersionMS),
                    HIWORD(pvs->dwFileVersionLS),
                    LOWORD(pvs->dwFileVersionLS));
    CSASSERT(cch < ARRAYSIZE(wszFileVersion));
    *ppwszVersion = (WCHAR*)LocalAlloc(LMEM_FIXED,
                            (wcslen(wszFileVersion)+1) * sizeof(WCHAR));
    if (NULL == *ppwszVersion)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszVersion, wszFileVersion);

    hr=S_OK;

error:
    if (NULL != pvData) {
        LocalFree(pvData);
    }

    return hr;
}

//--------------------------------------------------------------------
// create the .inc file that has the basic configuration data
HRESULT CreateCertWebDatIncPage(IN PER_COMPONENT_DATA *pComp, IN BOOL bIsServer)
{
    // precondition
    CSASSERT(NULL!=pComp);

    // common variables
    HRESULT hr=S_OK;
    HANDLE hTarget=INVALID_HANDLE_VALUE;
    const WCHAR * rgrgpwszSubst[12][2];
    WCHAR wszTargetFileName[MAX_PATH];
    wszTargetFileName[0] = L'\0';

    // variables that must be cleaned up
    WCHAR * pwszTempA=NULL;
    WCHAR * pwszTempB=NULL;
    WCHAR * pwszTempC=NULL;
    WCHAR * pwszTempD=NULL;
    WCHAR * pwszTempE=NULL;
    ENUM_CATYPES CAType;

    // create the target file name
    wcscpy(wszTargetFileName, pComp->pwszSystem32);
    wcscat(wszTargetFileName, L"CertSrv\\certdat.inc");
    
    // get html lines from resource
    // Note, we don't have to free these strings.
    WCHAR const * pwszCWDat=myLoadResourceString(IDS_HTML_CERTWEBDAT);
    if (NULL==pwszCWDat) {
        hr=myHLastError();
        _JumpError(hr, error, "myLoadResourceString");
    }

    // open the file
    hTarget=CreateFileW(wszTargetFileName, GENERIC_WRITE, 0/*no sharing*/, NULL/*security*/, 
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL/*template*/);
    if (INVALID_HANDLE_VALUE==hTarget) {
        hr=myHLastError();
        _JumpError(hr, error, "CreateFileW");
    }

    // prepare to write the file
    //   %0 - default company
    //   %1 - default OrgUnit
    //   %2 - default locality
    //   %3 - default state
    //   %4 - default country
    //   %5 - computer
    //   %6 - CA name (unsanitized, for config)
    //   %7 - server type
    //   %8 - opposite of %7
    //   %9 - XEnroll version
    //   %A - ScrdEnrl version
    //   %B - CA name (unsanitized, for display)

    rgrgpwszSubst[0][REPLACEE]=L"%0";
    rgrgpwszSubst[1][REPLACEE]=L"%1";
    rgrgpwszSubst[2][REPLACEE]=L"%2";
    rgrgpwszSubst[3][REPLACEE]=L"%3";
    rgrgpwszSubst[4][REPLACEE]=L"%4";
    rgrgpwszSubst[5][REPLACEE]=L"%5";
    rgrgpwszSubst[6][REPLACEE]=L"%6";
    rgrgpwszSubst[7][REPLACEE]=L"%7";
    rgrgpwszSubst[8][REPLACEE]=L"%8";
    rgrgpwszSubst[9][REPLACEE]=L"%9";
    rgrgpwszSubst[10][REPLACEE]=L"%A";
    rgrgpwszSubst[11][REPLACEE]=L"%B";

        rgrgpwszSubst[0][REPLACEMENT]=L""; // company/org
        rgrgpwszSubst[1][REPLACEMENT]=L""; // ou
        rgrgpwszSubst[2][REPLACEMENT]=L""; // locality
        rgrgpwszSubst[3][REPLACEMENT]=L""; // state
        rgrgpwszSubst[4][REPLACEMENT]=L""; // country

    if (FALSE==bIsServer) {
        // This is a web-client only setup
        CAWEBCLIENTSETUPINFO *pClient=pComp->CA.pClient;

         // set the identity of the CA
        rgrgpwszSubst[5][REPLACEMENT]=pClient->pwszWebCAMachine;

        pwszTempE=MakeStringVBScriptSafe(pClient->pwszWebCAName);
        _JumpIfOutOfMemory(hr, error, pwszTempE);
        rgrgpwszSubst[6][REPLACEMENT]=pwszTempE;

        pwszTempD=MakeStringHTMLSafe(pClient->pwszWebCAName);
        _JumpIfOutOfMemory(hr, error, pwszTempD);
        rgrgpwszSubst[11][REPLACEMENT]=pwszTempD;

        CAType = pClient->WebCAType;

    } else {
        // This is a server + web-client setup
        CASERVERSETUPINFO *pServer=pComp->CA.pServer;

         // set the identity of the CA
        rgrgpwszSubst[5][REPLACEMENT]=pComp->pwszServerName;

        pwszTempE=MakeStringVBScriptSafe(pServer->pwszCACommonName);
        _JumpIfOutOfMemory(hr, error, pwszTempE);
        rgrgpwszSubst[6][REPLACEMENT]=pwszTempE;

        pwszTempD=MakeStringHTMLSafe(pServer->pwszCACommonName);
        _JumpIfOutOfMemory(hr, error, pwszTempD);
        rgrgpwszSubst[11][REPLACEMENT]=pwszTempD;

        CAType = pServer->CAType;
    }

    // set the CA type
    if (IsStandaloneCA(CAType)) {
        rgrgpwszSubst[7][REPLACEMENT]=L"StandAlone";
        rgrgpwszSubst[8][REPLACEMENT]=L"Enterprise";
    } else {
        rgrgpwszSubst[7][REPLACEMENT]=L"Enterprise";
        rgrgpwszSubst[8][REPLACEMENT]=L"StandAlone";
    }

    //   %9 - XEnroll version
    wcscpy(wszTargetFileName, pComp->pwszSystem32);
    wcscat(wszTargetFileName, wszXEnrollDllFileForVer);
    hr=GetFileWebVersionString(wszTargetFileName, &pwszTempB);
    _JumpIfError(hr, error, "GetFileWebVersionString");
    rgrgpwszSubst[9][REPLACEMENT]=pwszTempB;

    //   %A - ScrdEnrl version
    wcscpy(wszTargetFileName, pComp->pwszSystem32);
    wcscat(wszTargetFileName, wszScrdEnrlDllFileForVer);
    hr=GetFileWebVersionString(wszTargetFileName, &pwszTempC);
    _JumpIfError(hr, error, "GetFileWebVersionString");
    rgrgpwszSubst[10][REPLACEMENT]=pwszTempC;

    // do the replacements
    pwszTempA=MultiStringReplace(pwszCWDat, rgrgpwszSubst, ARRAYSIZE(rgrgpwszSubst));
    _JumpIfOutOfMemory(hr, error, pwszTempA);

    // write the text
    hr=WriteString(hTarget, pwszTempA);
    _JumpIfError(hr, error, "WriteString");

    // all done
error:
    if (INVALID_HANDLE_VALUE!=hTarget) {
        CloseHandle(hTarget);
    }
    if (NULL!=pwszTempA) {
        LocalFree(pwszTempA);
    }
    if (NULL!=pwszTempB) {
        LocalFree(pwszTempB);
    }
    if (NULL!=pwszTempC) {
        LocalFree(pwszTempC);
    }
    if (NULL!=pwszTempD) {
        LocalFree(pwszTempD);
    }
    if (NULL!=pwszTempE) {
        LocalFree(pwszTempE);
    }
    return hr;
}


HRESULT
CreateConfigFiles(
    WCHAR *pwszDirectoryPath,
    PER_COMPONENT_DATA *pComp,
    BOOL fRemove,
    HWND hwnd)
{
    WCHAR wszpathConfig[MAX_PATH];
    WCHAR wszCACertFileName[MAX_PATH];
    HANDLE hConfigFile;
    DISPATCHINTERFACE di;
    ICertConfig *pConfig = NULL;
    BOOL fMustRelease = FALSE;
    HRESULT hr = S_OK;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    
    hr = DispatchSetup(
		DISPSETUP_COM,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTCONFIG,
		&CLSID_CCertConfig, 
		&IID_ICertConfig, 
		0,		// cDispatch
		NULL,           // pDispatchTable
		&di);
    if (S_OK != hr)
    {
        pComp->iErrMsg = IDS_ERR_LOADICERTCONFIG;
        _JumpError(hr, error, "DispatchSetup");
    }
    fMustRelease = TRUE;
    pConfig = (ICertConfig *) di.pUnknown;
    
    wcscpy(wszpathConfig, pwszDirectoryPath);
    wcscat(wszpathConfig, g_szSlashCertSrvDotTmp);
    
    hConfigFile = CreateFile(
            wszpathConfig, 
            GENERIC_WRITE, 
            0,
            NULL,
            CREATE_ALWAYS,
            0,
            0);
    if (INVALID_HANDLE_VALUE == hConfigFile)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
        _JumpErrorStr2(
		hr,
		error,
		"CreateFile",
		wszpathConfig,
		fRemove? hr : S_OK);
    }
    
    if (!fRemove)
    {
        // if installing, write our config entry first
        hr = WriteNewConfigEntry(hConfigFile, pComp);
        _PrintIfError(hr, "WriteNewConfigEntry");
    }
    
    if (S_OK == hr)
    {
        hr = WriteFilteredConfigEntries(
            hConfigFile,
            pConfig,
            pComp);
        _PrintIfError2(hr, "WriteFilteredConfigEntries", S_FALSE);
    }
    
    // must close here because the following call will move it
    if (NULL != hConfigFile)
    {
        CloseHandle(hConfigFile);
    }
    
    hr = CertReplaceFile(pComp->hInstance,
                     pComp->fUnattended,
                     hwnd,
                     wszpathConfig,
                     g_szCertSrvDotTxt,
                     g_szCertSrvDotBak);
    _JumpIfErrorStr(hr, error, "CertReplaceFile", g_szCertSrvDotTxt);
    
    hr = S_OK;
    
error:
    if (S_OK != hr && 0 == pComp->iErrMsg)
    {
        pComp->iErrMsg = IDS_ERR_WRITECONFIGFILE;
    }
    if (fMustRelease)
    {
        Config_Release(&di);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\cryptfix.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryptfix.cpp
//
//  Contents:   Crypto API, version 2. fix for certificate server
//
//              CryptDecodeObject/CryptEncodeObject structures added
//              after SP3.
//
//  Functions:  CryptFixDllMain
//
//  History:    13-Aug-96    kevinr   created
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "crypttls.h"
#include "unicode.h"
extern "C" {
#include "..\..\pki\certstor\ossx509.h"
}


#define __dwFILE__	__dwFILE_OCMSETUP_CRYPTFIX_CPP__


//#include <dbgdef.h>

// The CRYPTIE_STATIC prefixed variables and functions are defined in
// ..\certstor\wincert.obj
#define CRYPTIE_STATIC extern

CRYPTIE_STATIC HCRYPTOSSGLOBAL hX509OssGlobal;
CRYPTIE_STATIC HCRYPTOIDFUNCSET hX509EncodeFuncSet;
CRYPTIE_STATIC HCRYPTOIDFUNCSET hX509DecodeFuncSet;

#if DBG
    extern BOOL WINAPI DebugDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif

extern BOOL WINAPI UnicodeDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);


CRYPTIE_STATIC BOOL WINAPI OssX509KeygenRequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509KeygenRequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509IntegerEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509IntegerDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT int *pInfo,
        IN OUT DWORD *pcbInfo
        );
CRYPTIE_STATIC BOOL WINAPI OssX509ChoiceOfTimeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509ChoiceOfTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT LPFILETIME pInfo,
        IN OUT DWORD *pcbInfo
        );
CRYPTIE_STATIC BOOL WINAPI OssX509SequenceOfAnyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509SequenceOfAnyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509CrlDistPointsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509CrlDistPointsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRL_DIST_POINTS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityKeyId2Encode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityKeyId2Decode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509OctetStringEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509OctetStringDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509BitsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509BitsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityInfoAccessEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509AuthorityInfoAccessDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN OUT DWORD *pcbInfo
        );

CRYPTIE_STATIC BOOL WINAPI OssX509CtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
CRYPTIE_STATIC BOOL WINAPI OssX509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        );


//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Value
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameValueDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_NAME_VALUE pInfo,
        IN OUT DWORD *pcbInfo
        );

BOOL WINAPI CertDllKeygenRequestInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509KeygenRequestInfoEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllKeygenRequestInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509KeygenRequestInfoDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllIntegerEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509IntegerEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllIntegerDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT int *pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509IntegerDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllChoiceOfTimeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509ChoiceOfTimeEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllChoiceOfTimeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT LPFILETIME pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509ChoiceOfTimeDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllSequenceOfAnyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509SequenceOfAnyEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllSequenceOfAnyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509SequenceOfAnyDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllCrlDistPointsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509CrlDistPointsEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllCrlDistPointsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRL_DIST_POINTS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509CrlDistPointsDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllUnicodeNameValueEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return UnicodeNameValueEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllUnicodeNameValueDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_NAME_VALUE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return UnicodeNameValueDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllAuthorityKeyId2Encode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509AuthorityKeyId2Encode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllAuthorityKeyId2Decode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509AuthorityKeyId2Decode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllOctetStringEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509OctetStringEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllOctetStringDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509OctetStringDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllBitsEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509BitsEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllBitsDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509BitsDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllAuthorityInfoAccessEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509AuthorityInfoAccessEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllAuthorityInfoAccessDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509AuthorityInfoAccessDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}

BOOL WINAPI CertDllCtlUsageEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssX509CtlUsageEncode(
        dwCertEncodingType,
        lpszStructType,
        pInfo,
        pbEncoded,
        pcbEncoded
        );
}

BOOL WINAPI CertDllCtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    return OssX509CtlUsageDecode(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pInfo,
        pcbInfo
        );
}


typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

static const OID_REG_ENTRY RegEncodeTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, "CertDllKeygenRequestInfoEncode",
    X509_UNICODE_NAME_VALUE, "CertDllUnicodeNameValueEncode",
    X509_INTEGER, "CertDllIntegerEncode",
    X509_CHOICE_OF_TIME, "CertDllChoiceOfTimeEncode",
    X509_SEQUENCE_OF_ANY, "CertDllSequenceOfAnyEncode",
    X509_CRL_DIST_POINTS, "CertDllCrlDistPointsEncode",
    X509_AUTHORITY_KEY_ID2, "CertDllAuthorityKeyId2Encode",
    szOID_CRL_DIST_POINTS, "CertDllCrlDistPointsEncode",
    szOID_AUTHORITY_KEY_IDENTIFIER2, "CertDllAuthorityKeyId2Encode",
    X509_OCTET_STRING, "CertDllOctetStringEncode",
    X509_BITS, "CertDllBitsEncode",
    X509_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessEncode",
    szOID_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessEncode",
    X509_ENHANCED_KEY_USAGE, "CertDllCtlUsageEncode",
    szOID_ENHANCED_KEY_USAGE, "CertDllCtlUsageEncode",
};
#define REG_ENCODE_COUNT (sizeof(RegEncodeTable) / sizeof(RegEncodeTable[0]))

static const OID_REG_ENTRY RegDecodeTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, "CertDllKeygenRequestInfoDecode",
    X509_UNICODE_NAME_VALUE, "CertDllUnicodeNameValueDecode",
    X509_INTEGER, "CertDllIntegerDecode",
    X509_CHOICE_OF_TIME, "CertDllChoiceOfTimeDecode",
    X509_SEQUENCE_OF_ANY, "CertDllSequenceOfAnyDecode",
    X509_CRL_DIST_POINTS, "CertDllCrlDistPointsDecode",
    X509_AUTHORITY_KEY_ID2, "CertDllAuthorityKeyId2Decode",
    szOID_CRL_DIST_POINTS, "CertDllCrlDistPointsDecode",
    szOID_AUTHORITY_KEY_IDENTIFIER2, "CertDllAuthorityKeyId2Decode",
    X509_OCTET_STRING, "CertDllOctetStringDecode",
    X509_BITS, "CertDllBitsDecode",
    X509_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessDecode",
    szOID_AUTHORITY_INFO_ACCESS, "CertDllAuthorityInfoAccessDecode",
    X509_ENHANCED_KEY_USAGE, "CertDllCtlUsageDecode",
    szOID_ENHANCED_KEY_USAGE, "CertDllCtlUsageDecode",
};
#define REG_DECODE_COUNT (sizeof(RegDecodeTable) / sizeof(RegDecodeTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509EncodeFuncTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, CertDllKeygenRequestInfoEncode,
    X509_UNICODE_NAME_VALUE, CertDllUnicodeNameValueEncode,
    X509_INTEGER, CertDllIntegerEncode,
    X509_CHOICE_OF_TIME, CertDllChoiceOfTimeEncode,
    X509_SEQUENCE_OF_ANY, CertDllSequenceOfAnyEncode,
    X509_CRL_DIST_POINTS, CertDllCrlDistPointsEncode,
    X509_AUTHORITY_KEY_ID2, CertDllAuthorityKeyId2Encode,
    szOID_CRL_DIST_POINTS, CertDllCrlDistPointsEncode,
    szOID_AUTHORITY_KEY_IDENTIFIER2, CertDllAuthorityKeyId2Encode,
    X509_OCTET_STRING, CertDllOctetStringEncode,
    X509_BITS, CertDllBitsEncode,
    X509_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessEncode,
    szOID_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessEncode,
    X509_ENHANCED_KEY_USAGE, CertDllCtlUsageEncode,
    szOID_ENHANCED_KEY_USAGE, CertDllCtlUsageEncode,
};

#define X509_ENCODE_FUNC_COUNT (sizeof(X509EncodeFuncTable) / \
                                    sizeof(X509EncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeFuncTable[] = {
    X509_KEYGEN_REQUEST_TO_BE_SIGNED, CertDllKeygenRequestInfoDecode,
    X509_UNICODE_NAME_VALUE, CertDllUnicodeNameValueDecode,
    X509_INTEGER, CertDllIntegerDecode,
    X509_CHOICE_OF_TIME, CertDllChoiceOfTimeDecode,
    X509_SEQUENCE_OF_ANY, CertDllSequenceOfAnyDecode,
    X509_CRL_DIST_POINTS, CertDllCrlDistPointsDecode,
    X509_AUTHORITY_KEY_ID2, CertDllAuthorityKeyId2Decode,
    szOID_CRL_DIST_POINTS, CertDllCrlDistPointsDecode,
    szOID_AUTHORITY_KEY_IDENTIFIER2, CertDllAuthorityKeyId2Decode,
    X509_OCTET_STRING, CertDllOctetStringDecode,
    X509_BITS, CertDllBitsDecode,
    X509_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessDecode,
    szOID_AUTHORITY_INFO_ACCESS, CertDllAuthorityInfoAccessDecode,
    X509_ENHANCED_KEY_USAGE, CertDllCtlUsageDecode,
    szOID_ENHANCED_KEY_USAGE, CertDllCtlUsageDecode,
};

#define X509_DECODE_FUNC_COUNT (sizeof(X509DecodeFuncTable) / \
                                    sizeof(X509DecodeFuncTable[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI CryptFixDllMain(HMODULE hInst, ULONG  ulReason, LPVOID lpReserved)
{
    BOOL    fRet;

#   if DBG
#if 0
        //
        // Due to an apparent bug in the Win95 loader, the CRT gets unloaded
        // too early in some circumstances. In particular, it can get unloaded
        // before this routine executes at process detach time. This can cause
        // faults when executing this routine, and also when executing the rest
        // of CRYPT32:CRT_INIT, after this initroutine returns. Ergo, we do an
        // extra load of the CRT, to be sure it stays around long enough.
        //
        if ((ulReason == DLL_PROCESS_ATTACH) && (!(FIsWinNT())))
        {
            LoadLibrary( L"MSVCRTD.DLL");
        }
#endif

        DebugDllMain(hInst, ulReason, lpReserved);

#   endif // DBG

    UnicodeDllMain(hInst, ulReason, lpReserved);

    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
            if (0 == (hX509OssGlobal = I_CryptInstallOssGlobal(ossx509, 0, NULL)))
            {
                //goto CryptInstallOssGlobalError;
		goto ErrorReturn;
            }

            if (NULL == (hX509EncodeFuncSet = CryptInitOIDFunctionSet(
                                                CRYPT_OID_ENCODE_OBJECT_FUNC, 0)))
            {
                //goto CryptInitOIDFunctionSetError;
		goto ErrorReturn;
            }

            if (NULL == (hX509DecodeFuncSet = CryptInitOIDFunctionSet(
                                                CRYPT_OID_DECODE_OBJECT_FUNC, 0)))
            {
                //goto CryptInitOIDFunctionSetError;
		goto ErrorReturn;
            }

            if (!(CryptInstallOIDFunctionAddress(   hInst,
                                                    X509_ASN_ENCODING,
                                                    CRYPT_OID_ENCODE_OBJECT_FUNC,
                                                    X509_ENCODE_FUNC_COUNT,
                                                    X509EncodeFuncTable,
                                                    0)))
            {
                //goto CryptInstallOIDFunctionAddressError;
		goto ErrorReturn;
            }

            if (!(CryptInstallOIDFunctionAddress(   hInst,
                                                    X509_ASN_ENCODING,
                                                    CRYPT_OID_DECODE_OBJECT_FUNC,
                                                    X509_DECODE_FUNC_COUNT,
                                                    X509DecodeFuncTable,
                                                    0)))
            {
                //goto CryptInstallOIDFunctionAddressError;
		goto ErrorReturn;
            }


            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

//TRACE_ERROR(CryptInstallOssGlobalError)
//TRACE_ERROR(CryptInitOIDFunctionSetError)
//TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\browsedi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       browsedi.cpp
//
//--------------------------------------------------------------------------

//
// BrowseDir.cpp
//


#include "pch.cpp"
#pragma hdrstop

#include <shlobj.h>

#define __dwFILE__	__dwFILE_OCMSETUP_BROWSEDI_CPP__


int 
InitStartDir( 
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData)
{
    // we just capture Init Message
    if (BFFM_INITIALIZED == uMsg)
    {
        // we expect lpData to be our start path
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
    }

    return 0;
}
 



BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle,
                BOOL bRemoveTrailingBackslash )
{
    LPITEMIDLIST pItem = NULL;
    TCHAR szPath[MAX_PATH+1];
    BOOL bGotLocation = FALSE;

    BROWSEINFO bi;
    ZeroMemory(&bi, sizeof(bi));
    bi.hwndOwner = hwndParent;

    // initial folder
    if (pszInitialDir != NULL)
    {
        bi.lpfn = InitStartDir;
        bi.lParam = (LPARAM)pszInitialDir;
    }

    bi.pszDisplayName = szPath;   
    bi.lpszTitle = pszDialogTitle;
    bi.ulFlags = BIF_USENEWUI  |
                 BIF_SHAREABLE |
                 BIF_RETURNONLYFSDIRS;            // return only directories in the filesystem, not other folders


    pItem = SHBrowseForFolder(&bi);
    if (pItem == NULL)
        goto Ret;

    bGotLocation = SHGetPathFromIDList(pItem, szPath);
    if (!bGotLocation)
        goto Ret;
    
    CSASSERT((_tcslen(szPath)+1)*sizeof(TCHAR) <= (ULONG)cchBuf);
    if ((_tcslen(szPath)+1)*sizeof(TCHAR) > (ULONG)cchBuf)
        return FALSE;

    _tcscpy(pszBuf, szPath);
   
Ret:
    LPMALLOC pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
    {
       if (pItem)
           pMalloc->Free(pItem);
       if (bi.pidlRoot)
           pMalloc->Free((ITEMIDLIST*)bi.pidlRoot);

       pMalloc->Release();
    }

    return bGotLocation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\cspenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cspenum.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>
#include <assert.h>

#include "initcert.h"
#include "cscsp.h"
#include "cspenum.h"
#include "certmsg.h"


#define __dwFILE__	__dwFILE_OCMSETUP_CSPENUM_CPP__


WCHAR const g_wszRegKeyCSP[] = wszREGKEYCSP;
WCHAR const g_wszRegKeyEncryptionCSP[] = wszREGKEYENCRYPTIONCSP;
WCHAR const g_wszRegProviderType[] = wszREGPROVIDERTYPE;
WCHAR const g_wszRegProvider[] = wszREGPROVIDER;
WCHAR const g_wszRegHashAlgorithm[] = wszHASHALGORITHM;
TCHAR const g_wszRegEncryptionAlgorithm[] = wszENCRYPTIONALGORITHM;
WCHAR const g_wszRegMachineKeyset[] = wszMACHINEKEYSET;
WCHAR const g_wszRegKeySize[] = wszREGKEYSIZE;


// Hash Enumeration code begins
// move point to link list top
CSP_HASH* 
topHashInfoList(CSP_HASH *pHashInfoList)
{
    while (pHashInfoList->last)
    {
        pHashInfoList = pHashInfoList->last;
    }
    return pHashInfoList;
}

// move point to link list end
CSP_HASH* 
endHashInfoList(CSP_HASH *pHashInfoList)
{
    while (pHashInfoList->next)
    {
        pHashInfoList = pHashInfoList->next;
    }
    return pHashInfoList;
}

// add one more CSP_INFO
void 
addHashInfo(CSP_HASH *pHashInfoList, CSP_HASH *pHashInfo)
{
    // add
    pHashInfoList->next = pHashInfo;
    pHashInfo->last = pHashInfoList;
}

// add one more CSP_INFO to end
void 
addHashInfoToEnd(CSP_HASH *pHashInfoList, CSP_HASH *pHashInfo)
{
    // go to end
    pHashInfoList = endHashInfoList(pHashInfoList);
    // add
    pHashInfoList->next = pHashInfo;
    pHashInfo->last = pHashInfoList;
}

CSP_HASH *
newHashInfo(
    ALG_ID idAlg,
    CHAR *pszName)
{
    CSP_HASH *pHashInfo = NULL;

    if (NULL != pszName)
    {
        pHashInfo = (CSP_HASH*)LocalAlloc(LMEM_FIXED, sizeof(CSP_HASH));
        if (NULL == pHashInfo)
        {
            SetLastError(E_OUTOFMEMORY);
        }
        else
        {
            pHashInfo->pwszName = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                    (strlen(pszName)+1)*sizeof(WCHAR));
            if (NULL == pHashInfo->pwszName)
            {
		LocalFree(pHashInfo);
                SetLastError(E_OUTOFMEMORY);
		return NULL;
            }
            else
            {
                // create a new one
                pHashInfo->idAlg = idAlg;
                mbstowcs(pHashInfo->pwszName, pszName, strlen(pszName)+1);
                pHashInfo->last = NULL;
                pHashInfo->next = NULL;
            }
        }
    }
    return pHashInfo;
}


void 
freeHashInfo(CSP_HASH *pHashInfo)
{
    if (pHashInfo)
    {
        if (pHashInfo->pwszName)
        {
            LocalFree(pHashInfo->pwszName);
        }
        LocalFree(pHashInfo);
    }
}

void
freeHashInfoList(
    CSP_HASH *pHashInfoList)
{
    CSP_HASH *pNext;

    if (pHashInfoList)
    {
        // go top
        pHashInfoList = topHashInfoList(pHashInfoList);
        do
        {
			pNext = pHashInfoList->next;
            freeHashInfo(pHashInfoList);
            pHashInfoList = pNext;
        } while (pHashInfoList);
    }
}

HRESULT
GetHashList(
    DWORD dwProvType,
    WCHAR *pwszProvName,
    CSP_HASH **pHashInfoList)
{
    HRESULT       hr;
    HCRYPTPROV    hProv = NULL;
    CHAR          *pszName = NULL;
    DWORD         i;
    ALG_ID        idAlg;
    DWORD         cbData;
    BYTE         *pbData;
    DWORD         dwFlags;

    BOOL          fSupportSigningFlag = FALSE; // none-ms csp likely
    PROV_ENUMALGS_EX EnumAlgsEx;
    PROV_ENUMALGS    EnumAlgs;

    CSP_HASH      *pHashInfo = NULL;
    CSP_HASH      *pHashInfoNode;

    if (NULL == pwszProvName)
    {
        // the reason why I check this because
        // NULL is a valid input for CryptAcquireContext()
        hr = E_INVALIDARG;
	_JumpError(hr, error, "no provider name");
    }
    if (!myCertSrvCryptAcquireContext(
				&hProv,
				NULL,
				pwszProvName,
				dwProvType,
				CRYPT_VERIFYCONTEXT,
				FALSE))
    {
        hr = myHLastError();
        if (NULL != hProv)
        {
            hProv = NULL;
            _PrintError(hr, "CSP returns a non-null handle");
        }
	_JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
    }

    // check if csp support signing flag
    if (CryptGetProvParam(hProv, PP_ENUMEX_SIGNING_PROT, NULL, &cbData, 0))
    {
        fSupportSigningFlag = TRUE;
    }

    dwFlags = CRYPT_FIRST;
    for (i = 0; ; dwFlags = 0, i++)
    {
        if (fSupportSigningFlag)
        {
            cbData = sizeof(EnumAlgsEx);
	    pbData = (BYTE *) &EnumAlgsEx;
        }
        else
        {
	    cbData = sizeof(EnumAlgs);
	    pbData = (BYTE *) &EnumAlgs;
        }
	ZeroMemory(pbData, cbData);
	if (!CryptGetProvParam(
			    hProv,
			    fSupportSigningFlag?
				PP_ENUMALGS_EX : PP_ENUMALGS,
			    pbData,
			    &cbData,
			    dwFlags))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	    {
		// out of for loop
		break;
	    }
	    _JumpError(hr, error, "CryptGetProvParam");
	}
	idAlg = fSupportSigningFlag? EnumAlgsEx.aiAlgid : EnumAlgs.aiAlgid;

	if (ALG_CLASS_HASH == GET_ALG_CLASS(idAlg))
	{
            if (fSupportSigningFlag)
            {
                if (0 == (EnumAlgsEx.dwProtocols & CRYPT_FLAG_SIGNING))
                {
                    // this means this hash doesn't support signing
                    continue; // skip
                }
                pszName = EnumAlgsEx.szLongName;

                pszName = EnumAlgsEx.szName;
            }
            else
            {
                pszName = EnumAlgs.szName;
            }

	    pHashInfoNode = newHashInfo(idAlg, pszName); // 2nd parm: name
	    if (NULL == pHashInfoNode)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "newHashInfo");
	    }

	    if (NULL == pHashInfo)
	    {
		pHashInfo = pHashInfoNode;
	    }
	    else
	    {
		// add to temp list
		addHashInfoToEnd(pHashInfo, pHashInfoNode);
	    }
        }
    }

    // pass it back to caller
    *pHashInfoList = pHashInfo;
    pHashInfo = NULL;
    hr = S_OK;

error:
    if (NULL != pHashInfo)
    {
	freeHashInfoList(pHashInfo);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;
}


// CSP Enumeration code begins
// move point to link list top
CSP_INFO* 
topCSPInfoList(CSP_INFO *pCSPInfoList)
{
    while (pCSPInfoList->last)
    {
        pCSPInfoList = pCSPInfoList->last;
    }
    return pCSPInfoList;
}


// move point to link list end
CSP_INFO* 
endCSPInfoList(CSP_INFO *pCSPInfoList)
{
    while (pCSPInfoList->next)
    {
        pCSPInfoList = pCSPInfoList->next;
    }
    return pCSPInfoList;
}

// find first matched csp info from the list
CSP_INFO*
findCSPInfoFromList(
    CSP_INFO    *pCSPInfoList,
    WCHAR const *pwszProvName,
    const DWORD  dwProvType)
{
    while (NULL != pCSPInfoList)
    {
        if (0 == wcscmp(pCSPInfoList->pwszProvName, pwszProvName) &&
            pCSPInfoList->dwProvType == dwProvType)
        {
            // found it
            break;
        }
        pCSPInfoList = pCSPInfoList->next;
    }
    return pCSPInfoList;
}

// add one more CSP_INFO
void 
addCSPInfo(CSP_INFO *pCSPInfoList, CSP_INFO *pCSPInfo)
{
    // add
    pCSPInfoList->next = pCSPInfo;
    pCSPInfo->last = pCSPInfoList;
}


// add one more CSP_INFO to end
void 
addCSPInfoToEnd(CSP_INFO *pCSPInfoList, CSP_INFO *pCSPInfo)
{
    // go to end
    pCSPInfoList = endCSPInfoList(pCSPInfoList);
    // add
    pCSPInfoList->next = pCSPInfo;
    pCSPInfo->last = pCSPInfoList;
}


void 
freeCSPInfo(CSP_INFO *pCSPInfo)
{
    if (pCSPInfo)
    {
        if (pCSPInfo->pwszProvName)
        {
            LocalFree(pCSPInfo->pwszProvName);
        }
        if (pCSPInfo->pHashList)
        {
            freeHashInfoList(pCSPInfo->pHashList);
        }
        LocalFree(pCSPInfo);
    }
}


CSP_INFO *
newCSPInfo(
    DWORD    dwProvType,
    WCHAR   *pwszProvName)
{
    CSP_INFO *pCSPInfo = NULL;
    CSP_HASH *pHashList = NULL;

    if (NULL != pwszProvName)
    {
        // get all hash algorithms under this csp
        if (S_OK != GetHashList(dwProvType, pwszProvName, &pHashList))
        {
            // certsrv needs csp with hash support
            goto done;
        }
        else
        {
            pCSPInfo = (CSP_INFO*)LocalAlloc(LMEM_FIXED, sizeof(CSP_INFO));
            if (NULL == pCSPInfo)
            {
                freeHashInfoList(pHashList);
                SetLastError(E_OUTOFMEMORY);
            }
            else
            {
                pCSPInfo->pwszProvName = (WCHAR*)LocalAlloc(LMEM_FIXED,
                              (wcslen(pwszProvName) + 1) * sizeof(WCHAR));
                if (NULL == pCSPInfo->pwszProvName)
                {
                    freeHashInfoList(pHashList);
		    LocalFree(pCSPInfo);
                    pCSPInfo = NULL;
                    SetLastError(E_OUTOFMEMORY);
		    goto done;
                }
                else
                {
                    // create a new one
                    pCSPInfo->dwProvType = dwProvType;
                    pCSPInfo->fMachineKeyset = TRUE; // assume???
                    wcscpy(pCSPInfo->pwszProvName, pwszProvName);
                    pCSPInfo->pHashList = pHashList;
                    pCSPInfo->last = NULL;
                    pCSPInfo->next = NULL;
                }
            }
        }
    }
done:
    return pCSPInfo;
}


void
FreeCSPInfoList(CSP_INFO *pCSPInfoList)
{
    CSP_INFO *pNext;

    if (pCSPInfoList)
    {
        // go top
        pCSPInfoList = topCSPInfoList(pCSPInfoList);
        do
        {
            pNext = pCSPInfoList->next;
            freeCSPInfo(pCSPInfoList);
            pCSPInfoList = pNext;
        } while (pCSPInfoList);
    }
}

HRESULT
GetCSPInfoList(CSP_INFO **pCSPInfoList)
{
    HRESULT hr;
    long i;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;
    CSP_INFO *pCSPInfo = NULL;
    CSP_INFO *pCSPInfoNode;

    for (i = 0; ; i++)
    {
	// get provider name

	hr = myEnumProviders(
			i,
			NULL,
			0,
			&dwProvType,
			&pwszProvName);
	if (S_OK != hr)
	{
	    hr = myHLastError();
	    CSASSERT(
		HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr);
	    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr)
	    {
		// no more providers under type, terminate loop
		break;
	    }

	    // invalid CSP entry, skip it

	    continue;
	}
	
        if (PROV_RSA_FULL == dwProvType ||
	        PROV_RSA_SIG == dwProvType ||
	        PROV_DSS == dwProvType ||
	        PROV_MS_EXCHANGE == dwProvType ||
	        PROV_SSL == dwProvType)
	    {
	        if (NULL == pCSPInfo)
	        {
		    // first csp info
		    pCSPInfo = newCSPInfo(dwProvType, pwszProvName);
	        }
	        else
	        {
		    // create a node
		    pCSPInfoNode = newCSPInfo(dwProvType, pwszProvName);
		    if (NULL != pCSPInfoNode)
		    {
		        // add to list
		        addCSPInfoToEnd(pCSPInfo, pCSPInfoNode);
		    }
	        }
	    }
	LocalFree(pwszProvName);
	pwszProvName = NULL;
    }

    // pass back to caller

    *pCSPInfoList = pCSPInfo;
    hr = S_OK;

//error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
SetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszCAName,
    IN DWORD dwProvType,
    IN WCHAR const *pwszProvName,
    IN ALG_ID idAlg,
    IN BOOL fMachineKeyset,
    IN DWORD dwKeySize)
{
    HRESULT hr;
    HKEY hCertSrvKey = NULL;
    HKEY hCertSrvCAKey = NULL;
    HKEY hCertSrvCSPKey = NULL;
    DWORD dwDisposition;
    
    hr = RegCreateKeyEx(
		    HKEY_LOCAL_MACHINE,
		    wszREGKEYCONFIGPATH,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hCertSrvKey,
		    &dwDisposition);
    _JumpIfErrorStr(hr, error, "RegCreateKeyEx", wszREGKEYCONFIGPATH);

    hr = RegCreateKeyEx(
		    hCertSrvKey,
		    pwszCAName,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hCertSrvCAKey,
		    &dwDisposition);
    _JumpIfErrorStr(hr, error, "RegCreateKeyEx", pwszCAName);

    hr = RegCreateKeyEx(
		    hCertSrvCAKey,
		    fEncryptionCSP? g_wszRegKeyEncryptionCSP : g_wszRegKeyCSP,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hCertSrvCSPKey,
		    &dwDisposition);
    _JumpIfErrorStr(hr, error, "RegCreateKeyEx", g_wszRegKeyCSP);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProviderType,
		    0,
		    REG_DWORD,
		    (BYTE const *) &dwProvType,
		    sizeof(dwProvType));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegProviderType);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProvider,
		    0,
		    REG_SZ,
		    (BYTE const *) pwszProvName,
		    wcslen(pwszProvName) * sizeof(WCHAR));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegProvider);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    fEncryptionCSP? 
			g_wszRegEncryptionAlgorithm :
			g_wszRegHashAlgorithm,
		    0,
		    REG_DWORD,  // questionable???
		    (BYTE const *) &idAlg,
		    sizeof(idAlg));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegHashAlgorithm);

    hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegMachineKeyset,
		    0,
		    REG_DWORD,
		    (BYTE const *) &fMachineKeyset,
		    sizeof(fMachineKeyset));
    _JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegMachineKeyset);

    if (0 != dwKeySize)
    {
	hr = RegSetValueEx(
		    hCertSrvCSPKey,
		    g_wszRegKeySize,
		    0,
		    REG_DWORD,
		    (BYTE const *) &dwKeySize,
		    sizeof(dwKeySize));
	_JumpIfErrorStr(hr, error, "RegSetValueEx", g_wszRegKeySize);
    }

error:
    if (NULL != hCertSrvCSPKey)
    {
        RegCloseKey(hCertSrvCSPKey);
    }
    if (NULL != hCertSrvCAKey)
    {
        RegCloseKey(hCertSrvCAKey);
    }
    if (NULL != hCertSrvKey)
    {
        RegCloseKey(hCertSrvKey);
    }
    return(myHError(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\csocm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       csocm.cpp
//
//  Contents:   OCM component DLL for running the Certificate
//              Server setup.
//
//  Functions:
//
//  History:    12/13/96        TedM    Created Original Version
//              04/07/97        JerryK  Rewrite for Cert Server
//              04/??/97        JerryK  Stopped updating these comments since
//                                      every other line changes every day.
//          08/98       XTan    Major structure change
//
//  Notes:
//
//      This sample OCM component DLL can be the component DLL
//      for multiple components.  It assumes that a companion sample INF
//      is being used as the per-component INF, with private data in the 
//      following form.
//
//      [<pwszComponent>,<pwszSubComponent>]
//      Bitmap = <bitmapresourcename>
//      VerifySelect = 0/1
//      VerifyDeselect = 0/1
//      ;
//      ; follow this with install stuff such as CopyFiles= sections, etc.
//
//------------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "msg.h"
#include "certmsg.h"
#include "setuput.h"
#include "setupids.h"
#include "clibres.h"
#include "csresstr.h"

// defines
#define cwcMESSAGETEXT    250
#define cwcINFVALUE       250
#define wszSMALLICON      L"_SmallIcon"
#define wszUNINSTALL      L"_Uninstall"
#define wszUPGRADE        L"_Upgrade"
#define wszINSTALL        L"_Install"
#define wszVERIFYSELECT   L"_VerifySelect"
#define wszVERIFYDESELECT L"_VerifyDeselect"

#define wszCONFIGTITLE       L"Title"
#define wszCONFIGCOMMAND     L"ConfigCommand"
#define wszCONFIGARGS        L"ConfigArgs"
#define wszCONFIGTITLEVAL    L"Certificate Services"
#define wszCONFIGCOMMANDVAL  L"sysocmgr.exe"
#define wszCONFIGARGSVAL     L"/i:certmast.inf /x"

#define __dwFILE__	__dwFILE_OCMSETUP_CSOCM_CPP__


// globals
PER_COMPONENT_DATA g_Comp;              // Top Level component
HINSTANCE g_hInstance; // get rid of it????

// find out if certsrv post setup is finished by checking
// registry entries. ie. finish CYS?
HRESULT
CheckPostBaseInstallStatus(
    OUT BOOL *pfFinished)
{
    HRESULT hr;
    HKEY    hKey = NULL;
    DWORD   dwSize = 0;
    DWORD   dwType = REG_NONE;

    //init
    *pfFinished = TRUE;

    if (ERROR_SUCCESS ==  RegOpenKeyEx(
                              HKEY_LOCAL_MACHINE,
                              wszREGKEYCERTSRVTODOLIST,
                              0,
                              KEY_READ,
                              &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(
                                 hKey,
                                 wszCONFIGCOMMAND,
                                 NULL,
                                 &dwType,
                                 NULL, // only query size
                                 &dwSize) &&
            REG_SZ == dwType)
        {
            dwType = REG_NONE;
            if (ERROR_SUCCESS == RegQueryValueEx(
                                     hKey,
                                     wszCONFIGARGS,
                                     NULL,
                                     &dwType,
                                     NULL, // only query size
                                     &dwSize) &&
                REG_SZ == dwType)
            {
                dwType = REG_NONE;
                if (ERROR_SUCCESS == RegQueryValueEx(
                                         hKey,
                                         wszCONFIGTITLE,
                                         NULL,
                                         &dwType,
                                         NULL, // only query size
                                         &dwSize) &&
                    REG_SZ == dwType)
                {
                    //all entries exist
                    *pfFinished = FALSE;
                }
            }
        }
    }

    hr = S_OK;
//error:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return hr;
}


HRESULT
InitComponentAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN     HINSTANCE           hDllHandle)
{
    HRESULT hr;

    ZeroMemory(pComp, sizeof(PER_COMPONENT_DATA));
    pComp->hInstance = hDllHandle;
    g_hInstance = hDllHandle; //get rid of it????
    pComp->hrContinue = S_OK;
    pComp->pwszCustomMessage = NULL;
    pComp->fUnattended = FALSE;
    pComp->pwszUnattendedFile = NULL;
    pComp->pwszServerName = NULL;
    pComp->pwszServerNameOld = NULL;
    pComp->dwInstallStatus = 0x0;
    pComp->fPostBase = FALSE;
    (pComp->CA).pServer = NULL;
    (pComp->CA).pClient = NULL;

    hr = S_OK;
//error:
    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   DllMain( . . . . )
//
//  Synopsis:   DLL Entry Point.
//
//  Arguments:  [DllHandle]     DLL module handle.
//              [Reason]        Reasons for entry into DLL.
//              [Reserved]      Reserved.
//
//  Returns:    BOOL
//
//  History:    04/07/97        JerryK  Created (again)
// 
//-------------------------------------------------------------------------
BOOL WINAPI
DllMain(
    IN HMODULE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved)
{
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;
    switch(Reason) 
    {
        case DLL_PROCESS_ATTACH:
            DBGPRINT((DBG_SS_CERTOCMI, "Process Attach\n"));
            // component initialization
            InitComponentAttributes(&g_Comp, DllHandle);

            // Fall through to process first thread

        case DLL_THREAD_ATTACH:
            b = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            DBGPRINT((DBG_SS_CERTOCMI, "Process Detach\n"));
            myFreeResourceStrings("certocm.dll");
	    myFreeColumnDisplayNames();
            myRegisterMemDump();
	    csiLogClose();
            break;

        case DLL_THREAD_DETACH:
            break;
    }
    return b;
}

extern UNATTENDPARM aUnattendParmClient[];
extern UNATTENDPARM aUnattendParmServer[];

SUBCOMP g_aSubComp[] =
{
    {
        L"certsrv",             // pwszSubComponent
        cscTopLevel,            // cscSubComponent
        0,                      // InstallFlags
        0,                      // UninstallFlags
        0,                      // ChangeFlags
        0,                      // UpgradeFlags
        0,                      // EnabledFlags
        0,                      // SetupStatusFlags
        FALSE,                  // fDefaultInstallUnattend
        FALSE,                  // fInstallUnattend
        NULL                    // aUnattendParm
    },
    {
        wszSERVERSECTION,       // pwszSubComponent
        cscServer,              // cscSubComponent
        IS_SERVER_INSTALL,      // InstallFlags
        IS_SERVER_REMOVE,       // UninstallFlags
        IS_SERVER_CHANGE,       // ChangeFlags
        IS_SERVER_UPGRADE,	// UpgradeFlags
        IS_SERVER_ENABLED,	// EnabledFlags
	SETUP_SERVER_FLAG,	// SetupStatusFlags
        TRUE,                   // fDefaultInstallUnattend
        FALSE,                  // fInstallUnattend
        aUnattendParmServer     // aUnattendParm
    },
    {
        wszCLIENTSECTION,       // pwszSubComponent
        cscClient,              // cscSubComponent
        IS_CLIENT_INSTALL,      // InstallFlags
        IS_CLIENT_REMOVE,       // UninstallFlags
        IS_CLIENT_CHANGE,       // ChangeFlags
        IS_CLIENT_UPGRADE,	// UpgradeFlags
        IS_CLIENT_ENABLED,	// EnabledFlags
	SETUP_CLIENT_FLAG,	// SetupStatusFlags
        TRUE,                   // fDefaultInstallUnattend
        FALSE,                  // fInstallUnattend
        aUnattendParmClient     // aUnattendParm
    },
    {
        NULL,                   // pwszSubComponent
    }
};


SUBCOMP *
TranslateSubComponent(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent)
{
    SUBCOMP *psc;

    if (NULL == pwszSubComponent)
    {
        pwszSubComponent = pwszComponent;
    }
    for (psc = g_aSubComp; NULL != psc->pwszSubComponent; psc++)
    {
        if (0 == lstrcmpi(psc->pwszSubComponent, pwszSubComponent)) 
        {
            break;
        }
    }
    if (NULL == psc->pwszSubComponent)
    {
        psc = NULL;
    }
    return(psc);
}


SUBCOMP const *
LookupSubComponent(
    IN CertSubComponent SubComp)
{
    SUBCOMP const *psc;

    for (psc = g_aSubComp; NULL != psc->pwszSubComponent; psc++)
    {
        if (psc->cscSubComponent == SubComp)
        {
            break;
        }
    }
    CSASSERT(NULL != psc);
    return(psc);
}


BOOL fDebugSupress = TRUE;

HRESULT
UpdateSubComponentInstallStatus(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    BOOL fWasEnabled;
    BOOL fIsEnabled;
    DWORD InstallFlags;
    SUBCOMP const *psc;

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    fWasEnabled = certocmWasEnabled(pComp, psc->cscSubComponent);
    fIsEnabled = certocmIsEnabled(pComp, psc->cscSubComponent);
    CSILOGDWORD(IDS_LOG_WAS_ENABLED, fWasEnabled);
    CSILOGDWORD(IDS_LOG_IS_ENABLED, fIsEnabled);

    InstallFlags = psc->InstallFlags | psc->ChangeFlags | psc->EnabledFlags;
    if (!fWasEnabled)
    {
	if (fIsEnabled)
        {
	    // install case
	    pComp->dwInstallStatus |= InstallFlags;
        }
        else // !fIsEnabled
        {
	    // this is from check then uncheck, should remove the bit
	    // turn off both bits

	    pComp->dwInstallStatus &= ~InstallFlags;
        }
    }
    else // fWasEnabled
    {
        if (pComp->fPostBase &&
            (pComp->Flags & SETUPOP_STANDALONE) )
        {
            // was installed, invoke from post setup
            // this is install case

            pComp->dwInstallStatus |= InstallFlags;
        }
        else if (pComp->Flags & SETUPOP_NTUPGRADE)
        {
            // if was installed and now in upgrade mode, upgrade case

            pComp->dwInstallStatus |= psc->UpgradeFlags | psc->EnabledFlags;
        }
        else if (!fIsEnabled)
        {
            // uninstall case

	    pComp->dwInstallStatus &= ~psc->EnabledFlags;
            pComp->dwInstallStatus |= psc->UninstallFlags | psc->ChangeFlags;
        }
        else // fIsEnabled
        {
	    pComp->dwInstallStatus |= psc->EnabledFlags;
#if DBG_CERTSRV
            BOOL fUpgrade = FALSE;

            hr = myGetCertRegDWValue(
                            NULL,
                            NULL,
                            NULL,
                            L"EnforceUpgrade",
                            (DWORD *) &fUpgrade);
            if (S_OK == hr && fUpgrade)
            {
		pComp->dwInstallStatus |= psc->UpgradeFlags;
            }
#endif //DBG_CERTSRV
	}   // end fIsEnabled else
    } // end fWasEnabled else


    // after all of this, change upgrade->uninstall if not supported
    // detect illegal upgrade
    if (pComp->dwInstallStatus & IS_SERVER_UPGRADE)
    {
        hr = DetermineServerUpgradePath(pComp);
        _JumpIfError(hr, error, "DetermineServerUpgradePath");
    }
    else if (pComp->dwInstallStatus & IS_CLIENT_UPGRADE)
    {
        hr = DetermineClientUpgradePath(pComp);
        _JumpIfError(hr, error, "LoadAndDetermineClientUpgradeInfo");
    }
    if ((pComp->dwInstallStatus & IS_SERVER_UPGRADE) ||
        (pComp->dwInstallStatus & IS_CLIENT_UPGRADE))
    {
        CSASSERT(pComp->UpgradeFlag != CS_UPGRADE_UNKNOWN);
        if (CS_UPGRADE_UNSUPPORTED == pComp->UpgradeFlag)
        {
            pComp->dwInstallStatus &= ~InstallFlags;
            pComp->dwInstallStatus |= psc->UninstallFlags | psc->ChangeFlags;
        }
    }



    CSILOG(
	S_OK,
	IDS_LOG_INSTALL_STATE,
	pwszSubComponent,
	NULL,
	&pComp->dwInstallStatus);
    hr = S_OK;

error:
    return hr;
}


HRESULT
certocmOcPreInitialize(
    IN WCHAR const *pwszComponent,
    IN UINT Flags,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;

    *pulpRet = 0;

    DBGPRINT((DBG_SS_CERTOCMI, "OC_PREINITIALIZE(%ws, %x)\n", pwszComponent, Flags));

    myVerifyResourceStrings(g_hInstance);

    // Return value is flag telling OCM which char width we want to run in.

#ifdef UNICODE
    *pulpRet = OCFLAG_UNICODE & Flags;
#else
    *pulpRet = OCFLAG_ANSI & Flags;
#endif

    hr = S_OK;
//error:
    return hr;
}


// Allocate and initialize a new component.
//
// Return code is Win32 error indicating outcome.  ERROR_CANCELLED tells OCM to
// cancel the installation.

HRESULT
certocmOcInitComponent(
    IN HWND                      hwnd,
    IN WCHAR const              *pwszComponent,
    IN OUT SETUP_INIT_COMPONENT *pInitComponent,
    IN OUT PER_COMPONENT_DATA   *pComp,
    OUT ULONG_PTR               *pulpRet)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    HKEY hkey = NULL;
    WCHAR awc[30];
    WCHAR *pwc;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_INIT_COMPONENT(%ws, %p)\n",
            pwszComponent,
            pInitComponent));

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;
    *pulpRet = ERROR_CANCELLED;

    if (OCMANAGER_VERSION <= pInitComponent->OCManagerVersion)
    {
        pInitComponent->OCManagerVersion = OCMANAGER_VERSION;
    }

    // Allocate a new component string.
    pComp->pwszComponent = (WCHAR *) LocalAlloc(LPTR,
                        (wcslen(pwszComponent) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pComp->pwszComponent);

    wcscpy(pComp->pwszComponent, pwszComponent);

    // OCM passes in some information that we want to save, like the open
    // handle to our per-component INF.  As long as we have a per-component INF,
    // append-open any layout file that is associated with it, in preparation
    // for later inf-based file queueing operations.
    //
    // We save away certain other stuff that gets passed to us now, since OCM
    // doesn't guarantee that the SETUP_INIT_COMPONENT will persist beyond the
    // processing of this one interface routine.

    if (INVALID_HANDLE_VALUE != pInitComponent->ComponentInfHandle &&
        NULL != pInitComponent->ComponentInfHandle)
    {
        pComp->MyInfHandle = pInitComponent->ComponentInfHandle;
    }
    else
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid inf handle");
    }

    if (NULL != pComp->MyInfHandle)
    {
        if (!SetupOpenAppendInfFile(NULL, pComp->MyInfHandle, NULL))
        {
            // SetupOpenAppendInfFile:
            // If Filename (Param1) is NULL, the INF filename is 
            // retrieved from the LayoutFile value of the Version 
            // section in the existing INF file.
            //
            // If FileName was not specified and there was no 
            // LayoutFile value in the Version section of the 
            // existing INF File, GetLastError returns ERROR_INVALID_DATA.

            hr = myHLastError();
            _PrintErrorStr(hr, "SetupOpenAppendInfFile", pwszComponent);
        }
    }


    pComp->HelperRoutines = pInitComponent->HelperRoutines;

    pComp->Flags = pInitComponent->SetupData.OperationFlags;

    pwc = awc;
    pwc += wsprintf(pwc, L"0x");
    if (0 != (DWORD) (pComp->Flags >> 32))
    {
	pwc += wsprintf(pwc, L"%x:", (DWORD) (pComp->Flags >> 32));
    }
    wsprintf(pwc, L"%08x", (DWORD) pComp->Flags);
    CSILOG(S_OK, IDS_LOG_OPERATIONFLAGS, awc, NULL, NULL);
    CSILOGDWORD(IDS_LOG_POSTBASE, pComp->fPostBase);

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, wszREGKEYOCMSUBCOMPONENTS, &hkey);
    if (S_OK == hr)
    {
	DWORD dwType;
	DWORD dwValue;
	DWORD cb;
	DWORD const *pdw;
	
	cb = sizeof(dwValue);
	hr = RegQueryValueEx(
		        hkey,
		        wszSERVERSECTION,
		        0,
		        &dwType,
		        (BYTE *) &dwValue,
		        &cb);
	pdw = NULL;
	if (S_OK == hr && REG_DWORD == dwType && sizeof(dwValue) == cb)
	{
	    pdw = &dwValue;
	}
	CSILOG(hr, IDS_LOG_REGSTATE, wszSERVERSECTION, NULL, pdw);
	
	cb = sizeof(dwValue);
	hr = RegQueryValueEx(
		        hkey,
		        wszCLIENTSECTION,
		        0,
		        &dwType,
		        (BYTE *) &dwValue,
		        &cb);
	pdw = NULL;
	if (S_OK == hr && REG_DWORD == dwType && sizeof(dwValue) == cb)
	{
	    pdw = &dwValue;
	}
	CSILOG(hr, IDS_LOG_REGSTATE, wszCLIENTSECTION, NULL, pdw);
	
	cb = sizeof(dwValue);
	hr = RegQueryValueEx(
		        hkey,
			wszOLDDOCCOMPONENT,
		        0,
		        &dwType,
		        (BYTE *) &dwValue,
		        &cb);
	pdw = NULL;
	if (S_OK == hr && REG_DWORD == dwType && sizeof(dwValue) == cb)
	{
	    CSILOG(hr, IDS_LOG_REGSTATE, wszOLDDOCCOMPONENT, NULL, &dwValue);
	}
    }

    pComp->fUnattended = (pComp->Flags & SETUPOP_BATCH)? TRUE : FALSE;
    CSILOG(
	S_OK,
	IDS_LOG_UNATTENDED,
	pComp->fUnattended? pInitComponent->SetupData.UnattendFile : NULL,
	NULL,
	(DWORD const *) &pComp->fUnattended);

    if (pComp->fUnattended)
    {
        pComp->pwszUnattendedFile = (WCHAR *) LocalAlloc(
                        LMEM_FIXED,
                        (wcslen(pInitComponent->SetupData.UnattendFile) + 1) *
                            sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pComp->pwszUnattendedFile);

        wcscpy(
            pComp->pwszUnattendedFile,
            pInitComponent->SetupData.UnattendFile);
    }

    // initialize ca setup data
    hr = InitCASetup(hwnd, pComp);
    _JumpIfError(hr, error, "InitCASetup");


    hr = S_OK;
    *pulpRet = NO_ERROR;

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
certocmReadInfString(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *pwszFile,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszName,
    IN OUT WCHAR **ppwszValue)
{
    INFCONTEXT InfContext;
    HRESULT hr;
    WCHAR wszBuffer[cwcINFVALUE];
    WCHAR *pwsz;

    if (NULL != *ppwszValue)
    {
        // free old
        LocalFree(*ppwszValue);
        *ppwszValue = NULL;
    }

    if (!SetupFindFirstLine(hInf, pwszSection, pwszName, &InfContext))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "SetupFindFirstLine", pwszSection);
    }
    
    if (!SetupGetStringField(
                        &InfContext,
                        1,
                        wszBuffer,
                        sizeof(wszBuffer)/sizeof(wszBuffer[0]),
                        NULL))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "SetupGetStringField", pwszName);
    }

    pwsz = (WCHAR *) LocalAlloc(
                        LMEM_FIXED, 
                        (wcslen(wszBuffer) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwsz);

    wcscpy(pwsz, wszBuffer);
    *ppwszValue = pwsz;

    hr = S_OK;
error:
    return(hr);
}


HRESULT
certocmReadInfInteger(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *pwszFile,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszName,
    OUT INT *pValue)
{
    INFCONTEXT InfContext;
    HRESULT hr = S_OK;
    WCHAR wszBuffer[cwcINFVALUE];

    *pValue = 0;
    if (!SetupFindFirstLine(hInf, pwszSection, pwszName, &InfContext))
    {
        hr = myHLastError();
        DBGPRINT((
            DBG_SS_CERTOCMI, 
            __FILE__ "(%u): %ws%wsSetupFindFirstLine([%ws] %ws) failed! -> %x\n",
            __LINE__,
            NULL != pwszFile? pwszFile : L"",
            NULL != pwszFile? L": " : L"",
            pwszSection,
            pwszName,
            hr));
        goto error;
    }

    if (!SetupGetIntField(&InfContext, 1, pValue))
    {
        hr = myHLastError();
        DBGPRINT((
            DBG_SS_CERTOCM,
            __FILE__ "(%u): %ws%wsSetupGetIntField([%ws] %ws) failed! -> %x\n",
            __LINE__,
            NULL != pwszFile? pwszFile : L"",
            NULL != pwszFile? L": " : L"",
            pwszSection,
            pwszName,
            hr));
        goto error;
    }
    
    DBGPRINT((
        DBG_SS_CERTOCMI,
        "%ws%ws[%ws] %ws = %u\n",
        NULL != pwszFile? pwszFile : L"",
        NULL != pwszFile? L": " : L"",
        pwszSection,
        pwszName,
        *pValue));
    
error:
    return(hr);
}


// Return the GDI handle of a small bitmap to be used.  NULL means an error
// occurred -- OCM will use a default bitmap.
//
// Demonstrates use of private data in a per-component inf.  We will look in
// our per-component inf to determine the resource name for the bitmap for this
// component, and then go fetch it from the resources.
//
// Other possibilities would be to simply return the same hbitmap for all
// cases, or to return NULL, in which case OCM uses a default.  Note that we
// ignore the requested width and height and our bitmaps are not language
// dependent.

HRESULT
certocmOcQueryImage(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN SubComponentInfo wSubComp,
    IN WORD wWidth,
    IN WORD wHeight,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HANDLE hRet = NULL;
    HRESULT hr;

    DBGPRINT((
        DBG_SS_CERTOCMI,
        "OC_QUERY_IMAGE(%ws, %ws, %hx, %hx, %hx)\n",
        pwszComponent,
        pwszSubComponent,
        wSubComp,
        wWidth,
        wHeight));

    if (SubCompInfoSmallIcon != wSubComp)
    {
        goto done;
    }

    hRet = (HANDLE) LoadBitmap(pComp->hInstance, MAKEINTRESOURCE(IDB_APP));
    if (NULL == hRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "LoadBitmap");
    }

done:
    hr = S_OK;

error:
    *pulpRet = (ULONG_PTR) hRet;
    return hr;
}


// Return the number of wizard pages the current component places in the
// SETUP_REQUEST_PAGES structure.

HRESULT
certocmOcRequestPages(
    IN WCHAR const *pwszComponent,
    IN WizardPagesType WizPagesType,
    IN OUT SETUP_REQUEST_PAGES *pRequestPages,
    IN PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT  hr;

    *pulpRet = 0;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_REQUEST_PAGES(%ws, %x, %p)\n",
            pwszComponent,
            WizPagesType,
            pRequestPages));

    // don't invoke wiz apge if unattended
    // or if running from base setup/upgrade setup
    if ((!pComp->fUnattended) && (SETUPOP_STANDALONE & pComp->Flags))
    {
        *pulpRet = myDoPageRequest(pComp,
                      WizPagesType, pRequestPages);
    }
    else
    {
            DBGPRINT((
                DBG_SS_CERTOCMI,
		"Not adding wizard pages, %ws\n",
		pComp->fUnattended? L"Unattended" : L"GUI Setup"));

    }
    hr = S_OK;
//error:
    return hr;
}


HRESULT
IsIA5DnsMachineName()
{
    WCHAR *pwszDnsName = NULL;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    CRL_DIST_POINT       DistPoint;
    CERT_ALT_NAME_ENTRY  AltNameEntry;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    static HRESULT s_hr = S_FALSE;

    if (S_FALSE != s_hr)
    {
	goto error;
    }
    s_hr = myGetMachineDnsName(&pwszDnsName);
    _JumpIfError(s_hr, error, "myGetMachineDnsName");

    CRLDistInfo.cDistPoint = 1;
    CRLDistInfo.rgDistPoint = &DistPoint;

    ZeroMemory(&DistPoint, sizeof(DistPoint));
    DistPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;
    DistPoint.DistPointName.FullName.cAltEntry = 1;
    DistPoint.DistPointName.FullName.rgAltEntry = &AltNameEntry;

    ZeroMemory(&AltNameEntry, sizeof(AltNameEntry));
    AltNameEntry.dwAltNameChoice = CERT_ALT_NAME_URL;
    AltNameEntry.pwszURL = pwszDnsName;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	s_hr = myHLastError();
	_JumpIfError(s_hr, error, "myEncodeObject");
    }
    CSASSERT(S_OK == s_hr);

error:
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    return(s_hr);
}


// Return boolean to indicate whether to allow selection state change.  As
// demonstrated, again we'll go out to our per-component inf to see whether it
// wants us to validate.  Note that unattended mode must be respected.

HRESULT
certocmOcQueryChangeSelState(
    HWND            hwnd,
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN BOOL fSelectedNew,
    IN DWORD Flags,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    INT fVerify;
    TCHAR wszText[cwcMESSAGETEXT];
    const WCHAR* Args[2]; 
    SUBCOMP const *psc;
    HRESULT hr;
    WCHAR awc[20];
    WCHAR awc2[20];
    DWORD fRet;
    BOOL  fServerWasInstalled;
    BOOL  fWebClientWasInstalled;
    BOOL  fDisallow = FALSE;
    int   iMsg;
    static BOOL s_fWarned = FALSE;

    *pulpRet = FALSE;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUERY_CHANGE_SEL_STATE(%ws, %ws, %x, %x)\n",
            pwszComponent,
            pwszSubComponent,
            fSelectedNew,
            Flags));

    // disallow some selection changes
    fServerWasInstalled = certocmWasEnabled(pComp, cscServer);
    fWebClientWasInstalled = certocmWasEnabled(pComp, cscClient);

    if (fWebClientWasInstalled &&
        (OCQ_ACTUAL_SELECTION & Flags))
    {
        if (fSelectedNew)
        {
            // check
            if (!fServerWasInstalled &&
                (0 == lstrcmpi(wszSERVERSECTION, pwszSubComponent) ||
                 0 == lstrcmpi(wszCERTSRVSECTION, pwszSubComponent)) )
            {
                // case: web client installed and try install server
                fDisallow = TRUE;
                iMsg = IDS_WRN_UNINSTALL_CLIENT;
            }
            if (fServerWasInstalled &&
                0 == lstrcmpi(wszCLIENTSECTION, pwszSubComponent))
            {
                // case: uncheck both then check web client
                fDisallow = TRUE;
                iMsg = IDS_WRN_UNINSTALL_BOTH;
            }
        }
        else
        {
            // uncheck
            if (fServerWasInstalled &&
                0 == lstrcmpi(wszSERVERSECTION, pwszSubComponent))
            {
                // case: full certsrv installed and try leave only web client
                fDisallow = TRUE;
                iMsg = IDS_WRN_UNINSTALL_BOTH;
            }
        }
    }

    // not a server sku
    if (!FIsServer())
    {
        fDisallow = TRUE;
        iMsg = IDS_WRN_SERVER_ONLY;
    }

    if (fDisallow)
    {
        CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                iMsg,
                0,
                NULL);
        goto done;
    }

    if (fSelectedNew)
    {
	hr = IsIA5DnsMachineName();
	if (S_OK != hr)
	{
	    CertMessageBox(
		    pComp->hInstance,
		    pComp->fUnattended,
		    hwnd,
		    IDS_ERR_NONIA5DNSNAME,
		    hr,
		    MB_OK | MB_ICONERROR,
		    NULL);
	    goto done;
	}
	if ((OCQ_ACTUAL_SELECTION & Flags) &&
	    0 != lstrcmpi(wszCLIENTSECTION, pwszSubComponent))
	{
	    if (!s_fWarned)
	    {
		DWORD dwSetupStatus;

		hr = GetSetupStatus(NULL, &dwSetupStatus);
		if (S_OK == hr)
		{
		    if ((SETUP_CLIENT_FLAG | SETUP_SERVER_FLAG) & dwSetupStatus)
		    {
			s_fWarned = TRUE;
		    }
		    CSILOG(
			hr,
			IDS_LOG_QUERYCHANGESELSTATE,
			NULL,
			NULL,
			&dwSetupStatus);
		}
	    }
	    if (!s_fWarned)
	    {
		if (IDYES != CertMessageBox(
				pComp->hInstance,
				pComp->fUnattended,
				hwnd,
				IDS_WRN_NONAMECHANGE,
				S_OK,
				MB_YESNO | MB_ICONWARNING  | CMB_NOERRFROMSYS,
				NULL))
		{
		    goto done;
		}
		s_fWarned = TRUE;
	    }
	}
    }

    *pulpRet = TRUE;

    if (pComp->fUnattended)
    {
        goto done;
    }

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    hr = certocmReadInfInteger(
                    pComp->MyInfHandle,
                    NULL,
                    psc->pwszSubComponent,
                        fSelectedNew? wszVERIFYSELECT : wszVERIFYDESELECT,
                    &fVerify);
    if (S_OK != hr || !fVerify) 
    {
        goto done;
    }

    // Don't pass specific lang id to FormatMessage, as it fails if there's no
    // msg in that language.  Instead, set the thread locale, which will get
    // FormatMessage to use a search algorithm to find a message of the 
    // appropriate language, or use a reasonable fallback msg if there's none.

    Args[0] = pwszComponent;
    Args[1] = pwszSubComponent;

    FormatMessage(
              FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
              pComp->hInstance,
              fSelectedNew? MSG_SURE_SELECT : MSG_SURE_DESELECT,
              0,
              wszText,
              sizeof(wszText)/sizeof(wszText[0]),
              (va_list *) Args);

    *pulpRet = (IDYES == CertMessageBox(
                                pComp->hInstance,
                                pComp->fUnattended,
                                hwnd,
                                0,
                                S_OK,
                                MB_YESNO |
                                    MB_ICONWARNING |
                                    MB_TASKMODAL |
                                    CMB_NOERRFROMSYS,
                                wszText));

done:
    hr = S_OK;

error:
    wsprintf(awc, L"%u", fSelectedNew);
    wsprintf(awc2, L"0x%08x", Flags);
    fRet = (DWORD) *pulpRet;
    CSILOG(hr, IDS_LOG_QUERYCHANGESELSTATE, awc, awc2, &fRet);
    return hr;
}


// Calculate disk space for the component being added or removed.  Return a
// Win32 error code indicating outcome.  In our case the private section for
// this component/subcomponent pair is a simple standard inf install section,
// so we can use high-level disk space list API to do what we want.

HRESULT
certocmOcCalcDiskSpace(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN BOOL fAddComponent,
    IN HDSKSPC hDiskSpace,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    SUBCOMP const *psc;
    static fServerFirstCall = TRUE;
    static fClientFirstCall = TRUE;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_CALC_DISK_SPACE(%ws, %ws, %x, %p)\n",
            pwszComponent,
            pwszSubComponent,
            fAddComponent,
            hDiskSpace));

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    // Being installed or uninstalled.  Fetch INSTALL section name,
    // so we can add or remove the files being INSTALLed from the disk
    // space list.

    hr = certocmReadInfString(
                        pComp->MyInfHandle,
                        NULL,
                        psc->pwszSubComponent,
                        wszINSTALL,
                        &pwsz);
    _JumpIfError(hr, error, "certocmReadInfString");

    if (fAddComponent)  // Adding
    {
        if (!SetupAddInstallSectionToDiskSpaceList(
                                        hDiskSpace,
                                        pComp->MyInfHandle,
                                        NULL,
                                        pwsz,
                                        0,
                                        0))
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "SetupAddInstallSectionToDiskSpaceList", pwsz);
        }
    } 
    else                // Removing
    {
        if (!SetupRemoveInstallSectionFromDiskSpaceList(
                                        hDiskSpace,
                                        pComp->MyInfHandle,
                                        NULL,
                                        pwsz,
                                        0,
                                        0))
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "SetupRemoveInstallSectionFromDiskSpaceList", pwsz);
        }
    }
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    *pulpRet = hr;
    return(hr);
}


// OCM calls this routine when ready for files to be copied to effect the
// changes the user requested. The component DLL must figure out whether it is
// being installed or uninstalled and take appropriate action.  For this
// sample, we look in the private data section for this component/subcomponent
// pair, and get the name of an uninstall section for the uninstall case.
//
// Note that OCM calls us once for the *entire* component and then once per
// subcomponent.  We ignore the first call.
//
// Return value is Win32 error code indicating outcome.

HRESULT
certocmOcQueueFileOps(
    IN HWND         hwnd,
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN HSPFILEQ hFileQueue,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    SUBCOMP const *psc;
    BOOL fRemoveFile = FALSE;  // TRUE for uninstall; FALSE for install/upgrade
    WCHAR *pwszAction;
    WCHAR *pwsz = NULL;
    static BOOL s_fPreUninstall = FALSE; // preuninstall once

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUEUE_FILE_OPS(%ws, %ws, %p)\n",
            pwszComponent,
            pwszSubComponent,
            hFileQueue));

    if (NULL == pwszSubComponent)
    {
        // Do no work for top level component
        goto done;
    }

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }


    // if unattended, not upgrade, & not uninstall, load
    if (pComp->fUnattended && !(pComp->Flags & SETUPOP_NTUPGRADE) )
    {
        // retrieve unattended attributes
        hr = certocmRetrieveUnattendedText(
                 pwszComponent,
                 pwszSubComponent,
                 pComp);
        if (S_OK != hr && 0x0 != (pComp->Flags & SETUPOP_STANDALONE))
        {
            // only error out if it is from add/remove or post because
            // it could fail regular ntbase in unattended mode without certsrv
            _JumpError(hr, error, "certocmRetrieveUnattendedText");
        }

        // Init install status (must be done after retrieving unattended text)
        hr = UpdateSubComponentInstallStatus(pwszComponent,
                                             pwszSubComponent, 
                                             pComp);

        _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");

        if (psc->fInstallUnattend) // make sure ON
        {
            if (certocmWasEnabled(pComp, psc->cscSubComponent) &&
                !pComp->fPostBase)
            {
                // the case to run install with component ON twice or more
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
                _JumpError(hr, error, "You must uninstall before install");
            }
            if (SETUPOP_STANDALONE & pComp->Flags)
            {
                // only prepare and validate unattende attr in standalone mode
                // in other word, don't call following if NT base
                hr = PrepareUnattendedAttributes(
                         hwnd,
                         pwszComponent,
                         pwszSubComponent,
                         pComp);
                _JumpIfError(hr, error, "PrepareUnattendedAttributes");
            }
        }
    }
    else
    {
        // Initialize the install status
        hr = UpdateSubComponentInstallStatus(pwszComponent,
                                             pwszSubComponent, 
                                             pComp);

        _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");
    }


    // If we're not doing base setup or an upgrade, check to see if we already
    // copied files during base setup, by checking to see if base setup
    // left an entry in the ToDo List.
    if(pComp->fPostBase)
    {

            DBGPRINT((
                DBG_SS_CERTOCMI,
                "File Queueing Skipped, files already installed by GUI setup"));
        goto done;

    }

/*
    //--- Talk with OCM guys and put this functionality into a notification routine
    //--- This will allow us to pop compatibility error to user before unattended upgrade begins

    // detect illegal upgrade
    if (pComp->dwInstallStatus & IS_SERVER_UPGRADE)
    {
        hr = DetermineServerUpgradePath(pComp);
        _JumpIfError(hr, error, "DetermineServerUpgradePath");
    }
    else if (pComp->dwInstallStatus & IS_CLIENT_UPGRADE)
    {
        hr = DetermineClientUpgradePath(pComp);
        _JumpIfError(hr, error, "LoadAndDetermineClientUpgradeInfo");
    }
    if ((pComp->dwInstallStatus & IS_SERVER_UPGRADE) ||
        (pComp->dwInstallStatus & IS_CLIENT_UPGRADE))
    {
        // block if attempting upgrade that is not Win2K or Whistler
        // lodge a complaint in the log; upgrade all bits and 
        if ((CS_UPGRADE_NO != pComp->UpgradeFlag) && 
            (CS_UPGRADE_WHISTLER != pComp->UpgradeFlag) && 
            (CS_UPGRADE_WIN2000 != pComp->UpgradeFlag)) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
            CertErrorMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                IDS_ERR_UPGRADE_NOT_SUPPORTED,
                hr,
                NULL);
//            _JumpError(hr, error, "Unsupported upgrade");
            // continue uninstall/reinstall
        }
    }
*/

    if ((pComp->dwInstallStatus & psc->ChangeFlags) ||
        (pComp->dwInstallStatus & psc->UpgradeFlags) )
    {

        // for ChangeFlags, either install or uninstall
        // all cases, copy file or remove file

        if (pComp->dwInstallStatus & psc->UninstallFlags)
        {
            fRemoveFile = TRUE;
        }

        // Uninstall the core if:
        // this subcomponent is being uninstalled, and
        // this is a core subcomponent (client or server), and
        // this is the server subcomponent, or the server isn't being removed or
        // upgrade

        if (((pComp->dwInstallStatus & psc->UninstallFlags) ||
             (pComp->dwInstallStatus & psc->UpgradeFlags) ) &&
            (cscServer == psc->cscSubComponent ||
             !(IS_SERVER_REMOVE & pComp->dwInstallStatus) ) )
        {
            // if fall into here, either need to overwrite or
            // delete certsrv files so unreg all related dlls

            if (cscServer == psc->cscSubComponent &&
                (pComp->dwInstallStatus & psc->UpgradeFlags) )
            {
                // if this is server upgrade, determine upgrade path
                hr = DetermineServerUpgradePath(pComp);
                _JumpIfError(hr, error, "DetermineServerUpgradePath");

                // determine custom policy module
                hr = DetermineServerCustomModule(
                         pComp,
                         TRUE);  // policy
                _JumpIfError(hr, error, "DetermineServerCustomModule");

                // determine custom exit module
                hr = DetermineServerCustomModule(
                         pComp,
                         FALSE);  // exit
                _JumpIfError(hr, error, "DetermineServerCustomModule");
            }

            if (!s_fPreUninstall)
            {
                hr = PreUninstallCore(
                            hwnd,
                            pComp,
                            certocmPreserving(pComp, cscClient));
                _JumpIfError(hr, error, "PreUninstallCore");
                s_fPreUninstall = TRUE;
            }
        }

        if ((pComp->dwInstallStatus & psc->ChangeFlags) ||
            (pComp->dwInstallStatus & psc->UpgradeFlags) )
        {
            // Being installed or uninstalled.
            // Fetch [un]install/upgrade section name.
            if (pComp->dwInstallStatus & psc->InstallFlags)
            {
                pwszAction = wszINSTALL;
            }
            else if (pComp->dwInstallStatus & psc->UninstallFlags)
            {
                pwszAction = wszUNINSTALL;
            }
            else if (pComp->dwInstallStatus & psc->UpgradeFlags)
            {
                pwszAction = wszUPGRADE;
            }
            else
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            }
            hr = certocmReadInfString(
                            pComp->MyInfHandle,
                            NULL,
                            psc->pwszSubComponent,
                            pwszAction,
                            &pwsz);
            _JumpIfError(hr, error, "certocmReadInfString");

            // If uninstalling, copy files without version checks.

            if (!SetupInstallFilesFromInfSection(
                                            pComp->MyInfHandle,
                                            NULL,
                                            hFileQueue,
                                            pwsz,
                                            NULL,
                                            fRemoveFile? 0 : SP_COPY_NEWER))
            {
                hr = myHLastError();
                _JumpIfError(hr, error, "SetupInstallFilesFromInfSection");
            }
        }
    }

done:
    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    if (S_OK != hr)
    {
        SetLastError(hr);
    }
    *pulpRet = hr;
    return(hr);
}


// OCM calls this routine when it wants to find out how much work the component
// wants to perform for nonfile operations to install/uninstall a component or
// subcomponent.  It is called once for the *entire* component and then once
// for each subcomponent in the component.  One could get arbitrarily fancy
// here but we simply return 1 step per subcomponent.  We ignore the "entire
// component" case.
//
// Return value is an arbitrary 'step' count or -1 if error.

HRESULT
certocmOcQueryStepCount(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT  hr;

    *pulpRet = 0;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUERY_STEP_COUNT(%ws, %ws)\n",
            pwszComponent,
            pwszSubComponent));

    // Ignore all but "entire component" case.
    if (NULL != pwszSubComponent)
    {
        goto done;
    }
    *pulpRet = SERVERINSTALLTICKS;

done:
    hr = S_OK;
//error:
    return hr;
}


// OCM calls this routine when it wants the component dll to perform nonfile
// ops to install/uninstall a component/subcomponent.  It is called once for
// the *entire* component and then once for each subcomponent in the component.
// Our install and uninstall actions are based on simple standard inf install
// sections.  We ignore the "entire component" case.  Note how similar this
// code is to the OC_QUEUE_FILE_OPS case.

HRESULT
certocmOcCompleteInstallation(
    HWND                       hwnd,
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN OUT PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    TCHAR wszBuffer[cwcINFVALUE];
    SUBCOMP const *psc;
    WCHAR *pwsz = NULL;
    DWORD dwSetupStatusFlags;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR     *pwszActiveCA = NULL;
    static BOOL  fStoppedW3SVC = FALSE;

    *pulpRet = 0;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_COMPLETE_INSTALLATION(%ws, %ws)\n",
            pwszComponent,
            pwszSubComponent));

    // Do no work for top level component
    if (NULL == pwszSubComponent)
    {
        goto done;
    }

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error: unsupported component");
    }

    if (pComp->dwInstallStatus & IS_SERVER_REMOVE)
    {
        // for uninstall, check if active ca use DS
        hr = myGetCertRegStrValue(NULL, NULL, NULL,
                 wszREGACTIVE, &pwszActiveCA);
        if (S_OK == hr && NULL != pwszActiveCA)
        {
            hr = myGetCertRegDWValue(pwszActiveCA, NULL, NULL,
                     wszREGCAUSEDS, (DWORD*)&pServer->fUseDS);
            _PrintIfError(hr, "myGetCertRegDWValue");
        }
    }

    DBGPRINT((
	DBG_SS_CERTOCMI,
        "certocmOcCompleteInstallation: pComp->dwInstallStatus: %lx, pComp->Flags: %lx\n",
	pComp->dwInstallStatus,
	pComp->Flags));

    if ((pComp->dwInstallStatus & psc->ChangeFlags) ||
        (pComp->dwInstallStatus & psc->UpgradeFlags) )
    {
        // for unattended, make sure w3svc is stopped before file copy
        if (!fStoppedW3SVC &&
            pComp->fUnattended &&
            !(pComp->Flags & SETUPOP_NTUPGRADE) &&
            !(pComp->dwInstallStatus & psc->UninstallFlags) )
        {
            //fStoppedW3SVC makes stop only once
            //don't do this in upgrade
            // this happens for unattended
            // also not during uninstall
            hr = StartAndStopService(pComp->hInstance,
                     pComp->fUnattended,
                     hwnd,
                     wszW3SVCNAME,
                     TRUE,
                     FALSE,
                     0, // doesn't matter since no confirmation
                     &g_fW3SvcRunning);
            _PrintIfError(hr, "StartAndStopService");
            fStoppedW3SVC = TRUE;
        }

        // certsrv file copy
        if (!SetupInstallFromInfSection(
                                NULL,
                                pComp->MyInfHandle,
                                wszBuffer,
                                SPINST_INIFILES | SPINST_REGISTRY,
                                NULL,
                                NULL,
                                0,
                                NULL,
                                NULL,
                                NULL,
                                NULL))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetupInstallFromInfSection");
        }

        // Finish uninstalling the core if:
        // this subcomponent is being uninstalled, and
        // this is a core subcomponent (client or server), and
        // this is the server subcomponent, or the server isn't being removed.

        if ( (pComp->dwInstallStatus & psc->UninstallFlags) &&
             (cscServer == psc->cscSubComponent ||
              !(IS_SERVER_REMOVE & pComp->dwInstallStatus) ) )
        {
            // Do uninstall work 
            hr = UninstallCore(
                           hwnd,
                           pComp,
                           0,
                           100,
                           certocmPreserving(pComp, cscClient),
                           TRUE,
                           FALSE);
            _JumpIfError(hr, error, "UninstallCore");

            if (certocmPreserving(pComp, cscClient))
            {
                hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }
            else
            {
                // unmark all
                hr = SetSetupStatus(NULL, 0xFFFFFFFF, FALSE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }
        }

        // Finish installing the core if:
        // this subcomponent is being installed, and
        // this is a core subcomponent (client or server), and
        // this is the server subcomponent, or the server isn't being installed.
        // and this is not base setup (we'll do it later if it is)

        else
        if ((pComp->dwInstallStatus & psc->InstallFlags) &&
            (cscServer == psc->cscSubComponent ||
             !(IS_SERVER_INSTALL & pComp->dwInstallStatus)) &&
             (0 != (pComp->Flags & SETUPOP_STANDALONE)))
        {
                DBGPRINT((
                    DBG_SS_CERTOCMI,
                "Performing standalone server installation\n"));

        
            hr = InstallCore(hwnd, pComp, cscServer == psc->cscSubComponent);
            _JumpIfError(hr, error, "InstallCore");

            // last enough to mark complete
            if (pComp->dwInstallStatus & IS_SERVER_INSTALL)
            {
                // machine
                hr = SetSetupStatus(NULL, SETUP_SERVER_FLAG, TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");

                // ca
                hr = SetSetupStatus(
                                    pServer->pwszSanitizedName,
                                    SETUP_SERVER_FLAG,
                                    TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");

                if(IsEnterpriseCA(pServer->CAType))
                {
                    hr = SetSetupStatus(
                                        pServer->pwszSanitizedName,
                                        SETUP_UPDATE_CAOBJECT_SVRTYPE,
                                        TRUE);
                    _JumpIfError(hr, error, "SetSetupStatus SETUP_UPDATE_CAOBJECT_SVRTYPE");
                }


                hr = GetSetupStatus(pServer->pwszSanitizedName, &dwSetupStatusFlags);
                _JumpIfError(hr, error, "SetSetupStatus");

                // Only start the server if:
                // 1: we're not waiting for the CA cert to be issued, and
                // 2: this is not base setup -- SETUP_STANDALONE means we're
                //    running from the Control Panel or were manually invoked.
                //    The server will not start during base setup due to an
                //    access denied error from JetInit during base setup.

                if (0 == (SETUP_SUSPEND_FLAG & dwSetupStatusFlags) &&
                    (0 != (SETUPOP_STANDALONE & pComp->Flags)))
                {
                    hr = StartCertsrvService(FALSE);
                    _PrintIfError(hr, "failed in starting cert server service");
                }

                // during base setup: f=0 sus=8
                DBGPRINT((
                        DBG_SS_CERTOCMI,
                        "InstallCore: f=%x sus=%x\n",
                        pComp->Flags,
                        dwSetupStatusFlags));

                hr = EnableVRootsAndShares(FALSE, FALSE, TRUE, pComp);
                _PrintIfError(hr, "failed creating VRoots/shares");
            }
            if (pComp->dwInstallStatus & IS_CLIENT_INSTALL)
            {
                hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }
            if ((pComp->dwInstallStatus & IS_SERVER_INSTALL) &&
                (pComp->dwInstallStatus & IS_CLIENT_INSTALL))
            {
                hr = SetSetupStatus(
                                    pServer->pwszSanitizedName,
                                    SETUP_CLIENT_FLAG,
                                    TRUE);
                _JumpIfError(hr, error, "SetSetupStatus");
            }

            // in case we're doing a post-base setup,
            // we always clear the post-base to-do list
            RegDeleteKey(HKEY_LOCAL_MACHINE, wszREGKEYCERTSRVTODOLIST);

        }
        else
        if ((pComp->dwInstallStatus & psc->InstallFlags) &&
            (cscServer == psc->cscSubComponent ||
             !(IS_SERVER_INSTALL & pComp->dwInstallStatus)) &&
             (0 == (pComp->Flags & (SETUPOP_STANDALONE |
                                    SETUPOP_WIN31UPGRADE |
                                    SETUPOP_WIN95UPGRADE |
                                    SETUPOP_NTUPGRADE) )))
        {
            HKEY   hkToDoList = NULL;
            WCHAR *pwszConfigTitleVal = NULL;
            WCHAR *pwszArgsValTemp = NULL;
            WCHAR *pwszArgsVal = wszCONFIGARGSVAL;
            BOOL   fFreeTitle = FALSE;
            DWORD  disp;
            DWORD  err;

	    DBGPRINT((
		DBG_SS_CERTOCMI,
                "Adding Certificate Services to ToDoList\n"));

            // We're installing base, so create
            // the ToDoList entry stating that we copied files.
            err = ::RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             wszREGKEYCERTSRVTODOLIST,
                             0,
                             NULL,
                             0,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hkToDoList,
                             &disp);
            hr = HRESULT_FROM_WIN32(err);
            _JumpIfError(hr, error, "RegCreateKeyEx");

            hr = myLoadRCString(
                         g_hInstance,
                         IDS_TODO_TITLE,
                         &pwszConfigTitleVal);
            if (S_OK == hr)
            {
                fFreeTitle = TRUE;
            }
            else
            {
                // If there was no resource, get something...
                pwszConfigTitleVal = wszCONFIGTITLEVAL;
            }

            // config title
            err = RegSetValueEx(hkToDoList, 
                                wszCONFIGTITLE,
                                0, 
                                REG_SZ, 
                                (PBYTE)pwszConfigTitleVal, 
                                sizeof(WCHAR)*(wcslen(pwszConfigTitleVal)+1));
            hr = HRESULT_FROM_WIN32(err);
            _PrintIfErrorStr(hr, "RegSetValueEx", wszCONFIGTITLE);

	    CSILOG(hr, IDS_LOG_TODOLIST, wszCONFIGTITLE, pwszConfigTitleVal, NULL);

            // config command
            err = RegSetValueEx(hkToDoList, 
                                wszCONFIGCOMMAND, 
                                0, 
                                REG_SZ,
                                (PBYTE)wszCONFIGCOMMANDVAL,
                                sizeof(WCHAR)*(wcslen(wszCONFIGCOMMANDVAL)+1));
            hr = HRESULT_FROM_WIN32(err);
            _PrintIfErrorStr(hr, "RegSetValueEx", wszCONFIGCOMMAND);

	    CSILOG(hr, IDS_LOG_TODOLIST, wszCONFIGCOMMAND, wszCONFIGCOMMANDVAL, NULL);

            // config args
            if (pComp->fUnattended && NULL != pComp->pwszUnattendedFile)
            {
                // if nt base is in unattended mode, expand args with
                // unattended answer file name

                pwszArgsValTemp = (WCHAR*)LocalAlloc(LMEM_FIXED,
                    (wcslen(pwszArgsVal) +
                     wcslen(pComp->pwszUnattendedFile) + 5) * sizeof(WCHAR));
                _JumpIfOutOfMemory(hr, error, pwszArgsValTemp);

                wcscpy(pwszArgsValTemp, pwszArgsVal);
                wcscat(pwszArgsValTemp, L" /u:");
                wcscat(pwszArgsValTemp, pComp->pwszUnattendedFile);
                pwszArgsVal = pwszArgsValTemp;
            }
            err = RegSetValueEx(hkToDoList, 
				    wszCONFIGARGS,
                                    0, 
                                    REG_SZ, 
                                    (PBYTE)pwszArgsVal,
                                    sizeof(WCHAR)*(wcslen(pwszArgsVal)+1));
            hr = HRESULT_FROM_WIN32(err);
            _PrintIfErrorStr(hr, "RegSetValueEx", wszCONFIGARGS);

	    CSILOG(hr, IDS_LOG_TODOLIST, wszCONFIGARGS, pwszArgsVal, NULL);


            // free stuff
            if (NULL != pwszConfigTitleVal && fFreeTitle)
            {
                LocalFree(pwszConfigTitleVal);
            }
            if (NULL != pwszArgsValTemp)
            {
                LocalFree(pwszArgsValTemp);
            }
            if (NULL != hkToDoList)
            {
                RegCloseKey(hkToDoList);
            }
        }
        else if (pComp->dwInstallStatus & psc->UpgradeFlags)
        {
            BOOL fFinishCYS;

            hr = CheckPostBaseInstallStatus(&fFinishCYS);
            _JumpIfError(hr, error, "CheckPostBaseInstallStatus");

            // if post mode is true, don't execute setup upgrade path
            if (fFinishCYS)
            {
                BOOL fServer = FALSE;
                // upgrade
                if (cscServer == psc->cscSubComponent)
                {
                    hr = UpgradeServer(hwnd, pComp);
                    _JumpIfError(hr, error, "UpgradeServer");
                    fServer = TRUE;
                }
                else if (cscClient == psc->cscSubComponent)
                {
                    hr = UpgradeClient(hwnd, pComp);
                    _JumpIfError(hr, error, "UpgradeClient");
                }

                // mark setup status
                hr = SetSetupStatus(NULL, psc->SetupStatusFlags, TRUE);
                _PrintIfError(hr, "SetSetupStatus");
                if (fServer)
                {
                    // ca level
                    hr = SetSetupStatus(
                             pServer->pwszSanitizedName,
                             psc->SetupStatusFlags, TRUE);
                    _PrintIfError(hr, "SetSetupStatus");

                    if(IsEnterpriseCA(pServer->CAType))
                    {
                        hr = SetSetupStatus(
                                pServer->pwszSanitizedName,
                                SETUP_UPDATE_CAOBJECT_SVRTYPE,
                                TRUE);
                        _JumpIfError(hr, error, 
                            "SetSetupStatus SETUP_UPDATE_CAOBJECT_SVRTYPE");
                    }
                }

                if (fServer && pServer->fCertSrvWasRunning)
                {
                    hr = StartCertsrvService(TRUE);
                    _PrintIfError(hr, "failed in starting cert server service");
                }
            }
        }
    }

done:
    hr = S_OK;

error:
    if (NULL != pwszActiveCA)
    {
        LocalFree(pwszActiveCA);
    }
    *pulpRet = hr;
    return(hr);
}


HRESULT
certocmOcCommitQueue(
    IN HWND                hwnd,
    IN WCHAR const        *pwszComponent,
    IN WCHAR const        *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    SUBCOMP  *pSub;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_ABOUT_TO_COMMIT_QUEUE(%ws, %ws)\n",
            pwszComponent,
            pwszSubComponent));

    pSub = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == pSub)
    {
        goto done;
    }

    // setup will satrt soon, mark it incomplete
    if ((pSub->InstallFlags & pComp->dwInstallStatus) &&
         cscServer == pSub->cscSubComponent)
    {
        hr = SetSetupStatus(NULL, pSub->SetupStatusFlags, FALSE);
        _PrintIfError(hr, "SetSetupStatus");
        hr = SetSetupStatus(
                 pServer->pwszSanitizedName, 
                 pSub->SetupStatusFlags,
                 FALSE);
        _PrintIfError(hr, "SetSetupStatus");
    }

    if ((cscServer == pSub->cscSubComponent) &&
        (pSub->UpgradeFlags & pComp->dwInstallStatus) )
    {
        // upgrade case, no UI, stop existing certsrv
        hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hwnd,
                 wszSERVICE_NAME,
                 TRUE,  // stop the service
                 FALSE, // no confirm
                 0,    //doesn't matter since no confirm
                 &pServer->fCertSrvWasRunning);
        _PrintIfError(hr, "ServiceExists");
    }

done:
    hr = S_OK;
//error:
    return hr;
}

// Component dll is being unloaded.

VOID
certocmOcCleanup(
    IN WCHAR const *pwszComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    DBGPRINT((DBG_SS_CERTOCMI, "OC_CLEANUP(%ws)\n", pwszComponent));

    if (NULL != pComp->pwszComponent)
    {
        if (0 == lstrcmpi(pComp->pwszComponent, pwszComponent))
        {
            FreeCAComponentInfo(pComp);
        }
    }

    // also free some globals
    FreeCAGlobals();
}

/////////////////////////////////////////////////////////////////////////////
//++
//
// certocmOcQueryState
//
// Routine Description:
//    This funcion sets the original, current, and final selection states of the
//    CertSrv service optional component.
//
// Return Value:
//    SubcompOn - indicates that the checkbox should be set
//    SubcompOff - indicates that the checkbox should be clear
//    SubcompUseOCManagerDefault - OC Manager should set the state of the checkbox
//                                 according to state information that is maintained
//                                 internally by OC Manager itself.
//
// Note:
//    By the time this function gets called OnOcInitComponent has already determined
//    that Terminal Services is not installed. It is only necessary to determine
//    whether Terminal Services is selected for installation.
//--
/////////////////////////////////////////////////////////////////////////////

HRESULT
certocmOcQueryState(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent,
    IN DWORD SelectionState,
    IN PER_COMPONENT_DATA *pComp,
    OUT ULONG_PTR *pulpRet)
{
    HRESULT hr;
    SubComponentState stateRet = SubcompUseOcManagerDefault;
    DWORD  status;
    WCHAR awc[20];
    BOOL  fFinished;

    DBGPRINT((
            DBG_SS_CERTOCMI,
            "OC_QUERY_STATE(%ws, %ws, %x)\n",
            pwszComponent,
            pwszSubComponent,
            SelectionState));

    if (NULL == pwszSubComponent)
    {
        goto done;
    }

    switch(SelectionState)
    {
        case OCSELSTATETYPE_ORIGINAL:
        {
            // check to see if the post link exist
            hr = CheckPostBaseInstallStatus(&fFinished);
            _JumpIfError(hr, error, "CheckPostBaseInstallStatus");

            if (!pComp->fPostBase &&
                (SETUPOP_STANDALONE & pComp->Flags) )
            {
                // install through Components button
                if (!fFinished)
                {
                    // don't honor local reg SetupStatus
                    break;
                }
            }

            // Return the initial installation state of the subcomponent
            if (!pComp->fPostBase &&
                ((SETUPOP_STANDALONE & pComp->Flags) || 
                 (SETUPOP_NTUPGRADE & pComp->Flags)) )
            {
                //there is chance for user installed certsrv during base setup
                //and then upgrade without finishing CYS
                if (fFinished)
                {
                // If this is an upgrade or a standalone, query the registry to 
                // get the current installation status

                // XTAN, 7/99
                // currently certsrv_server has Needs relationship with
                // certsrv_client. OCM gathers success for certsrv_client before
                // certsrv_server is complete so we don't trust OCM state info
                // about certsrv_client and we check our reg SetupStatus here.
                // our certsrv_server Needs define is incorrect. If we take it
                // out, we probably don't need to reg SetupStatus at 
                // Configuration level at all and we can trust OCM state info

                hr = GetSetupStatus(NULL, &status);
                if (S_OK == hr)
                {
                    if (
                        (0 == lstrcmpi(wszSERVERSECTION, pwszSubComponent) &&
                         !(SETUP_SERVER_FLAG & status)) ||
                        (0 == lstrcmpi(wszCLIENTSECTION, pwszSubComponent) &&
                         !(SETUP_CLIENT_FLAG & status))
                       )
                    {
                        // overwrite OCM default
                        stateRet = SubcompOff;
                    }
                }
                }
            }
            break;
        }
        case OCSELSTATETYPE_CURRENT:
        {
            break;
        }

        case OCSELSTATETYPE_FINAL:
        {
            SUBCOMP const *psc;
            BOOL  fWasEnabled;

            if (S_OK != pComp->hrContinue && !pComp->fUnattended)
            {
                stateRet = SubcompOff;
            }

            //get component install info
            psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
            if (NULL == psc)
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error: unsupported component");
            }
            fWasEnabled = certocmWasEnabled(pComp, psc->cscSubComponent);

            // after all of this, change upgrade->uninstall if not supported
            if ((SETUPOP_NTUPGRADE & pComp->Flags) && fWasEnabled)
            {
               CSASSERT(pComp->UpgradeFlag != CS_UPGRADE_UNKNOWN);
               if (CS_UPGRADE_UNSUPPORTED == pComp->UpgradeFlag)
                  stateRet = SubcompOff;
            }


            break;
        }
    }

done:
    hr = S_OK;
error:
    wsprintf(awc, L"%u", SelectionState);
    CSILOG(S_OK, IDS_LOG_SELECTIONSTATE, awc, NULL, (DWORD const *) &stateRet);
    *pulpRet = stateRet;
    return(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CertSrvOCProc( . . . . )
//
//  Synopsis:   Service procedure for Cert Server OCM Setup.
//
//  Arguments:  [pwszComponent]
//              [pwszSubComponent]
//              [Function]
//              [Param1]              
//              [Param2]
//
//  Returns:    DWORD 
//
//  History:    04/07/97        JerryK  Created
// 
//-------------------------------------------------------------------------

ULONG_PTR
CertSrvOCProc(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN UINT Function,
    IN UINT_PTR Param1,
    IN OUT VOID *Param2)
{
    ULONG_PTR ulpRet = 0;
    WCHAR const *pwszFunction = NULL;
    BOOL fReturnErrCode = TRUE;

    __try
    {
	switch (Function) 
	{
	    // OC_PREINITIALIZE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = CHAR top level component string
	    // Param1 = char width flags
	    // Param2 = unused
	    //
	    // Return code is char width allowed flags

	    case OC_PREINITIALIZE:
		csiLogOpen("+certocm.log");
		pwszFunction = L"OC_PREINITIALIZE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_PREINITIALIZE");

		g_Comp.hrContinue = certocmOcPreInitialize(
					pwszComponent,
					(UINT)Param1, //cast to UINT, use as flags
					&ulpRet);
		break;


	    // OC_INIT_COMPONENT:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = unused
	    // Param2 = points to IN OUT SETUP_INIT_COMPONENT structure
	    //
	    // Return code is Win32 error indicating outcome.

	    case OC_INIT_COMPONENT:
		pwszFunction = L"OC_INIT_COMPONENT";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_INIT_COMPONENT");

		g_Comp.hrContinue = certocmOcInitComponent(
					NULL, // probably have to pass null hwnd
					pwszComponent,
					(SETUP_INIT_COMPONENT *) Param2,
					&g_Comp,
					&ulpRet);
		break;

	    case OC_SET_LANGUAGE:
		pwszFunction = L"OC_SET_LANGUAGE";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_SET_LANGUAGE");
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_SET_LANGUAGE(%ws, %ws, %x, %x)\n",
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;

	    // OC_QUERY_IMAGE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = low 16 bits specify image; only small icon supported
	    // Param2 = low 16 bits = desired width, high 16 bits = desired height
	    //
	    // Return value is the GDI handle of a small bitmap to be used.


	    case OC_QUERY_IMAGE:
		pwszFunction = L"OC_QUERY_IMAGE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_IMAGE");

		g_Comp.hrContinue = certocmOcQueryImage(
					pwszComponent,
					pwszSubComponent,
					(SubComponentInfo) LOWORD(Param1),
					LOWORD((ULONG_PTR) Param2),
					HIWORD((ULONG_PTR) Param2),
					&g_Comp,
					&ulpRet);
		break;

	    // OC_REQUEST_PAGES:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = Type of wiz pages being requested (WizardPagesType enum)
	    // Param2 = points to IN OUT SETUP_REQUEST_PAGES structure
	    //
	    // Return value is number of pages the component places in the
	    // SETUP_REQUEST_PAGES structure.

	    case OC_REQUEST_PAGES:
		pwszFunction = L"OC_REQUEST_PAGES";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_REQUEST_PAGES");

		g_Comp.hrContinue = certocmOcRequestPages(
						pwszComponent,
						(WizardPagesType) Param1,
						(SETUP_REQUEST_PAGES *) Param2,
						&g_Comp,
						&ulpRet);
		break;

	    // OC_QUERY_CHANGE_SEL_STATE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = proposed new sel state; 0 = unselected, non 0 = selected
	    // Param2 = flags -- OCQ_ACTUAL_SELECTION
	    //
	    // Return boolean to indicate whether to allow selection state change

	    case OC_QUERY_CHANGE_SEL_STATE:
		pwszFunction = L"OC_QUERY_CHANGE_SEL_STATE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_CHANGE_SEL_STATE");

		g_Comp.hrContinue = certocmOcQueryChangeSelState(
					g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
					pwszComponent,
					pwszSubComponent,
					(BOOL) Param1,
					(DWORD) (ULONG_PTR) Param2,
					&g_Comp,
					&ulpRet);
		break;

	    // OC_CALC_DISK_SPACE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = 0 for removing component or non 0 for adding component
	    // Param2 = HDSKSPC to operate on
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_CALC_DISK_SPACE:
		pwszFunction = L"OC_CALC_DISK_SPACE";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_CALC_DISK_SPACE");

		g_Comp.hrContinue = certocmOcCalcDiskSpace(
					pwszComponent,
					pwszSubComponent,
					(BOOL) Param1,
					(HDSKSPC) Param2,
					&g_Comp,
					&ulpRet);
		break;

	    // OC_QUEUE_FILE_OPS:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused
	    // Param2 = HSPFILEQ to operate on
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_QUEUE_FILE_OPS:
		pwszFunction = L"OC_QUEUE_FILE_OPS";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUEUE_FILE_OPS");

		g_Comp.hrContinue = certocmOcQueueFileOps(
					g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
					pwszComponent,
					pwszSubComponent,
					(HSPFILEQ) Param2,
					&g_Comp,
					&ulpRet);
		break;

	    // Params? xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	    // OC_NOTIFICATION_FROM_QUEUE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is ???

	    case OC_NOTIFICATION_FROM_QUEUE:
		pwszFunction = L"OC_NOTIFICATION_FROM_QUEUE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_NOTIFICATION_FROM_QUEUE(%ws, %ws, %x, %x)\n",
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;

	    // OC_QUERY_STEP_COUNT:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is an arbitrary 'step' count or -1 if error.

	    case OC_QUERY_STEP_COUNT:
		pwszFunction = L"OC_QUERY_STEP_COUNT";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_STEP_COUNT");

		g_Comp.hrContinue = (DWORD) certocmOcQueryStepCount(
						    pwszComponent,
						    pwszSubComponent,
						    &ulpRet);
		break;

	    // OC_COMPLETE_INSTALLATION:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = reserved for future expansion
	    // Param2 = unused
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_COMPLETE_INSTALLATION:
		pwszFunction = L"OC_COMPLETE_INSTALLATION";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_COMPLETE_INSTALLATION");

		g_Comp.hrContinue = certocmOcCompleteInstallation(
				g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
				pwszComponent,
				pwszSubComponent,
				&g_Comp,
				&ulpRet);
		break;

	    // OC_CLEANUP:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is ignored

	    case OC_CLEANUP:
		// don't _LeaveIfError(g_Comp.hrContinue, "OC_CLEANUP");
		// avoid memory leaks

		pwszFunction = L"OC_CLEANUP";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		certocmOcCleanup(pwszComponent, &g_Comp);
		break;

	    // Params? xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	    // OC_QUERY_STATE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused? (but Index Server uses it for current state)!
	    // Param2 = unused
	    //
	    // Return value is from the SubComponentState enumerated type

	    case OC_QUERY_STATE:
		pwszFunction = L"OC_QUERY_STATE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		//don't _LeaveIfError(g_Comp.hrContinue, "OC_QUERY_STATE");

		certocmOcQueryState(
			    pwszComponent,
			    pwszSubComponent,
			    (DWORD)Param1, //cast to DWORD, use as flags
			    &g_Comp,
			    &ulpRet);
		break;

	    // Params? xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	    // OC_NEED_MEDIA:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = unused
	    // Param2 = unused
	    //
	    // Return value is ???

	    case OC_NEED_MEDIA:
		pwszFunction = L"OC_NEED_MEDIA";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_NEED_MEDIA(%ws, %ws, %x, %x)\n",
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;

	    // OC_ABOUT_TO_COMMIT_QUEUE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = WCHAR sub-component string
	    // Param1 = reserved for future expansion
	    // Param2 = unused
	    //
	    // Return value is Win32 error code indicating outcome.

	    case OC_ABOUT_TO_COMMIT_QUEUE:
		pwszFunction = L"OC_ABOUT_TO_COMMIT_QUEUE";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_ABOUT_TO_COMMIT_QUEUE");

		g_Comp.hrContinue = certocmOcCommitQueue(
				    g_Comp.HelperRoutines.QueryWizardDialogHandle(g_Comp.HelperRoutines.OcManagerContext),
				    pwszComponent,
				    pwszSubComponent,
				    &g_Comp);
		break;

	    // OC_QUERY_SKIP_PAGE:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = unused
	    // Param1 = OcManagerPage page indicator
	    // Param2 = unused
	    //
	    // Return value is a boolean -- 0 for display or non 0 for skip

	    case OC_QUERY_SKIP_PAGE:
		pwszFunction = L"OC_QUERY_SKIP_PAGE";
		fReturnErrCode = FALSE;
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"OC_QUERY_SKIP_PAGE(%ws, %x)\n",
			pwszComponent,
			(OcManagerPage) Param1));
		_LeaveIfError(g_Comp.hrContinue, "OC_QUERY_SKIP_PAGE");

		if (g_Comp.fPostBase &&
		    (WizardPagesType) Param1 == WizPagesWelcome)
		{
		    ulpRet = 1; // non 0 to skip wiz page
		}
		break;

	    // OC_WIZARD_CREATED:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = ???
	    // Param1 = ???
	    // Param2 = ???
	    //
	    // Return value is ???

	    case OC_WIZARD_CREATED:
		pwszFunction = L"OC_WIZARD_CREATED";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_WIZARD_CREATED");
		break;

	    // OC_EXTRA_ROUTINES:
	    // pwszComponent = WCHAR top level component string
	    // pwszSubComponent = ???
	    // Param1 = ???
	    // Param2 = ???
	    //
	    // Return value is ???

	    case OC_EXTRA_ROUTINES:
		pwszFunction = L"OC_EXTRA_ROUTINES";
		CSILOG(g_Comp.hrContinue, IDS_LOG_BEGIN, pwszFunction, pwszSubComponent, NULL);
		_LeaveIfError(g_Comp.hrContinue, "OC_EXTRA_ROUTINES");
		break;

	    // Some other notification:

	    default:
		fReturnErrCode = FALSE;
		CSILOG(
		    g_Comp.hrContinue,
		    IDS_LOG_BEGIN,
		    pwszFunction,
		    pwszSubComponent,
		    (DWORD const *) &Function);
		DBGPRINT((
			DBG_SS_CERTOCMI,
			"DEFAULT(0x%x: %ws, %ws, %x, %x)\n",
			Function,
			pwszComponent,
			pwszSubComponent,
			Param1,
			Param2));
		break;
	}
    }
    __except(ulpRet = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	if (S_OK == g_Comp.hrContinue)
	{
	    g_Comp.hrContinue = (HRESULT)ulpRet;
	}
	_PrintError((HRESULT)ulpRet, "Exception");
    }

    DBGPRINT((DBG_SS_CERTOCMI, "return %p\n", ulpRet));

    // make sure to get a pop up in case of fatal error
    if (S_OK != g_Comp.hrContinue)
    {
        if (!g_Comp.fShownErr)
        {
            int iMsgId = g_Comp.iErrMsg;
            if (0 == iMsgId)
            {
                // use generic one
                iMsgId = IDS_ERR_CERTSRV_SETUP_FAIL;
            }
            CertErrorMessageBox(
                    g_Comp.hInstance,
                    g_Comp.fUnattended,
                    NULL,  // null hwnd
                    iMsgId,
                    g_Comp.hrContinue,
                    g_Comp.pwszCustomMessage);
            g_Comp.fShownErr = TRUE;
        }
        // anything fails, cancel install
        HRESULT hr2 = CancelCertsrvInstallation(NULL, &g_Comp);
        _PrintIfError(hr2, "CancelCertsrvInstallation");
    }
    CSILOG(
	fReturnErrCode? (HRESULT) ulpRet : S_OK,
	IDS_LOG_END,
	pwszFunction,
	pwszSubComponent,
	fReturnErrCode? NULL : (DWORD const *) &ulpRet);
    return(ulpRet);
}


ULONG_PTR
CertSrvOCPostProc(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN UINT Function,
    IN UINT Param1,
    IN OUT VOID *Param2)
{
    // post setup entry point
    // by going through this path, we know it is invoked in post setup
    g_Comp.fPostBase = TRUE;

    return CertSrvOCProc(
                pwszComponent,
                pwszSubComponent,
                Function,
                Param1,
                Param2);
}

VOID
certocmBumpGasGauge(
    OPTIONAL IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentComplete
    DBGPARM(IN WCHAR const *pwszSource))
{
    static DWORD dwTickCount = 0;

    if (NULL != pComp)
    {
        DWORD NewCount;

        NewCount = (PerCentComplete * SERVERINSTALLTICKS)/100;
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmBumpGasGauge(%ws, %u%%) %d ticks: %d --> %d\n",
            pwszSource,
            PerCentComplete,
            NewCount - dwTickCount,
            dwTickCount,
            NewCount));

        if (SERVERINSTALLTICKS < NewCount)
        {
            NewCount = SERVERINSTALLTICKS;
        }
        while (dwTickCount < NewCount)
        {
            (*pComp->HelperRoutines.TickGauge)(
                                pComp->HelperRoutines.OcManagerContext);
            dwTickCount++;
        }
    }
}

BOOL
certocmEnabledSub(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp,
    DWORD SelectionStateType)
{
    SUBCOMP const *psc;
    BOOL bRet = FALSE;
    
    psc = LookupSubComponent(SubComp);
    if (NULL != psc->pwszSubComponent)
    {
        if (pComp->fUnattended &&
            OCSELSTATETYPE_CURRENT == SelectionStateType &&
            0 == (pComp->Flags & SETUPOP_NTUPGRADE) )
        {
            // unattended case, flags from unattended file
            // upgrade is automatically in unattended mode and make sure
            // to exclude it
            bRet = psc->fInstallUnattend;
        }
        else
        {
            bRet = (*pComp->HelperRoutines.QuerySelectionState)(
                pComp->HelperRoutines.OcManagerContext,
                psc->pwszSubComponent,
                SelectionStateType);
        }
    }
    return(bRet);
}


BOOL
certocmIsEnabled(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    bRet = certocmEnabledSub(pComp, SubComp, OCSELSTATETYPE_CURRENT);
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmIsEnabled(%ws) Is %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"Enabled" : L"Disabled"));
    }
    return(bRet);
}


BOOL
certocmWasEnabled(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    bRet = certocmEnabledSub(pComp, SubComp, OCSELSTATETYPE_ORIGINAL);
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmWasEnabled(%ws) Was %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"Enabled" : L"Disabled"));
    }
    return(bRet);
}


BOOL
certocmUninstalling(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    fDebugSupress++;
    bRet = certocmWasEnabled(pComp, SubComp) && !certocmIsEnabled(pComp, SubComp);
    fDebugSupress--;
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmUninstalling(%ws) %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"TRUE" : L"False"));
    }
    return(bRet);
}


BOOL
certocmInstalling(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    fDebugSupress++;
    bRet = !certocmWasEnabled(pComp, SubComp) && certocmIsEnabled(pComp, SubComp);
    fDebugSupress--;
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmInstalling(%ws) %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"TRUE" : L"False"));
    }
    return(bRet);
}


BOOL
certocmPreserving(
    PER_COMPONENT_DATA *pComp,
    CertSubComponent SubComp)
{
    BOOL bRet;

    fDebugSupress++;
    bRet = certocmWasEnabled(pComp, SubComp) && certocmIsEnabled(pComp, SubComp);
    fDebugSupress--;
    if (!fDebugSupress)
    {
        DBGPRINT((
            DBG_SS_CERTOCMI,
            "certocmPreserving(%ws) %ws\n",
            LookupSubComponent(SubComp)->pwszSubComponent,
            bRet? L"TRUE" : L"False"));
    }
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\cspenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cspenum.h
//
//--------------------------------------------------------------------------

#ifndef _CSPENUM_H_
#define _CSPENUM_H_

HRESULT
SetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszCAName,
    IN DWORD dwProvType,
    IN WCHAR const *pwszProvName,
    IN ALG_ID idAlg,
    IN BOOL fMachineKeyset,
    IN DWORD dwKeySize);

HRESULT GetCSPInfoList(CSP_INFO** pCSPInfoList);
void FreeCSPInfoList(CSP_INFO* pCSPInfoList);
CSP_INFO* topCSPInfoList(CSP_INFO *pCSPInfoList);
CSP_INFO* findCSPInfoFromList(
    CSP_INFO    *pCSPInfoList,
    WCHAR const *pwszProvName,
    const DWORD  dwProvType);

CSP_HASH *topHashInfoList(CSP_HASH *pHashInfoList);

CSP_INFO *
newCSPInfo(
    DWORD    dwProvType,
    WCHAR   *pwszProvName);

void 
freeCSPInfo(CSP_INFO *pCSPInfo);

CSP_INFO*
findCSPInfoFromList(
    CSP_INFO    *pCSPInfoList,
    WCHAR const *pwszProvName,
    const DWORD  dwProvType);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

RESDEPENDFILES = \
    res.hm \
    $(O)\msg.rc \
    $(O)\msg00001.bin

$(O)\csocm.res:	$(RESDEPENDFILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"ocmsetup"

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <setupapi.h>
#include <ocmanage.h>

#include <certsrv.h>
#include "certlib.h"
#include "initcert.h"
#include "res.h"
#include "setuput.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\dssetup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        setup.cpp
//
// Contents:    
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include <accctrl.h>
#include <ntldap.h>
#include "certca.h"
#include "cainfop.h"
#include "csldap.h"
#include "dssetup.h"



#define __dwFILE__	__dwFILE_OCMSETUP_DSSETUP_CPP__


typedef HRESULT (* LPFNDLL_INSTALL)(BOOL bInstall, LPCWSTR pszCmdLine);


BOOL
IsCAExistInDS(
    IN WCHAR const *pwszSanitizedName)
{
    BOOL       exist = FALSE;
    HRESULT    hr;
    HCAINFO    hCAInfo = NULL;
    WCHAR *pwszDSName = NULL;

    hr = mySanitizedNameToDSName(pwszSanitizedName, &pwszDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
		pwszDSName,
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCAInfo);
    _JumpIfErrorStr(hr, error, "IsCAExistInDS:CAFindByName", pwszDSName);

    if (NULL == hCAInfo)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid CA in DS");
    }
    exist = TRUE;

error:
    if (NULL != pwszDSName)
    {
        LocalFree(pwszDSName);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    return exist;
}




BOOL
IsDSAvailable(VOID)
{
    // fail out quickly if DS not present on domain
    if (S_OK != myDoesDSExist(FALSE))
        return FALSE;

    BOOL     available = FALSE;
    LDAP    *pldap = NULL;
    ULONG    ldaperr;
    HRESULT hr;
    HMODULE hMod = NULL;

    hMod = LoadLibrary(L"wldap32.dll");
    if (NULL == hMod)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "LoadLibrary", L"wldap32.dll");
    }
    // bind to ds
    hr = myRobustLdapBind(&pldap, FALSE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    available = TRUE;

error:
    if (NULL != pldap)
    {
        ldap_unbind(pldap);
    }
    if (NULL != hMod)
    {
        FreeLibrary(hMod);
    }
    return available;
}


HRESULT
RemoveCAInDS(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT    hr;
    HCAINFO    hCAInfo = NULL;
    WCHAR *pwszDSName = NULL;

    hr = mySanitizedNameToDSName(pwszSanitizedName, &pwszDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
		pwszDSName,
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCAInfo);
    _JumpIfErrorStr(hr, error, "RemoveCAInDS:CAFindByName", pwszDSName);

    if (NULL == hCAInfo)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid CA in DS");
    }
    hr = CADeleteCA(hCAInfo);
    _JumpIfError(hr, error, "CADeleteCA");

    hr = RemoveCAMachineFromCertPublishers();
    _JumpIfError(hr, error, "RemoveCAInDS");

error:
    if (NULL != pwszDSName)
    {
        LocalFree(pwszDSName);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    return hr;
}


DWORD 
GetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT BSTR *DomainDn,
    OUT BSTR *ConfigDn
    )
/*++

Routine Description:
    
    This routine simply queries the operational attributes for the
    domaindn and configdn.
    
    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session
    
    DomainDn      : a pointer to a string to be allocated in this routine
    
    ConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and
    
    Other operation errors.
    
--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];

    WCHAR  *DefaultNamingContext       = L"defaultNamingContext";
    WCHAR  *ConfigurationNamingContext = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectClass=*";

    //
    // These must be present
    //

    //
    // Set the out parameters to null
    //
    if(ConfigDn)
    {
        *ConfigDn = NULL;
    }
    if(DomainDn)
    {
        *DomainDn = NULL;
    }

    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = DefaultNamingContext;
    AttrArray[1] = ConfigurationNamingContext;
    AttrArray[2] = NULL;  // this is the sentinel

    LdapError = ldap_search_sW(LdapHandle,
                               NULL,
                               LDAP_SCOPE_BASE,
                               ObjectClassFilter,
                               AttrArray,
                               FALSE,
                               &SearchResult);

    WinError = myHLdapError(LdapHandle, LdapError, NULL);

    if (ERROR_SUCCESS == WinError) {

        Entry = ldap_first_entry(LdapHandle, SearchResult);

        if (Entry) {

            Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

            while (Attr) {

                if (!_wcsicmp(Attr, DefaultNamingContext)) {

                    if(DomainDn)
                    {
                        Values = ldap_get_values(LdapHandle, Entry, Attr);

                        if (Values && Values[0]) {
                            (*DomainDn) = SysAllocString(Values[0]);
                            _JumpIfOutOfMemory(WinError, error, *DomainDn);
                        }
                        ldap_value_free(Values);
                    }

                } else if (!_wcsicmp(Attr, ConfigurationNamingContext)) {

                    if(ConfigDn)
                    {
                        Values = ldap_get_valuesW(LdapHandle, Entry, Attr);

                        if (Values && Values[0]) {
                            (*ConfigDn) = SysAllocString(Values[0]);
                            _JumpIfOutOfMemory(WinError, error, *ConfigDn);
                        }
                        ldap_value_free(Values);
                    }
                }

                Attr = ldap_next_attribute(LdapHandle, Entry, BerElement);
            }
        }

        if ( (DomainDn &&(!(*DomainDn))) || (ConfigDn && (!(*ConfigDn)))) {
            //
            // We could get the default domain - bail out
            //
            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

        }

    }

error:
    return WinError;
}


HRESULT CreateCertDSHierarchy(VOID)
{

    HRESULT hr = S_OK;
    ULONG   ldaperr;
    LDAP *pld = NULL;
    LDAPMod objectClass;

    DWORD err;

    WCHAR *objectClassVals[3];
    LDAPMod *mods[2];
    BSTR     bstrConfigDN = NULL;


    WCHAR * awszLocations[] = {
        L"CN=Public Key Services,CN=Services,",
        L"CN=Enrollment Services,CN=Public Key Services,CN=Services,",
        NULL,
    };

    WCHAR ** pwszCurLocation;
    DWORD                    cbBuffer;
    BSTR                     bstrBuffer = NULL;

	// bind to ds
    hr = myRobustLdapBind(&pld, FALSE);

    if(hr != S_OK)
    {
        goto error;
    }

    err = GetAuthoritativeDomainDn(pld, NULL, &bstrConfigDN);
    if(err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    pwszCurLocation = awszLocations;
    // Build the Public Key Services container
    mods[0] = &objectClass;
    mods[1] = NULL;

    objectClass.mod_op = 0;
    objectClass.mod_type = TEXT("objectclass");
    objectClass.mod_values = objectClassVals;

    objectClassVals[0] = TEXT("top");
    objectClassVals[1] = TEXT("container");
    objectClassVals[2] = NULL;

    while(*pwszCurLocation)
    {
        cbBuffer = wcslen(*pwszCurLocation) + wcslen(bstrConfigDN) + 1;

        // Build a string containing the CA Location
        bstrBuffer = SysAllocStringLen(NULL, cbBuffer);
        if(bstrBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        wcscpy(bstrBuffer, *pwszCurLocation);
        wcscat(bstrBuffer, bstrConfigDN);

        ldaperr = ldap_add_s(pld, bstrBuffer, mods);
        SysFreeString(bstrBuffer);
        if(ldaperr != LDAP_SUCCESS && ldaperr != LDAP_ALREADY_EXISTS)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
            goto error;
        }
        pwszCurLocation++;
    }

error:

    if(bstrConfigDN)
    {
        SysFreeString(bstrConfigDN);
    }

    if(pld != NULL)
    {
        ldap_unbind(pld);
        pld = NULL;
    }

    return hr;
}


// 
HRESULT InitializeCertificateTemplates(VOID)
{
    HRESULT hr = S_OK;
    DWORD   err = ERROR_SUCCESS;

    HINSTANCE hCertCli = NULL;
    LPFNDLL_INSTALL lpfnDllInstall = NULL;

    hCertCli = LoadLibrary(L"certcli.dll");
    if(hCertCli == NULL)
    {
        hr = myHLastError();
        goto error;
    }
    lpfnDllInstall = (LPFNDLL_INSTALL)GetProcAddress(hCertCli, "DllInstall");
    if(lpfnDllInstall == NULL)
    {
        hr = myHLastError();
        goto error;
    }
    err = lpfnDllInstall(TRUE, L"i");
    hr = HRESULT_FROM_WIN32(err);


error:


    return hr;

}


HRESULT 
DNStoDirectoryName(IN LPWSTR wszDNSDomain, 
                   OUT LPWSTR *pwszDN)

{
    HRESULT hr = S_OK;
    DWORD cDN;
    LPWSTR wszResult = NULL;

    LPWSTR wszCurrent, wszNext;

    if (wszDNSDomain == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "DNStoDirectoryName");
    }

    if(0==wcsncmp(wszDNSDomain, L"\\\\", 2))
    {
        // this is a DC DNS name, skip the machine name
        wszDNSDomain = wcschr(wszDNSDomain, L'.');
        
        // no dot found?
        if(!wszDNSDomain)
        {
            hr =E_UNEXPECTED;
            _JumpError(hr, error, "DC DNS doesn't contain at least one dot");
        }
        
        // jump over the dot
        wszDNSDomain++;

        // no domain name following the DC name?
        if(L'\0'==*wszDNSDomain)
        {
            hr = E_UNEXPECTED;
            _JumpError(hr, error, "DC DNS name doesn't contain a domain name");
        }
    }

    // Estimate the size of the output string
    cDN = wcslen(wszDNSDomain) + 3;

    wszCurrent=wszDNSDomain;

    while(wszCurrent = wcschr(wszCurrent, L'.'))
    {
        cDN += 4;  // sizeof ,DC= 
        wszCurrent++;
    }
    cDN += 1; // NULL terminate

    wszResult = (LPWSTR)LocalAlloc(LMEM_FIXED, cDN * sizeof(WCHAR));
    
    if(wszResult == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    wszCurrent=wszDNSDomain;

    // prepend the first DC=
    wszNext = wszResult + 3;
    wcscpy(wszResult, L"DC=");
    while(*wszCurrent)
    {
        if(*wszCurrent != '.')
        {
            *wszNext++ = *wszCurrent++;
        }
        else
        {
            wszCurrent++;
            if(*wszCurrent)
            {
                wcscpy(wszNext, L",DC=");
                wszNext += 4;
            }
        }
    }
    *wszNext = 0;

    if(pwszDN)
    {
        *pwszDN = wszResult;
        wszResult = NULL;
    }
error:

    if(wszResult)
    {
        LocalFree(wszResult);
    }
    return hr;
}


HRESULT CurrentUserCanInstallCA(bool& fCanInstall)
{
    HRESULT hr;
    HANDLE hThread = NULL; // no free
    HANDLE hAccessToken = NULL, hDupToken = NULL;
    LDAP *pld = NULL;
    BSTR bstrConfigDN = NULL;
    LPWSTR pwszPKIContainerFilter = 
        L"(&(objectClass=container)(CN=Public Key Services))";
    LPWSTR pwszSDAttr = L"nTSecurityDescriptor";
    LPWSTR pwszAttrArray[3];
    LDAPMessage* pResult = NULL;
    LDAPMessage *pEntry;
    struct berval **bervalSD = NULL;
    PSECURITY_DESCRIPTOR pSD; // no free
    GENERIC_MAPPING mapping;
    PRIVILEGE_SET PrivilegeSet;
    DWORD cPrivilegeSet = sizeof(PrivilegeSet);
    DWORD dwGrantedAccess;
    BOOL fAccess = FALSE;
    struct l_timeval timeout;
    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, 
        DACL_SECURITY_INFORMATION |
        OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    PLDAPControl    server_controls[2] =
                    {
                        &se_info_control,
                        NULL
                    };

    pwszAttrArray[0] = pwszSDAttr;
    pwszAttrArray[1] = L"name";
    pwszAttrArray[2] = NULL;

    ZeroMemory(&mapping, sizeof(mapping));

    fCanInstall = false;

    // Get the access token for current thread
    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }

    if (!OpenThreadToken(
            hThread,
            TOKEN_QUERY | TOKEN_DUPLICATE,
            FALSE,
            &hAccessToken))
    {
        hr = myHLastError();

        if(hr==HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            HANDLE hProcess = GetCurrentProcess();
            if (NULL == hProcess)
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetCurrentProcess");
            }

            if (!OpenProcessToken(hProcess,
                    TOKEN_DUPLICATE,
                    &hAccessToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "OpenProcessToken");
            }

            if (!DuplicateToken(hAccessToken, SecurityIdentification, &hDupToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "DuplicateToken");
            }

        }
        else
        {
            _JumpError(hr, error, "OpenThreadToken");
        }
    }

    hr = myRobustLdapBind(
        &pld,
        TRUE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    hr = myGetAuthoritativeDomainDn(
        pld,
        NULL,
        &bstrConfigDN);
    _JumpIfError(hr, error, "myGetAuthoritativeDomainDn");

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    hr = ldap_search_ext_s(
                    pld,
                    bstrConfigDN,
                    LDAP_SCOPE_SUBTREE,
                    pwszPKIContainerFilter,
                    pwszAttrArray,
                    0,
                    (PLDAPControl *)&server_controls,
                    NULL,
                    &timeout,
                    0,
                    &pResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_sW");

    pEntry = ldap_first_entry(pld, pResult);
    if (NULL == pEntry)
    {
        hr = myHLdapLastError(pld, NULL);
        _JumpError(hr, error, "ldap_first_entry");
    }

    bervalSD = ldap_get_values_len(pld, pEntry, pwszSDAttr);

    if(bervalSD && (*bervalSD)->bv_val)
    {
        pSD = (*bervalSD)->bv_val;

        if(IsValidSecurityDescriptor(pSD))
        {
            if(!AccessCheck(
                    pSD,
                    hDupToken,
                    ACTRL_DS_WRITE_PROP |
                    WRITE_DAC |
                    ACTRL_DS_CREATE_CHILD,
                    &mapping,
                    &PrivilegeSet,
                    &cPrivilegeSet,
                    &dwGrantedAccess,
                    &fAccess))
            {
                hr = myHLastError();

                if(E_ACCESSDENIED==hr)
                {
                    hr = S_OK;
                }
                _JumpError(hr, error, "AccessCheck");
            }
        }
        else
        {
            DBGPRINT((DBG_SS_CERTOCM, "Invalid security descriptor for PKI container" ));
        }
    }
    else
    {
        DBGPRINT((DBG_SS_CERTOCM, "No security descriptor for PKI container" ));
    }

    if(fAccess)
    {
        fCanInstall = true;
    }

error:
    if(bervalSD)
    {
        ldap_value_free_len(bervalSD);
    }
    if(bstrConfigDN)
    {
        SysFreeString(bstrConfigDN);
    }
    if (NULL != pResult)
    {
        ldap_msgfree(pResult);
    }
    if (pld)
    {
        ldap_unbind(pld);
    }
    if (hAccessToken)
    {
        CloseHandle(hAccessToken);
    }
    if (hDupToken)
    {
        CloseHandle(hDupToken);
    }

    //we should always return S_OK; since we do not want to abort
    //ocmsetup just because we failed to contact the directory
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\pfximpt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pfximpt.cpp
//
//  Contents:   PFX import dialog
//
//  History:    06/98   xtan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "cscsp.h"
#include "certmsg.h"
#include "initcert.h"
#include "setuput.h"
#include "cspenum.h"
#include "wizpage.h"
#include "usecert.h"


#define __dwFILE__      __dwFILE_OCMSETUP_PFXIMPT_CPP__


typedef struct _certpfximportinfo
{
    HINSTANCE hInstance;
    BOOL      fUnattended;
    WCHAR   *pwszFileName;
    DWORD    dwFileNameSize;
    WCHAR   *pwszPassword;
    DWORD    dwPasswordSize;
} CERTPFXIMPORTINFO