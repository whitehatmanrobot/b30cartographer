 + 1 == j ) ? ' ' : ',' ));

                }

            fprintf( hOutput, "};\n" );

            }
         }

    /** dump the vectors to the token vs state table **/

    fprintf(hOutput, "\n#define VALIDTOKENS %d\n", ValidTokens );
    fprintf( hOutput, "\nTOKVSSTATEVECTOR TokVsState%s[ VALIDTOKENS ] = { \n",pPrefix);

    for( i = 0;
         i < MAXTOKENVALUE+1;
         ++i )
        {

        if( j = pTokVsStateIndex[ i ])
            {
            fprintf( hOutput, "\n{ %d, _tS%s%.4d, %d }",i, pPrefix, i, j );
            fprintf(hOutput, "%c", (i + 1 == NTOKENS) ? ' ' : ',' );
            }


        }

    fprintf( hOutput, "\n\n};\n" );
    fprintf( hOutput, "\n" );

fprintf(hOutput, "#endif\n");

    }


BOOL
SearchForStateInTokenVsState(
    short TokenValue,
    short Goto )
    {
    int i,j;

    for( i = 0, j = pTokVsStateIndex[ TokenValue ];
         i < j;
         ++i )
        {
        if( *(pTokVsState[ TokenValue ] + i) == Goto )
            return TRUE;
        }
    return FALSE;
    }

void
TranslateExpectedConstructs( void )
    {
    int i,State,Count,Temp;
    char Buffer[ MAX_TRANSLATION_LINE_SIZE ];
    char Buffer1[ MAX_TRANSLATION_LINE_SIZE ];
    DBENTRY *p;
    XLAT    *pX;

    /**
        firstly, read in the translation data base, which shows the
        expected token name vs the actual error string the compiler wants to
        output.
     **/

    for(;;)
        {
        i = fscanf( hXlatFile,
                    "%[^ \t]%1s%[^\n]\n",
                    Buffer,
                    &Temp,
                    Buffer1 );

        if( i == EOF || i == 0 )
            break;

        if( ( Buffer[0] != '$' ) && ( Buffer[1] != '$' ) )
            {
            pX = calloc( 1 , sizeof( XLAT ) );

                        if (!pX )
                            {
                            fprintf( stderr, "Out of memory!" );
                            exit(OUT_OF_MEMORY );
                            }

            pX->pIncoming = malloc( strlen( Buffer ) + 1 );
                     
                        if (!pX->pIncoming )
                            {
                            fprintf( stderr, "Out of memory!" );
                            exit(OUT_OF_MEMORY );
                            }
                        
            strcpy( pX->pIncoming, Buffer );

            pX->pTranslated = malloc( strlen( Buffer1 ) + 1 );

                        if (!pX->pTranslated)
                           {
                           fprintf( stderr, "Out of memory!" );
                           exit(OUT_OF_MEMORY );
                           }

            strcpy( pX->pTranslated, Buffer1 );

            if( pXlatCur == 0 )
                {
                pXlatCur = pXlat = pX;
                }
            else
                {
                pXlatCur->pNext = pX;
                pXlatCur = pX;
                }
            }
        }
         

    /**
        Then read the STATE_VS_EXPECTED_FILE, and read in the expected
        tokens/productions for each entry, as translated by looking up the
        data base.
     **/

    p = pDataBase;

    while( p < (pDataBase + MAXSTATEVSEXPECTED) )
        {

        CHECK_FSCAN_STATUS( 
            fscanf( hStateVsExpectedFile, "%d %c %d %c",
                    &State,
                    &Temp,
                    &Count,
                    &Temp,
                    Buffer ) );



        if( Count )
            {
            CHECK_FSCAN_STATUS( 
                fscanf( hStateVsExpectedFile, " %[^\n]\n", Buffer ) );
            p->State = (short) State;
            p->pTranslated = Translate( Buffer );
            p++;
            }
        else
            CHECK_FSCAN_STATUS( 
                fscanf( hStateVsExpectedFile, "\n" ) );

        }
    /**
        emit the state vs expected array with the proper prefix
     **/

    fprintf( hOutput, "\n#ifndef _DBENTRY_DEFINED\n" );
    fprintf( hOutput, "\n#define _DBENTRY_DEFINED\n" );
    fprintf( hOutput, "\ntypedef struct _DBENTRY {" );
    fprintf( hOutput, "\n\t short State;");
    fprintf( hOutput, "\n\t char * pTranslated;");
    fprintf( hOutput, "\n} DBENTRY;\n");
    fprintf( hOutput, "\n#endif\n" );

    fprintf( hOutput, "\n#define MAXSTATEVSEXPECTED_SIZE_%s %d\n", pPrefix, MAXSTATEVSEXPECTED );
    fprintf( hOutput, "\n DBENTRY %s_SyntaxErrorDB[ MAXSTATEVSEXPECTED_SIZE_%s ] = {\n", pPrefix, pPrefix);

    for( p = pDataBase;
         p < (pDataBase + MAXSTATEVSEXPECTED);
         p++ )
        {
        fprintf( hOutput, "{ %d , \"%s\"},\n" , p->State, p->pTranslated );
        }

    fprintf( hOutput, "\n};\n" );

    }

char *
Translate(
    char *pIncoming )
    {
    char *p;

    pXlatCur = pXlat;

    while( pXlatCur )
        {
        if( strcmp( pXlatCur->pIncoming, pIncoming ) == 0 )
            return pXlatCur->pTranslated;
        pXlatCur = pXlatCur->pNext;
        }

    p = malloc( strlen( pIncoming ) + 1 );
 
        if (!p )
            {
            fprintf( stderr, "Out of memory.\n" );
            exit( OUT_OF_MEMORY );
            }

    strcpy( p, pIncoming );

    return p;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\pg\gram.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

# define ID 257
# define NUMBER 258
# define TOKEN_CASE 259
# define TOKEN_CHAR 260
# define TOKEN_END 261
# define TOKEN_END_CASE 262
# define TOKEN_MYACT 263
# define TOKEN_START 264
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\erec\ebase.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef __EBASE_H__
#define __EBASE_H__

typedef struct _sgoto
	{
	short	Goto;
	short	Token;
	} SGOTO;

typedef struct _sgotovector
	{

	short		State;
	SGOTO	*	pSGoto;
	short		Count;

	} SGOTOVECTOR;

typedef struct _tokvsstatevector
	{
	short		Token;
	short	*	pTokenVsState;
	short		Count;
	} TOKVSSTATEVECTOR;

#endif//__EBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\pg\flexcom.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* common macro definitions for C/FTL programs generated by flex */


/* returned upon end-of-file */
#define YY_END_TOK 0

/* action number for an "end-of-file was seen and yywrap indicated that we
 * should continue processing"
 */
#define YY_NEW_FILE -1

/* action number for "the default action should be done" */
#define YY_DO_DEFAULT -2

#ifndef BUFSIZ
#include <stdio.h>
#endif

#define YY_BUF_SIZE (BUFSIZ * 2) /* size of input buffer */

/* number of characters one rule can match.  One less than YY_BUF_SIZE to make
 * sure we never access beyond the end of an array
 */
#define YY_BUF_MAX (YY_BUF_SIZE - 1)

/* we will never use more than the first YY_BUF_LIM + YY_MAX_LINE positions
 * of the input buffer
 */
#ifndef YY_MAX_LINE
#define YY_MAX_LINE BUFSIZ
#endif

#define YY_BUF_LIM (YY_BUF_MAX - YY_MAX_LINE)

/* copy whatever the last rule matched to the standard output */

#define ECHO fputs( yytext, yyout )

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#if 1
#define YY_INPUT(buf,result,max_size) \
	{	\
	result = fread( buf, 1, max_size, yyin );	\
	if( ferror( yyin ) )	\
	    YY_FATAL_ERROR( "fread() in flex scanner failed" );	\
	}
#else // 0
#define YY_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(yyin), buf, max_size )) < 0 ) \
	    YY_FATAL_ERROR( "read() in flex scanner failed" );
#endif // 0

#define YY_NULL 0

/* macro used to output a character */
#define YY_OUTPUT(c) putc( c, yyout );

/* report a fatal error */
#define YY_FATAL_ERROR(msg) \
	{ \
	fputs( msg, stderr ); \
	putc( '\n', stderr ); \
	exit( 1 ); \
	}

/* returns the first character of the matched text */
#define YY_FIRST_CHAR yy_ch_buf[yy_b_buf_p]

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way that old Unix-lex does it
 */
#define BEGIN yy_start = 1 +

/* callable from YY_INPUT to set things up so that '%' will match.  Proper
 * usage is "YY_SET_BOL(array,pos)"
 */
#define YY_SET_BOL(array,pos) array[pos - 1] = '\n';

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define YY_DECL int yylex()

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
	{ \
	YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */ \
	yy_c_buf_p = yy_b_buf_p + n - 1; \
	YY_DO_BEFORE_ACTION; /* set up yytext again */ \
	}

/* code executed at the end of each rule */
#define YY_BREAK break;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\pg\flexskel.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* macro definitions for compressed-table C/FTL programs generated by flex */

#include "flexcom.h"

/* reinitializes everything except the current start condition.  The last
 * input character is set to a newline so an initial beginning-of-line
 * rule will match
 */
#define YY_INIT \
	{ \
	yyleng = yy_c_buf_p = yy_e_buf_p = 0; \
	yy_hold_char = yy_ch_buf[yy_c_buf_p] = '\n'; \
	yytext = &yy_ch_buf[yy_c_buf_p]; \
	yy_saw_eof = 0; \
	}

/* returns the length of the matched text */
#define YY_LENG (yy_c_buf_p - yy_b_buf_p + 1)

/* done before the next pattern has been matched action */
#define YY_DO_BEFORE_SCAN \
	yytext[yyleng] = yy_hold_char;

/* done after the current pattern has been matched and before the corresponding action */
#define YY_DO_BEFORE_ACTION \
	yytext = &yy_ch_buf[yy_b_buf_p]; \
	yyleng = YY_LENG; \
	yy_hold_char = yytext[yyleng]; \
	yytext[yyleng] = '\0';

/* find the next rule matched */
#ifdef FLEX_REJECT_ENABLED
#define REJECT \
        { \
	YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */ \
	yy_c_buf_p = yy_full_match; /* restore possibly backed-over text */ \
        ++yy_lp; \
        goto find_rule; \
        }
#else
#define REJECT YY_FATAL_ERROR( "REJECT used and scanner was not generated using -r" )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\pg\lex.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

union   s_lextype   {
	char	*	yystring;
	int			yynumber;
	char		yycharval;
};

typedef union s_lextype lextype_t;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\pg\gram.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*
 * Created by CSD YACC (IBM PC) from "gram.y" */


/****************************************************************************
 ***		local defines
 ***************************************************************************/

#define pascal 
#define FARDATA
#define NEARDATA
#define FARCODE
#define NEARCODE
#define NEARSWAP

#define PASCAL pascal
#define CDECL
#define VOID void
#define CONST const
#define GLOBAL

#define YYSTYPE         lextype_t
#define YYNEAR          NEARCODE
#define YYPASCAL        PASCAL
#define YYPRINT         printf
#define YYSTATIC        static
#define YYLEX           yylex
#define YYPARSER        yyparse

#define MAXARRAY				1000
#define CASE_BUFFER_SIZE		10000

#define CASE_FN_FORMAT			("\nvoid\n%s_case_fn_%.4d()")
#define DISPATCH_ENTRY_FORMAT	("\n\t,%s_case_fn_%.4d")
#define DISPATCH_FIRST_ENTRY	("\n\t %s_case_fn_%.4d")

/****************************************************************************
 ***		include files
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "lex.h"

/****************************************************************************
 ***		externals 
 ***************************************************************************/

extern	int			Incase;
extern	int			ActionSensed;
extern	int			yylex();
extern	int			yyparse();
extern	char	*	name_prefix;

/****************************************************************************
 ***		local procs 
 ***************************************************************************/

void				Init( void );
void				EmitCaseTableArray( void );
void				EmitDefaultCase( void );
void				EmitCaseBody( int );
void				RegisterCase( int );
void				BufferIt( char * pStr, int iLen );
void				ResetBuffer();
void				FlushBuffer();

/****************************************************************************
 ***		local data 
 ***************************************************************************/

unsigned	long	SavedIDCount	= 0;
unsigned	long	IDCount			= 0;
unsigned	char	CaseTable[ MAXARRAY ] = { 0 };
int					CaseNumber		= 0;
int					MaxCaseNumber	= 0;
char		*		pBufStart;
char		*		pBufCur;
char		*		pBufEnd;

# define ID 257
# define NUMBER 258
# define TOKEN_CASE 259
# define TOKEN_CHAR 260
# define TOKEN_END 261
# define TOKEN_END_CASE 262
# define TOKEN_MYACT 263
# define TOKEN_START 264
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
#ifndef YYFARDATA
#define	YYFARDATA	/*nothing*/
#endif
#if ! defined YYSTATIC
#define	YYSTATIC	/*nothing*/
#endif
#ifndef YYOPTTIME
#define	YYOPTTIME	0
#endif
#ifndef YYR_T
#define	YYR_T	int
#endif
typedef	YYR_T	yyr_t;
#ifndef YYEXIND_T
#define	YYEXIND_T	unsigned int
#endif
typedef	YYEXIND_T	yyexind_t;
#ifndef	YYACT
#define	YYACT	yyact
#endif
#ifndef	YYPACT
#define	YYPACT	yypact
#endif
#ifndef	YYPGO
#define	YYPGO	yypgo
#endif
#ifndef	YYR1
#define	YYR1	yyr1
#endif
#ifndef	YYR2
#define	YYR2	yyr2
#endif
#ifndef	YYCHK
#define	YYCHK	yychk
#endif
#ifndef	YYDEF
#define	YYDEF	yydef
#endif
#ifndef	YYLOCAL
#define	YYLOCAL
#endif
# define YYERRCODE 256



/*****************************************************************************
 *	utility functions
 *****************************************************************************/
YYSTATIC VOID FARCODE PASCAL 
yyerror(char *szError)
	{
		extern int Line;
		extern char LocalBuffer[];

		fprintf(stderr, "%s at Line %d near %s\n", szError, Line, LocalBuffer);
	}
void
Init()
	{
	pBufStart = pBufCur = malloc( CASE_BUFFER_SIZE );
	if( !pBufStart )
		{
		fprintf(stderr,"Out Of Memory\n");
		exit(1);
		}
	pBufEnd = pBufStart + CASE_BUFFER_SIZE;
	}

void
BufferIt( 
	char	*	pStr,
	int			iLen )
	{
	if( pBufCur + iLen > pBufEnd )
		{
		printf("ALERT iLen = %d\n", iLen );
//		assert( (pBufCur + iLen) <= pBufEnd );
		exit(1);
		}
	strncpy( pBufCur , pStr, iLen );
	pBufCur += iLen;
	*pBufCur = '\0';
	}

void
ResetBuffer()
	{
	pBufCur = pBufStart;
	*pBufCur= '\0';
	}

void
FlushBuffer()
	{
	fprintf(stdout, "%s", pBufStart);
	ResetBuffer();
	}

void
EmitCaseBody( 
	int		CaseNumber )
	{
	fprintf( stdout, CASE_FN_FORMAT, name_prefix, CaseNumber );
	FlushBuffer();
	fprintf( stdout, "}\n" );
	}

void
EmitCaseTableArray()
	{
	int		i, iTemp;

	fprintf( stdout, "const pfn\t %s_case_fn_array[] = \n\t{", name_prefix );
	fprintf( stdout,DISPATCH_FIRST_ENTRY,name_prefix, 0 );

	for( i = 1 ; i <= MaxCaseNumber ; ++i )
		{
		iTemp = CaseTable[ i ] ? i : 0;
		fprintf(stdout,DISPATCH_ENTRY_FORMAT,name_prefix, iTemp );
		}

	fprintf( stdout, "\n\t};\n" );
	fprintf( stdout, "\nstatic void\nyy_vc_init()\n{ \n\tpcase_fn_array = (pfn *) %s_case_fn_array;\n\tyym_vc_max = %d;\n}\n" , name_prefix, MaxCaseNumber);
	}

void
EmitDefaultCase()
	{
	fprintf(stdout, "void\n%s_case_fn_%.4d() {\n\t}\n\n", name_prefix, 0 );
	}
void
RegisterCase(
	int		iCase )
	{
	CaseTable[ iCase ] = 1;
	}
YYSTATIC short yyexca[] ={
#if !(YYOPTTIME)
-1, 1,
#endif
	0, -1,
	-2, 0,
	};
# define YYNPROD 16
#if YYOPTTIME
YYSTATIC yyexind_t yyexcaind[] = {
0,
0,
	};
#endif
# define YYLAST 39
YYSTATIC short YYFARDATA YYACT[]={

   8,  13,  28,   6,   7,  16,   5,  25,  23,  21,
  24,   2,  20,   4,   3,  26,  19,   9,  15,  12,
  10,   1,  11,   0,  14,   0,   0,  17,  18,   0,
   0,   0,  22,   0,   0,   0,   0,   0,  27 };
YYSTATIC short YYFARDATA YYPACT[]={

-254,-1000,-264,-254,-1000,-1000,-1000,-1000,-1000,-1000,
-254,-262,-254,-1000,-256,-254,-254,-250,-1000,-250,
-1000,-252,-1000,-248,-253,-1000,-254,-260,-1000 };
YYSTATIC short YYFARDATA YYPGO[]={

   0,  21,  11,  20,  19,  18,  16,  12,  15,  14,
  13 };
YYSTATIC yyr_t YYFARDATA YYR1[]={

   0,   3,   1,   5,   4,   6,   6,   8,   7,   2,
   2,   9,   9,  10,  10,  10 };
YYSTATIC yyr_t YYFARDATA YYR2[]={

   0,   0,   8,   0,   4,   2,   1,   0,   7,   1,
   0,   2,   1,   1,   1,   1 };
YYSTATIC short YYFARDATA YYCHK[]={

-1000,  -1,  -2,  -9, -10, 260, 257, 258, 264, -10,
  -3,  -2,  -4, 263,  -2,  -5, 261,  -2,  -2,  -6,
  -7, 259,  -7, 260, 258, 260,  -8,  -2, 262 };
YYSTATIC short YYFARDATA YYDEF[]={

  10,  -2,   0,   9,  12,  13,  14,  15,   1,  11,
  10,   0,  10,   3,   0,  10,  10,   0,   2,   4,
   6,   0,   5,   0,   0,   7,  10,   0,   8 };
#ifdef YYRECOVER
YYSTATIC short yyrecover[] = {
-1000	};
#endif
/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
YYSTATIC YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC int yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */
short yyexpected;

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif
#ifdef VC_ERRORS
static short yysavestate = 0;
#endif

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps;
	YYSTYPE		*yypv;
	short		yyj, yym;

#ifdef YYDEBUG
	yydebug = 1;
#endif // YYDEBUG

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else // YYDEBUG
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif // YYDEBUG
	if( ++yyps > &yys[YYMAXDEPTH] ) {
#ifdef VC_ERRORS
		yyerror( "yacc stack overflow", -1 );
#else //  VC_ERRORS
		yyerror( "yacc stack overflow");
#endif //  VC_ERRORS
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

#ifdef VC_ERRORS
	yysavestate = yystate;
#endif

	yyn = yypact[yystate];

yyexpected = -yyn;

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}
	if( yychar < 0 ) {	/*  need a lookahead */
		yychar = YYLEX();
	}
	if( ((yyn += (short) yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}
	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ){ /* error */
		/* error ... attempt to resume parsing */

		switch( yyerrflag ){

		case 0:		/* brand new error */
#ifdef YYRECOVER
			{
			register	int		i,j;

			for(i = 0;
				(yyrecover[i] != -1000) && (yystate > yyrecover[i]);
				i += 3
			) {
				;
			}
			if(yystate == yyrecover[i]) {
#ifdef YYDEBUG
				yyprintf("recovered, from state %d to state %d on token %d\n",
						yystate,yyrecover[i+2],yyrecover[i+1], 0
						);
#else // YYDEBUG
				yyprintf("recovered, from state %d to state %d on token %d\n",
						yystate,yyrecover[i+2],yyrecover[i+1]
						);
#endif // YYDEBUG
				j = yyrecover[i + 1];
				if(j < 0) {
				/*
				**  here we have one of the injection set, so we're not quite
				**  sure that the next valid thing will be a shift. so we'll
				**  count it as an error and continue.
				**  actually we're not absolutely sure that the next token
				**  we were supposed to get is the one when j > 0. for example,
				**  for(+) {;} error recovery with yyerrflag always set, stops
				**  after inserting one ; before the +. at the point of the +,
				**  we're pretty sure the guy wants a 'for' loop. without
				**  setting the flag, when we're almost absolutely sure, we'll
				**  give him one, since the only thing we can shift on this
				**  error is after finding an expression followed by a +
				*/
					yyerrflag++;
					j = -j;
					}
				if(yyerrflag <= 1) {	/*  only on first insertion  */
					yyrecerr(yychar,j);	/*  what was, what should be first */
				}
				yyval = yyeval(j);
				yystate = yyrecover[i + 2];
				goto yystack;
				}
			}
#endif

#ifdef VC_ERRORS
		yyerror("syntax error", yysavestate);
#else
		yyerror("syntax error");
#endif

		// yyerrlab:
			++yynerrs;

		case 1:
		case 2: /* incompletely recovered error ... try again */

			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */

			while ( yyps >= yys ) {
			   yyn = yypact[*yyps] + YYERRCODE;
			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
			      yystate = yyact[yyn];  /* simulate a shift of "error" */
			      goto yystack;
			      }
			   yyn = yypact[*yyps];

			   /* the current yyps has no shift onn "error", pop stack */

#ifdef YYDEBUG
yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1], 0, 0 );
#else // YYDEBUG
yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1], 0  );
#endif // YYDEBUG
			   --yyps;
			   --yypv;
			   }

			/* there is no state on the stack with an error shift ... abort */

	yyabort:
			return(1);


		case 3:  /* no shift yet; clobber input char */

#ifdef YYDEBUG
			yyprintf( "error recovery discards char %d\n", yychar, 0, 0, 0 );
#else // YYDEBUG
			yyprintf( "error recovery discards char %d\n", yychar, 0, 0 );
#endif // YYDEBUG
			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
			yychar = -1;
			goto yynewstate;   /* try again in the same state */
			}
		}

	/* reduction by production yyn */
// yyreduce:
		{
		register	YYSTYPE	*yypvt;
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else // YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif // YYDEBUG
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = (short) yyr1[yyn];	/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		switch(yym){
			
case 1:
{
		Init();
		} break;
case 2:
{
		EmitDefaultCase();
		EmitCaseTableArray();
		} break;
case 3:
{
		ActionSensed++;
		ResetBuffer();
		} break;
case 4:
{
		} break;
case 5:
{
		} break;
case 6:
{
		} break;
case 7:
{
		Incase = 1;

		CaseNumber		= yypvt[-1].yynumber;
		if(yypvt[-1].yynumber >= MAXARRAY)
			{
			fprintf(stderr, "Case Limit Reached : Contact Dov/Vibhas\n");
			return 1;
			}

		SavedIDCount	= IDCount;
		} break;
case 8:
{
		if(SavedIDCount != IDCount)
			{
			RegisterCase( CaseNumber );
			EmitCaseBody( CaseNumber );
			}

		ResetBuffer();

		if(CaseNumber > MaxCaseNumber)
			MaxCaseNumber = CaseNumber;
		Incase = 0;
		} break;
case 9:
{
		} break;
case 10:
{
		} break;
case 11:
{
		} break;
case 12:
{
		} break;
case 13:
{
		if(!ActionSensed)
			fprintf(stdout, "%c", yypvt[-0].yycharval);
		else
			BufferIt( &yypvt[-0].yycharval, 1);
		} break;
case 14:
{
		IDCount++;
		if(!ActionSensed)
			fprintf(stdout, "%s", yypvt[-0].yystring);
		else
			BufferIt( yypvt[-0].yystring, strlen(yypvt[-0].yystring) );
		} break;
case 15:
{
		if(!ActionSensed)
			fprintf(stdout, "%d", yypvt[-0].yynumber);
		else
			{
			char	buffer[20];
			sprintf(buffer,"%d", yypvt[-0].yynumber );
			BufferIt( buffer, strlen(buffer) );
			}
		} break;/* End of actions */
			}
		}
		goto yystack;  /* stack new state and value */
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\pg\lexyy.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define YY_DEFAULT_ACTION ECHO;
#define FLEX_USE_ECS
#define FLEX_USE_MECS
/* A lexical scanner generated by flex */

#include "flexskel.h"

#define INITIAL 0
/***
 *** lexer for preprocessing the parser driver generated by yacc, in
 *** order to convert the big switch statement into individual semantic
 *** functions
 ***/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include "lex.h"
#include "gram.h"

#define VC_PRINTF( x ) /** printf(x) **/

void		LexInstall_ID( void );
void		LexInstall_Number( void );
int			IsToken( void );
lextype_t	yylval;
int			Line = 0;
int			Incase = 0;
int			ActionSensed = 0;
char		LocalBuffer[ 100 ];

#define YY_JAM 40
#define YY_JAM_BASE 65
#define YY_TEMPLATE 41
static char l[41] =
    {   0,
       -2,   -2,    6,    5,    4,    1,    6,    4,    1,    0,
        0,    0,    0,    0,    0,    0,    0,    2,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    3,    0
    } ;

static char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    1,    1,    1,    1,    6,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    1,    8,    1,
        1,    1,    1,    1,    9,    9,    9,    9,   10,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        1,    1,    1,    1,    9,    1,   11,   12,   13,   14,

       15,   16,    9,    9,   17,    9,   18,    9,    9,   19,
       20,    9,    9,   21,   22,   23,    9,    9,    9,    9,
        9,    9,    1,    1,   24,    1,    1
    } ;

static char m[25] =
    {   0,
        1,    1,    1,    1,    1,    1,    2,    1,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    1
    } ;

static short int b[43] =
    {   0,
        0,   24,   65,   65,   58,    0,   60,   56,    0,   50,
       40,   45,   48,   40,   49,   47,    7,   65,   51,    8,
       12,   33,   33,   42,   25,   28,   39,   31,   28,   17,
       22,   18,   18,   12,   15,   31,   17,   18,   65,   65,
       53,   13
    } ;

static short int d[43] =
    {   0,
       41,   41,   40,   40,   40,   42,   40,   40,   42,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,-32767,
       40,   40
    } ;

static short int n[90] =
    {   0,
        3,    3,    4,    3,    3,    3,    5,    3,   17,   21,
       17,   21,   19,   21,    9,   21,   36,   22,   36,   37,
       39,   22,   38,    7,    3,    3,    4,    3,    3,    3,
        5,    3,   36,   35,   36,   37,   34,   33,   32,   31,
       30,   29,   28,   27,   26,   25,   24,    7,   17,   18,
       17,   23,   19,    6,    6,   20,   16,   15,   14,   13,
       12,   11,    8,   10,    8,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40
    } ;

static short int c[90] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,   17,   20,
       17,   20,   17,   21,   42,   21,   35,   20,   35,   35,
       38,   21,   37,    1,    2,    2,    2,    2,    2,    2,
        2,    2,   36,   34,   36,   36,   33,   32,   31,   30,
       29,   28,   27,   26,   25,   24,   23,    2,   16,   16,
       16,   22,   16,   41,   41,   19,   15,   14,   13,   12,
       11,   10,    8,    7,    5,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin, *yyout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
static int yyleng;

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;
#ifdef FLEX_REJECT_ENABLED
    int yy_full_match;
#endif




    if ( yy_init )
	{
VC_PRINTF( "Init\n");
	YY_INIT;
	yy_start = 1;
	yy_init = 0;
	}

    goto get_next_token;

do_action:

VC_PRINTF( "do_action\n");

#ifdef FLEX_REJECT_ENABLED
    /* remember matched text in case we back up due to trailing context */
    yy_full_match = yy_c_buf_p;
#endif

    for ( ; ; )
	{
	YY_DO_BEFORE_ACTION

VC_PRINTF( "For loop \n");

#ifdef FLEX_DEBUG
	fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
	switch ( yy_act )
	    {
case 1:
{
							int	Token;

				VC_PRINTF(" Case 1\n");

							if( Token = IsToken() )
								{
								return Token;
								}
							else
								LexInstall_ID();
							return ID;
							}
	break;
case 2:
{
				VC_PRINTF(" Case 2\n");
							Line++;
							return TOKEN_END_CASE;
							}
	break;
case 3:
{
				VC_PRINTF(" Case 3\n");
							Line++;
							return TOKEN_END_CASE;
							}
	break;
case 4:
{
				VC_PRINTF(" Case 4\n");
							LexInstall_Number();
							return NUMBER;
							}
	break;
case 5:
{
				VC_PRINTF(" Case 5\n");
							Line++;
							yylval.yycharval = '\n';
							return TOKEN_CHAR;
							}
	break;
case 6:
{
				VC_PRINTF(" Case 6\n");
							yylval.yycharval = yytext[0];
							return TOKEN_CHAR;
							}
	break;
case 7:
YY_DEFAULT_ACTION;
	YY_BREAK

case YY_NEW_FILE:
break; /* begin reading from new file */

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
	    }

get_next_token:
	{
	register int yy_curst;
	register char yy_sym;

VC_PRINTF( "Get_next_token 1\n");

	YY_DO_BEFORE_SCAN

	/* set up to begin running DFA */

	yy_curst = yy_start;

	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
	    ++yy_curst;

	/* yy_b_buf_p points to the position in yy_ch_buf
	 * of the start of the current run.
	 */

	yy_b_buf_p = yy_c_buf_p + 1;

VC_PRINTF( "Get_next_token 2\n");

	do /* until the machine jams */
	    {
	    if ( yy_c_buf_p == yy_e_buf_p )
		{ /* need more input */
		if ( yy_e_buf_p >= YY_BUF_LIM )
		    { /* not enough room to do another read */
		    /* see if we can make some room for more chars */

VC_PRINTF( "Get_next_token 4\n");
		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;

		    if ( yy_n_chars >= 0 )
			/* shift down buffer to make room */
			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
			    {
VC_PRINTF( "Get_next_token 5\n");
			    yy_buf_pos = yy_b_buf_p + yy_iii;
			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
			    }

		    yy_b_buf_p = 0;
		    yy_e_buf_p = yy_n_chars;

		    if ( yy_e_buf_p >= YY_BUF_LIM )
			YY_FATAL_ERROR( "flex input buffer overflowed" );

		    yy_c_buf_p = yy_e_buf_p;
		    }

		else if ( yy_saw_eof )
		    {
VC_PRINTF( "Get_next_token 6\n");
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
			{
			if ( yywrap() )
			    {
			    yy_act = YY_END_TOK;
			    goto do_action;
			    }
			
			else
			    {
			    YY_INIT;
			    yy_act = YY_NEW_FILE;
			    goto do_action;
			    }
			}

		    else /* do a jam to eat up more input */
			{
#ifndef FLEX_INTERACTIVE_SCANNER
			/* we're going to decrement yy_c_buf_p upon doing
			 * the jam.  In this case, that's wrong, since
			 * it points to the last non-jam character.  So
			 * we increment it now to counter the decrement.
			 */
			++yy_c_buf_p;
#endif
VC_PRINTF( "Get_next_token 7\n");
			break;
			}
		    }

VC_PRINTF( "Get_next_token 8\n");
		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
			  YY_MAX_LINE );

		if ( yy_n_chars == YY_NULL )
		    {
VC_PRINTF( "Get_next_token 9\n");
		    if ( yy_saw_eof )
	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
		    yy_saw_eof = 1;
		    goto saweof;
		    }

		yy_e_buf_p += yy_n_chars;
		}

	    ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
	    yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

VC_PRINTF( "Get_next_token 10\n");

#ifdef FLEX_FULL_TABLE
	    yy_curst = n[yy_curst][yy_sym];

#else /* get next state from compressed table */

	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
		{
		yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
		/* we've arrange it so that templates are never chained
		 * to one another.  This means we can afford make a
		 * very simple test to see if we need to convert to
		 * yy_sym's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		if ( yy_curst >= YY_TEMPLATE )
		    yy_sym = m[yy_sym];
#endif
		}

	    yy_curst = n[b[yy_curst] + yy_sym];

#endif

VC_PRINTF( "Get_next_token 11\n");
	    yy_st_buf[yy_c_buf_p] = yy_curst;

	    }
#ifdef FLEX_INTERACTIVE_SCANNER
	while ( b[yy_curst] != YY_JAM_BASE );
#else
	while ( yy_curst != YY_JAM );
	--yy_c_buf_p; /* put back character we jammed on */

#endif

	if ( yy_c_buf_p >= yy_b_buf_p )
	    { /* we matched some text */
	    yy_curst = yy_st_buf[yy_c_buf_p];
	    yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
#endif

	    for ( ; ; ) /* until we find what rule we matched */
		{
#ifdef FLEX_REJECT_ENABLED
		if ( yy_lp && yy_lp < l[yy_curst + 1] )
		    {
		    yy_act = a[yy_lp];
		    goto do_action; /* "continue 2" */
		    }
#else
		if ( yy_lp )
		    {
		    yy_act = yy_lp;
		    goto do_action; /* "continue 2" */
		    }
#endif

		if ( --yy_c_buf_p < yy_b_buf_p )
		    break;

		yy_curst = yy_st_buf[yy_c_buf_p];
		yy_lp = l[yy_curst];
		}
	    }

	YY_FATAL_ERROR( "no match in flex scanner - possible NULL in input" );
	}
	}

    /*NOTREACHED*/
    }



/****************************************************************************
 *	utility routines
 ****************************************************************************/
/**************************************************************************
 *** install parser value stack
 **************************************************************************/

void
LexInstall_ID()
	{
	strncpy( LocalBuffer, yytext, yyleng );
	LocalBuffer[ yyleng ] = '\0';
	yylval.yystring = LocalBuffer;
	}
void
LexInstall_Number()
	{
	yylval.yynumber = atoi(yytext);
	}
/**************************************************************************
 *** token search
 **************************************************************************/
int
IsToken()
	{
static char *pTokens[] =
	{
	 "case"
	,"___a_r_u_myact"
	,"___a_r_u_start"
	,"___a_r_u_end"
	};
static int	Tokens[] =
	{
	 TOKEN_CASE
	,TOKEN_MYACT
	,TOKEN_START
	,TOKEN_END
	};

	int i = 0;
	int Token;

	while( i < sizeof(pTokens) / sizeof(char *) )
		{
		if(strcmp( pTokens[i] , yytext ) == 0 )
			{
			Token = Tokens[i];
			if(Token == TOKEN_CASE)
				{
				if(!ActionSensed || Incase)
					return 0;
				}
			return Token;
			}
		++i;
		}
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\pg\main.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

extern int yyparse();
extern FILE *yyin, *yyout;
char *	name_prefix;

void
main(
	int		argc,
	char	*argv[] )
	{

	int ExitCode;
	char * cur;

    yyin = stdin;
    yyout = stdout;
	fprintf(stderr, "Grammar (.cxx) munge utility\n");

	if( argc < 2 )
		{
		printf("Usage : pg <filename>\n");
		exit(1);
		}
	else
		{
		if( (yyin = fopen( argv[1], "rt" )) == (FILE *)NULL )
			{
			printf("Error opening file %s\n",  argv[1] );
			exit(1);
			}
		}

	name_prefix = _strdup( argv[1] );

    if ( NULL == name_prefix )
        {
        fprintf( stderr, "Out of memory" );
        exit(1);
        }

	name_prefix = _strlwr( name_prefix );
	for ( cur = name_prefix; islower( *cur ); cur++ );

	*cur = '\0';
	


	ExitCode	= yyparse();

	fprintf(stderr, "Exit Code (%d) \n", ExitCode );

	exit( ExitCode );

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\system.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*                             *********************
 *                             *  S Y S T E M . H  *
 *                             *********************
 *
 * This file replaces the original "files." header file. It defines, for
 * the IBM PC/XT version, the target parser function source file, overriding
 * file name string defines, and other system-specific definitions and
 * parameters.
 *
 * Bob Denny    06-Dec-80
 *
 * Edits:
 *              18-Dec-80  ZAPFILE no longer used in Decus Yacc.
 *                         Parser file renamed yypars.c
 *
 *              28-Aug-81  Temp files for RSX have specific version
 *                         numbers of 1 to avoid multi-versions. Rename
 *                         parser info file ".i".
 *
 *              12-Apr-83  Add FNAMESIZE & EX_xxx parameters.
 *
 *Scott Guthery 23-Dec-83  Adapt for the IBM PC/XT & DeSmet C compiler.
 *
 */

/* Define WORD32 if target machine is a 32 bitter */

# ifdef M_I386
# define WORD32
# define HUGETAB YES
# else
# define MEDTAB YES
#endif

/*
 * Name of INCLUDE environment string
 */
#define INCLUDE "INCLUDE"
#define LIBENV "LIB"

/*
 * Target parser source file
 */
# define PARSER "yypars.c"

/*
/*
 * Filespec definitions
 */
# define ACTNAME "yacc2.tmp"
# define TEMPNAME "yacc1.tmp"
# define FNAMESIZE 24

/*
 * Exit status values
 */
#define EX_SUC 0
#define EX_WAR 1
#define EX_ERR 2
#define EX_SEV 4

#define MIDL_UNLINK  _unlink
#define MIDL_STRDUP  _strdup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\fprot.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef FPROT_INCLUDED
#define FPROT_INCLUDED
#include <basetsd.h>
extern  void error(char *s, ...);
extern  struct looksets *flset(struct looksets *p);
extern  void main(int argc,char * *argv);
extern  int unix_getc(struct _iobuf *iop);
extern  void yungetc(SSIZE_T, FILE * );
extern  void prlook(struct looksets *p);
extern  void putitem(SSIZE_T *ptr,struct looksets *lptr);
extern  char *symnam(SSIZE_T i);
extern  int state(SSIZE_T c);
extern  int setunion(SSIZE_T *a,SSIZE_T *b);
extern  char *writem(SSIZE_T *pp);
extern  int defin(int t,char *s);
extern  void defout(void );
extern  SSIZE_T fdtype(SSIZE_T t);
extern  SSIZE_T gettok(void );
extern  void go2gen(int c);
extern  void go2out(void );
extern  void hideprod(void );
extern  void wrstate(int i);
extern  void aoutput(void );
extern  void gin(SSIZE_T i);
extern  int gtnm(void );
extern  int nxti(void );
extern  void stin(SSIZE_T i);
extern  void arout(char *s,SSIZE_T *v,SSIZE_T n);
extern  void writeline(FILE *fh);
extern	void aryfil( SSIZE_T *v, SSIZE_T n, SSIZE_T c );
extern	void cpfir( void );
extern	void cpres( void );
extern	void cempty( void );
extern	void callopt( void );
extern	void SSwitchExit( void );
extern	void summary( void );
extern	void cpyunion( void );
extern	void ydfout( void );
extern	void setup( int i, char *argv[] );
extern	int chfind( int, char * );
extern	void cpycode( void );
extern	void cpyact( SSIZE_T );
extern	void finact( void );
extern	void yyparse( void );
extern	void usage( void );
extern	void yg2out( void );
extern	void warray( char *, SSIZE_T *, int );
extern	void osummary( void );
extern	void others( void );
extern	void closure( int );
extern	int apack( SSIZE_T *, int );
extern	void stagen( void );
extern	void SSwitchInit( void );
extern	void EmitStateVsExpectedConstruct( int, SSIZE_T * );
extern	int CountStateVsExpectedConstruct( int, SSIZE_T * );
extern	void EmitStateGotoTable( int );
extern	void wdef( char *, int );
extern void wract( int );
extern void precftn( SSIZE_T, int, int );
extern void output( void );
extern int skipcom( void );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\util.c ===
/***************************** Module Header ****************************\
* Copyright (c) 1990-1999 Microsoft Corporation
*
* Module Name: util.c
*
* Extended functions for opening files on environment paths.
*
* Created: 01-May-90
*
* History:
*   01-May-90 created by SMeans
*
\************************************************************************/

#include <stdio.h>
#include <string.h>

FILE *pfopen(const char *path, char *search, const char *type)
{
    char szTmp[256];
    char *pszEnd;
    char c;
    FILE *fp;

    if (!(pszEnd = search)) {
        return fopen(path, type);
    }

    c = *search;

    while (c) {
        while (*pszEnd && *pszEnd != ';') {
            pszEnd++;
        }

        c = *pszEnd;
        *pszEnd = '\0';
        strcpy(szTmp, search);
        *pszEnd = c;

        if (szTmp[strlen(szTmp) - 1] != '\\') {
            strcat(szTmp, "\\");
        }

        strcat(szTmp, path);

        if (fp = fopen(szTmp, type)) {
            return fp;
        }

        search = ++pszEnd;
    }

    return (FILE *)NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\dtxtrn.h ===
/*
 * DTXTRN.H  -- Original extern file for UNIX YACC.
 *
 * Modified to call in "decus" or "vax11c" .H files to set up
 * parameters as appropriate.
 *
 * Copyright (c) 1993-1999 Microsoft Corporation
 */

#ifndef __DTXTRN_H__
#define __DTXTRN_H__

#include <stdio.h>
#include "system.h"

#include "fprot.h"

/*  MANIFEST CONSTANT DEFINITIONS */

/* base of nonterminal internal numbers */
#define NTBASE 010000

/* internal codes for error and accept actions */

#define ERRCODE  8190
#define ACCEPTCODE 8191

/* sizes and limits */

#ifdef HUGETAB              /* defined for a 32 bit machine */
#pragma message ("using HUGETAB")
#define ACTSIZE 12000
#define MEMSIZE 12000
#define NSTATES 1000        /* original value 750 */
#define NTERMS 512          /* original value 127 */
#define NPROD 600
#define NNONTERM 300
#define TEMPSIZE 1200
#define CNAMSZ 10000         /* original value 6000 then 8000*/
#define LSETSIZE 600
#define WSETSIZE 350
#endif

#ifdef MEDTAB           /* defined for a 16 bit machine */
#pragma message ("using MEDTAB")
    #if 0
        #define ACTSIZE 4000
        #define MEMSIZE 5200
        #define NSTATES 600
        #define NTERMS 127
        #define NPROD 400
        #define NNONTERM 200
        #define TEMPSIZE 800
        #define CNAMSZ 4000
        #define LSETSIZE 450
        #define WSETSIZE 250
    #else  // 0
        #define ACTSIZE 12000
        #define MEMSIZE 12000
        #define NSTATES 750
        #define NTERMS 512
        #define NPROD 600
        #define NNONTERM 300
        #define TEMPSIZE 1200
        #define CNAMSZ 5000
        #define LSETSIZE 600
        #define WSETSIZE 350
    #endif // 0
#endif

#ifdef SMALLTAB
#pragma message ("using SMALLTAB")
#define ACTSIZE 1000
#define MEMSIZE 1500
#define NSTATES 450
#define NTERMS 127
#define NPROD 200
#define NNONTERM 100
#define TEMPSIZE 600
#define CNAMSZ 1000
#define LSETSIZE 200
#define WSETSIZE 125
#endif

#define NAMESIZE 50
#define NTYPES 63

#ifdef WORD32
#define TBITSET ((32+NTERMS)/32)

/* bit packing macros (may be machine dependent) */
#define BIT(a,i) ((a)[(i)>>5] & (1<<((i)&037)))
#define SETBIT(a,i) ((a)[(i)>>5] |= (1<<((i)&037)))

/* number of words needed to hold n+1 bits */
#define NWORDS(n) (((n)+32)/32)

#else

#define TBITSET ((16+NTERMS)/16)

/* bit packing macros (may be machine dependent) */
#define BIT(a,i) ((a)[(i)>>4] & (1<<((i)&017)))
#define SETBIT(a,i) ((a)[(i)>>4] |= (1<<((i)&017)))

/* number of words needed to hold n+1 bits */
#define NWORDS(n) (((n)+16)/16)
#endif

/* relationships which must hold:
        TBITSET ints must hold NTERMS+1 bits...
        WSETSIZE >= NNONTERM
        LSETSIZE >= NNONTERM
        TEMPSIZE >= NTERMS + NNONTERMs + 1
        TEMPSIZE >= NSTATES
        */

/* associativities */

#define NOASC 0  /* no assoc. */
#define LASC 1  /* left assoc. */
#define RASC 2  /* right assoc. */
#define BASC 3  /* binary assoc. */

/* flags for state generation */

#define DONE 0
#define MUSTDO 1
#define MUSTLOOKAHEAD 2

/* flags for a rule having an action, and being reduced */

#define ACTFLAG 04
#define REDFLAG 010

/* output parser flags */
#define YYFLAG1 (-1000)

/* macros for getting associativity and precedence levels */

#define ASSOC(i) ((i)&03)
#define PLEVEL(i) (((i)>>4)&077)
#define TYPE(i)  ((i>>10)&077)

/* macros for setting associativity and precedence levels */

#define SETASC(i,j) i|=j
#define SETPLEV(i,j) i |= (j<<4)
#define SETTYPE(i,j) i |= (j<<10)

/* looping macros */

#define TLOOP(i) for(i=1;i<=ntokens;++i)
#define NTLOOP(i) for(i=0;i<=nnonter;++i)
#define PLOOP(s,i) for(i=s;i<nprod;++i)
#define SLOOP(i) for(i=0;i<nstate;++i)
#define WSBUMP(x) ++x
#define WSLOOP(s,j) for(j=s;j<cwp;++j)
#define ITMLOOP(i,p,q) q=pstate[i+1];for(p=pstate[i];p<q;++p)
#define SETLOOP(i) for(i=0;i<tbitset;++i)

/* I/O descriptors */

#ifndef y2imp
extern FILE * finput;           /* input file */
extern FILE * faction;          /* file for saving actions */
extern FILE *fdefine;           /* file for #defines */
extern FILE * ftable;           /* y.tab.c file */
extern FILE * ftemp;            /* tempfile to pass 2 */
extern FILE * foutput;          /* y.output file */
#endif

/* structure declarations */

struct looksets
   {
   SSIZE_T lset[TBITSET];
   };

struct item
   {
   SSIZE_T *pitem;
   struct looksets *look;
   };

struct toksymb
   {
   char *name;
   SSIZE_T value;
   };

struct ntsymb
   {
   char *name;
   SSIZE_T tvalue;
   };

struct wset
   {
   SSIZE_T *pitem;
   int flag;
   struct looksets ws;
   };

#ifndef y2imp
/* token information */extern int ntokens ;    /* number of tokens */
extern struct toksymb tokset[];
extern int toklev[];    /* vector with the precedence of the terminals */
#endif

/* nonterminal information */

#ifndef y2imp
extern int nnonter ;    /* the number of nonterminals */
extern struct ntsymb nontrst[];
#endif

/* grammar rule information */
#ifndef y2imp
extern int nprod ;      /* number of productions */
extern SSIZE_T *prdptr[];   /* pointers to descriptions of productions */
extern SSIZE_T levprd[] ;   /* contains production levels to break conflicts */
#endif

/* state information */

#ifndef y1imp
extern int nstate ;             /* number of states */
extern struct item *pstate[];   /* pointers to the descriptions of the states */
extern SSIZE_T tystate[];   /* contains type information about the states */
#ifndef y3imp
extern SSIZE_T defact[];    /* the default action of the state */
#endif
extern int tstates[];   /* the states deriving each token */
extern int ntstates[];  /* the states deriving each nonterminal */
extern int mstates[];   /* the continuation of the chains begun in tstates and ntstates */
#endif

/* lookahead set information */

#ifndef y1imp
extern struct looksets lkst[];
extern int nolook;  /* flag to turn off lookahead computations */
#endif

/* working set information */

#ifndef y1imp
extern struct wset wsets[];
extern struct wset *cwp;
#endif

/* storage for productions */
#ifndef y2imp
extern SSIZE_T mem0[];
extern SSIZE_T *mem;
#endif

/* storage for action table */

#ifndef y1imp
extern SSIZE_T amem[];  /* action table storage */
extern SSIZE_T *memp ;              /* next free action table position */
extern SSIZE_T indgo[];             /* index to the stored goto table */

/* temporary vector, indexable by states, terms, or ntokens */

extern SSIZE_T temp1[];
extern int lineno; /* current line number */

/* statistics collection variables */

extern int zzgoent ;
extern int zzgobest ;
extern int zzacent ;
extern int zzexcp ;
extern int zzclose ;
extern int zzrrconf ;
extern int zzsrconf ;
extern char *pszPrefix;
#endif

/* define functions with strange types... */extern char *cstash();
extern struct looksets *flset();
extern char *symnam();
extern char *writem();

/* default settings for a number of macros */

#define ISIZE 400       /* Specific for static in cpres() */

/* name of yacc tempfiles */

#ifndef TEMPNAME
#define TEMPNAME "yacc.tmp"
#endif

#ifndef ACTNAME
#define ACTNAME "yacc.act"
#endif

/* output file name */

#ifndef OFILE
#define OFILE "ytab.c"
#endif

/* user output file name */

#ifndef FILEU
#define FILEU "y.out"
#endif

/* output file for #defines */

#ifndef FILED
#define FILED "ytab.h"
#endif

/* Size of complete filespec */
#ifndef FNAMESIZE
#define FNAMESIZE 32
#endif

/* command to clobber tempfiles after use */

#ifndef ZAPFILE
#define ZAPFILE(x) MIDL_UNLINK(x)
#endif

#endif /* __DTXTRN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y1imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data used by modules originally in Y1.C. External declarations in Y1.H */

#define y1imp yes
#include "dtxtrn.h"

/* lookahead computations */

int tbitset;  /* size of lookahead sets */
struct looksets lkst [ LSETSIZE ];
int nlset = 0; /* next lookahead set index */
int nolook = 0; /* flag to suppress lookahead computations */
struct looksets clset;  /* temporary storage for lookahead computations */

/* working set computations */

struct wset wsets[ WSETSIZE ];
struct wset *cwp;

/* state information */

int nstate = 0;         /* number of states */
struct item *pstate[NSTATES+2]; /* pointers to the descriptions of the states */
SSIZE_T tystate[NSTATES];   /* contains type information about the states */
SSIZE_T indgo[NSTATES];             /* index to the stored goto table */
int tstates[ NTERMS ]; /* states generated by terminal gotos */
int ntstates[ NNONTERM ]; /* states generated by nonterminal gotos */
int mstates[ NSTATES ]; /* chain of overflows of term/nonterm generation lists  */

/* storage for the actions in the parser */

SSIZE_T amem[ACTSIZE];      /* action table storage */
SSIZE_T *memp = amem;       /* next free action table position */

/* other storage areas */

SSIZE_T temp1[TEMPSIZE]; /* temporary storage, indexed by terms + ntokens or states */
int lineno= 1; /* current input line number */
int fatfl = 1;          /* if on, error is fatal */
int nerrors = 0;        /* number of errors */

/* storage for information about the nonterminals */

SSIZE_T **pres[NNONTERM+2];  /* vector of pointers to productions yielding each nonterminal */
struct looksets *pfirst[NNONTERM+2];  /* vector of pointers to first sets for each nonterminal */
SSIZE_T pempty[NNONTERM+1];  /* vector of nonterminals nontrivially deriving e */

/* accumulators for statistics information */

struct wset *zzcwp = wsets;
int zzgoent = 0;
int zzgobest = 0;
int zzacent = 0;
int zzexcp = 0;
int zzclose = 0;
int zzsrconf = 0;
SSIZE_T * zzmemsz = mem0;
int zzrrconf = 0;

/* data pulled from internal static to here */
/* declared external only in user module    */

SSIZE_T *pyield[NPROD];             /* from ycpres */
char sarr[ISIZE];               /* from ywritm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y1.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */ 
/*                              *************                                   */
/*                              *  Y 1 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y1.C to their impure data in Y1IMP.1C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

#include "dtxtrn.h"

/* lookahead computations */

extern int tbitset;  /* size of lookahead sets */
extern int nlset; /* next lookahead set index */
extern struct looksets clset;  /* temporary storage for lookahead computations */

/* other storage areas */

extern int fatfl;               /* if on, error is fatal */
extern int nerrors;             /* number of errors */

/* storage for information about the nonterminals */

extern SSIZE_T **pres[ ];           /* vector of pointers to productions yielding each nonterminal */
extern struct looksets *pfirst[ ]; /* vector of pointers to first sets for each nonterminal */
extern SSIZE_T pempty[ ];           /* vector of nonterminals nontrivially deriving e */

/* accumulators for statistics information */

extern struct wset *zzcwp;
extern SSIZE_T * zzmemsz;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y2.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */
/*                              *************                                   */
/*                              *  Y 2 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y2.C to their impure data in Y2IMP.2C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

# include "dtxtrn.h" 

# define IDENTIFIER 257
# define MARK 258
# define TERM 259
# define LEFT 260
# define RIGHT 261
# define BINARY 262
# define PREC 263
# define LCURLY 264
# define C_IDENTIFIER 265  /* name followed by colon */
# define NUMBER 266
# define START 267
# define TYPEDEF 268
# define TYPENAME 269
# define UNION 270
# define ENDFILE 0

/* communication variables between various I/O routines */

extern char *infile;            /* input file name */
extern SSIZE_T numbval;             /* value of an input number */
extern char tokname[ ];         /* input token name */

/* storage of names */

extern char cnames[ ];          /* place where token and nonterminal names are stored */
extern int cnamsz;              /* size of cnames */
extern char * cnamp;            /* place where next name is to be put in */
extern int ndefout;             /* number of defined symbols output */

/* storage of types */
extern int ntypes;              /* number of types defined */
extern char * typeset[ ];       /* pointers to type tags */

/* symbol tables for tokens and nonterminals */

extern int start;               /* start symbol */

/* assigned token type values */
extern int extval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y3imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data from modules split from y3.c */
#define y3imp YES

#include "dtxtrn.h"

int lastred;            /* the number of the last reduction of a state */

SSIZE_T defact[NSTATES];    /* the default actions of states */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y4imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data from y4.c modules */

# include "dtxtrn.h"

# define a amem
# define pa indgo
# define yypact temp1
# define greed tystate

# define NOMORE -1000

SSIZE_T * ggreed = lkst[0].lset;
SSIZE_T * pgo = wsets[0].ws.lset;
SSIZE_T *yypgo = &nontrst[0].tvalue;

SSIZE_T maxspr = 0;  /* maximum spread of any entry */
SSIZE_T maxoff = 0;  /* maximum offset into a array */
SSIZE_T *pmem = mem0;
SSIZE_T *maxa;
int nxdb = 0;
int adb = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y3.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */
/*                              *************                                   */
/*                              *  Y 3 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y3.C to their impure data in Y3IMP.3C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

# include "dtxtrn.h"

extern SSIZE_T lastred;             /* the number of the last reduction of a state */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y2imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data needed by routines pulled from Y2.C */

#define y2imp YES
#include "dtxtrn.h"

/* communication variables between various I/O routines */

char *infile;   /* input file name */
SSIZE_T numbval;    /* value of an input number */
char tokname[NAMESIZE]; /* input token name */

/* storage of names */

char cnames[CNAMSZ];    /* place where token and nonterminal names are stored */
int cnamsz = CNAMSZ;    /* size of cnames */
char * cnamp = cnames;  /* place where next name is to be put in */
int ndefout = 3;  /* number of defined symbols output */

/* storage of types */
int ntypes;     /* number of types defined */
char * typeset[NTYPES]; /* pointers to type tags */

/* symbol tables for tokens and nonterminals */

int ntokens = 0;
struct toksymb tokset[NTERMS];
int toklev[NTERMS];
int nnonter = -1;
struct ntsymb nontrst[NNONTERM];
int start;      /* start symbol */

/* assigned token type values */
int extval = 0;

/* input and output file descriptors */

FILE * finput = NULL;          /* yacc input file */
FILE * faction = NULL;         /* file for saving actions */
FILE * fdefine = NULL;         /* file for # defines */
FILE * ftable = NULL;          /* y.tab.c file */
FILE * ftemp = NULL;    /* tempfile to pass 2 */
FILE * foutput = NULL;         /* y.output file */

/* storage for grammar rules */

SSIZE_T mem0[MEMSIZE] ; /* production storage */
SSIZE_T *mem = mem0;
int nprod= 1;   /* number of productions */
SSIZE_T *prdptr[NPROD];     /* pointers to descriptions of productions */
SSIZE_T levprd[NPROD] ;     /* precedence levels for the productions */

/* Statics pulled from modules */

int peekline;           /* from gettok() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\y4.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */
/*                              *************                                   */
/*                              *  Y 4 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y4.C to their impure data in Y4IMP.4C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

# include "dtxtrn.h"

# define a amem
# define pa indgo
# define yypact temp1
# define greed tystate

# define NOMORE -1000

extern SSIZE_T * ggreed;
extern SSIZE_T * pgo;
extern SSIZE_T *yypgo;

extern SSIZE_T maxspr;              /* maximum spread of any entry */
extern SSIZE_T maxoff;              /* maximum offset into a array */
extern SSIZE_T *pmem;
extern SSIZE_T *maxa;
extern int nxdb;
extern int adb;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yaoput.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
aoutput( void )
   {
   /* this version is for C */
   /* write out the optimized parser */

   fprintf( ftable, "# define YYLAST %d\n", maxa-a+1 );

   arout( "yyact", a, (maxa-a)+1 );
   arout( "yypact", pa, nstate );
   arout( "yypgo", pgo, nnonter+1 );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yacc.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"

/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 * Added s - switch. Please refer to ywstat.c for details on sswitch
 */

extern FILE * finput;
extern FILE * faction;
extern FILE * fdefine;
extern FILE * ftable;
extern FILE * ftemp;
extern FILE * foutput;
extern FILE *tokxlathdl;    /* token xlation file,token index vs value*/
extern FILE *stgotohdl;     /* state goto table file handle */
extern FILE *stexhdl;	    /* state vs expected construct handle */

void
main(argc,argv) int argc;
char *argv[];

   {

   tokxlathdl = stdout;/* token xlation file,token index vs value*/
   stgotohdl = stdout; /* state goto table file handle */
   stexhdl = stdout;	 /* state vs expected construct handle */

   puts("Setup...");
   setup(argc,argv); /* initialize and read productions */
   puts("cpres ...");
   tbitset = NWORDS(ntokens);
   cpres(); /* make table of which productions yield a given nonterminal */
   puts("cempty ...");
   cempty(); /* make a table of which nonterminals can match the empty string */
   puts("cpfir ...");
   cpfir(); /* make a table of firsts of nonterminals */
   puts("stagen ...");
   stagen(); /* generate the states */
   puts("output ...");
   output();  /* write the states and the tables */
   puts("go2out ...");
   go2out();
   puts("hideprod ...");
   hideprod();
   puts("summary ...");
   summary();
   puts("callopt ...");
   callopt();
   puts("others ...");
   others();
   puts("DONE !!!");

   SSwitchExit();

   exit(EX_SUC);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yapack.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

/*
 * yapack.3c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */
int
apack(SSIZE_T *p, int n )
   {
   /* pack state i from temp1 into amem */
   int off;
   SSIZE_T *pp, *qq, *rr;
   SSIZE_T *q, *r;

   /* we don't need to worry about checking because we
                   we will only look entries known to be there... */

   /* eliminate leading and trailing 0's */

   q = p+n;
   for( pp=p,off=0 ; *pp==0 && pp<=q; ++pp,--off ) /* VOID */ ;
   if( pp > q ) return(0);  /* no actions */
   p = pp;

   /* now, find a place for the elements from p to q, inclusive */

   r = &amem[ACTSIZE-1];
   for( rr=amem; rr<=r; ++rr,++off )
      {
      /* try rr */
      for( qq=rr,pp=p ; pp<=q ; ++pp,++qq)
         {
         if( *pp != 0 )
            {
            if( *pp != *qq && *qq != 0 ) goto nextk;
            }
         }

      /* we have found an acceptable k */

#ifdef debug
      if(foutput!=NULL) fprintf(foutput,"off = %d, k = %d\n",off,rr-amem);
#endif
      for( qq=rr,pp=p; pp<=q; ++pp,++qq )
         {
         if( *pp )
            {
            if( qq > r ) error( "action table overflow" );
            if( qq>memp ) memp = qq;
            *qq = *pp;
            }
         }
#ifdef debug
      if( foutput!=NULL )
         {
         for( pp=amem; pp<= memp; pp+=10 )
            {
            fprintf( foutput, "\t");
            for( qq=pp; qq<=pp+9; ++qq ) fprintf( foutput, "%d ", *qq );
            fprintf( foutput, "\n");
            }
         }
#endif
      return( off );

nextk: 
      ;
      }
   error("no space in action table" );
   return off; /* NOTREACHED */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yarout.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
arout( char *s, SSIZE_T *v, SSIZE_T n )

   {

   SSIZE_T i;

   fprintf( ftable, "short %s%s[]={\n", pszPrefix ? pszPrefix : "", s );
   for( i=0; i<n; )
      {
      if( i%10 == 0 ) fprintf( ftable, "\n" );
      fprintf( ftable, "%4d", v[i] );
      if( ++i == n ) fprintf( ftable, " };\n" );
      else fprintf( ftable, "," );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yaryfl.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"
void
aryfil( v, n, c ) 
SSIZE_T *v,n,c; 
   {
   /* set elements 0 through n-1 to c */
   register SSIZE_T i;
   for( i=0; i<n; ++i ) v[i] = c;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yclopt.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Edits:
 *      06-Dec-80 Broken out of y4.c, impure data in y4imp.c.
 *      18-Dec-80 ZAPFILE not used for decus compiler, fmkdl() used.
 */

#include "y4.h"
void
callopt( void )
   {

   SSIZE_T i, j, k, *p, *q;

   /* read the arrays from tempfile and set parameters */

   
   if( (finput=fopen(TEMPNAME,"r")) == NULL ) error( "optimizer cannot open tempfile" );
   pgo[0] = 0;
   yypact[0] = 0;
   nstate = 0;
   nnonter = 0;
   for(;;)
      {
      switch( gtnm() )
         {

      case '\n':
         yypact[++nstate] = (--pmem) - mem0;

      case ',':
         continue;

      case '$':
         break;

      default:
         error( "bad tempfile" );
         }
      break;
      }

   yypact[nstate] = yypgo[0] = (--pmem) - mem0;

   for(;;)
      {
      switch( gtnm() )
         {

      case '\n':
         yypgo[++nnonter]= pmem-mem0;
      case '\r':
      case ',' :
         continue;

      case -1: /* EOF */
         break;

      default:
         error( "bad tempfile" );
         }
      break;
      }

   yypgo[nnonter--] = (--pmem) - mem0;

   for( i=0; i<nstate; ++i )
      {

      k = 32000;
      j = 0;
      q = mem0 + yypact[i+1];
      for( p = mem0 + yypact[i]; p<q ; p += 2 )
         {
         if( *p > j ) j = *p;
         if( *p < k ) k = *p;
         }
      if( k <= j )
         {
         /* nontrivial situation */
         /* temporarily, kill this for compatibility
                                j -= k;  j is now the range */
         if( k > maxoff ) maxoff = k;
         }
      greed[i] = (yypact[i+1]-yypact[i]) + 2*j;
      if( j > maxspr ) maxspr = j;
      }

   /* initialize ggreed table */

   for( i=1; i<=nnonter; ++i )
      {
      ggreed[i] = 1;
      j = 0;
      /* minimum entry index is always 0 */
      q = mem0 + yypgo[i+1] -1;
      for( p = mem0+yypgo[i]; p<q ; p += 2 ) 
         {
         ggreed[i] += 2;
         if( *p > j ) j = *p;
         }
      ggreed[i] = ggreed[i] + 2*j;
      if( j > maxoff ) maxoff = j;
      }

   /* now, prepare to put the shift actions into the a array */

   for( i=0; i<ACTSIZE; ++i ) a[i] = 0;
   maxa = a;

   for( i=0; i<nstate; ++i ) 
      {
      if( greed[i]==0 && adb>1 ) fprintf( ftable, "State %d: null\n", i );
      pa[i] = YYFLAG1;
      }

   while( (i = nxti()) != NOMORE ) 
      {
      if( i >= 0 ) stin(i);
      else gin(-i);

      }

   if( adb>2 )

      {
      /* print a array */
      for( p=a; p <= maxa; p += 10)
         {
         fprintf( ftable, "%4d  ", p-a );
         for( i=0; i<10; ++i ) fprintf( ftable, "%4d  ", p[i] );
         fprintf( ftable, "\n" );
         }
      }
   /* write out the output appropriate to the language */

   aoutput();

   osummary();

   fclose(finput);
   ZAPFILE(TEMPNAME);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ychcpy.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

char *chcopy( p, q )  char *p, *q; 
   {
   /* copies string q into p, returning next free char ptr */
   while( *p = *q++ ) ++p;
   return( p );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ycemty.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"

/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 */
void
cempty( void )
   {
   /* mark nonterminals which derive the empty string */
   /* also, look for nonterminals which don't derive any token strings */

# define EMPTY 1
# define WHOKNOWS 0
# define OK 1

   SSIZE_T i, *p;

   /* first, use the array pempty to detect productions that can never be reduced */
   /* set pempty to WHONOWS */
   aryfil( pempty, nnonter+1, WHOKNOWS );

   /* now, look at productions, marking nonterminals which derive something */

more:
   PLOOP(0,i)
      {
      if( pempty[ *prdptr[i] - NTBASE ] ) continue;
      for( p=prdptr[i]+1; *p>=0; ++p )
         {
         if( *p>=NTBASE && pempty[ *p-NTBASE ] == WHOKNOWS ) break;
         }
      if( *p < 0 )
         {
         /* production can be derived */
         pempty[ *prdptr[i]-NTBASE ] = OK;
         goto more;
         }
      }

   /* now, look at the nonterminals, to see if they are all OK */

   NTLOOP(i)
      {
      /* the added production rises or falls as the start symbol ... */
      if( i == 0 ) continue;
      if( pempty[ i ] != OK )
         {
         fatfl = 0;
         error( "nonterminal %s never derives any token string", nontrst[i].name );
         fatfl = 1;
         }
      }

   if( nerrors )
      {
      summary();
      exit(EX_ERR);
      }

   /* now, compute the pempty array, to see which nonterminals derive the empty string */

   /* set pempty to WHOKNOWS */

   aryfil( pempty, nnonter+1, WHOKNOWS );

   /* loop as long as we keep finding empty nonterminals */

again:
   PLOOP(1,i)
      {
      if( pempty[ *prdptr[i]-NTBASE ]==WHOKNOWS )
         {
         /* not known to be empty */
         for( p=prdptr[i]+1; *p>=NTBASE && pempty[*p-NTBASE]==EMPTY ; ++p ) ;
         if( *p < 0 )
            {
            /* we have a nontrivially empty nonterminal */
            pempty[*prdptr[i]-NTBASE] = EMPTY;
            goto again; /* got one ... try for another */
            }
         }
      }

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ychfnd.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
#include <string.h>

int
chfind( int t, register char *s )

   {
   int i;

   if (s[0]==' ')t=0;
   TLOOP(i)
      {
      if(!strcmp(s,tokset[i].name))
         {
         return( i );
         }
      }
   NTLOOP(i)
      {
      if(!strcmp(s,nontrst[i].name)) 
         {
         return( i+NTBASE );
         }
      }
   /* cannot find name */
   if( t>1 )
      error( "%s should have been defined earlier", s );
   return( defin( t, s ) );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ycpact.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdio.h>
#include <ctype.h>
#include "y2.h"

void
cpyact( SSIZE_T offset)
   {
   /* copy C action to the next ; or closing } */
   int brac, c, match, s;
   SSIZE_T j, tok;

   writeline(faction);

   brac = 0;

loop:
   c = unix_getc(finput);
swt:
   switch( c )
      {

   case ';':
      if( brac == 0 )
         {
         putc( c , faction );
         return;
         }
      goto lcopy;

   case '{':
      brac++;
      goto lcopy;

   case '$':
      s = 1;
      tok = -1;
      c = unix_getc(finput);
      if( c == '<' )
         {
         /* type description */
         yungetc( c, finput );
         if( gettok() != TYPENAME ) error( "bad syntax on $<ident> clause" );
         tok = numbval;
         c = unix_getc(finput);
         }
      if( c == '$' )
         {
         fprintf( faction, "yyval");
         if( ntypes )
            {
            /* put out the proper tag... */
            if( tok < 0 ) tok = fdtype( *prdptr[nprod] );
            fprintf( faction, ".%s", typeset[tok] );
            }
         goto loop;
         }
      if( c == '-' )
         {
         s = -s;
         c = unix_getc(finput);
         }
      if( isdigit(c) )
         {
         j=0;
         while( isdigit(c) )
            {

            j= j*10+c-'0';
            c = unix_getc(finput);
            }

         j = j*s - offset;
         if( j > 0 )
            {
            error( "Illegal use of $%d", j+offset );
            }

         fprintf( faction, "yypvt[-%d]", -j );
         if( ntypes )
            {
            /* put out the proper tag */
            if( j+offset <= 0 && tok < 0 ) error( "must specify type of $%d", j+offset );
            if( tok < 0 ) tok = fdtype( prdptr[nprod][j+offset] );
            fprintf( faction, ".%s", typeset[tok] );
            }
         goto swt;
         }
      putc( '$' , faction );
      if( s<0 ) putc('-', faction );
      goto swt;

   case '}':
      if( --brac ) goto lcopy;
      putc( c, faction );
      return;


   case '/':    /* look for comments */
      putc( c , faction );
      c = unix_getc(finput);
      if( c != '*' ) goto swt;

      /* it really is a comment */

      putc( c , faction );
      c = unix_getc(finput);
      while( c != EOF )
         {
         while( c=='*' )
            {
            putc( c , faction );
            if( (c=unix_getc(finput)) == '/' ) goto lcopy;
            }
         putc( c , faction );
         if( c == '\n' )++lineno;
         c = unix_getc(finput);
         }
      error( "EOF inside comment" );

   case '\'':   /* character constant */
      match = '\'';
      goto string;

   case '"':    /* character string */
      match = '"';

string:

      putc( c , faction );

      while( c=unix_getc(finput) )
         {

         if( c=='\\' )
            {
            putc( c , faction );
            c=unix_getc(finput);
            if( c == '\n' ) ++lineno;
            }
         else if( c==match ) goto lcopy;
         else if( c=='\n' ) error( "newline in string or char. const." );
         putc( c , faction );
         }
      error( "EOF in string or character constant" );

   case -1: /* EOF */
      error("action does not terminate" );

   case '\n':   
      ++lineno;
      goto lcopy;

      }

lcopy:
   putc( c , faction );
   goto loop;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yclsur.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * yclsur.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */

void 
closure( int i)

   {
   /* generate the closure of state i */

   int work, k;
   SSIZE_T ch, c;
   register struct wset *u, *v;
   SSIZE_T *pi;
   SSIZE_T **s, **t;
   struct item *q;
   register struct item *p;

   ++zzclose;

   /* first, copy kernel of state i to wsets */

   cwp = wsets;
   ITMLOOP(i,p,q)

      {
      cwp->pitem = p->pitem;
      cwp->flag = 1;    /* this item must get closed */
      SETLOOP(k) cwp->ws.lset[k] = p->look->lset[k];
      WSBUMP(cwp);
      }

   /* now, go through the loop, closing each item */

   work = 1;
   while( work )

      {
      work = 0;
      WSLOOP(wsets,u)

         {

         if( u->flag == 0 ) continue;
         c = *(u->pitem);  /* dot is before c */

         if( c < NTBASE )

            {
            u->flag = 0;
            continue;  /* only interesting case is where . is before nonterminal */
            }

         /* compute the lookahead */
         aryfil( clset.lset, tbitset, 0 );

         /* find items involving c */

         WSLOOP(u,v)

            {
            if( v->flag == 1 && *(pi=v->pitem) == c )

               {
               v->flag = 0;
               if( nolook ) continue;
               while( (ch= *++pi)>0 )

                  {
                  if( ch < NTBASE )

                     {
                     /* terminal symbol */
                     SETBIT( clset.lset, ch );
                     break;
                     }
                  /* nonterminal symbol */
                  setunion( clset.lset, pfirst[ch-NTBASE]->lset );
                  if( !pempty[ch-NTBASE] ) break;
                  }
               if( ch<=0 ) setunion( clset.lset, v->ws.lset );
               }
            }

         /*  now loop over productions derived from c */

         c -= NTBASE; /* c is now nonterminal number */

         t = pres[c+1];
         for( s=pres[c]; s<t; ++s )

            {
            /* put these items into the closure */
            WSLOOP(wsets,v)

               {
               /* is the item there */
               if( v->pitem == *s )

                  {
                  /* yes, it is there */
                  if( nolook ) goto nexts;
                  if( setunion( v->ws.lset, clset.lset ) ) v->flag = work = 1;
                  goto nexts;
                  }
               }

            /*  not there; make a new entry */
            if( cwp-wsets+1 >= WSETSIZE ) error( "working set overflow" );
            cwp->pitem = *s;
            cwp->flag = 1;
            if( !nolook )

               {
               work = 1;
               SETLOOP(k) cwp->ws.lset[k] = clset.lset[k];
               }
            WSBUMP(cwp);
nexts: 
            ;
            }

         }
      }

   /* have computed closure; flags are reset; return */

   if( cwp > zzcwp ) zzcwp = cwp;

#ifdef debug
   if( foutput!=NULL )

      {
      fprintf( foutput, "\nState %d, nolook = %d\n", i, nolook );
      WSLOOP(wsets,u)

         {
         if( u->flag ) fprintf( foutput, "flag set!\n");
         u->flag = 0;
         fprintf( foutput, "\t%s", writem(u->pitem));
         prlook( &u->ws );
         fprintf( foutput,  "\n" );
         }
      }
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ycpycd.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

void
cpycode( void )
   {
   /* copies code between \{ and \} */

   int c;

   c = unix_getc(finput);
   if( c == '\n' ) 
      {
      c = unix_getc(finput);
      lineno++;
      }

   writeline(ftable);

   while( c>=0 )
      {
      if( c=='\\' )
         if( (c=unix_getc(finput)) == '}' ) return;
         else putc('\\', ftable );
      if( c=='%' )
         if( (c=unix_getc(finput)) == '}' ) return;
         else putc('%', ftable );
      putc( c , ftable );
      if( c == '\n' ) ++lineno;
      c = unix_getc(finput);
      }
   error("eof before %%}" );
   }

void writeline(FILE *fh) {
   char *psz = infile;

   fprintf( fh, "\n#line %d \"", lineno );
   psz = infile;
   while (*psz) {
      putc(*psz, fh);
      if (*psz == '\\') {
        putc('\\', fh);
      }
      psz++;
   }
   fprintf(fh, "\"\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ycpuni.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

void
cpyunion( void )
   {
   /* copy the union declaration to the output, and the define file if present */

   int level, c;

   writeline(ftable);

   fprintf( ftable, "\n#define UNION 1\n");
   fprintf( ftable, "typedef union " );
   if( fdefine ) fprintf( fdefine, "\ntypedef union " );

   level = 0;
   for(;;)
      {
      if( (c=unix_getc(finput)) < 0 ) error( "EOF encountered while processing %%union" );
      putc( c, ftable );
      if( fdefine ) putc( c, fdefine );

      switch( c )
         {

      case '\n':
         ++lineno;
         break;

      case '{':
         ++level;
         break;

      case '}':
         --level;
         if( level == 0 ) 
            {
            /* we are finished copying */
            fprintf( ftable, " YYSTYPE;\n" );
            if( fdefine ) fprintf( fdefine, " YYSTYPE;\nextern YYSTYPE yylval;\n" );
            return;
            }
         }
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ycpfir.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * ycpfir.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */

void
cpfir( void ) 

   {
   /* compute an array with the first of nonterminals */
   SSIZE_T *p, **s, i, **t, ch, changes;

   zzcwp = &wsets[nnonter];
   NTLOOP(i)

      {
      aryfil( wsets[i].ws.lset, tbitset, 0 );
      t = pres[i+1];
      for( s=pres[i]; s<t; ++s )

         {
         /* initially fill the sets */
         for( p = *s; (ch = *p) > 0 ; ++p ) 

            {
            if( ch < NTBASE ) 

               {
               SETBIT( wsets[i].ws.lset, ch );
               break;
               }
            else if( !pempty[ch-NTBASE] ) break;
            }
         }
      }

   /* now, reflect transitivity */

   changes = 1;
   while( changes )

      {
      changes = 0;
      NTLOOP(i)

         {
         t = pres[i+1];
         for( s=pres[i]; s<t; ++s )

            {
            for( p = *s; ( ch = (*p-NTBASE) ) >= 0; ++p ) 

               {
               changes |= setunion( wsets[i].ws.lset, wsets[ch].ws.lset );
               if( !pempty[ch] ) break;
               }
            }

         }
      }

   NTLOOP(i) pfirst[i] = flset( &wsets[i].ws );
#ifdef debug
   if( (foutput!=NULL) )

      {
      NTLOOP(i) 

         {
         fprintf( foutput,  "\n%s: ", nontrst[i].name );
         prlook( pfirst[i] );
         fprintf( foutput,  " %d\n", pempty[i] );
         }
      }
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ycstsh.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
char *
cstash( s ) register char *s; 

   {
   char *temp;

   temp = cnamp;
   do 
      {
      if( cnamp >= &cnames[cnamsz] ) error("too many characters in id's and literals" );
      else *cnamp++ = *s;
      }
     while ( *s++ );
   return( temp );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ycpres.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"
/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 */
extern SSIZE_T * pyield[NPROD];

void
cpres( void )
   {
   /* compute an array with the beginnings of  productions yielding given nonterminals
        The array pres points to these lists */
   /* the array pyield has the lists: the total size is only NPROD+1 */
   SSIZE_T **pmem;
   register j, i;
   SSIZE_T c;

   pmem = pyield;

   NTLOOP(i)
      {
      c = i+NTBASE;
      pres[i] = pmem;
      fatfl = 0;  /* make undefined  symbols  nonfatal */
      PLOOP(0,j)
         {
         if (*prdptr[j] == c) *pmem++ =  prdptr[j]+1;
         }
      if(pres[i] == pmem)
         {
         error("nonterminal %s not defined!", nontrst[i].name);
         }
      }
   pres[i] = pmem;
   fatfl = 1;
   if( nerrors )
      {
      summary();
      exit(EX_ERR);
      }
   if( pmem != &pyield[nprod] ) error( "internal Yacc error: pyield %d", pmem-&pyield[nprod] );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yerror.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"
#include <stdarg.h>

/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 */

void
error(char *s, ...)

   {
   va_list arg_ptr;
   va_start(arg_ptr, s);
   /* write out error comment */

   ++nerrors;
   fprintf( stderr, "\n fatal error: ");
   vfprintf( stderr, s, arg_ptr);
   fprintf( stderr, ", line %d\n", lineno );
   va_end(arg_ptr);
   if( !fatfl ) return;
   summary();
   exit(EX_ERR);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ydfout.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
#include <ctype.h>

void
defout( void )
   {
   /* write out the defines (at the end of the declaration section) */

   register int i, c;
   register char *cp;

   for( i=ndefout; i<=ntokens; ++i )
      {

      cp = tokset[i].name;
      if( *cp == ' ' ) ++cp;  /* literals */

      for( ; (c= *cp)!='\0'; ++cp )
         {

         if( islower(c) || isupper(c) || isdigit(c) || c=='_' );  /* VOID */
         else goto nodef;
         }

      fprintf( ftable, "# define %s %d\n", tokset[i].name, tokset[i].value );
      if( fdefine != NULL ) fprintf( fdefine, "# define %s %d\n", tokset[i].name, tokset[i].value );

nodef:  
      ;
      }

   ndefout = ntokens+1;

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ydefin.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

int
defin( int t, register char *s )

   {
   /*   define s to be a terminal if t=0
        or a nonterminal if t=1         */

   register val;

   if (t) 
      {
      if( ++nnonter >= NNONTERM ) error("too many nonterminals, limit %d",NNONTERM);
      nontrst[nnonter].name = cstash(s);
      return( NTBASE + nnonter );
      }
   /* must be a token */
   if( ++ntokens >= NTERMS ) error("too many terminals, limit %d",NTERMS );
   tokset[ntokens].name = cstash(s);

   /* establish value for token */

   if( s[0]==' ' && s[2]=='\0' ) /* single character literal */
      val = s[1];
   else if ( s[0]==' ' && s[1]=='\\' ) 
      {
      /* escape sequence */
      if( s[3] == '\0' )
         {
         /* single character escape sequence */
         switch ( s[2] )
            {
            /* character which is escaped */
         case 'n': 
            val = '\n'; 
            break;
         case 'r': 
            val = '\r'; 
            break;
         case 'b': 
            val = '\b'; 
            break;
         case 't': 
            val = '\t'; 
            break;
         case 'f': 
            val = '\f'; 
            break;
         case '\'': 
            val = '\''; 
            break;
         case '"': 
            val = '"'; 
            break;
         case '\\': 
            val = '\\'; 
            break;
         default: 
            error( "invalid escape" );
            }
         }

      else if( s[2] <= '7' && s[2]>='0' )
         {
         /* \nnn sequence */
         if( s[3]<'0' || s[3] > '7' || s[4]<'0' ||
             s[4]>'7' || s[5] != '\0' ) error("illegal \\nnn construction" );
         val = 64*s[2] + 8*s[3] + s[4] - 73*'0';
         if( val == 0 ) error( "'\\000' is illegal" );
         }
      }
   else 
      {
      val = extval++;
      }
   tokset[ntokens].value = val;
   toklev[ntokens] = 0;
   return( ntokens );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yfdtyp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

SSIZE_T fdtype( SSIZE_T t )
   {
   /* determine the type of a symbol */
   SSIZE_T v;
   if( t >= NTBASE ) v = nontrst[t-NTBASE].tvalue;
   else v = TYPE( toklev[t] );
   if( v <= 0 ) error( "must specify type for %s", (t>=NTBASE)?nontrst[t-NTBASE].name:
   tokset[t].name );
   return( v );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yg2gen.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

/*
 * yg2gen.3c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */
void
go2gen(int c)

   {
   /* output the gotos for nonterminal c */

   int i, work;
   SSIZE_T cc;
   struct item *p, *q;


   /* first, find nonterminals with gotos on c */

   aryfil( temp1, nnonter+1, 0 );
   temp1[c] = 1;

   work = 1;
   while( work )

      {
      work = 0;
      PLOOP(0,i)

         {
         if( (cc=prdptr[i][1]-NTBASE) >= 0 )

            {
            /* cc is a nonterminal */
            if( temp1[cc] != 0 )

               {
               /* cc has a goto on c */
               cc = *prdptr[i]-NTBASE; /* thus, the left side of production i does too */
               if( temp1[cc] == 0 )

                  {
                  work = 1;
                  temp1[cc] = 1;
                  }
               }
            }
         }
      }

   /* now, we have temp1[c] = 1 if a goto on c in closure of cc */

#ifdef debug
   if( foutput!=NULL )

      {
      fprintf( foutput, "%s: gotos on ", nontrst[c].name );
      NTLOOP(i) if( temp1[i] ) fprintf( foutput, "%s ", nontrst[i].name);
      fprintf( foutput, "\n");

      }
#endif
   /* now, go through and put gotos into tystate */

   aryfil( tystate, nstate, 0 );
   SLOOP(i)

      {
      ITMLOOP(i,p,q)

         {
         if( (cc= *p->pitem) >= NTBASE )

            {
            if( temp1[cc -= NTBASE] )

               {
               /* goto on c is possible */
               tystate[i] = amem[indgo[i]+c];
               break;
               }
            }
         }
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yfnact.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

void
finact( void )
   {
   /* finish action routine */

   fclose(faction);

   fprintf( ftable, "# define YYERRCODE %d\n", tokset[2].value );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yflset.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

struct looksets *flset( p )   struct looksets *p; 

   {
   /* decide if the lookahead set pointed to by p is known */
   /* return pointer to a perminent location for the set */

   register struct looksets *q;
   int j;
   SSIZE_T *u, *v, *w;

   for( q = &lkst[nlset]; q-- > lkst; )
      {
      u = p->lset;
      v = q->lset;
      w = & v[tbitset];
      while( v<w) if( *u++ != *v++ ) goto more;
      /* we have matched */
      return( q );
more: 
      ;
      }
   /* add a new one */
   q = &lkst[nlset++];
   if( nlset >= LSETSIZE )error("too many lookahead sets" );
   SETLOOP(j)
      {
      q->lset[j] = p->lset[j];
      }
   return( q );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ygtnm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"
#include <ctype.h>

gtnm()
   {

   register s, val, c;

   /* read and convert an integer from the standard input */
   /* return the terminating character */
   /* blanks, tabs, and newlines are ignored */

   s = 1;
   val = 0;

   while( (c=unix_getc(finput)) != EOF )
      {
      if( isdigit(c) )
         {
         val = val * 10 + c - '0';
         }
      else if ( c == '-' ) s = -1;
	  else if ( c == '\r') continue;
      else break;
      }
   *pmem++ = s*val;
   if( pmem > &mem0[MEMSIZE] ) error( "out of space" );
   return( c );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ygttok.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
#include <ctype.h>
#include <string.h>

extern int peekline; /* number of '\n' seen in lookahead */

SSIZE_T
gettok() 
   {
   register i, base;
   register reserve;
   SSIZE_T match, c;

begin:
   reserve = 0;
   lineno += peekline;
   peekline = 0;
   c = unix_getc(finput);
   while( c==' ' || c=='\n' || c=='\t' || c=='\f' || c=='\r')
      {
      if( c == '\n' ) ++lineno;
      c=unix_getc(finput);
      }
   if( c == '/' )
      {
      /* skip comment */
      lineno += skipcom();
      goto begin;
      }

   switch(c)
      {

   case -1: /* EOF */
      return(ENDFILE);
   case '{':
      yungetc( c, finput );
      return( '=' );  /* action ... */
   case '<':  /* get, and look up, a type name (union member name) */
      i = 0;
      while( (c=unix_getc(finput)) != '>' && c>=0 && c!= '\n' )
         {
         tokname[i] = (char) c;
         if( ++i >= NAMESIZE ) --i;
         }
      if( c != '>' ) error( "unterminated < ... > clause" );
      tokname[i] = '\0';
      for( i=1; i<=ntypes; ++i )
         {
         if( !strcmp( typeset[i], tokname ) )
            {
            numbval = i;
            return( TYPENAME );
            }
         }
      typeset[numbval = ++ntypes] = cstash( tokname );
      return( TYPENAME );

   case '"':    
   case '\'':
      match = c;
      tokname[0] = ' ';
      i = 1;
      for(;;)
         {
         c = unix_getc(finput);

         if( c == '\n' || c == EOF )
            error("illegal or missing ' or \"" );
         if( c == '\\' )
            {
            c = unix_getc(finput);
            tokname[i] = '\\';
            if( ++i >= NAMESIZE ) --i;
            }
         else if( c == match ) break;
         tokname[i] = (char) c;
         if( ++i >= NAMESIZE ) --i;
         }
      break;

   case '%':
   case '\\':

      switch(c=unix_getc(finput)) 
         {

      case '0': 
         return(TERM);
      case '<': 
         return(LEFT);
      case '2': 
         return(BINARY);
      case '>': 
         return(RIGHT);
      case '%':
      case '\\':        
         return(MARK);
      case '=': 
         return(PREC);
      case '{': 
         return(LCURLY);
      default:  
         reserve = 1;
         }

   default:

      if( isdigit((int) c) )
         {
         /* number */
         numbval = c-'0' ;
         base = (c=='0') ? 8 : 10 ;
         for( c=unix_getc(finput); isdigit((int) c) ; c=getc(finput) )
            {
            numbval = numbval*base + c - '0';
            }
         yungetc( c, finput );
         return(NUMBER);
         }
      else if( islower((int) c) || isupper((int) c) || c=='_' || c=='.' || c=='$' )
         {
         i = 0;
         while( islower((int) c) || isupper((int) c) || isdigit((int) c) || c=='_' || c=='.' || c=='$' )
            {
            tokname[i] = (char) c;
            if( reserve && isupper((int) c) ) tokname[i] += 'a'-'A';
            if( ++i >= NAMESIZE ) --i;
            c = unix_getc(finput);

            }
         }
      else return(c);

      yungetc( c, finput );
      }

   tokname[i] = '\0';

   if( reserve )
      {
      /* find a reserved word */
      if( !strcmp(tokname,"term")) return( TERM );
      if( !strcmp(tokname,"token")) return( TERM );
      if( !strcmp(tokname,"left")) return( LEFT );
      if( !strcmp(tokname,"nonassoc")) return( BINARY );
      if( !strcmp(tokname,"binary")) return( BINARY );
      if( !strcmp(tokname,"right")) return( RIGHT );
      if( !strcmp(tokname,"prec")) return( PREC );
      if( !strcmp(tokname,"start")) return( START );
      if( !strcmp(tokname,"type")) return( TYPEDEF );
      if( !strcmp(tokname,"union")) return( UNION );
      error("invalid escape, or illegal reserved word: %s", tokname );
      }

   /* look ahead to distinguish IDENTIFIER from C_IDENTIFIER */

   c = unix_getc(finput);
   while( c==' ' || c=='\t'|| c=='\n' || c=='\f' || c== '/' ) 
      {
      if( c == '\n' ) ++peekline;
      else if( c == '/' )
         {
         /* look for comments */
         peekline += skipcom();
         }
      c = unix_getc(finput);
      }
   if( c == ':' ) return( C_IDENTIFIER );
   yungetc( c, finput );
   return( IDENTIFIER );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ygin.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
gin(SSIZE_T i)
   {

   SSIZE_T *p, *r, *s, *q1, *q2;

   /* enter gotos on nonterminal i into array a */

   ggreed[i] = 0;

   q2 = mem0+ yypgo[i+1] - 1;
   q1 = mem0 + yypgo[i];

   /* now, find a place for it */

   for( p=a; p < &a[ACTSIZE]; ++p )
      {
      if( *p ) continue;
      for( r=q1; r<q2; r+=2 )
         {
         s = p + *r +1;
         if( *s ) goto nextgp;
         if( s > maxa )
            {
            if( (maxa=s) > &a[ACTSIZE] ) error( "a array overflow" );
            }
         }
      /* we have found a spot */

      *p = *q2;
      if( p > maxa )
         {
         if( (maxa=p) > &a[ACTSIZE] ) error( "a array overflow" );
         }
      for( r=q1; r<q2; r+=2 )
         {
         s = p + *r + 1;
         *s = r[1];
         }

      pgo[i] = p-a;
      if( adb>1 ) fprintf( ftable, "Nonterminal %d, entry at %d\n" , i, pgo[i] );
      goto nextgi;

nextgp:  
      ;
      }

   error( "cannot place goto %d\n", i );

nextgi:  
   ;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yg2out.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
go2out( void )
   {
   /* output the gotos for the nontermninals */
   int i, j, k, count, times;
   SSIZE_T best, cbest;

   fprintf( ftemp, "$\n" );  /* mark begining of gotos */

   for( i=1; i<=nnonter; ++i ) 
      {
      go2gen(i);

      /* find the best one to make default */

      best = -1;
      times = 0;

      for( j=0; j<=nstate; ++j )
         {
         /* is j the most frequent */
         if( tystate[j] == 0 ) continue;
         if( tystate[j] == best ) continue;

         /* is tystate[j] the most frequent */

         count = 0;
         cbest = tystate[j];

         for( k=j; k<=nstate; ++k ) if( tystate[k]==cbest ) ++count;

         if( count > times )
            {
            best = cbest;
            times = count;
            }
         }

      /* best is now the default entry */

      zzgobest += (times-1);
      for( j=0; j<=nstate; ++j )
         {
         if( tystate[j] != 0 && tystate[j]!=best )
            {
            fprintf( ftemp, "%d,%d,", j, tystate[j] );
            zzgoent += 1;
            }
         }

      /* now, the default */

      zzgoent += 1;
      fprintf( ftemp, "%d\n", best );

      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ynxti.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

nxti()
   {
   /* finds the next i */
   register i, maxi;
   SSIZE_T max;

   max = 0;

   for( i=1; i<= nnonter; ++i ) if( ggreed[i] >= max )
      {
      max = ggreed[i];
      maxi = -i;
      }

   for( i=0; i<nstate; ++i ) if( greed[i] >= max )
      {
      max = greed[i];
      maxi = i;
      }

   if( nxdb ) fprintf( ftable, "nxti = %d, max = %d\n", maxi, max );
   if( max==0 ) return( NOMORE );
   else return( maxi );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yosmry.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

/*
 * Write summary.
 */

void
osummary( void )

   {
   SSIZE_T i, *p;
   
   if(foutput == NULL) return;

   i=0;
   for(p=maxa; p>=a; --p)

      {
      if(*p == 0) ++i;
      }
   fprintf(foutput,"Optimizer space used: input %d/%d, output %d/%d\n",
   pmem-mem0+1, MEMSIZE, maxa-a+1, ACTSIZE);
   fprintf(foutput, "%d table entries, %d zero\n", (maxa-a)+1, i);
   fprintf(foutput, "maximum spread: %d, maximum offset: %d\n",maxspr, maxoff);
   fclose(foutput);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yhdprd.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
hideprod( void )
   {
   /* in order to free up the mem and amem arrays for the optimizer,
        /* and still be able to output yyr1, etc., after the sizes of
        /* the action array is known, we hide the nonterminals
        /* derived by productions in levprd.
        */

   register i, j;

   j = 0;
   levprd[0] = 0;
   PLOOP(1,i)
      {
      if( !(levprd[i] & REDFLAG) )
         {
         ++j;
         if( foutput != NULL )
            {
            fprintf( foutput, "Rule not reduced:   %s\n", writem( prdptr[i] ) );
            }
         }
      levprd[i] = *prdptr[i] - NTBASE;
      }
   if( j ) fprintf( stdout, "%d rules never reduced\n", j );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yothrs.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Edits:
 *      06-Dec-80 Original code broken out of y1.c.
 *      18-Dec-80 Add conditional code for Decus for tempfile deletion.
 */

#include "y1.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

FILE *pfopen(const char *path, char *search, const char *type);

void
others( void )
   {
   /* put out other arrays, copy the parsers */
   register c, i, j;
   char *psz;
   extern char *infile;

   finput = NULL;
   if ((psz = strrchr(infile, '\\')) || (psz = strrchr(infile, ':'))) {
      char tmp[FNAMESIZE];
      char c = *++psz;

      *psz = '\0';
      strcpy(tmp, infile);
      *psz = c;
      strcat(tmp, PARSER);
      finput = fopen(tmp, "r");
   }

   if ( !finput && !(finput = fopen(PARSER, "r"))) {
      if (!(finput = pfopen(PARSER, getenv(LIBENV), "r"))) {
         error( "cannot find parser %s", PARSER );
      }
   }

   warray( "yyr1", levprd, nprod );

   aryfil( temp1, nprod, 0 );
   PLOOP(1,i)temp1[i] = prdptr[i+1]-prdptr[i]-2;
   warray( "yyr2", temp1, nprod );

   aryfil( temp1, nstate, -1000 );
   TLOOP(i)
      {
      for( j=tstates[i]; j!=0; j=mstates[j] )
         {
         temp1[j] = tokset[i].value;
         }
      }
   NTLOOP(i)
      {
      for( j=ntstates[i]; j!=0; j=mstates[j] )
         {
         temp1[j] = -i;
         }
      }
   warray( "yychk", temp1, nstate );

   warray( "yydef", defact, nstate );

   /* copy parser text */

   while( (c=unix_getc(finput) ) != EOF )
      {
      if( c == '$' ) {
         switch (c=unix_getc(finput)) {
         case 'A':
            faction = fopen( ACTNAME, "r" );
            if( faction == NULL ) error( "cannot reopen action tempfile" );
            while( (c=unix_getc(faction) ) != EOF ) putc( c, ftable );
            fclose(faction);
            ZAPFILE(ACTNAME);
            c = unix_getc(finput);
            break;

         case 'T':
            if (pszPrefix) {
                fprintf(ftable, "%s", pszPrefix);
            }
            c = unix_getc(finput);
            break;

         default:
            putc( '$', ftable );
            break;
         }
      }

      putc( c, ftable );
   }

   fclose( ftable );
}

static char getbuf[30], *getbufptr = getbuf;

unix_getc(iop)
FILE *iop;
{
	if(getbufptr == getbuf)
		return(getc(iop));
	else
		return(*--getbufptr);
}

void
yungetc(c, iop)
SSIZE_T c;
FILE *iop; /* WARNING: iop ignored ... ungetc's are multiplexed!!! */
{
	*getbufptr++ = (char) c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yprcft.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
precftn(SSIZE_T r,int t,int s)
   {
   /* decide a shift/reduce conflict by precedence.*/
   /* r is a rule number, t a token number */
   /* the conflict is in state s */
   /* temp1[t] is changed to reflect the action */

   int lt, action;
   SSIZE_T lp;

   lp = levprd[r];
   lt = toklev[t];
   if( PLEVEL(lt) == 0 || PLEVEL(lp) == 0 ) 
      {
      /* conflict */
      if( foutput != NULL ) fprintf( foutput, "\n%d: shift/reduce conflict (shift %d, red'n %d) on %s",
      s, temp1[t], r, symnam(t) );
      ++zzsrconf;
      return;
      }
   if( PLEVEL(lt) == PLEVEL(lp) ) action = ASSOC(lt);
   else if( PLEVEL(lt) > PLEVEL(lp) ) action = RASC;  /* shift */
   else action = LASC;  /* reduce */

   switch( action )
      {

   case BASC:  /* error action */
      temp1[t] = ERRCODE;
      return;

   case LASC:  /* reduce */
      temp1[t] = -r;
      return;

      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\youtpt.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
output( void )
   {
   /* print the output for the states */

   int i, k;
   SSIZE_T c;
   register struct wset *u, *v;

   fprintf( ftable, "short %syyexca[] ={\n", pszPrefix ? pszPrefix : "" );

   SLOOP(i) 
      {
      /* output the stuff for state i */
      nolook = !(tystate[i]==MUSTLOOKAHEAD);
      closure(i);
      /* output actions */
      nolook = 1;
      aryfil( temp1, ntokens+nnonter+1, 0 );
      WSLOOP(wsets,u)
         {
         c = *( u->pitem );
         if( c>1 && c<NTBASE && temp1[c]==0 ) 
            {
            WSLOOP(u,v)
               {
               if( c == *(v->pitem) ) putitem( v->pitem+1, (struct looksets *)0 );
               }
            temp1[c] = state(c);
            }
         else if( c > NTBASE && temp1[ (c -= NTBASE) + ntokens ] == 0 )
            {
            temp1[ c+ntokens ] = amem[indgo[i]+c];
            }
         }

      if( i == 1 ) temp1[1] = ACCEPTCODE;

      /* now, we have the shifts; look at the reductions */

      lastred = 0;
      WSLOOP(wsets,u)
         {
         c = *( u->pitem );
         if( c<=0 )
            {
            /* reduction */
            lastred = -c;
            TLOOP(k)
               {
               if( BIT(u->ws.lset,k) )
                  {
                  if( temp1[k] == 0 ) temp1[k] = c;
                  else if( temp1[k]<0 )
                     {
                     /* reduce/reduce conflict */
                     if( foutput!=NULL )
                        fprintf( foutput,
                        "\n%d: reduce/reduce conflict (red'ns %d and %d ) on %s",
                        i, -temp1[k], lastred, symnam(k) );
                     if( -temp1[k] > lastred ) temp1[k] = -lastred;

                     ++zzrrconf;
                     }
                  else 
                     {
                     /* potential shift/reduce conflict */
                     precftn( lastred, k, i );
                     }
                  }
               }
            }
         }
      wract(i);
      }

   fprintf( ftable, "\t};\n" );

   wdef( "YYNPROD", nprod );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yprlok.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

void
prlook( struct looksets * p )

   {
   SSIZE_T j, *pp;
   pp = p->lset;
   if( pp == 0 ) fprintf( foutput, "\tNULL");
   else 
      {
      fprintf( foutput, " { " );
      TLOOP(j) 
         {
         if( BIT(pp,j) ) fprintf( foutput,  "%s ", symnam(j) );
         }
      fprintf( foutput,  "}" );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yptitm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * yptitm.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */

void
putitem( SSIZE_T * ptr, struct looksets * lptr )
   {
   register struct item *j;

#ifdef debug
   if( foutput!=NULL ) 

      {
      fprintf( foutput, "putitem(%s), state %d\n", writem(ptr), nstate );
      }
#endif
   j = pstate[nstate+1];
   j->pitem = ptr;
   if( !nolook ) j->look = flset( lptr );
   pstate[nstate+1] = ++j;
   if( (SSIZE_T *)j > zzmemsz )

      {
      zzmemsz = (SSIZE_T *)j;
      if( zzmemsz >=  &mem0[MEMSIZE] ) error( "out of state space" );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ysmnam.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

char *symnam( SSIZE_T i)
   {
   /* return a pointer to the name of symbol i */
   char *cp;

   cp = (i>=NTBASE) ? nontrst[i-NTBASE].name : tokset[i].name ;
   if( *cp == ' ' ) ++cp;
   return( cp );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yskpcm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

int
skipcom( void )
   {
   /* skip over comments */
   register c, i;  /* i is the number of lines skipped */
   i=0;                                                         /*01*/
   /* skipcom is called after reading a / */

   c = unix_getc(finput);
   if (c == '/') {
        while ((c = unix_getc(finput)) != '\n')
            ;
        return ++i;
   } else {
      if( c != '*' )
          error( "illegal comment" );
      c = unix_getc(finput);
      while( c != EOF )
         {
         if (c == '*') {
             if ((c = unix_getc(finput)) != '/') {
                 continue;
             } else {
                 return i;
             }
         }
         if (c == '\n') {
            i++;
         }
         c = unix_getc(finput);
         }
      error( "EOF inside comment" );
      return i; /* NOTREACHED */
   }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ysetup.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y2.h"
#include <string.h>
#include <ctype.h>
/*
 * YSETUP.C  -- Modified for use with DECUS LEX
 *              Variable "yylval" resides in yylex(), not in yypars();
 *              Therefore, is defined "extern" here.
 *
 *              Also, the command line processing for the Decus version
 *              has been changed.  A new switch has been added to allow
 *              specification of the "table" file name(s), and unused
 *              switch processing removed.
 *
 *                               NOTE
 *              This probably won't run on UNIX any more.
 *
 * Bob Denny 27-Aug-81
 * Bob Denny 22-Mar-82 (01) Added header line, changes for 'new' DECUS library
 * Bob Denny 12-Apr-83 (02) Make filename[] size per #define'd FNAMESIZE so
 *                          VAX filenames won't blow out.  Conditionalize
 *                          time handling for banner.  Make filespec buffer
 *                          static for safety, since global "infile" is
 *                          pointed to it.
 * Scott Guthery 15-May-83  (03) Fixed up option flag handling for RT-11
 *				 23-Dec-83  Adapted for IBM PC/XT & DeSmet C compiler
 */

static char filename[FNAMESIZE];

int i;
SSIZE_T lev, t, j, ty;
int c;
SSIZE_T tempty;
SSIZE_T *p;
int defsw, infsw, ssw = 0;
char actname[8];
char *cp;
char *pszPrefix = NULL;

void
setup(argc,argv)
int argc;
char *argv[];
   {
   char finsave[FNAMESIZE];

   defsw = infsw = 0;
   foutput = NULL;
   fdefine = NULL;

   argc--;
   argv++;
   while( argc && **argv == '-' )
      {
      while( *++(*argv) )
         {
         switch( toupper(**argv) )
            {
         case 'I':
            infsw++;
            continue;
         case 'H':
            defsw++;
            continue;

		 case 'S':
			ssw++;
			infsw++;
			continue;

         case 'T':
            if (!--argc) {
                fprintf(stderr, "-t requires an argument\n");
                usage();
            } else {
                argv++;
                if (pszPrefix) {
                    free(pszPrefix);
                }
		pszPrefix = MIDL_STRDUP(*argv);
                goto next_arg;  // I hate myself
            }
            break;

         default:
            fprintf(stderr, "Illegal option: %c\n", *argv[i]);
            usage();
            }
         }
next_arg:
      argc--;
      argv++;
      }

   if(!argc) {
      fprintf(stderr, "No input file specified\n");
      usage();               /* Catch no filename given */
   }

/*
 * Now open the input file with a default extension of ".Y",
 * then replace the period in argv[1] with a null, so argv[1]
 * can be used to form the table, defs and info filenames.
 */

   if (!(cp = strrchr(argv[i], '\\')) && !(cp = strrchr(argv[i], ':'))) {
       cp = argv[i];
   }

   cp = strrchr(cp, '.');

   if(!cp) {
      strcpy(filename, argv[i]); strcat(filename, ".Y");
   } else {
      strcpy(filename, argv[i]);
      *cp = '\0';
   }

   strcpy(finsave, filename);
   if((finput=fopen( filename, "r" )) == NULL )
      error( "cannot open input file \"%s\"", filename );

/*
 * Now open the .H and .I files if requested.
 */

   if(defsw)
      {
      strcpy(filename, argv[i]); strcat(filename, ".H");
      fdefine = fopen(filename, "w");
      if(fdefine == NULL) error("cannot open defs file\"%s\"", filename);
      }

   if(infsw)
      {
      strcpy(filename, argv[i]); strcat(filename, ".I");
      foutput = fopen(filename, "w");
      if(foutput == NULL) error("cannot open info file\"%s\"", filename);
      }
/*
 * Now the "table" output C file.
 */
   strcpy(filename, argv[i]); strcat(filename, ".C");
   ftable = fopen(filename, "w");
   if( ftable == NULL ) error( "cannot open table file \"%s\"", filename);

/*
 * Finally, the temp files.
 */
   ftemp = fopen( TEMPNAME, "w" );
   if( ftemp==NULL ) error( "cannot open temp file" );
   faction = fopen( ACTNAME, "w" );
   if( faction==NULL ) error( "cannot open action file" );


/*
 * Now put the full filename of the input file into
 * the "filename" buffer for cpyact(), and point the
 * global cell "infile" at it.
 */
   strcpy(filename, finsave);
   infile = filename;
/*
 * Put out a header line at the beginning of the 'table' file.
 */
fprintf(ftable, "/*\n * Created by CSD YACC (IBM PC) from \"%s\" */\n",
        infile);
/*
 * Complete  initialization.
 */
   cnamp = cnames;
   defin(0,"$end");
   extval = 0400;
   defin(0,"error");
   defin(1,"$accept");
   mem=mem0;
   lev = 0;
   ty = 0;
   i=0;

   yyparse();
   }
void
yyparse( void )
   {
   /* sorry -- no yacc parser here.....
                we must bootstrap somehow... */

   for( t=gettok();  t!=MARK && t!= ENDFILE; )
      {
      switch( t )
         {

      case ';':
         t = gettok();
         break;

      case START:
         if( (t=gettok()) != IDENTIFIER )
            {
            error( "bad %%start construction" );
            }
         start = chfind(1,tokname);
         t = gettok();
         continue;

      case TYPEDEF:
         if( (t=gettok()) != TYPENAME ) error( "bad syntax in %%type" );
         ty = numbval;
         for(;;)

            {
            t = gettok();
            switch( t )
               {

            case IDENTIFIER:
               if( (t=chfind( 1, tokname ) ) < NTBASE )
                  {
                  j = TYPE( toklev[t] );
                  if( j!= 0 && j != ty )
                     {
                     error( "type redeclaration of token %s",
                     tokset[t].name );
                     }
                  else SETTYPE( toklev[t],ty);
                  }
               else
                  {
                  j = nontrst[t-NTBASE].tvalue;
                  if( j != 0 && j != ty )
                     {
                     error( "type redeclaration of nonterminal %s",
                     nontrst[t-NTBASE].name );
                     }
                  else nontrst[t-NTBASE].tvalue = ty;
                  }
            case ',':
               continue;

            case ';':
               t = gettok();
               break;
            default:
               break;
               }
            break;
            }
         continue;

      case UNION:
         /* copy the union declaration to the output */
         cpyunion();
         t = gettok();
         continue;

      case LEFT:
      case BINARY:
      case RIGHT:
         ++i;
      case TERM:
         lev = t-TERM;  /* nonzero means new prec. and assoc. */
         ty = 0;

         /* get identifiers so defined */

         t = gettok();
         if( t == TYPENAME )
            {
            /* there is a type defined */
            ty = numbval;
            t = gettok();
            }

         for(;;)
            {
            switch( t )
               {

            case ',':
               t = gettok();
               continue;

            case ';':
               break;

            case IDENTIFIER:
               j = chfind(0,tokname);
               if( lev )
                  {
                  if( ASSOC(toklev[j]) ) error( "redeclaration of precedence of%s", tokname );
                  SETASC(toklev[j],lev);
                  SETPLEV(toklev[j],i);
                  }
               if( ty )
                  {
                  if( TYPE(toklev[j]) ) error( "redeclaration of type of %s", tokname );
                  SETTYPE(toklev[j],ty);
                  }
               if( (t=gettok()) == NUMBER )
                  {
                  tokset[j].value = numbval;
                  if( j < ndefout && j>2 )
                     {
                     error( "please define type number of %s earlier",
                     tokset[j].name );
                     }
                  t=gettok();
                  }
               continue;

               }

            break;
            }

         continue;

      case LCURLY:
         defout();
         cpycode();
         t = gettok();
         continue;

      default:
	     printf("Unrecognized character: %o\n", t);
         error( "syntax error" );

         }

      }

   if( t == ENDFILE )
      {
      error( "unexpected EOF before %%" );
      }

   /* t is MARK */

   defout();

   fprintf( ftable,"#define yyclearin yychar = -1\n" );
   fprintf( ftable,"#define yyerrok yyerrflag = 0\n" );
/*
   fprintf( ftable,"extern int yychar;\nextern short yyerrflag;\n" );
*/
   fprintf( ftable,"#ifndef YYMAXDEPTH\n#define YYMAXDEPTH 150\n#endif\n" );
   if(!ntypes)
      fprintf( ftable,  "#ifndef YYSTYPE\n#define YYSTYPE int\n#endif\n" );
#ifdef unix
   fprintf( ftable,  "YYSTYPE yylval, yyval;\n" );
#else
   fprintf( ftable, "extern YYSTYPE yylval;  /*CSD & DECUS LEX */\n");
   fprintf( ftable, "YYSTYPE yyval;          /*CSD & DECUS LEX */\n");
#endif
   prdptr[0]=mem;
   /* added production */
   *mem++ = NTBASE;
   *mem++ = start;  /* if start is 0, we will overwrite with the lhs of the firstrule */
   *mem++ = 1;
   *mem++ = 0;
   prdptr[1]=mem;
   while( (t=gettok()) == LCURLY ) cpycode();
   if( t != C_IDENTIFIER ) error( "bad syntax on first rule" );
   if( !start ) prdptr[0][1] = chfind(1,tokname);

   /* read rules */

   while( t!=MARK && t!=ENDFILE )
      {

      /* process a rule */

      if( t == '|' )
         {
         *mem++ = *prdptr[nprod-1];
         }
      else if( t == C_IDENTIFIER )
         {
         *mem = chfind(1,tokname);
         if( *mem < NTBASE ) error( "token illegal on LHS of grammar rule" );
         ++mem;
         }
      else error( "illegal rule: missing semicolon or | ?" );

      /* read rule body */
      t = gettok();
more_rule:
      while( t == IDENTIFIER )
         {
         *mem = chfind(1,tokname);
         if( *mem<NTBASE ) levprd[nprod] = toklev[*mem];
         ++mem;
         t = gettok();
         }
      if( t == PREC )

         {
         if( gettok()!=IDENTIFIER) error( "illegal %%prec syntax" );
         j = chfind(2,tokname);
         if( j>=NTBASE)error("nonterminal %s illegal after %%prec", nontrst[j-NTBASE].name);
         levprd[nprod]=toklev[j];
         t = gettok();
         }
      if( t == '=' )
         {
         levprd[nprod] |= ACTFLAG;
         fprintf( faction, "\ncase %d:", nprod );
         cpyact( mem-prdptr[nprod]-1 );
         fprintf( faction, " break;" );
         if( (t=gettok()) == IDENTIFIER )
            {
            /* action within rule... */
            sprintf( actname, "$$%d", nprod );
            j = chfind(1,actname);  /* make it a nonterminal */
            /* the current rule will become rule number nprod+1 */
            /* move the contents down, and make room for the null */
            for( p=mem; p>=prdptr[nprod]; --p ) p[2] = *p;
            mem += 2;
            /* enter null production for action */
            p = prdptr[nprod];
            *p++ = j;
            *p++ = -nprod;

            /* update the production information */
            levprd[nprod+1] = levprd[nprod] & ~ACTFLAG;
            levprd[nprod] = ACTFLAG;

            if( ++nprod >= NPROD ) error( "more than %d rules", NPROD );
            prdptr[nprod] = p;

            /* make the action appear in the original rule */
            *mem++ = j;

            /* get some more of the rule */

            goto more_rule;
            }

         }

      while( t == ';' ) t = gettok();

      *mem++ = -nprod;

      /* check that default action is reasonable */

      if( ntypes && !(levprd[nprod]&ACTFLAG) && nontrst[*prdptr[nprod]-NTBASE].tvalue )
         {
         /* no explicit action, LHS has value */
         /*01*/
         tempty = prdptr[nprod][1];
         if( tempty < 0 ) error( "must return a value, since LHS has a type" );
         else if( tempty >= NTBASE ) tempty = nontrst[tempty-NTBASE].tvalue;
         else tempty = TYPE( toklev[tempty] );
         if( tempty != nontrst[*prdptr[nprod]-NTBASE].tvalue )
            {
            error( "default action causes potential type clash" );
            }

         }
      if( ++nprod >= NPROD ) error( "more than %d rules", NPROD );
      prdptr[nprod] = mem;
      levprd[nprod]=0;
      }
   /* end of all rules */
   fprintf(faction, "/* End of actions */"); /* Properly terminate the last line */
   finact();
   if( t == MARK )
      {
      writeline(ftable);
      while( (c=unix_getc(finput)) != EOF ) putc( c, ftable );
      }
   fclose( finput );
   }

void
usage( void )

   {
   fprintf(stderr,"UNIX YACC (CSD Variant):\n");
   fprintf(stderr,"   yacc -hist tag infile\n\n");
   fprintf(stderr,"Switches:\n");
   fprintf(stderr,"   -h     Create definitions header file\n");
   fprintf(stderr,"   -i     Create parser description file\n");
   fprintf(stderr,"   -t tag Prepends tag to tables\n");
   fprintf(stderr,"   -s     Generates extended tables (MIDL specific) \n\n");
   fprintf(stderr,"Default input file extension is \".Y\"\n");
   fprintf(stderr,"Defs file same name, \".H\" extension.\n");
   fprintf(stderr,"Info file same name, \".I\" extension.\n");
   fprintf(stderr,"Extended Tables in file \"extable.[h1/h2/h3]\".\n");
   fprintf(stderr,"Specifying -s switch also enables the -i switch\n");
   exit(EX_ERR);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ystagn.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * ystagn.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */
void
stagen( void )

   {
   /* generate the states */

   int i;
#ifdef debug
   int j;
#endif
   SSIZE_T c;
   register struct wset *p, *q;

   /* initialize */

   nstate = 0;
   /* THIS IS FUNNY from the standpoint of portability */
   /* it represents the magic moment when the mem0 array, which has
        /* been holding the productions, starts to hold item pointers, of a
        /* different type... */
   /* someday, alloc should be used to allocate all this stuff... for now, we
        /* accept that if pointers don't fit in integers, there is a problem... */

   pstate[0] = pstate[1] = (struct item *)mem;
   aryfil( clset.lset, tbitset, 0 );
   putitem( prdptr[0]+1, &clset );
   tystate[0] = MUSTDO;
   nstate = 1;
   pstate[2] = pstate[1];

   aryfil( amem, ACTSIZE, 0 );

   /* now, the main state generation loop */

more:
   SLOOP(i)

      {
      if( tystate[i] != MUSTDO ) continue;
      tystate[i] = DONE;
      aryfil( temp1, nnonter+1, 0 );
      /* take state i, close it, and do gotos */
      closure(i);
      WSLOOP(wsets,p)

         {
         /* generate goto's */
         if( p->flag ) continue;
         p->flag = 1;
         c = *(p->pitem);
         if( c <= 1 ) 

            {
            if( pstate[i+1]-pstate[i] <= p-wsets ) tystate[i] = MUSTLOOKAHEAD;
            continue;

            }
         /* do a goto on c */
         WSLOOP(p,q)

            {
            if( c == *(q->pitem) )

               {
               /* this item contributes to the goto */
               putitem( q->pitem + 1, &q->ws );
               q->flag = 1;
               }
            }
         if( c < NTBASE ) 

            {
            state(c);  /* register new state */
            }
         else 

            {
            temp1[c-NTBASE] = state(c);
            }
         }
#ifdef debug
      if( foutput!=NULL )

         {
         fprintf( foutput,  "%d: ", i );
         NTLOOP(j) 

            {
            if( temp1[j] ) fprintf( foutput,  "%s %d, ", nontrst[j].name, temp1[j] );
            }
         fprintf( foutput, "\n");
         }
#endif
      indgo[i] = apack( &temp1[1], nnonter-1 ) - 1;
      goto more; /* we have done one goto; do some more */
      }
   /* no more to do... stop */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ystuni.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

setunion( a, b ) SSIZE_T *a, *b; 

   {
   /* set a to the union of a and b */
   /* return 1 if b is not a subset of a, 0 otherwise */
   register i, sub;
   SSIZE_T x;

   sub = 0;
   SETLOOP(i)
      {
      *a = (x = *a)|*b++;
      if( *a++ != x ) sub = 1;
      }
   return( sub );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ysumry.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

void
summary( void )
   {
   /* output the summary on the tty */

   if( foutput!=NULL )
      {
      fprintf( foutput, "\n%d/%d terminals, %d/%d nonterminals\n", ntokens, NTERMS,
      nnonter, NNONTERM );
      fprintf( foutput, "%d/%d grammar rules, %d/%d states\n", nprod, NPROD, nstate, NSTATES );
      fprintf( foutput, "%d shift/reduce, %d reduce/reduce conflicts reported\n", zzsrconf, zzrrconf );
      fprintf( foutput, "%d/%d working sets used\n", zzcwp-wsets,  WSETSIZE );
      fprintf( foutput, "memory: states,etc. %d/%d, parser %d/%d\n", zzmemsz-mem0, MEMSIZE,
      memp-amem, ACTSIZE );
      fprintf( foutput, "%d/%d distinct lookahead sets\n", nlset, LSETSIZE );
      fprintf( foutput, "%d extra closures\n", zzclose - 2*nstate );
      fprintf( foutput, "%d shift entries, %d exceptions\n", zzacent, zzexcp );
      fprintf( foutput, "%d goto entries\n", zzgoent );
      fprintf( foutput, "%d entries saved by goto default\n", zzgobest );
      }
   if( zzsrconf!=0 || zzrrconf!=0 )
      {
      fprintf( stdout,"\nconflicts: ");
      if( zzsrconf )fprintf( stdout, "%d shift/reduce" , zzsrconf );
      if( zzsrconf && zzrrconf )fprintf( stdout, ", " );
      if( zzrrconf )fprintf( stdout, "%d reduce/reduce" , zzrrconf );
      fprintf( stdout, "\n" );
      }

   if (ftemp) {
       fclose( ftemp );
   }

   if( fdefine != NULL ) fclose( fdefine );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ystate.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

int
state( SSIZE_T c)
   {
   /* sorts last state,and sees if it equals earlier ones. returns state number */
   SSIZE_T size1,size2;
   register i;
   SSIZE_T *s;                                                  /*01*/
   struct looksets *ss;                                         /*01*/
   int s__;                                                     /*01*/
   struct item *p1, *p2, *k, *l, *q1, *q2;
   p1 = pstate[nstate];
   p2 = pstate[nstate+1];
   if(p1==p2) return(0); /* null state */
   /* sort the items */
   for(k=p2-1;k>p1;k--) 
      {
      /* make k the biggest */
      for(l=k-1;l>=p1;--l)if( l->pitem > k->pitem )
         {
         s = k->pitem;
         k->pitem = l->pitem;
         l->pitem = s;
         ss = k->look;
         k->look = l->look;
         l->look = ss;
         }
      }
   size1 = p2 - p1; /* size of state */

   for( i= (c>=NTBASE)?ntstates[c-NTBASE]:tstates[c]; i != 0; i = mstates[i] ) 
      {
      /* get ith state */
      q1 = pstate[i];
      q2 = pstate[i+1];
      size2 = q2 - q1;
      if (size1 != size2) continue;
      k=p1;
      for(l=q1;l<q2;l++) 
         {
         if( l->pitem != k->pitem ) break;
         ++k;
         }
      if (l != q2) continue;
      /* found it */
      pstate[nstate+1] = pstate[nstate]; /* delete last state */
      /* fix up lookaheads */
      if( nolook ) return(i);
      for( l=q1,k=p1; l<q2; ++l,++k )
         {
         SETLOOP(s__) clset.lset[s__] = l->look->lset[s__];
         if( setunion( clset.lset, k->look->lset ) ) 
            {
            tystate[i] = MUSTDO;
            /* register the new set */
            l->look = flset( &clset );
            }
         }
      return (i);
      }
   /* state is new */

   if( nolook ) error( "yacc state/nolook error" );
   pstate[nstate+2] = p2;
   if(nstate+1 >= NSTATES) error("too many states" );
   if( c >= NTBASE )
      {
      mstates[ nstate ] = ntstates[ c-NTBASE ];
      ntstates[ c-NTBASE ] = nstate;
      }
   else 
      {
      mstates[ nstate ] = tstates[ c ];
      tstates[ c ] = nstate;
      }
   tystate[nstate]=MUSTDO;
   return(nstate++);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ywarry.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
warray( char *s, SSIZE_T *v, int n )
   {

   register i;

   fprintf( ftable, "short %s%s[]={\n", pszPrefix ? pszPrefix : "", s );
   for( i=0; i<n; )
      {
      if( i%10 == 0 ) fprintf( ftable, "\n" );
      fprintf( ftable, "%4d", v[i] );
      if( ++i == n ) fprintf( ftable, " };\n" );
      else fprintf( ftable, "," );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ystin.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
stin( SSIZE_T i)
   {
   SSIZE_T *r, *s, n, flag, j, *q1, *q2;

   greed[i] = 0;

   /* enter state i into the a array */

   q2 = mem0+yypact[i+1];
   q1 = mem0+yypact[i];
   /* find an acceptable place */

   for( n= -maxoff; n<ACTSIZE; ++n )
      {

      flag = 0;
      for( r = q1; r < q2; r += 2 )
         {
         if( (s = *r + n + a ) < a ) goto nextn;
         if( *s == 0 ) ++flag;
         else if( *s != r[1] ) goto nextn;
         }

      /* check that the position equals another only if the states are identical */

      for( j=0; j<nstate; ++j )
         {
         if( pa[j] == n ) 
            {
            if( flag ) goto nextn;  /* we have some disagreement */
            if( yypact[j+1] + yypact[i] == yypact[j] + yypact[i+1] )
               {
               /* states are equal */
               pa[i] = n;
               if( adb>1 ) fprintf( ftable, "State %d: entry at %d equals state %d\n",
               i, n, j );
               return;
               }
            goto nextn;  /* we have some disagreement */
            }
         }

      for( r = q1; r < q2; r += 2 )
         {
         if( (s = *r + n + a ) >= &a[ACTSIZE] ) error( "out of space in optimizer a array" );
         if( s > maxa ) maxa = s;
         if( *s != 0 && *s != r[1] ) error( "clobber of a array, pos'n %d, by %d", s-a, r[1] );
         *s = r[1];
         }
      pa[i] = n;
      if( adb>1 ) fprintf( ftable, "State %d: entry at %d\n", i, pa[i] );
      return;

nextn:  
      ;
      }

   error( "Error; failure to place state %d\n", i );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ywract.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
wract( int i)
   {
   /* output state i */
   /* temp1 has the actions, lastred the default */
   int p, p0;
   SSIZE_T p1;
   int ntimes, count, j;
   SSIZE_T tred;
   int flag;

   /* find the best choice for lastred */

   lastred = 0;
   ntimes = 0;
   TLOOP(j)
      {
      if( temp1[j] >= 0 ) continue;
      if( temp1[j]+lastred == 0 ) continue;
      /* count the number of appearances of temp1[j] */
      count = 0;
      tred = -temp1[j];
      levprd[tred] |= REDFLAG;
      TLOOP(p)
         {
         if( temp1[p]+tred == 0 ) ++count;
         }
      if( count >ntimes )
         {
         lastred = tred;
         ntimes = count;
         }
      }

   /* for error recovery, arrange that, if there is a shift on the
        /* error recovery token, `error', that the default be the error action */
   if( temp1[1] > 0 ) lastred = 0;

   /* clear out entries in temp1 which equal lastred */
   TLOOP(p) if( temp1[p]+lastred == 0 )temp1[p]=0;

   wrstate(i);
   defact[i] = lastred;

   flag = 0;
   TLOOP(p0)
      {
      if( (p1=temp1[p0])!=0 ) 
         {
         if( p1 < 0 )
            {
            p1 = -p1;
            goto exc;
            }
         else if( p1 == ACCEPTCODE ) 
            {
            p1 = -1;
            goto exc;
            }
         else if( p1 == ERRCODE ) 
            {
            p1 = 0;
            goto exc;

exc:
            if( flag++ == 0 ) fprintf( ftable, "-1, %d,\n", i );
            fprintf( ftable, "\t%d, %d,\n", tokset[p0].value, p1 );
            ++zzexcp;
            }
         else 
            {
            fprintf( ftemp, "%d,%d,", tokset[p0].value, p1 );
            ++zzacent;
            }
         }
      }
   if( flag ) 
      {
      defact[i] = -2;
      fprintf( ftable, "\t-2, %d,\n", lastred );
      }
   fprintf( ftemp, "\n" );
   return;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ywstat.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 The s switch has been introduced to allow yacc to generate extended tables
 for MIDL error recovery and reporting scheme. The following are the routines
 which take part in s switch processing:

 . EmitStateVsExpectedConstruct
 . EmitStateGotoTable
 . SSwitchInit
 . SSwitchExit

 The global int variable ssw is 0 if s switch is not specified, non-zero
 otherwise. This is set in ysetup.c If the sswitch is specified, the i switch
 is automatically enabled.

 ----------------------------------------------------------------------------*/
#include <malloc.h>
#include <stdlib.h>
#include "y3.h"
#include "y4.h"

extern int ssw;

FILE *tokxlathdl;/* token xlation file,token index vs value*/
FILE *stgotohdl; /* state goto table file handle */
FILE *stexhdl;	 /* state vs expected construct handle */
short MaxStateVsTokenCount = 0;
short MaxTokenVsStateCount = 0;
short *pTokenVsStateCount;
SSIZE_T MaxTokenValue = 0;
short NStates = 0;
int StateVsExpectedCount = 0;

void
wrstate( int i)
   {
   /* writes state i */
   register j0;
   SSIZE_T j1;
   register struct item *pp, *qq;
   register struct wset *u;

   if( foutput == NULL ) return;

	SSwitchInit();

   fprintf( foutput, "\nstate %d\n",i);
   ITMLOOP(i,pp,qq)
	{
	fprintf( foutput, "\t%s\n", writem(pp->pitem));
	EmitStateVsExpectedConstruct( i,  pp->pitem );
	}

   if( tystate[i] == MUSTLOOKAHEAD )
      {
      /* print out empty productions in closure */
      WSLOOP( wsets+(pstate[i+1]-pstate[i]), u )
         {
         if( *(u->pitem) < 0 ) fprintf( foutput, "\t%s\n", writem(u->pitem) );
         }
      }

   /* check for state equal to another */

   TLOOP(j0)
	{
	if( (j1=temp1[j0]) != 0 )
      {
      fprintf( foutput, "\n\t%s  ", symnam(j0) );
      if( j1>0 )
         {
         /* shift, error, or accept */
         if( j1 == ACCEPTCODE ) fprintf( foutput,  "accept" );
         else if( j1 == ERRCODE ) fprintf( foutput, "error" );
         else fprintf( foutput,  "shift %d", j1 );
         }
      else fprintf( foutput, "reduce %d",-j1 );
      }
	}

	/* output any s switch information */

	EmitStateGotoTable( i );

   /* output the final production */

   if( lastred ) fprintf( foutput, "\n\t.  reduce %d\n\n", lastred );
   else fprintf( foutput, "\n\t.  error\n\n" );

   /* now, output nonterminal actions */

   j1 = ntokens;
   for( j0 = 1; j0 <= nnonter; ++j0 )
      {
      if( temp1[++j1] )
		fprintf( foutput, "\t%s  goto %d\n", symnam( j0+NTBASE), temp1[j1] );
      }

   }

void
wdef( char *s, int n )

   {
   /* output a definition of s to the value n */
   fprintf( ftable, "# define %s %d\n", s, n );
   }
void
EmitStateGotoTable(
	int		i )
	{

	register int j0;
	short count = 0;

#define TLOOP_0(i) for(i=0;i<=ntokens;++i)
	if( ssw )
		{

		NStates++;

		TLOOP_0( j0 )
			{
			if( (temp1[ j0 ] > 0 ) && (temp1[ j0 ] != ACCEPTCODE ) )
				count++;
			}

		if( count >= MaxStateVsTokenCount )
			MaxStateVsTokenCount = count;

		fprintf( stgotohdl, "%.4d : %.4d : ", i, count );

   		TLOOP_0( j0 )
			{
			if( (temp1[ j0 ] > 0 ) && (temp1[ j0 ] != ACCEPTCODE ) )
				{
				fprintf( stgotohdl, " %.4d, %.4d", temp1[ j0 ], j0 );
				pTokenVsStateCount[ j0 ] += 1;
				if( pTokenVsStateCount[ j0 ] >= MaxTokenVsStateCount )
					MaxTokenVsStateCount = pTokenVsStateCount[ j0 ];
				}
			}

		fprintf( stgotohdl, "\n");
		}

	}
void
EmitStateVsExpectedConstruct(
	int state,
	SSIZE_T *pp )
   {
   SSIZE_T i,*p;
//   char *q;
   int flag = 0;
   int Count;

   if( ssw )
	{
   	for( p=pp; *p>0 ; ++p ) ;

   	p = prdptr[-*p];

// 	fprintf( stexhdl, " %s", nontrst[ *p-NTBASE ].name );
 	fprintf( stexhdl, " %.4d : ", state );

	Count = CountStateVsExpectedConstruct( state, pp );

	StateVsExpectedCount += Count;

	fprintf( stexhdl, " %.4d : ",Count );
	
   	for(;;)
      	{
      	if( ++p==pp )
			{
			if( ( i = *p ) <= 0 )
				{
				fprintf( stexhdl, "\n" );
				return;
				}
			else
				fprintf( stexhdl, "%s\n", symnam(i) );
			}
		if( p >= pp ) return;
      	}
	}
}
int
CountStateVsExpectedConstruct(
	int state,
	SSIZE_T *pp )
   {
   SSIZE_T i,*p;
   int flag = 0;
   int Count = 0;

   if( ssw )
	{
   	for( p=pp; *p>0 ; ++p ) ;

   	p = prdptr[-*p];

   	for(;;)
      	{
      	if( ++p==pp )
			{
			if( ( i = *p ) <= 0 )
				{
				return Count;
				}
			else
				++Count;
			}
		if( p >= pp ) return Count;
      	}
	}

    return Count;   /* NOTREACHED */
}
void
SSwitchInit()
	{
static sswitch_inited = 0;
	int	i	= 0;

	if( ssw && ! sswitch_inited )
		{
		tokxlathdl	= fopen( "extable.h1" , "w" );

        if ( NULL == tokxlathdl ) {error("Unable to open tokxlathdl" );exit(0);}

		/* output the token index vs the token value table */

		fprintf( tokxlathdl, "%d %d\n", ntokens+1, ACCEPTCODE );

		while( i <= ntokens )
			{
			fprintf( tokxlathdl , "%d ",
				tokset[ i ].value);

			if( tokset[ i ].value >= MaxTokenValue )
				MaxTokenValue = tokset[ i ].value;

			++i;
			}

		fprintf(tokxlathdl, "\n");

		/* set up for the state vs expected construct */

		stexhdl	= fopen( "extable.h2", "w" );
               
                if ( NULL == stexhdl ) error("Unable to open extable.h2");

		/* set up for state goto table */

		stgotohdl = fopen( "extable.h3", "w");

                if ( NULL == stgotohdl ) error("Unable to open extable.h3");

		/* set up state vs token count array */

		pTokenVsStateCount = calloc( 1, (ntokens+1 ) * sizeof(short) );

                if ( NULL == pTokenVsStateCount ) error("Out of memory");

		sswitch_inited = 1;
		}
	}

void
SSwitchExit( void )
	{
	int i;

	if( ssw )
		{

		/** print the token index vs goto count **/

		for( i = 0; i <= ntokens ; ++i )
			{
			fprintf( tokxlathdl , "%d ", pTokenVsStateCount[ i ]);
			}

		fprintf( tokxlathdl, "\n");
		fprintf( tokxlathdl, "%d %d %d %d %d \n",
							 NStates,
							 MaxTokenVsStateCount,
							 MaxStateVsTokenCount,
							 MaxTokenValue,
							 StateVsExpectedCount );

		fclose( tokxlathdl );
		fclose( stexhdl );
		fclose( stgotohdl );
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\ywritm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

char *chcopy(char *, char *);

extern char sarr[ISIZE];

char *writem(pp) SSIZE_T *pp; 

   {
   /* creates output string for item pointed to by pp */
   SSIZE_T i,*p;
   char *q;

   for( p=pp; *p>0 ; ++p ) ;
   p = prdptr[-*p];
   q = chcopy( sarr, nontrst[*p-NTBASE].name );
   q = chcopy( q, " : " );

   for(;;)
      {
      *q++ = ++p==pp ? '_' : ' ';
      *q = '\0';
      if((i = *p) <= 0) break;
      q = chcopy( q, symnam(i) );
      if( q> &sarr[ISIZE-30] ) error( "item too big" );
      }

   if( (i = *pp) < 0 )
      {
      /* an item calling for a reduction */
      q = chcopy( q, "    (" );
      sprintf( q, "%d)", -i );
      }

   return( sarr );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yypars.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
___a_r_u_start
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
YYSTATIC YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC int yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

static	void	yy_vc_init();
typedef	void	(*pfn)();
static	pfn		*pcase_fn_array;
static	int		returnflag = 0;
static	YYSTYPE	*yypvt;
static	int		yym_vc_max = 0;
extern  short	GrammarAct;

extern short	yysavestate;

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps, *yysave_yyps;
	YYSTYPE		*yypv,*yysave_yypv;
	YYSTYPE		yysave_yyval;
	short		yyj, yym;
	short		fHaveRecoveredChar	= 0;

	yy_vc_init();
#ifdef YYDEBUG
	yydebug = 1;
#endif /* YYDEBUG */

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else /* YYDEBUG */
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif /* YYDEBUG */
	if( ++yyps > &yys[YYMAXDEPTH] ) {
/*		yyerror( "yacc stack overflow" ); */
		ParseError(C_STACK_OVERFLOW, (char *)NULL);
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

	yysavestate	= yystate;
	yysave_yypv	= yypv;
	yysave_yyval= yyval;
	yysave_yyps	= yyps;

	yyn = yypact[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}

	if( ! fHaveRecoveredChar )
		{
		if( yychar < 0 ) /*  need a lookahead */
			{
			yychar = YYLEX();
			}
		}

	fHaveRecoveredChar	= 0;

	if( ((yyn += yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}

	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ) /* error */
		{ 

		int yytempchar;


		if( ( yytempchar = GetExpectedChar( yysavestate ) ) != -1 )
			{
			char Buf[ 9 ];

			SyntaxError( BENIGN_SYNTAX_ERROR, yysavestate );

			fHaveRecoveredChar	= 1;
			yyunlex( yychar );
			yychar	= yytempchar;

			sprintf( Buf, " %c ", yytempchar );
			ParseError( ASSUMING_CHAR, Buf );

			yystate	= yysavestate;
			yypv	= yysave_yypv;
			yyval	= yysave_yyval;
			yyps	= yysave_yyps;

			goto yynewstate;

			}
		else
			{
			SyntaxError( SYNTAX_ERROR, yysavestate );
			return 1;
			}
		}

	/* reduction by production yyn */
/* yyreduce: */
		{
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else /* YYDEBUG */
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif /* YYDEBUG */
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = yyr1[yyn];		/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		returnflag = 0;
		GrammarAct = yym;
		(*(pcase_fn_array[ (yym <= yym_vc_max) ? yym : 0  ]))();
		if(returnflag != 0)
			return returnflag;
		}
		goto yystack;  /* stack new state and value */
	}
___a_r_u_myact
$A
___a_r_u_end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yyless.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

yyless(x)

   {
   extern char yytext[];
   register char *lastch, *ptr;
   extern int yyleng;
   extern int yyprevious;
   lastch = yytext+yyleng;
   if (x>=0 && x <= yyleng)
      ptr = x + yytext;
   else
      ptr = x;
   while (lastch > ptr)
      yyunput(*--lastch);
   *lastch = 0;
   if (ptr >yytext)
      yyprevious = *--lastch;
   yyleng = ptr-yytext;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\yywrap.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

yywrap()

   {
   return(1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\yacc\template\yypars.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
___a_r_u_start
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
YYSTATIC YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC int yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

static	void	yy_vc_init();
typedef	void	(*pfn)();
static	pfn		*pcase_fn_array;
static	int		returnflag = 0;
static	YYSTYPE	*yypvt;
static	int		yym_vc_max = 0;
extern  short	GrammarAct;

extern short	yysavestate;

#define MAX_RECOVERY_ATTEMPTS	(50)
#define MAX_RETRY_COUNT			(3)
static short RetryCount = 0;
static short MaxRecoveryAttempts = 0;
static short fJustDiscarded = 0;

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps, *yysave_yyps;
	YYSTYPE		*yypv,*yysave_yypv;
	YYSTYPE		yysave_yyval;
	short		yyj, yym;
	short		fHaveRecoveredChar	= 0;

	yy_vc_init();
#ifdef YYDEBUG
	yydebug = 1;
#endif /* YYDEBUG */

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

	RetryCount = 0;

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else /* YYDEBUG */
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif /* YYDEBUG */
	if( ++yyps > &yys[YYMAXDEPTH] ) {
/*		yyerror( "yacc stack overflow" ); */
		ParseError(C_STACK_OVERFLOW, (char *)NULL);
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

	yysavestate	= yystate;
	yysave_yypv	= yypv;
	yysave_yyval= yyval;
	yysave_yyps	= yyps;

	yyn = yypact[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}

	if( ! fHaveRecoveredChar )
		{
		if( yychar < 0 ) /*  need a lookahead */
			{
			yychar = YYLEX();
			}
		}

	fHaveRecoveredChar	= 0;

	if( ((yyn += yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}

	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ) /* error */
		{ 

		int yytempchar;


		if( (yychar != EOI ) &&
			 ( RetryCount < MAX_RETRY_COUNT ) &&
			 ( MaxRecoveryAttempts < MAX_RECOVERY_ATTEMPTS ) )
			{ 
			if( RetryCount == 0 )
				SyntaxError( BENIGN_SYNTAX_ERROR, yysavestate );

			if((( yytempchar = PossibleMissingToken( yysavestate, yychar ) ) != -1 ))
				{
				char Buf[ 50 ];


				fHaveRecoveredChar	= 1;
				yyunlex( yychar );
				yychar	= yytempchar;

				if( (yytempchar < 128 ) && isprint( yytempchar ) )
					{
					sprintf( Buf, " %c ", yytempchar );
					}
				else if( yytempchar == IDENTIFIER )
					{
					yylval.yy_pSymName = GenTempName();
					sprintf( Buf, " identifier %s", yylval.yy_pSymName );
					}
				else if( (yytempchar == NUMERICCONSTANT ) ||
						 (yytempchar == NUMERICLONGCONSTANT ) ||
						 (yytempchar == NUMERICULONGCONSTANT ) ||
						 (yytempchar == HEXCONSTANT ) ||
						 (yytempchar == HEXLONGCONSTANT ) ||
						 (yytempchar == HEXULONGCONSTANT ) )
					{
					sprintf( Buf, "a number" );
					yylval.yy_numeric.Val = 0;
					yylval.yy_numeric.pValStr = new char[2];
					strcpy( yylval.yy_numeric.pValStr, "0");
					}

				ParseError( ASSUMING_CHAR, Buf );
				RetryCount = 0;
				MaxRecoveryAttempts++;
				fJustDiscarded = 0;
				}
			else 
				{
				char buf[ 20 ];
				if( (yychar < 128 ) && isprint( yychar ) )
					{
					sprintf( buf, " %c ", yychar );
					}
				else
					{
					sprintf( buf, " the last token " );
					}

				ParseError( DISCARDING_CHAR, buf );
				yychar = -1;
				RetryCount++;
				MaxRecoveryAttempts++;
				fJustDiscarded = 1;
				}

			yystate	= yysavestate;
			yypv	= yysave_yypv;
			yyval	= yysave_yyval;
			yyps	= yysave_yyps;

			goto yynewstate;

			}
		else if( (yychar == EOI ) && (fJustDiscarded == 0 ) )
			{
			SyntaxError( UNEXPECTED_END_OF_FILE, yysavestate );
			return 1;
			}
		else
			{
			SyntaxError( SYNTAX_ERROR, yysavestate );
			return 1;
			}
		}

	/* reduction by production yyn */
/* yyreduce: */
		{
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else /* YYDEBUG */
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif /* YYDEBUG */
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = yyr1[yyn];		/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		returnflag = 0;
		GrammarAct = yym;
		(*(pcase_fn_array[ (yym <= yym_vc_max) ? yym : 0  ]))();
		if(returnflag != 0)
			return returnflag;
		}
		goto yystack;  /* stack new state and value */
	}
___a_r_u_myact
$A
___a_r_u_end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\uuidgen\uuidfmt.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    uuidfmt.c {v1.00}

Abstract:

This module contains I_UuidStringGenerate, which coalesces
the procedures UuidCreate and UuidToString to create a UUID
in one of the formats IDL, C struct, or plain.

Author:

    Joev Dubach (t-joevd) 6/11/92

Revision History:

--*/

//
// Defines
//

#define IDL_STR "[\nuuid(%s),\nversion(1.0)\n]\ninterface %s\n{\n\n}\n"

//
// Inclusions
//
// The order in which these includes are performed seems, after
// extensive testing and analysis, to be highly crucial to a
// successful NT build.

#include <sysinc.h>
#include <rpc.h>
#include <uuidfmt.h>
#include <stdio.h>
#include <stdlib.h>

//
// Function prototypes.
//

void GenUuidAsIDL (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    );

void GenUuidAsCStruct (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    );

void GenUuidPlain (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString
    );

void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    size_t size
    )
{
    return malloc(size);
}

void __RPC_API
MIDL_user_free(
    void __RPC_FAR * pvBuf
    )
{
    free(pvBuf);
}



/*

Routine Description:

    This routine creates a UUID in one of several string representations.

Arguments:

    Flag - UUIDGEN_FORMAT_IDL gives an IDL template;
           UUIDGEN_FORMAT_CSTRUCT gives a C Struct;
           UUIDGEN_FORMAT_PLAIN gives a plain UUID.

    UuidFormattedString - Must be preinitialized; will contain result.

    InterfaceName - Name of desired interface; used for IDL and C Structs.

Return Value:

    RPC_S_OK - We successfully converted the UUID into its string
        representation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a string.

    RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
        token ring address for this machine.


*/

RPC_STATUS I_UuidStringGenerate(
    int Flag,
    int Sequential,
    int AllCaps,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    )
{
    UUID MyUuid;                    // Storage for a retrieved UUID.
    char PAPI * MyUuidString;
    RPC_STATUS Result;
    int LocalOnly = 0;

    ASSERT(   (Flag == UUIDGEN_FORMAT_IDL)
           || (Flag == UUIDGEN_FORMAT_CSTRUCT)
           || (Flag == UUIDGEN_FORMAT_PLAIN));

    if (Sequential)
        {
        Result = UuidCreateSequential(&MyUuid);
        }
    else 
        {
        Result = UuidCreate(&MyUuid);
        }

    ASSERT(    (Result == RPC_S_UUID_NO_ADDRESS)
            || (Result == RPC_S_OK)
            || (Result == RPC_S_UUID_LOCAL_ONLY) );

    if (Result == RPC_S_UUID_LOCAL_ONLY)
        {
        Result = RPC_S_OK;
        LocalOnly = 1;
        }

    if (Result == RPC_S_OK)
        {
        Result = UuidToString(
            &MyUuid,
            &MyUuidString
            );

        ASSERT((Result == RPC_S_OK) || (Result == RPC_S_OUT_OF_MEMORY));
        if (Result == RPC_S_OK)
            {

            if (AllCaps) {
                char *p = MyUuidString;
                while (*p)
                    {
                    *p= (char)toupper(*p);
                    p++;
                    }
                }

            switch(Flag)
                {
                case UUIDGEN_FORMAT_IDL:
                    GenUuidAsIDL(
                        MyUuidString,
                        UuidFormattedString,
                        InterfaceName
                        );
                    break;
                case UUIDGEN_FORMAT_CSTRUCT:
                    GenUuidAsCStruct(
                        MyUuidString,
                        UuidFormattedString,
                        InterfaceName
                        );
                    break;

                case UUIDGEN_FORMAT_PLAIN:
                    GenUuidPlain(
                        MyUuidString,
                        UuidFormattedString
                        );
                } // end switch
            RpcStringFree(&MyUuidString);
            } // end if
        } // end if

    if (   (Result == RPC_S_OK)
        && (LocalOnly) )
        {
        return(RPC_S_UUID_LOCAL_ONLY);
        }

    return(Result);
} // end I_UuidStringGenerate

void GenUuidAsIDL (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    )
{
    sprintf(
        UuidFormattedString,
        IDL_STR,
        MyUuidString,
        InterfaceName
        );
}

void GenUuidAsCStruct (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    )
{
    int      i;
    char     temp[157] =
        "%s = { /* ........-....-....-....-............ */\n"
        "    0x........,\n"
        "    0x....,\n"
        "    0x....,\n"
        "    {0x.., 0x.., 0x.., 0x.., 0x.., 0x.., 0x.., 0x..}\n"
        "  };\n\0";

    for (i=0; i<36; i++) temp[10+i] = MyUuidString[i];
    for (i=0; i<8; i++) temp[56+i] = MyUuidString[i];
    for (i=0; i<4; i++) temp[72+i] = MyUuidString[9+i];
    for (i=0; i<4; i++) temp[84+i] = MyUuidString[14+i];
    for (i=0; i<2; i++) temp[97+i] = MyUuidString[19+i];
    for (i=0; i<2; i++) temp[103+i] = MyUuidString[21+i];
    for (i=0; i<2; i++) temp[109+i] = MyUuidString[24+i];
    for (i=0; i<2; i++) temp[115+i] = MyUuidString[26+i];
    for (i=0; i<2; i++) temp[121+i] = MyUuidString[28+i];
    for (i=0; i<2; i++) temp[127+i] = MyUuidString[30+i];
    for (i=0; i<2; i++) temp[133+i] = MyUuidString[32+i];
    for (i=0; i<2; i++) temp[139+i] = MyUuidString[34+i];
    sprintf(UuidFormattedString, temp, InterfaceName);
}

void GenUuidPlain (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString
    )
{
    strcpy(UuidFormattedString, MyUuidString);
    strcat(UuidFormattedString, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\uuidgen\uuidfmt.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    uuidfmt.h {v1.00}

Abstract:

    This module is used by uuidfmt.c and any other module which
    uses uuidfmt.c.
    It prototypes the entry into uuidfmt.c, I_UuidStringGenerate,
    and contains the set of flag codes used by I_UuidStringGenerate.

Author:

    Joev Dubach (t-joevd) 6/11/92

Revision History:

--*/

#ifndef __UUIDGEN_H__
#define __UUIDGEN_H__

//
// Defines (flags for I_UuidStringGenerate)
//

#define UUIDGEN_FORMAT_IDL 0
#define UUIDGEN_FORMAT_CSTRUCT 1
#define UUIDGEN_FORMAT_PLAIN 2

//
// Function prototypes
//

RPC_STATUS I_UuidStringGenerate(
    int Flag,
    int Sequential,
    int AllCaps,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    );

#endif /* __UUIDGEN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\pch.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       pch.cxx
//
//  Contents:   headers to be built into the precompiled header file
//
//              include headers that don't change often in here
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>                 //  NT definitions
    #include <ntrtl.h>              //  NT runtime library definitions
    #include <nturtl.h>
}

#include <fileno.hxx>           //  macros to be used with THIS_FILE_NUMBER

#include <netevent.h>
#include <windows.h>            //  Win32 type definitions
#include <windowsx.h>           //  GET_WM_COMMAND_ID
#include <winnetwk.h>

#include <stdio.h>
#include <string.h>

#include <lmcons.h>             //  LAN Manager common definitions
#include <lmerr.h>              //  LAN Manager network error definitions
#include <lmshare.h>
#include <lmsname.h>            //  LAN Manager service names
#include <lmapibuf.h>           //  NetApiBufferFree
#include <lmserver.h>           //  NetServerEnum
#include <lmaccess.h>           //  NetUserGetInfo

#ifndef UNICODE
#define NetpGetDomainName NetpGetDomainNameT
#endif
#include <netlib.h>             //  LAN Man utility routines
#undef NetpGetDomainName
#include <netlibnt.h>           //  NetpNtStatusToApiStatus
#include <netdebug.h>           //  NetpDbgPrint

#include <stdlib.h>
#include <tchar.h>
//#include <tstring.h>            //  Transitional string functions
//#include <icanon.h>             //  I_Net canonicalize functions
//#include <align.h>              //  ROUND_UP_COUNT macro

#include <svcs.h>

//#include <apperr.h>             //  APE_AT_ID_NOT_FOUND
extern "C"
{
    #include <rpcutil.h>            //  Prototypes for MIDL user functions
}

#include <tchar.h>
#include <dsgetdc.h>            // DsGetDcName

#include <cfiletim.hxx>
#include <winldap.h>
#include <new>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\uuidgen\uuidgen.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    uuidgen.c {v1.00}

Abstract:

usage: uuidgen [-xisconvh?]
        x - Generate sequential (V1) UUIDs
        i - Output UUID in an IDL interface template
        s - Output UUID as an initialized C struct
        c - Output UUID in upper case
        o<filename> - redirect output to a file, specified immediately after o
        n<number> - Number of UUIDs to generate, specified immediately after n
        v - display version information about uuidgen
        h,? - Display command option summary

This command-line program simply uses the procedure I_UuidStringGenerate
to output one or more UUIDs in one of the formats normal, IDL, or C struct.
This code should build under nt to nt and nmake under os2 to dos.
Requires uuidfmt.c.

Author:

    Joev Dubach (t-joevd) 6/11/92

Revision History:

--*/

//
// Inclusions
//
// The order in which these includes are performed seems, after
// extensive testing and analysis, to be highly crucial to an
// NT build.

#include <sysinc.h>
#include <rpc.h>
#include <uuidfmt.h>
#include <stdio.h>
#include <stdlib.h>

#include <common.ver>

//
// Defines
//

#define IDL_BIT_FLAG 0x01
#define CSTRUCT_BIT_FLAG 0x02
#define SEQUENTIAL_UUIDS   0x04
#define UPPER_CASE_UUIDS   0x08
#define BAD_SWITCH_STR "Invalid Switch Usage: %s\n\n"
#define CANNOT_OPEN_STR "Cannot open output file: %s\n\n"
#define TOO_SMALL_STR "Argument to %s must be an integer greater than 0.\n\n"
#define VERSION_INFO_STR \
 "Microsoft UUID Generator v1.01 " \
 VER_LEGALCOPYRIGHT_STR \
 "\n\n"
#define BAD_ARGS_STR "The arguments i and s are mutually exclusive.\n\n"
#define NO_ADDRESS_STR \
 "Cannot find the RPC End Point Mapper (RPCSS.EXE); Unable to allocate UUIDs.\n\n"
#define OUT_OF_MEMORY_STR \
 "Unable to allocate enough memory to create string.\n\n"
#define LOCAL_ONLY_STR \
 "Warning: Unable to determine your network address.  The UUID generated is\n" \
 "unique on this computer only.  It should not be used on another computer.\n"

//
// Function prototypes.
//

#ifdef NTENV
int __cdecl
#else // NTENV
int
#endif // NTENV
main(
    int argc,
    char **argv
    );

void Usage(void);

void ErrorUsageAndExit(void);

void NoErrorUsageAndExit(void);

//
// Global variables
//

FILE * OutputFile = stdout;

#ifdef NTENV
int __cdecl
#else // NTENV
int
#endif // NTENV
main(
    int argc,
    char **argv
    )
{
    int  ConditionFlags = 0;       // Holds conditions IDL_BIT_FLAG and
                                       // CSTRUCT_BIT_FLAG.
    char MyUuidString[255];        // The UUID string returned by
                                       // I_UuidStringGenerate.
    int  NumberOfUuids = 1;        // How many to make.
    int  i;                        // Current arg#.
    int Flag;                      // UUID Format requested.
    RPC_STATUS Result;
    int FirstTime = 1;
    
    //
    // Parse the command line.
    //

    for (i=1;argc-i;i++)
        {

        //
        // Make sure arg is in proper format.
        //

        if ( (argv[i][0] != '/') && (argv[i][0] != '-') )
            {
            fprintf(stderr, BAD_SWITCH_STR, argv[i]);
            ErrorUsageAndExit();
            }

        //
        // Which arg is it?
        //

        switch (argv[i][1])
            {
            case 'c':
            case 'C':
                ConditionFlags |= UPPER_CASE_UUIDS;
                break;
            case 'I':
            case 'i':
                ConditionFlags |= IDL_BIT_FLAG;
                break;

            case 'S':
            case 's':
                ConditionFlags |= CSTRUCT_BIT_FLAG;
                break;

            case 'O':
            case 'o':
                OutputFile = fopen(argv[i]+2, "wt");
                if (OutputFile == NULL)
                    {
                    fprintf(stderr,CANNOT_OPEN_STR, argv[i]+2);
                    exit(1);
                    }
                break;

            case 'N':
            case 'n':
                NumberOfUuids = atoi(argv[i]+2);
                if (NumberOfUuids <= 0)
                    {
                    fprintf(stderr, TOO_SMALL_STR, argv[i-1]);
                    ErrorUsageAndExit();
                    }
                break;

            case 'x':
            case 'X':
                ConditionFlags |= SEQUENTIAL_UUIDS;
                break;

            case 'V':
            case 'v':
                fprintf(OutputFile, VERSION_INFO_STR);
                exit(0);

            case 'H':
            case 'h':
            case '?':
                NoErrorUsageAndExit();

            default:
                fprintf(stderr, BAD_SWITCH_STR, argv[i]);
                ErrorUsageAndExit();

            } // switch
        } // for

    //
    // Fulfill the user's request
    //

    if ((ConditionFlags & IDL_BIT_FLAG) && (ConditionFlags & CSTRUCT_BIT_FLAG))
        {
        fprintf(stderr,BAD_ARGS_STR);
        ErrorUsageAndExit();
        }

    if (ConditionFlags & IDL_BIT_FLAG)
        {
        Flag = UUIDGEN_FORMAT_IDL;
        }
    else if (ConditionFlags & CSTRUCT_BIT_FLAG)
        {
        Flag = UUIDGEN_FORMAT_CSTRUCT;
        }
    else
        {
        Flag = UUIDGEN_FORMAT_PLAIN;
        }

    for (;NumberOfUuids;NumberOfUuids--)
        {
        Result = I_UuidStringGenerate(
            Flag,
            (ConditionFlags & SEQUENTIAL_UUIDS) != 0,
            (ConditionFlags & UPPER_CASE_UUIDS) != 0,
            MyUuidString,
            "INTERFACENAME"
            );

        ASSERT((Result == RPC_S_OK)
               || (Result == RPC_S_UUID_LOCAL_ONLY)
               || (Result == RPC_S_OUT_OF_MEMORY)
               || (Result == RPC_S_UUID_NO_ADDRESS));

        switch(Result)
            {
            case RPC_S_OUT_OF_MEMORY:
                fprintf(stderr,OUT_OF_MEMORY_STR);
                exit(1);

            case RPC_S_UUID_NO_ADDRESS:
                fprintf(stderr,NO_ADDRESS_STR);
                exit(1);

            case RPC_S_UUID_LOCAL_ONLY:
                if (FirstTime)
                    {
                    fprintf(stderr,LOCAL_ONLY_STR);
                    FirstTime = 0;
                    }

                // Fall through to the valid case.

            case RPC_S_OK:
                fprintf(
                    OutputFile,
                    MyUuidString
                    );
            } // end switch
        } // end for

    return(0);
}

void Usage(void)
{
    fprintf(OutputFile, VERSION_INFO_STR
                        "usage: uuidgen [-xisconvh?]\n"
                        "\tx - Generate sequential (V1) UUIDs\n"
                        "\ti - Output UUID in an IDL interface template\n"
                        "\ts - Output UUID as an initialized C struct\n"
                        "\tc - Output UUID in upper case\n"
                        "\to<filename> - redirect output to a file, specified immediately after o\n"
                        "\tn<number> - Number of UUIDs to generate, specified immediately after n\n"
                        "\tv - display version information about uuidgen\n"
                        "\th,? - Display command option summary\n"
            );
}

void ErrorUsageAndExit(void)
{
    OutputFile = stderr;
    Usage();
    exit(1);
}

void NoErrorUsageAndExit(void)
{
    Usage();
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpcutil\server.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    RpcServ.c

Abstract:

    This file contains commonly used server-side RPC functions,
    such as starting and stoping RPC servers.

Author:

    Dan Lafferty    danl    09-May-1991

Environment:

    User Mode - Win32

Revision History:

    09-May-1991     Danl
        Created

    03-July-1991    JimK
        Copied from a net-specific file.

    18-Feb-1992     Danl
        Added support for multiple endpoints & interfaces per server.

    10-Nov-1993     Danl
        Wait for RPC calls to complete before returning from
        RpcServerUnregisterIf.  Also, do a WaitServerListen after
        calling StopServerListen (when the last server shuts down).
        Now this is similar to RpcServer functions in netlib.

    29-Jun-1995     RichardW
        Read an alternative ACL from a key in the registry, if one exists.
        This ACL is used to protect the named pipe.

--*/

//
// INCLUDES
//

// These must be included first:
#include <nt.h>              // DbgPrint
#include <ntrtl.h>              // DbgPrint
#include <windef.h>             // win32 typedefs
#include <rpc.h>                // rpc prototypes
#include <ntrpcp.h>
#include <nturtl.h>             // needed for winbase.h
#include <winbase.h>            // LocalAlloc

// These may be included in any order:
#include <stdlib.h>      // for wcscpy wcscat
#include <tstr.h>       // WCSSIZE

#define     NT_PIPE_PREFIX_W        L"\\PIPE\\"
#define     NT_PIPE_SD_PREFIX_W     L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SecurePipeServers\\"

static
PWSTR   RpcpSecurablePipes[] = {
                L"eventlog"         // Eventlog server
                };

//
// GLOBALS
//

    static CRITICAL_SECTION RpcpCriticalSection;
    static DWORD            RpcpNumInstances;



DWORD
RpcpInitRpcServer(
    VOID
    )

/*++

Routine Description:

    This function initializes the critical section used to protect the
    global server handle and instance count.

Arguments:

    none

Return Value:

    none

--*/
{
    InitializeCriticalSection(&RpcpCriticalSection);
    RpcpNumInstances = 0;

    return(0);
}

#pragma warning(push)
#pragma warning(disable:4701)

NTSTATUS
RpcpReadSDFromRegistry(
    IN  LPWSTR                  InterfaceName,
    OUT PSECURITY_DESCRIPTOR *  pSDToUse)
/*++

Routine Description:

    This function checks the registry in the magic place to see if an extra
    ACL has been defined for the pipe being passed in.  If there is one, it
    is translated to a NP acl, then returned.  If there isn't one, or if
    something goes wrong, an NULL acl is returned.

Arguments:

    InterfaceName   name of the pipe to check for, e.g. winreg, etc.

    pSDToUse        returned a pointer to the security decriptor to use.

Return Value:

    STATUS_SUCCESS,
    STATUS_NO_MEMORY,
    Possible other errors from registry apis.


--*/
{
    HANDLE                  hKey;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UniString;
    PWSTR                   PipeKey;
    NTSTATUS                Status;
    PSECURITY_DESCRIPTOR    pSD;
    ULONG                   cbNeeded;
    ACL_SIZE_INFORMATION    AclSize;
    ULONG                   AceIndex;
    ACCESS_MASK             NewMask;
    PACCESS_ALLOWED_ACE     pAce;
    PACL                    pAcl;
    BOOLEAN                 DaclPresent;
    BOOLEAN                 DaclDefaulted;
    UNICODE_STRING          Interface;
    UNICODE_STRING          Allowed;
    ULONG                   i;
    BOOLEAN                 PipeNameOk;
    PSECURITY_DESCRIPTOR    pNewSD;
    PACL                    pNewAcl;

    *pSDToUse = NULL;

    RtlInitUnicodeString( &Interface, InterfaceName );

    PipeNameOk = FALSE;

    for ( i = 0 ; i < sizeof( RpcpSecurablePipes ) / sizeof(PWSTR) ; i++ )
    {
        RtlInitUnicodeString( &Allowed, RpcpSecurablePipes[i] );

        if ( RtlCompareUnicodeString( &Allowed, &Interface, TRUE ) == 0 )
        {
            PipeNameOk = TRUE;
            break;
        }
    }

    if ( PipeNameOk )
    {

        PipeKey = RtlAllocateHeap(RtlProcessHeap(), 0,
                        sizeof(NT_PIPE_SD_PREFIX_W) + WCSSIZE(InterfaceName) );

        if (!PipeKey)
        {
            return(STATUS_NO_MEMORY);
        }

        wcscpy(PipeKey, NT_PIPE_SD_PREFIX_W);
        wcscat(PipeKey, InterfaceName);

        RtlInitUnicodeString(&UniString, PipeKey);

        InitializeObjectAttributes( &ObjAttr,
                                    &UniString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL, NULL);

        Status = NtOpenKey( &hKey,
                            KEY_READ,
                            &ObjAttr);

        RtlFreeHeap(RtlProcessHeap(), 0, PipeKey);

    }
    else
    {
        //
        // This is not one of the interfaces that we allow to be secured
        // in this fashion.  Fake and error,
        //

        Status = STATUS_OBJECT_NAME_NOT_FOUND ;
    }

    //
    // In general, most times we won't find this key
    //

    if (!NT_SUCCESS(Status))
    {
        if ((Status == STATUS_OBJECT_NAME_NOT_FOUND) ||
            (Status == STATUS_OBJECT_PATH_NOT_FOUND) )
        {
            *pSDToUse = NULL;
            return(STATUS_SUCCESS);
        }

        return(Status);

    }

    //
    // Son of a gun, someone has established security for this pipe.
    //

    pSD = NULL;

    cbNeeded = 0;
    Status = NtQuerySecurityObject(
                    hKey,
                    DACL_SECURITY_INFORMATION,
                    NULL,
                    0,
                    &cbNeeded );

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        pSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbNeeded);
        if (pSD)
        {
            Status = NtQuerySecurityObject(
                        hKey,
                        DACL_SECURITY_INFORMATION,
                        pSD,
                        cbNeeded,
                        &cbNeeded );

            //
            // One way or the other, we are done with the key handle
            //

            NtClose(hKey);

            if (NT_SUCCESS(Status))
            {
                //
                // Now, the tricky part.  There is no 1-1 mapping of Key
                // permissions to Pipe permissions.  So, we do it here.
                // We walk the DACL, and examine each ACE.  We build a new
                // access mask for each ACE, and set the flags as follows:
                //
                //  if (KEY_READ) GENERIC_READ
                //  if (KEY_WRITE) GENERIC_WRITE
                //

                Status = RtlGetDaclSecurityDescriptor(
                                        pSD,
                                        &DaclPresent,
                                        &pAcl,
                                        &DaclDefaulted);


                //
                // If this failed, or there is no DACL present, then
                // we're in trouble.
                //

                if (!NT_SUCCESS(Status) || !DaclPresent)
                {
                    goto GetSDFromKey_BadAcl;
                }


                Status = RtlQueryInformationAcl(pAcl,
                                                &AclSize,
                                                sizeof(AclSize),
                                                AclSizeInformation);

                if (!NT_SUCCESS(Status))
                {
                    goto GetSDFromKey_BadAcl;
                }

                for (AceIndex = 0; AceIndex < AclSize.AceCount ; AceIndex++ )
                {
                    NewMask = 0;
                    Status = RtlGetAce( pAcl,
                                        AceIndex,
                                        & pAce);

                    //
                    // We don't care what kind of ACE it is, since we
                    // are just mapping the access types, and the access
                    // mask is always at a constant position.
                    //

                    if (NT_SUCCESS(Status))
                    {
                        if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) &&
                            (pAce->Header.AceType != ACCESS_DENIED_ACE_TYPE))
                        {
                            //
                            // Must be an audit or random ACE type.  Skip it.
                            //

                            continue;

                        }


                        if (pAce->Mask & KEY_READ)
                        {
                            NewMask |= GENERIC_READ;
                        }

                        if (pAce->Mask & KEY_WRITE)
                        {
                            NewMask |= GENERIC_WRITE;
                        }

                        pAce->Mask = NewMask;
                    }
                    else
                    {
                        //
                        // Panic:  Bad ACL?
                        //

                        goto GetSDFromKey_BadAcl;
                    }

                }

                //
                // BUGBUG:  RPC does not understand self-relative SDs, so
                // we have to turn this into an absolute for them to turn
                // back into a self relative.
                //

                pNewSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbNeeded);
                if (!pNewSD)
                {
                    goto GetSDFromKey_BadAcl;
                }

                InitializeSecurityDescriptor(   pNewSD,
                                                SECURITY_DESCRIPTOR_REVISION);

                pNewAcl = (PACL) (((PUCHAR) pNewSD) +
                                    sizeof(SECURITY_DESCRIPTOR) );

                RtlCopyMemory(pNewAcl, pAcl, AclSize.AclBytesInUse);

                SetSecurityDescriptorDacl(pNewSD, TRUE, pNewAcl, FALSE);

                RtlFreeHeap(RtlProcessHeap(), 0, pSD);

                *pSDToUse = pNewSD;
                return(Status);
            }
        }
        return(STATUS_NO_MEMORY);
    }
    else
    {
        //
        // Failed to read SD:
        //

        NtClose(hKey);


GetSDFromKey_BadAcl:

        //
        // Free the SD that we have allocated
        //

        if (pSD)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, pSD);
        }

        //
        // Key exists, but there is no security descriptor, or it is unreadable
        // for whatever reason.
        //

        pSD = RtlAllocateHeap(RtlProcessHeap(), 0,
                                sizeof(SECURITY_DESCRIPTOR) );
        if (pSD)
        {
            InitializeSecurityDescriptor( pSD,
                                          SECURITY_DESCRIPTOR_REVISION );

            if (SetSecurityDescriptorDacl (
                    pSD,
                    TRUE,                           // Dacl present
                    NULL,                           // NULL Dacl
                    FALSE                           // Not defaulted
                    ) )
            {
                *pSDToUse = pSD;
                return(STATUS_SUCCESS);
            }

        }
        return(STATUS_NO_MEMORY);

    }


}

#pragma warning(pop)


NTSTATUS
RpcpAddInterface(
    IN  LPWSTR                  InterfaceName,
    IN  RPC_IF_HANDLE           InterfaceSpecification
    )

/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIf()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    RPC_STATUS          RpcStatus;
    LPWSTR              Endpoint = NULL;

    BOOL                Bool;
    NTSTATUS            Status;

    // We need to concatenate \pipe\ to the front of the interface name.

    Endpoint = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(NT_PIPE_PREFIX_W) + WCSSIZE(InterfaceName));
    if (Endpoint == 0) {
       return(STATUS_NO_MEMORY);
    }
    wcscpy(Endpoint, NT_PIPE_PREFIX_W );
    wcscat(Endpoint,InterfaceName);

    //
    // Croft up a security descriptor that will grant everyone
    // all access to the object (basically, no security)
    //
    // We do this by putting in a NULL Dacl.
    //
    // BUGBUG: rpc should copy the security descriptor,
    // Since it currently doesn't, simply allocate it for now and
    // leave it around forever.
    //

    Status = RpcpReadSDFromRegistry(InterfaceName, &SecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
		ASSERT(Endpoint);
		LocalFree(Endpoint);
        return(Status);
    }

	// Ignore the second argument for now.

    RpcStatus = RpcServerUseProtseqEpW(L"ncacn_np", 10, Endpoint, SecurityDescriptor);

    // If RpcpStartRpcServer and then RpcpStopRpcServer have already
    // been called, the endpoint will have already been added but not
    // removed (because there is no way to do it).  If the endpoint is
    // already there, it is ok.

    if (   (RpcStatus != RPC_S_OK)
        && (RpcStatus != RPC_S_DUPLICATE_ENDPOINT)) {

#if DBG
        DbgPrint("RpcServerUseProtseqW failed! rpcstatus = %u\n",RpcStatus);
#endif
        goto CleanExit;
    }

    RpcStatus = RpcServerRegisterIf(InterfaceSpecification, 0, 0);

CleanExit:
    if ( Endpoint != NULL ) {
        LocalFree(Endpoint);
    }
    if ( SecurityDescriptor != NULL ) {
        LocalFree(SecurityDescriptor);
    }

    return( I_RpcMapWin32Status(RpcStatus) );
}


NTSTATUS
RpcpStartRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    )

/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIf()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    RPC_STATUS          RpcStatus;

    EnterCriticalSection(&RpcpCriticalSection);

    RpcStatus = RpcpAddInterface( InterfaceName,
                                  InterfaceSpecification );

    if ( RpcStatus != RPC_S_OK ) {
        LeaveCriticalSection(&RpcpCriticalSection);
        return( I_RpcMapWin32Status(RpcStatus) );
    }

    RpcpNumInstances++;

    if (RpcpNumInstances == 1) {


       // The first argument specifies the minimum number of threads to
       // be created to handle calls; the second argument specifies the
       // maximum number of concurrent calls allowed.  The last argument
       // indicates not to wait.

       RpcStatus = RpcServerListen(1,12345, 1);
       if ( RpcStatus == RPC_S_ALREADY_LISTENING ) {
           RpcStatus = RPC_S_OK;
           }
    }

    LeaveCriticalSection(&RpcpCriticalSection);
    return( I_RpcMapWin32Status(RpcStatus) );
}


NTSTATUS
RpcpDeleteInterface(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    )

/*++

Routine Description:

    Deletes the interface.  This is likely
    to be caused by an invalid handle.  If an attempt to add the same
    interface or address again, then an error will be generated at that
    time.

Arguments:

    InterfaceSpecification - A handle for the interface that is to be removed.

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIf(InterfaceSpecification, 0, 1);

    return( I_RpcMapWin32Status(RpcStatus) );
}


NTSTATUS
RpcpStopRpcServer(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    )

/*++

Routine Description:

    Deletes the interface.  This is likely
    to be caused by an invalid handle.  If an attempt to add the same
    interface or address again, then an error will be generated at that
    time.

Arguments:

    InterfaceSpecification - A handle for the interface that is to be removed.

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIf(InterfaceSpecification, 0, 1);
    EnterCriticalSection(&RpcpCriticalSection);

    RpcpNumInstances--;

    if (RpcpNumInstances == 0)
    {
        //
        // Return value needs to be from RpcServerUnregisterIf() to maintain
        // semantics, so the return values from these are ignored.
        //

        RpcMgmtStopServerListening(0);
        RpcMgmtWaitServerListen();
    }

    LeaveCriticalSection(&RpcpCriticalSection);

    return (I_RpcMapWin32Status(RpcStatus));
}


NTSTATUS
RpcpStopRpcServerEx(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    )

/*++

Routine Description:

    Deletes the interface and close all context handles associated with it.
    This can only be called on interfaces that use strict context handles
    (RPC will assert and return an error otherwise).

Arguments:

    InterfaceSpecification - A handle for the interface that is to be removed.

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
        RpcServerUnregisterIfEx.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIfEx(InterfaceSpecification, 0, 1);
    EnterCriticalSection(&RpcpCriticalSection);

    RpcpNumInstances--;

    if (RpcpNumInstances == 0)
    {
        //
        // Return value needs to be from RpcServerUnregisterIfEx() to
        // maintain semantics, so the return values from these are ignored.
        //

        RpcMgmtStopServerListening(0);
        RpcMgmtWaitServerListen();
    }

    LeaveCriticalSection(&RpcpCriticalSection);

    return (I_RpcMapWin32Status(RpcStatus));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpcutil\client.c ===
/*++

Copyright (c) 1990-92  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This file contains commonly used client-side RPC control functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    26-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) so linker doesn't get confused.
        Deleted tabs.
    03-July-1991    JimK
        Copied from LM specific file.
    27-Feb-1992 JohnRo
        Fixed heap trashing bug in RpcpBindRpc().

--*/

// These must be included first:
#include <nt.h>         // needed for NTSTATUS
#include <ntrtl.h>      // needed for nturtl.h
#include <nturtl.h>     // needed for windows.h
#include <windows.h>    // win32 typedefs
#include <rpc.h>        // rpc prototypes
#include <ntrpcp.h>

#include <stdlib.h>      // for wcscpy wcscat
#include <tstr.h>       // WCSSIZE


#define     NT_PIPE_PREFIX      TEXT("\\PIPE\\")
#define     NT_PIPE_PREFIX_W        L"\\PIPE\\"



NTSTATUS
RpcpBindRpc(
    IN  LPWSTR               ServerName,
    IN  LPWSTR               ServiceName,
    IN  LPWSTR               NetworkOptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )

/*++

Routine Description:

    Binds to the RPC server if possible.

Arguments:

    ServerName - Name of server to bind with.

    ServiceName - Name of service to bind with.

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    STATUS_SUCCESS - The binding has been successfully completed.

    STATUS_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    STATUS_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/

{
    NTSTATUS Status;
    RPC_STATUS        RpcStatus;
    LPWSTR            StringBinding;
    LPWSTR            Endpoint;
    WCHAR             ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD             bufLen;
    LPWSTR AllocatedServerName = NULL;
    LPWSTR UncServerName = NULL;

    *pBindingHandle = NULL;

    if ( ServerName != NULL ) {
        DWORD ServerNameLength = wcslen(ServerName);

        //
        // Canonicalize the server name
        //

        if ( ServerName[0] == L'\0' ) {
            ServerName = NULL;
            UncServerName = NULL;

        } else if ( ServerName[0] == L'\\' && ServerName[1] == L'\\' ) {
            UncServerName = ServerName;
            ServerName += 2;
            ServerNameLength -= 2;

            if ( ServerNameLength == 0 ) {
                Status = STATUS_INVALID_COMPUTER_NAME;
                goto Cleanup;
            }

        } else {
            AllocatedServerName = LocalAlloc( 0, (ServerNameLength+2+1) * sizeof(WCHAR) );

            if ( AllocatedServerName == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            AllocatedServerName[0] = L'\\';
            AllocatedServerName[1] = L'\\';
            RtlCopyMemory( &AllocatedServerName[2],
                           ServerName,
                           (ServerNameLength+1) * sizeof(WCHAR) );

            UncServerName = AllocatedServerName;
        }


        //
        // If the passed in computer name is the netbios name of this machine,
        //  drop the computer name so we can avoid the overhead of the redir/server/authentication.
        //

        if ( ServerName != NULL && ServerNameLength <= MAX_COMPUTERNAME_LENGTH ) {

            bufLen = MAX_COMPUTERNAME_LENGTH + 1;
            if (GetComputerNameW( ComputerName, &bufLen )) {
                if ( ServerNameLength == bufLen &&
                     _wcsnicmp( ComputerName, ServerName, ServerNameLength) == 0 ) {
                    ServerName = NULL;
                    UncServerName = NULL;
                }
            }

        }

        //
        // If the passed in computer name is the DNS host name of this machine,
        //  drop the computer name so we can avoid the overhead of the redir/server/authentication.
        //

        if ( ServerName != NULL ) {
            LPWSTR DnsHostName;

            //
            // Further canonicalize the ServerName.
            //

            if ( ServerName[ServerNameLength-1] == L'.' ) {
                ServerNameLength -= 1;
            }

            DnsHostName = LocalAlloc( 0, (MAX_PATH+1) * sizeof(WCHAR));

            if ( DnsHostName == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            bufLen = MAX_PATH + 1;
            if ( GetComputerNameExW(
                    ComputerNameDnsFullyQualified,
                    DnsHostName,
                    &bufLen ) ) {

                if ( ServerNameLength == bufLen &&
                     _wcsnicmp( DnsHostName, ServerName, ServerNameLength) == 0 ) {
                    ServerName = NULL;
                    UncServerName = NULL;
                }
            }

            LocalFree( DnsHostName );
        }


    }

    // We need to concatenate \pipe\ to the front of the service
    // name.

    Endpoint = (LPWSTR)LocalAlloc(
                    0,
                    sizeof(NT_PIPE_PREFIX_W) + WCSSIZE(ServiceName));
    if (Endpoint == 0) {
       Status = STATUS_NO_MEMORY;
       goto Cleanup;
    }
    wcscpy(Endpoint,NT_PIPE_PREFIX_W);
    wcscat(Endpoint,ServiceName);

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", UncServerName,
                    Endpoint, NetworkOptions, &StringBinding);
    LocalFree(Endpoint);

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // Get an actual binding handle.
    //

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, pBindingHandle);
    RpcStringFreeW(&StringBinding);
    if ( RpcStatus != RPC_S_OK ) {
        *pBindingHandle = NULL;
        if ( RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT ||
             RpcStatus == RPC_S_INVALID_NET_ADDR ) {

            Status = STATUS_INVALID_COMPUTER_NAME;
        } else {
            Status = STATUS_NO_MEMORY;
        }
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:
    if ( AllocatedServerName != NULL ) {
        LocalFree( AllocatedServerName );
    }
    return Status;
}


NTSTATUS
RpcpUnbindRpc(
    IN RPC_BINDING_HANDLE  BindingHandle
    )

/*++

Routine Description:

    Unbinds from the RPC interface.
    If we decide to cache bindings, this routine will do something more
    interesting.

Arguments:

    BindingHandle - This points to the binding handle that is to be closed.


Return Value:


    STATUS_SUCCESS - the unbinding was successful.

--*/
{
    RPC_STATUS       RpcStatus;

    if (BindingHandle != NULL) {
        RpcStatus = RpcBindingFree(&BindingHandle);
//        ASSERT(RpcStatus == RPC_S_OK);
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpcutil\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991    JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.
    03-July-1991   JimK
        Moved to a common directory so services available to more than just
        LM code.
    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)
        Also check alignment of allocated data.

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>          // needed for nturtl.h
#include <nturtl.h>         // needed for windows.h
#include <windows.h>        // win32 typedefs
#include <rpc.h>            // rpc prototypes

// These may be included in any order:
#include <align.h>              // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <ntrpcp.h>            // MIDL_user_allocate(), MIDL_user_free().

#include <winbase.h>            // LocalAlloc


#define LOCAL_ALLOCATION_FLAGS  LMEM_ZEROINIT


PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    LPVOID NewPointer;

    NewPointer = LocalAlloc(
            LOCAL_ALLOCATION_FLAGS,
            NumBytes);

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_allocate



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    ASSERT( POINTER_IS_ALIGNED( MemPointer, ALIGN_WORST) );
    (void) LocalFree(MemPointer);

} // MIDL_user_free

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    )
{
    LPVOID NewPointer;  // may be NULL.

    ASSERT( POINTER_IS_ALIGNED( OldPointer, ALIGN_WORST) );


    // Special cases: something into nothing, or nothing into something.
    if (OldPointer == NULL) {

        NewPointer = LocalAlloc(
                LOCAL_ALLOCATION_FLAGS,
                NewByteCount);

    } else if (NewByteCount == 0) {

        (void) LocalFree( OldPointer );
        NewPointer = NULL;

    } else {  // must be realloc of something to something else.

        HANDLE hOldMem;
        HANDLE hNewMem;                     // handle for new (may = old handle)

        hOldMem = LocalHandle( (LPSTR) OldPointer);
        ASSERT(hOldMem != NULL);

        hNewMem = LocalReAlloc(
                hOldMem,                        // old handle
                NewByteCount,                   // new size in bytes
                LOCAL_ALLOCATION_FLAGS |        // flags
                    LMEM_MOVEABLE);             //  (motion okay)
        if (hNewMem == NULL) {
            // BUGBUG: call GetLastError, could be out of memory or error.
            return (NULL);
        }
        NewPointer = (LPVOID) hNewMem;

    } // must be realloc of something to something else

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_reallocate


unsigned long
MIDL_user_size(
    IN void * Pointer
    )
{
    DWORD ByteCount;
    HANDLE hMemory;

    ASSERT( Pointer != NULL );
    ASSERT( POINTER_IS_ALIGNED( Pointer, ALIGN_WORST ) );

    hMemory = LocalHandle( (LPSTR) Pointer );
    ASSERT( hMemory != NULL );

    ByteCount = (DWORD)LocalSize( hMemory );

    ASSERT( ByteCount > 0 );

    return (ByteCount);

} // MIDL_user_size

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\midlallc.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <rpc.h>
#include <windows.h>



void __RPC_USER MIDL_user_free( void __RPC_FAR *pv ) 
{ 
    LocalFree(pv); 
}


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t s) 
{ 
    return (void __RPC_FAR *) LocalAlloc(LMEM_FIXED, s); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\fileops.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       fileops.cxx
//
//  Contents:   OBJID and file operations
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"
#include "mountmgr.h"



//+-------------------------------------------------------------------
//
//  Function:   ConvertToNtPath, public
//
//  Synopsis:   Convert the path in the buffer to an Nt style path, in the
//              other buffer.
//
//  Arguments:  [pwszVolumePath] -- In. Buffer containing Dos style path.
//              [pwszNtPath]  -- Out. Buffer for new path.
//              [cwcBuf]      -- In. Size of buffer in wide chars.
//
//  Returns:    Return value is length in characters (not including nul)
//              of converted path.  Zero if not completely converted.
//
//--------------------------------------------------------------------

unsigned
ConvertToNtPath(const TCHAR *ptszVolumePath, WCHAR *pwszNtPath, ULONG cwcBuf)
{
    unsigned i=12;  // for \DosDevices\   .
    WCHAR *pwszWrite = pwszNtPath;
    ULONG cwcLeft = cwcBuf;
    BOOL  fDone = FALSE;
    unsigned ret;

    if (ptszVolumePath[0] == TEXT('\\') && ptszVolumePath[1] == TEXT('\\'))
    {
        i+=3;
        ptszVolumePath++;

        // i = 15
        // ptszVolumePath -----\ .
        //                     |
        //                     v
        //                    \\billmo2\rootd
        //
    }

    if (cwcLeft > i)
    {
        memcpy(pwszWrite, L"\\DosDevices\\UNC", i*sizeof(WCHAR));

        pwszWrite += i;
        cwcLeft   -= i;

        while (cwcLeft)
        {
            *pwszWrite = (WCHAR) *ptszVolumePath;
            cwcLeft --;

            if (*ptszVolumePath == 0)
            {
                // we just copied a null
                fDone = TRUE;
                break;
            }
            else
            {
                ptszVolumePath++;
                pwszWrite++;
            }
        }
    }

    ret = (fDone ? (unsigned)(pwszWrite - pwszNtPath) : 0);

    return(ret);
}



//+----------------------------------------------------------------------------
//
//  IsLocalObjectVolume
//
//  Determine if the specified volume (specified as a mount manager volume
//  name) is capable of object IDs (i.e. NTFS5).  The tracking service
//  currently only supports fixed volumes, so this routine really only
//  returns true for fixed NTFS5 volumes.
//
//  The input is a "volume name", as opposed to a volume device name
//  (i.e. it has a trailing slash).  E.g.:
//
//       \\?\Volume{8baec120-078b-11d2-824b-000000000000}\ 
//
//  The proper way to implement this routine is to open the filesystem
//  on this device, query for its FS attributes, and check for the
//  supports-object-ids bit.  But the ugly side-effect of this is that
//  we end up opening every volume on the system during system bootup,
//  including the floppies.  So as a workaround, we look up the device
//  in the object directory first, and only bother to check for the
//  bit on "\Device\HarddiskVolume" type devices.
//
//+----------------------------------------------------------------------------

const TCHAR *s_tszHarddiskDevicePrefix = TEXT("\\Device\\HarddiskVolume");

BOOL
IsLocalObjectVolume( const TCHAR *ptszVolumeName )
{


    TCHAR tszTargetSymLink[ MAX_PATH ];
    TCHAR tszVolumeDeviceName[ MAX_PATH + 1 ];
    ULONG cchVolumeName;
    DWORD dwFsFlags = 0;

    // Validate the volume name prefix.
    //TrkAssert( !_tcsnicmp( TEXT("\\\\?\\"), ptszVolumeName, 4 ) );

    /*
    // For the QueryDosDevice call, we need to strip the "\\?\"
    // from the beginning of the name.

    cchVolumeName = _tcslen( &ptszVolumeName[4] );

    memcpy( tszVolumeDeviceName, &ptszVolumeName[4],
            cchVolumeName * sizeof(TCHAR) );

    // Also for the QueryDosDevice call, we nee to strip the
    // whack from the end of the name.

    TrkAssert( TEXT('\\') == tszVolumeDeviceName[cchVolumeName-1] );
    tszVolumeDeviceName[ cchVolumeName - 1 ] = TEXT('\0');


    // Query for this device's symlink.

    if( !QueryDosDevice( tszVolumeDeviceName,
                         tszTargetSymLink,
                         sizeof(tszTargetSymLink)/sizeof(TCHAR) ))
    {
        TrkLog(( TRKDBG_MISC,
                 TEXT("Couldn't query %s for symlink in obj dir (%lu)"),
                 tszVolumeDeviceName, GetLastError() ));
        return FALSE;
    }


    TrkLog(( TRKDBG_MISC,
             TEXT("Volume %s is %s"),
             ptszVolumeName, tszTargetSymLink ));

    // Is this a harddisk?  I.e., does the symlink have the \Device\HarddiskVolume
    // prefix?

    if( _tcsnicmp( tszTargetSymLink,
                   s_tszHarddiskDevicePrefix,
                   _tcslen(s_tszHarddiskDevicePrefix) ))
    {
        // No, assume therefore that it's not an object (NTFS5) volume.
        return FALSE;
    }
    

    // Otherwise, is it a fixed harddisk?
    else if( DRIVE_FIXED != GetDriveType(ptszVolumeName) )
        // No - we don't currently handle removeable media.
        return FALSE;
    */

    if( DRIVE_FIXED != GetDriveType(ptszVolumeName) )
        return FALSE;

    // Finally, check to see if it supports object IDs
    if( GetVolumeInformation(ptszVolumeName,
                             NULL,
                             0,
                             NULL,
                             NULL,
                             &dwFsFlags,
                             NULL,
                             0 )
         &&
         (dwFsFlags & FILE_SUPPORTS_OBJECT_IDS) )
    {
        // Yes, it's a fixed harddisk that supports OIDs
        return TRUE;
    }
    else
        // It's a fixed harddisk, but it doesn't supports
        // OIDs (it's probably FAT).
        return FALSE;
}


#if 0
BOOL
IsLocalObjectVolume( const TCHAR *ptszVolumeDeviceName )
{
    BOOL fObjectIdCapable = FALSE;
    TCHAR tszVol[4];
    TCHAR tszRootOfVolume[MAX_PATH+1];
    DWORD dw;
    DWORD dwFsFlags;
    UINT DriveType;

    _tcscpy( tszRootOfVolume, ptszVolumeDeviceName );
    _tcscat( tszRootOfVolume, TEXT("\\") );

    // Get the drive type

    DriveType = GetDriveType(tszRootOfVolume);

    // Return TRUE if the drive type is fixed, and if
    // the filesystem attribute bit is set that indicates
    // that object IDs are supported.

    return ( ( DRIVE_FIXED == DriveType
               /*|| DRIVE_REMOVABLE == DriveType*/
             )
             &&
             GetVolumeInformation(tszRootOfVolume,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &dwFsFlags,
                                 NULL,
                                 0 )
             &&
             (dwFsFlags & FILE_SUPPORTS_OBJECT_IDS) );
}
#endif

//+-------------------------------------------------------------------
//
//  Function:   MapLocalPathToUNC
//
//  Synopsis:   Convert a volume-relative path to a UNC path.
//              Since there could be multiple UNC paths which cover
//              this local path, that which provides greatest
//              coverage & access will be returns (e.g., "C:\"
//              covers more than "C:\Docs".
//
//  Arguments:  [tszLocalPath] (in)
//                  A local path, including the drive letter.
//              [tszUNC] (out)
//                  An equivalent UNC path which provides the
//                  greatest access.
//
//  Returns:    [HRESULT]
//
//  Exceptions: None
//
//--------------------------------------------------------------------

HRESULT
MapLocalPathToUNC( RPC_BINDING_HANDLE IDL_handle,
                   const TCHAR *ptszLocalPath,
                   TCHAR *ptszUNC )
{
    //  -----
    //  Locals
    //  ------

    HRESULT hr = S_OK;  // Return value

    CShareEnumerator cShareEnum;

    ULONG ulBestMerit;
    TCHAR tszBestShare[ MAX_PATH + 1 ];
    TCHAR tszBestPath[ MAX_PATH + 1 ];
    ULONG cchBestPath = 0;


    //  ----------
    //  Initialize
    //  ----------
    __try
    {
        // Open an enumeration of the disk shares on this machine.
        // If we early-exit due to an exception, it will clean itself up.
        // NOTE:  The ptszLocalPath is only provided until we can fix
        // GetAccessLevel so that it doesn't have to do opens.

        cShareEnum.Initialize( IDL_handle );

        ulBestMerit = cShareEnum.GetMinimumMerit() - 1;

        //  --------------------
        //  Enumerate the shares
        //  --------------------

        while( cShareEnum.Next() )
        {
            // Does this share cover the local path?

            if( cShareEnum.CoversDrivePath( ptszLocalPath ))
            {
                // Is this a better share than anything we've seen so far?

                if( cShareEnum.GetMerit() > ulBestMerit )
                {
                    // We have a new best share.  We'll hang on to both
                    // the share and it's path.

                    _tcscpy( tszBestShare, cShareEnum.GetShareName() );
                    _tcscpy( tszBestPath, cShareEnum.GetSharePath() );

                    ulBestMerit = cShareEnum.GetMerit();
                    cchBestPath = cShareEnum.QueryCCHSharePath();
                }
            }   // if( cenumShares.QueryCCHSharePath() < cchBestPath )
        }   // while( cenumShares.Next() )


        // Did we find a share which encompasses the file?

        if( 0 == cchBestPath )
        {
            hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            goto Exit;
        }

        //  -------------------
        //  Create the UNC path
        //  -------------------

        _tcscpy( ptszUNC, cShareEnum.GetMachineName() );
        _tcscat( ptszUNC, TEXT("\\") );
        _tcscat( ptszUNC, tszBestShare );
        if ( ptszLocalPath[ cchBestPath ] != TEXT('\\') )
            _tcscat( ptszUNC, TEXT("\\") );
        _tcscat( ptszUNC, &ptszLocalPath[ cchBestPath ] );

        hr = S_OK;
    }   // __try

    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("MapLocalPathToUNC returned hr=%08x"), hr ));
    }

    return( hr );

}   // MapLocalPathToUNC



//+-------------------------------------------------------------------
//
//  Function:   OpenVolume, public
//
//  [ptszVolumeDeviceName] is a Win32 name for a volume in the NT
//  namespace, *without* the trailing whack.  E.g.
//
//      \\.\A:
//
//  if you append a whack on the end of this, it opens the root
//  of the volume, not the volume itself.
//
//--------------------------------------------------------------------

NTSTATUS
OpenVolume( const TCHAR *ptszVolumeDeviceName, HANDLE * phVolume )
{
    NTSTATUS            status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    IO_STATUS_BLOCK Iosb;
    HANDLE hDirect = NULL;

    // First, open the file in direct mode (by only opening it for
    // file_read_attributes).  This will open the volume but not cause
    // any filesystem to be loaded.  This was done for the following scenario:
    // A volume gets dismounted and goes offline for some reason.  Trkwks
    // gets the dismount notification and closes its handles.  Something
    // attempt to open the volume, and IO loads the RAW filesystem (if no other
    // filesystem can be loaded, IO always loads the rawfs).  This causes a
    // mount notification.  Trkwks gets this mount notification and
    // tries to reopen its handles.  It can open the volume handle, but it's
    // just to the rawfs.  It tries to open the oid index, but IO returns an
    // invalid parameter error.  Trkwks then closes all of its handles again,
    // including the volume handle.  When all handles are closed on rawfs in this
    // way, it automatically dismounts (without sending a dismount notification).
    // The problem is, when trkwks opened the volume handle, it mounted the 
    // volume (rawfs) and caused a new mount notification, which it now receives
    // and tries to open its handles again.  In this way trkwks goes into an
    // infinite loop.
    //
    // The solution is to open the volume direct, and see if it's really mounted.
    // If not, don't try to open the volume.

    status = TrkCreateFile(
                ptszVolumeDeviceName,
                FILE_READ_ATTRIBUTES,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                &hDirect );

    if( !NT_SUCCESS(status) ) goto Exit;
    

    // Check for the current mount status.

    status = NtQueryVolumeInformationFile(
                hDirect,
                &Iosb,
                &DeviceInfo,
                sizeof(DeviceInfo),
                FileFsDeviceInformation );

    NtClose( hDirect );
    if( !NT_SUCCESS(status) ) goto Exit;

    if( !(FILE_DEVICE_IS_MOUNTED & DeviceInfo.Characteristics) )
    {
        // This volume isn't currently mounted, and we don't want to be
        // the ones to mount it.

        TrkLog(( TRKDBG_WARNING, TEXT("Attempted to open dismounted volume (%s)"),
                 ptszVolumeDeviceName ));
        status = STATUS_VOLUME_DISMOUNTED;
        goto Exit;
    }

    // The filesystem is already mounted, so it's OK for us to
    // open our handle.

    status = TrkCreateFile(
                ptszVolumeDeviceName,
                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                phVolume );

Exit:

    TrkAssert(NT_SUCCESS(status) || *phVolume == NULL);
    return(status);
}




//+----------------------------------------------------------------------------
//
//  Function:   CheckVolumeWriteProtection
//
//  Check the filesystem attributes on a volume to see if it's write-
//  protected.
//
//+----------------------------------------------------------------------------

NTSTATUS
CheckVolumeWriteProtection( const TCHAR *ptszVolumeDeviceName,
                            BOOL *pfWriteProtected )
{
    NTSTATUS status;
    HANDLE hVolume = NULL;
    IO_STATUS_BLOCK Iosb;
    FILE_FS_ATTRIBUTE_INFORMATION FsAttrs;

    status = OpenVolume( ptszVolumeDeviceName, &hVolume );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't open volume - 0x%08x (%s)"),
                 status, ptszVolumeDeviceName ));
        goto Exit;
    }

    status = NtQueryVolumeInformationFile(
                hVolume,
                &Iosb,
                &FsAttrs,
                sizeof(FsAttrs),
                FileFsAttributeInformation );
    if( !NT_SUCCESS(status) && STATUS_BUFFER_OVERFLOW != status)
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't query fs attrs - 0x%08x (%s)"),
                 status, ptszVolumeDeviceName ));
        goto Exit;
    }

    if( FILE_READ_ONLY_VOLUME & FsAttrs.FileSystemAttributes )
        *pfWriteProtected = TRUE;
    else
        *pfWriteProtected = FALSE;

    status = STATUS_SUCCESS;

Exit:

    if( NULL != hVolume )
        NtClose( hVolume );

    return status;

}


//+-------------------------------------------------------------------
//
//  Function:   MapVolumeDeviceNameToIndex
//
//  Map a volume device name, as defined by the mount manager, to a
//  zero-relative index, where 0 represents 'A:'.  A "volume device name"
//  is e.g.
//
//      \\?\Volume{96765fc3-9c72-11d1-b93d-000000000000}
//
//  a "volume name" is the volume device name post-pended with a
//  whack (it is in this form that the mount manager returns the name).
//
//+-------------------------------------------------------------------

/*
LONG
MapVolumeDeviceNameToIndex( TCHAR *ptszVolumeDeviceName )
{
    // BUGBUG:  Rewrite this to use IOCTL_MOUNTMGR_QUERY_POINTS

    TCHAR tszVolumeNameOfCaller[ CCH_MAX_VOLUME_NAME + 1 ];
    TCHAR tszVolumeNameForRoot[ CCH_MAX_VOLUME_NAME + 1 ];
    TCHAR tszRoot[] = TEXT("*:\\");

    // Convert the caller's volume name to a volume device name.

    _tcscpy( tszVolumeNameOfCaller, ptszVolumeDeviceName );
    _tcscat( tszVolumeNameOfCaller, TEXT("\\") );


    // Loop through all the possible drive letters, trying to find the
    // caller's volume name.

    for( LONG iVol = 0; iVol < NUM_VOLUMES; iVol++ )
    {
        tszRoot[0] = TEXT('A') + iVol;

        if( GetVolumeNameForVolumeMountPoint( tszRoot, tszVolumeNameForRoot, sizeof(tszVolumeNameForRoot) ))
        {
            // We have a real volume with a name.  See if it's the name we seek.
            if( 0 == _tcscmp( tszVolumeNameForRoot, tszVolumeNameOfCaller ))
                return( iVol );
        }

    }


    return( -1 );

}
*/

LONG
MapVolumeDeviceNameToIndex( TCHAR *ptszVolumeDeviceName )
{
    HANDLE                  hMountManager = INVALID_HANDLE_VALUE;
    BYTE                    MountPointBuffer[ sizeof(MOUNTMGR_MOUNT_POINT) + MAX_PATH ];
    PMOUNTMGR_MOUNT_POINT   pMountPoint = (PMOUNTMGR_MOUNT_POINT) MountPointBuffer;
    BYTE                    MountPointsBuffer[ MAX_PATH ];
    PMOUNTMGR_MOUNT_POINTS  pMountPoints = (PMOUNTMGR_MOUNT_POINTS) MountPointsBuffer;
    BOOL                    fQuerySuccessful = FALSE;
    ULONG                   cbMountPoints = 0;
    ULONG                   cbVolumeDeviceName;
    LONG                    iVol = -1;

    __try
    {
        // Open the mount manager.

        hMountManager = CreateFileW( MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                     INVALID_HANDLE_VALUE );
        if( INVALID_HANDLE_VALUE == hMountManager )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open MountManager") ));
            TrkRaiseLastError();
        }

        // Initialize the input (pMountPoint)

        pMountPoint = (PMOUNTMGR_MOUNT_POINT) MountPointBuffer;
        memset(pMountPoint, 0, sizeof(MountPointBuffer) );

        cbVolumeDeviceName = sizeof(TCHAR) * _tcslen(ptszVolumeDeviceName);

        // Load the name of the device for which we wish to query.  We convert
        // this from Win32 "\\?\" form to NT "\??\" form.

        pMountPoint->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
        pMountPoint->DeviceNameLength = cbVolumeDeviceName;

        _tcscpy( (TCHAR*)( MountPointBuffer + pMountPoint->DeviceNameOffset ),
                 TEXT("\\??") );
        _tcscat( (TCHAR*)( MountPointBuffer + pMountPoint->DeviceNameOffset ),
                 &ptszVolumeDeviceName[3] );


        // Query the mount manager for info on this device.

        ULONG cQueryAttempts = 0; // Guarantee no infinite loop.
        fQuerySuccessful = FALSE;
        cbMountPoints = sizeof(MountPointsBuffer);

        while( !fQuerySuccessful )
        {
            // Check for an infinite loop.
            if( cQueryAttempts > 100 )
            {
                TrkLog(( TRKDBG_ERROR,
                         TEXT("Failed IOCTL_MOUNTMGR_QUERY_POINTS (%lu, loop detect)"), GetLastError() ));
                TrkRaiseLastError();
            }

            // Query the mount manager

            fQuerySuccessful = DeviceIoControl( hMountManager,
                                                IOCTL_MOUNTMGR_QUERY_POINTS,
                                                pMountPoint,
                                                sizeof(MountPointBuffer),
                                                pMountPoints,
                                                cbMountPoints,
                                                &cbMountPoints,
                                                NULL);

            // Did it work?
            if( fQuerySuccessful )
                // Yes, we got the info.
                break;

            // Otherwise, do we need a bigger out-buf?

            else if( ERROR_MORE_DATA == GetLastError() )
            {
                // Yes, the size of the necessary out-buf is at
                // the beginning of the out-buf we provided.

                cbMountPoints = pMountPoints->Size;

                // The initial guess buffer is on the stack, not heap.

                if( (PMOUNTMGR_MOUNT_POINTS) MountPointsBuffer != pMountPoints )
                    delete [] pMountPoints;

                pMountPoints = (PMOUNTMGR_MOUNT_POINTS) new BYTE[ cbMountPoints ];
                if( NULL == pMountPoints )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc pMountPoints") ));
                    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
                }
            }

            // Of it's not a more-data error, then there's nothing more we can do.
            else
                break;

        }   // while( !fQuerySuccessful )

        // Raise if the query failed.

        if( !fQuerySuccessful )
        {
            TrkLog(( TRKDBG_WARNING,
                     TEXT("Failed IOCTL_MOUNTMGR_QUERY_POINTS (%lu)"), GetLastError() ));
            TrkRaiseLastError();
        }
                        

        // Loop through the returned mount points.  There should be 2: one of
        // the form "\??\Volume{8baec120-078b-11d2-824b-000000000000}",
        // and one of the form "\DosDevices\C:" (for the C drive).

        static const WCHAR wszSymLinkPrefix[] = { L"\\DosDevices\\" };
        ULONG cchSymLinkPrefix = sizeof(wszSymLinkPrefix)/sizeof(WCHAR) - 1;

        for( int i = 0; i < pMountPoints->NumberOfMountPoints; ++i )
        {
            PMOUNTMGR_MOUNT_POINT pOutPoint = &pMountPoints->MountPoints[i];
            WCHAR wc;
            const WCHAR *pwszSymLinkName
                = (PWCHAR)( (BYTE*)pMountPoints + pOutPoint->SymbolicLinkNameOffset );

            if( pOutPoint->SymbolicLinkNameLength/sizeof(WCHAR) >= 14
                &&
                0 == wcsncmp( pwszSymLinkName, wszSymLinkPrefix, cchSymLinkPrefix )
                &&
                pOutPoint->UniqueIdLength )

            {
                wc = pwszSymLinkName[ cchSymLinkPrefix ];

                if( TEXT('a') <= wc && wc <= TEXT('z') )
                {
                    iVol = wc - TEXT('a');
                    break;
                }
                else if( TEXT('A') <= wc && wc <= TEXT('Z') )
                {
                    iVol = wc - TEXT('A');
                    break;
                }

            }
        }


    }
    __finally
    {
        if( INVALID_HANDLE_VALUE != hMountManager )
            CloseHandle( hMountManager );

        if( (PMOUNTMGR_MOUNT_POINTS) MountPointsBuffer != pMountPoints
            &&
            NULL != pMountPoints )
        {
            delete [] pMountPoints;
        }

    }

    return iVol;
}



//+----------------------------------------------------------------------------
//
//  IsSystemVolumeInformation
//
//  Is the given volume-relative path under the "System Volume Information"
//  directory?
//
//  Note:  This is hard-coded for now, but will be replaced by a forthcoming
//  Rtl export.
//
//+----------------------------------------------------------------------------

BOOL
IsSystemVolumeInformation( const TCHAR *ptszPath )
{
    return 0 == _wcsnicmp( s_tszSystemVolumeInformation,
                           ptszPath,
                           wcslen(s_tszSystemVolumeInformation)/sizeof(WCHAR) );
}




//+-------------------------------------------------------------------
//
//  OpenFileById
//
//  Given an NTFS5 object ID, open the file and returns its handle.
//
//--------------------------------------------------------------------

NTSTATUS
OpenFileById( const TCHAR  *ptszVolumeDeviceName,
              const CObjId  &oid,
              ACCESS_MASK   AccessMask,
              ULONG         ShareAccess,
              ULONG         AdditionalCreateOptions,
              HANDLE        *ph)
{

    NTSTATUS    status;


    // A buffer for the id-based path.  This path is the volume's
    // path followed by the 16 byte object ID

    TCHAR tszPath[ MAX_PATH + 1 ] = { TEXT('\0') }; // Init to prevent prefix error.

    // Parameters for NtCreateFile
    OBJECT_ATTRIBUTES   ObjectAttr;
    IO_STATUS_BLOCK     IoStatus;

    UNICODE_STRING      uPath;
    PVOID               pFreeBuffer = NULL;


    // Compose a buffer with a Win32-style name with a dummy value where
    // the object ID will go (use "12345678" for now).  It's Win32-style
    // in that we will pass it to RtlDosPathNameToNtPathName below.

    TrkAssert( NULL != ptszVolumeDeviceName );
    _tcscpy( tszPath, ptszVolumeDeviceName );
    _tcscat( tszPath, TEXT("\\") );
    _tcscat( tszPath, TEXT("12345678") );

    // Convert to the NT path to this volume

    if( !RtlDosPathNameToNtPathName_U( tszPath, &uPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }
    pFreeBuffer = uPath.Buffer;

    // Put in the real object ID in place of the "12345678"

    TrkAssert( oid.Size() == 16 );
    oid.SerializeRaw( reinterpret_cast<BYTE*>(&uPath.Buffer[ (uPath.Length-oid.Size()) / sizeof(uPath.Buffer[0]) ]) );


    // And open the file

    InitializeObjectAttributes( &ObjectAttr,              // Structure
                                &uPath,                   // Name (identifier)
                                OBJ_CASE_INSENSITIVE,     // Attributes
                                0,                        // Root
                                0 );                      // Security


    status =   NtCreateFile( ph,
                             AccessMask,
                             &ObjectAttr, &IoStatus,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             ShareAccess,
                             FILE_OPEN,
                             FILE_OPEN_BY_FILE_ID | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT
                                | AdditionalCreateOptions,
                             NULL,
                             0 );
    if( !NT_SUCCESS(status) )
    {
        *ph = NULL;
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND )
    {
        TrkLog(( TRKDBG_MISC, TEXT("OpenFileById returned status=%08X"), status ));
    }

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );

    return( status );

}   // OpenFileById



//+----------------------------------------------------------------------
//
//  Function:   SetVolId
//
//  Synopsis:   Set the volume ID on a local volume.
//
//  Returns:    NTSTATUS
//
//  Note:       Setting the volid (and changing a volume's lable) triggers
//              a GUID_IO_VOLUME_CHANGE PNP device event.
//
//+----------------------------------------------------------------------------

NTSTATUS
SetVolId( const TCHAR *ptszVolumeDeviceName, const CVolumeId &volid )
{
    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING  usPath;
    PVOID pFreeBuffer = NULL;

    HANDLE hVol = NULL;
    FILE_FS_OBJECTID_INFORMATION file_fs_objectid_information;

    OBJECT_ATTRIBUTES ObjectAttr;
    IO_STATUS_BLOCK IoStatus;

    EnableRestorePrivilege();

    // Generate the NT path name to this volume.  The VolumeDeviceName has
    // no trailing whack, so we'll be opening the volume, not the root dir of
    // the volume.

    if( !RtlDosPathNameToNtPathName_U( ptszVolumeDeviceName, &usPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }
    pFreeBuffer = usPath.Buffer;

    // Fill in an ObjectAttributes for the NtCreateFile request

    InitializeObjectAttributes( &ObjectAttr,              // Structure
                                &usPath,                  // Name (identifier)
                                OBJ_CASE_INSENSITIVE,     // Attributes
                                0,                        // Root
                                0 );                      // Security

    // Open the volume.
    // You wouldn't think that FILE_SHARE_WRITE would be necessary, but
    // without it we encounter a STATUS_UNABLE_TO_DELETE_SECTION error.
    // Also, we must use NtOpenFile; if we use NtCreateFile(...,FILE_OPEN,...),
    // we get a STATUS_ACCESS_DENIED error on the NtSetVolumeInformationFile
    // call.

    status =   NtOpenFile( &hVol,
                           SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                           &ObjectAttr, &IoStatus,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_SYNCHRONOUS_IO_NONALERT
                           );


    if( !NT_SUCCESS(status) )
    {
        hVol = NULL;
        TrkLog(( TRKDBG_ERROR, TEXT("SetVolId couldn't open the volume %s (status=%08x)"),
                 ptszVolumeDeviceName, status ));
        goto Exit;
    }

    // Set the Volume ID

    file_fs_objectid_information = volid;

    status = NtSetVolumeInformationFile( hVol, &IoStatus,
                                         &file_fs_objectid_information,
                                         sizeof(file_fs_objectid_information),
                                         FileFsObjectIdInformation );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("SetVolId couldn't set volume ID on volume %s (status=%08x)"),
                 ptszVolumeDeviceName, status ));
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hVol )
        NtClose( hVol );

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );

    return( status );
}





//+----------------------------------------------------------------------------
//
//  Function:   TrkCreateFile
//
//  Synopsis:   Creates a file using NtCreateFile.
//
//  Arguments:  [pwszCompleteDosPath] (in)
//                  The path to open, in 'dos' format as opposed to
//                  NT format (e.g. "\\m\s\f" rather than "\DosDevices\..."
//              [AccessMask] (in)
//                  Required access.  SYNCRHONIZE is requested automatically.
//              [Attributes] (in)
//              [ShareAccess] (in)
//              [CreationDisposition] (in)
//              [CreateOptions] (in)
//              [lpSecurityAttributes] (in)
//              [ph] (out)
//                  The resulting file handle. Always set to NULL when function
//                  is entered.
//
//  Returns:    NTSTATUS
//
//+----------------------------------------------------------------------------

NTSTATUS
TrkCreateFile( const WCHAR           *pwszCompleteDosPath,
               ACCESS_MASK            AccessMask,
               ULONG                  Attributes,
               ULONG                  ShareAccess,
               ULONG                  CreationDisposition,
               ULONG                  CreateOptions,
               LPSECURITY_ATTRIBUTES  lpSecurityAttributes,
               HANDLE                 *ph)
{

    NTSTATUS    status;

    // Parameters for NtCreateFile
    OBJECT_ATTRIBUTES   ObjectAttr;
    IO_STATUS_BLOCK     IoStatus;

    // E.g. "\??\D:\..."
    UNICODE_STRING      uPath;
    PVOID               pFreeBuffer = NULL;

    *ph = NULL;

    //  -------------
    //  Open the File
    //  -------------

    // Generate the NT path name

    if( !RtlDosPathNameToNtPathName_U( pwszCompleteDosPath, &uPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }
    pFreeBuffer = uPath.Buffer;


    // Set up the ObjectAttributes

    InitializeObjectAttributes( &ObjectAttr,              // Structure
                                &uPath,                   // Name (identifier)
                                OBJ_CASE_INSENSITIVE,     // Attributes
                                0,                        // Root
                                0 );                      // Security


    if( NULL != lpSecurityAttributes )
    {
        ObjectAttr.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle )
        {
            ObjectAttr.Attributes |= OBJ_INHERIT;
        }
    }

    // Create/Open the file

    status =   NtCreateFile( ph,
                             AccessMask | SYNCHRONIZE,
                             &ObjectAttr, &IoStatus,
                             NULL,
                             Attributes,
                             ShareAccess,
                             CreationDisposition,
                             CreateOptions, // | FILE_SYNCHRONOUS_IO_NONALERT,
                             NULL,  // No EA buffer
                             0 );
    if( !NT_SUCCESS(status) )
    {
        *ph = NULL;
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );

    return( status );

}   // TrkCreateFile



//+----------------------------------------------------------------------------
//
//  Function:   FindLocalPath
//
//  Synopsis:   Given a volume index and a file ObjectId, return a volume-relative
//              path to the file, and return the file's Birth ID.  The returned
//              path does not have the drive letter prefix.
//
//  Inputs:     [ptszVolumeDeviceName] (in)
//                  The volume on which to search.
//              [objid] (in)
//                  The ObjectID to search for on this volume.
//              [pdroidBirth] (out)
//                  If the function is successful, returns the found file's
//                  birth ID.
//              [ptszLocalPath] (out)
//                  If the function is successful, returns the volume-relative
//                  path (includes the drive letter).
//
//  Returns:    [NTSTATUS]
//
//  Exceptions: None.
//
//+----------------------------------------------------------------------------


NTSTATUS
FindLocalPath( IN  const TCHAR *ptszVolumeDeviceName,
               IN  const CObjId &objid,
               OUT CDomainRelativeObjId *pdroidBirth,
               OUT TCHAR *ptszLocalPath )
{
    //  ------
    //  Locals
    //  ------

    NTSTATUS status;
    IO_STATUS_BLOCK Iosb;
    HANDLE hFile = NULL;


    // Open the file

    status = OpenFileById(  ptszVolumeDeviceName,
                            objid,
                            SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            0,
                            &hFile);
    if( !NT_SUCCESS(status) )
    {
        hFile = NULL;
        goto Exit;
    }

    // Get the file's birth ID

    status = GetBirthId( hFile, pdroidBirth );
    if( !NT_SUCCESS(status) ) goto Exit;

    // Get the volume-relative path

    status = QueryVolRelativePath( hFile, ptszLocalPath );
    if( !NT_SUCCESS(status) ) goto Exit;

    // When ptszLocalPath is a root directory, no relative path
    // will be found. i.e. "d:" will remain "d:", instead of "d:\", which is
    // what we want. We have to put the '\' in here.

    if(TEXT('\0') == ptszLocalPath[0])
    {
        ptszLocalPath[0] = TEXT('\\');
        ptszLocalPath[1] = TEXT('\0');
    }

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    if( !NT_SUCCESS(status)
        &&
        STATUS_OBJECT_PATH_NOT_FOUND != status
        &&
        STATUS_OBJECT_NAME_NOT_FOUND != status
        &&
        STATUS_INVALID_PARAMETER != status  // Happens when the objid is really the volid
      )
    {
        TrkLog(( TRKDBG_MISC,
                 TEXT("FindLocalPath returned status=%08X"), status ));
    }

    return( status );
}



//+----------------------------------------------------------------------------
//
//  Function:   GetDroids
//
//  Synopsis:   Get the current and birth domain-relative object IDs from
//              a file.  If rgoEnum is RGO_GET_OBJECT_ID, then an object ID
//              will be generated if necessary.  If RGO_READ_OBJECT_ID is
//              specified, and the file doesn't already have an object ID,
//              then STATUS_OBJECT_NAME_NOT_FOUND will be returned.
//
//  Inputs:     [tszFile] (in)
//                  The file who's object ID is to be retrieved.
//              [pdroidCurrent] (out)
//                  The file's CDomainRelativeObjId.
//              [pdroidBirth] (out)
//                  The file's birth CDomainRelativeObjId
//              [rgoEnum] (in)
//                  RGO_READ_OBJECTID => Read the object IDs, return
//                      STATUS_OBJECT_NAME_NOT_FOUND if none exist.
//                  RGO_GET_OBJECTID => Get the object IDs, generating
//                      and setting if necessary.
//
//  Returns:    NTSTATUS, outputs zero on error
//
//  Exceptions: None
//
//+----------------------------------------------------------------------------

NTSTATUS
GetDroids( HANDLE hFile,
           CDomainRelativeObjId *pdroidCurrent,
           CDomainRelativeObjId *pdroidBirth,
           RGO_ENUM rgoEnum )
{
    NTSTATUS status = STATUS_SUCCESS;
                            // Filled by NtQueryInformationFile
    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK Iosb;

    CDomainRelativeObjId droidCurrent;
    CDomainRelativeObjId droidBirth;

    pdroidCurrent->Init();
    pdroidBirth->Init();

    //  -----------------
    //  Get the Object ID
    //  -----------------

    // Use the file handle to get the file's Object ID

    memset( &fobOID, 0, sizeof(fobOID) );

    status = NtFsControlFile(
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &Iosb,
                 RGO_READ_OBJECTID == rgoEnum ? FSCTL_GET_OBJECT_ID : FSCTL_CREATE_OR_GET_OBJECT_ID,
                 NULL,
                 0,
                 &fobOID,               // Out buffer
                 sizeof(fobOID) );      // Out buffer size
    if( !NT_SUCCESS(status) )
        goto Exit;

    //  ---------------
    //  Load the Droids
    //  ---------------


    droidBirth.InitFromFOB( fobOID );
    droidBirth.GetVolumeId().Normalize();

    status = droidCurrent.InitFromFile( hFile, fobOID );
    if( !NT_SUCCESS(status) ) goto Exit;

    *pdroidCurrent = droidCurrent;
    *pdroidBirth = droidBirth;


    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status)
        &&
        STATUS_OBJECT_NAME_NOT_FOUND != status      // Ignore non-link source
        &&
        STATUS_INVALID_DEVICE_REQUEST != status     // Ignore e.g. FAT
        &&
        STATUS_VOLUME_NOT_UPGRADED != status        // Ignore NTFS4
        )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("GetDroids returned ntstatus=%08X"), status ));
    }

    return( status );
}


// Following is a wrapper that takes a filename, opens the file,
// and then calls the above GetDroids with the file handle.

NTSTATUS
GetDroids( const TCHAR *ptszFile,
           CDomainRelativeObjId *pdroidCurrent,
           CDomainRelativeObjId *pdroidBirth,
           RGO_ENUM rgoEnum )
{
    HANDLE hFile = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {
        status = TrkCreateFile( ptszFile, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OPEN,
                                FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL, &hFile );
        if( !NT_SUCCESS(status ))
        {
            hFile = NULL;
            goto Exit;
        }

        status = GetDroids( hFile, pdroidCurrent, pdroidBirth, rgoEnum );
    }
    __finally
    {
        if( NULL != hFile )
            NtClose( hFile );
    }

Exit:

    return( status );

}



//+----------------------------------------------------------------------------
//
//  Function:   SetObjId
//
//  Synopsis:   Sets an Object ID (GUID) on a file.
//
//  Inputs:     [ptszFile] (in)
//                  The file to be indexed.
//              [objid] (in)
//                  The ID to put on the file.
//              [droidBirth] (in)
//                  The BirthId to put on the file.
//
//  Returns:    NTSTATUS
//
//  Exceptions: None
//
//+----------------------------------------------------------------------------

NTSTATUS
SetObjId( const HANDLE hFile,
          CObjId objid,
          const CDomainRelativeObjId &droidBirth )
{

    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;

    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK IoStatus;

    // Initialize the request buffer

    memset( &fobOID, 0, sizeof(fobOID) );

    droidBirth.SerializeRaw( fobOID.ExtendedInfo );
    objid.SerializeRaw( fobOID.ObjectId );


    // Send the FSCTL

    status = NtFsControlFile(
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatus,
                 FSCTL_SET_OBJECT_ID,
                 &fobOID,
                 sizeof(fobOID),
                 NULL,  // Out buffer
                 0);    // Out buffer size
    if( !NT_SUCCESS(status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("SetObjId returned ntstatus=%08X"), status ));
    }

    return( status );
}


NTSTATUS
SetObjId( const TCHAR *ptszFile,
          CObjId objid,
          const CDomainRelativeObjId &droidBirth )
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;

    __try
    {
        // Setting the object ID requires restore privelege, but no
        // file access.

        EnableRestorePrivilege();

        status = TrkCreateFile( ptszFile, FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OPEN,
                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL, &hFile );
        if( !NT_SUCCESS(status ))
        {
            hFile = NULL;
            goto Exit;
        }

        status = SetObjId( hFile, objid, droidBirth );
    }
    __finally
    {
        if( NULL != hFile )
            NtClose( hFile );
    }

Exit:

    return( status );
}




//+----------------------------------------------------------------------------
//
//  Function:   MakeObjIdReborn
//
//  Synopsis:   Resets the birth ID on a file to it's current location.
//
//  Inputs:     [hFile]
//                  The handle of the file to delete the object id of.
//
//  Returns:    NTSTATUS
//
//  Exceptions: None
//
//+----------------------------------------------------------------------------

NTSTATUS
MakeObjIdReborn(const TCHAR *ptszVolumeDeviceName, const CObjId &objid)
{

    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;
    IO_STATUS_BLOCK IoStatus;

    // Open the file

    EnableRestorePrivilege();

    status = OpenFileById(ptszVolumeDeviceName,
                        objid,
                        SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT, // for FSCTL_DELETE_OBJECT_ID
                        &hFile);
    if( !NT_SUCCESS(status) )
    {
        hFile = NULL;
        TrkLog(( (STATUS_SHARING_VIOLATION == status || STATUS_ACCESS_DENIED == status)
                     ? TRKDBG_MISC : TRKDBG_ERROR,
                 TEXT("Couldn't make born again objid (%s) on %s, failed open (%08x)"),
                 (const TCHAR*)CDebugString(objid), ptszVolumeDeviceName, status ));
        goto Exit;
    }

    // Clear the file's birth ID

    status = MakeObjIdReborn( hFile );
    if( !NT_SUCCESS(status) && STATUS_OBJECT_NAME_NOT_FOUND != status )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't make born again Object ID (%s) on %s:, failed delete (%08x)"),
                 (const TCHAR*)CDebugString(objid), ptszVolumeDeviceName, status ));
        goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    #if DBG
    if( !NT_SUCCESS(status)
        &&
        STATUS_SHARING_VIOLATION != status
        &&
        STATUS_ACCESS_DENIED != status )
    {
        TCHAR tszPath[ MAX_PATH + 1 ];
        NTSTATUS statusDebug;

        hFile = NULL;
        statusDebug = OpenFileById( ptszVolumeDeviceName, objid,
                                    SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    FILE_ATTRIBUTE_NORMAL,
                                    &hFile );
        if( !NT_SUCCESS(statusDebug) )
            hFile = NULL;

        if( NT_SUCCESS(statusDebug) )
            statusDebug = QueryVolRelativePath( hFile, tszPath );
        else
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't OpenFileById (%08x)"), statusDebug ));

        if( NT_SUCCESS(statusDebug) )
            TrkLog(( TRKDBG_ERROR, TEXT("Failed to make born again objid on %s:%s"),
                     ptszVolumeDeviceName, tszPath ));
        else
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't QueryVolRelativePath (%08x)"), statusDebug ));

        if( NULL != hFile )
            NtClose( hFile );

    }
    #endif

    return( status );
}



NTSTATUS
MakeObjIdReborn(HANDLE hFile )
{
    NTSTATUS status = STATUS_SUCCESS;

    status = SetBirthId( hFile, CDomainRelativeObjId( ));
    if( !NT_SUCCESS(status) ) goto Exit;

Exit:

    return( status );

}


//+----------------------------------------------------------------------------
//
//  SetBirthId
//
//  The the birth ID on a file.  The object ID isn't altered.
//
//+----------------------------------------------------------------------------

NTSTATUS
SetBirthId( HANDLE hFile,
            const CDomainRelativeObjId &droidBirth )
{

    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;
    BOOL   fOpen = FALSE;
    CObjId objidNull;

    FILE_OBJECTID_BUFFER fobOID;
    UNICODE_STRING uPath;
    IO_STATUS_BLOCK IoStatus;

    // Initialize the request buffer

    memset( &fobOID, 0, sizeof(fobOID) );

    droidBirth.SerializeRaw( fobOID.ExtendedInfo );
    objidNull.SerializeRaw( fobOID.ObjectId );

    // Send the FSCTL

    status = NtFsControlFile(
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatus,
                 FSCTL_SET_OBJECT_ID_EXTENDED,
                 &fobOID.ExtendedInfo,
                 sizeof(fobOID.ExtendedInfo),
                 NULL,  // Out buffer
                 0);    // Out buffer size
    if( !NT_SUCCESS(status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("SetBirthId returned ntstatus=%08X"), status ));
    }

    return( status );
}


// Set the birth ID given a path, rather than a handle.

NTSTATUS
SetBirthId( const TCHAR *ptszFile,
            const CDomainRelativeObjId &droidBirth )
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;

    __try
    {
        EnableRestorePrivilege();

        status = TrkCreateFile( ptszFile, SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OPEN,
                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL, &hFile );
        if( !NT_SUCCESS(status ))
        {
            hFile = NULL;
            goto Exit;
        }

        status = SetBirthId( hFile, droidBirth );
    }
    __finally
    {
        if( NULL != hFile )
            NtClose( hFile );

    }

Exit:

    return( status );
}



//+----------------------------------------------------------------------------
//
//  Function:   GetBirthId
//
//  Synopsis:   Get the birth ID from a given file.
//
//  Parameters: [hFile] (in)
//                  The file to query.
//              [pdroidBirth] (out)
//                  The file's birth ID.
//
//  Returns:    [NTSTATUS]
//
//+----------------------------------------------------------------------------

NTSTATUS
GetBirthId( IN HANDLE hFile,
            OUT CDomainRelativeObjId *pdroidBirth )
{
    NTSTATUS status = STATUS_SUCCESS;
    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK IoStatus;

    TrkAssert( NULL != pdroidBirth );
    TrkAssert( INVALID_HANDLE_VALUE != hFile && NULL != hFile );

    status = NtFsControlFile(
                 hFile,
                 NULL, NULL, NULL,
                 &IoStatus,
                 FSCTL_GET_OBJECT_ID,
                 NULL, 0,
                 &fobOID,
                 sizeof(fobOID));

    if( !NT_SUCCESS(status) ) goto Exit;

    // Load the droid from the objid buffer.
    pdroidBirth->InitFromFOB( fobOID );

    // Clear the bit xvol-move bit, which is not considered part of the ID.
    pdroidBirth->GetVolumeId().Normalize();

Exit:

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\sources.inc ===
# Copyright (c) 1996-1999 Microsoft Corporation


INCLUDES=$(INCLUDES);\
    ..;\
    ..\common;\
    ..\trkwks;\
    ..\trksvr;\
    $(COM_INC_PATH); \
    $(NET_INC_PATH); \
    $(DS_INC_PATH); \
    $(BASE_INC_PATH); \
    ..\trkcom

UNICODE=1

#
# set TWK_OWN_PROCESS to 1 to build a Tracking (Workstation) Service that
# runs in its own process
#
# set TWK_OWN_PROCESS to 0 to build a Tracking (Workstation) Service that
# runs in services.exe as part of the server service
#

TRK_OWN_PROCESS=0

C_DEFINES=      -DINCL_32= \
                -DNT \
                -DRPC_NO_WINDOWS_H \
                -DSTRICT=1 \
                -DUNICODE \
                -D_UNICODE \
                -DTRK_OWN_PROCESS=$(TRK_OWN_PROCESS)\
                -DUSE_LDAP\
                -D_ATL_MIN_CRT\
                -D_USRDLL #** Added for ATL

USE_MSVCRT=1
UMENTRY=wmain

MSC_WARNING_LEVEL=/W3 /WX

# Keep netlib.lib ahead of netapi32.lib to avoid a linker warning
TARGETLIBS= $(TARGETLIBS)\
          ..\common\$(O)\common.lib\
	      ..\pch\$(O)\pch.lib \
          $(SDK_LIB_PATH)\ntdll.lib\
          $(SDK_LIB_PATH)\wldap32.lib\
          $(SDK_LIB_PATH)\rpcrt4.lib\
          $(SDK_LIB_PATH)\uuid.lib\
          $(SDK_LIB_PATH)\user32.lib\
          $(SDK_LIB_PATH)\kernel32.lib\
          $(SDK_LIB_PATH)\advapi32.lib\
          $(SDK_LIB_PATH)\netlib.lib\
          $(SDK_LIB_PATH)\netapi32.lib\
          $(SDK_LIB_PATH)\mpr.lib\

PRECOMPILED_CXX=1
PRECOMPILED_TARGET=..\pch\$(O)\pch.pch
PRECOMPILED_OPTION=/Yupch.cxx /Fp..\pch\$(O)\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\config.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation


//+============================================================================
//
//  config.cxx
//
//  Common configuration code for both services, in the form of the
//  CTrkConfiguration base class (inherited by CTrkWksConfiguration and
//  CTrkSvrConfiguration).
//
//+============================================================================


#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"

CMultiTsz CTrkConfiguration::_mtszOperationLog;


//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Initialize
//
//  Open the main key (identified by the global s_tszKeyNameLinkTrack, 
//  which is defined appropriately in trkwks.dll and trksvr.dll).  Then
//  read global values that are applicable to both services:  debug flags,
//  operation log filename, and test flags.
//
//+----------------------------------------------------------------------------

void
CTrkConfiguration::Initialize()
{
    ULONG lResult;
    TCHAR tszConfigurationKey[ MAX_PATH ];

    _fInitialized = TRUE;
    _hkey = NULL;

    // Open the base key

    _tcscpy( tszConfigurationKey, s_tszKeyNameLinkTrack );
    _tcscat( tszConfigurationKey, TEXT("\\") );
    _tcscat( tszConfigurationKey, TEXT("Configuration") );

    lResult = RegOpenKey( HKEY_LOCAL_MACHINE,
                          tszConfigurationKey,
                          &_hkey );
    if( ERROR_SUCCESS != lResult
        &&
        ERROR_PATH_NOT_FOUND != lResult
        &&
        ERROR_FILE_NOT_FOUND != lResult )
    {
        // We'll just make do without any custom configuration, rather than
        // making this a fatal error.

        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open Configuration key (%lu)"), lResult ));
        return;
    }

    // Read values that are common to trkwks & trksvr.

    Read( TRK_DEBUG_FLAGS_NAME, &_dwDebugFlags, TRK_DEBUG_FLAGS_DEFAULT );

    // Copy these flags into the global debug flags (debug.cxx)
    IFDBG( g_grfDebugFlags = _dwDebugFlags; )

    Read( DEBUG_STORE_FLAGS_NAME, &_dwDebugStoreFlags, DEBUG_STORE_FLAGS_DEFAULT );
    Read( TRK_TEST_FLAGS_NAME, &_dwTestFlags, TRK_TEST_FLAGS_DEFAULT );
    Read( OPERATION_LOG_NAME_NAME, &_mtszOperationLog, OPERATION_LOG_NAME_DEFAULT );

}


//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::UnInitialize
//
//  Close the main reg key.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _hkey )
        {
            RegCloseKey( _hkey );
            _hkey = NULL;
        }

        _fInitialized = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Read( REG_DWORD )
//
//  Read a DWORD configuration parameter.  Return the defaulut value 
//  if not found.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::Read( const TCHAR *ptszName, DWORD *pdwValue, DWORD dwDefault ) const
{
    *pdwValue = dwDefault;

    if( NULL != _hkey )
    {
        LONG lResult;
        DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(dwValue);

        lResult = RegQueryValueEx(  const_cast<HKEY>( _hkey ),
                                    ptszName,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) &dwValue,
                                    &cbValue);
        if( ERROR_SUCCESS == lResult )
        {
            if( REG_DWORD == dwType )
            {
                *pdwValue = dwValue;
                TrkLog(( TRKDBG_MISC, TEXT("RegConfig: %s = 0x%x (%lu)"),
                         ptszName, dwValue, dwValue ));
            }
            else
                TrkLog(( TRKDBG_ERROR,
                          TEXT("Registry value is wrong type") ));

        }
        else if( ERROR_FILE_NOT_FOUND != lResult )
        {
            TrkLog(( TRKDBG_ERROR,
                     TEXT("Couldn't read %s from registry (%lu)"), ptszName, lResult ));
        }
    }

    return;

}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Read( REG_SZ )
//
//  Read a string configuration parameter.  Return the default value
//  if not found.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::Read( const TCHAR *ptszName, ULONG *pcbValue, TCHAR *ptszValue, TCHAR *ptszDefault ) const
{
    ULONG cbIn = *pcbValue;
    LONG lResult = ERROR_PATH_NOT_FOUND;
    DWORD dwType;

    if( NULL != _hkey )
    {
        lResult = RegQueryValueEx(  const_cast<HKEY>( _hkey ),
                                    ptszName,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) ptszValue,
                                    pcbValue );
    }

    if( ERROR_SUCCESS != lResult || REG_SZ != dwType )
    {
        *pcbValue = 0;
        memset( ptszValue, 0, cbIn );
        _tcscpy( ptszValue, ptszDefault );
    }
    else
    {
        TrkLog(( TRKDBG_MISC, TEXT("RegConfig: %s = %s"), ptszName, ptszValue ));
    }

    return;

}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Read( REG_MULTI_SZ )
//
//  Read a string array configuration parameter.  Return the default
//  value if not found.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::Read( const TCHAR *ptszName, CMultiTsz *pmtszValue, TCHAR *ptszDefault ) const
{
    ULONG cbValue = pmtszValue->MaxSize();
    LONG lResult = ERROR_PATH_NOT_FOUND;
    DWORD dwType;

    // Read the value

    if( NULL != _hkey )
    {
        lResult = RegQueryValueEx(  const_cast<HKEY>( _hkey ),
                                    ptszName,
                                    NULL,
                                    &dwType,
                                    pmtszValue->GetBuffer(),
                                    &cbValue );
    }

    // Check the type

    if( ERROR_SUCCESS != lResult || (REG_SZ != dwType && REG_MULTI_SZ != dwType) )
    {
        // It didn't exist, or was the wrong type.  Return the default.

        *pmtszValue = ptszDefault;
#if DBG
        if( ERROR_FILE_NOT_FOUND != lResult && ERROR_PATH_NOT_FOUND != lResult )
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read %s from registry (%lu)"), ptszName, lResult ));
#endif
    }
    else
    {
        // We found the value.  Dump the first three values to dbgout.

        #if DBG
        TCHAR tszValues[ sizeof(*pmtszValue) ];
        _tcscpy( tszValues, TEXT("") );

        for( int i = 0; i < 3; i++ )
        {
           if( i >= (int) pmtszValue->NumStrings() )
              break;

           _tcscat( tszValues, (*pmtszValue)[i] );
           _tcscat( tszValues, TEXT(" ") );
        }

        if( 3 < (int) pmtszValue->NumStrings() )
           _tcscat( tszValues, TEXT("...") );

        TrkLog(( TRKDBG_MISC, TEXT("RegConfig: %s = %s"),
                 ptszName, tszValues ));
        #endif // #if DBG
    }

    return;
}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Write( REG_DWORD )
//
//  Write a DWORD configuration parameter.
//
//+----------------------------------------------------------------------------

BOOL
CTrkConfiguration::Write( const TCHAR *ptszName, DWORD dwValue ) const
{
    if( NULL != _hkey )
    {
        LONG lResult;
        DWORD cbValue = sizeof(dwValue);

        lResult = RegSetValueEx(  const_cast<HKEY>( _hkey ),
                                  ptszName,
                                  NULL,
                                  REG_DWORD,
                                  (LPBYTE) &dwValue,
                                  cbValue);
        if( ERROR_SUCCESS != lResult )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write %s to registry (%lu)"), ptszName, lResult ));
            return( FALSE );
        }
    }

    return( TRUE );

}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Write( REG_SZ )
//
//  Write a string configuration parameter.
//
//+----------------------------------------------------------------------------

BOOL
CTrkConfiguration::Write( const TCHAR *ptszName, const TCHAR *ptszValue ) const
{
    LONG lResult = ERROR_PATH_NOT_FOUND;

    if( NULL != _hkey )
    {
        lResult = RegSetValueEx(  const_cast<HKEY>( _hkey ),
                                  ptszName,
                                  NULL,
                                  REG_SZ,
                                  (LPBYTE) ptszValue,
                                  _tcslen(ptszValue) + 1 );
    }

    if( ERROR_SUCCESS != lResult )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write %s to registry (%lu)"), ptszName, lResult ));
        return( FALSE );
    }

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\common.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       common.cxx
//
//  Contents:   Code common to Tracking (Workstation) Service and
//              Tracking (Server) Service.
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"
#include "ntlsa.h"  // LsaGetUserName

#if MAX_COMPUTERNAME_LENGTH != 15
#error MAX_COMPUTERNAME_LENGTH assumed to be 15
#endif

//DWORD g_ftIndex;


const TCHAR s_HexGuidString[] = TEXT("%08X%04X%04X%02X%02X%02X%02X%02X%02X%02X%02X");
#define CCH_HEXGUID_STRING (8+4+4+2*8)

EXTERN_C const CLSID CLSID_TrackFile = {0x8790c947, 0xa30b, 0x11d0, {0x8c, 0xab, 0x00, 0xc0, 0x4f, 0xd9, 0x0f, 0x85} };



#if DBG
#define TRK_E_ERROR_MAP(tr,hr) { tr, hr, TEXT(#tr) }
#else
#define TRK_E_ERROR_MAP(tr,hr) { tr, hr }
#endif

// Map of TRK_E_ type error codes to HRESULTs, and in the debug build to strings.

const TrkEMap g_TrkEMap[] =
{
    TRK_E_ERROR_MAP(TRK_S_OUT_OF_SYNC,                            HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_LOG,                            HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_TIMER_REGISTRY_CORRUPT,                 HRESULT_FROM_WIN32(ERROR_REGISTRY_CORRUPT) ),
    TRK_E_ERROR_MAP(TRK_E_REGISTRY_REFRESH_CORRUPT,               HRESULT_FROM_WIN32(ERROR_REGISTRY_CORRUPT) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_IDT,                            HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_DB_CONNECT_ERROR,                       HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_DN_TOO_LONG,                            CO_E_PATHTOOLONG ),
    TRK_E_ERROR_MAP(TRK_E_DOMAIN_COMPUTER_NAMES_TOO_LONG,         HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_BAD_USERNAME_NO_SLASH,                  HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_UNKNOWN_SID,                            HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_IMPERSONATED_COMPUTERNAME_TOO_LONG,     HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_UNKNOWN_SVR_MESSAGE_TYPE,               HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_FAIL_TEST,                              E_FAIL ),
    TRK_E_ERROR_MAP(TRK_E_DENIAL_OF_SERVICE_ATTACK,               HRESULT_FROM_WIN32(ERROR_RETRY) ),
    TRK_E_ERROR_MAP(TRK_E_SERVICE_NOT_RUNNING,                    HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) ),
    TRK_E_ERROR_MAP(TRK_E_TOO_MANY_UNSHORTENED_NOTIFICATIONS,     HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_CLNTSYNC,                       HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_COMPUTER_NAME_TOO_LONG,                 HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_SERVICE_STOPPING,                       HRESULT_FROM_WIN32(ERROR_NO_TRACKING_SERVICE) ),
    TRK_E_ERROR_MAP(TRK_E_BIRTHIDS_DONT_MATCH,                    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_VOLTAB,                         HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_INTERNAL_ERROR,                         HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_PATH_TOO_LONG,                          CO_E_PATHTOOLONG ),
    TRK_E_ERROR_MAP(TRK_E_GET_MACHINE_NAME_FAIL,                  HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_SET_VOLUME_STATE_FAIL,                  HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_VOLUME_ACCESS_DENIED,                   HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_S_VOLUME_NOT_FOUND,                       HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) ),
    TRK_E_ERROR_MAP(TRK_S_VOLUME_NOT_OWNED,                       HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_REFERRAL,                               HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_NOT_FOUND,                              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ),
    TRK_E_ERROR_MAP(TRK_E_UNAVAILABLE,                            HRESULT_FROM_WIN32(ERROR_CONNECTION_UNAVAIL) ),
    TRK_E_ERROR_MAP(TRK_E_TIMEOUT,                                HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT) ),
    TRK_E_ERROR_MAP(TRK_E_VOLUME_QUOTA_EXCEEDED,                  HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_QUOTA) ),
    TRK_E_ERROR_MAP(TRK_S_NOTIFICATION_QUOTA_EXCEEDED,            HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_QUOTA) ),
    TRK_E_ERROR_MAP(TRK_E_SERVER_TOO_BUSY,                        HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY) ),
    TRK_E_ERROR_MAP(TRK_E_INVALID_VOLUME_ID,                      HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_POTENTIAL_FILE_FOUND,                   HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND) ),
    TRK_E_ERROR_MAP(TRK_E_NULL_COMPUTERNAME,                      HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_NOT_FOUND_AND_LAST_VOLUME_NOT_FOUND,    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ),
    TRK_E_ERROR_MAP(TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND,        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )
};


//+----------------------------------------------------------------------------
//
//  Function:   GetErrorString
//
//  Synopsis:   Map an TRK_E_ error to a descriptive string.
//
//+----------------------------------------------------------------------------

#if DBG
const TCHAR * GetErrorString(HRESULT hr)
{
    ULONG iError;

    if( S_OK == hr )
        return( TEXT("S_OK") );

    for( iError = 0; iError < sizeof(g_TrkEMap)/sizeof(*g_TrkEMap); iError++ )
    {
        if( g_TrkEMap[iError].tr == hr )
            return( g_TrkEMap[iError].ptszDescription );
    }

    return( TEXT("Not a TRK_E_ error") );
}
#endif

//+----------------------------------------------------------------------------
//
//  Function:   MapTR2HR
//
//  Synopsis:   Map a TRK_E_ type error code to an HRESULT.  If the input is
//              already a non-trk HRESULT, the input will be returned unchanged.
//
//+----------------------------------------------------------------------------

HRESULT MapTR2HR( HRESULT tr )
{
    ULONG iError;
    HRESULT hr = tr;

    if( S_OK == hr )
        return( hr );

    // Convert TRK_E_ error codes into an HRESULT

    for( iError = 0; iError < sizeof(g_TrkEMap)/sizeof(*g_TrkEMap); iError++ )
    {
        if( g_TrkEMap[iError].tr == hr )
        {
            hr = g_TrkEMap[iError].hr;
            break;
        }
    }

    // If this HRESULT is actually an NTSTATUS, then convert it to a Win32
    // error, then back to an HRESULT.

    if( FACILITY_NT_BIT & hr )
    {
        if( STATUS_VOLUME_NOT_UPGRADED == hr )
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        else
            hr = HRESULT_FROM_WIN32( RtlNtStatusToDosError(hr & ~FACILITY_NT_BIT) );
    }

    return( hr );
}




//+----------------------------------------------------------------------------
//
//  HexStringizeGuid
//
//  Optimized conversion from a GUID to a string.
//
//+----------------------------------------------------------------------------

inline void
HexStringizeByte( BYTE b, TCHAR* &rptsz )
{
    static const TCHAR _tszLookup[] = { TEXT("0123456789ABCDEF") };

    *rptsz++ = _tszLookup[ b >> 4 ];
    *rptsz++ = _tszLookup[ b & 0xF ];
}


void
HexStringizeGuid(const GUID &g, TCHAR * & rptsz)
{

    HexStringizeByte( HIGH_BYTE(HIGH_WORD(g.Data1)), rptsz );
    HexStringizeByte( LO_BYTE(HIGH_WORD(g.Data1)), rptsz );
    HexStringizeByte( HIGH_BYTE(LO_WORD(g.Data1)), rptsz );
    HexStringizeByte( LO_BYTE(LO_WORD(g.Data1)), rptsz );

    HexStringizeByte( HIGH_BYTE(g.Data2), rptsz );
    HexStringizeByte( LO_BYTE(g.Data2), rptsz );

    HexStringizeByte( HIGH_BYTE(g.Data3), rptsz );
    HexStringizeByte( LO_BYTE(g.Data3), rptsz );

    for( int i = 0; i < sizeof(g.Data4); i++ )
        HexStringizeByte( g.Data4[i], rptsz );

    *rptsz = TEXT('\0');

}


//+----------------------------------------------------------------------------
//
//  HexUnstringizeGuid
//
//  Convert a string to a GUID.  This is not used as often as HexStringizeGuid,
//  so it uses the CRT.
//
//+----------------------------------------------------------------------------

BOOL
HexUnstringizeGuid(const TCHAR * &ptsz, GUID * pg)
{
    DWORD Data1;
    DWORD Data2;
    DWORD Data3;
    DWORD Data40;
    DWORD Data41;
    DWORD Data42;
    DWORD Data43;
    DWORD Data44;
    DWORD Data45;
    DWORD Data46;
    DWORD Data47;

    if( 11 != _stscanf(  ptsz,
                         s_HexGuidString,
                         &Data1,
                         &Data2,
                         &Data3,
                         &Data40,
                         &Data41,
                         &Data42,
                         &Data43,
                         &Data44,
                         &Data45,
                         &Data46,
                         &Data47))
    {
        return( FALSE );
    }

    pg->Data1     = Data1;
    pg->Data2     = (WORD)Data2;
    pg->Data3     = (WORD)Data3;
    pg->Data4[0]  = (BYTE)Data40;
    pg->Data4[1]  = (BYTE)Data41;
    pg->Data4[2]  = (BYTE)Data42;
    pg->Data4[3]  = (BYTE)Data43;
    pg->Data4[4]  = (BYTE)Data44;
    pg->Data4[5]  = (BYTE)Data45;
    pg->Data4[6]  = (BYTE)Data46;
    pg->Data4[7]  = (BYTE)Data47;

    ptsz += CCH_HEXGUID_STRING;

    return( TRUE );
}

TCHAR *
wcstotcs(TCHAR *ptszBuf, const WCHAR *pwsz)
{
#ifdef UNICODE
    wcscpy(ptszBuf, pwsz);
#else
    wcstombs(ptszBuf, pwsz, (wcslen(pwsz)+1)*sizeof(WCHAR));
#endif
    return(ptszBuf);
}

CHAR *
tcstombs(CHAR *pszBuf, const TCHAR *ptsz)
{
#ifdef UNICODE
    wcstombs(pszBuf, ptsz, (_tcslen(ptsz)+1)*sizeof(CHAR));
#else
    strcpy(pszBuf, ptsz);
#endif
    return(pszBuf);
}

WCHAR *
tcstowcs(WCHAR *pwszBuf, const TCHAR *ptsz)
{
#ifdef UNICODE
    wcscpy(pwszBuf, ptsz);
#else
    mbstowcs(pwszBuf, ptsz, (_tcslen(ptsz)+1)*sizeof(WCHAR));
#endif
    return(pwszBuf);
}

TCHAR *
mbstotcs(TCHAR *ptszBuf, const CHAR *psz)
{
#ifdef UNICODE
    mbstowcs(ptszBuf, psz, (strlen(psz)+1)*sizeof(WCHAR));
#else
    _tcscpy(ptszBuf, psz);
#endif
    return(ptszBuf);
}




DWORD
TrkTimeUnits(const SYSTEMTIME &st)
{
    CFILETIME cft( st );

    // 2**32 * 100e-9 =  429.4967296 seconds
    //
    // 32bit int can last  1844674407371 seconds =  58494.24173551 years

    return( cft.HighDateTime() );
}

DWORD
TrkTimeUnits(const CFILETIME &cft)
{
    // 2**32 * 100e-9 =  429.4967296 seconds
    //
    // 32bit int can last  1844674407371 seconds =  58494.24173551 years

    return( cft.HighDateTime() );
}



#if DBG

void
CMachineId::AssertValid()
{
}

#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CMachineId::CMachineId( ptsz )
//
//  Instantiate a mcid from a computer name, e.g. "mymachine".
//
//+----------------------------------------------------------------------------

CMachineId::CMachineId(const TCHAR * ptszPath)
{
    HRESULT hr = E_FAIL;
    int nReturn;

    // Zero everything out first
    new(this) CMachineId;

    // Ensure that this isn't a real path, it should
    // have been pre-processed already.

    TrkAssert( _tcslen(ptszPath) < 2
               ||
               ( TEXT('\\') != ptszPath[0]
                 &&
                 TEXT(':') != ptszPath[1]
               )
             );

    // Ensure that it's not too long.
    if (_tcslen(ptszPath) > MAX_COMPUTERNAME_LENGTH )
        TrkRaiseException( TRK_E_COMPUTER_NAME_TOO_LONG );

#ifndef _UNICODE
#error Ansi build not supported.
#endif

    // Convert the Unicode machine name into Ansi, using
    // the OEM code page (the netbios/computer name is always
    // OEM code page, not the Windows Ansi code page).

    nReturn = WideCharToMultiByte( CP_OEMCP, 0,
                                   ptszPath, -1,
                                   _szMachine, sizeof(_szMachine),
                                   NULL, NULL );

    if( 0 == nReturn )
        TrkRaiseLastError();


    TrkLog(( TRKDBG_WARNING, TEXT("Machine name is: %hs (from %s)"),
             _szMachine, ptszPath ));

    Normalize();    // Guarantee a terminator
}


//+----------------------------------------------------------------------------
//
//  CMachineId::CMachineId( type )
//
//  Initialize an mcid.  The type indicates if the mcid should be for the
//  local computer, a DC (possibly doing a rediscovery), or invalid.
//
//+----------------------------------------------------------------------------

CMachineId::CMachineId(MCID_CREATE_TYPE type)
{
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    int nReturn;

    TrkAssert(type == MCID_LOCAL ||
              type == MCID_INVALID ||
              type == MCID_DOMAIN ||
              type == MCID_DOMAIN_REDISCOVERY ||
              type == MCID_PDC_REQUIRED);

    // Basic initialization
    new(this) CMachineId;

    if (type == MCID_INVALID)
        goto Exit;

    switch (type)
    {
    case MCID_LOCAL:
        {
            WCHAR wszComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];

            // Create an MCID of the local machine
            // We can't call GetComputerNameA, because it uses 
            // RtlUnicodeStringToAnsiString and consequently returns
            // a Windows/Ansi string, when it should be returning an
            // OEM string.

            if (!GetComputerNameW(wszComputerName, &dwSize))
                TrkRaiseException(HRESULT_FROM_WIN32(GetLastError()));

            nReturn = WideCharToMultiByte( CP_OEMCP, 0,
                                           wszComputerName, -1,
                                           szComputerName, sizeof(szComputerName),
                                           NULL, NULL );
            if( 0 == nReturn )
                TrkRaiseLastError();
        }

        break;

    case MCID_DOMAIN:
    case MCID_DOMAIN_REDISCOVERY:
    case MCID_PDC_REQUIRED:

        // Create an MCID for a DC

        DWORD dwErr;
        PDOMAIN_CONTROLLER_INFOW pdci;

        // DsGetDcName gets us the appropriate DC computer name
        // (of the form \\machine).  We call the W version
        // because the A version returns an Ansi string, 
        // rather than an OEM string.

        dwErr = DsGetDcNameW(NULL, NULL, NULL, NULL,
                        DS_RETURN_FLAT_NAME |
                         DS_BACKGROUND_ONLY |
                         DS_DIRECTORY_SERVICE_REQUIRED |
                         DS_WRITABLE_REQUIRED |
                         (type == MCID_DOMAIN_REDISCOVERY ?
                            DS_FORCE_REDISCOVERY : 0 ) |
                         (type == MCID_PDC_REQUIRED ?
                            DS_PDC_REQUIRED : 0 ),
                        &pdci);
        if (dwErr != NO_ERROR)
        {
            TrkRaiseWin32Error(dwErr);
        }

        // Validate the returned name.

        TrkAssert(pdci->DomainControllerName &&
                  pdci->DomainControllerName[0] == L'\\' &&
                  pdci->DomainControllerName[1] == L'\\');

        dwSize = wcslen(pdci->DomainControllerName + 2);
        if ( dwSize + 1 > sizeof(_szMachine))
        {
            NetApiBufferFree(pdci);
            TrkRaiseException(HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
        }

        // Keep the returned name.

        nReturn = WideCharToMultiByte( CP_OEMCP, 0,
                                       &pdci->DomainControllerName[2], -1,
                                       _szMachine, sizeof(_szMachine),
                                       NULL, NULL );
        if( 0 == nReturn )
            TrkRaiseLastError();

        NetApiBufferFree(pdci);

        goto Exit;
    }   // switch

    if (dwSize + 1 <= sizeof(_szMachine))
    {
        strcpy(_szMachine, szComputerName);
        Normalize();
    }
    else
    {
        TrkRaiseException(HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
    }

Exit:

    Normalize();    // Guarantee a terminator
    return;
}


#ifndef UNICODE
extern "C"
NET_API_STATUS
NetpGetDomainName (
    IN  LPWSTR   *ComputerNamePtr);
#endif

//+----------------------------------------------------------------------------
//
//  CMachineId::GetLocalAuthName
//
//  Returns the authentication name for use in secure RPC (to be used in
//  the RpcBindingSetAuthInfo on the server).  The name
//  is of the form DOMAIN\MACHINE$, where DOMAIN is the local domain
//  and MACHINE is the contents of this CMachineId
//
//+----------------------------------------------------------------------------

void
CMachineId::GetLocalAuthName(RPC_TCHAR * ptszAuthName, DWORD cchBuf) const
{
    // To get domain name: if you link to netlib.lib, you can call NetpGetDomainName,
    // which does all the work for you. Or you could copy the code
    // from \nt\private\net\netlib\domname.c

    NET_API_STATUS Status;
    WCHAR * pwszDomain;
    DWORD dwErr;
    PDOMAIN_CONTROLLER_INFOA pdci = NULL;

    __try
    {
        // Get the domain name ...

        Status = NetpGetDomainName(&pwszDomain);
        if (Status != NO_ERROR)
        {
            pwszDomain = NULL;
            TrkRaiseWin32Error(Status);
        }

        // and validate it.

        if (cchBuf < wcslen(pwszDomain) + 1 + strlen(_szMachine) + 1 + 1)
        {
            TrkRaiseException(TRK_E_DOMAIN_COMPUTER_NAMES_TOO_LONG);
        }

        // Copy the domain name then the machine name into the return buffer.

        wcstotcs((TCHAR*)ptszAuthName, pwszDomain);
        _tcscat((TCHAR*)ptszAuthName, TEXT("\\"));
        mbstotcs(_tcschr((TCHAR*)ptszAuthName, 0), _szMachine);
        _tcscat((TCHAR*)ptszAuthName, TEXT("$"));

    }
    __finally
    {
        if (pwszDomain != NULL)
        {
            NetApiBufferFree(pwszDomain);
        }
    }
}

//+----------------------------------------------------------------------------
//
//  GetFileTimeNow
//
//  Get the current FILETIME (UTC).
//
//+----------------------------------------------------------------------------

FILETIME GetFileTimeNow()
{
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    return(ft);
}

//+----------------------------------------------------------------------------
//
//  CDomainRelativeObjId::Stringize
//
//  Stringize a droid.
//
//+----------------------------------------------------------------------------

TCHAR *
CDomainRelativeObjId::Stringize( TCHAR * ptszOutBuf, DWORD cchBuf ) const
{
    TCHAR *ptszBuf = ptszOutBuf;
    _volume.Stringize(ptszBuf);     /*in, out, c++ reference*/
    _object.Stringize(ptszBuf);     /*in, out, c++ reference*/

    TrkAssert(_tcslen(ptszOutBuf) + 1 < cchBuf);

    return(ptszOutBuf);
}



//+----------------------------------------------------------------------------
//
//  CTrkRegistryKey::Delete
//
//  Common code to delete a registry key, relative to _hkey.
//
//+----------------------------------------------------------------------------

LONG
CTrkRegistryKey::Delete( const TCHAR *ptszName )
{
    LONG lRet = 0;
    _cs.Enter();
    __try
    {
        // Open _hkey if it's not already.

        lRet = Open();

        // And delete the value

        if( ERROR_SUCCESS == lRet )
        {
            RegDeleteValue( _hkey, ptszName );
            Close();
        }
    }
    __finally
    {
        _cs.Leave();
    }

    return( lRet );
}


//+----------------------------------------------------------------------------
//
//  CTrkRegistryKey::SetDword
//
//  Set a REG_DWORD value under _hkey.
//
//+---------------------------------------------------------------------------0

LONG
CTrkRegistryKey::SetDword( const TCHAR *ptszName, DWORD dw )
{
    LONG lRet = 0;

    _cs.Enter();
    __try
    {
        // Open _hkey if it's not already

        lRet = Open();

        // And set the value

        if ( ERROR_SUCCESS == lRet )
        {
            lRet = RegSetValueEx(  _hkey,
                                   ptszName,
                                   0,
                                   REG_DWORD,
                                   reinterpret_cast<CONST BYTE *>(&dw),
                                   sizeof(dw) );
            if( ERROR_SUCCESS != lRet )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set registry value for %s (%lu)"),
                         ptszName, lRet ));
                RegDeleteKey( _hkey, ptszName );
            }

            Close();
        }
    }
    __finally
    {
        _cs.Leave();
    }

    return( lRet );
}


//+----------------------------------------------------------------------------
//
//  CTrkRegistryKey::GetDword
//
//  Get a REG_DWORD value from _hkey.
//
//+---------------------------------------------------------------------------0

LONG
CTrkRegistryKey::GetDword( const TCHAR *ptszName, DWORD *pdwRead, DWORD dwDefault )
{
    LONG lRet;
    DWORD dwRead;
    DWORD cbData = sizeof(*pdwRead);
    DWORD dwType;

    *pdwRead = dwDefault;

    _cs.Enter();
    __try
    {
        // Open _hkey if it's not already.

        lRet = Open();
        if( ERROR_SUCCESS != lRet )
            __leave;


        // Get the DWORD

        lRet = RegQueryValueEx( _hkey, ptszName, 0, &dwType,
                                reinterpret_cast<BYTE*>(&dwRead), &cbData );

        if( ERROR_SUCCESS == lRet )
        {
            // Validate the type

            if( REG_DWORD != dwType || sizeof(dwRead) != cbData )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Wrong type/size (%d/%d) for registry value %s"),
                         dwType, cbData, ptszName ));
                RegDeleteKey( _hkey, ptszName );
            }
            else
            {
                *pdwRead = dwRead;
            }
        }
        else if( ERROR_FILE_NOT_FOUND == lRet
                 ||
                 ERROR_PATH_NOT_FOUND == lRet )
        {
            lRet = ERROR_SUCCESS;
        }
        else
        {
            TrkLog(( TRKDBG_ERROR,
                     TEXT("Couldn't read %s from registry (%lu)"), ptszName, lRet ));
            RegDeleteKey( _hkey, ptszName );
            __leave;
        }
    }
    __finally
    {
        Close();
        _cs.Leave();
    }


    return( lRet );
}


//+----------------------------------------------------------------------------
//
//  ThreadPoolCallbackFunction
//
//  This function is passed as the callback function to
//  RegisterWaitForSingleObjectEx.  The context is a PWorkItem pointer.
//
//  Arguments:
//      [pvWorkItem]
//          The Context parameter from RegisterWaitForSingleObjectEx.
//          Is a PWorkItem*
//      [fTimeout]
//          We always register INFINITE as the timeout, so this value
//          should always be FALSE.
//
//+----------------------------------------------------------------------------

VOID NTAPI
ThreadPoolCallbackFunction( PVOID pvWorkItem, BOOLEAN fTimeout )
{
    SThreadFromPoolState state;
    PWorkItem *pWorkItem = reinterpret_cast<PWorkItem*>(pvWorkItem);

    TrkLog(( TRKDBG_WORKMAN, TEXT("Enter ThreadPoolCallbackFunction for %s (%p/%p)"),
             pWorkItem->_tszWorkItemSig, pWorkItem, *reinterpret_cast<UINT_PTR*>(pWorkItem) ));

    TrkAssert( FALSE == fTimeout );

    // Make sure we never raise back into the thread pool.

    __try
    {
        // Update thread-count stats.  Note that this isn't
        // thread-safe, but for private statistics it's not worth
        // creating a critsec.

        InterlockedIncrement( reinterpret_cast<LONG*>(&g_cThreadPoolThreads) );
        if( g_cThreadPoolThreads > g_cThreadPoolMaxThreads )
            g_cThreadPoolMaxThreads = g_cThreadPoolThreads;

        // Set our necessary thread-specific settings
        state = InitializeThreadFromPool();

        // Process the signal
        pWorkItem->DoWork();
    }
    __except( BREAK_THEN_RETURN( EXCEPTION_EXECUTE_HANDLER ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Unexpected exception on thread pool callback (%08x)"),
                 GetExceptionCode() ));
    }

    TrkLog(( TRKDBG_WORKMAN, TEXT("Exit  ThreadPoolCallbackFunction for %s (%p)"),
             pWorkItem->_tszWorkItemSig, pWorkItem ));

    InterlockedDecrement( reinterpret_cast<LONG*>(&g_cThreadPoolThreads) );

    //IFDBG( TrkRtlCheckForOrphanedCriticalSections( GetCurrentThread() ));

    // Restore the original thread-specific settings
    UnInitializeThreadFromPool( state );
}

// The work item callback function (used for RtlQueueWorkItem)
// just calls to the function above.

VOID NTAPI
ThreadPoolWorkItemFunction( PVOID pvWorkItem )
{
    ThreadPoolCallbackFunction( pvWorkItem, FALSE );
}

//+----------------------------------------------------------------------------
//
//  RunningAsAdministratorHack
//
//  This routine is only used by test/debug hooks.  It checks to see if
//  the thread is running as an administrative user by seeing if we can
//  get write access to the service's parameters key in the registry.
//
//+----------------------------------------------------------------------------

BOOL
RunningAsAdministratorHack()
{
    LONG lResult = 0;
    HKEY hkey = NULL;
    BOOL fReturn = FALSE;

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            s_tszKeyNameLinkTrack,
                            0,  // Options, reserved must be zero
                            KEY_ALL_ACCESS,
                            &hkey );
    if( ERROR_SUCCESS == lResult )
    {
        fReturn = TRUE;
        RegCloseKey( hkey );
    }

    return( fReturn );

}

//+----------------------------------------------------------------------------
//
//  EnablePrivilege
//
//  Enable the specified privielge in the current access token if
//  it is available.
//
//+----------------------------------------------------------------------------

BOOL
EnablePrivilege( const TCHAR *ptszPrivilegeName )
{
    BOOL fSuccess = FALSE;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    LUID luid;
    TOKEN_PRIVILEGES token_privileges;

    // Get the process token.

    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &hToken))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed OpenProcessToken (%lu)"), GetLastError() ));
        goto Exit;
    }

    // Look up the name of this privilege.

    if( !LookupPrivilegeValue( (LPTSTR) NULL, ptszPrivilegeName, &luid ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed LookupPrivilegeValue (%lu)"), GetLastError() ));
        goto Exit;
    }

    // Enable the privilege.

    token_privileges.PrivilegeCount = 1;
    token_privileges.Privileges[0].Luid = luid;
    token_privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges( hToken, FALSE, &token_privileges, sizeof(TOKEN_PRIVILEGES),
                           (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL);

    // The return value doesn't tell us anything useful.  We have to check GetLastError
    // for ERROR_SUCCESS or ERROR_NOT_ALL_ASSIGNED.

    if( ERROR_SUCCESS != GetLastError() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't adjust process token privileges (%lu)"), GetLastError() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    if( INVALID_HANDLE_VALUE != hToken )
        CloseHandle( hToken );

    return( fSuccess );

}



#if DBG

CDebugString::CDebugString(const TRKSVR_MESSAGE_TYPE MsgType)
{
    switch(MsgType)
    {
    case old_SEARCH:
        _tcscpy( _tsz, TEXT("old_SEARCH") ); break;
    case SEARCH:
        _tcscpy( _tsz, TEXT("SEARCH") ); break;
    case MOVE_NOTIFICATION:
        _tcscpy( _tsz, TEXT("MOVE_NOTIFICATION") ); break;
    case REFRESH:
        _tcscpy( _tsz, TEXT("REFRESH") ); break;
    case SYNC_VOLUMES:
        _tcscpy( _tsz, TEXT("SYNC_VOLUMES") ); break;
    case DELETE_NOTIFY:
        _tcscpy( _tsz, TEXT("DELETE_NOTIFY") ); break;
    case STATISTICS:
        _tcscpy( _tsz, TEXT("STATISTICS") ); break;
    default:
        _tcscpy( _tsz, TEXT("UNKNOWN") ); break;
    }
}

#endif // #if DBG



#if DBG

CDebugString::CDebugString(LONG VolIndex, const PFILE_NOTIFY_INFORMATION pNotifyInfo )
{
    TCHAR *ptsz = _tsz;
    _tsz[0] = TEXT('\0');

    switch( pNotifyInfo->Action )
    {
    case FILE_ACTION_ADDED:
        _tcscat( _tsz, TEXT("Added ")); break;
    case FILE_ACTION_REMOVED:
        _tcscat( _tsz, TEXT("Removed ")); break;
    case FILE_ACTION_MODIFIED:
        _tcscat( _tsz, TEXT("Modified ")); break;
    case FILE_ACTION_RENAMED_OLD_NAME:
        _tcscat( _tsz, TEXT("Rename old name ")); break;
    case FILE_ACTION_RENAMED_NEW_NAME:
        _tcscat( _tsz, TEXT("Rename new name ")); break;
    case FILE_ACTION_ADDED_STREAM:
        _tcscat( _tsz, TEXT("Added stream ")); break;
    case FILE_ACTION_REMOVED_STREAM:
        _tcscat( _tsz, TEXT("Removed stream ")); break;
    case FILE_ACTION_MODIFIED_STREAM:
        _tcscat( _tsz, TEXT("Modified stream ")); break;
    case FILE_ACTION_REMOVED_BY_DELETE:
        _tcscat( _tsz, TEXT("Removed by delete ")); break;
    case FILE_ACTION_ID_NOT_TUNNELLED:
        _tcscat( _tsz, TEXT("OID not tunnelled ")); break;
    case FILE_ACTION_TUNNELLED_ID_COLLISION:
        _tcscat( _tsz, TEXT("OID tunnel collision ")); break;
    default:
        _stprintf( _tsz, TEXT("Unknown action (0x%x)"), pNotifyInfo->Action ); break;
    }

    ptsz = _tsz + _tcslen(_tsz);

    // The name length for an object ID is always 72
    if( pNotifyInfo->FileNameLength != 72 )
        _stprintf( ptsz, TEXT(" name length=%d"), pNotifyInfo->FileNameLength );
    else
    {
        // Stringize the path of this object ID
        CDomainRelativeObjId droidBirth;
        CObjId objid( FOI_OBJECTID, *(FILE_OBJECTID_INFORMATION*)pNotifyInfo->FileName );

        ptsz[0] = VolChar(VolIndex);
        ptsz[1] = TEXT(':');
        ptsz[2] = TEXT('\0');
        FindLocalPath( VolIndex, objid, &droidBirth, &ptsz[2] );
        ptsz += _tcslen(ptsz);
        ptsz += _stprintf( ptsz, TEXT(" - %c:"), VolChar(VolIndex) );
        _stprintf( ptsz, TEXT("%s"), CDebugString(objid)._tsz );
        ptsz += _tcslen(ptsz);
    }

}

#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CActiveThreadList::AddCurrent
//
//  Add the current thread to the list of threads maintained by this class.
//
//+----------------------------------------------------------------------------

HRESULT
CActiveThreadList::AddCurrent( )
{
    HRESULT hr = S_OK;
    HANDLE hThread = NULL;

    if( !_cs.IsInitialized() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Active thread list critsec not initialized!!!") ));
        return S_OK;
    }

    _cs.Enter();

    if( _cActiveThreads < _cMaxThreads )
    {
        // Add the thread ID at the end of the list.
        _prgdwThreadIDs[ _cActiveThreads++ ] = GetCurrentThreadId();
    }
    else
    {
        // Alloc a larger buffer for the list, then add the thread ID.

        hr = Grow();
        if( SUCCEEDED(hr) )
        {
            _prgdwThreadIDs[ _cActiveThreads++ ] = GetCurrentThreadId();
        }
    }

#if DBG
    if( SUCCEEDED(hr) )
        TrkLog(( TRKDBG_WORKMAN, TEXT("Added thread 0x%x to the active thread list (%d)"),
                 GetCurrentThreadId(), _cActiveThreads ));
#endif

    _cs.Leave();

    return( hr );
}


//+----------------------------------------------------------------------------
//
//  CActiveThreadList::RemoveCurrent
//
//  Remove the current thread ID from the list which is maintained by this
//  class.
//
//+----------------------------------------------------------------------------

HRESULT
CActiveThreadList::RemoveCurrent( )
{
    HRESULT hr = S_OK;
    BOOL fFound = FALSE;
    DWORD dwThreadID = GetCurrentThreadId();

    if( !_cs.IsInitialized() )
        return S_OK;

    _cs.Enter();

    // Search for the current thread's ID in the list.

    for( ULONG i = 0; i < _cActiveThreads; i++ )
    {
        if( _prgdwThreadIDs[ i ] == dwThreadID )
        {
            // We found this thread.  Remove it from the list by copying down
            // all the IDs behind it.

            memcpy( &_prgdwThreadIDs[i], &_prgdwThreadIDs[i+1],
                    (--_cActiveThreads - i) * sizeof(_prgdwThreadIDs[0]) );
            _prgdwThreadIDs[ _cActiveThreads ] = 0;

            TrkLog(( TRKDBG_WORKMAN, TEXT("Removed thread 0x%x from the active thread list (%d)"),
                     dwThreadID, _cActiveThreads ));

            fFound = TRUE;
            break;
        }
    }

    if( !fFound )
    {
        hr = E_FAIL;
        TrkLog(( TRKDBG_WORKMAN, TEXT("CActiveThreadList couldn't remove thread 0x%x, not found"),
                 dwThreadID ));
    }

    _cs.Leave();

    return( hr );
}


//+----------------------------------------------------------------------------
//
//  CActiveThreadList::CancelAllRpc
//
//  Call RpcCancelThread on each of the threads in the list.
//
//+----------------------------------------------------------------------------

void
CActiveThreadList::CancelAllRpc()
{
    if( !_cs.IsInitialized() )
        return;

    _cs.Enter();

    TrkLog(( TRKDBG_WKS|TRKDBG_SVR, TEXT("Canceling all out-going RPCs") ));

    // Loop through the list of threads.

    for( ULONG i = 0; i < _cActiveThreads; i++ )
    {
        TrkAssert( 0 != _prgdwThreadIDs[i] );

        // Get a thread handle for this thread ID.

        HANDLE hThread = OpenThread( THREAD_ALL_ACCESS, FALSE, _prgdwThreadIDs[i] );
        if( NULL == hThread )
        {
            // Nothing we can do about it.  Move on to the next thread.
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open thread 0x%x to cancel RPC (%lu)"),
                     _prgdwThreadIDs[i], GetLastError() ));
            continue;
        }

        // Cancel any out-going RPC on this thread.

        RPC_STATUS rpcstatus = RpcCancelThread( hThread );
        if( RPC_S_OK != rpcstatus )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcCancelThread on %p/0x%x (%lu)"),
                     hThread, _prgdwThreadIDs[i], rpcstatus ));
        }
        else
        {
            TrkLog(( TRKDBG_WORKMAN, TEXT("Canceled RPC on %p/0x%x"),
                     hThread, _prgdwThreadIDs[i] ));
        }

        // Close the thread handle and move on.

        CloseHandle( hThread );
    }

    _cs.Leave();
}



//+----------------------------------------------------------------------------
//
//  CActiveThreadList::Grow
//
//  Private member function to grow the buffer used to hold the thread IDs.
//
//+----------------------------------------------------------------------------


HRESULT
CActiveThreadList::Grow()
{
    // This is a private method, the critsec has already been entered.

    HRESULT hr = S_OK;
    DWORD *prgNew = NULL;
    ULONG cMaxThreads = _cMaxThreads + INCREMENT_ACTIVE_THREAD_LIST;

    prgNew = new DWORD[ cMaxThreads ];
    if( NULL == prgNew )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't grow active thread list") ));
        return( E_OUTOFMEMORY );
    }

    TrkLog(( TRKDBG_WORKMAN, TEXT("Growing active thread list from %d to %d"),
             _cMaxThreads, cMaxThreads ));

    memcpy( prgNew, _prgdwThreadIDs, _cMaxThreads*sizeof(_prgdwThreadIDs[0]) );
    _cMaxThreads = cMaxThreads;
    delete [] _prgdwThreadIDs;
    _prgdwThreadIDs = prgNew;

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\objidenm.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       objidenm.cxx
//
//  Contents:   CObjId enumeration from a volume
//
//  Classes:    CObjIdEnumerator
//
//  History:    18-Nov-96  BillMo      Created.
//              09-Jun-97  WeiruC      Modified. Skip volume id entries in
//                                     NTFS object id table.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop
#include "trklib.hxx"


//+----------------------------------------------------------------------------
//
//  CObjIdEnumerator::Initialize
//
//  Prepare to enumerate the object IDs on a volume.  This opens a handle
//  to the object ID index directory.
//
//+----------------------------------------------------------------------------

BOOL
CObjIdEnumerator::Initialize(const TCHAR *ptszVolumeDeviceName)
{
    TCHAR tszDirPath[MAX_PATH];

    _tcscpy( tszDirPath, ptszVolumeDeviceName);
    _tcscat( tszDirPath, TEXT("\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION") );

    _hDir = CreateFile( tszDirPath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    return( INVALID_HANDLE_VALUE != _hDir );
}


//+----------------------------------------------------------------------------
//
//  CObjIdEnumerator::UnInitialize
//
//  Close the handle to the object ID index directory.
//
//+----------------------------------------------------------------------------

void
CObjIdEnumerator::UnInitialize()
{
    if( INVALID_HANDLE_VALUE != _hDir )
        CloseHandle(_hDir);
    _hDir = INVALID_HANDLE_VALUE;
}


//+----------------------------------------------------------------------------
//
//  CObjIdEnumerator::Find
//
//  This private method is used by the public FindFirst and FindNext
//  methods.  This method queries the object ID index directory
//  for a set of entries and puts the result into _ObjIdInfo.  It then
//  takes the first real entry and puts it into the caller-provided parameters
//  (the object ID and birth ID).  To start enumerating from the top of the
//  index, fRestart is set by the caller.
//
//+----------------------------------------------------------------------------


BOOL
CObjIdEnumerator::Find( CObjId * pobjid, CDomainRelativeObjId * pdroidBirth, BOOL fRestart )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL            fObjFound = FALSE;

    // Loop until we find a real entry.

    do
    {
        // Query the object ID index for a set of entries.

        Status = NtQueryDirectoryFile( _hDir,
                                       NULL,     //  Event
                                       NULL,     //  ApcRoutine
                                       NULL,     //  ApcContext
                                       &IoStatusBlock,
                                       _ObjIdInfo,
                                       sizeof(_ObjIdInfo),
                                       FileObjectIdInformation,
                                       FALSE,    //  ReturnSingleEntry
                                       NULL,     //  FileName
                                       fRestart != 0);  //  RestartScan
        if(NT_SUCCESS(Status) && IoStatusBlock.Information != 0)
        {
            fRestart = FALSE;

            // Update the count of entries and the cursor into the entries.

            _cbObjIdInfo = (ULONG)IoStatusBlock.Information;
            _pObjIdInfo = _ObjIdInfo;

            TrkAssert( _cbObjIdInfo % sizeof(*_pObjIdInfo) == 0 );
            TrkAssert( _cbObjIdInfo <= sizeof(_ObjIdInfo) );

            // In the NTFS's ObjectID table is a record which represents
            // not the file object id but the volume id. We skip this record.

            while( _pObjIdInfo < &_ObjIdInfo[_cbObjIdInfo / sizeof(_ObjIdInfo[0])]
                   &&
                   (_pObjIdInfo->FileReference & FILEREF_MASK) == FILEREF_VOL )
            {
                _pObjIdInfo++;
            }

            // If we haven't exhausted the objects in the buffer, take the next
            // one and return it to the caller.

            if(_pObjIdInfo < &_ObjIdInfo[_cbObjIdInfo / sizeof(_ObjIdInfo[0])])
            {
                UnloadFileObjectIdInfo( *_pObjIdInfo, pobjid, pdroidBirth );
                _pObjIdInfo ++;
                fObjFound = TRUE;
                break;
            }
        }
        else
        {
            break;
        }
    } while(TRUE);

    if(TRUE == fObjFound)
    {
        return(TRUE);
    }
    else
    {
        _cbObjIdInfo = 0;
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\debug.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       debug.cxx
//
//  Contents:   Debug support.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------



#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"
#include <stdio.h>      //  vsprintf

#if DBG == 1

//CFailPoint * CFailPoint::g_pList = NULL;

#define TRKSVC_LOG_FILE              TEXT("%SystemRoot%\\debug\\trksvcs.log")



CHAR                     TrkGlobalDebugBuffer[ 1024];     //  arbitrary
DWORD                    TrkGlobalDebug;

HANDLE                   g_LogFile = INVALID_HANDLE_VALUE;

// This critical section is used to serialize simultaneous dbgout calls.
CRITICAL_SECTION         g_csDebugOut;
LONG                     g_cCritSecInit = 0;

CHAR                     g_szDebugBuffer[ 1024];     //  arbitrary
TCHAR                    g_tszDebugBuffer[ 1024 ];
ULONG                    g_grfDebugFlags = 0;
ULONG                    g_grfLogFlags = 0;
CHAR                     g_szModuleName[ MAX_PATH ] = { "" };
LONG                     g_cInitializations = 0;


VOID TrkDebugDelete( VOID)
{
    // This isn't thread safe, so we won't ever delete it.
    // It just means there's a one-time leak in the chk build
    // when the service gets stopped.

    //if( 0 == InterlockedDecrement( &g_cCritSecInit ))
      //  DeleteCriticalSection( &g_csDebugOut);

    InterlockedDecrement(&g_cInitializations);

    if( INVALID_HANDLE_VALUE != g_LogFile )
    {
        CloseHandle( g_LogFile );
        g_LogFile = INVALID_HANDLE_VALUE;
    }

}


VOID TrkDebugCreate( ULONG grfLogFlags, CHAR *pszModuleName )
{
    TCHAR       Buffer[ MAX_PATH];
    DWORD       Length;

    if( 1 < InterlockedIncrement(&g_cInitializations) ) return;

    strncpy( g_szModuleName, pszModuleName, sizeof(g_szModuleName) );
    g_szModuleName[ sizeof(g_szModuleName) - 1 ] = TEXT('\0');

    if( 1 == InterlockedIncrement( &g_cCritSecInit ))
        InitializeCriticalSection( &g_csDebugOut );

    if( (TRK_DBG_FLAGS_WRITE_TO_FILE | TRK_DBG_FLAGS_APPEND_TO_FILE) & grfLogFlags )
    {
        //
        //  Length returned by ExpandEnvironmentalStrings includes terminating
        //  NULL byte.
        //

        Length = ExpandEnvironmentStrings( TRKSVC_LOG_FILE, Buffer, sizeof( Buffer));
        if ( Length == 0) {
            TrkLog(( TRKDBG_ERROR, TEXT("Error=%d"), GetLastError()));
            return;
        }
        if ( Length > sizeof( Buffer) ||  Length != _tcslen(Buffer) + 1) {
            Beep(2000,2000);
            TrkLog(( TRKDBG_ERROR, TEXT("Buffer=%x, Length = %d"), Buffer, Length));
            return;
        }

        g_LogFile = CreateFile( Buffer,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                      NULL,
                                      (TRK_DBG_FLAGS_APPEND_TO_FILE & grfLogFlags)
                                        ? OPEN_ALWAYS
                                        : CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL );

        if ( g_LogFile == INVALID_HANDLE_VALUE ) {
            TCHAR tsz[ 2 * MAX_PATH ];
            _stprintf( tsz, TEXT("Cannot open %s (%lu)\n"),
                      Buffer, GetLastError() );
            OutputDebugString( tsz );
            return;
        }

        if( TRK_DBG_FLAGS_APPEND_TO_FILE & grfLogFlags )
        {
            //
            // Position the log file at the end
            //
            (VOID) SetFilePointer( g_LogFile,
                                   0,
                                   NULL,
                                   FILE_END );
        }
        else
        {
            // 
            // Truncate the file
            //

            SetFilePointer( g_LogFile, 0, NULL, FILE_BEGIN );
            SetEndOfFile( g_LogFile );
        }

    }

    g_grfLogFlags = grfLogFlags;
    
}


VOID TrkLogRoutine(
    IN      DWORD       DebugFlag,
    IN      LPTSTR      Format,
    ...
    )
{
    LONG l = GetLastError();

    va_list Arguments;
    va_start( Arguments, Format );

    TrkLogErrorRoutineInternal( DebugFlag, NULL, Format, Arguments );

    SetLastError(l);
}

VOID TrkLogErrorRoutine(
    IN      DWORD       DebugFlag,
    IN      HRESULT     hr,
    IN      LPTSTR      Format,
    ...
    )
{
    CHAR szHR[8];
    va_list Arguments;

    va_start( Arguments, Format );
    sprintf( szHR, "%08X", hr );

    TrkLogErrorRoutineInternal( DebugFlag, szHR, Format, Arguments );
}


VOID TrkLogErrorRoutineInternal(
    IN      DWORD       DebugFlag,
    IN      LPSTR       pszHR,
    IN      LPTSTR      Format,
    IN      va_list     Arguments
    )

{
//    va_list     arglist;
    ULONG       length = 0;
    DWORD       BytesWritten;
    ULONG       iFormatStart = 0;

    // Skip if TrkDebugCreate hasn't been called yet.
    if( 0 == g_grfLogFlags )
        return;

    //
    // If we aren't debugging this type of message and it's not an
    // error, then we're done.
    //

    if( !( (g_grfDebugFlags | TRKDBG_ERROR ) & DebugFlag ) )
        return;

    //
    //  vsprintf isn't multithreaded + we don't want to intermingle output
    //  from different threads.  Therefore we can use just a single output
    //  debug buffer.
    //

    EnterCriticalSection( &g_csDebugOut );

    //
    // Prefix the line with any newlines
    //

    for( iFormatStart = 0; TEXT('\n') == Format[iFormatStart]; iFormatStart++ )
        g_szDebugBuffer[length++] = '\n';

    //
    // Put our name/time at the beginning of the line.
    //

    CFILETIME cftLocal(0);
    cftLocal.SetToLocal();

    SYSTEMTIME st = static_cast<SYSTEMTIME>( cftLocal );

    length += (ULONG) sprintf( &g_szDebugBuffer[length],
                               "[%s/%02d%02d%02d.%03d:%03x] ",
                               g_szModuleName,
                               st.wHour, st.wMinute, st.wSecond, st.wMilliseconds,
                               GetCurrentThreadId() );

    //
    // Put the information requested by the caller onto the line
    //

    _vstprintf( g_tszDebugBuffer, &Format[iFormatStart], Arguments );
    tcstombs( &g_szDebugBuffer[length], g_tszDebugBuffer );
    length = strlen( g_szDebugBuffer );

    if( NULL != pszHR )
        length += (ULONG) sprintf( &g_szDebugBuffer[length], "  %s", pszHR );

    length += (ULONG) sprintf( &g_szDebugBuffer[length], "\n" );

    TrkAssert(length <= sizeof(g_szDebugBuffer));



    if( TRK_DBG_FLAGS_WRITE_TO_DBG & g_grfLogFlags )
        (void) OutputDebugStringA( (PCH) g_szDebugBuffer);

    if( TRK_DBG_FLAGS_WRITE_TO_STDOUT & g_grfLogFlags )
        printf( (PCH) g_szDebugBuffer );

    if( (TRK_DBG_FLAGS_WRITE_TO_FILE | TRK_DBG_FLAGS_APPEND_TO_FILE) & g_grfLogFlags )
    {
        if ( INVALID_HANDLE_VALUE == g_LogFile
             ||
             !WriteFile( g_LogFile,
                         g_szDebugBuffer,
                         length,
                         &BytesWritten,
                         NULL ) )
        {
            (void) OutputDebugStringA( (PCH) g_szDebugBuffer);
        }

    }


    LeaveCriticalSection( &g_csDebugOut );

}

VOID TrkAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
/*++

    Have my own version of RtlAssert so debug versions of netlogon really assert on
    free builds.

--*/
{
    char Response[ 2 ];

    for ( ; ; ) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, terminate Process, Sleep 30 seconds, or terminate Thread (bipst)? ",
                   Response, sizeof( Response));
        switch ( toupper(Response[0])) {
        case 'B':
            DbgBreakPoint();
            break;
        case 'I':
            return;
            break;
        case 'P':
            NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
            break;
        case 'S':
            Sleep( 30000L);
            break;
        case 'T':
            NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
            break;
        }
    }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
}



typedef void (*PFNWin4AssertEx)( char const *pszFile, int iLine, char const *pszMsg);

VOID TrkAssertFailedDlg(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    static HINSTANCE hinstOLE32 = NULL;
    static PFNWin4AssertEx pfnWin4AssertEx = NULL;

    if( NULL == hinstOLE32 )
    {
        hinstOLE32 = LoadLibraryEx( TEXT("ole32.dll"), NULL, 0 );
        if( NULL == hinstOLE32 )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't load ole32.dll for Win4AssertEx (%#08x)"),
                     GetLastError() ));
            return;
        }
    }

    if( NULL == pfnWin4AssertEx )
    {
        pfnWin4AssertEx = (PFNWin4AssertEx) GetProcAddress( hinstOLE32, "Win4AssertEx" );
        if( NULL == pfnWin4AssertEx )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get Win4AssertEx from ole32.dll (%#08x)"),
                     GetLastError() ));
            return;
        }
    }

    pfnWin4AssertEx( (char*) FileName, (int) LineNumber, (char*) FailedAssertion );

    return;

}



VOID TrkLogRuntimeList( IN PCHAR Comment)
{
    PLIST_ENTRY     pListEntry;

    TrkLog(( TRKDBG_ERROR, TEXT("%s\n"), Comment));
}



HANDLE hTestThread = NULL;

/*
DWORD WINAPI _TestWorkManagerThread(LPVOID pParam)
{
    __try
    {
        ((CWorkManager*) pParam)->WorkManagerThread();
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        TrkAssert(GetExceptionCode() != STATUS_ACCESS_VIOLATION);
    }
    return(0);
}


void
StartTestWorkerThread(CWorkManager * pwm)
{
    DWORD dwThreadId;
    hTestThread = CreateThread( NULL,
                          0,
                          _TestWorkManagerThread,
                          pwm,
                          0,
                          &dwThreadId );
    TrkAssert(hTestThread != NULL);

    // Hack:  make sure the work manager has a chance to init
    Sleep( 500 );

}


void
WaitTestThreadExit()
{
    if (hTestThread != NULL)
    {
        WaitForSingleObject(hTestThread, INFINITE);
        CloseHandle(hTestThread);
    }
}
*/

#endif // #if DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\eventlog.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//-----------------------------------------------------------------------------
//
// File:        eventlog.cxx
//
// Contents:    Utilities to report events.
//
// Histories:   08/06/97 created by weiruc
//
//-----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"
#include "netevent.h"

#define MAX_STRINGS 100

const extern TCHAR*   g_ptszEventSource;



//------------------------------------------------------------------------------
//
// Function:        TrkReportRawEvent
//
// Synopsis:        Report an event using the event logging service.
//                  It's "raw" because an lpRawData parameter may be passed.
//
// Input:           [in]  dwEventId
//                      Event id as defined in eventmsg.h.
//                  [in]  wType
//                      Type of event. Choices are:
//                      EVENTLOG_ERROR_TYPE         Error event 
//                      EVENTLOG_WARNING_TYPE       Warning event 
//                      EVENTLOG_INFORMATION_TYPE   Information event 
//                      EVENTLOG_AUDIT_SUCCESS      Success Audit event 
//                      EVENTLOG_AUDIT_FAILURE      Failure Audit event 
//                  [in]  ...
//                        Any string the caller wants to log.
//
// Requirement:     Because this function does not copy the string parameters
//                  into internal buffers. So the input strings can not be
//                  modified when the function is being called.
//                  The last string parameter passed in MUST be NULL to
//                  mark the end of the argument list. Any arguments passed
//                  in after a NULL argument are going to be ignored.
//
//------------------------------------------------------------------------------

HRESULT TrkReportRawEvent(DWORD dwEventId,
                          WORD wType,
                          DWORD cbRawData,
                          const void *pvRawData,
                          va_list pargs )
{
    HANDLE  hEventLog = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    const TCHAR*  rgtszStrings[MAX_STRINGS];
    WORD    wCounter = 0;

    // initialize the insertion string array
    memset(rgtszStrings, 0, sizeof(rgtszStrings));

    // build the insertion string array
    wCounter = 0;
    while(TRUE)
    {
        if(wCounter >= MAX_STRINGS)
        {
            break;
        }
        rgtszStrings[wCounter] = va_arg(pargs, const TCHAR*);
        if(NULL == rgtszStrings[wCounter])
        {
            break;
        }
        else
        {
            wCounter++;
        }
    }
    va_end(pargs);
    
    // open registry
    hEventLog = RegisterEventSource(NULL, g_ptszEventSource);
    if(NULL == hEventLog)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TrkLog((TRKDBG_ERROR, TEXT("Can't open registry (%s), hr = %08x"),
                g_ptszEventSource, hr));
        goto Exit;
    }

    // write event log
    if(!ReportEvent(hEventLog,
                    wType,
                    0,
                    dwEventId,
                    NULL,
                    wCounter,
                    cbRawData,
                    rgtszStrings,
                    const_cast<void*>(pvRawData) ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TrkLog((TRKDBG_ERROR, TEXT("ReportEvent failed. hr = %08x"), hr));
    }

    // close registry
    if(!DeregisterEventSource(hEventLog) && S_OK == hr)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TrkLog((TRKDBG_ERROR, TEXT("Can't close registry (%s), hr = %08x"),
                g_ptszEventSource, hr));
    }

Exit:

    return hr;
}



//+----------------------------------------------------------------------------
//
//  TrkReportInternalError
//
//  Report an event that should never happen.  The file number and line
//  number are put into the hidden data blob.
//
//+----------------------------------------------------------------------------

HRESULT TrkReportInternalError(DWORD dwFileNo,
                               DWORD dwLineNo,
                               HRESULT hrErrorNo,
                               const TCHAR* ptszData)
{
    HRESULT hr = S_OK;
    TCHAR   tszHr[9];
    struct
    {
        DWORD   dwFileNo;
        DWORD   dwLineNo;
        TCHAR   tszData[ MAX_PATH + 1 ];
    }   sRawData;
    DWORD   cbRawData = 0;

    sRawData.dwFileNo = dwFileNo;
    sRawData.dwLineNo = dwLineNo;

    cbRawData = sizeof(sRawData.dwFileNo) + sizeof(sRawData.dwLineNo);
    if( NULL != ptszData )
    {
        _tcsncpy( sRawData.tszData, ptszData, MAX_PATH );
        cbRawData += 2 * _tcslen( ptszData );
    }

    // build the insertion strings
    _stprintf(tszHr, TEXT("%08x"), hrErrorNo);

    // This is just a special case of TrkReportEvent.
    hr = TrkReportRawEventWrapper( EVENT_TRK_INTERNAL_ERROR,
                                   EVENTLOG_ERROR_TYPE,
                                   cbRawData,
                                   reinterpret_cast<void*>(&sRawData),
                                   tszHr, TRKREPORT_LAST_PARAM );

    

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\oplog.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  oplog.cxx
//
//  Implementation for COperationsLog, which maintains a simple, circular
//  log of events.
//
//+============================================================================


#include "pch.cxx"
#pragma hdrstop

#ifndef NO_OPLOG

#include "trklib.hxx"

#define OPERATION_LOG_SIZE  ( (( (1024*1024) - sizeof(SHeader) )/sizeof(SRecord))*sizeof(SRecord) + sizeof(SHeader) )
#define OPERATION_LOG_RECORD_COUNT  ( (OPERATION_LOG_SIZE - sizeof(SHeader)) / sizeof(SRecord) )


//+----------------------------------------------------------------------------
//
//  COperationLog::InitializeLogFile
//
//  Initialize the operations log file.  This is called lazily so that we don't
//  impact service start (and don't get called unless the oplog is turned on).
//
//+----------------------------------------------------------------------------

HRESULT
COperationLog::InitializeLogFile(  )
{
    HRESULT hr = E_FAIL;
    ULONG cbFile = 0;

    _iRecord = 0;

    Lock();

    __try
    {
        BY_HANDLE_FILE_INFORMATION FileInfo;

        _fLogFileInitialized = TRUE;

        TrkLog(( TRKDBG_VOLUME, TEXT("Initializing operation log file (%s)"), _ptszOperationLog ));

        // Loop twice, if we find a problem the first time, we'll delete and
        // try again.

        for( int i = 0; i < 2; i++ )
        {
            if( INVALID_HANDLE_VALUE != _hFile )
                CloseHandle( _hFile );

            // Open/create the file on the first pass, create it on the second pass.

            _hFile = CreateFile( _ptszOperationLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_DELETE, NULL,
                                 0 == i ? OPEN_ALWAYS : CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE );
            if( INVALID_HANDLE_VALUE == _hFile )
            {
                TrkLog(( TRKDBG_WARNING, TEXT("Couldn't create/open status log file (%lu)"),
                         GetLastError() ));
                TrkRaiseLastError();
            }

            // On the first pass, check the file to see if it looks valid.
            // If not, continue the loop so that a new file can be created.

            if( 1 == i )
                cbFile = 0;
            else
            {
                // All we check is the size.  There's no support for trying
                // to migrate a file if we change the file size.

                if( !GetFileInformationByHandle( _hFile, &FileInfo ))
                {
                    TrkLog(( TRKDBG_WARNING, TEXT("Couldn't get status file info") ));
                    TrkRaiseLastError();
                }
                if( 0 != FileInfo.nFileSizeHigh )
                {
                    TrkLog(( TRKDBG_WARNING, TEXT("Operation file to big") ));
                    continue;
                }
                else if( 0 != FileInfo.nFileSizeLow
                         &&
                         OPERATION_LOG_SIZE != FileInfo.nFileSizeLow )
                {
                    TrkLog(( TRKDBG_WARNING, TEXT( "Operation log file wrong size") ));
                    continue;
                }
                cbFile = FileInfo.nFileSizeLow;
            }
        }

        // Create a mapping of the file.

        _hFileMapping = CreateFileMapping( _hFile, NULL, PAGE_READWRITE, 0, OPERATION_LOG_SIZE, NULL );
        if( INVALID_HANDLE_VALUE == _hFileMapping )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't create status log file mapping (%lu)"), GetLastError() ));
            TrkRaiseLastError();
        }

        // And map a view of the file.

        _pHeader = (SHeader*) MapViewOfFile( _hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, OPERATION_LOG_SIZE );
        if( NULL == _pHeader )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't map view of status log file (%lu)"),
                     GetLastError() ));
            TrkRaiseLastError();
        }

        // If we opened an existing file, validate the shutdown and version.
        // If anything looks wrong, or if this file is new, zero it out.

        if( 0 == cbFile
            ||
            0 == (_pHeader->grfFlags & PROPER_SHUTDOWN)
            ||
            OPERATION_LOG_VERSION != _pHeader->dwVersion )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Re-initializing operation log file") ));
            _iRecord = 0;
            memset( _pHeader, 0, OPERATION_LOG_SIZE );
            _pHeader->dwVersion = OPERATION_LOG_VERSION;
        }
        else
            _iRecord = _pHeader->iRecord;

        // Show that the file isn't properly shut down.

        _pHeader->grfFlags &= ~PROPER_SHUTDOWN;
        _prgRecords = (SRecord*) ( (BYTE*)_pHeader + sizeof(SHeader) );
        Flush();

        TrkLog(( TRKDBG_VOLUME, TEXT("Status log starts at index %d"), _iRecord ));
        hr = S_OK;

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }


    Unlock();
    return( hr );
}



//+----------------------------------------------------------------------------
//
//  COperationsLog::Flush
//
//  Flush the operations log to disk.
//
//+----------------------------------------------------------------------------

void
COperationLog::Flush()
{
    __try
    {
        if( !_fLogFileInitialized )
            __leave;

        _pHeader->iRecord = _iRecord;

        if( NULL != _pHeader && !FlushViewOfFile( _pHeader, OPERATION_LOG_SIZE ))
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't flush operation log file view") ));
        }
        if( INVALID_HANDLE_VALUE != _hFile && !FlushFileBuffers( _hFile ))
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't flush operation log file") ));
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in COpLog::Flush (0x%08x)"),
                 GetExceptionCode() ));
    }
}



//+----------------------------------------------------------------------------
//
//  COperationLog::InternalAdd
//
//  Add an entry to the operation log.
//
//+----------------------------------------------------------------------------

void
COperationLog::InternalAdd( DWORD dwOperation, HRESULT hr, const CMachineId &mcidSource,
                               DWORD dwExtra0, DWORD dwExtra1, DWORD dwExtra2, DWORD dwExtra3,
                               DWORD dwExtra4, DWORD dwExtra5, DWORD dwExtra6, DWORD dwExtra7 )
{
    ULONG iFile = 0;
    ULONG cbWritten = 0;

    Lock();
    __try
    {
        // Lazy initialization of the log file.

        if( !_fLogFileInitialized )
        {
            if( FAILED( InitializeLogFile() ))
                __leave;
        }

        // Ensure we have valid mappings.

        if( NULL == _pHeader || NULL == _prgRecords )
            __leave;

        // Add the data to the next record.

        _prgRecords[_iRecord].dwOperation = dwOperation;
        _prgRecords[_iRecord].ftOperation = CFILETIME();
        _prgRecords[_iRecord].mcidSource = mcidSource;
        _prgRecords[_iRecord].hr = hr;

        _prgRecords[_iRecord].rgdwExtra[0] = dwExtra0;
        _prgRecords[_iRecord].rgdwExtra[1] = dwExtra1;
        _prgRecords[_iRecord].rgdwExtra[2] = dwExtra2;
        _prgRecords[_iRecord].rgdwExtra[3] = dwExtra3;
        _prgRecords[_iRecord].rgdwExtra[4] = dwExtra4;
        _prgRecords[_iRecord].rgdwExtra[5] = dwExtra5;
        _prgRecords[_iRecord].rgdwExtra[6] = dwExtra6;
        _prgRecords[_iRecord].rgdwExtra[7] = dwExtra7;

        // Advance the seek pointer.

        _iRecord++;
        if( OPERATION_LOG_RECORD_COUNT == _iRecord )
        {
            _iRecord = 0;
            TrkLog(( TRKDBG_VOLUME, TEXT("Wrapping operation log") ));
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in COpLog::InternalAdd (0x%08x)"),
                 GetExceptionCode() ));
    }


    Unlock();
}


#endif // #ifndef NO_OPLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\rpccbind.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       RpcCBind.cxx
//
//  Contents:   CRpcClientBinding, which wraps a client-side RPC
//              binding handle.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     CRpcClientBinding::RcInitialize
//
//  Synopsis:   Create a binding handle to the caller-provided
//              machine/protocol/endpoint.  If requested, set security too.
//
//+----------------------------------------------------------------------------

void
CRpcClientBinding::RcInitialize(const CMachineId &mcid,
                                const TCHAR *ptszRpcProtocol, const TCHAR *ptszRpcEndPoint,
                                RC_AUTHENTICATE auth )
{
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_TCHAR   tszComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];

    TrkAssert(!_fBound);

    // Get the name of the computer to which we're binding.

    mcid.GetName(tszComputerName, sizeof(tszComputerName)/sizeof(tszComputerName[0]));

    // Create the binding string that encapsulates the target machine, protocol,
    // and endpoint.

    rpcstatus = RpcStringBindingCompose(NULL,
                                        const_cast<TCHAR*>(ptszRpcProtocol),
                                        tszComputerName,
                                        const_cast<TCHAR*>(ptszRpcEndPoint),
                                        NULL,
                                        &ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        TrkRaiseWin32Error( rpcstatus );
    }

    // Get a binding handle from the binding string.

    rpcstatus = RpcBindingFromStringBinding(ptszStringBinding, &_BindingHandle);
    RpcStringFree(&ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        TrkRaiseWin32Error( rpcstatus );
    }

    // If necessary, set security on the binding

    if( RpcSecurityEnabled() && NO_AUTHENTICATION != auth )
    {
        TrkAssert( PRIVACY_AUTHENTICATION == auth || INTEGRITY_AUTHENTICATION == auth );

        RPC_TCHAR tszAuthName[MAX_COMPUTERNAME_LENGTH * 2 + 2 + 1]; // slash and $ and NUL
        
        mcid.GetLocalAuthName(tszAuthName, sizeof(tszAuthName)/sizeof(tszAuthName[0]));

        rpcstatus = RpcBindingSetAuthInfo(_BindingHandle,
                       tszAuthName,
                       PRIVACY_AUTHENTICATION == auth
                          ? RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                          : RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                       RPC_C_AUTHN_GSS_NEGOTIATE,
                       NULL,    // AuthIdentity - current process/address space
                       0);      // AuthzSvc - ignored for RPC_C_AUTHN_DCE_PRIVATE

        if( rpcstatus )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingSetAuthInfo %lu"), rpcstatus ));
            TrkRaiseWin32Error( rpcstatus );
        }
    }   // if( RpcSecurityEnabled() )

    _fBound = TRUE;
}


//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Synopsis:   Free a binding.
//
//+----------------------------------------------------------------------------

void
CRpcClientBinding::UnInitialize()
{
    if (_fBound)
    {
        RpcBindingFree(&_BindingHandle);
        _fBound = FALSE;
    }

    CTrkRpcConfig::UnInitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\svcctrl.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       svcctrl.cxx
//
//  Contents:   Class for service control interface.
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"

#define THIS_FILE_NUMBER    SVCCTRL_CXX_FILE_NO


// This is static so that we can handle a PNP timing problem
// (see the comment in CSvcCtrlInterface::ServiceHandler).
BOOL CSvcCtrlInterface::_fStoppedOrStopping = TRUE;


//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::Initialize
//
//  Register our service control handler with the control dispatcher, and set our state
//  to start-pending.
//
//+----------------------------------------------------------------------------

void
CSvcCtrlInterface::Initialize(const TCHAR *ptszServiceName, IServiceHandler *pServiceHandler)
{
    _fInitializeCalled = TRUE;
    _pServiceHandler = pServiceHandler;
    _fStoppedOrStopping = FALSE;
    _dwCheckPoint = 0;

    // Register with the control dispatcher.

    _ssh = RegisterServiceCtrlHandlerEx(ptszServiceName, ServiceHandler, this );
    if (_ssh == 0)
    {
        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(GetLastError()),
                                ptszServiceName );
        TrkRaiseLastError();
    }

    // Go to the start-pending state.

    SetServiceStatus(SERVICE_START_PENDING, 0, NO_ERROR);

}



//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::ServiceHandler
//
//  This method is called by the control dispatcher.  If we get a stop
//  or shutdown request, automatically send a stop-pending before calling
//  the service's handler.  Interrogate is handled automatically in
//  this routine without bothering to call the service.
//
//+----------------------------------------------------------------------------

DWORD   // static
CSvcCtrlInterface::ServiceHandler(DWORD dwControl,
                                  DWORD dwEventType,
                                  PVOID EventData,
                                  PVOID pData)
{
    //  NOTE:   In services.exe, this method is called on the one and only ServiceHandler
    //          thread.  So while we execute, no other service in this process can
    //          receive notifications.  Thus it is important that we do nothing
    //          blocking or time-consuming here.

    DWORD       dwRet = NO_ERROR;
    CSvcCtrlInterface *pThis = (CSvcCtrlInterface*)pData;

#if DBG
    if( SERVICE_CONTROL_STOP == dwControl )
        TrkLog(( TRKDBG_SVR|TRKDBG_WKS, TEXT("\n") ));
    TrkLog(( TRKDBG_SVR|TRKDBG_WKS,
             TEXT("ServiceHandler(%s)"),
             StringizeServiceControl(dwControl) ));
#endif

    // On a stop or shutdown, flag it (e.g. so we don't try to accept new
    // requests from clients) and tell the SCM that we're stopping.

    switch (dwControl)
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:
        pThis->SetServiceStatus(SERVICE_STOP_PENDING, 0, NO_ERROR);
        _fStoppedOrStopping = TRUE;

        break;
    }

    // Check for PNP timing issues.  The problem is that during a stop
    // or shutdown, we unregister with PNP so that we don't get any more
    // notifications.  This is fine, except that between now and the time
    // we do that unregister, more PNP notifications might get queued.  So
    // when we get called to process those undesired notifications, we need
    // to ignore them here in the static function.
    //
    // As a quick fix, since only trkwks receives PNP notifications, we'll
    // just check to see if it's alive.  A better fix (raided) is to have
    // a static function for each service, so that only the trkwks has to
    // deal with it.

    if( SERVICE_CONTROL_DEVICEEVENT == dwControl && _fStoppedOrStopping )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring SERVICE_CONTROL_DEVICEEVENT; service is stopped") ));
        return dwRet;
    }


    // Call this service's service handler.  As a final safety measure,
    // catch any exceptions (there should be none).  We must be sure that we don't
    // kill this thread, since it's shared by everyone in services.exe.

    __try
    {
        dwRet = pThis->_pServiceHandler->ServiceHandler(dwControl, dwEventType, EventData, pData);

        switch (dwControl)
        {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            break;
        case SERVICE_CONTROL_PAUSE:
            pThis->SetServiceStatus(SERVICE_PAUSED, pThis->_dwControlsAccepted, NO_ERROR);
            break;
        case SERVICE_CONTROL_CONTINUE:
            pThis->SetServiceStatus(SERVICE_RUNNING, pThis->_dwControlsAccepted, NO_ERROR);
            break;
        case SERVICE_CONTROL_INTERROGATE:
            pThis->SetServiceStatus(pThis->_dwState, pThis->_dwControlsAccepted, NO_ERROR);
            break;
        case SERVICE_CONTROL_DEVICEEVENT:
            break;
        }
    }
    __except( BREAK_THEN_RETURN( EXCEPTION_EXECUTE_HANDLER ))
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("Unexpected exception in CSvcCtrlInterface::ServiceHandler (%08x)"),
                 GetExceptionCode() ));
        dwRet = ERROR_EXCEPTION_IN_SERVICE;
    }

    return dwRet;
}


//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::SetServiceStatus
//
//  Send a SetServiceStatus to the SCM.  The checkpoint is automatically
//  maintained by this class.
//
//+----------------------------------------------------------------------------

void
CSvcCtrlInterface::SetServiceStatus(DWORD dwState, DWORD dwControlsAccepted, DWORD dwWin32ExitCode)
{
    SERVICE_STATUS ss;

    _dwState = dwState;
    _dwControlsAccepted = dwControlsAccepted;

    if( SERVICE_START_PENDING != dwState
        &&
        SERVICE_STOP_PENDING != dwState )
    {
        _dwCheckPoint = 0;
    }

    ss.dwServiceType = SERVICE_WIN32;   // XX_SC
    ss.dwCurrentState = _dwState;
    ss.dwControlsAccepted = _dwControlsAccepted;
    ss.dwWin32ExitCode = dwWin32ExitCode;
    ss.dwServiceSpecificExitCode = 0;
    ss.dwCheckPoint = _dwCheckPoint++;
    ss.dwWaitHint = DEFAULT_WAIT_HINT;

    if (_ssh != 0)
    {
        if( !::SetServiceStatus(_ssh, &ss) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("SetServiceStatus(%s) failed, gle=%lu"),
                     (const TCHAR*)CDebugString(SServiceState(dwState)), GetLastError() ));
        }
        else
        {
            TrkLog(( TRKDBG_MISC, TEXT("SetServiceStatus(%s)"),
                     (const TCHAR*)CDebugString(SServiceState(dwState)) ));
        }
    }
}


//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::UpdateWaitHint
//
//  Send a non-default wait hint to the SCM.
//
//+----------------------------------------------------------------------------

void
CSvcCtrlInterface::UpdateWaitHint(DWORD dwMilliseconds)
{
    SERVICE_STATUS ss;

    ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ss.dwCurrentState = _dwState;
    ss.dwControlsAccepted = _dwControlsAccepted;
    ss.dwWin32ExitCode = NO_ERROR;
    ss.dwServiceSpecificExitCode = 0;
    ss.dwCheckPoint = _dwCheckPoint++;
    ss.dwWaitHint = dwMilliseconds;

    if (_ssh != 0)
        ::SetServiceStatus(_ssh, &ss);
}



//+----------------------------------------------------------------------------
//
//  StringizeServiceControl (debug only)
//
//+----------------------------------------------------------------------------

#if DBG
TCHAR * StringizeServiceControl( DWORD dwControl )
{
    switch( dwControl )
    {
    case SERVICE_CONTROL_STOP:
        return TEXT("SERVICE_CONTROL_STOP");

    case SERVICE_CONTROL_PAUSE:
        return TEXT("SERVICE_CONTROL_PAUSE");

    case SERVICE_CONTROL_CONTINUE:
        return TEXT("SERVICE_CONTROL_CONTINUE");

    case SERVICE_CONTROL_INTERROGATE:
        return TEXT("SERVICE_CONTROL_INTERROGATE");

    case SERVICE_CONTROL_SHUTDOWN:
        return TEXT("SERVICE_CONTROL_SHUTDOWN");

    case SERVICE_CONTROL_PARAMCHANGE:
        return TEXT("SERVICE_CONTROL_PARAMCHANGE");

    case SERVICE_CONTROL_NETBINDADD:
        return TEXT("SERVICE_CONTROL_NETBINDADD");

    case SERVICE_CONTROL_NETBINDREMOVE:
        return TEXT("SERVICE_CONTROL_NETBINDREMOVE");

    case SERVICE_CONTROL_NETBINDENABLE:
        return TEXT("SERVICE_CONTROL_NETBINDENABLE");

    case SERVICE_CONTROL_NETBINDDISABLE:
        return TEXT("SERVICE_CONTROL_NETBINDDISABLE");

    case SERVICE_CONTROL_DEVICEEVENT:
        return TEXT("SERVICE_CONTROL_DEVICEEVENT");

    default:
        return TEXT("Unknown");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\rpccfg.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  rpccfg.cxx
//  
//  Base class for CRpcServer and CRpcClientBinding, which provides
//  reg-based configuration support.
//
//=============================================================================


#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"


BOOL CTrkRpcConfig::_fInitialized = FALSE;
CMultiTsz CTrkRpcConfig::_mtszCustomDcName;
CMultiTsz CTrkRpcConfig::_mtszCustomSecureDcName;

CTrkRpcConfig::CTrkRpcConfig()
{
    // This isn't thread-safe because it's not worth the expense;
    // if multiple threads load this data, they'll each load the
    // same data anyway.

    if( !_fInitialized )
    {
        CTrkConfiguration::Initialize( );

        Read( CUSTOM_DC_NAME_NAME, &_mtszCustomDcName, CUSTOM_DC_NAME_DEFAULT );
        Read( CUSTOM_SECURE_DC_NAME_NAME, &_mtszCustomSecureDcName, CUSTOM_SECURE_DC_NAME_DEFAULT );

        _fInitialized = TRUE;

        CTrkConfiguration::UnInitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\rpcsvr.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  rpcsvr.cxx
//
//  Implementation of CRpcServer, with the common code to support
//  trkwks & trksvr RPC servers.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"

#define THIS_FILE_NUMBER    RPCSVR_CXX_FILE_NO

//+----------------------------------------------------------------------------
//
//  CRpcServer::Initialize
//
//  Initialize the CRpcServer base class.  Before calling this
//  method, a derivation should perform all of its necessary
//  RpcUseProtseq calls.
//
//  If a ptszProtSeqForEpRegistration is specified, find the
//  binding handle for that protocol and register this interface
//  just with that binding.
//
//+----------------------------------------------------------------------------

void
CRpcServer::Initialize(RPC_IF_HANDLE ifspec,
                       ULONG grfRpcServerRegisterInterfaceEx,
                       UINT cMaxCalls,
                       BOOL fSetAuthInfo,
                       const TCHAR *ptszProtSeqForEpRegistration )
{
    RPC_STATUS          rpcstatus;
    RPC_BINDING_VECTOR *pBindingVector = NULL;
    TCHAR              *ptszStringBinding = NULL;
    TCHAR              *ptszProtSeq = NULL;

    _ifspec = ifspec;
    _fEpRegister = NULL != ptszProtSeqForEpRegistration;

    __try
    {
        // If required, set authentication information

        if( RpcSecurityEnabled() && fSetAuthInfo )
        {

            RPC_TCHAR tszAuthName[MAX_COMPUTERNAME_LENGTH * 2 + 2 + 1]; // slash and $ and NUL
            CMachineId mcid(MCID_LOCAL);

            // Get the authentiation name, e.g. domain\machine$
            mcid.GetLocalAuthName(tszAuthName, sizeof(tszAuthName)/sizeof(tszAuthName[0]));

            // Set the auth info.  We set it to negotiate, but we'll always get Kerberos.
            rpcstatus = RpcServerRegisterAuthInfo(
                tszAuthName,
                RPC_C_AUTHN_GSS_NEGOTIATE,
                NULL,   // RPC_AUTH_KEY_RETRIEVAL_FN,
                NULL ); // Arg );

            if (rpcstatus)
            {
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                        HRESULT_FROM_WIN32(rpcstatus), tszAuthName );
                TrkRaiseWin32Error(rpcstatus);
            }
        }

        // If using dynamic enpoints, register in the endpoint mapper
        // for the first binding handle for the specified protocol sequence.

        if( _fEpRegister )
        {

            // Query for the currently active binding handles

            rpcstatus = RpcServerInqBindings(&pBindingVector);
            if (rpcstatus)
            {
                TrkLog((TRKDBG_ERROR, TEXT("RpcServerInqBindings %08x"), rpcstatus));
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                        HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                TrkRaiseWin32Error(rpcstatus);
            }

            // Loop through the binding handles, looking for the first one with
            // the required protocol sequence.

            for( ULONG i = 0; i < pBindingVector->Count; i++ )
            {
                // Stringize the binding handle.

                rpcstatus = RpcBindingToStringBinding( pBindingVector->BindingH[i],
                                                       &ptszStringBinding );
                if( RPC_S_OK != rpcstatus )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("RpcBindingToStringBinding %08x"), rpcstatus ));
                    TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                    TrkRaiseWin32Error(rpcstatus);
                }

                // Parse the binding string for the protseq

                rpcstatus = RpcStringBindingParse( ptszStringBinding, NULL,
                                                   &ptszProtSeq,
                                                   NULL, NULL, NULL );
                if( RPC_S_OK != rpcstatus )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("RpcStringBindingParse %08x"), rpcstatus ));
                    TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                    TrkRaiseWin32Error(rpcstatus);
                }

                // See if this protseq is that which we seek

                if( 0 == _tcscmp( ptszProtSeq, ptszProtSeqForEpRegistration ))
                {
                    // We have a match.  Register against this binding handle.

                    RPC_BINDING_VECTOR PartialBindingVector;
                    PartialBindingVector.Count = 1;
                    PartialBindingVector.BindingH[0] = pBindingVector->BindingH[i];

                    rpcstatus = RpcEpRegister(ifspec, &PartialBindingVector, NULL, NULL);
                    if( RPC_S_OK != rpcstatus )
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("RpcEpRegister %08x"), rpcstatus));
                        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                        TrkRaiseWin32Error(rpcstatus);
                    }
                    else
                        TrkLog(( TRKDBG_MISC, TEXT("RpcEpRegister on %s"), ptszStringBinding ));
                    break;
                }

                RpcStringFree( &ptszStringBinding );
                ptszStringBinding = NULL;
                RpcStringFree( &ptszProtSeq );
                ptszProtSeq = NULL;
            }

            if( i == pBindingVector->Count )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't find protseq %s in binding vector"),
                        ptszProtSeqForEpRegistration ));
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                TrkRaiseWin32Error( HRESULT_FROM_WIN32(RPC_S_NO_PROTSEQS_REGISTERED) );
            }

        }   // if( _fEpRegister )

        // Finally, register the server interface

        rpcstatus = RpcServerRegisterIfEx(ifspec, NULL, NULL,
                                          grfRpcServerRegisterInterfaceEx,
                                          cMaxCalls, NULL );
                                      
        if (rpcstatus != RPC_S_OK && rpcstatus != RPC_S_TYPE_ALREADY_REGISTERED)
        {
            TrkLog((TRKDBG_ERROR, TEXT("RpcServerRegisterIf %08x"), rpcstatus));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                    HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
            TrkRaiseWin32Error(rpcstatus);
        }
    }
    __finally
    {
        if( NULL != pBindingVector )
            RpcBindingVectorFree( &pBindingVector );
        if( NULL != ptszStringBinding )
            RpcStringFree( &ptszStringBinding );
        if( NULL != ptszProtSeq )
            RpcStringFree( &ptszProtSeq );
    }

}


//+----------------------------------------------------------------------------
//
//  CRpcServer::UnInitialize
//
//  Unregister the interface, and if necessary unregister the endpoints.
//
//+----------------------------------------------------------------------------

void
CRpcServer::UnInitialize()
{
    RPC_STATUS          rpcstatus;
    RPC_BINDING_VECTOR *pBindingVector = NULL;

    if (_ifspec == NULL)
        return;

    // If we registered with the endpoint mapper, unreg now.

    if( _fEpRegister )
    {
        // Ignore any errors; we should still unregister the interface
        // no matter what.

        rpcstatus = RpcServerInqBindings(&pBindingVector);
        if (rpcstatus)
        {
            TrkLog((TRKDBG_ERROR, TEXT("RpcServerInqBindings %08x"), rpcstatus));
        }
        else
        {
            rpcstatus = RpcEpUnregister(_ifspec, pBindingVector, NULL);
            RpcBindingVectorFree( &pBindingVector );
            if( RPC_S_OK != rpcstatus && EPT_S_NOT_REGISTERED != rpcstatus )
            {
                TrkLog((TRKDBG_ERROR, TEXT("RpcEpUnregister %08x"), rpcstatus));
            }
        }
    }
    
    // Unregister the interface

    rpcstatus = RpcServerUnregisterIf(_ifspec, NULL, 1 /* wait for calls */);
    if (rpcstatus != RPC_S_OK)
    {
        TrkLog((TRKDBG_ERROR, TEXT("RpcServerUnregisterIf %08x"), rpcstatus));
        //TrkRaiseWin32Error(rpcstatus);
    }

    CTrkRpcConfig::UnInitialize();

    _ifspec = NULL;
    _fEpRegister = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\timer.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       timer.cxx
//
//  Contents:   Code for a timer.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "trklib.hxx"

BOOL
LoadPersistentFileTime(
    const TCHAR * ptszStaticRegName,
    CFILETIME * pcft
    );

void
UpdatePersistentFileTime(
    const TCHAR * ptszStaticRegName,
    const CFILETIME & cft
    );

void
RemovePersistentFileTime(
    const TCHAR * ptszStaticRegName
    );



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::Initiliaze
//
//  Synopsis:   Initialize the object and create the timer but don't set it
//              yet.
//
//  Inputs:     [pTimerCallback] (in)
//                  Who to call when the timer fires.
//              [pWorkManager] (in)
//                  The WorkManager with which the timer will be registered
//              [ptszName] (in, optional)
//                  If specified, the timer is persistent, and the name is
//                  used to store the timer information in the registry.
//                  If not specified the timer is not persistent.
//                  If data already exists in the registry for this name, it
//                  is used the next time the timer is set.
//              [ulTimerContext] (in)
//                  Passed to pTimerCallback->Timer.
//              [ulPeriodInSeconds] (in)
//                  The length of this timer when it's set.
//              [retrytype] (in)
//                  From the TimerRetryType enumeration.  Can 
//                  be no_retry, retry_randomly, or retry_with_backoff.
//              [ulLowerRetryTime] (in)
//                  Only valid when retrytype isn't no_retry.
//              [ulUpperRetryTime] (in)
//                  Only valid when retrytype isn't no_retry.
//              [ulMaxLifetime] (in)
//                  Only valid when retrytype isn't no_retry.
//
//  Returns:    Void
//
//+----------------------------------------------------------------------------

void
CNewTimer::Initialize( PTimerCallback *pTimerCallback,
                       const TCHAR *ptszName,
                       ULONG ulTimerContext,
                       ULONG ulPeriodInSeconds,
                       TimerRetryType retrytype,
                       ULONG ulLowerRetryTime,
                       ULONG ulUpperRetryTime,
                       ULONG ulMaxLifetime )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CFILETIME cftLastTimeSet;


    TrkAssert( ulLowerRetryTime <= ulUpperRetryTime );
    TrkAssert( NO_RETRY == retrytype
               ||
               0 != ulLowerRetryTime
               &&
               0 != ulUpperRetryTime );
    TrkAssert( NO_RETRY != retrytype || 0 == ulMaxLifetime );

    // Initialize our critical section.  _fIntitializeCalled is used to 
    // indicate that this has been done.

    _cs.Initialize();
    _fInitializeCalled = TRUE;

    // Keep the parameters

    _pTimerCallback = pTimerCallback;
    _ptszName = ptszName;
    _ulTimerContext = ulTimerContext;
    _ulPeriodInSeconds = ulPeriodInSeconds;
    _RetryType = retrytype;
    _ulLowerRetryTime = ulLowerRetryTime;
    _ulUpperRetryTime = ulUpperRetryTime;
    _ulMaxLifetime = ulMaxLifetime;

#if DBG
    // Set the workitem signature for use in debug outputs.
    _stprintf( _tszWorkItemSig, TEXT("CTimer:%p"), this );
    if( NULL != ptszName )
    {
        _tcscat( _tszWorkItemSig, TEXT("/") );
        _tcscat( _tszWorkItemSig, ptszName );
    }
    TrkAssert( _tcslen(_tszWorkItemSig) < ELEMENTS(_tszWorkItemSig) );
#endif

    // Create the NT timer.

    Status = NtCreateTimer(
                &_hTimer,
                TIMER_ALL_ACCESS,
                NULL,
                SynchronizationTimer );  // this sort of timer becomes un-signalled
                                         // when a wait is satisfied
    if (!NT_SUCCESS(Status))
    {
        _hTimer = NULL;
        TrkRaiseNtStatus(Status);
    }

    // If this is a persistent timer, load the persisted state from the
    // registry.

    LoadFromRegistry();

    // Register a work item with the Win32 thread pool.

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hTimer, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTELONGFUNCTION | WT_EXECUTEDEFAULT );

    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CNewTimer::Initialize (%lu) for %s)"),
                 GetLastError(),  GetTimerName() ));
        TrkRaiseLastError();
    }
    else
        TrkLog(( TRKDBG_TIMER, TEXT("Registered timer %s with thread pool (%p/%p)"),
                 GetTimerName(), this, *reinterpret_cast<UINT_PTR*>(this) ));

}   // CNewTimer::Initialize


//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::SetTimer
//
//  Synopsis:   Start the timer.  If _cftDue isn't already set, we'll use
//              _ulPeriodInSeconds (or _ulCurrentRetryTime) to set it.  If this
//              is a persistent timer, the registry is updated.
//
//+----------------------------------------------------------------------------

void
CNewTimer::SetTimer()
{
    NTSTATUS Status;
    CFILETIME cftNow, cftMax(0);

    TrkAssert(NULL != _hTimer);
    TrkAssert(sizeof(LARGE_INTEGER) == sizeof(_cftDue));


    // If we're already running and not in retry mode, then there's nothing
    // to be done.

    if( _fRunning && 0 == _ulCurrentRetryTime )
        return;

    // Has the due time already been determined?
    if( 0 == _cftDue )
    {
        // Are we in retry mode?
        if( 0 != _ulCurrentRetryTime )
        {
            _cftDue = cftNow;
            _cftDue.IncrementSeconds( _ulCurrentRetryTime );
        }
        else
        {
            _cftDue = cftNow;
            _cftDue.IncrementSeconds( _ulPeriodInSeconds );
            _cftSet = cftNow;
        }
    }

    // We already have a non-zero due time.  That doesn't mean that we're running,
    // though, it might be a persistent timer that's been initialized but not
    // started.

    else if( _fRunning )
    {
        TrkAssert( 0 != _ulCurrentRetryTime );

        // This timer was in retry mode but is now being started again.
        // Restart as if it was being started for the first time.

        _ulCurrentRetryTime = 0;
        _cftDue = _cftSet = cftNow;
        _cftDue.IncrementSeconds( _ulPeriodInSeconds );
    }

    if( 0 < _ulMaxLifetime )
    {
        cftMax = _cftSet;
        cftMax.IncrementSeconds( _ulMaxLifetime );

        if( cftNow > cftMax )
        {
            TrkLog(( TRKDBG_TIMER, TEXT("Stopping timer %s/%p due to liftime limit"),
                     (NULL == _ptszName) ? TEXT("") : _ptszName,
                     this ));
            Cancel();
            return;
        }

        else if( _cftDue > cftMax )
        {
            TrkLog(( TRKDBG_TIMER, TEXT("Shortening timer %s/%p due to lifetime limit"),
                     (NULL == _ptszName) ? TEXT("") : _ptszName,
                     this ));
            _cftDue = cftMax;
        }
    }

    SaveToRegistry();

    // Set the timer, but not if it's currently firing.  When the timer
    // fires, the DoWork method is called, but that method doesn't hold
    // the lock while it calls the Timer callback.  Thus, if 
    // _fTimerSignalInProgress is true, some other thread is currently
    // in the callback.  When it complets, it will set this timer.

    if( !_fTimerSignalInProgress )
    {
        Status = NtSetTimer ( _hTimer, //IN HANDLE TimerHandle,
                              (LARGE_INTEGER*) &_cftDue,      //IN PLARGE_INTEGER DueTime,
                              NULL,    //IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
                              NULL,    //IN PVOID TimerContext OPTIONAL,
                              FALSE,   //IN BOOLEAN ResumeTimer,
                              0,       //IN LONG Period OPTIONAL,
                              NULL );  //OUT PBOOLEAN PreviousState OPTIONAL
        TrkAssert(NT_SUCCESS(Status));
    }

    _fRunning = TRUE;

}   // CNewTimer::SetTimer



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::Cancel
//
//  Synopsis:   Cancel the timer and remove its persistent state from the
//              registry (if it's a persistent timer).
//
//+----------------------------------------------------------------------------

void
CNewTimer::Cancel()
{
    NTSTATUS Status;

    TrkAssert( _fInitializeCalled );

    Lock();
    __try
    {
        Status = NtCancelTimer(_hTimer, NULL);
        TrkAssert(NT_SUCCESS(Status));

        _fRunning = FALSE;
        _ulCurrentRetryTime = 0;
        _cftDue = _cftSet = 0;

        RemoveFromRegistry();

    }
    __finally
    {
        Unlock();
    }

}



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::DebugStringize
//
//  Synopsis:   Stringize the current state of the timer.
//
//+----------------------------------------------------------------------------

#if DBG
void
CNewTimer::DebugStringize( ULONG cch, TCHAR *ptsz ) const
{
    ULONG cchUsed = 0;
    TCHAR *ptszTimerState;

    TrkAssert( _fInitializeCalled );

    Lock();
    __try
    {
        if( _fRunning )
        {
            if( 0 != _ulCurrentRetryTime )
                ptszTimerState = TEXT("retrying");
            else
                ptszTimerState = TEXT("running");
        }
        else
            ptszTimerState = TEXT("stopped");

        cchUsed = _stprintf( ptsz, TEXT("Timer %s/%p is %s "), 
                                   NULL == _ptszName ? TEXT("") : _ptszName,
                                   this,  ptszTimerState );

        if( _fRunning )
        {
            LONGLONG llDelta;
            llDelta = static_cast<LONGLONG>(_cftDue - CFILETIME()) / (10*1000*1000);

            if( 0 <= llDelta && 120 >= llDelta )
                cchUsed += _stprintf( &ptsz[cchUsed], TEXT("(expires in %I64i seconds)"), llDelta );
            else
            {
                cchUsed += _stprintf( &ptsz[cchUsed], TEXT("(expires on ") );
                _cftDue.Stringize( cch-cchUsed, &ptsz[cchUsed] );
                cchUsed += _tcslen( &ptsz[cchUsed] );
                cchUsed += _stprintf( &ptsz[cchUsed], TEXT(" UTC)") );
            }
        }

        TrkAssert( cch >= cchUsed );
    }
    __finally
    {
        Unlock();
    }
}
#endif



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::DoWork
//
//  Synopsis:   This method is called by the work manager when the NT timer
//              is signaled.  We call pTimerCallback->Timer so that the timer
//              event can be handled.  That Timer method returns a status
//              that tells us what we should do next.  The returned status
//              is a TimerContinuation, that can be Continue (causes
//              a recurring timer to be set again), Break (causes a recurring
//              timer to be stopped), or Retry.
//
//+----------------------------------------------------------------------------

void
CNewTimer::DoWork()
{
    TrkAssert( _fInitializeCalled );

    PTimerCallback::TimerContinuation continuation;

    Lock();
    {
        // We were obviously running recently, or we wouldn't have been called.
        // But if we're not running now, we must have been canceled after the 
        // timer object was signaled (waking the WaitForMultiple) but before
        // entry into this routine.

        if( !_fRunning )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Timer %s/%p stopped while firing"),
                     NULL == _ptszName ? TEXT("") : _ptszName,
                     this ));
            Unlock();
            return;
        }

        // For now, we're no longer running.  If someone calls Set* while we're in
        // the Timer callback below, this will be set true.
        _fRunning = FALSE;
        _cftDue = 0;


        // Show that the timer has fired and is being processed.  This is used
        // by SetTimer so that it knows that we're in a call to the Timer
        // callback.
        _fTimerSignalInProgress = TRUE;
    }
    TrkAssert( 1 == GetLockCount() );
    Unlock();

    // Call the timer handler.  On return, it tells us how we should
    // proceed.

    continuation = _pTimerCallback->Timer( _ulTimerContext );
    // continuation : {Break, Continue, Retry}

    Lock();
    __try   // __except
    {
        // We're no longer in the timer callback.
        _fTimerSignalInProgress = FALSE;

        // If, while we were in the Timer callback, another thread came along
        // and set the timer, then that takes priority over the
        // continuation that was just returned.  In such an case, _fRunning
        // will have been set to TRUE.

        if( _fRunning )
        {
            TrkAssert( 0 != _cftDue );
            TrkAssert( NULL != _hTimer );

            // Show that we're not in retry mode
            _ulCurrentRetryTime = 0;

            NTSTATUS Status;

            // _cftDue was set in the SetTimer call already

            Status = NtSetTimer ( _hTimer, //IN HANDLE TimerHandle,
                                  (LARGE_INTEGER*) &_cftDue,      //IN PLARGE_INTEGER DueTime,
                                  NULL,    //IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
                                  NULL,    //IN PVOID TimerContext OPTIONAL,
                                  FALSE,   //IN BOOLEAN ResumeTimer,
                                  0,       //IN LONG Period OPTIONAL,
                                  NULL );  //OUT PBOOLEAN PreviousState OPTIONAL
            TrkAssert(NT_SUCCESS(Status));
        }

        else if( PTimerCallback::BREAK_TIMER == continuation )
        {
            // Break out of this timer; stop it even if it's a recurring timer.
            Cancel();
        }

        else if( PTimerCallback::CONTINUE_TIMER == continuation )
        {
            // Continue with this timer; stop it if it's a single shot, set it again
            // if it's recurring.

            _ulCurrentRetryTime = 0;    // If we were retrying, we aren't any longer

            if( _fRecurring )
                SetTimer();
            else
                Cancel();
        }

        else    // RETRY_TIMER
        {
            TrkAssert( PTimerCallback::RETRY_TIMER == continuation );
            TrkAssert( _ulLowerRetryTime <= _ulUpperRetryTime );

            if( 0 == _ulUpperRetryTime || NO_RETRY == _RetryType )
            {
                TrkAssert( !TEXT("Attempted to retry a timer with no retry times set") );
                Cancel();
            }

            if( RETRY_WITH_BACKOFF == _RetryType )
            {
                if( 0 == _ulCurrentRetryTime )
                    _ulCurrentRetryTime = _ulLowerRetryTime;
                else if( (MAXULONG/2) < _ulCurrentRetryTime )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Questionable retry time") ));
                    TrkAssert( FALSE );
                    _ulCurrentRetryTime = MAXULONG;
                }
                else
                    _ulCurrentRetryTime *= 2;

                if( _ulCurrentRetryTime > _ulUpperRetryTime )
                    _ulCurrentRetryTime = _ulUpperRetryTime;

            }
            else // PTimerCallback::RETRY_RANDOMLY == _RetryType
            {
                CFILETIME cftNow;

                _ulCurrentRetryTime = _ulLowerRetryTime
                                      +
                                      ( QuasiRandomDword() % (_ulUpperRetryTime - _ulLowerRetryTime) );

            }

            TrkLog(( TRKDBG_TIMER, TEXT("Retrying timer %s/%p for %d seconds"),
                     (NULL == _ptszName) ? TEXT("") : _ptszName,
                     this,
                     _ulCurrentRetryTime ));

            // Set the timer with the just-calculated retry period
            SetTimer();

        }   // else if( CONTINUE_TIMER == continuation ) ... else
    }
    __except( BreakOnDebuggableException() )
    {
        // The exception may have been in the timer, but more likely
        // was in the PTimerCallback::Timer routine.  As a cure-all,
        // just reset the timer to an arbitrary value (we don't want
        // to re-use _ulPeriodInSeconds, because it may be zero).

        TrkLog(( TRKDBG_ERROR, TEXT("Unexpected timer exception") ));
        TrkAssert( FALSE );

        __try
        {
            _ulPeriodInSeconds = TRKDAY;
            Cancel();
            SetTimer();
        }
        __except( BreakOnDebuggableException() )
        {
        }
    }

    Unlock();

}   // CNewTimer::DoWork


//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::SaveToRegistry
//
//  Synopsis:   Save the timer's state to the registry, using _ptszName
//              as a value name.
//
//+----------------------------------------------------------------------------

void
CNewTimer::SaveToRegistry()
{
    LONG lErr = ERROR_SUCCESS;

    HKEY hk = NULL;

    // If this isn't a persistent timer, then there's nothing to do.
    if( NULL == _ptszName )
        return;

    Lock();
    __try
    {
        lErr = RegOpenKey( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack, &hk );

        PersistentState persist;

        persist.cftSet = _cftSet;
        persist.cftDue = _cftDue;
        persist.ulCurrentRetryTime = _ulCurrentRetryTime;

        if ( lErr == ERROR_SUCCESS )
        {

            lErr = RegSetValueEx(  hk,
                                   _ptszName,
                                   0,
                                   REG_BINARY,
                                   (CONST BYTE *)&persist,
                                   sizeof(persist) );
            RegCloseKey(hk);
        }
    }
    __finally
    {
        Unlock();
    }

    TrkAssert( lErr == ERROR_SUCCESS
               ||
               lErr == ERROR_NOT_ENOUGH_MEMORY
               ||
               lErr == ERROR_NO_SYSTEM_RESOURCES );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::LoadFromRegistry
//
//  Synopsis:   Load this timer's previously persisted state from the
//              registry.
//
//+----------------------------------------------------------------------------

void
CNewTimer::LoadFromRegistry()
{

    LONG l;
    HKEY hk = NULL;

    // If this isn't a persistent timer, then there's nothing to do.
    if( NULL == _ptszName )
        return;

    Lock();
    __try
    {
        // Open the main link-tracking key.

        l = RegCreateKey(HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack, &hk);
        if (l != ERROR_SUCCESS)
        {
            hk = NULL;
        }
        else
        {
            // The main link-tracking key exists.  See if we can open this 
            // timer's value.

            PersistentState persist;
            DWORD cbData = sizeof(persist);
            DWORD dwType = 0;

            l = RegQueryValueEx( hk,
                             _ptszName,
                             NULL,
                             &dwType,
                             (BYTE *)&persist,
                             &cbData );

            if (l == ERROR_SUCCESS)
            {
                if (dwType == REG_BINARY
                    &&
                    cbData == sizeof(persist))
                {

                    // This timer has a persistent value in the registry.  Override
                    // the caller-provided timeout.
    
                    _cftDue = persist.cftDue;
                    _cftSet = persist.cftSet;
                    _ulCurrentRetryTime = persist.ulCurrentRetryTime;
                }
                else
                {
                    RegDeleteValue( hk, _ptszName );
                    l = ERROR_FILE_NOT_FOUND;
                }
            }   // if (l == ERROR_SUCCESS)
        }   // if (l != ERROR_SUCCESS) ... else
    }
    __finally
    {
        if( NULL != hk )
            RegCloseKey(hk);

        Unlock();
    }

    if (l != ERROR_SUCCESS && l != ERROR_FILE_NOT_FOUND)
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring error %08x in timer %s LoadFromRegistry"),
                 l, _ptszName ));
    }

    return;
}



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::RemoveFromRegistry
//
//  Synopsis:   Remove this timer's persistent state from the registry.
//
//+----------------------------------------------------------------------------

void
CNewTimer::RemoveFromRegistry()
{
    LONG lErr = ERROR_SUCCESS;
    HKEY hk = NULL;

    if( NULL == _ptszName )
        return;

    Lock();
    __try
    {
        lErr = RegOpenKey( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack, &hk );

        if ( lErr == ERROR_SUCCESS )
        {
            lErr = RegDeleteValue(  hk, _ptszName );
            RegCloseKey(hk);

            if( ERROR_SUCCESS != lErr
                &&
                ERROR_PATH_NOT_FOUND != lErr
                &&
                ERROR_FILE_NOT_FOUND != lErr )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't delete timer's static reg name (\"%s\", %08x)"),
                        _ptszName, lErr ));
            }
        }
    }
    __finally
    {
        Unlock();
    }

}



//+----------------------------------------------------------------------------
//
//  CNewTimer::UnInitialize
//
//  Unregister the timer handle from the thread pool, cancel the timer,
//  and release it.
//
//+----------------------------------------------------------------------------

void
CNewTimer::UnInitialize()
{
    if( _fInitializeCalled )
    {
        TrkLog(( TRKDBG_TIMER, TEXT("Uninitializing timer %s/%p"), GetTimerName(), this ));

        // Take the timer out of the thread pool, which must be
        // done before closing the timer.

        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CNewTimer (%s/%p, %lu)"),
                         NULL == _ptszName ? TEXT("") : _ptszName, this,
                         GetLastError() ));
            }
            else
            {
                TrkLog(( TRKDBG_TIMER, TEXT("Unregistered wait for timer (%s/%p)"),
                         NULL == _ptszName ? TEXT("") : _ptszName, this ));
            }
            _hRegisterWaitForSingleObjectEx = NULL;
        }

        // Close the timer handle

        TrkVerify( NT_SUCCESS( NtCancelTimer(_hTimer, NULL) ));
        NtClose(_hTimer);

        // Delete the CNewTimer critical section.

        _cs.UnInitialize();

        _fInitializeCalled = FALSE;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\sharenum.cxx ===
// Copyright (c) 1996-2002 Microsoft Corporation


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       sharenum.cxx
//
//  Contents:   The CShareEnumerator class implementation.
//
//  Classes:    CShareEnumerator
//
//  History:    28-Jan-98   MikeHill    Created
//
//  Notes:      
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"

//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::Initialize
//
//  Synopsis:   Initializes this enumeration by calling
//              NetShareEnum.
//
//  Arguments:  [IDL_handle] (in)
//                  The RPC binding handle to the client on whom's
//                  behalf we're acting.
//
//              [ptszMachineName] (in)
//                  The machine on which shares are to be enumerated.
//                  If this value is NULL, the local machine is assumed.
//
//
//  Returns:    None.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------


VOID
CShareEnumerator::Initialize( RPC_BINDING_HANDLE IDL_handle, const TCHAR *ptszMachineName )
{
    NET_API_STATUS netstatus;
    NETRESOURCE netresourceMachine;
    DWORD dwTotalEntries;

    TrkAssert( !_fInitialized );    
    
    // Start with a clean state
    
    _ClearCache();
    _iCurrentEntry = static_cast<ULONG>(-1);
    _fInitialized = TRUE;

    _IDL_handle = IDL_handle;

    // Keep the machine name, retrieving it if necessary.

    _tcscpy( _tszMachineName, TEXT("\\\\") );

    if( NULL != ptszMachineName )
        _tcscpy( &_tszMachineName[2], ptszMachineName );
    else
    {
        DWORD cbMachineName = sizeof(_tszMachineName) - 2;
        if( !GetComputerName( &_tszMachineName[2], &cbMachineName ))
            TrkRaiseLastError();
    }

    // Start the enumeration.  We'll simply get all the share information
    // at once, instead of using a resume handle and making repeated RPC
    // calls to the Server service.

    netstatus = NetShareEnum( (TCHAR*) ptszMachineName,     // Server (we must de-const it)
                              502,                          // Info level
                              (LPBYTE*) &_prgshare_info,     // Return buffer
                              MAX_PREFERRED_LENGTH,         // Get everything
                              &_cEntries,                   // Entries read
                              &dwTotalEntries,              // Total entries avail
                              NULL );                       // Resume handle

    if( STATUS_SUCCESS != netstatus )
        TrkRaiseWin32Error( HRESULT_FROM_WIN32(netstatus) );

    TrkAssert( _cEntries == dwTotalEntries );

    return;

}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::UnInitialize
//
//  Synopsis:   Free any resources.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Raises:     No
//
//--------------------------------------------------------------------

VOID
CShareEnumerator::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _prgshare_info )
            NetApiBufferFree( _prgshare_info );

        InitLocals();
    }

    CTrkRpcConfig::UnInitialize();
}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_ClearCache
//
//  Synopsis:   Clear the data members of the CShareEnumerator
//              which are cached information about the current share.
//              (This is done in preparation to move on to the next
//              share in the enumeration.)
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Raises:     No
//
//--------------------------------------------------------------------

VOID
CShareEnumerator::_ClearCache()
{
    // Clear the cached information about the
    // current share.

    _cchSharePath = (ULONG) -1;
    _ulMerit = 0;
    _enumHiddenState = HS_UNKNOWN;

}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::Next
//
//  Synopsis:   Moves the enumerator on to the next share in the
//              the enumeration.
//
//  Arguments:  None.
//
//  Returns:    TRUE if there was another element in the enumeration,
//              FALSE if there are no more shares to enumerate.
//
//  Raises:     No.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::Next()
{
    TrkAssert( _fInitialized );

    if( _iCurrentEntry + 1 < _cEntries )
    {
        _ClearCache();
        _iCurrentEntry++;
        return( TRUE );
    }
    else
        return( FALSE );

}



//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::CoversDrivePath
//
//  Synopsis:   Determines if the current share in the enumeration
//              "covers" a given drive path.  E.g., a share to
//              "c:\docs" covers the drive path "c:\docs\mydoc.doc".
//
//  Arguments:  [ptszDrivePath]
//                  The drive-based path to check for coverage.
//
//  Returns:    TRUE if the current share covers the given path,
//              FALSE otherwise.
//
//  Raises:     No
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::CoversDrivePath( const TCHAR *ptszDrivePath )
{
    TrkAssert( _fInitialized );
    TrkAssert( TEXT(':') == ptszDrivePath[1] );

    // Does the current share path cover the file?  It does if it compares
    // successfully with the local path, up to the entire length of the
    // share path.

    if( _IsValidShare()
        &&
        QueryCCHSharePath() <= _tcslen(ptszDrivePath)
        &&
        !_tcsnicmp( GetSharePath(), ptszDrivePath, QueryCCHSharePath() )
      )
        return TRUE;
    else
        return FALSE;
    
}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_IsHiddenShare
//
//  Synopsis:   Determines if the current share is "hidden"
//              (i.e., the share name ends in a '$').
//
//              The first time this method is called, the share
//              named is checked for hidden-ness.  The result is
//              cached for subsequent calls.
//
//  Arguments:  None.
//
//  Returns:    TRUE if the current share is hidden,
//              FALSE if it is visible.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::_IsHiddenShare()
{
    TrkAssert( _fInitialized );
    TrkAssert( _IsValidShare() );
    TrkAssert( NULL != GetShareName() );
    TrkAssert( TEXT('\0') != GetShareName()[0] );

    if( _enumHiddenState == HS_UNKNOWN )
    {
        _enumHiddenState = TEXT('$') == GetShareName()[ _tcslen(GetShareName()) - 1 ]
                           ? HS_HIDDEN
                           : HS_VISIBLE;
    }

    return( HS_HIDDEN == _enumHiddenState );
}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_IsAdminShare
//
//  Synopsis:   Determines if the current share is Admin share.
//              Admin shares are automatically created by the Server
//              service during initialization.  They're hard-coded
//              to be A$, B$, C$, etc., for each of the drives,
//              and ADMIN$ for the %windir% directory.
//
//  Arguments:  None.
//
//  Returns:    TRUE if the current share is an auto-generated admin share,
//              FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::_IsAdminShare()
{
    TCHAR tcDriveLetter;
    TrkAssert( _fInitialized );
    TrkAssert( _IsValidShare() );
    TrkAssert( NULL != GetShareName() );
    TrkAssert( TEXT('\0') != GetShareName()[0] );

    tcDriveLetter = TrkCharUpper( GetShareName()[0] );

    // Check for the admin share characteristics.

    if( 2 == _tcslen(GetShareName())
        &&
        TEXT('$')  == GetShareName()[ 1 ]
        &&
        TEXT('A')  <= tcDriveLetter
        &&
        TEXT('Z')  >= tcDriveLetter
      )
    {
        return( TRUE ); // It's a drive share
    }
    else if( !_tcsicmp( TEXT("admin$"), GetShareName() ))
        return( TRUE ); // It's the %windir% share

    else
        return( FALSE );

}


//+----------------------------------------------------------------------------
//
//  Method:     _IsValidShare
//
//  Synopsis:   Returns True if the current share is valid.  A share
//              valid it if it is in the form "<drive letter>:\\".  E.g.
//              "IPC$" isn't a valid share.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

inline BOOL
CShareEnumerator::_IsValidShare()
{
    TCHAR tcFirstChar;

    // There should be a path, and it should be at least 3 characters
    // (e.g. "D:\")

    if( NULL == GetSharePath() || 3 > QueryCCHSharePath() )
        return FALSE;

    tcFirstChar = TrkCharUpper( GetSharePath()[0] );

    // Make sure that the share path begins with "<Drive>:\\".

    if( TEXT('A') <= tcFirstChar && tcFirstChar <= TEXT('Z')
        &&
        TEXT(':') == GetSharePath()[1]
        &&
        TEXT('\\') == GetSharePath()[2]
        )
    {
        return( TRUE );
    }
    else
        return( FALSE );

}

//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::GetMerit
//
//  Synopsis:   Returns the linear (ULONG) merit of the current path.
//              The greater this merit value, the more useful the share
//              is.  This is calculated on the first call to this method,
//              and cached for use in subsequent calls.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

ULONG
CShareEnumerator::GetMerit()
{
    TrkAssert( _fInitialized );

    // The merit of a share is the bitwise-OR of the share's
    // enumAccessLevel, its hidden-ness, and the length of
    // the covered path.
    //
    // Shorter paths are more mertious than longer paths
    // (because they cover more of the volume), so we subtract
    // the path length from the max-value; thus giving shorter
    // paths more weight.

    if( 0 == _ulMerit && _IsValidShare() )
    {
        _ulMerit = ( _GetAccessLevel() )
                   |
                   ( SPC_MAX_COVERAGE - QueryCCHSharePath() )
                   |
                   ( _IsHiddenShare() ? HS_HIDDEN : HS_VISIBLE );
    }

    TrkLog(( TRKDBG_MEND, TEXT("Score %d for %s (%s)"),
             _ulMerit,
             _prgshare_info[ _iCurrentEntry ].shi502_netname,
             _prgshare_info[ _iCurrentEntry ].shi502_path ));
    
    return( _ulMerit );
}


static void SDAllocHelper( BYTE **ppb, ULONG cbCurrent, ULONG cbRequired )
{
    if( cbRequired <= cbCurrent )
        return;

    *ppb = new BYTE[ cbRequired ];
    if( NULL == *ppb )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed alloc in SDAllocHelper")));
        TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
    }

    return;
}

void
CShareEnumerator::_AbsoluteSDHelper( const PSECURITY_DESCRIPTOR pSDRelative,
                                     PSECURITY_DESCRIPTOR *ppSDAbs, ULONG *pcbSDAbs,
                                     PACL *ppDaclAbs,     ULONG *pcbDaclAbs,
                                     PACL *ppSaclAbs,     ULONG *pcbSaclAbs,
                                     PSID *ppSidOwnerAbs, ULONG *pcbSidOwnerAbs,
                                     PSID *ppSidGroupAbs, ULONG *pcbSidGroupAbs  )
{
    ULONG cbSDAbs = *pcbSDAbs;
    ULONG cbDaclAbs = *pcbDaclAbs;
    ULONG cbSaclAbs = *pcbSaclAbs;
    ULONG cbSidOwnerAbs = *pcbSidOwnerAbs;
    ULONG cbSidGroupAbs = *pcbSidGroupAbs;

    for( int i = 0; i < 2; i++ )
    {
        if( !MakeAbsoluteSD( pSDRelative,
			    *ppSDAbs, pcbSDAbs,
			    *ppDaclAbs, pcbDaclAbs,
			    *ppSaclAbs, pcbSaclAbs,
			    *ppSidOwnerAbs, pcbSidOwnerAbs,
			    *ppSidGroupAbs, pcbSidGroupAbs ))
	{
	    if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
	    {
		TrkLog((TRKDBG_ERROR, TEXT("Couldn't make absolute SD")));
		TrkRaiseLastError( );
	    }

            TrkLog(( TRKDBG_MEND, TEXT("Realloc _AbsoluteSDHelper") ));

            SDAllocHelper( (BYTE**) ppSDAbs, cbSDAbs, *pcbSDAbs );
            SDAllocHelper( (BYTE**) ppDaclAbs, cbDaclAbs, *pcbDaclAbs );
            SDAllocHelper( (BYTE**) ppSaclAbs, cbSaclAbs, *pcbSaclAbs );
            SDAllocHelper( (BYTE**) ppSidOwnerAbs, cbSidOwnerAbs, *pcbSidOwnerAbs );
            SDAllocHelper( (BYTE**) ppSidGroupAbs, cbSidGroupAbs, *pcbSidGroupAbs );
        }
    }

}





//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_GetAccessLevel
//
//  Synopsis:   Determines the "access level" of the current share.
//              The definition of an access level is provided by
//              the enumAccessLevels enumeration in PShareMerit.
//
//              Once calculated, this access level is not cached for
//              subsequent calls, because this method is only called
//              by GetMerit, which provides its own cacheing.
//
//              *** Note:  This is a temporary solution.  This should
//              be replaced with a solution that simply checks security
//              on the share, without actually attempting to open the
//              file.
//
//  Arguments:  None.
//
//  Returns:    An access level in the form of an enumAccessLevels.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

PShareMerit::enumAccessLevels
CShareEnumerator::_GetAccessLevel()
{

    enumAccessLevels AccessLevel = AL_NO_ACCESS;
    static const int StackBufferSizes = 256;

    TCHAR tszUNCPath[ MAX_PATH + 1 ];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    int iAttempt;
    DWORD rgAccess[] = { GENERIC_READ | GENERIC_WRITE, // => AL_READWRITE_ACCESS
                         GENERIC_READ,                 // => AL_READ_ACCESS
                         GENERIC_WRITE };              // => AL_WRITE_ACCESS

    HANDLE hAccessToken;
    BOOL   fAccessToken = FALSE;

    RPC_STATUS rpc_status;
    DWORD dwStatus;
    DWORD cbActual;
    BOOL fImpersonating = FALSE;

    BYTE rgbTokenUser[StackBufferSizes];
    ULONG cbTokenUser = sizeof(rgbTokenUser);
    TOKEN_USER *pTokenUser = (TOKEN_USER*) rgbTokenUser;

    BYTE rgbTokenGroups[ 4 * StackBufferSizes ];
    ULONG cbTokenGroups = sizeof(rgbTokenGroups);
    TOKEN_GROUPS *pTokenGroups = (TOKEN_GROUPS*) rgbTokenGroups;

    BYTE rgbSDAbs[ StackBufferSizes ];
    ULONG cbSDAbs = sizeof(rgbSDAbs);
    PSECURITY_DESCRIPTOR pSDAbs = (PSECURITY_DESCRIPTOR) rgbSDAbs;

    BYTE rgbDaclAbs[ StackBufferSizes ];
    ULONG cbDaclAbs = sizeof(rgbDaclAbs);
    PACL pDaclAbs = (PACL) rgbDaclAbs;

    BYTE rgbSaclAbs[ StackBufferSizes ];
    ULONG cbSaclAbs = sizeof(rgbSaclAbs);
    PACL pSaclAbs = (PACL) rgbSaclAbs;

    BYTE rgbSidOwnerAbs[ StackBufferSizes ];
    ULONG cbSidOwnerAbs = sizeof(rgbSidOwnerAbs);
    PSID pSidOwnerAbs = (PSID) rgbSidOwnerAbs;

    BYTE rgbSidGroupAbs[ StackBufferSizes ];
    ULONG cbSidGroupAbs = sizeof(rgbSidGroupAbs);
    PSID pSidGroupAbs = (PSID) rgbSidGroupAbs;

    GENERIC_MAPPING Generic_Mapping = { FILE_GENERIC_READ, FILE_GENERIC_WRITE, FILE_GENERIC_EXECUTE, FILE_ALL_ACCESS };

    PRIVILEGE_SET rgPrivilegeSet[ 10 ];
    ULONG cbPrivilegeSet = sizeof(rgPrivilegeSet);
    PRIVILEGE_SET *pPrivilegeSet = rgPrivilegeSet;

    DWORD dwGrantedAccess;
    BOOL fAccessStatus;

    CSID     csidAdministrators;
    CSecDescriptor csdAdministrators;

    PSECURITY_DESCRIPTOR psdCheck = NULL;

    // If there is no security descriptor and this isn't an admin share,
    // it means that Everyone has 'full control'.

    if( NULL == _prgshare_info[ _iCurrentEntry ].shi502_security_descriptor && !_IsAdminShare() )
        return( AL_FULL_ACCESS );


    // Otherwise, we'll look at the share's DACL ...

    __try
    {
        // Impersonate the client
        TrkAssert( NULL != _IDL_handle );

        if( RpcSecurityEnabled() )
        {
            rpc_status = RpcImpersonateClient( _IDL_handle );
            if( S_OK != rpc_status )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't impersonate client")));
                TrkRaiseWin32Error( rpc_status );
            }
            fImpersonating = TRUE;
        }
        else
        {
            if( !ImpersonateSelf( SecurityImpersonation ) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't impersonate self")));
                TrkRaiseLastError( );
            }
            fImpersonating = TRUE;
        }

        // Get the client's access token

        if( !OpenThreadToken( GetCurrentThread(),
                              TOKEN_READ, //TOKEN_ALL_ACCESS,
                              TRUE, // Open as self
                              &hAccessToken ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed OpenThreadToken")));
            TrkRaiseLastError( );
        }
        fAccessToken = TRUE;

        // Get the client's owner SID

	for( int i = 0; i < 2; i++ )
	{
    	    if( !GetTokenInformation( hAccessToken,
                                      TokenUser,
                                      (LPVOID) pTokenUser,
                                      cbTokenUser,
                                      &cbActual ))
	    {
	        if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
	        {
		    TrkLog((TRKDBG_ERROR, TEXT("Failed GetTokenInformation (TokenUser)")));
		    TrkRaiseLastError( );
	        }

                TrkLog(( TRKDBG_MEND, TEXT("Realloc pTokenUser") ));
	        cbTokenUser = cbActual;
	        pTokenUser = (TOKEN_USER*) new BYTE[ cbTokenUser ];
	        if( NULL == pTokenUser )
		    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
	    }
	}

        // Get the client's group SID

	for( i = 0; i < 2; i++ )
	{
	    if( !GetTokenInformation( hAccessToken,
				      TokenGroups,
				      (LPVOID) pTokenGroups,
				      cbTokenGroups,
				      &cbActual ))
	    {
	        if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
	        {
		    TrkLog((TRKDBG_ERROR, TEXT("Failed GetTokenInformation (TokenGroups)")));
		    TrkRaiseLastError( );
	        }

                TrkLog(( TRKDBG_MEND, TEXT("Realloc pTokenGroups") ));
	        cbTokenGroups = cbActual;
	        pTokenGroups = (TOKEN_GROUPS*) new BYTE[ cbTokenGroups ];
	        if( NULL == pTokenGroups )
		    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
	    }
	}
    
        // Get a pointer to the security descriptor we want to check against.

        if( _IsAdminShare() )
        {
            // For admin shares, we don't get a security descriptor in _prgshare_info
            // from the NetShareEnum call.  But, we know what the ACLs on admin shares
            // should be, so we'll craft up an SD.

            csidAdministrators.Initialize( CSID::CSID_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS );

            csdAdministrators.Initialize();
            csdAdministrators.AddAce( CSecDescriptor::ACL_IS_DACL, CSecDescriptor::AT_ACCESS_ALLOWED,
                                      FILE_ALL_ACCESS, csidAdministrators );

            psdCheck = csdAdministrators;

        }
        else
        {
            // Convert the share's Security Descriptor into absolute form.

            _AbsoluteSDHelper( _prgshare_info[ _iCurrentEntry ].shi502_security_descriptor,
                               &pSDAbs, &cbSDAbs,
                               &pDaclAbs, &cbDaclAbs,
                               &pSaclAbs, &cbSaclAbs,
                               &pSidOwnerAbs, &cbSidOwnerAbs,
                               &pSidGroupAbs, &cbSidGroupAbs );

            psdCheck = pSDAbs;
        }
        // The appropriate security descriptor is now in 'psdCheck'

        // Put the client's owner SID in the Security Descriptor.

        if( !SetSecurityDescriptorOwner( psdCheck,
                                         pTokenUser->User.Sid,
                                         FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't add user to SD")));
            TrkRaiseLastError( );
        }

        // Put the client's group SID in the Security Descriptor.
        // (Perf) Why?  I think it's because GetEffectiveRightsFromAcl wasn't working,
        // so we had to use AccessCheck.  But to use that call I think we had to pass
        // in an SD with an owner/group, and the one returned from shi502_security_descriptor
        // didn't have them.

        if( !SetSecurityDescriptorGroup( psdCheck,
                                         pTokenGroups->Groups->Sid,
                                         FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't add group to SD")));
            TrkRaiseLastError( );
        }

        // We have to stop impersonating in order to make the AccessCheck call.

        fImpersonating = FALSE;
        if( RpcSecurityEnabled() )
            RpcRevertToSelf();
        else
            RevertToSelf();

        // Check the access that this user has to this share.  If this returns
        // false, it means that NtAccessCheck returned an error.  If this returns
        // true, but fAccessStatus is false, it means that NtAccessCheck succeeded,
        // but it returned an error in its RealStatus parameter.  In either case,
        // we need to check GetLastError.

        for( i = 0; i < 2; i++ )
        {
            if( !AccessCheck( psdCheck,
                            hAccessToken, MAXIMUM_ALLOWED, &Generic_Mapping,
                            pPrivilegeSet, &cbPrivilegeSet, 
                            &dwGrantedAccess, &fAccessStatus )
                ||
                !fAccessStatus )
            {
                if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
                {
                    TrkLog((TRKDBG_ERROR, TEXT("Couldn't perform AccessCheck for %s (%08x)"),
                            GetShareName(), HRESULT_FROM_WIN32(GetLastError()) ));
                    TrkRaiseLastError( );
                }

                TrkLog(( TRKDBG_MEND, TEXT("Realloc pPrivilegeSet") ));
                pPrivilegeSet = (PRIVILEGE_SET*) new BYTE[ cbPrivilegeSet ];
                if( NULL == pPrivilegeSet )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc pPrivilegeSet") ));
                    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
        }

        // Reduce this complete list of accesses to a synopsis

        if( AreAllAccessesGranted( dwGrantedAccess, FILE_ALL_ACCESS ))
            AccessLevel = AL_FULL_ACCESS;
        else if( AreAllAccessesGranted( dwGrantedAccess, FILE_GENERIC_READ | FILE_GENERIC_WRITE ))
            AccessLevel = AL_READ_WRITE_ACCESS;
        else if( AreAllAccessesGranted( dwGrantedAccess, FILE_GENERIC_READ ))
            AccessLevel = AL_READ_ACCESS;
        else if( AreAllAccessesGranted( dwGrantedAccess, FILE_GENERIC_WRITE ))
            AccessLevel = AL_WRITE_ACCESS;
        else
            AccessLevel = AL_NO_ACCESS;

    }
    __finally
    {

        csdAdministrators.UnInitialize();
        csidAdministrators.UnInitialize();

        if( fAccessToken )
            CloseHandle( hAccessToken );

        if( fImpersonating )
        {
            if( RpcSecurityEnabled() )
                RpcRevertToSelf();
            else
                RevertToSelf();
        }

        if( rgPrivilegeSet != pPrivilegeSet )
            delete[] pPrivilegeSet;

        if( rgbTokenUser != (BYTE*) pTokenUser )
            delete[] pTokenUser;
        if( rgbTokenGroups != (BYTE*) pTokenGroups )
            delete[] pTokenGroups;

        if( rgbSDAbs != (BYTE*) pSDAbs )
            delete[] pSDAbs;
        if( rgbDaclAbs != (BYTE*) pDaclAbs )
            delete[] pDaclAbs;
        if( rgbSaclAbs != (BYTE*) pSaclAbs )
            delete[] pSaclAbs;
        if( rgbSidOwnerAbs != (BYTE*) pSidOwnerAbs )
            delete[] pSidOwnerAbs;
        if( rgbSidGroupAbs != (BYTE*) pSidGroupAbs )
            delete[] pSidGroupAbs;

    }

    return( AccessLevel );

}

//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::GenerateUNCPath
//
//  Synopsis:   Generate a UNC path to the give drive-based path
//              WRT to the current share.
//
//  Arguments:  [ptszUNCPath] (out)
//                  Filled with the generated UNC path.  This 
//                  is assumed to be at least MAX_PATH+1 characters.
//
//              [ptszDrivePath] (in)
//                  The drive-based path to the file.
//                  E.g. "c:\my documents\wordfile.doc".
//
//  Returns:    FALSE if the current share doesn't cover the
//              file, TRUE otherwise.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::GenerateUNCPath( TCHAR *ptszUNCPath, const TCHAR * ptszDrivePath )
{
    TrkAssert( _fInitialized );
    TrkAssert( TEXT(':') == ptszDrivePath[1] );

    // Ensure that this share covers the drive-based path.

    if( !CoversDrivePath( ptszDrivePath ))
        return( FALSE );

    // Start out the UNC name with the \\machine\share.

    _tcscpy( ptszUNCPath, _tszMachineName );
    _tcscat( ptszUNCPath, TEXT("\\") );
    _tcscat( ptszUNCPath, GetShareName() );
    _tcscat( ptszUNCPath, TEXT("\\") );

    // Finish the UNC name with the portion of the
    // volume path which is under the share path.

    _tcscat( ptszUNCPath, &ptszDrivePath[ QueryCCHSharePath() ] );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\common\secure.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       secure.cxx
//
//              This file contains wrapper classes for the NT security
//              objects.
//
//  Contents:   Code common to Tracking (Workstation) Service and
//              Tracking (Server) Service.
//
//  Classes:    CACL, CSID, and CSecDescriptor
//
//  History:    28-Jan-98   MikeHill    Created
//
//  Notes:      
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"


//+-------------------------------------------------------------------
//
//  Function:   CACL::Initialize, public
//
//  Synopsis:   Initialize the ACL by allocating a buffer
//              and calling InitializeAcl on it.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CACL::Initialize()
{
    _fInitialized = TRUE;

    _pacl = (PACL) new BYTE[ MIN_ACL_SIZE ];
    if( NULL == _pacl )
        TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );

    _cbacl = MIN_ACL_SIZE;

    if( !InitializeAcl( _pacl, _cbacl, ACL_REVISION ))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed InitializeAcl")) );
        TrkRaiseLastError();
    }

    _fDirty = TRUE;

}



//+-------------------------------------------------------------------
//
//  Function:   CACL::UnInitialize, public
//
//  Synopsis:   Free the ACL.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CACL::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _pacl )
        {
            delete [] _pacl;
        }

        _fInitialized = FALSE;
    }
}




//+-------------------------------------------------------------------
//
//  Function:   CACL::Initialize, public
//
//  Synopsis:   Initialize a SID with its authority
//              and sub-authority(ies).
//
//  Arguments:  [enumCSIDAuthority] (in)
//                  An enumeration which tells us which of the
//                  standard authorities to use.
//              [cSubAuthorities] (in)
//                  The number of sub-auths in this SID.
//              [dwSubAuthority?] (in)
//                  The Sub-Authorities.
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSID::Initialize( enumCSIDAuthority enumcsidAuthority,
                  BYTE  cSubAuthorities ,
                  DWORD dwSubAuthority0 = 0,
                  DWORD dwSubAuthority1 = 0,
                  DWORD dwSubAuthority2 = 0,
                  DWORD dwSubAuthority3 = 0,
                  DWORD dwSubAuthority4 = 0,
                  DWORD dwSubAuthority5 = 0,
                  DWORD dwSubAuthority6 = 0,
                  DWORD dwSubAuthority7 = 0 )
{
    SID_IDENTIFIER_AUTHORITY rgsid_identifier_authority[] = { SECURITY_NT_AUTHORITY };

    TrkAssert(!_fInitialized);

    _fInitialized = TRUE;
    _psid = NULL;

    if( !AllocateAndInitializeSid( &rgsid_identifier_authority[ enumcsidAuthority ],
                               cSubAuthorities,
                               dwSubAuthority0,
                               dwSubAuthority1,
                               dwSubAuthority2,
                               dwSubAuthority3,
                               dwSubAuthority4,
                               dwSubAuthority5,
                               dwSubAuthority6,
                               dwSubAuthority7,
                               &_psid ))
    {

        TrkLog((TRKDBG_ERROR, TEXT("AllocateAndInitializeSid failed")));
        TrkRaiseLastError();
    }
            
}


//+-------------------------------------------------------------------
//
//  Function:   CSID::UnInitialize, public
//
//  Synopsis:   Free the SID.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSID::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _psid )
        {
            FreeSid( _psid );   // Alloc-ed with AllocAndInitializeSid()
        }

        _fInitialized = FALSE;
    }
}




//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::_Allocate, public
//
//  Synopsis:   Allocate a Security Descriptor.
//
//  Arguments:  [cb]
//                  Size of buffer to allocate for SD.
//
//  Returns:    None
//
//--------------------------------------------------------------------

void
CSecDescriptor::_Allocate( ULONG cb )
{
    PSECURITY_DESCRIPTOR psd;

    psd = (PSECURITY_DESCRIPTOR) new BYTE[ cb ];
    
    if( NULL == psd )
        TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );

    if( NULL != _psd )
        delete [] _psd;

    _psd = psd;

}


//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::Initialize, public
//
//  Synopsis:   Allocate a SD, and call a Security API to init it.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSecDescriptor::Initialize()
{

    _fInitialized = TRUE;

    _Allocate( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if( !InitializeSecurityDescriptor( _psd,
                                       SECURITY_DESCRIPTOR_REVISION ))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed InitializeSecurityDescriptor")));
        TrkRaiseLastError();
    }

    if( !SetSecurityDescriptorControl( _psd,
                                       SE_DACL_AUTO_INHERITED,
                                       SE_DACL_AUTO_INHERITED ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed InitializeSecurityDescriptor (SetSecurityDescriptorControl") ));
        TrkRaiseLastError();
    }
}


//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::UnInitialize, public
//
//  Synopsis:   Free the SD buffer, and free its ACLs.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSecDescriptor::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _psd )
        {
            delete [] _psd;
        }

        _cDacl.UnInitialize();
        _cSacl.UnInitialize();

        _fInitialized = FALSE;
    }
}



//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::AddAce, public
//
//  Synopsis:   Adds an ACE (access allowed or denied) to an
//              ACL in this SID.
//
//  Arguments:  [enumAclType] (in)
//                  Either ACL_DACL or ACL_SACL.
//              [enumAccessType] (in)
//                  Either AT_ACCESS_ALLOWED or AT_ACCESS_DENIED.
//              [access_mask] (in)
//                  The access bits to put in this ACE.
//              [psid] (in)
//                  The SID to put in this ACE.
//
//  Returns:    None
//
//--------------------------------------------------------------------

void
CSecDescriptor::AddAce( const enumAclType AclType, const enumAccessType AccessType,
                        const ACCESS_MASK access_mask, const PSID psid )
{
    BOOL fSuccess;

    // Get a pointer to the member CACL object.

    CACL  *pcacl = ACL_IS_DACL == AclType ? &_cDacl : &_cSacl;

    // Initialize the CACL if necessary.

    if( !pcacl->IsInitialized() )
        pcacl->Initialize();

    // Size the ACL appropriately

    //pcacl->SetSize( psid ); // Not currently implemented.

    // Add the ACE to the appropriate ACL.

    if( AT_ACCESS_ALLOWED == AccessType )
    {
        fSuccess = pcacl->AddAccessAllowed( access_mask, psid );
    }
    else
    {
        fSuccess = pcacl->AddAccessDenied( access_mask, psid );
    }

    if( !fSuccess )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't add an ACE to an ACL")));
        TrkRaiseLastError();
    }

    return;

}


//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::_ReloadAcl, public
//
//  Synopsis:   Puts the member ACLs back into the member
//              Security Descriptor, if they are dirty.
//
//  Arguments:  [enumAclType] (in)
//                  Either ACL_DACL or ACL_SACL.
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSecDescriptor::_ReloadAcl( enumAclType AclType )
{
    if( ACL_IS_DACL == AclType && _cDacl.IsDirty() )
    {
        if( !SetSecurityDescriptorDacl( _psd, TRUE, _cDacl, FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't put DACL into SD")));
            TrkRaiseLastError();
        }
        _cDacl.ClearDirty();
    }
    else if( ACL_IS_SACL == AclType && _cSacl.IsDirty() )
    {
        if( !SetSecurityDescriptorSacl( _psd, TRUE, _cSacl, FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't put SACL into SD")));
            TrkRaiseLastError();
        }
        _cSacl.ClearDirty();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\enumoid.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"



BOOL
DltAdminEnumOids( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    LONG iVol = 0;
    LONG iArg = 0;
    BOOL fSuccess = FALSE;
    BOOL fCrossVolumeOnly = FALSE;
    BOOL fShowPath = FALSE;
    BOOL fShowBirth = FALSE;
    BOOL fAllVolumes = TRUE;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        *pcEaten = 1;
        printf( "\nOption EnumOIDs\n"
                  "   Purpose: Enumerate the object IDs on one or more volumes\n"
                  "   Usage:   -enumoids [-<options>] [drive letter (all drives if omitted)]\n"
                  "   Options: -x  => Show only files with cross-volume bit set\n"
                  "            -b  => Show the birth ID too\n"
                  "            -f  => Show the filename too\n"
                  "   E.g.:    -enumoids\n"
                  "            -enumoids -xb d:\n" );
        return( TRUE );
    }

    if( cArgs > 0 &&
        ( TEXT('/') == rgptszArgs[iArg][0]
          ||
          TEXT('-') == rgptszArgs[iArg][0]
        ) )
    {
        _tcslwr( rgptszArgs[iArg] );
        for( LONG iOption = 1; TEXT('\0') != rgptszArgs[0][iOption]; iOption++ )
        {
            switch( rgptszArgs[iArg][iOption] )
            {
            case TEXT('x'):
                fCrossVolumeOnly = TRUE;
                break;
            case TEXT('b'):
                fShowBirth = TRUE;
                break;
            case TEXT('f'):
                fShowPath = TRUE;
                break;
            default:
                _tprintf( TEXT("Ignoring invalid option (use -? for help): %c\n"), rgptszArgs[0][iOption] );
                break;
            }
        }
        iArg++;
        (*pcEaten)++;
    }

    if( cArgs > iArg )
    {
        _tcslwr( rgptszArgs[iArg] );
        if( TEXT(':') != rgptszArgs[iArg][1]
            ||
            TEXT('a') > rgptszArgs[iArg][0]
            ||
            TEXT('z') < rgptszArgs[iArg][0] )
        {
            printf( "Invalid arguments.  Use -? for help\n" );
            return( FALSE );
        }

        (*pcEaten)++;
        iVol = rgptszArgs[iArg][0] - TEXT('a');
        fAllVolumes = FALSE;
    }


    while( iVol < 26 )
    {
        if( IsLocalObjectVolume( iVol ))
        {
            LONG lLastError = 0;

            printf( "Volume %c:\n", iVol+TEXT('a') );

            __try // __finally
            {
                CObjId                  objid;
                CDomainRelativeObjId    droidBirth;
                CObjIdEnumerator        oie;
                ULONG                   cObjId = 0;

                if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
                {
                    if( oie.FindFirst( &objid, &droidBirth ))
                    {
                        do
                        {
                            if( fCrossVolumeOnly && droidBirth.GetVolumeId().GetUserBitState()
                                ||
                                !fCrossVolumeOnly )
                            {
                                if( droidBirth.GetVolumeId().GetUserBitState() )
                                    printf( " x " );
                                else
                                    printf( "   " );

                                _tprintf( TEXT("objid = %s\n"),
                                          static_cast<const TCHAR*>(CStringize(objid)));

                                if( fShowBirth )
                                {
                                    _tprintf( TEXT("           %s (birth volid)\n"),
                                              static_cast<const TCHAR*>(CStringize(droidBirth.GetVolumeId() )));
                                    _tprintf( TEXT("           %s (birth objid)\n"),
                                              static_cast<const TCHAR*>(CStringize(droidBirth.GetObjId() )));
                                }

                                if( fShowPath )
                                {
                                    TCHAR tszPath[ MAX_PATH + 1 ];
                                    NTSTATUS status = FindLocalPath( iVol, objid, &droidBirth, &tszPath[2] );
                                    if( NT_SUCCESS(status) )
                                    {
                                        tszPath[0] = VolChar(iVol);
                                        tszPath[1] = TEXT(':');
                                        _tprintf( TEXT("           %s\n"), tszPath );
                                    }
                                    else
                                        _tprintf( TEXT("           %s (%08x)\n"), TEXT("<not found>"), status );
                                }
                            }

                        } while(oie.FindNext(&objid, &droidBirth));

                    }
                }
            }
            __except( BreakOnDebuggableException() )
            {
                printf( "Exception occurred: %08x\n", GetExceptionCode() );
            }

        }   // if( IsLocalObjectVolume( iVol ))

        if( !fAllVolumes )
            break;
        iVol++;

    }   // while( iVol < 26 )

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\dltadmin.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"
#include "trksvr.hxx"
#include "dltadmin.hxx"


OLECHAR *
tcstoocs(OLECHAR *poszBuf, const TCHAR *ptsz)
{
#ifdef OLE2ANSI
    return tcstombs( poszBuf, ptsz );
#else
    return tcstowcs( poszBuf, ptsz );
#endif
}

TCHAR *
ocstotcs(TCHAR *ptszBuf, const OLECHAR *posz)
{
#ifdef OLE2ANSI
    return mbstotcs( ptszBuf, posz );
#else
    return wcstotcs( ptszBuf, posz );
#endif
}



void Usage()
{
    printf( "\nDistributed Link Tracking service admin tools\n"
              "\n"
              "Usage:    dltadmin [command command-parameters]\n"
              "For help: dltadmin [command] -?\n"
              "Commands: -VolInfoFile   (get volume info from a file path)\n"
              "          -VolStat       (volume statistics)\n"
              "          -FileOid       (set/get/use file Object IDs)\n"
              "          -EnumOids      (enumerate object IDs)\n"
              "          -OidSnap       (save/restore all OIDs)\n"
              "          -Link          (create/resolve shell link)\n"
              "          -VolId         (get/set volume IDs)\n"
              "          -CleanVol      (clean Object/Volume IDs)\n"
              "          -LockVol       (lock/dismount a volume)\n"
              "          -SvrStat       (trkSvr statistics)\n"
              "          -LoadLib       (load a dll into a process)\n"
              "          -FreeLib       (unload a dll from a process)\n"
              "          -Config        (configure the registry and/or runing service)\n"
              "          -Refresh       (refresh the trkwks volume list)\n"
              "          -DebugBreak    (break into a process)\n"
              "          -LookupVolId   (look up entry in DC volume table)\n"
              "          -LookupDroid   (look up entry in DC move table)\n"
              "          -DelDcMoveId   (del move table entry from DC)\n"
              "          -DelDcVolId    (del volume table entry from DC)\n"
              "          -SetVolSeq     (set volid sequence number)\n"
              "          -SetDroidSeq   (set move entry sequence number)\n" );
}


// Dummy function to make it link
void
ServiceStopCallback( PVOID pContext, BOOLEAN fTimeout )
{
    return;
}


VOID
TSZ2CLSID( const LPTSTR tszCLSID, CLSID *pclsid )
{
    HRESULT hr = S_OK;
    OLECHAR oszCLSID[ CCH_GUID_STRING + 1 ];

    tcstoocs( oszCLSID, tszCLSID );

    hr = CLSIDFromString( oszCLSID, pclsid );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't convert string to CLSID") ));
        TrkRaiseException( hr );
    }

}







BOOL
DltAdminLockVol( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{

    HRESULT hr = S_OK;
    NTSTATUS status = 0;
    ULONG iVolume = static_cast<ULONG>(-1);
    TCHAR tszVolume[ ] = TEXT("\\\\.\\A:");
    OBJECT_ATTRIBUTES ObjAttr;
    IO_STATUS_BLOCK Iosb;
    UNICODE_STRING      uPath;
    HANDLE hVolume = NULL;
    BOOL fSuccess = FALSE;
    CHAR rgcCommands[ 10 ];
    ULONG iCommand = 0, cCommands = 0;


    *pcEaten = 0;

    if( 0 == cArgs
        ||
        1 <= cArgs && IsHelpArgument(rgptszArgs[0]) )
    {
        *pcEaten = 1;
        printf( "\nOption LockVol\n"
                  "   Purpose: Lock and/or dismount a volume\n"
                  "   Usage:   -LockVol <options> <drive letter>:\n"
                  "   Where:   <options> are any combination (up to %d) of:\n"
                  "               -d    Send FSCTL_DISMOUNT_VOLUME\n"
                  "               -l    Send FSCTL_LOCK_VOLUME\n"
                  "               -u    Send FSCTL_UNLOCK_VOLUME\n"
                  "               -p    Pause for user input\n"
                  "   E.g.:    -LockVol -d -l -u c:\n"
                  "            -LockVol -l c:\n",
                  ELEMENTS(rgcCommands) );

        return( TRUE );
    }

    for( int iArgs = 0; iArgs < cArgs; iArgs++ )
    {
        if( 2 == _tcslen( rgptszArgs[iArgs] ) && TEXT(':') == rgptszArgs[iArgs][1] )
        {
            TCHAR tc = rgptszArgs[iArgs][0];
            if( TEXT('A') <= tc && TEXT('Z') >= tc )
                iVolume = tc - TEXT('A');
            else if( TEXT('a') <= tc && TEXT('z') >= tc )
                iVolume = tc - TEXT('a');
        }
        else if( TEXT('-') == rgptszArgs[iArgs][0]
                 ||
                 TEXT('/') == rgptszArgs[iArgs][0] )
        {
            _tcslwr(rgptszArgs[iArgs]);

            if( iCommand >= ELEMENTS(rgcCommands) )
            {
                printf( "Too many commands to LockVol.  Use -? for usage info.\n" );
                return( FALSE );
            }

            if( TEXT('d') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'd';
            else
            if( TEXT('l') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'l';
            else
            if( TEXT('u') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'u';
            else
            if( TEXT('p') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'p';
            else
            {
                printf( "Invalid option.  Use -? for usage info.\n" );
                return( FALSE );
            }
        }

        cCommands++;
        iCommand++;
        (*pcEaten)++;
    }

    if( static_cast<ULONG>(-1) == iVolume )
    {
        printf( "Invalid parameter.  Use -? for usage info\n" );
        return( FALSE );
    }


    tszVolume[4] += static_cast<TCHAR>(iVolume);

    if( !RtlDosPathNameToNtPathName_U( tszVolume, &uPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }

    InitializeObjectAttributes(
        &ObjAttr,
        &uPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
                &hVolume,
                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE,
                &ObjAttr,
                &Iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if( !NT_SUCCESS(status) )
    {
        printf( "Failed NtOpenFile of %s (%08x)\n", tszVolume, status );
        goto Exit;
    }


    for( iCommand = 0; iCommand < cCommands; iCommand++ )
    {
        switch( rgcCommands[iCommand] )
        {
        case 'd':
            {
                status = NtFsControlFile(
                            hVolume,
                            NULL,                       /* Event */
                            NULL,                       /* ApcRoutine */
                            NULL,                       /* ApcContext */
                            &Iosb,
                            FSCTL_DISMOUNT_VOLUME,
                            NULL,                       /* InputBuffer */
                            0,                          /* InputBufferLength */
                            NULL,                       /* OutputBuffer */
                            0                           /* OutputBufferLength */
                            );
                if( !NT_SUCCESS(status) )
                    printf( "Failed FSCTL_DISMOUNT_VOLUME (%08x)\n", status );
                else
                    printf( "Volume dismounted\n" );
            }
            break;

        case 'l':
            {
                status = NtFsControlFile(
                            hVolume,
                            NULL,                       /* Event */
                            NULL,                       /* ApcRoutine */
                            NULL,                       /* ApcContext */
                            &Iosb,
                            FSCTL_LOCK_VOLUME,
                            NULL,                       /* InputBuffer */
                            0,                          /* InputBufferLength */
                            NULL,                       /* OutputBuffer */
                            0                           /* OutputBufferLength */
                            );
                if( !NT_SUCCESS(status) )
                    printf( "Failed FSCTL_LOCK_VOLUME (%08x)\n", status );
                else
                    printf( "Volume is locked\n" );

            }
            break;

        case 'u':
            {
                status = NtFsControlFile(
                            hVolume,
                            NULL,                       /* Event */
                            NULL,                       /* ApcRoutine */
                            NULL,                       /* ApcContext */
                            &Iosb,
                            FSCTL_UNLOCK_VOLUME,
                            NULL,                       /* InputBuffer */
                            0,                          /* InputBufferLength */
                            NULL,                       /* OutputBuffer */
                            0                           /* OutputBufferLength */
                            );
                if( !NT_SUCCESS(status) )
                    printf( "Failed FSCTL_UNLOCK_VOLUME (%08x)\n", status );
                else
                    printf( "Volume unlocked\n" );
            }
            break;

        case 'p':
            {
                printf( "Press enter to unlock ..." );
                getchar();
            }
            break;

        }   // switch( rgcCommands[iCommand] )
    }   // for( iCommand = 0; iCommand < cCommands; iCommand++ )

    fSuccess = TRUE;

Exit:

    return( fSuccess );

}



void
MakeAbsolutePath( TCHAR * ptszAbsolute, TCHAR * ptszRelative )
{

    if( !_tcsncmp( TEXT("\\\\"), ptszRelative, 2 )     // A UNC path
        ||
        TEXT(':') == ptszRelative[1] )             // A drive-based path
    {
        // The command-line has an absolute path
        _tcscpy( ptszAbsolute, ptszRelative );
    }
    else
    {
        // The command-line has a relative path

        DWORD dwLength = 0;

        dwLength = GetCurrentDirectory( MAX_PATH, ptszAbsolute );
        if( 0 == dwLength )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get current directory") ));
            TrkRaiseLastError( );
        }
        if( TEXT('\\') != ptszAbsolute[dwLength-1] )
            _tcscat( ptszAbsolute, TEXT("\\") );

        _tcscat( ptszAbsolute, ptszRelative );
    }
}


BOOL
DltAdminFileOid( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = S_OK;
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    WCHAR wszFile[ MAX_PATH + 1 ];
    TCHAR tszUNCPath[ MAX_PATH + 1 ];
    WCHAR wszOID[ CCH_GUID_STRING + 1 ];
    ULONG cbInBuffer;
    TCHAR tszMachineName[ MAX_PATH + 1 ];
    LPCTSTR tszVolumePath = NULL;
    USHORT iVolume;

    OLECHAR oszOID[ CCH_GUID_STRING + 1 ];

    EnablePrivilege( SE_RESTORE_NAME );

    *pcEaten = 0;

    //  -------------------------
    //  Validate the command-line
    //  -------------------------

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        *pcEaten = 1;
        printf( "\nOption FileOID\n"
                  "   Purpose: Get/set/use file Object IDs\n"
                  "   Usage:   -fileoid <option> <filename or object id, depending on the option>\n"
                  "   Options: -r  => Read the object ID from a file\n"
                  "            -g  => Get (creating if necessary) the object ID from a file\n"
                  "            -f  => Search the local machine for an object ID's filename\n"
                  "            -s  => Set an ID on a file (specify objid, then filename)\n"
                  "            -sr => Make a file reborn\n"
                  "            -df => Delete the object ID from it's file, given the filename\n"
                  "            -do => Delete the object ID from it's file, given the object ID\n"
                  "   E.g.:    -fileoid -g d:\\test.txt\n"
                  "            -fileoid -r d:\\test.txt\n"
                  "            -fileoid -f {C69F3AA6-8B4C-11D0-8C9D-00C04FD90F85}\n"
                  "            -fileoid -do {C69F3AA6-8B4C-11D0-8C9D-00C04FD90F85}\n"
                  "            -fileoid -df d:\\test.txt\n" );
        return( TRUE );
    }
    else
    if( 2 > cArgs
        ||
        rgptszArgs[0][0] != TEXT('-')
        &&
        rgptszArgs[0][0] != TEXT('/')
        )
    {
        printf( "Parameter error.  Use -? for usage info\n" );
    }

    *pcEaten = 2;

    // Convert the option to upper case (options are case-insensitive).
    _tcsupr( rgptszArgs[0] );

    __try
    {
        // Switch on the option (e.g, the 'F' in "-F")

        switch( rgptszArgs[0][1] )
        {

            //  --------------------------------
            //  Get a file name from an ObjectID
            //  --------------------------------

            case TEXT('F'):
                {
                    CDomainRelativeObjId droidBirth;

                    // Get the OID in binary format
                    CObjId oid;
                    TSZ2CLSID( rgptszArgs[1], (GUID*)&oid );

                    // Scan the volumes for this objectID

                    for (LONG vol = 0; vol < 26; vol++)
                    {
                        if( IsLocalObjectVolume( vol )
                            &&
                            NT_SUCCESS(FindLocalPath(vol, oid, &droidBirth, &tszUNCPath[2])) )
                        {
                            tszUNCPath[0] = VolChar(vol);
                            tszUNCPath[1] = TEXT(':');
                            break;
                        }
                    }

                    if( 'z'-'a' == vol )
                    {
                        hr = ERROR_FILE_NOT_FOUND;
                        __leave;
                    }

                    // Display the filename

                    wprintf( L"File name = \"%s\"\n", tszUNCPath );
                }

                break;


            //  --------------------
            //  Read/Get an ObjectID
            //  --------------------

            case TEXT('R'):
            case TEXT('G'):

                {

                    TCHAR tszFile[ MAX_PATH + 1 ];

                    MakeAbsolutePath( tszFile, rgptszArgs[1] );

                    CDomainRelativeObjId droidCurrent;
                    CDomainRelativeObjId droidBirth;

                    status = GetDroids( tszFile, &droidCurrent, &droidBirth,
                                        rgptszArgs[0][1] == TEXT('R') ? RGO_READ_OBJECTID : RGO_GET_OBJECTID );
                    if( !NT_SUCCESS(status) )
                    {
                        hr = status;
                        __leave;
                    }

                    _tprintf( TEXT("Current:\n") );
                    _tprintf( TEXT("   volid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidCurrent.GetVolumeId() )));
                    _tprintf( TEXT("   objid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidCurrent.GetObjId() )));

                    _tprintf( TEXT("Birth:\n") );
                    _tprintf( TEXT("   volid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidBirth.GetVolumeId() )));
                    _tprintf( TEXT("   objid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidBirth.GetObjId() )));

                }

                break;

            //  ---------------
            //  Set an ObjectID
            //  ---------------

            case TEXT('S'):

                {
                    HANDLE hFile;
                    CObjId objid;
                    IO_STATUS_BLOCK IoStatus;
                    TCHAR tszFile[ MAX_PATH + 1 ];

                    if( TEXT('R') == rgptszArgs[0][2] )
                    {
                        if( 2 > cArgs )
                        {
                            printf( "Parameter error.  Use -? for usage info\n" );
                            hr = E_FAIL;
                            goto Exit;
                        }
                        (*pcEaten)++;

                        MakeAbsolutePath( tszFile, rgptszArgs[1] );

                        status = TrkCreateFile( tszFile, FILE_READ_ATTRIBUTES,
                                                FILE_ATTRIBUTE_NORMAL,
                                                FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN,
                                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                                NULL,
                                                &hFile );
                        if (!NT_SUCCESS(status))
                        {
                            printf( "TrkCreateFile failed\n" );
                            hr = status;
                            __leave;
                        }
                        status = MakeObjIdReborn( hFile );
                        if( NT_SUCCESS(status) )
                            printf( "File is reborn\n" );
                        else
                            printf( "Failed to make reborn (%08x)\n", status );
                    }
                    else
                    {
                        TSZ2CLSID( rgptszArgs[1], (GUID*)&objid );

                        if( 3 > cArgs )
                        {
                            printf( "Parameter error.  Use -? for usage info\n" );
                            hr = E_FAIL;
                            goto Exit;
                        }
                        (*pcEaten)++;

                        MakeAbsolutePath( tszFile, rgptszArgs[2] );

                        status = TrkCreateFile( tszFile, FILE_READ_ATTRIBUTES,
                                                FILE_ATTRIBUTE_NORMAL,
                                                FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN,
                                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                                NULL,
                                                &hFile );
                        if (!NT_SUCCESS(status))
                        {
                            printf( "TrkCreateFile failed\n" );
                            hr = status;
                            __leave;
                        }

                        status = SetObjId( hFile, objid, CDomainRelativeObjId() );

                        if (!NT_SUCCESS(status))
                        {
                            printf( "FSCTL_SET_OBJECT_ID failed\n" );
                            hr = status;
                            __leave;
                        }
                        printf( "ID set ok\n" );
                    }

                }

                break;

            case TEXT('D'):
                {
                    if( TEXT('F') == rgptszArgs[0][2] )
                    {
                        TCHAR tszFile[ MAX_PATH + 1 ];
                        HANDLE hFile;
                        NTSTATUS status;
                        IO_STATUS_BLOCK IoStatus;

                        MakeAbsolutePath( tszFile, rgptszArgs[1] );

                        status = TrkCreateFile( tszFile, FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                                                FILE_ATTRIBUTE_NORMAL,
                                                FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN,
                                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                                NULL,
                                                &hFile );
                        if (!NT_SUCCESS(status))
                        {
                            printf( "TrkCreateFile failed\n" );
                            hr = status;
                            __leave;
                        }

                        status = NtFsControlFile(
                             hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             FSCTL_DELETE_OBJECT_ID,
                             NULL,  // in buffer
                             0,     // in buffer size
                             NULL,  // Out buffer
                             0);    // Out buffer size

                        if (!NT_SUCCESS(status))
                        {
                            printf( "FSCTL_DELETE_OBJECT_ID failed\n" );
                            hr = status;
                            __leave;
                        }
                        printf( "Deleted ok\n" );

                    }

                    else if( TEXT('O') == rgptszArgs[0][2] )
                    {
                        // Get the OID in binary format
                        CObjId oid;
                        CDomainRelativeObjId droidBirth;
                        TSZ2CLSID( rgptszArgs[1], (GUID*)&oid );
                        BOOL fFound = FALSE;

                        for (int vol='a'-'a'; vol<'z'-'a'; vol++)
                        {
                            if( IsLocalObjectVolume(CVolumeDeviceName(vol)) )
                            {
                                status = FindLocalPath(vol, oid, &droidBirth, &tszUNCPath[2]);
                                if( STATUS_OBJECT_NAME_NOT_FOUND == status )
                                    continue;
                                if( !NT_SUCCESS(status) ) goto Exit;

                                tszUNCPath[0] = VolChar(vol);
                                tszUNCPath[1] = TEXT(':');

                                _tprintf( TEXT("Deleting object ID on %s\n"), tszUNCPath );

                                status = DelObjId( vol, oid );
                                if( !NT_SUCCESS(status) ) goto Exit;
                                printf( "Deleted ok\n" );

                                break;
                            }
                        }

                        if( fFound ) printf( "Not found\n" );
                    }
                    else
                        printf( "Bad parameter\n" );
                }   // case TEXT('D'):
                break;


        }   // switch

        hr = S_OK;

    }   // __try

    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
        printf( "HR = %08X\n", hr );

    return SUCCEEDED(hr);

}






BOOL
DltAdminTemp( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fBound = FALSE;
    LONG iVol = 4;
    GUID volid = { /* 9f1534ee-ceab-4710-98b9-daaf048e3ad2 */
        0x9f1534ee,
        0xceab,
        0x4710,
        {0x98, 0xb9, 0xda, 0xaf, 0x04, 0x8e, 0x3a, 0xd2}
      };

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Refresh\n"
                " Purpose: Temp test placeholder\n"
                " Usage:   -temp\n" );
        return( TRUE );
    }


    rpcstatus = RpcStringBindingCompose( NULL, TEXT("ncalrpc"), NULL, TEXT("trkwks"),
                                         NULL, &ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;


    __try
    {
        hr = LnkSetVolumeId( hBinding, iVol, volid );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( TRUE );

}   // main()










CVolumeId
DisplayLogStatus( LONG iVol )
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;
    TCHAR tszLog[ MAX_PATH + 1 ];

    ULONG     cbRead;
    LogHeader logheader;
    LogInfo   loginfo;
    VolumePersistentInfo volinfo;

    _tcscpy( tszLog, CVolumeDeviceName(iVol) );
    _tcscat( tszLog, s_tszLogFileName );

    status = TrkCreateFile( tszLog, FILE_GENERIC_READ, FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, &hFile );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open %s"), tszLog ));
        TrkRaiseNtStatus(status);
    }

    if( !ReadFile( hFile, &logheader, sizeof(logheader), &cbRead, NULL )
        ||
        sizeof(logheader) != cbRead )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read log header") ));
        TrkRaiseLastError();
    }

    if( !ReadFile( hFile, &volinfo, sizeof(volinfo), &cbRead, NULL )
        ||
        sizeof(volinfo) != cbRead )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read volinfo") ));
        TrkRaiseLastError();
    }

    if( !ReadFile( hFile, &loginfo, sizeof(loginfo), &cbRead, NULL )
        ||
        sizeof(loginfo) != cbRead )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read loginfo") ));
        TrkRaiseLastError();
    }

    _tprintf( TEXT("\nLog Header:\n") );
    _tprintf( TEXT("    guidSignature = \t%s\n"), static_cast<const TCHAR*>(CStringize(logheader.guidSignature)) );
    _tprintf( TEXT("    dwFormat = \t\t0x%x,0x%x\n"), logheader.dwFormat>>16, logheader.dwFormat&0xFFFF );
    _tprintf( TEXT("    ProperShutdown = \t%s\n"), (logheader.dwFlags & PROPER_SHUTDOWN) ? TEXT("True") : TEXT("False") );
    _tprintf( TEXT("    DownlevelDirtied = \t%s\n"), (logheader.dwFlags & DOWNLEVEL_DIRTIED) ? TEXT("True") : TEXT("False") );
    _tprintf( TEXT("    Expansion start = \t%d\n"), logheader.expand.ilogStart );
    _tprintf( TEXT("              end = \t%d\n"), logheader.expand.ilogEnd );
    _tprintf( TEXT("              cb = \t%d\n"), logheader.expand.cbFile );


    _tprintf( TEXT("\nLog Information:\n") );
    _tprintf( TEXT("    Start = \t\t%lu\n"), loginfo.ilogStart );
    _tprintf( TEXT("    End = \t\t%lu\n"), loginfo.ilogEnd );
    _tprintf( TEXT("    Write = \t\t%lu\n"), loginfo.ilogWrite );
    _tprintf( TEXT("    Read = \t\t%lu\n"), loginfo.ilogRead );
    _tprintf( TEXT("    Last = \t\t%lu\n"), loginfo.ilogLast );
    _tprintf( TEXT("    seqNext = \t\t%li\n"), loginfo.seqNext );
    _tprintf( TEXT("    seqLastRead = \t%li\n"), loginfo.seqLastRead );


    CVolumeId volidNTFS;
    status = QueryVolumeId( iVol, &volidNTFS );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get NTFS volume ID") ));
        TrkRaiseNtStatus(status);
    }

    _tprintf( TEXT("\nVolume Information:\n") );
    _tprintf( TEXT("    Machine = \t\t%s\n"), static_cast<const TCHAR*>(CStringize(volinfo.machine)) );
    _tprintf( TEXT("    VolId (log) = \t%s\n"), static_cast<const TCHAR*>(CStringize(volinfo.volid)) );
    _tprintf( TEXT("    VolId (NTFS) = \t%s\n"), static_cast<const TCHAR*>(CStringize(volidNTFS)) );
    _tprintf( TEXT("    Secret = \t\t%s\n"), static_cast<const TCHAR*>(CStringize(volinfo.secret)) );
    _tprintf( TEXT("    Last Refresh = \t%d\n"), volinfo.cftLastRefresh.LowDateTime() );
    _tprintf( TEXT("    Enter not-owned = \t%s\n"), volinfo.cftEnterNotOwned == CFILETIME(0)
                                                        ? TEXT("(N/A)")
                                                        : static_cast<const TCHAR*>(CStringize(volinfo.cftEnterNotOwned)) );
    _tprintf( TEXT("    Make OIDs reborn = \t%s\n"), volinfo.fDoMakeAllOidsReborn ? TEXT("True") : TEXT("False") );
    _tprintf( TEXT("    Not-Created = \t%s\n"), volinfo.fNotCreated ? TEXT("True") : TEXT("False") );

    if( NULL != hFile )
        NtClose( hFile );

    return( volinfo.volid );
}



void
DisplayDcStatus( const CVolumeId &volid )
{
    CRpcClientBinding rc;
    TRKSVR_SYNC_VOLUME SyncVolume;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );

    printf( "\nDC Information:\n" );

    __try
    {
        Msg.MessageType = SYNC_VOLUMES;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_9;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;
        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = QUERY_VOLUME;
        SyncVolume.volume = volid;

        hr = LnkCallSvrMessage( rc, &Msg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    if( FAILED(hr) )
    {
        printf( "    Couldn't get status from DC:  %08x\n", hr );

        if( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr )
            printf( "    Make sure you have the 0x1 bit set in the TestFlags registry value\n" );

        goto Exit;
    }

    if( TRK_S_VOLUME_NOT_FOUND == SyncVolume.hr )
    {
        printf( "    Volume is not in DC\n" );
    }
    else if( TRK_S_VOLUME_NOT_OWNED == SyncVolume.hr )
    {
        printf( "    Volume is not owned by this machine\n" );
    }
    else if( S_OK == SyncVolume.hr )
    {
        _tprintf( TEXT("    Sequence # = \t%li\n"), SyncVolume.seq );
        _tprintf( TEXT("    Last Refresh = \t%lu\n"), SyncVolume.ftLastRefresh.dwLowDateTime );
                  //static_cast<const TCHAR*>(CStringize(CFILETIME(SyncVolume.ftLastRefresh))) );
    }
    else
    {
        printf( "    Volume state couldn't get queried from DC:  %08x\n", hr );
    }

Exit:

    return;
}


void
DisplayOidInformation( LONG iVol )
{

    CObjId                  objid;
    CDomainRelativeObjId    droid;
    CObjIdEnumerator        oie;

    ULONG cFilesWithOid         = 0;
    ULONG cCrossVolumeBitSet    = 0;

    if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
    {
        if(oie.FindFirst(&objid, &droid))
        {
            do
            {
                cFilesWithOid++;

                if( droid.GetVolumeId().GetUserBitState() )
                    cCrossVolumeBitSet++;

            } while(oie.FindNext(&objid, &droid));
        }
    }

    printf( "\nObjectID Information\n" );
    printf( "    Files with ObjectIDs = \t\t%lu\n", cFilesWithOid );
    printf( "    Files with x-volume bit set = \t%lu\n", cCrossVolumeBitSet );

}



VolumeStatistics( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    TCHAR* ptcTmp = NULL;
    BOOL fSuccess = FALSE;
    LONG iVol = 0;

    *pcEaten = 0;

    if( 1 > cArgs || IsHelpArgument(rgptszArgs[0]) )
    {
        printf( "\nOption VolStat\n"
                  "   Purpose:  Get link tracking info about a volume\n"
                  "   Usage:    -volstat <drive letter>\n"
                  "   E.g.:     -volstat D:\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    if( TEXT('a') > rgptszArgs[0][0]
        &&
        TEXT('z') < rgptszArgs[0][0]
        &&
        TEXT('A') > rgptszArgs[0][0]
        &&
        TEXT('Z') < rgptszArgs[0][0]
        ||
        TEXT(':') != rgptszArgs[0][1] )
    {
        printf( "Parameter error.  Use -? for usage info\n" );
        return( FALSE );
    }

    iVol = (LONG)((ULONG_PTR)CharLower((LPTSTR)rgptszArgs[0][0]) - TEXT('a'));

    if( !IsLocalObjectVolume( iVol ))
    {
        _tprintf( TEXT("%c: isn't a local NTFS5 volume\n"), VolChar(iVol) );
        goto Exit;
    }

    __try
    {
        CVolumeId volid;

        EnablePrivilege( SE_RESTORE_NAME );

        volid = DisplayLogStatus(iVol);
        DisplayDcStatus( volid );
        DisplayOidInformation( iVol );

        fSuccess = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        printf( "Fatal error:  %08x\n", GetExceptionCode() );
    }


Exit:

    return( fSuccess );

}   // main()










VolumeIdSetOrGet( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    NTSTATUS status = STATUS_SUCCESS;

    TCHAR tszFile[ MAX_PATH + 1 ];
    WCHAR wszFile[ MAX_PATH + 1 ];
    TCHAR tszUNCPath[ MAX_PATH + 1 ];
    WCHAR wszOID[ CCH_GUID_STRING + 1 ];
    ULONG cbInBuffer;
    TCHAR tszMachineName[ MAX_PATH + 1 ];
    LPCTSTR tszVolumePath = NULL;
    USHORT iVolume;

    OLECHAR oszOID[ CCH_GUID_STRING + 1 ];

    if( 1 == cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption VolId\n"
                  "   Purpose: Set or get volume IDs\n"
                  "   Usage:   -volid [-s <drive>: {GUID} | -g <drive>:]\n"
                  "   Where:   '-s' means Set, and '-g' means Get\n"
                  "   E.g.:    -volid -g d:\n"
                  "            -volid -s d: {d2a2ac27-b89a-11d2-9335-00805ffe11b8}\n" );
                               // The volid in this example is actually the well-known invalid volid
        *pcEaten = 1;
        return( TRUE );
    }
    else
    if( 2 > cArgs
        ||
        TEXT('-') != rgptszArgs[0][0]
        &&
        TEXT('/') != rgptszArgs[0][0]
        ||
        TEXT(':') != rgptszArgs[1][1] )
    {
        printf( "Invalid parameter.  Use -? for help\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 2;
    __try
    {
        CVolumeId volid;

        TCHAR tcCommand = (TCHAR)CharUpper( (LPTSTR) rgptszArgs[0][1] );
        TCHAR tcDrive   = (TCHAR)CharUpper( (LPTSTR) rgptszArgs[1][0] );
        LONG iVol = tcDrive - TEXT('A');


        if( TEXT('G') == tcCommand )
        {
            OLECHAR *poszVolId;

            status = QueryVolumeId( iVol, &volid );
            if( FAILED(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query for volume id") ));
                TrkRaiseNtStatus(status);
            }

            hr = StringFromCLSID( *(GUID*)&volid, &poszVolId );
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed StringFromClsid %08x"), hr ));
                TrkRaiseException( hr );
            }

            _tprintf( TEXT("VolID = %s\n"), poszVolId );
            CoTaskMemFree( poszVolId );

        }
        else if( TEXT('S') == tcCommand && 3 <= cArgs )
        {
            TSZ2CLSID( rgptszArgs[2], (GUID*)&volid );
            EnablePrivilege( SE_RESTORE_NAME );
            status = SetVolId( iVol, volid );
            if( FAILED(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set volume id") ));
                TrkRaiseNtStatus(status);
            }
        }
        else
        {
            printf( "Invalid parameter.  Use -? for help\n" );
            goto Exit;
        }

        hr = S_OK;
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return( SUCCEEDED(hr) );

}   // main()









BOOL
DltAdminVolInfoFile( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr;
    HANDLE hFile = NULL;
    IO_STATUS_BLOCK Iosb;
    OLECHAR *poszVolId = NULL;

    BYTE rgb[ 2 * MAX_PATH ];
    PFILE_FS_VOLUME_INFORMATION pfile_fs_volume_information
        = reinterpret_cast<PFILE_FS_VOLUME_INFORMATION>(rgb);
    PFILE_FS_ATTRIBUTE_INFORMATION pfile_fs_attribute_information
        = reinterpret_cast<PFILE_FS_ATTRIBUTE_INFORMATION>(rgb);
    PFILE_FS_OBJECTID_INFORMATION pfile_fs_objectid_information
        = reinterpret_cast<PFILE_FS_OBJECTID_INFORMATION>(rgb);

    FILE_FS_SIZE_INFORMATION file_fs_size_information;
    FILE_FS_FULL_SIZE_INFORMATION file_fs_full_size_information;
    FILE_FS_DEVICE_INFORMATION file_fs_device_information;

    TCHAR tszFileSystemAttributes[ 2 * MAX_PATH ];
    DWORD dwFileSystemAttributeMask;
    TCHAR *ptszDeviceType = NULL;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a file/directory name must be specified\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption VolInfoFile\n"
                  "   Purpose: Get volume information, given a file or directory name\n"
                  "   Usage:   -volinfofile <file or directory>\n"
                  "   E.g.     -volinfofile C:\\foo.doc\n"
                  "            -volinfofile \\\\scratch\\scratch\\jdoe\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    __try
    {
        *pcEaten = 1;

        TCHAR tszFileTime[ 80 ];

        status = TrkCreateFile(
                    rgptszArgs[0],
                    FILE_READ_ATTRIBUTES,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    &hFile );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open file \"%s\" (%08x)"), rgptszArgs[1], status ));
            TrkRaiseNtStatus(status);
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               pfile_fs_volume_information,
                                               sizeof(rgb),
                                               FileFsVolumeInformation );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query volume information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        pfile_fs_volume_information->VolumeLabel[ pfile_fs_volume_information->VolumeLabelLength/sizeof(WCHAR) ]
            = L'\0';

        static_cast<CFILETIME>(pfile_fs_volume_information->VolumeCreationTime)
                              .Stringize( ELEMENTS(tszFileTime), tszFileTime );

        _tprintf( TEXT("\n")
                  TEXT("Volume creation time:\t%08x:%08x (%s)\n")
                  TEXT("Volume serial number:\t%08x\n")
                  TEXT("Supports objects:\t%s\n")
                  TEXT("Volume label:\t\t%s\n"),
                  pfile_fs_volume_information->VolumeCreationTime.HighPart,
                  pfile_fs_volume_information->VolumeCreationTime.LowPart,
                  tszFileTime,
                  pfile_fs_volume_information->VolumeSerialNumber,
                  pfile_fs_volume_information->SupportsObjects ? TEXT("True") : TEXT("False"),
                  pfile_fs_volume_information->VolumeLabel );

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               pfile_fs_attribute_information,
                                               sizeof(rgb),
                                               FileFsAttributeInformation );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query attribute information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        pfile_fs_attribute_information->FileSystemName[ pfile_fs_attribute_information->FileSystemNameLength/sizeof(WCHAR) ]
            = L'\0';

        _tcscpy( tszFileSystemAttributes, TEXT("") );

        dwFileSystemAttributeMask = FILE_CASE_SENSITIVE_SEARCH
                                    | FILE_CASE_PRESERVED_NAMES
                                    | FILE_UNICODE_ON_DISK
                                    | FILE_PERSISTENT_ACLS
                                    | FILE_FILE_COMPRESSION
                                    | FILE_VOLUME_QUOTAS
                                    | FILE_SUPPORTS_SPARSE_FILES
                                    | FILE_SUPPORTS_REPARSE_POINTS
                                    | FILE_SUPPORTS_REMOTE_STORAGE
                                    | FILE_VOLUME_IS_COMPRESSED
                                    | FILE_SUPPORTS_OBJECT_IDS
                                    | FILE_SUPPORTS_ENCRYPTION;

        if( FILE_CASE_SENSITIVE_SEARCH & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tCase sensitive search\n"));
        if( FILE_CASE_PRESERVED_NAMES & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tCase preserved names\n"));
        if( FILE_UNICODE_ON_DISK & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tUnicode on disk\n"));
        if( FILE_PERSISTENT_ACLS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tPersistent ACLs\n"));
        if( FILE_FILE_COMPRESSION & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tFile compression\n"));
        if( FILE_VOLUME_QUOTAS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tVolume quotas\n"));
        if( FILE_SUPPORTS_SPARSE_FILES & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports sparse files\n"));
        if( FILE_SUPPORTS_REPARSE_POINTS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports reparse points\n"));
        if( FILE_SUPPORTS_REMOTE_STORAGE & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports remote storage\n"));
        if( FILE_VOLUME_IS_COMPRESSED & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tVolume is compressed\n"));
        if( FILE_SUPPORTS_OBJECT_IDS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports object IDs\n"));
        if( FILE_SUPPORTS_ENCRYPTION & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports encryption\n"));
        if( FILE_NAMED_STREAMS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports named streams\n"));
        if( !dwFileSystemAttributeMask & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\t(Unknown bit)"));


        _tprintf( TEXT("File system attributes:\t%08x\n%s")
                  TEXT("Max component name:\t%d\n")
                  TEXT("File system name\t%s\n"),
                  pfile_fs_attribute_information->FileSystemAttributes, tszFileSystemAttributes,
                  pfile_fs_attribute_information->MaximumComponentNameLength,
                  pfile_fs_attribute_information->FileSystemName );

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               pfile_fs_objectid_information,
                                               sizeof(rgb),
                                               FileFsObjectIdInformation );
        if( NT_SUCCESS(status) )
        {
            hr = StringFromCLSID( *(GUID*)pfile_fs_objectid_information->ObjectId, &poszVolId );
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed StringFromClsid %08x"), hr ));
                TrkRaiseException( hr );
            }

            _tprintf( TEXT("Volume Id:\t\t%s\n"), poszVolId );
            CoTaskMemFree( poszVolId );
        }
        else if( status != STATUS_INVALID_PARAMETER && status != STATUS_OBJECT_NAME_NOT_FOUND )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query objectid information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               &file_fs_full_size_information,
                                               sizeof(file_fs_full_size_information),
                                               FileFsFullSizeInformation );
        if( !NT_SUCCESS(status) )
        {
            status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                                   &file_fs_size_information,
                                                   sizeof(file_fs_size_information),
                                                   FileFsSizeInformation );
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query full size info or size info (%08x)"), status ));
                TrkRaiseNtStatus( status );
            }

            double TotalAllocInMB = file_fs_size_information.TotalAllocationUnits.QuadPart
                                    *
                                    file_fs_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_size_information.BytesPerSector
                                    /
                                    1000000.0;

            _tprintf( TEXT("Total allocation units:\t%I64u (%.2fMB)\n")
                      TEXT("Available alloc:\t%I64u units\n")
                      TEXT("Sectors per alloc unit:\t%d\n")
                      TEXT("Bytes per sector:\t%d\n"),
                      file_fs_size_information.TotalAllocationUnits.QuadPart,
                      TotalAllocInMB,
                      file_fs_size_information.AvailableAllocationUnits.QuadPart,
                      file_fs_size_information.SectorsPerAllocationUnit,
                      file_fs_size_information.BytesPerSector );

        }
        else
        {
            double TotalAllocInMB = file_fs_full_size_information.TotalAllocationUnits.QuadPart
                                    *
                                    file_fs_full_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_full_size_information.BytesPerSector
                                    /
                                    1000000.0;

            double CallerAvailAllocInMB
                                  = file_fs_full_size_information.CallerAvailableAllocationUnits.QuadPart
                                    *
                                    file_fs_full_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_full_size_information.BytesPerSector
                                    /
                                    1000000.0;

            double ActualAvailAllocInMB
                                  = file_fs_full_size_information.ActualAvailableAllocationUnits.QuadPart
                                    *
                                    file_fs_full_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_full_size_information.BytesPerSector
                                    /
                                    1000000.0;

            _tprintf( TEXT("Total allocation units:\t%I64u (%.2fMB)\n")
                      TEXT("Caller avail alloc:\t%I64u units (%.2fMB)\n")
                      TEXT("Actual avail alloc:\t%I64u units (%.2fMB)\n")
                      TEXT("Sectors per alloc unit:\t%d\n")
                      TEXT("Bytes per sector:\t%d\n"),
                      file_fs_full_size_information.TotalAllocationUnits.QuadPart,
                      TotalAllocInMB,
                      file_fs_full_size_information.CallerAvailableAllocationUnits.QuadPart,
                      CallerAvailAllocInMB,
                      file_fs_full_size_information.ActualAvailableAllocationUnits.QuadPart,
                      ActualAvailAllocInMB,
                      file_fs_full_size_information.SectorsPerAllocationUnit,
                      file_fs_full_size_information.BytesPerSector );
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               &file_fs_device_information,
                                               sizeof(file_fs_device_information),
                                               FileFsDeviceInformation );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query file fs device information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        switch( file_fs_device_information.DeviceType )
        {
        case FILE_DEVICE_NETWORK:
            ptszDeviceType = L"Network"; break;
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            ptszDeviceType = L"Network file system"; break;
        case FILE_DEVICE_CD_ROM:
            ptszDeviceType = L"CDROM"; break;
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            ptszDeviceType = L"CDROM file system"; break;
        case FILE_DEVICE_VIRTUAL_DISK:
            ptszDeviceType = L"Virtual disk"; break;
        case FILE_DEVICE_DISK:
            ptszDeviceType = file_fs_device_information.Characteristics & FILE_REMOVABLE_MEDIA
                ? L"Removable disk" : L"Fixed disk";
            break;
        case FILE_DEVICE_DISK_FILE_SYSTEM:
            ptszDeviceType = file_fs_device_information.Characteristics & FILE_REMOVABLE_MEDIA
                ? L"Removable disk file system" : L"Fixed disk file system";
            break;
        default:
            ptszDeviceType = L"Unknown";
        }

        _tprintf( TEXT("Device Type:\t\t%s%s\n"),
                  ptszDeviceType,
                  (file_fs_device_information.Characteristics & FILE_REMOTE_DEVICE)
                      ? TEXT(" (remote)")
                      : TEXT("")
                  );


        hr = S_OK;

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

    if( NULL != hFile )
        NtClose( hFile );


    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return SUCCEEDED(hr);
}



BOOL
DeleteIdFromVolumeTable( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CVolumeId volid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRKSVR_SYNC_VOLUME SyncVolume;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a volume ID name must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Deleting volume %s from DC volume table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption DelDcVolId\n"
                  "   Purpose: Delete a volume ID from the DC volume table\n"
                  "   Usage:   -deldcvolid <stringized volume ID>\n"
                  "   E.g.     -deldcvolid {56730825-3ddc-11d2-a168-00805ffe11b8}\n"
                  "   Note:    The volume ID must be owned by this machine.\n"
                  "            Also, the services\\trkwks\\parameters\\configuration\\trkflags\n"
                  "            reg value must have the 0x1 bit set.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    // Convert the volid string to a volid

    stringize.Use( rgptszArgs[0] );
    volid = stringize;

    if( CVolumeId() == volid )
    {
        _tprintf( TEXT("Error: Invalid volume ID\n") );
        return( FALSE );
    }

    // Send the delete request

    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        Msg.MessageType = SYNC_VOLUMES;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_9;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;
        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = DELETE_VOLUME;
        SyncVolume.volume = volid;

        hr = LnkCallSvrMessage( rc, &Msg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if( SUCCEEDED(hr) )
        hr = SyncVolume.hr;

    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else if( S_OK != hr )
        _tprintf( TEXT("Success code: %08x\n"), hr );

    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return( SUCCEEDED(hr) );

}


BOOL
DeleteIdFromMoveTable( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CDomainRelativeObjId droid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a birth ID name must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Deleting file %s from DC move table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption DelDcMoveId\n"
                  "   Purpose: Delete an entry from the DC move table\n"
                  "   Usage:   -deldcmoveid <stringized GUIDs of birth ID>\n"
                  "   E.g.     -deldcmoveid {xxx...xxx}{xxx...xxx}\n"
                  "   Where:   a stringized GUID is e.g. \"{56730825-3ddc-11d2-a168-00805ffe11b8}\"\n"
                  "   Note:    The birth ID must be owned by this machine.\n"
                  "            Also, the services\\trkwks\\parameters\\configuration\\trkflags\n"
                  "            reg value must have the 0x1 bit set.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    stringize.Use( rgptszArgs[0] );
    droid = stringize;

    if( CDomainRelativeObjId() == droid )
    {
        _tprintf( TEXT("Error: Invalid birth ID\n") );
        return( FALSE );
    }


    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        CVolumeId volidDummy;
        Msg.MessageType = DELETE_NOTIFY;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_5;
        Msg.Delete.cVolumes = 0;
        Msg.Delete.pVolumes = &volidDummy;

        Msg.Delete.adroidBirth = &droid;
        Msg.Delete.cdroidBirth = 1;

        LnkCallSvrMessage(rc, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }


    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else if( S_OK != hr )
        _tprintf( TEXT("Success code: %x\n"), hr );

    return( SUCCEEDED(hr) );
}





BOOL
DltAdminLookupVolId( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CVolumeId volid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRKSVR_SYNC_VOLUME SyncVolume;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a volume ID name must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Searching for volume %s in DC volume table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption LookupVolId\n"
                  "   Purpose: Look up a volume ID from the DC volume table\n"
                  "   Usage:   -lookupvolid <stringized volume ID>\n"
                  "   E.g.     -lookupvolid {56730825-3ddc-11d2-a168-00805ffe11b8}\n"
                  "   Note:    The services\\trkwks\\parameters\\configuration\\trkflags\n"
                  "            reg value must have the 0x1 bit set before trkwks is started.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    // Convert the volid string to a volid

    stringize.Use( rgptszArgs[0] );
    volid = stringize;

    if( CVolumeId() == volid )
    {
        _tprintf( TEXT("Error: Invalid volume ID\n") );
        return( FALSE );
    }

    // Send the delete request

    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        Msg.MessageType = SYNC_VOLUMES;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_9;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;
        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = FIND_VOLUME;
        SyncVolume.volume = volid;

        hr = LnkCallSvrMessage( rc, &Msg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if( SUCCEEDED(hr) )
        hr = SyncVolume.hr;

    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else
    {
        if( S_OK != hr )
            _tprintf( TEXT("Success code is %08x\n"), hr );

        _tprintf( TEXT("Machine = \"%s\"\n"), static_cast<const TCHAR*>(CStringize(SyncVolume.machine)) );
    }

    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return( SUCCEEDED(hr) );

}






BOOL
DltAdminLookupDroid( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CVolumeId volid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRK_FILE_TRACKING_INFORMATION FileTrackingInformation;
    TRKSVR_MESSAGE_UNION Msg;
    CDomainRelativeObjId droid;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a DROID must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Searching for move ID %s in DC volume table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption LookupDroid\n"
                  "   Purpose: Look up a DROID from the DC move table\n"
                  "   Usage:   -lookupdroid <stringized DROIID>\n"
                  "   E.g.     -lookupdroid {f8b534f0-b65b-11d2-8fd8-0008c709d19e}{0ed45deb-03ed-11d3-b766-00805ffe11b8}\n"
                  "   Note:    You must be running as an administrator\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    stringize.Use( rgptszArgs[0] );
    droid = stringize;

    if( CDomainRelativeObjId() == droid )
    {
        _tprintf( TEXT("Error: Invalid birth ID\n") );
        return( FALSE );
    }


    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        memset( &FileTrackingInformation, 0, sizeof(FileTrackingInformation) );
        FileTrackingInformation.droidLast = droid;

        Msg.MessageType = SEARCH;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_5;
        Msg.Search.cSearch = 1;
        Msg.Search.pSearches = &FileTrackingInformation;

        LnkCallSvrMessage(rc, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }


    if( SUCCEEDED(hr) )
        hr = FileTrackingInformation.hr;

    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else
    {
        if( S_OK != hr )
            _tprintf( TEXT("Success code is %08x\n"), hr );

        _tprintf( TEXT("Machine = \"%s\"\n"), static_cast<const TCHAR*>(CStringize(FileTrackingInformation.mcidLast)) );
    }

    return( TRUE );
}






EXTERN_C void __cdecl _tmain( int cArgs, TCHAR *prgtszArg[])
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    int iArg = 0;
    int iError = 0;

    OLECHAR oszOID[ CCH_GUID_STRING + 1 ];

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "DltAdmin" );
    hr = CoInitialize( NULL );
    if (FAILED(hr))
    {
        _tprintf( TEXT("Unable to CoInitialize( NULL )-- aborting. (0x%08x)\n"), 
                  hr );
        return;
    }

    TCHAR tszStringizedTime[ 80 ];

    __try
    {
        // Skip over the executable name
        iArg++;
        cArgs--;

        if( 0 == cArgs )
        {
            Usage();
            exit(1);
        }

        for( ; iArg <= cArgs; cArgs--, iArg++ )
        {
            ULONG cEaten = 0;

            if( TEXT('-') != prgtszArg[iArg][0]
                &&
                TEXT('/') != prgtszArg[iArg][0] )
            {
                _tprintf( TEXT("Invalid option, ignoring: %s\n"), prgtszArg[iArg] );
                iError = max( iError, 1 );
                continue;
            }

            if( !_tcsicmp( TEXT("deldcvolid"), &prgtszArg[iArg][1] ) )
            {
                iArg++;
                cArgs--;
                if( !DeleteIdFromVolumeTable( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );

                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("deldcmoveid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DeleteIdFromMoveTable( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("lookupvolid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLookupVolId( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("lookupdroid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLookupDroid( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("volinfofile"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminVolInfoFile( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("cleanvol"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminCleanVol( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("svrstat"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminSvrStat( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("volstat"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !VolumeStatistics( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("volid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !VolumeIdSetOrGet( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("lockvol"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLockVol( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("fileoid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminFileOid( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("enumoids"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminEnumOids( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("oidsnap"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminOidSnap( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("link"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLink( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("loadlib"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( LOAD_LIBRARY, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("freelib"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( FREE_LIBRARY, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("debugbreak"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( DEBUG_BREAK, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("createprocess"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( CREATE_PROCESS, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("config"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminConfig( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("refresh"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminRefresh( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("setvolseq"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminSetVolumeSeqNumber( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("setdroidseq"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminSetDroidSeqNumber( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("backupread"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminBackupRead( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("backupwrite"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminBackupWrite( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("sleep"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;
                Sleep( 1000 );
            }
            else if( !_tcsicmp( TEXT("temp"), &prgtszArg[iArg][1] ))
            {
                if( !DltAdminTemp( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( TEXT('?') == prgtszArg[iArg][1] )
            {
                Usage();
                exit( 1 );
            }
            else
            {
                _tprintf( TEXT("Invalid option, ignoring: %s\n"), prgtszArg[iArg] );
                iError = max( iError, 1 );
                continue;
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        iError = max( iError, 2 );
    }

    if( FAILED(hr) )
        printf( "HR = %08X\n", hr );

    CoUninitialize();

//    return( iError );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\backup.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "trksvr.hxx"
#include "dltadmin.hxx"

BOOL
DltAdminBackupRead( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    HANDLE hSource = NULL;
    HANDLE hBackup = NULL;
    BYTE rgb[ 8 * 1024 ];
    ULONG cbRead, cbWritten;
    void *pvBackup = NULL;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption BackupRead\n"
                  "   Purpose: Run the BackupRead API on a file\n"
                  "   Usage:   -backupread <file to be read> <read data>\n"
                  "   E.g.:    -backupread file.tst file.tst.bak\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    if( 2 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    // Open the source file

    hSource = CreateFile( rgptszArgs[0],
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL );
    if( INVALID_HANDLE_VALUE == hSource )
    {
        printf( "Failed to open file (%lu)\n", GetLastError() );
        return FALSE;
    }

    // Open the backup file
                          
    hBackup = CreateFile( rgptszArgs[1],
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          0,
                          NULL );
    if( INVALID_HANDLE_VALUE == hBackup )
    {
        printf( "Failed to open backup file (%lu)\n", GetLastError() );
        return FALSE;
    }
    

    while( TRUE )
    {
        if( !BackupRead( hSource,
                         rgb,
                         sizeof(rgb),
                         &cbRead,
                         FALSE,
                         FALSE, //TRUE,
                         &pvBackup ))
        {
            printf( "Failed BackupRead (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( !WriteFile( hBackup, rgb, cbRead, &cbWritten, NULL ))
        {
            printf( "Failed WriteFile (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( cbRead < sizeof(rgb) )
            break;
    }

    // Free resources
    BackupRead( hSource, rgb, sizeof(rgb), &cbRead, TRUE, TRUE, &pvBackup );

    CloseHandle( hSource );
    CloseHandle( hBackup );

    return TRUE;

}


BOOL
DltAdminBackupWrite( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    HANDLE hRestore = NULL;
    HANDLE hBackup = NULL;
    BYTE rgb[ 8 * 1024 ];
    ULONG cbRead, cbWritten;
    void *pvBackup = NULL;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption BackupWrite\n"
                  "   Purpose: Run the BackupWrite API on a file\n"
                  "   Usage:   -backupread <backup file> <restored file>\n"
                  "   E.g.:    -backupread file.tst.bak file.tst\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    if( 2 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    // Open the backup file

    hBackup = CreateFile( rgptszArgs[0],
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL );
    if( INVALID_HANDLE_VALUE == hBackup )
    {
        printf( "Failed to open backup file (%lu)\n", GetLastError() );
        return FALSE;
    }

    // Open the restore file
                          
    hRestore = CreateFile( rgptszArgs[1],
                           GENERIC_READ | GENERIC_WRITE | WRITE_DAC,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_FLAG_BACKUP_SEMANTICS,
                           NULL );
    if( INVALID_HANDLE_VALUE == hRestore )
    {
        printf( "Failed to open restore file (%lu)\n", GetLastError() );
        return FALSE;
    }
    

    while( TRUE )
    {
        if( !ReadFile( hBackup, rgb, sizeof(rgb), &cbRead, NULL ))
        {
            printf( "Failed ReadFile (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( !BackupWrite( hRestore,
                          rgb,
                          cbRead,
                          &cbWritten,
                          FALSE,
                          FALSE, //TRUE,
                          &pvBackup ))
        {
            printf( "Failed BackupWrite (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( cbRead < sizeof(rgb) )
            break;
    }

    // Free resources
    BackupWrite( hRestore, rgb, 0, &cbWritten, TRUE, TRUE, &pvBackup );

    CloseHandle( hRestore );
    CloseHandle( hBackup );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\cleanvol.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"


class CLogFileNotify : public PLogFileNotify
{
    void OnHandlesMustClose()
    {
        return;
    }
};


BOOL
EmptyLogFile( LONG iVol )
{
    LogInfo loginfo, loginfoNew;
    CLogFile logfile;
    BOOL fSuccess = FALSE;
    TCHAR tszFile[ MAX_PATH + 1 ];
    CTrkWksConfiguration wksconfig;
    CLogFileNotify logfilenotify;

    __try
    {
        wksconfig.Initialize();

        memset( &loginfo, 0, sizeof(loginfo) );
        memset( &loginfoNew, 0, sizeof(loginfoNew) );

        logfile.Initialize( static_cast<const TCHAR*>(CVolumeDeviceName(iVol)),
                            &wksconfig, &logfilenotify, VolChar(iVol) );
        logfile.ReadExtendedHeader( CLOG_LOGINFO_START, &loginfo, sizeof(loginfo) );

        loginfoNew.ilogStart = loginfoNew.ilogWrite = loginfoNew.ilogRead = 0;
        loginfoNew.ilogLast = loginfoNew.ilogEnd = loginfo.ilogEnd;

        loginfoNew.seqNext = 0;
        loginfoNew.seqLastRead = loginfoNew.seqNext - 1;

        logfile.WriteExtendedHeader( CLOG_LOGINFO_START, &loginfoNew, sizeof(loginfoNew) );
        logfile.SetShutdown( TRUE );

        logfile.InitializeLogEntries( 0, logfile.NumEntriesInFile() - 1 );

        _tprintf( TEXT("    Emptied log\n" ) );
        fSuccess = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        logfile.UnInitialize();
    }

    return( fSuccess );
}


BOOL
DeleteLogFile( LONG iVol )
{
    NTSTATUS status;
    BOOL fSuccess = FALSE;
    TCHAR tszFile[ MAX_PATH + 1 ];

    __try   // __except
    {
        status = SetVolId( iVol, CVolumeId() );
        if( !NT_SUCCESS(status) )
        {
            _tprintf( TEXT("    Couldn't delete vol ID (%08x)\n"), status );
            __leave;
        }

        _tcscpy( tszFile, static_cast<const TCHAR*>(CVolumeDeviceName(iVol)) );
        _tcscat( tszFile, s_tszLogFileName );

        for( int i = 0; i < 4; i ++ )
        {
            // Delete the file

            if(!DeleteFile( tszFile ))
            {
                LONG lLastError = GetLastError();
                if( ERROR_FILE_NOT_FOUND != lLastError
                    &&
                    ERROR_PATH_NOT_FOUND != lLastError )
                {
                    _tprintf(TEXT("    Couldn't delete %s (%08x)\n"), tszFile, GetLastError());
                }
            }
            else
                _tprintf( TEXT("    Deleted %s\n"), tszFile );

            if( 1 & i ) // 1, 3
            {
                CDirectoryName dirname;
                dirname.SetFromFileName( tszFile );

                if(!RemoveDirectory( dirname ))
                {
                    LONG lLastError = GetLastError();
                    if( ERROR_FILE_NOT_FOUND != lLastError )
                    {
                       _tprintf(TEXT("    Couldn't delete %s (%lu)\n"),
                                     static_cast<const TCHAR*>(dirname), lLastError);
                    }
                }
                else
                    _tprintf( TEXT("    Deleted %s\n"), static_cast<const TCHAR*>(dirname) );

                _tcscpy( tszFile, static_cast<const TCHAR*>(CVolumeDeviceName(iVol)) );
                _tcscat( tszFile, s_tszOldLogFileName );

            }
            else
                _tcscat( tszFile, TEXT(".bak") );

        }

        fSuccess = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        _tprintf( TEXT("Exception %08x in DeleteLogFileAndOids"), GetExceptionCode() );
    }

    return( fSuccess );

}

BOOL
DltAdminCleanVol( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status = 0;
    TCHAR* ptcTmp = NULL;
    LONG iVol, iVolChar = 0;
    BOOL fSuccess = TRUE;
    BOOL fEmptyLog = FALSE;

    *pcEaten = 0;

    if( 1 <= cArgs )
    {
        _tcsupr( rgptszArgs[0] );

        if( IsHelpArgument( rgptszArgs[0] ))
        {
            printf( "\nOption CleanVol\n"
                      "   Purpose:  Clean all the IDs (object and volume) a volume\n"
                      "   Usage:    -cleanvol [options] [drive letter]\n"
                      "   Options:  -e  Empty log rather than deleting it\n"
                      "   E.g.:     -cleanvol -r D:\n"
                      "             -cleanvol\n"
                      "   Note:     If no drive is specified, all drives will be cleaned\n" );
            *pcEaten = 1;
            return( TRUE );
        }

        if( TEXT('-') == rgptszArgs[0][0]
            ||
            TEXT('/') == rgptszArgs[0][0] )
        {
            (*pcEaten)++;
            switch( rgptszArgs[0][1] )
            {
            case 'E':
                fEmptyLog = TRUE;
                break;
            default:
                _tprintf( TEXT("Invalid option.  Use -cleanvol -? for help\n") );
                return( TRUE );
            }

            iVolChar = 1;
        }
        else
            iVolChar = 0;
    }


    if( iVolChar < cArgs )
    {
        (*pcEaten)++;
        _tcsupr( rgptszArgs[iVolChar] );
        iVol = *rgptszArgs[iVolChar] - TEXT('A');
    }
    else
        iVol = 0;

    EnablePrivilege( SE_RESTORE_NAME );

    while( iVol < 26 )
    {
        if( IsLocalObjectVolume( iVol ))
        {
            LONG lLastError = 0;

            printf( "Cleaning volume %c:\n", iVol+TEXT('A') );

            if( fEmptyLog )
                fSuccess = EmptyLogFile( iVol );
            else
                fSuccess = DeleteLogFile( iVol );

            __try // except
            {
                CObjId                  objid;
                CDomainRelativeObjId    droid;
                CObjIdEnumerator        oie;
                ULONG                   cObjId = 0;

                if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
                {
                    if(oie.FindFirst(&objid, &droid))
                    {
                        do
                        {
                            DelObjId( iVol, objid );
                            cObjId++;
                        } while(oie.FindNext(&objid, &droid));

                        printf( "    Deleted %d object ID%s\n",
                                cObjId,
                                1 == cObjId ? "" : "s" );
                    }
                }
            }
            __except( BreakOnDebuggableException() )
            {
            }

        }   // if( IsLocalObjectVolume( iVol ))

        if( 1 <= cArgs ) break;
        iVol++;

    }   // while( iVol < 26 )

    return( fSuccess );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\config.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"



HRESULT
SendParameterValueToService( BOOL fTrkWks, DWORD dwParameter, DWORD dwValue )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fBound = FALSE;
    TRKSVR_MESSAGE_UNION Msg;

    if( !fTrkWks )
        return( HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED ));

    rpcstatus = RpcStringBindingCompose( NULL, TEXT("ncalrpc"), NULL, TEXT("trkwks"),
                                         NULL, &ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;

    memset( &Msg, 0, sizeof(Msg) );
    Msg.MessageType = WKS_CONFIG;
    Msg.Priority = PRI_0;
    Msg.WksConfig.dwParameter = dwParameter;
    Msg.WksConfig.dwNewValue = dwValue;

    __try
    {
        hr = LnkCallSvrMessage( hBinding, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( hr );

}









BOOL
DltAdminConfig( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    BOOL fTrkWks = FALSE;
    LONG iArg = 0;
    BOOL fDynamic = FALSE;


    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Config\n"
                " Purpose: Set tracking service configuration\n"
                " Usage:   -config <trkwks|trksvr> [options] [<parameter> <value>]\n"
                "          If the parm/value is ommitted, a list\n"
                "          of parameters is displayed\n"
                " Options: -d  Attempt to dynamically change the parameter\n"
                "              on the running service\n"
                " E.g.:    -config trkwks VolInitInitialDelay 0\n"
                "          -config trkwks\n"
                "          -config trkwks -d MoveNotifyTimeout 5\n" );
        return( TRUE );
    }

    if( !_tcsicmp( rgptszArgs[iArg], TEXT("trkwks") ))
        fTrkWks = TRUE;
    else if( !_tcsicmp( rgptszArgs[iArg], TEXT("trksvr") ))
        fTrkWks = FALSE;
    else
    {
        _tprintf( TEXT("Invalid service name (%s).  Use -? for help\n"), rgptszArgs[0] );
        return( FALSE );
    }
    iArg++;

    while( iArg < cArgs
           &&
           ( rgptszArgs[ iArg ][0] == TEXT('/')
             ||
             rgptszArgs[ iArg ][0] == TEXT('-') ) )
    {
        _tcsupr( rgptszArgs[ iArg ] );
        switch( rgptszArgs[ iArg ][ 1 ] )
        {
        case TEXT('D'):
            fDynamic = TRUE;
            break;
            
        default:
            _tprintf( TEXT("Unknown option (%s).  Use -? for help\n"), rgptszArgs[iArg] );
            return( FALSE );
        }

        iArg++;
        (*pcEaten)++;
    }

    if( iArg + 2 != cArgs
        &&
        iArg != cArgs )
    {
        printf( "Invalid parameters.  Use -? for help\n" );
        return( FALSE );
    }
    (*pcEaten) += 2;

    if( fTrkWks )
    {
        CTrkWksConfiguration configWks;
        configWks.Initialize( TRUE ); // => Persistable

        if( iArg == cArgs )
            printf( "Configurable parameters:\n\n" );

        for( int i = 0; i < configWks.GetParameterCount(); i++ )
        {
            if( iArg == cArgs )
            {
                _tprintf( TEXT("   %s\n"), configWks.GetParameterName( i ) );
            }

            else if( !_tcsicmp( configWks.GetParameterName(i), rgptszArgs[iArg] ))
            {
                DWORD dwValue;
                if( 1 == _stscanf( rgptszArgs[iArg+1], TEXT("0x%x"), &dwValue )
                    ||
                    1 == _stscanf( rgptszArgs[iArg+1], TEXT("%lu"), &dwValue) )
                {
                    if( fDynamic )
                    {
                        HRESULT hr = SendParameterValueToService( fTrkWks, i, dwValue );
                        if( FAILED(hr) )
                        {
                            _tprintf( TEXT("Couldn't set %s in service (%08x)"),
                                      rgptszArgs[iArg], hr );
                            return( FALSE );
                        }
                        else
                        {

                        }
                    }

                    HRESULT hr = configWks.PersistParameter( i, dwValue );
                    if( FAILED(hr) )
                    {
                        printf( "Couldn't write parameter to registry (%08x)", hr );
                        return( FALSE );
                    }
                    else
                    {
                        _tprintf( TEXT("Set %s to 0x%x\n"), configWks.GetParameterName(i), dwValue );
                    }
                }
                else
                {
                    _tprintf( TEXT("Couldn't interpret parameter value (%s)\n"), rgptszArgs[iArg+1] );
                    return( FALSE );
                }

                break;
            }
        }
    }



    return( TRUE );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\oidsnap.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"


inline void
WriteToSnapshot( HANDLE hFileSnapshot, const TCHAR *ptsz )
{
    ULONG cb, cbWritten;

    if( NULL != ptsz )
        cb = _tcslen( ptsz ) * sizeof(TCHAR);
    else
    {
        cb = sizeof(TCHAR);
        ptsz = TEXT("");
    }

    if( !WriteFile( hFileSnapshot, ptsz, cb, &cbWritten, NULL ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed WriteFile (%lu)"), GetLastError() ));
        TrkRaiseLastError();
    }

    if( cb != cbWritten )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Not all of the data was written (%d/%d)"),
                 cbWritten, cb ));
        TrkRaiseWin32Error( ERROR_WRITE_FAULT );
    }
}


BOOL
DltAdminOidSnap( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    TCHAR* ptcTmp = NULL;
    LONG iVol;
    BOOL fSuccess = TRUE;
    BOOL fSaving = FALSE;
    HANDLE hFileSnapshot = INVALID_HANDLE_VALUE;
    HANDLE hMapping = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK Iosb;
    TCHAR tszFileData[ 3 * MAX_PATH ];
    ULONG cLine = 0;


    if( cArgs >= 2 )
    {
        _tcslwr( rgptszArgs[0] );
        _tcslwr( rgptszArgs[1] );
    }

    if( 3 != cArgs
        ||
        TEXT('-') != rgptszArgs[0][0] && TEXT('/') != rgptszArgs[0][0]
        ||
        TEXT('g') != rgptszArgs[0][1] && TEXT('s') != rgptszArgs[0][1]
        ||
        TEXT(':') != rgptszArgs[1][1]
        ||
        TEXT('a') > rgptszArgs[1][0] || TEXT('z') < rgptszArgs[1][0] )
    {
        printf( "\nOption OidSnap\n"
                " Purpose: Take a snapshot of the volume ID and all object IDs for a volume\n"
                " Usage:   -oidsnap [-g|-s] <drive letter>: <snapshot file>\n"
                " Where:   -g indicates get (create a snapshot)\n"
                "          -s indicates set (from the snapshot file)\n"
                " E.g.:    -oidsnap -g d: snapshot.txt\n"
                "          -oidsnap -s d: snapshot.txt\n" );
        return( TRUE );
    }


    fSaving = TEXT('g') == rgptszArgs[0][1];

    iVol = rgptszArgs[1][0] - TEXT('a');
    if( !IsLocalObjectVolume( iVol ))
    {
        _tprintf( TEXT("%c: isn't an NTFS5 volume\n"), VolChar(iVol) );
        goto Exit;
    }


    __try
    {
        FILE_FS_OBJECTID_INFORMATION fsobOID;

        EnableRestorePrivilege();

        // Open the snapshot file

        hFileSnapshot = CreateFile( rgptszArgs[2],
                            fSaving ? GENERIC_WRITE : GENERIC_READ,
                            0, NULL,
                            fSaving ? CREATE_ALWAYS : OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFileSnapshot )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open file: %s (%lu)"),
                     rgptszArgs[2], GetLastError() ));
            TrkRaiseLastError();
        }

        //  ----
        //  Save
        //  ----

        if( fSaving )
        {
            // Get the volid

            CVolumeId volid;
            status = QueryVolumeId( iVol, &volid );
            if( STATUS_OBJECT_NAME_NOT_FOUND != status && !NT_SUCCESS(status) )
                TrkRaiseNtStatus( status );

            // Write the volid to the snapshot file.

            WriteToSnapshot( hFileSnapshot, TEXT("VolId, ") );

            CStringize strVolid(volid);
            WriteToSnapshot( hFileSnapshot, static_cast<const TCHAR*>(strVolid) );
            WriteToSnapshot( hFileSnapshot, TEXT("\n") );
            WriteToSnapshot( hFileSnapshot, NULL );
            cLine++;

            CObjId                  objid;
            CDomainRelativeObjId    droidBirth;
            CObjIdEnumerator        oie;

            // Loop through the files with object IDs

            if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
            {
                if(oie.FindFirst(&objid, &droidBirth))
                {
                    do
                    {
                        // Open the file so that we can get its path

                        HANDLE hFile;
                        status = OpenFileById(  iVol, objid, SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                                0, &hFile);
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed OpenFileById for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Get the local path 

                        status = QueryVolRelativePath( hFile, tszFileData );
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed QueryVolRelativePath for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Write the path, objid, and birth ID to the snapshot file.

                        _tcscat( tszFileData, TEXT(" = ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(objid)) );
                        _tcscat( tszFileData, TEXT(", ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(droidBirth)) );
                        _tcscat( tszFileData, TEXT("\n") );


                        // Write a line terminator to the snapshot file.

                        WriteToSnapshot( hFileSnapshot, tszFileData );
                        WriteToSnapshot( hFileSnapshot, NULL );

                        cLine++;

                    } while(oie.FindNext(&objid, &droidBirth));

                    // Write an marker to show end-of-file

                    WriteToSnapshot( hFileSnapshot, TEXT("\n") );
                    WriteToSnapshot( hFileSnapshot, NULL );
                }
            }

            printf( "%d IDs saved\n", cLine );
        
        }   // if fSaving

        //  ---------
        //  Restoring
        //  ---------

        else
        {
            ULONG cCollisions = 0, cSuccess = 0;
            TCHAR *ptsz = NULL;

            // Map the snapshot file into memory.

            hMapping = CreateFileMapping( hFileSnapshot, NULL, PAGE_READONLY, 0, 0, NULL );
            if( NULL == hMapping )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed CreateFileMapping") ));
                TrkRaiseLastError();
            }

            ptsz = reinterpret_cast<TCHAR*>( MapViewOfFile( hMapping, FILE_MAP_READ, 0, 0, 0 ));
            if( NULL == ptsz )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't map view of file") ));
                TrkRaiseLastError();
            }

            // The file should start with the volid

            if( NULL == _tcsstr( ptsz, TEXT("VolId, ") ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't find volid") ));
                TrkRaiseException( E_FAIL );
            }

            // Move ptsz to the start of the stringized volid
            ptsz += _tcslen(TEXT("VolId, "));

            // Unstringize the volid and set it on the volume.

            CVolumeId volid;
            CStringize stringize;
            stringize.Use( ptsz );
            volid = stringize;

            status = SetVolId( iVol, volid );
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set volid") ));
                TrkRaiseNtStatus(status);
            }
            cSuccess++;

            // Move past the eol & null after the volid.

            ptsz = _tcschr( ptsz, TEXT('\n') );
            if( NULL == ptsz || TEXT('\0') != ptsz[1] )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Unexpected end of file") ));
                TrkRaiseException( E_FAIL );
            }
            cLine++;
            ptsz += 2;  // Past '\n' and '\0'

            // Init tszPath with the drive letter.

            TCHAR tszPath[ MAX_PATH + 1 ];
            tszPath[0] = VolChar(iVol);
            tszPath[1] = TEXT(':');

            // Loop through the object IDs in the snapshot file.
            // They are in the form:
            //
            //    <file> = <objid>, <birth ID>
            //
            // E.g.
            //    \test = {...}, {...}{...}

            while( TRUE )
            {
                // Find the separator between the file name and the objid

                TCHAR *ptszSep;
                ptszSep = _tcschr( ptsz, TEXT('=') );
                if( NULL == ptszSep )
                    TrkRaiseException( E_FAIL );

                // cch is the length of the file name

                ULONG cch = ptszSep - ptsz;
                if( 0 == cch )
                    TrkRaiseException( E_FAIL );
                cch--;

                // Put the file name into tszPath

                _tcsncpy( &tszPath[2], ptsz, cch );
                tszPath[2+cch] = TEXT('\0');

                // Move ptsz to the beginning of the stringized objid

                ptsz = ptszSep + 1;
                if( TEXT(' ') != *ptsz )
                    TrkRaiseException( E_FAIL );
                ptsz++;

                // Unstringize the objid

                stringize.Use( ptsz );
                CObjId objid = stringize;

                // Move ptsz to the beginning of the birth ID, and unstringize it.

                ptsz = _tcschr( ptsz, TEXT(',') );
                if( NULL == ptsz || TEXT(' ') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                ptsz += 2;
                stringize.Use( ptsz );
                CDomainRelativeObjId droidBirth;
                droidBirth = stringize;

                // Set the objid and birth ID

                status = SetObjId( tszPath, objid, droidBirth );
                if( STATUS_OBJECT_NAME_COLLISION == status )
                {
                    cCollisions++;
                    status = STATUS_SUCCESS;
                }
                else if( FAILED(status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set objid on %s"), tszPath ));
                    TrkRaiseNtStatus( status );
                }
                else
                    cSuccess++;

                //_tprintf( TEXT("Set %s on %s\n"), static_cast<const TCHAR*>(CStringize(objid)), tszPath );

                // Move to the endo of the line

                ptsz = _tcschr( ptsz, TEXT('\n') );
                if( NULL == ptsz || TEXT('\0') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                // Move to the beginning of the next line
                ptsz += 2;  // '\n' & '\0'

                // If this is an empty line, then we're at the end of the file.
                if( TEXT('\n') == *ptsz )
                    break;

            }   // while( TRUE )

            printf( "%d IDs successfully set, %d ID collisions\n", cSuccess, cCollisions );

        }   // if fSaving ... else
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        printf( "Error exception at line %d: %08x\n", cLine, GetExceptionCode() );
    }


Exit:

    return( TRUE );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\link.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"
#include <shlobj.h>
#include <shlguid.h>

#define CB_LINK_CLIENT_MAX  512


void
DoCreateLink(IShellLink * pshlink, const TCHAR *ptszLink, const TCHAR *ptszSrc)
{
    HRESULT hr;
    IPersistFile *pPersistFile = NULL;

    DWORD dwWritten;
    BYTE rgb[ CB_LINK_CLIENT_MAX ];
    ULONG cbPersist = 0;

    memset( rgb, 0, sizeof(rgb) );

    hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
    if( FAILED(hr) )
    {
        _tprintf( TEXT("Couldn't QI IShellLink for IPersistFile (%08x)"), hr );
        goto Exit;
    }

    hr = pshlink->SetPath( ptszSrc );
    _tprintf( TEXT("IShellLink::SetPath returned %08X\n"), hr );
    if( S_OK != hr )
        goto Exit;

    hr = pPersistFile->Save( ptszLink, TRUE );
    if( FAILED(hr) )
    {
        _tprintf( TEXT("Couldn't persist IShellLink (%08x"), hr );
        goto Exit;
    }
    pPersistFile->SaveCompleted( ptszLink );

Exit:

    RELEASE_INTERFACE( pPersistFile );
    return;

}

TCHAR *
GetRestrict(DWORD r)
{
    static TCHAR tszError[256];

    tszError[0] = 0;
    if (r == TRK_MEND_DEFAULT)
    {
        _tcscpy(tszError, TEXT("TRK_MEND_DEFAULT "));
    }
    if (r & TRK_MEND_DONT_USE_LOG)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_LOG "));
    }
    if (r & TRK_MEND_DONT_USE_DC)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_DC "));
    }
    if (r & TRK_MEND_SLEEP_DURING_MEND)
    {
        _tcscat(tszError, TEXT("TRK_MEND_SLEEP_DURING_SEARCH "));
    }
    if (r & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_SEARCH_ALL_VOLUMES "));
    }
    if (r & TRK_MEND_DONT_USE_VOLIDS)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_VOLIDS "));
    }
    return(tszError);
}



enum EXTRAFLAGS
{
    EXTRAFLAG_SHOW_IDS = 1
};

extern "C"
IID IID_ISLTracker
= { /* 7c9e512f-41d7-11d1-8e2e-00c04fb9386d */
    0x7c9e512f,
    0x41d7,
    0x11d1,
    {0x8e, 0x2e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
};

class ISLTracker : public IUnknown
{
public:

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) ()  PURE;
    STDMETHOD_(ULONG,Release) () PURE;

    STDMETHOD(Resolve)(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions) PURE;
    STDMETHOD(GetIDs)(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid) PURE;
};  // interface ISLTracker




void
DisplayIDs( ISLTracker *ptracker )
{
    HRESULT hr = S_OK;
    CDomainRelativeObjId droidBirth, droidLast;
    CMachineId mcid;
    TCHAR tsz[ MAX_PATH ];
    TCHAR *ptsz = tsz;

    hr = ptracker->GetIDs( &droidBirth, &droidLast, &mcid );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get IDs") ));
        TrkRaiseException( hr );
    }

    droidBirth.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Birth =\t%s\n"), tsz );

    droidLast.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Last =\t%s\n"), tsz );

    ptsz = tsz;
    mcid.Stringize(ptsz);
    _tprintf( TEXT("Machine =\t%s\n"), tsz );

}


void
DoResolveLink(IShellLink * pshlink, const TCHAR * ptszLink, DWORD r, DWORD dwSLR, DWORD grfExtra,
              DWORD dwTimeout )
{
    IPersistFile * pPersistFile = NULL;
    ISLTracker * ptracker = NULL;

    __try
    {
        DWORD dwRead;
        HRESULT  hr;
        WCHAR    wszPath[MAX_PATH+1];
        ULONG    cbPath = sizeof(wszPath);
        WIN32_FIND_DATA fd;

        hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for IPersistFile")));
            TrkRaiseException( hr );
        }

        hr = pPersistFile->Load( ptszLink, STGM_SHARE_EXCLUSIVE | STGM_READWRITE );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't load IShellLink")));
            TrkRaiseException( hr );
        }
        RELEASE_INTERFACE( pPersistFile );

        if( (SLR_NO_UI & dwSLR) )
        {
            if( 0 != dwTimeout )
            {
                dwTimeout = min( dwTimeout, 0xfffe );
                _tprintf( TEXT("Timeout = %d seconds\n"), dwTimeout/1000 );
            }
        }
        else if( 0 != dwTimeout )
        {
            _tprintf( TEXT("Timeout will be ignored (since SLR_NO_UI isn't set)\n") );
        }

        // Track it
        if( TRK_MEND_DEFAULT == r && 0 == grfExtra )
        {
            hr = pshlink->Resolve( (SLR_NO_UI & dwSLR) ? NULL : GetDesktopWindow(),
                                   (dwTimeout<<16) | dwSLR | SLR_ANY_MATCH );
        }
        else
        {
            hr = pshlink->QueryInterface( IID_ISLTracker, (void**) &ptracker );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for ISLTracker")));
                TrkRaiseException( hr );
            }

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );

            hr = ptracker->Resolve( GetDesktopWindow(), (dwTimeout<<16) | dwSLR | SLR_ANY_MATCH, r );

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );
        }

        pshlink->GetPath( wszPath, cbPath, &fd, 0 );


        wprintf( L"%s %08X %s\n",
                  wszPath, hr, GetRestrict(r) );

        RELEASE_INTERFACE( ptracker );

    }
    __except( BreakOnDebuggableException() )
    {
        RELEASE_INTERFACE( pPersistFile );
        RELEASE_INTERFACE( ptracker );

    }

}


BOOL
DltAdminLink( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{ 
    BOOL fSuccess = FALSE;
    HRESULT hr;
    CMachineId mcid(MCID_LOCAL);
    DWORD r = TRK_MEND_DEFAULT;
    DWORD grfExtra = 0;
    DWORD dwTimeout = 0;
    DWORD dwSLR = 0;    // SLR_ flags
    IShellLink *pshlink = NULL;
    WCHAR wszFullPath[ MAX_PATH + 1 ];
    DWORD dwMoveFlags = MOVEFILE_FAIL_IF_NOT_TRACKABLE |
                        MOVEFILE_COPY_ALLOWED |
                        MOVEFILE_REPLACE_EXISTING;


    *pcEaten = 0;

    if( 0 == cArgs
        ||
        rgptszArgs[0][0] != TEXT('-') && rgptszArgs[0][0] != TEXT('/') )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        goto Exit;
    }
    else if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption Link\n"
                  "   Purpose: Create/resolve a shell link\n"
                  "   Usage:   -link [operation]\n"
                  "   E.g.:    -link -c LinkClient LinkSource\n"
                  "            -link -r LinkClient\n"
                  "            -link -rd LinkClient\n" );

        printf(   "   Operations:\n" );
        printf(   "            Operation   Params\n");
        printf(   "            ---------   ------\n");
        printf(   "            CreateLink  -c <link> <src>\n");
        printf(   "            ResolveLink -r<opts> <link>\n");
        printf(   "              where <opts> may use:\n" );
        printf(   "                            -l = don't use log\n");
        printf(   "                            -d = don't use dc\n");
        printf(   "                            -i = don't use volids\n");
        printf(   "                            -m = don't scan all volumes on a machine\n");
        printf(   "                            -s = no search (SLR_NOSEARCH)\n");
        printf(   "                            -t = no track (SLR_NOTRACK)\n");
        printf(   "                            -x = show before/after droids\n");
        printf(   "                            -u = no UI (SLR_NOUI)\n");
        printf(   "                            -w(#)\n");
        printf(   "                               = Timeout (wait) seconds on IShellLink::Resolve\n");
        printf(   "                            -z = sleep in CTrkWksSvc::Mend\n");

        *pcEaten = 1;
        fSuccess = TRUE;
        goto Exit;
    }


    hr = CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_ALL, IID_IShellLink, (void**)&pshlink );
    if( FAILED(hr) )
    {
        printf( "Couldn't get an IShellLink (%08x)\n", hr );
        goto Exit;
    }

    switch (rgptszArgs[0][1])
    {
    case TEXT('c'):
    case TEXT('C'):

        if( 3 <= cArgs )
        {
            *pcEaten = 3;
            if( MAX_PATH < RtlGetFullPathName_U( rgptszArgs[2],
                                                 sizeof(wszFullPath),
                                                 wszFullPath, NULL ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get full path name") ));
                goto Exit;
            }
            DoCreateLink( pshlink, rgptszArgs[1], wszFullPath );
        }
        break;

    case TEXT('r'):
    case TEXT('R'):

        if( 2 <= cArgs )
        {
            *pcEaten = 2;

            for( int i = 2; rgptszArgs[0][i] != TEXT('\0'); i++ )
            {
                switch(rgptszArgs[0][i])
                {
                    case TEXT('l'):
                    case TEXT('L'):
                        r |= TRK_MEND_DONT_USE_LOG;
                        break;
                    case TEXT('d'):
                    case TEXT('D'):
                        r |= TRK_MEND_DONT_USE_DC;
                        break;
                    case TEXT('i'):
                    case TEXT('I'):
                        r |= TRK_MEND_DONT_USE_VOLIDS;
                        break;
                    case TEXT('m'):
                    case TEXT('M'):
                        r |= TRK_MEND_DONT_SEARCH_ALL_VOLUMES;
                        break;
                    case TEXT('s'):
                    case TEXT('S'):
                        dwSLR |= SLR_NOSEARCH;
                        break;
                    case TEXT('t'):
                    case TEXT('T'):
                        dwSLR |= SLR_NOTRACK;
                        break;
                    case TEXT('u'):
                    case TEXT('U'):
                        dwSLR |= SLR_NO_UI;
                        break;
                    case TEXT('x'):
                    case TEXT('X'):
                        grfExtra |= EXTRAFLAG_SHOW_IDS;
                        break;
                    case TEXT('z'):
                    case TEXT('Z'):
                        r |= TRK_MEND_SLEEP_DURING_MEND;
                        break;

                    case TEXT('w'):
                    case TEXT('W'):

                        // e.g. -link -rw(30)m
                        if( TEXT('(') == rgptszArgs[0][i+1] )
                        {
                            TCHAR *ptc = _tcschr( &rgptszArgs[0][i], TEXT(')') );
                            if( NULL != ptc )
                            {
                                if( 1 == _stscanf( &rgptszArgs[0][i+1], TEXT("(%d)"), &dwTimeout ))
                                {
                                    dwTimeout *= 1000;  // => milliseconds
                                    i = ( (BYTE*) ptc - (BYTE*) rgptszArgs[0] ) / sizeof(TCHAR);
                                    break;
                                }
                            }
                        }


                    default:
                        _tprintf( TEXT("Bad Resolve switch: %c\n"), rgptszArgs[0][i] );
                        goto Exit;
                }   // switch
            }   // for

            DoResolveLink( pshlink, rgptszArgs[1], r, dwSLR, grfExtra, dwTimeout );
        }
        break;

    default:
        _tprintf( TEXT("Invalid Link option: %c\n"), rgptszArgs[0][1] );
        *pcEaten = 1;
        break;
    }


Exit:

    RELEASE_INTERFACE( pshlink );

    return( fSuccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\procact.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"



typedef HINSTANCE (WINAPI *PFNLoadLibrary)(LPCTSTR);
typedef HMODULE (WINAPI *PFNGetModuleHandle)(LPCTSTR);
typedef BOOL (WINAPI *PFNFreeLibrary)(HINSTANCE);
typedef LONG (WINAPI *PFNGetLastError)();
typedef VOID (WINAPI *PFNDebugBreak)();
typedef VOID (WINAPI *PFNOutputDebugStringW)( LPCTSTR );
typedef BOOL (WINAPI *PFNCreateProcessW)(
                                            IN LPCWSTR lpApplicationName,
                                            IN LPWSTR lpCommandLine,
                                            IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                            IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                            IN BOOL bInheritHandles,
                                            IN DWORD dwCreationFlags,
                                            IN LPVOID lpEnvironment,
                                            IN LPCWSTR lpCurrentDirectory,
                                            IN LPSTARTUPINFOW lpStartupInfo,
                                            OUT LPPROCESS_INFORMATION lpProcessInformation
                                            );

typedef struct
{
    EProcessAction eAction;
    PFNGetModuleHandle pfnGetModuleHandleW;
    PFNFreeLibrary pfnFreeLibrary;
    PFNLoadLibrary pfnLoadLibraryW;
    PFNGetLastError pfnGetLastError;
    PFNDebugBreak pfnDebugBreak;
    PFNOutputDebugStringW pfnOutputDebugStringW;
    PFNCreateProcessW pfnCreateProcessW;
    WCHAR wsz[ 4*MAX_PATH + 1 ];
    WCHAR wszMessage[ 2*MAX_PATH + 1 ];
}   THREADFNSTRUCT;


extern "C"
{

// Turn off stack-probing.
#pragma check_stack (off)

// Also turn off optimizations, to ensure that the compiler doesn't
// consolidate any of this code with that from another function.
#pragma optimize( "", off )

static void BeforeThreadFunc (void)
{
    // Prevent optimizations
    int i = rand();
}

static DWORD WINAPI
RemoteThreadFunc( THREADFNSTRUCT *pStruct )
{
    pStruct->pfnOutputDebugStringW( pStruct->wszMessage );

    if( FREE_LIBRARY == pStruct->eAction )
    {
        HINSTANCE hinst = NULL;

        hinst = pStruct->pfnGetModuleHandleW( pStruct->wsz );
        if( NULL == hinst )
            return( pStruct->pfnGetLastError() );

        if( !pStruct->pfnFreeLibrary( hinst ))
            return( pStruct->pfnGetLastError()  );
        else
            return( ERROR_SUCCESS );

    }
    else if( LOAD_LIBRARY == pStruct->eAction )
    {
        if( NULL == pStruct->pfnLoadLibraryW( pStruct->wsz ))
            return( pStruct->pfnGetLastError() );
        else
            return( ERROR_SUCCESS );
    }
    else if( DEBUG_BREAK == pStruct->eAction )
    {
        pStruct->pfnDebugBreak();
        return( ERROR_SUCCESS );
    }
    else if( CREATE_PROCESS == pStruct->eAction )
    {
        if( !pStruct->pfnCreateProcessW( NULL, pStruct->wsz,
                                         NULL, NULL,
                                         FALSE, NORMAL_PRIORITY_CLASS,
                                         NULL, NULL, NULL, NULL ))
        {
            return GetLastError();
        }
        else
            return ERROR_SUCCESS;
    }
    else
    {
        pStruct->pfnOutputDebugStringW( L"Invalid action to RemoteThreadFunc" );
        return ERROR_INVALID_PARAMETER;
    }

}

static void AfterThreadFunc (void)
{
    // Prevent optimziations
    int i = 2 * rand();
}

#pragma optimize ("", on )  // Restore to default
#pragma check_stack         // Restore to default
}

BOOL
RemoteProcessAction( HANDLE hProcess,
                     EProcessAction eAction,
                     const WCHAR *pwsz )
{
    int cbCodeSize = 0;
    const DWORD cbMemSize = cbCodeSize + sizeof(THREADFNSTRUCT) + 3;
    DWORD *pdwCodeRemote = NULL;
    THREADFNSTRUCT ThreadFnStruct;
    THREADFNSTRUCT *pRemoteThreadFnStruct = NULL;
    HANDLE hThread = NULL;
    DWORD dwThreadID = 0;
    BOOL fSuccess = FALSE;

    __try {

        // Determine the size of RemoteThreadFunc.  Assume the functions
        // either in order or in reverse order.

        if( (LPBYTE) AfterThreadFunc > (LPBYTE) RemoteThreadFunc )
            cbCodeSize = (int)( (LPBYTE) AfterThreadFunc - (LPBYTE) RemoteThreadFunc );
        else if( (LPBYTE) BeforeThreadFunc > (LPBYTE) RemoteThreadFunc )
            cbCodeSize = (int)( (LPBYTE) BeforeThreadFunc - (LPBYTE) RemoteThreadFunc );
        else
        {
            printf( "Can't determine size of code to inject (%p, %p, %p)\n",
                    BeforeThreadFunc, AfterThreadFunc, RemoteThreadFunc );
            __leave;
        }
            

        // Allocate memory in the remote process's address space large 
        // enough to hold our RemoteThreadFunc function and a THREADFNSTRUCT structure.

	pdwCodeRemote = (DWORD*) VirtualAllocEx( hProcess, NULL, cbMemSize,
                                                 MEM_COMMIT, PAGE_EXECUTE_READWRITE );

	if( NULL == pdwCodeRemote )
	{
            printf( "VirtualAllocEx failed: %d\n", GetLastError() );
	    __leave;
        }


	// Write a copy of RemoteThreadFunc to the remote process.
	if( !WriteProcessMemory( hProcess, pdwCodeRemote,
		                (LPVOID) RemoteThreadFunc,
                                cbCodeSize, NULL ))
        {
            printf( "WriteProcessMemory failed:  %d\n", GetLastError() );
            __leave;
        }


	// Write a copy of ThreadFnStruct to the remote process
	// (the structure MUST start on an even 32-bit bourdary).

	pRemoteThreadFnStruct = reinterpret_cast<THREADFNSTRUCT *>
                                ( (BYTE*)pdwCodeRemote + ((cbCodeSize + 4) & ~3) );


        memset( &ThreadFnStruct, 0, sizeof(ThreadFnStruct) );
        ThreadFnStruct.eAction = eAction;

        //wcscpy( ThreadFnStruct.wszMessage, L"*** Remote thread from dltadmin.exe ***\n" );


        if( LOAD_LIBRARY == eAction )
        {
            wcscpy( ThreadFnStruct.wsz, pwsz );
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to load \"%s\"\n",
                      pwsz );

            ThreadFnStruct.pfnLoadLibraryW = (PFNLoadLibrary)
                                             GetProcAddress( GetModuleHandle( L"kernel32.dll" ),
                                                             "LoadLibraryW" );
            if( NULL == ThreadFnStruct.pfnLoadLibraryW )
            {
                printf( "Couldn't load LoadLibraryW (%d)\n", GetLastError() );
                __leave;
            }
        }
        else if( FREE_LIBRARY == eAction )
        {
            wcscpy( ThreadFnStruct.wsz, pwsz );
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to free \"%s\"\n",
                      pwsz );
            ThreadFnStruct.pfnFreeLibrary = (PFNFreeLibrary)
                                            GetProcAddress( GetModuleHandleA("kernel32.dll"),
                                                            "FreeLibrary" );
            if( NULL == ThreadFnStruct.pfnFreeLibrary )
            {
                printf( "Couldn't load FreeLibrary (%d)\n", GetLastError() );
                __leave;
            }

            ThreadFnStruct.pfnGetModuleHandleW = (PFNGetModuleHandle)
                                                 GetProcAddress( GetModuleHandle(L"kernel32.dll"),
                                                 "GetModuleHandleW" );
            if( NULL == ThreadFnStruct.pfnFreeLibrary )
            {
                printf( "Couldn't load FreeLibrary (%d)\n", GetLastError() );
                __leave;
            }
        }
        else if( CREATE_PROCESS == eAction )
        {
            wcscpy( ThreadFnStruct.wsz, pwsz );
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to create \"%s\"\n",
                      pwsz );
            ThreadFnStruct.pfnCreateProcessW = (PFNCreateProcessW)
                                               GetProcAddress( GetModuleHandleA("kernel32.dll"),
                                                               "CreateProcessW" );
            if( NULL == ThreadFnStruct.pfnCreateProcessW )
            {
                printf( "Couldn't load CreateProcess (%d)\n", GetLastError() );
                __leave;
            }

        }
        else    // DEBUG_BREAK
        {
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to DebugBreak\n" );
            ThreadFnStruct.pfnDebugBreak = (PFNDebugBreak)
                                            GetProcAddress( GetModuleHandleA("kernel32.dll"),
                                                            "DebugBreak" );
            if( NULL == ThreadFnStruct.pfnDebugBreak )
            {
                printf( "Couldn't load DebugBreak (%d)\n", GetLastError() );
                __leave;
            }

        }

        ThreadFnStruct.pfnGetLastError = (PFNGetLastError)
                                         GetProcAddress( GetModuleHandle( L"kernel32.dll" ),
                                                         "GetLastError" );
        if( NULL == ThreadFnStruct.pfnGetLastError )
        {
            printf( "Couldn't load GetLastError (%d)\n", GetLastError() );
            __leave;
        }

        ThreadFnStruct.pfnOutputDebugStringW = (PFNOutputDebugStringW)
                                               GetProcAddress( GetModuleHandle( L"kernel32.dll" ),
                                                               "OutputDebugStringW" );
        if( NULL == ThreadFnStruct.pfnOutputDebugStringW )
        {
            printf( "Couldn't load OutputDebugStringW (%d)\n", GetLastError() );
            __leave;
        }

	// Write the struct into the remote thread's memory block.

	if( !WriteProcessMemory( hProcess, pRemoteThreadFnStruct,
		                 &ThreadFnStruct, sizeof(THREADFNSTRUCT), NULL ))
        {
            printf( "Couldn't write ThreadFnStruct to remote thread: %d\n", GetLastError() );
            __leave;
        }


	hThread = CreateRemoteThread( hProcess, NULL, 0,
                                      (LPTHREAD_START_ROUTINE) pdwCodeRemote,
		                      pRemoteThreadFnStruct, 0, &dwThreadID );
	if( NULL == hThread )
	{
            printf( "Couldn't create remote thread: %d\n", GetLastError() );
            __leave;
	}

        DWORD dwWait = WaitForSingleObject( hThread, INFINITE );
        if( WAIT_OBJECT_0 != dwWait )
            printf( "Wait failed: %d, %d\n", dwWait, GetLastError() );

    }	// __try
    __finally
    {

        if( NULL != hThread )
        {
            DWORD dwError;

            if( !AbnormalTermination() )
            {
                if( !GetExitCodeThread( hThread, &dwError ))
                    printf( "Couldn't get remote thread exit code: %d\n", GetLastError() );
                else if( ERROR_MOD_NOT_FOUND == dwError )
                {
                    if( LOAD_LIBRARY == eAction )
                        wprintf( L"DLL \"%s\" not found\n", pwsz );
                    else if( FREE_LIBRARY == eAction )
                        wprintf( L"DLL \"%s\" not already loaded\n", pwsz );
                }
                else if( ERROR_SUCCESS != dwError )
                    printf( "Failed: 0x%x\n", dwError );
                else
                    fSuccess = TRUE;
            }

            CloseHandle(hThread);
        }
        
        if( NULL != pdwCodeRemote )
        {
            if( !VirtualFreeEx( hProcess, pdwCodeRemote, 0, MEM_RELEASE ))
                printf( "Couldn't free remote memory: 0x%x\n", GetLastError() );
        }

    }   // __finally

    if( fSuccess )
        printf( "Succeeded\n" );
    return( fSuccess );

}



BOOL
DltAdminProcessAction( EProcessAction eAction, ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    BOOL fSuccess = FALSE;

    *pcEaten = 0;

    if( 0 == cArgs
        ||
        1 <= cArgs && IsHelpArgument(rgptszArgs[0]) )
    {
        *pcEaten = 1;

        if( LOAD_LIBRARY == eAction )
        {
            printf( "\nOption LoadLib\n"
                      "   Purpose: Load a dll into a process with LoadLibrary\n"
                      "   Usage:   -LoadLib -p <process ID> <library name>\n"
                      "   E.g.:    -LoadLib -p 182 shell32.dll\n" );
        }
        else if( FREE_LIBRARY == eAction )
        {
            printf( "\nOption FreeLib\n"
                      "   Purpose: Unload a dll from a process with FreeLibrary\n"
                      "   Usage:   -FreeLib -p <process ID> <library name>\n"
                      "   E.g.:    -FreeLib -p 182 shell32.dll\n" );
        }
        else
        {
            printf( "\nOption DebugBreak\n"
                      "   Purpose: Execute DebugBreak within a process\n"
                      "   Usage:   -DebugBreak -p <process ID>\n"
                      "   E.g.:    -DebugBreak -p 182\n" );
        }
        return( TRUE );
    }

    ULONG iArgs = 0;

    if( 2 > cArgs
        ||
        TEXT('-') != rgptszArgs[0][0]
        &&
        TEXT('/') != rgptszArgs[0][0]
        ||
        TEXT('P') != rgptszArgs[0][1]
        &&
        TEXT('p') != rgptszArgs[0][1] )

    {
        printf( "Argument error.  Use -? for usage info.\n" );
        return( FALSE );
    }

    HANDLE hProcess = NULL;
    __try
    {
        DWORD dwProcessID = 0;

        _stscanf( rgptszArgs[1], TEXT("%d"), &dwProcessID );
        if( 0 == dwProcessID )
        {
            printf( "Failed to open system process\n" );
            __leave;
        }

        EnablePrivilege(SE_DEBUG_NAME);
        hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, dwProcessID );
        if( NULL == hProcess )
        {
            printf( "Failed to open process %d (%lu)\n", dwProcessID, GetLastError() );
            __leave;
        }

        if( RemoteProcessAction( hProcess, eAction,
                                 DEBUG_BREAK == eAction ? NULL : rgptszArgs[2] ))
            fSuccess = TRUE;

        if( DEBUG_BREAK == eAction )
            *pcEaten = 2;
        else
            *pcEaten = 3;

    }
    __finally
    {
        if( NULL != hProcess )
            CloseHandle( hProcess );
    }

    return( fSuccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\frcown.cpp ===
// FrcOwn.cpp : Implementation of CForceOwnership

#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include <trklib.hxx>
#include <trksvr.hxx>
#undef TRKDATA_ALLOCATE

#include "stdafx.h"
#include "ITrkAdmn.h"
#include "FrcOwn.h"




STDMETHODIMP
CTrkForceOwnership::Volumes(BSTR bstrUncPath, long scope )
{

    HRESULT hr = S_OK;
    HANDLE hFile = NULL;
    CVolumeId volid;

    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    CPCVolumes cpcVolumes( &mcid, &_voltab, &_refreshSequenceStorage );
    TRpcPipeControl< TRK_VOLUME_TRACKING_INFORMATION_PIPE,
                     TRK_VOLUME_TRACKING_INFORMATION,
                     CPCVolumes
                   > cpipeVolumes( &cpcVolumes );

    rc.Initialize( mcid );

    if( TRKINFOSCOPE_VOLUME == scope )
    {
        NTSTATUS status;
        IO_STATUS_BLOCK Iosb;
        FILE_FS_OBJECTID_INFORMATION fsobOID;

        status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                FILE_OPEN_NO_RECALL, NULL, &hFile );
        if( !NT_SUCCESS(status) )
        {
            hFile = NULL;
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
            TrkRaiseNtStatus( status );
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                               FileFsObjectIdInformation );

        if( STATUS_OBJECT_NAME_NOT_FOUND == status )
        {
            TRK_VOLUME_TRACKING_INFORMATION volinfo;

            volinfo.volindex = -1;
            cpcVolumes.Push( &volinfo, 1 );
            hr = S_OK;
            goto Exit;
        }
        else if( !NT_SUCCESS(status) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath ));
            TrkRaiseNtStatus( status );
        }

        volid.Load( &volid, fsobOID );

        NtClose( hFile );
        hFile = NULL;
    }
    else if( TRKINFOSCOPE_MACHINE != scope )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::VolumeStatus (%l)"), scope ));
        TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
    }


    RpcTryExcept
    {
        hr = GetVolumeTrackingInformation( rc, volid, static_cast<TrkInfoScope>(scope), cpipeVolumes );
        if( SUCCEEDED(hr) && SUCCEEDED(cpcVolumes.GetHResult()) )
            hr = TriggerVolumeClaims( rc, cpcVolumes.Count(), cpcVolumes.GetVolIds() );
    }
    RpcExcept( BreakOnDebuggableException() )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    return( hr );
}



STDMETHODIMP
CTrkForceOwnership::Files(BSTR bstrUncPath, long scope)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = NULL;

    CPCFiles cpcFiles( &_idt );
    TRpcPipeControl< TRK_FILE_TRACKING_INFORMATION_PIPE,
                     TRK_FILE_TRACKING_INFORMATION,
                     CPCFiles
                   > cpipeFiles( &cpcFiles);

    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    __try
    {
        NTSTATUS status;
        CDomainRelativeObjId droidCurrent, droidBirth;

        if( TRKINFOSCOPE_ONE_FILE == scope )
        {

            // BUGBUG P2:  Optimize this; we don't need droidBirth
            status = GetDroids( bstrUncPath, &droidCurrent, &droidBirth, RGO_READ_OBJECTID );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFiles.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed GetDroids (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
        }
        else if( TRKINFOSCOPE_VOLUME == scope )
        {
            NTSTATUS status;
            IO_STATUS_BLOCK Iosb;
            FILE_FS_OBJECTID_INFORMATION fsobOID;
            CVolumeId volid;

            status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                    FILE_OPEN_NO_RECALL, NULL, &hFile );
            if( !NT_SUCCESS(status) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }

            status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                                   FileFsObjectIdInformation );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFiles.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
            volid.Load( &volid, fsobOID );
            droidCurrent = CDomainRelativeObjId( volid, CObjId() );

            NtClose( hFile );
            hFile = NULL;
        }
        else if( TRKINFOSCOPE_MACHINE != scope )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::FileStatus (%d)"), scope ));
            TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
        }
    
        rc.Initialize( mcid );

        RpcTryExcept
        {
            hr = GetFileTrackingInformation( rc, droidCurrent, static_cast<TrkInfoScope>(scope), cpipeFiles );
        }
        RpcExcept( BreakOnDebuggableException() )
        {
            hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
        }
        RpcEndExcept;
        if( FAILED(hr) ) goto Exit;
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( NULL != hFile )
        NtClose( hFile );

    return( hr );
}

STDMETHODIMP
CTrkForceOwnership::VolumeStatus(BSTR bstrUncPath, long scope,
                                 VARIANT *pvarlongVolIndex, VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = NULL;
    SAFEARRAYBOUND sabound;
    CVolumeId volid;

    // Determine the machine ID
    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    // This is used by the RPC server to pull the bstrUncPath
    CPCPath cpcPath( bstrUncPath );
    TRpcPipeControl< TCHAR_PIPE, TCHAR, CPCPath> cpipePath( &cpcPath );

    // This is used by the RPC server to push the volume information
    CPCVolumeStatus cpcVolumeStatus( &_voltab );
    TRpcPipeControl< TRK_VOLUME_TRACKING_INFORMATION_PIPE, TRK_VOLUME_TRACKING_INFORMATION, CPCVolumeStatus
                   > cpipeVolumeStatus( &cpcVolumeStatus );


    __try
    {
        NTSTATUS status;

        // Initialize the outputs
        VariantInit( pvarlongVolIndex );
        VariantInit( pvarbstrVolId );
        VariantInit( pvarlongStatus );

        // Initialize the pipe callback
        cpcVolumeStatus.Initialize( &mcid, pvarlongVolIndex, pvarbstrVolId, pvarlongStatus );

        // Connect to the workstation in question
        rc.Initialize( mcid );

        if( TRKINFOSCOPE_VOLUME == scope )
        {
            IO_STATUS_BLOCK Iosb;
            FILE_FS_OBJECTID_INFORMATION fsobOID;

            status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                    FILE_OPEN_NO_RECALL, NULL, &hFile );
            if( !NT_SUCCESS(status) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }

            status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                                   FileFsObjectIdInformation );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_VOLUME_TRACKING_INFORMATION volinfo;

                volinfo.volindex = -1;
                cpcVolumeStatus.Push( &volinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
            volid.Load( &volid, fsobOID );

            NtClose( hFile );
            hFile = NULL;
        }
        else if( TRKINFOSCOPE_MACHINE != scope )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::VolumeStatus (%l)"), scope ));
            TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
        }


        RpcTryExcept
        {
            hr = GetVolumeTrackingInformation( rc, volid, static_cast<TrkInfoScope>(scope), cpipeVolumeStatus );
        }
        RpcExcept( BreakOnDebuggableException() )
        {
            hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
        }
        RpcEndExcept;

        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed call to GetVolumeTrackInformation")));
            TrkRaiseException( hr );
        }

        if( FAILED(cpcVolumeStatus.GetHResult()) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed in VolumeStatus pipe callback")));
            TrkRaiseException( cpcVolumeStatus.GetHResult() );
        }

        // Truncate the safearrays
        cpcVolumeStatus.Compact();

    }
    __except( BreakOnDebuggableException() )
    {
        cpcVolumeStatus.UnInitialize();
        hr = GetExceptionCode();
    }

Exit:

    if( FAILED(hr) )
    {
        VariantClear( pvarlongVolIndex );
        VariantClear( pvarbstrVolId );
        VariantClear( pvarlongStatus );
    }

    if( NULL != hFile )
        NtClose( hFile );

    return( hr );
}


void
CPCVolumeStatus::Initialize( CMachineId *pmcid, VARIANT *pvarlongVolIndex, VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus )
{
    _pmcid = pmcid;
    _pvarlongVolIndex = pvarlongVolIndex;
    _pvarbstrVolId = pvarbstrVolId;
    _pvarlongStatus = pvarlongStatus;

    _iArrays = 0;
    _hr = S_OK;
    _sabound.lLbound = 0;
    _sabound.cElements = NUM_VOLUMES;

    _fInitialized = TRUE;

    _pvarlongVolIndex->parray = SafeArrayCreate( VT_I4, 1, &_sabound );
    if( NULL == _pvarlongVolIndex->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarlongVolIndex->vt = VT_I4 | VT_ARRAY;

    _pvarbstrVolId->parray = SafeArrayCreate( VT_BSTR, 1, &_sabound );
    if( NULL == _pvarbstrVolId->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarbstrVolId->vt = VT_BSTR | VT_ARRAY;

    _pvarlongStatus->parray = SafeArrayCreate( VT_I4, 1, &_sabound );
    if( NULL == _pvarlongStatus->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarlongStatus->vt = VT_I4 | VT_ARRAY;

}

void
CPCVolumeStatus::UnInitialize()
{
    // Nothing to do, the Variants are cleaned by the caller
    return;
}


void
CPCVolumeStatus::Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems )
{
    TrkLog(( TRKDBG_ADMIN, TEXT("CPCVolumeStatus received %d elements"), cElems ));

    HRESULT hr = S_OK;
    HRESULT hrGet;
    ULONG iElem = 0;
    BSTR bstrVolId = NULL;

    __try
    {
        for( iElem = 0; iElem < cElems; iElem++ )
        {
            CMachineId mcidCheck;
            CVolumeSecret volsecCheck;
            SequenceNumber seqCheck;
            CVolumeId volNULL;

            TCHAR tszVolId[ 40 ];
            TCHAR *ptszVolId = tszVolId;

            long VolOwnership = OBJOWN_UNKNOWN;

            if( pVolInfo[iElem].volume != volNULL )
                hrGet = _pvoltab->GetVolumeInfo( pVolInfo[iElem].volume, &mcidCheck, &volsecCheck, &seqCheck );

            if( _iArrays >= static_cast<LONG>(_sabound.cElements) )
            {
                TrkAssert( !TEXT("Not yet implemented") );
                // BUGBUG: do a SafeArrayReDim
                return;
            }


            TrkAssert( sizeof(long) == sizeof(pVolInfo[iElem].volindex) );
            hr = SafeArrayPutElement( _pvarlongVolIndex->parray, &_iArrays, &pVolInfo[iElem].volindex );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }

            // BUGBUG:  Add a Serialize(BSTR) method to CVolumeId
            pVolInfo[iElem].volume.Stringize( ptszVolId );

            bstrVolId = SysAllocString( tszVolId );
            if( NULL == bstrVolId )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SysAllocString")));
                TrkRaiseWin32Error( E_OUTOFMEMORY );
            }

            hr = SafeArrayPutElement( _pvarbstrVolId->parray, &_iArrays, bstrVolId );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }

            if( S_OK != hrGet )
            {
                VolOwnership = OBJOWN_DOESNT_EXIST;
            }
            else if( mcidCheck == *_pmcid )
            {
                VolOwnership = OBJOWN_OWNED;
            }
            else if( volNULL == pVolInfo[iElem].volume )
            {
                VolOwnership = OBJOWN_NO_ID;
            }
            else
            {
                VolOwnership = OBJOWN_NOT_OWNED;
            }

            hr = SafeArrayPutElement( _pvarlongStatus->parray, &_iArrays, &VolOwnership );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElemnt")));
                TrkRaiseException( hr );
            }

            SysFreeString( bstrVolId ); bstrVolId = NULL;
            _iArrays++;
        }

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
    {
        if( NULL != bstrVolId )
            SysFreeString( bstrVolId );

        if( !FAILED(_hr) )
            _hr = hr;
    }

    return;
}


void
CPCVolumeStatus::Compact()
{
    HRESULT hr = S_OK;

    _sabound.cElements = _iArrays;

    hr = SafeArrayRedim( _pvarlongVolIndex->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarbstrVolId->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarlongStatus->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }
}


void
CPCVolumes::Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems )
{
    TrkLog(( TRKDBG_ADMIN, TEXT("CPCVolumeStatus received %d elements"), cElems ));

    HRESULT hr = S_OK;
    ULONG iElem = 0;

    __try
    {
        for( iElem = 0; iElem < cElems; iElem++ )
        {

            hr = _pvoltab->SetMachine( pVolInfo[iElem].volume, *_pmcid );
            if( TRK_S_VOLUME_NOT_FOUND == hr )
                _pvoltab->CreateVolume(
                    pVolInfo[iElem].volume,
                    *_pmcid,
                    CVolumeSecret(),
                    _pRefreshSequenceStorage->GetSequenceNumber() );

            // BUGBUG P1:  Handle this error
            TrkAssert( SUCCEEDED(hr) );

            _rgvolid[ _cVolIds++ ] = pVolInfo[iElem].volume;
            
        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    if( FAILED(hr) )
    {
        if( !FAILED(_hr) )
            _hr = hr;
    }

    return;
}

void
CPCFiles::Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems )
{
    ULONG iFile;

    __try
    {
        // BUGBUG P2:  Instead of a loop, batch these up
        for( iFile = 0; iFile < cElems; iFile++ )
        {
            _pidt->Delete( pFileInfo[iFile].droidBirth );

            TrkVerify( _pidt->Add( pFileInfo[iFile].droidBirth, pFileInfo[iFile].droidLast,
                       pFileInfo[iFile].droidBirth ));
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("CPCFiles::Push had an exception (%08x)"), GetExceptionCode() ));
    }

    
}


void
CPCFileStatus::Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems )
{
    TrkLog(( TRKDBG_ADMIN, TEXT("CPCFileStatus received %d elements"), cElems ));

    HRESULT hr = S_OK;
    ULONG iElem = 0;
    BSTR bstr = NULL;

    __try
    {
        for( iElem = 0; iElem < cElems; iElem++ )
        {
            BOOL fExistsInTable = FALSE;
            BOOL fAtBirthplace = FALSE;

            CDomainRelativeObjId droidBirthCheck;
            CDomainRelativeObjId droidNowCheck;
            const CDomainRelativeObjId droidNULL;
            TCHAR tszDroid[ MAX_PATH ];
            long FileOwnership;

            if( droidNULL == pFileInfo[iElem].droidBirth
                ||
                pFileInfo[iElem].droidBirth == pFileInfo[iElem].droidLast )
            {
                fAtBirthplace = TRUE;
            }
            else
            {
                fExistsInTable = _pidt->Query( pFileInfo[iElem].droidBirth, &droidNowCheck, &droidBirthCheck );
            }

            if( _iArrays >= static_cast<LONG>(_sabound.cElements) )
            {
                TrkAssert( !TEXT("Not yet impelemented") );
                // BUGBUG: do a SafeArrayReDim
                return;
            }

            bstr = SysAllocString( pFileInfo[iElem].tszFilePath );
            if( NULL == bstr )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SysAllocString")));
                TrkRaiseWin32Error( E_OUTOFMEMORY );
            }

            hr = SafeArrayPutElement( _pvarrgbstrFileName->parray, &_iArrays, bstr );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }
            SysFreeString( bstr ); bstr = NULL;

            // BUGBUG:  Add a Serialize(BSTR) method to CDroid
            pFileInfo[iElem].droidBirth.Stringize( tszDroid, sizeof(tszDroid) );
            bstr = SysAllocString( tszDroid );
            if( NULL == bstr )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SysAllocString")));
                TrkRaiseWin32Error( E_OUTOFMEMORY );
            }

            hr = SafeArrayPutElement( _pvarrgbstrFileId->parray, &_iArrays, bstr );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }

            if( fAtBirthplace )
                FileOwnership = OBJOWN_OWNED;

            else if( !fExistsInTable )
                FileOwnership = OBJOWN_DOESNT_EXIST;

            else if( droidNowCheck == pFileInfo[iElem].droidLast
                     &&
                     droidBirthCheck == pFileInfo[iElem].droidBirth )
                FileOwnership = OBJOWN_OWNED;

            else
                FileOwnership = OBJOWN_NOT_OWNED;


            hr = SafeArrayPutElement( _pvarrglongStatus->parray, &_iArrays, &FileOwnership );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElemnt")));
                TrkRaiseException( hr );
            }

            _iArrays++;
        }

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
    {
        if( NULL != bstr )
            SysFreeString( bstr );

        if( !FAILED(_hr) )
            _hr = hr;
    }

    return;
}



void
CPCFileStatus::Initialize( CMachineId *pmcid, VARIANT *pvarrgbstrFileName,
                           VARIANT *pvarrgbstrFileId, VARIANT *pvarrglongStatus )
{
    _pmcid = pmcid;
    _pvarrgbstrFileName = pvarrgbstrFileName;
    _pvarrgbstrFileId = pvarrgbstrFileId;
    _pvarrglongStatus = pvarrglongStatus;

    _iArrays = 0;
    _hr = S_OK;
    _sabound.lLbound = 0;
    _sabound.cElements = 10;

    _fInitialized = TRUE;

    _pvarrgbstrFileName->parray = SafeArrayCreate( VT_BSTR, 1, &_sabound );
    if( NULL == _pvarrgbstrFileName->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarrgbstrFileName->vt = VT_BSTR | VT_ARRAY;

    _pvarrgbstrFileId->parray = SafeArrayCreate( VT_BSTR, 1, &_sabound );
    if( NULL == _pvarrgbstrFileId->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarrgbstrFileId->vt = VT_BSTR | VT_ARRAY;

    _pvarrglongStatus->parray = SafeArrayCreate( VT_I4, 1, &_sabound );
    if( NULL == _pvarrglongStatus->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarrglongStatus->vt = VT_I4 | VT_ARRAY;


}   // CPCFileStatus::Initialize



void
CPCFileStatus::Compact()
{
    HRESULT hr = S_OK;

    _sabound.cElements = _iArrays;

    hr = SafeArrayRedim( _pvarrgbstrFileName->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarrgbstrFileId->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarrglongStatus->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }
}



STDMETHODIMP CTrkForceOwnership::FileStatus(BSTR bstrUncPath, long scope,
                                            VARIANT * pvarrgbstrFileName, VARIANT *pvarrgbstrFileId, VARIANT * pvarrglongStatus)
{
    HRESULT hr = E_FAIL;
    SAFEARRAYBOUND sabound;
    HANDLE hFile = NULL;

    // Determine the machine ID
    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    // This is used by the RPC server to push the volume information
    CPCFileStatus cpcFileStatus( &_idt );
    TRpcPipeControl< TRK_FILE_TRACKING_INFORMATION_PIPE, TRK_FILE_TRACKING_INFORMATION, CPCFileStatus
                   > cpipeFileStatus( &cpcFileStatus );


    __try
    {
        NTSTATUS status;

        // Initialize the outputs
        VariantInit( pvarrgbstrFileName );
        VariantInit( pvarrgbstrFileId );
        VariantInit( pvarrglongStatus );

        CDomainRelativeObjId droidCurrent, droidBirth;

        // Initialize the pipe callback
        cpcFileStatus.Initialize( &mcid, pvarrgbstrFileName, pvarrgbstrFileId, pvarrglongStatus );

        if( TRKINFOSCOPE_ONE_FILE == scope )
        {

            // BUGBUG P2:  Optimize this; we don't need droidBirth
            status = GetDroids( bstrUncPath, &droidCurrent, &droidBirth, RGO_READ_OBJECTID );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFileStatus.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed GetDroids (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
        }
        else if( TRKINFOSCOPE_VOLUME == scope )
        {
            NTSTATUS status;
            IO_STATUS_BLOCK Iosb;
            FILE_FS_OBJECTID_INFORMATION fsobOID;
            CVolumeId volid;

            status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                    FILE_OPEN_NO_RECALL, NULL, &hFile );
            if( !NT_SUCCESS(status) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }

            status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                                   FileFsObjectIdInformation );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFileStatus.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath));
                TrkRaiseNtStatus( status );
            }
            volid.Load( &volid, fsobOID );
            droidCurrent = CDomainRelativeObjId( volid, CObjId() );

            NtClose( hFile );
            hFile = NULL;
        }
        else if( TRKINFOSCOPE_MACHINE != scope )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::FileStatus (%d)"), scope ));
            TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
        }

        // Connect to the workstation in question
        rc.Initialize( mcid );

        // Get the volume status info
        RpcTryExcept
        {
            hr = GetFileTrackingInformation( rc, droidCurrent, static_cast<TrkInfoScope>(scope), cpipeFileStatus );
        }
        RpcExcept( BreakOnDebuggableException() )
        {
            hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
        }
        RpcEndExcept;

        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed call to GetFileTrackInformation")));
            TrkRaiseException( hr );
        }

        if( FAILED(cpcFileStatus.GetHResult()) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed in FileStatus pipe callback")));
            TrkRaiseException( cpcFileStatus.GetHResult() );
        }
        // Truncate the safearrays
        cpcFileStatus.Compact();

    }
    __except( BreakOnDebuggableException() )
    {
        cpcFileStatus.UnInitialize();
        hr = GetExceptionCode();
    }

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    if( FAILED(hr) )
    {
        VariantClear( pvarrgbstrFileName );
        VariantClear( pvarrgbstrFileId );
        VariantClear( pvarrglongStatus );
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\svrstat.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "trksvr.hxx"
#include "dltadmin.hxx"


void
CDomainRelativeObjId::FillLdapIdtKeyBuffer(TCHAR * const pchCN,
                                DWORD cch) const
{
    TCHAR *pchBuf = pchCN;
    _tcscpy(pchBuf, TEXT("CN="));
    pchBuf = pchBuf + 3;
    _volume.Stringize(pchBuf);
    _object.Stringize(pchBuf);
    TrkAssert(pchBuf <= pchCN+cch);
}

void
ShowMoveCounter( const TCHAR *ptszHostName )
{
    CDbConnection       dbc;
    dbc.Initialize( NULL, ptszHostName );

    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();

    BOOL                    fSuccess = FALSE;
    struct berval**         ppbvCounter = NULL;
    TCHAR*                  rgtszAttrs[2];
    LDAPMessage*            pRes = NULL;
    int                     ldapRV;
    int                     cEntries = 0;
    LDAPMessage*            pEntry = NULL;
    CLdapQuotaCounterKeyDn  dnKeyCounter(dbc.GetBaseDn());
    DWORD dwCounter = 0;

    __try
    {
        rgtszAttrs[0] = const_cast<TCHAR*>(s_volumeSecret);
        rgtszAttrs[1] = NULL;
        ldapRV = ldap_search_s(dbc.Ldap(),
                               dnKeyCounter,
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               rgtszAttrs,
                               0,
                               &pRes);
        if( LDAP_NO_SUCH_OBJECT == ldapRV )
        {
            printf( "Move table counter doesn't exist\n" );
            __leave;
        }
        else if( LDAP_SUCCESS != ldapRV )
        {
            printf( "Couldn't read move table counter (%d)\n", ldapRV );
            __leave;
        }

        cEntries = ldap_count_entries(dbc.Ldap(), pRes);
        if( 0 == cEntries )
        {
            printf( "Move table counter didn't exist or couldn't be read\n" );
            __leave;
        }
        else if( 1 != cEntries )
        {
            printf( "Too many move table counters (%d)!\n", cEntries );
            __leave;
        }

        pEntry = ldap_first_entry(dbc.Ldap(), pRes);
        if(NULL == pEntry)
        {
            printf( "Entries couldn't be read from result\n" );
            __leave;
        }

        ppbvCounter = ldap_get_values_len(dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_volumeSecret) );
        if (ppbvCounter == NULL)
        {
            _tprintf( TEXT("Move table counter is corrupt, missing %s attribute\n"),
                      s_volumeSecret );
            __leave;
        }

        if ((*ppbvCounter)->bv_len < sizeof(DWORD))
        {
            _tprintf( TEXT("Move table counter attribute %s has wrong type (%d)\n"),
                      s_volumeSecret, (*ppbvCounter)->bv_len );
            __leave;
        }

        memcpy( (PCHAR)&dwCounter, (*ppbvCounter)->bv_val, sizeof(DWORD) );
        printf( "Move table counter (in DS)              %lu\n", dwCounter );
    }
    __finally
    {
        if(NULL != pRes)
        {
            ldap_msgfree(pRes);
        }
        if (ppbvCounter != NULL)
        {
            ldap_value_free_len(ppbvCounter);
        }
    }

}



/*
ShowDcEntries( const TCHAR *ptszHostName )
{
    TCHAR*              rgptszAttrs[4];
    LDAPMessage*        pRes = NULL;
    int                 ldapRV;
    HRESULT             hr = E_FAIL;

    CDbConnection       dbc;
    dbc.Initialize( NULL, ptszHostName );

    CLdapVolumeKeyDn    dnKey(dbc.GetBaseDn());
    LONGLONG            llCreationTime, llLastAliveTime;
    CFILETIME           cftNow;
    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();

    struct berval **    ppbvMachineId = NULL;
    TCHAR**             pptszCreationTime = NULL;
    TCHAR**             pptszLastAliveTime = NULL;
    LDAPMessage *       pEntry = NULL;

    struct SDcEntries
    {
        CMachineId  mcid;
        BOOL        fSuspended;
        CFILETIME   cftCreation;
        CFILETIME   cftLastAlive;
    };

    SDcEntries rgsDcEntries[ 100 ];
    ULONG               cDcEntries = 0;
    CMachineId          mcidDesignated;
    ULONG               cEntries = 0;


    __try
    {
        rgptszAttrs[0] = const_cast<TCHAR*>(s_Cn);
        rgptszAttrs[1] = const_cast<TCHAR*>(s_timeVolChange);
        rgptszAttrs[2] = const_cast<TCHAR*>(s_timeRefresh);
        rgptszAttrs[3] = NULL;

        ldapRV = ldap_search_s( dbc.Ldap(),
                                dnKey,
                                LDAP_SCOPE_ONELEVEL,
                                TEXT("(cn=QTDC_*)"),
                                rgptszAttrs,
                                0,
                                &pRes);
        if(LDAP_SUCCESS != ldapRV)
        {
            printf( "Failed ldap_search_s (%lu)\n", LdapMapErrorToWin32(ldapRV) );
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV) );
            __leave;
        }

        cEntries = ldap_count_entries( dbc.Ldap(), pRes );
        if(cEntries < 1)
            __leave;

        pEntry = ldap_first_entry( dbc.Ldap(), pRes );
        if(NULL == pEntry)
        {
            printf( "Invalid ldap_first_entry\n" );
            __leave;
        }

        // Loop through the results.

        while(TRUE)
        {
            // Get the machine id.
            ppbvMachineId = ldap_get_values_len( dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_Cn) );
            if(NULL == ppbvMachineId)
            {
                printf( "Couldn't get machine ID\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            if((*ppbvMachineId)->bv_val == NULL)
            {
                printf( "Couldn't get machine ID\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            memcpy( &rgsDcEntries[cDcEntries].mcid,
                    (*ppbvMachineId)->bv_val + 5,
                    strlen((*ppbvMachineId)->bv_val+5));

            // Get the creation time.
            pptszCreationTime = ldap_get_values(dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_timeVolChange) );
            if(NULL == pptszCreationTime)
            {
                printf( "Couldn't get the creation time\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            _stscanf(*pptszCreationTime, TEXT("%I64u"), &llCreationTime);
            rgsDcEntries[cDcEntries].cftCreation = CFILETIME(llCreationTime);

            // Get the last alive time.
            pptszLastAliveTime = ldap_get_values(dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
            if(NULL == pptszLastAliveTime)
            {
                printf( "Couldn't get last alive time\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            _stscanf(*pptszLastAliveTime, TEXT("%I64u"), &llLastAliveTime);
            rgsDcEntries[cDcEntries].cftLastAlive = CFILETIME(llLastAliveTime);


            rgsDcEntries[cDcEntries].fSuspended = FALSE;
            if(((LONGLONG)cftNow - (LONGLONG)rgsDcEntries[cDcEntries].cftCreation) / 10000000  < configSvr.GetDcSuspensionPeriod()
               ||
               ((LONGLONG)cftNow - (LONGLONG)rgsDcEntries[cDcEntries].cftLastAlive) / 10000000 > configSvr.GetDcSuspensionPeriod()
                )
            {
                rgsDcEntries[cDcEntries].fSuspended = TRUE;
            }
            else if( rgsDcEntries[cDcEntries].mcid > mcidDesignated )
            {
                mcidDesignated = rgsDcEntries[cDcEntries].mcid;
            }

            if (ppbvMachineId != NULL)
            {
                ldap_value_free_len(ppbvMachineId);
                ppbvMachineId = NULL;
            }

            if (pptszCreationTime != NULL)
            {
                ldap_value_free(pptszCreationTime);
                pptszCreationTime = NULL;
            }

            if (pptszLastAliveTime != NULL)
            {
                ldap_value_free(pptszLastAliveTime);
                pptszLastAliveTime = NULL;
            }

            cDcEntries++;
            pEntry = ldap_next_entry(dbc.Ldap(), pEntry);
            if(!pEntry)
            {
                break;
            }
        }   // while( TRUE )

        for( int iEntry = 0; iEntry < cDcEntries; iEntry++ )
        {
            CFILETIME cftLocal;
            TCHAR tszTime[ 80 ];

            printf( "    %-16s ", &rgsDcEntries[iEntry].mcid );

            if( rgsDcEntries[iEntry].mcid == mcidDesignated )
                printf( "       (** Designated **)\n" );
            else if( rgsDcEntries[iEntry].fSuspended )
                printf("        (suspended)\n" );
            else
                printf("        (not suspended)\n" );

            cftLocal = rgsDcEntries[iEntry].cftCreation.ConvertUtcToLocal();
            cftLocal.Stringize( ELEMENTS(tszTime), tszTime );
            _tprintf(  TEXT("        Create = %s\n"), tszTime );

            cftLocal = rgsDcEntries[iEntry].cftLastAlive.ConvertUtcToLocal();
            cftLocal.Stringize( ELEMENTS(tszTime), tszTime );
            _tprintf( TEXT("        Alive  = %s\n"), tszTime );

        }

    }
    __finally
    {
        if (ppbvMachineId != NULL)
        {
            ldap_value_free_len(ppbvMachineId);
        }
        if (pptszCreationTime != NULL)
        {
            ldap_value_free(pptszCreationTime);
        }
        if (pptszLastAliveTime != NULL)
        {
            ldap_value_free(pptszLastAliveTime);
        }

        if( NULL != pRes )
            ldap_msgfree(pRes);
    }

    return hr;
}
*/



BOOL
DltAdminSvrStat( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;

    RPC_BINDING_HANDLE BindingHandle;
    BOOL fBound = FALSE;
    BOOL fShowDsInfo = FALSE;
    ULONG iDcName = 0;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption SvrStat\n"
                  "   Purpose: Query a DC for TrkSvr statistics\n"
                  "   Usage:   -svrstat [options] <DC name>\n"
                  "   E.g.:    -svrstat ntdsdc0\n"
                  "   Note:    To find a DC name for a domain, use the nltest tool\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    _tprintf( TEXT("Checking for TrkSvr statistics\n"), rgptszArgs[0] );

    if( 1 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 1;

    if( 2 <= cArgs && TEXT('-') == rgptszArgs[0][0] )
    {
        if( TEXT('d') == rgptszArgs[0][1]
            ||
            TEXT('D') == rgptszArgs[0][1] )
        {
            fShowDsInfo = TRUE;
        }
        else
        {
            printf( "Invalid option.  Use -? for help\n" );
            return( FALSE );
        }

        iDcName = 1;
        (*pcEaten)++;
    }


    __try
    {
        CFILETIME cftLocal(0);
        TCHAR tszLocalFileTime[ 80 ];
        WCHAR wszAuthName[ 80 ];
        WCHAR wszUser[ 80 ];
        WCHAR wszDomain[ 80 ];
        RPC_STATUS rpcstatus = RPC_S_OK;
        RPC_TCHAR * ptszStringBinding = NULL;


        TRKSVR_MESSAGE_UNION Msg;
        memset( &Msg, 0, sizeof(Msg) );
        Msg.MessageType = STATISTICS;
        Msg.Priority = PRI_0;

        // Create a binding string

        rpcstatus = RpcStringBindingCompose(NULL,
                                            L"ncacn_np",
                                            const_cast<TCHAR*>(rgptszArgs[iDcName]),
                                            L"\\pipe\\trksvr",
                                            NULL,
                                            &ptszStringBinding);
        if( RPC_S_OK != rpcstatus )
        {
            hr = HRESULT_FROM_WIN32( rpcstatus );
            _tprintf( TEXT("Failed RpcStringBindingCompose (%d)\n"), rpcstatus );
            goto Exit;
        }
        _tprintf( TEXT("String binding = %s\n"), ptszStringBinding );

        // Get a client binding handle.

        rpcstatus = RpcBindingFromStringBinding(ptszStringBinding, &BindingHandle);
        RpcStringFree(&ptszStringBinding);
        if( RPC_S_OK != rpcstatus )
        {
            _tprintf( TEXT("Failed RpcBindingFromStringBinding (%d)\n"), rpcstatus );
            hr = HRESULT_FROM_WIN32( rpcstatus );
            goto Exit;
        }
        fBound = TRUE;

        // Call up to TrkSvr

        __try
        {
            hr = LnkSvrMessage(BindingHandle, &Msg);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            hr = HRESULT_FROM_WIN32( GetExceptionCode() );
        }
        if( FAILED(hr) )
        {
            _tprintf( TEXT("Failed LnkSvrMessage RPC (%08x)\n"), hr );
            goto Exit;
        }

        // Dump the results

        _tprintf( TEXT("\n") );
        _tprintf( TEXT("%-35s\t%d.%d (Build %d)\n"), TEXT("Version"),
                  Msg.Statistics.Version.dwMajor, Msg.Statistics.Version.dwMinor,
                  Msg.Statistics.Version.dwBuildNumber );

        _tprintf( TEXT("\n") );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("SyncVolume Requests/Errors/Threads"),
                  Msg.Statistics.cSyncVolumeRequests, Msg.Statistics.cSyncVolumeErrors, Msg.Statistics.cSyncVolumeThreads );

        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   CreateVolume Requests/Errors"),
                  Msg.Statistics.cCreateVolumeRequests, Msg.Statistics.cCreateVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   ClaimVolume Requests/Errors"),
                  Msg.Statistics.cClaimVolumeRequests, Msg.Statistics.cClaimVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   QueryVolume Requests/Errors"),
                  Msg.Statistics.cQueryVolumeRequests, Msg.Statistics.cQueryVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   FindVolume Requests/Errors"),
                  Msg.Statistics.cFindVolumeRequests, Msg.Statistics.cFindVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   TestVolume Requests/Errors"),
                  Msg.Statistics.cTestVolumeRequests, Msg.Statistics.cTestVolumeErrors );

        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("Search Requests/Errors/Threads"),
                  Msg.Statistics.cSearchRequests, Msg.Statistics.cSearchErrors, Msg.Statistics.cSearchThreads );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("MoveNotify Requests/Errors/Threads"),
                  Msg.Statistics.cMoveNotifyRequests, Msg.Statistics.cMoveNotifyErrors, Msg.Statistics.cMoveNotifyThreads );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("Refresh Requests/Errors/Threads"),
                  Msg.Statistics.cRefreshRequests, Msg.Statistics.cRefreshErrors, Msg.Statistics.cRefreshThreads );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("DeleteNotify Requests/Errors/Threads"),
                  Msg.Statistics.cDeleteNotifyRequests, Msg.Statistics.cDeleteNotifyErrors, Msg.Statistics.cDeleteNotifyThreads );

        _tprintf( TEXT("\n") );
        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftServiceStart).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Service start"),
                  Msg.Statistics.ftServiceStart.dwHighDateTime, Msg.Statistics.ftServiceStart.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );

        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftLastSuccessfulRequest).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Last successful request"),
                  Msg.Statistics.ftLastSuccessfulRequest.dwHighDateTime, Msg.Statistics.ftLastSuccessfulRequest.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x\n"), TEXT("Last Error"), Msg.Statistics.hrLastError );

        _tprintf( TEXT("\nQuota Information:\n") );
        _tprintf( TEXT("   %-32s\t%d\n"), TEXT("Move Limit"), Msg.Statistics.dwMoveLimit );

        _tprintf( TEXT("   %-32s\t%d\n"), TEXT("Volume table cached count"), Msg.Statistics.dwCachedVolumeTableCount );
        _tprintf( TEXT("   %-32s\t%d\n"), TEXT("Move table cached count"), Msg.Statistics.dwCachedMoveTableCount );

        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftCacheLastUpdated).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("   %-32s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Cache counts last updated"),
                  Msg.Statistics.ftCacheLastUpdated.dwHighDateTime, Msg.Statistics.ftCacheLastUpdated.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );

        _tprintf( TEXT("   %-32s\t%s\n"), TEXT("Is designated DC"),
                  Msg.Statistics.fIsDesignatedDc ? TEXT("Yes") : TEXT("No") );

        _tprintf( TEXT("\n") );
        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftNextGC).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Next GC"),
                  Msg.Statistics.ftNextGC.dwHighDateTime, Msg.Statistics.ftNextGC.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Entries GC-ed"), Msg.Statistics.cEntriesGCed);
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Max DS write events"), Msg.Statistics.cMaxDsWriteEvents);
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Current failed writes"), Msg.Statistics.cCurrentFailedWrites);

        _tprintf( TEXT("\n") );
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Refresh counter"), Msg.Statistics.lRefreshCounter );
        _tprintf( TEXT("%-35s\t%d/%d/%d\n"), TEXT("Available/least/max RPC server threads"),
                  Msg.Statistics.cAvailableRpcThreads, Msg.Statistics.cLowestAvailableRpcThreads, Msg.Statistics.cMaxRpcThreads );
        _tprintf( TEXT("%-35s\t%d/%d\n"), TEXT("Current/most thread pool threads"),
                  Msg.Statistics.cNumThreadPoolThreads, Msg.Statistics.cMostThreadPoolThreads );
        /*
        _tprintf( TEXT("%-35s\t%s\n"), TEXT("Service controller state"),
                  CDebugString( static_cast<SServiceState>(Msg.Statistics.SvcCtrlState))._tsz );
        */

        //ShowMoveCounter( rgptszArgs[iDcName] );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( fBound )
        RpcBindingFree( &BindingHandle );

    return( SUCCEEDED(hr) );
}




BOOL
SetRefreshCounter( CDbConnection &dbc,
                   CLdapVolumeKeyDn dnKey,
                   const SequenceNumber seq )
{
    int                 ldapRV;
    HRESULT             hr = E_FAIL;

    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();
    LDAPMod * mods[2];


    __try
    {
        CLdapSeqNum    lsn(seq);
        CLdapStringMod lsmSequence(s_timeRefresh, lsn, LDAP_MOD_REPLACE );

        mods[0] = &lsmSequence._mod;
        mods[1] = 0;

        ldapRV = ldap_modify_s(dbc.Ldap(), dnKey, mods);

        if(LDAP_SUCCESS != ldapRV)
        {
            printf( "Failed ldap_modify_s(%lu)\n", LdapMapErrorToWin32(ldapRV) );
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV) );
            __leave;
        }

    }
    __finally
    {
    }

    return SUCCEEDED(hr);
}



class CLdapSecret
{
public:
    CLdapSecret()
    {
        memset(_abPad,0,sizeof(_abPad));
    }

    CLdapSecret(const CVolumeSecret &secret)
    {
        _secret = secret;
        memset(_abPad,0,sizeof(_abPad));
    }

    CVolumeSecret _secret;
    BYTE _abPad[sizeof(GUID) - sizeof(CVolumeSecret)];
};



BOOL
DltAdminSetVolumeSeqNumber( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    SequenceNumber seq;
    CVolumeId volid;
    CStringize stringize;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption SetVolSeq\n"
                  "   Purpose: Set the sequence number in a volume table entry\n"
                  "   Usage:   -setvolseq <DC name> <seq> <volid>\n"
                  "   E.g.:    -setvolseq ntdsdc0 90 {d763433c-73a3-48c7-88a5-d6f3552835c6}\n"
                  "   Note:    Requires write access to volume table in DS.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    _tprintf( TEXT("Setting sequence number in volume table\n"), rgptszArgs[0] );

    if( 3 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 1;

    // Get the sequence number

    if( 1 != _stscanf( rgptszArgs[1], TEXT("%d"), &seq ))
    {
        printf( "Invalid sequence number.  Use -? for usage info\n" );
        return FALSE;
    }

    // Get the volid

    // mikehill_test
    DebugBreak();
    stringize.Use( rgptszArgs[2] );
    volid = stringize;

    /*
    {
        RPC_STATUS rpc_status = RPC_S_INVALID_STRING_UUID;
        TCHAR tszTemp[ MAX_PATH ];
        TCHAR *ptszTemp = NULL;

        if( TEXT('{') == rgptszArgs[2][0] ) 
        {
            _tcscpy( tszTemp, &rgptszArgs[2][1] );
            ptszTemp = _tcschr( tszTemp, TEXT('}') );
            if( NULL != ptszTemp )
            {

                *ptszTemp = TEXT('\0');

                rpc_status = UuidFromString( tszTemp, (GUID*)&volid );
            }
        }

        if( RPC_S_OK != rpc_status )
        {
            _tprintf( TEXT("Error: Invalid volume ID\n") );
            return FALSE;
        }
    }
    */

    // Set the sequence

    CDbConnection       dbc;
    dbc.Initialize( NULL, rgptszArgs[0] );

    CLdapVolumeKeyDn dnKey(dbc.GetBaseDn(), volid);

    return SetRefreshCounter( dbc, dnKey, seq );
}




BOOL
SetRefreshCounter2( CDbConnection &dbc,
                   CLdapIdtKeyDn dnKey,
                   const SequenceNumber seq )
{
    int                 ldapRV;
    HRESULT             hr = E_FAIL;

    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();
    LDAPMod * mods[2];


    __try
    {
        CLdapSeqNum    lsn(seq);
        CLdapStringMod lsmSequence(s_timeRefresh, lsn, LDAP_MOD_REPLACE );

        mods[0] = &lsmSequence._mod;
        mods[1] = 0;

        ldapRV = ldap_modify_s(dbc.Ldap(), dnKey, mods);

        if(LDAP_SUCCESS != ldapRV)
        {
            printf( "Failed ldap_modify_s(%lu)\n", LdapMapErrorToWin32(ldapRV) );
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV) );
            __leave;
        }

    }
    __finally
    {
    }

    return SUCCEEDED(hr);
}



BOOL
DltAdminSetDroidSeqNumber( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    SequenceNumber seq;
    CDomainRelativeObjId droid;
    CStringize stringize;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption SetDroidSeq\n"
                  "   Purpose: Set the sequence number in a move table entry\n"
                  "   Usage:   -setdroidseq <DC name> <seq> <volid>\n"
                  "   E.g.:    -setdroidseq ntdsdc0 90 {d763433c-73a3-48c7-88a5-d6f3552835c6}{183c8367-a392-c784-88a5-d6f3552835c6}\n"
                  "   Note:    Requires write access to volume table in DS.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    _tprintf( TEXT("Setting sequence number in move table\n"), rgptszArgs[0] );

    if( 3 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 1;

    // Get the sequence number

    if( 1 != _stscanf( rgptszArgs[1], TEXT("%d"), &seq ))
    {
        printf( "Invalid sequence number.  Use -? for usage info\n" );
        return FALSE;
    }

    // Get the droid

    stringize.Use( rgptszArgs[2] );
    droid = stringize;

    if( CDomainRelativeObjId() == droid )
    {
        _tprintf( TEXT("Error: Invalid DROID\n") );
        return FALSE;
    }

    // Set the sequence

    CDbConnection       dbc;
    dbc.Initialize( NULL, rgptszArgs[0] );

    CLdapIdtKeyDn dnKey(dbc.GetBaseDn(), droid);

    return SetRefreshCounter2( dbc, dnKey, seq );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\frcown.h ===
// FrcOwn.h : Declaration of the CForceOwnership

#ifndef __FRCOWN_H_
#define __FRCOWN_H_

#include "resource.h"       // main symbols
#include <trkwks.hxx>

/////////////////////////////////////////////////////////////////////////////
// CForceOwnership
class ATL_NO_VTABLE CTrkForceOwnership : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CTrkForceOwnership, &CLSID_TrkForceOwnership>,
        public IDispatchImpl<ITrkForceOwnership, &IID_ITrkForceOwnership, &LIBID_ITRKADMNLib>
{
public:
        CTrkForceOwnership() :
            _idt(_dbc, &_refreshSequenceStorage),
            _voltab(_dbc, &_refreshSequenceStorage),
            _refreshSequenceStorage( &_voltab )
        {
            __try
            {
                _dbc.Initialize(NULL);
                _voltab.Initialize(NULL,0,0);
                _idt.Initialize();
            }
            __except( BreakOnDebuggableException() )
            {
            }
        }

DECLARE_REGISTRY_RESOURCEID(IDR_FRCOWN)

BEGIN_COM_MAP(CTrkForceOwnership)
        COM_INTERFACE_ENTRY(ITrkForceOwnership)
        COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ITrkForceOwnership
public:
        STDMETHOD(FileStatus)(BSTR bstrUncPath, long lScope, VARIANT *pvarrgbstrFileName, VARIANT* pvarrgbstrFileId, VARIANT* pvarrglongStatus);
        STDMETHOD(VolumeStatus)(BSTR bstrUncPath, long lScope, VARIANT *pvarlongVolIndex,
                                VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus);
        STDMETHOD(Files)(BSTR bstrUncPath, long lScope);
        STDMETHOD(Volumes)(BSTR bstrUncPath, long lScope );

private:

    CDbConnection       _dbc;
    CVolumeTable        _voltab;
    CIntraDomainTable   _idt;
    CRefreshSequenceStorage _refreshSequenceStorage;
};


//
// This class is used on the client side of an RPC pipe parameter that passes
// volume tracking information.  The client provides a derived class which
// overrides the push/pull methods as appropriate.
//

class PVolInfoPipeCallback : public TPRpcPipeCallback<TRK_VOLUME_TRACKING_INFORMATION>
{
public:

    virtual void Pull( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems ) = 0;
    virtual void Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems ) = 0;

    virtual void Alloc( unsigned long cbRequested, TRK_VOLUME_TRACKING_INFORMATION **ppVolInfo, unsigned long * pcbActual )
    {
        if( cbRequested > sizeof(_rgVolInfo) )
            *pcbActual = sizeof(_rgVolInfo);
        else
            *pcbActual = cbRequested;

        *ppVolInfo = _rgVolInfo;

        return;
    }

private:

    TRK_VOLUME_TRACKING_INFORMATION _rgVolInfo[ 26 ];

};


//
// This class is used on the client side of an RPC pipe parameter that passes
// file tracking information.  The client provides a derived class which
// overrides the push/pull methods as appropriate.
//

class PFileInfoPipeCallback : public TPRpcPipeCallback<TRK_FILE_TRACKING_INFORMATION>
{
public:

    virtual void Pull( TRK_FILE_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems ) = 0;
    virtual void Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems ) = 0;

    virtual void Alloc( unsigned long cbRequested, TRK_FILE_TRACKING_INFORMATION **ppFileInfo, unsigned long * pcbActual )
    {
        if( cbRequested > sizeof(_rgFileInfo) )
            *pcbActual = sizeof(_rgFileInfo);
        else
            *pcbActual = cbRequested;

        *ppFileInfo = _rgFileInfo;

        return;
    }

protected:

    TRK_FILE_TRACKING_INFORMATION _rgFileInfo[ 32 ];

};



//
// This class is used on the client side of an RPC pipe parameter that passes
// a path from the client to the server.
//

class CPCPath : public TPRpcPipeCallback<TCHAR>
{
public:

    CPCPath( TCHAR *ptszPath )
    {
        _iPath = 0;
        _tcscpy( _tszPath, ptszPath );
        _cchPath = _tcslen(_tszPath) + 1;
    }

public:

    void Pull( TCHAR *ptszPath, unsigned long cbBuffer, unsigned long * pcElems )
    {
        if( 0 > _iPath )
        {
            *pcElems = 0;
            return;
        }
        else
        {
            if( sizeof(TCHAR) * (_cchPath - _iPath) > cbBuffer )
                *pcElems = cbBuffer / sizeof(TCHAR);
            else
                *pcElems = _cchPath - _iPath;

            memcpy( ptszPath, &_tszPath[ _iPath ], *pcElems * sizeof(TCHAR) );
            
            if( _iPath + *pcElems >= _cchPath )
                _iPath = -1;
            else
                _iPath += *pcElems;

            return;
        }
    }

    void Push( TCHAR *ptszPath, unsigned long cElems )
    {
        TrkAssert( !TEXT("CGetPathPipeCallback::push shouldn't be called") );
        return;
    }

    void Alloc( unsigned long cbRequested, TCHAR **pptszPath, unsigned long * pcbActual )
    {
        if( cbRequested > sizeof(_tszBuffer) )
            *pcbActual = sizeof(_tszBuffer);
        else
            *pcbActual = cbRequested;

        *pptszPath = _tszBuffer;

        return;
    }

private:

    TCHAR _tszPath[ MAX_PATH + 1 ]; // BUGBUG P2: Path
    TCHAR _tszBuffer[ MAX_PATH + 1 ];
    LONG  _iPath;
    ULONG _cchPath;

};




class CPCVolumeStatus : public PVolInfoPipeCallback
{
public:

    CPCVolumeStatus( CVolumeTable *pvoltab ) : _fInitialized(FALSE), _pvoltab(pvoltab) {};

public:

    void Initialize( CMachineId *pmcid, VARIANT *pvarlongVolIndex, VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus );
    void UnInitialize();

    void Pull( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCVolumeStatus should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems );

public:

    HRESULT GetHResult()
    {
        return( _hr );
    }

    void Compact();

private:

    HRESULT         _hr;
    BOOL            _fInitialized;

    CMachineId      *_pmcid;
    CVolumeTable    *_pvoltab;
    VARIANT         *_pvarlongVolIndex;
    VARIANT         *_pvarbstrVolId;
    VARIANT         *_pvarlongStatus;

    SAFEARRAYBOUND  _sabound;
    LONG            _iArrays;

};




class CPCVolumes : public PVolInfoPipeCallback
{
public:

    CPCVolumes( CMachineId *pmcid,
                CVolumeTable *pvoltab,
                CRefreshSequenceStorage *pRefreshSequenceStorage ) :
                    _pmcid(pmcid),
                    _pvoltab(pvoltab),
                    _pRefreshSequenceStorage(pRefreshSequenceStorage)
    {
        _cVolIds = 0;
        _hr = S_OK;
    };

public:

    void Pull( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCVolumes should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems );

public:

    HRESULT GetHResult()
    {
        return( _hr );
    }

    ULONG   Count()
    {
        return( _cVolIds );
    }

    CVolumeId * GetVolIds()
    {
        return( _rgvolid );
    }


private:

    HRESULT         _hr;
    CMachineId      *_pmcid;
    CVolumeTable    *_pvoltab;
    CRefreshSequenceStorage *_pRefreshSequenceStorage;
    ULONG           _cVolIds;
    CVolumeId       _rgvolid[ NUM_VOLUMES ];  // BUGBUG:  Fixed # volumes

};




class CPCFileStatus : public PFileInfoPipeCallback
{
public:

    CPCFileStatus( CIntraDomainTable *pidt ) : _fInitialized(FALSE), _pidt(pidt) {};

public:

    void Initialize( CMachineId *pmcid, VARIANT *pvarrgbstrFileName, VARIANT *pvarrgbstrFileId, VARIANT *pvarrglongStatus );
    void UnInitialize()
    {
        // Nothing to do, the Variants are cleaned by the caller
        return;
    }

    void Pull( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCFileStatus should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems );

public:

    HRESULT GetHResult()
    {
        return( _hr );
    }

    void Compact();

private:

    HRESULT         _hr;
    BOOL            _fInitialized;

    CMachineId      *_pmcid;
    CIntraDomainTable
                    *_pidt;
    VARIANT         *_pvarrgbstrFileName;
    VARIANT         *_pvarrgbstrFileId;
    VARIANT         *_pvarrglongStatus;

    SAFEARRAYBOUND  _sabound;
    long            _iArrays;

};

class CPCFiles : public PFileInfoPipeCallback
{
public:

    CPCFiles( CIntraDomainTable *pidt )
    {
        _pidt = pidt;
    }

public:

    void Pull( TRK_FILE_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCFiles should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems );

private:

    CIntraDomainTable   *_pidt;

};




#endif //__FRCOWN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\stubs.cxx ===
//+============================================================================
//
//	Stubs to allow the link to succeeded.  None are used.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"



HRESULT StubLnkSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                             ULONG                       RestrictionsIn,
                             const CDomainRelativeObjId *pdroidBirthLast,
                             const CDomainRelativeObjId *pdroidLast,
                             CDomainRelativeObjId       *pdroidBirthNext,
                             CDomainRelativeObjId       *pdroidNext,
                             CMachineId                 *pmcidNext,
                             TCHAR                      *ptsz )
{
    return E_FAIL;
}

HRESULT StubLnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [switch_is][out][in] */ TRKSVR_MESSAGE_UNION __RPC_FAR *pMsg)
{
    return E_FAIL;
}

void
StubLnkMendLink(PRPC_ASYNC_STATE            pAsync_handle,
                RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirth,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId *          pmcidLast,
                CDomainRelativeObjId *      pdroidCurrent,
                CMachineId *                pmcidCurrent,
                ULONG *                     pcbPath,
                WCHAR *                     wsz)
{
    return;
}


HRESULT Stubold2_LnkSearchMachine(  RPC_BINDING_HANDLE           IDL_handle,
                                    ULONG                        RestrictionsIn,
                                    const CDomainRelativeObjId  *pdroidLast,
                                    CDomainRelativeObjId        *pdroidNext,
                                    CMachineId                  *pmcidNext,
                                    TCHAR                       *tsz )
{
    return E_FAIL;
}


HRESULT StubLnkOnRestore(/*[in]*/ RPC_BINDING_HANDLE IDL_handle)
{
    return E_FAIL;
}

HRESULT
StubTriggerVolumeClaims(          RPC_BINDING_HANDLE IDL_handle,
                         /*[in]*/ ULONG cVolumes,
                         /*[in]*/ const CVolumeId *rgvolid )
{
    return E_FAIL;
}

HRESULT
StubGetFileTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                /*[in]*/ CDomainRelativeObjId droidCurrent,
                                /*[in]*/ TrkInfoScope scope,
                                /*[out]*/ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    return E_FAIL;
}

HRESULT
StubGetVolumeTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                  /*[in]*/ CVolumeId volid,
                                  /*[in]*/ TrkInfoScope scope,
                                  /*[out]*/ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    return( E_NOTIMPL );
}

HRESULT StubLnkSetVolumeId( 
    handle_t IDL_handle,
    ULONG iVolume,
    const CVolumeId VolId)
{
    return( E_NOTIMPL );
}



HRESULT StubLnkRestartDcSynchronization(
    RPC_BINDING_HANDLE IDL_handle
    )
{
    return(E_NOTIMPL);
}

HRESULT Stubold_LnkSearchMachine(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidReferral,
    /* [string][out] */ TCHAR __RPC_FAR tsz[ MAX_PATH + 1 ])
{
    return E_NOTIMPL;
}


HRESULT Stubold_LnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD __RPC_FAR *pMsg)
{
    return E_NOTIMPL;
}

HRESULT Stubold_LnkMendLink(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidCurrent,
    /* [string][out] */ WCHAR __RPC_FAR wsz[ MAX_PATH + 1 ] )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\dltadmin\refresh.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"




BOOL
DltAdminRefresh( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fBound = FALSE;
    TRKSVR_MESSAGE_UNION Msg;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Refresh\n"
                " Purpose: Tell the tracking service to update volume list\n"
                " Usage:   -refresh\n" );
        return( TRUE );
    }


    rpcstatus = RpcStringBindingCompose( NULL, TEXT("ncalrpc"), NULL, TEXT("trkwks"),
                                         NULL, &ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;

    memset( &Msg, 0, sizeof(Msg) );
    Msg.MessageType = WKS_VOLUME_REFRESH;
    Msg.Priority = PRI_0;

    __try
    {
        hr = LnkCallSvrMessage( hBinding, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( TRUE );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\makefile.inc ===
#
# Show that the compiled resource file depends
# on the type library.  Otherwise, when the idl
# file is updated, the nmake won't realize that
# it's necessary to recompile the rc file.
#

typelib: $O\itrkadmn.res

$O\itrkadmn.res : .\itrkadmn.tlb

.\itrkadmn.tlb : .\itrkadmn.h

#  The RC file pulls in COM registration scripts
.\itrkadmn.rc : .\frcown.rgs restore.rgs restpars.rgs

#
# Copy the itrkadmn.h header file to publics
#

copyheader : $(BASEDIR)\public\sdk\inc\itrkadmn.h

$(BASEDIR)\public\sdk\inc\itrkadmn.h: itrkadmn.h
        copy itrkadmn.h $(BASEDIR)\public\sdk\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\itrkadmn.cpp ===
// ITrkAdmn.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL, 
//              run nmake -f ITrkAdmnps.mk in the project directory.

#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>
#include <trksvr.hxx>

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ITrkAdmn.h"

#include "ITrkAdmn_i.c"
#include "FrcOwn.h"
#include "RestPars.hxx"
#include "Restore.h"

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

#if DBG
DWORD g_Debug = 0;
CTrkConfiguration g_config;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_TrkForceOwnership, CTrkForceOwnership)
        OBJECT_ENTRY(CLSID_TrkRestoreNotify, CTrkRestoreNotify)
        OBJECT_ENTRY(CLSID_TrkRestoreParser, CRestoreParser)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#if DBG
        g_config.Initialize( );
        g_Debug = g_config._dwDebugFlags;
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "ITrkAdmn" );
#endif
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        // registers object, typelib and all interfaces in typelib
        return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ITrkAdmn.rc
//
#define IDS_PROJNAME                    100
#define IDR_FRCOWN                      101
#define IDR_FRCOWN1                     102
#define IDR_RESTORE                     103
#define IDR_RESTORE1                    104
#define IDR_RESTPARS                    105
#define IDR_RESTPARS1                   106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\pch\dummy.cxx ===
#include "pch.cxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>


#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Prevent the following warning (and three others like it):
// d:\nt\public\sdk\inc\atl21\atlimpl.cpp(2281) : warning C4273: 'malloc' : inconsistent dll linkage.  dllexport assumed.
#pragma warning(disable:4273)
#include <atlimpl.cpp>
#pragma warning(default:4273)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A2531F39_C67D_11D0_8CB1_00C04FD90F85__INCLUDED_)
#define AFX_STDAFX_H__A2531F39_C67D_11D0_8CB1_00C04FD90F85__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_BOTH_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A2531F39_C67D_11D0_8CB1_00C04FD90F85__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\restore.h ===
// Restore.h : Declaration of the CTrkRestoreNotify

#ifndef __RESTORE_H_
#define __RESTORE_H_

#include "resource.h"       // main symbols

#include <trkwks.hxx>

/////////////////////////////////////////////////////////////////////////////
// CTrkRestoreNotify
class ATL_NO_VTABLE CTrkRestoreNotify : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTrkRestoreNotify, &CLSID_TrkRestoreNotify>,
	public IDispatchImpl<ITrkRestoreNotify, &IID_ITrkRestoreNotify, &LIBID_ITRKADMNLib>
{
public:
	CTrkRestoreNotify()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_RESTORE)

BEGIN_COM_MAP(CTrkRestoreNotify)
	COM_INTERFACE_ENTRY(ITrkRestoreNotify)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ITrkRestoreNotify
public:
	STDMETHOD(OnRestore)();

public:
	void		SetMachine(const CMachineId& mcid);

private:
	CMachineId	_mcid;
};

#endif //__RESTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\restore.cpp ===
#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>
#include <trksvr.hxx>

#include "stdafx.h"
#include "ITrkAdmn.h"
#include "Restore.h"

/////////////////////////////////////////////////////////////////////////////
// CTrkRestoreNotify


STDMETHODIMP CTrkRestoreNotify::OnRestore()
{
    HRESULT     hr = E_FAIL;
    CRpcClientBinding rc;

    TrkLog(( TRKDBG_ADMIN, TEXT("CTrkRestoreNotify::OnRestore called") ));

    rc.Initialize(_mcid);

    RpcTryExcept
    {
        hr = LnkOnRestore(rc);
    }
    RpcExcept(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(RpcExceptionCode());
    }
    RpcEndExcept;

Exit:

    return MapTR2HR(hr);
}

void CTrkRestoreNotify::SetMachine(const CMachineId& mcid)
{
	_mcid = mcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkcom\cfactory.cxx ===
#include <pch.cxx>
#pragma hdrstop
#include "trkcom.hxx"

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

long    g_cDllRefs = 0;

#if DBG
DWORD g_Debug = TRKDBG_ERROR;
CTrkConfiguration g_config;
#endif

EXTERN_C int APIENTRY DllMain (HINSTANCE hInstance,
                               DWORD dwReason, 
                               LPVOID lpReserved)
{
    if( DLL_PROCESS_ATTACH == dwReason )
    {
#if DBG
        g_config.Initialize( );
        g_Debug = g_config._dwDebugFlags;
#endif
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "TrkCom" );
        InterlockedIncrement( &g_cDllRefs );
    }

    else if( DLL_PROCESS_DETACH == dwReason )
        InterlockedDecrement( &g_cDllRefs );

    return TRUE;
}

STDAPI DllCanUnloadNow (void)
{
    return ResultFromScode( (0 == g_cDllRefs) ? S_OK : S_FALSE );
}


EXTERN_C STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

    if (!IsEqualCLSID (rclsid, CLSID_TrackFile))
        return ResultFromScode (CLASS_E_CLASSNOTAVAILABLE);
        
    CClassFactory *pClassFactory = new CClassFactory ();

    if (pClassFactory == NULL)
        return ResultFromScode (E_OUTOFMEMORY);

    HRESULT hr = pClassFactory->QueryInterface (riid, ppv);
    pClassFactory->Release ();
    return hr;
}



STDMETHODIMP
CClassFactory::QueryInterface( REFIID riid, void **ppvObject )
{
    IUnknown *pUnk = NULL;

    if( riid == IID_IUnknown
        ||
        riid == IID_IClassFactory
      )
    {
        pUnk = this;
    }

    if( pUnk != NULL )
    {
        pUnk->AddRef();
        *ppvObject = pUnk;
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CClassFactory::AddRef( void )
{
    long cNew;
    cNew = InterlockedIncrement( &_cRefs );
    return( cNew );
}


STDMETHODIMP_(ULONG)
CClassFactory::Release( void )
{
    long cNew;
    cNew = InterlockedDecrement( &_cRefs );

    if( 0 == cNew )
        delete this;

    return( cNew >= 0 ? cNew : 0 );
}


STDMETHODIMP
CClassFactory::CreateInstance( IUnknown *pUnkOuter,
                               REFIID riid,
                               void **ppvObject )
{
    CTrackFile *pObj = NULL;

    if( pUnkOuter != NULL )
    {
        return( CLASS_E_NOAGGREGATION );
    }

    pObj = (CTrackFile*) new CTrackFile( );
    if( pObj == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    return pObj->QueryInterface( riid, ppvObject );
}


STDMETHODIMP
CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
        AddRef();
    else
        Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\itrkadmn\restpars.cxx ===
// RestPars.cxx : Implementation of CRestoreParser


#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>
#include <trksvr.hxx>

#include "stdafx.h"
#include "ITrkAdmn.h"
#include "restore.h"
#include "RestPars.hxx"

/////////////////////////////////////////////////////////////////////////////
// CRestoreParser



HRESULT STDMETHODCALLTYPE
CRestoreParser::ParseDisplayName(
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [in] */ LPOLESTR poszDisplayName,
        /* [out] */ ULONG __RPC_FAR *pchEaten,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut)
{
    LPOLESTR        poszTmp = poszDisplayName;
    HRESULT         hr = E_INVALIDARG;

    *ppmkOut = static_cast<IMoniker*>(this);
    *pchEaten = ocslen(poszDisplayName);
    (*ppmkOut)->AddRef();
    
    if(TEXT('@') != poszTmp[0])
    {
        TrkLog((TRKDBG_ERROR, TEXT("Unrecognized display name (%s)"),
                poszDisplayName));
        goto Exit;
    }
    poszTmp++;
    poszTmp = _tcschr(poszTmp, TEXT('@'));
    if(TEXT('\0') == poszTmp)
    {
        TrkLog((TRKDBG_ERROR, TEXT("Unrecognized progid in display name (%s)"),
                poszDisplayName));
        goto Exit;
    }
    poszTmp++;
    if(TEXT('\0') == poszTmp)
    {
        TrkLog((TRKDBG_ERROR, TEXT("Unexpected end of display name (%s)"),
                poszDisplayName));
        goto Exit;
    }
    __try
    {
        _mcid = CMachineId(poszTmp);
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrkLog((TRKDBG_ERROR, TEXT("Can't convert \"%s\" to machine id"),
                poszTmp));
        hr = GetExceptionCode();
        goto Exit;
    }

Exit:

    return(hr);
}


/* [local] */ HRESULT STDMETHODCALLTYPE
CRestoreParser::BindToObject(
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [in] */ REFIID riidResult,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult)
{ 
    HRESULT hr = E_FAIL;
    IClassFactory *pCF = NULL;

    hr = _Module.GetClassObject(CLSID_TrkRestoreNotify, IID_IClassFactory,
                                reinterpret_cast<void**>(&pCF) );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get ClassFactory in CRestoreParser::BindTobObject (%08x)"), hr ));
        goto Exit;
    }

    hr = pCF->CreateInstance( NULL, riidResult, ppvResult );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't createinstance in CRestoreParser (%08x)"), hr ));
        goto Exit;
    }

    reinterpret_cast<CTrkRestoreNotify*>(*ppvResult)->SetMachine(_mcid);

    hr = S_OK;

Exit:

    RELEASE_INTERFACE( pCF );

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkstub\stub_trkwks_s.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <windows.h>
#include <rpc.h>
#include <rpcasync.h>
#include "trkwks_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkstub\stub_trkwks_c.c ===
#undef RPC_NO_WINDOWS_H
#include <trkwks_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkcom\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( trkcom )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( trkcom ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkstub\trkstub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trklib.hxx"
#include "trkwks.hxx"
#include "trkstub.h"

extern "C"
NTSTATUS
WINAPI
StartTrkWksServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    )
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    dwStatus = RpcpStartRpcServer(
                        SvcsRpcPipeName,
                        Stubtrkwks_v1_2_s_ifspec
                        );

    if(NT_SUCCESS(dwStatus))
    {
        dwStatus = RpcpStartRpcServer(
                    SvcsRpcPipeName,
                    Stubtrkwks_v1_2_s_ifspec
                    );
    }

    return dwStatus;
}


extern "C"
NTSTATUS
WINAPI
StopTrkWksServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    )

{

    NTSTATUS dwStatus = STATUS_SUCCESS;

    RpcpStopRpcServer(
                        Stubtrkwks_v1_2_s_ifspec
                        );

    dwStatus = RpcpStopRpcServer(
                        Stubtrkwks_v1_2_s_ifspec
                        );
    return dwStatus;
}

HRESULT
GetBinding( const TCHAR *ptszProtSeq,
            const TCHAR *ptszEndPoint,
            RPC_BINDING_HANDLE *phBinding )
{
    WCHAR *pwszStringBinding = NULL;
    HRESULT hr = E_FAIL;
    RPC_STATUS rpcstatus;

    rpcstatus = RpcStringBindingCompose( NULL,
                                         const_cast<TCHAR*>(ptszProtSeq),
                                         NULL,
                                         const_cast<TCHAR*>(ptszEndPoint),
                                         NULL,
                                         &pwszStringBinding);
    if( RPC_S_OK != rpcstatus )
    {
        hr = rpcstatus;
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( pwszStringBinding, phBinding );
    if( RPC_S_OK != rpcstatus )
    {
        hr = rpcstatus;
        goto Exit;
    }

    hr = S_OK;

Exit:

    if( NULL != pwszStringBinding )
    {
        RpcStringFree( &pwszStringBinding );
        pwszStringBinding = NULL;
    }

    return hr;
}




HRESULT StubLnkSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                             ULONG                       RestrictionsIn,
                             const CDomainRelativeObjId *pdroidBirthLast,
                             const CDomainRelativeObjId *pdroidLast,
                             CDomainRelativeObjId       *pdroidBirthNext,
                             CDomainRelativeObjId       *pdroidNext,
                             CMachineId                 *pmcidNext,
                             TCHAR                      *ptsz )
{
    HRESULT hr;
    RPC_STATUS  rpcstatus;
    RPC_BINDING_HANDLE  hBinding = NULL;
    BOOL fImpersonating = FALSE;

    hr = GetBinding( s_tszTrkWksRemoteRpcProtocol,
                     s_tszTrkWksRemoteRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {

        hr = LnkSearchMachine( hBinding,
                               RestrictionsIn,
                               pdroidBirthLast,
                               pdroidLast,
                               pdroidBirthNext,
                               pdroidNext,
                               pmcidNext,
                               ptsz );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    return hr;

}

HRESULT StubLnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [switch_is][out][in] */ TRKSVR_MESSAGE_UNION __RPC_FAR *pMsg)
{
    HRESULT hr;
    RPC_STATUS rpcstatus;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fImpersonating = FALSE;

    hr = GetBinding( s_tszTrkWksRemoteRpcProtocol,
                     s_tszTrkWksRemoteRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {
        hr = LnkCallSvrMessage( hBinding, pMsg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    return hr;
}


void
StubLnkMendLink(PRPC_ASYNC_STATE            pAsync_handle,
                RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirth,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId *          pmcidLast,
                CDomainRelativeObjId *      pdroidCurrent,
                CMachineId *                pmcidCurrent,
                ULONG *                     pcbPath,
                WCHAR *                     wsz)
{
    HRESULT hr;
    RPC_STATUS  rpcstatus;
    RPC_BINDING_HANDLE  hBinding = NULL;
    BOOL fImpersonating = FALSE;
    RPC_ASYNC_STATE  RpcAsyncState;
    HANDLE hEvent = NULL;

    hr = GetBinding( s_tszTrkWksLocalRpcProtocol,
                     s_tszTrkWksLocalRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {
        DWORD dwWaitReturn;

        rpcstatus = RpcAsyncInitializeHandle( &RpcAsyncState, RPC_ASYNC_VERSION_1_0 );
        if ( RPC_S_OK != rpcstatus )
        {
            hr = HRESULT_FROM_WIN32( rpcstatus );
            __leave;
        }

        hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ); // Auto-reset, not initially signaled
        if( NULL == hEvent )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            __leave;
        }


        RpcAsyncState.NotificationType = RpcNotificationTypeEvent;
        RpcAsyncState.u.hEvent = hEvent;
        RpcAsyncState.UserInfo = NULL;

        LnkMendLink( &RpcAsyncState,
                     hBinding,
                     ftLimit,
                     RestrictionsIn,
                     pdroidBirth,
                     pdroidLast,
                     pmcidLast,
                     pdroidCurrent,
                     pmcidCurrent,
                     pcbPath,
                     wsz );


        dwWaitReturn = WaitForSingleObject( hEvent, INFINITE );
        if ( WAIT_OBJECT_0 != dwWaitReturn )
        {
            // There was an error of some kind.
            hr = HRESULT_FROM_WIN32( GetLastError() );
            __leave;
        }

        // Now we find out how the LnkMendLink call completed.  If we get
        // RPC_S_OK, then it completed normally, and the result is
        // in hr.

        rpcstatus = RpcAsyncCompleteCall( &RpcAsyncState, &hr );
        if ( RPC_S_OK != rpcstatus )
        {
            // The call either failed or was cancelled (the reason for the
            // cancel would be that the UI thread called CTracker::CancelSearch,
            // or because we timed out above and called RpcAsyncCancelCall).

            hr = HRESULT_FROM_WIN32(rpcstatus);
            __leave;
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }
    
    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    if( NULL != pAsync_handle )
    {
        HRESULT hrT = RpcAsyncCompleteCall( pAsync_handle, &hr );
    }
}


HRESULT Stubold_LnkMendLink(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidCurrent,
    /* [string][out] */ WCHAR __RPC_FAR wsz[ MAX_PATH + 1 ] )
{
    return E_NOTIMPL;
}

HRESULT Stubold2_LnkSearchMachine(  RPC_BINDING_HANDLE           IDL_handle,
                                    ULONG                        RestrictionsIn,
                                    const CDomainRelativeObjId  *pdroidLast,
                                    CDomainRelativeObjId        *pdroidNext,
                                    CMachineId                  *pmcidNext,
                                    TCHAR                       *tsz )
{
    return E_NOTIMPL;
}

HRESULT Stubold_LnkSearchMachine(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidReferral,
    /* [string][out] */ TCHAR __RPC_FAR tsz[ MAX_PATH + 1 ])
{
    return E_NOTIMPL;
}

HRESULT
StubLnkGetBackup(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ DWORD __RPC_FAR *pcVolumes,
    /* [size_is][size_is][out] */ VolumeMapEntry __RPC_FAR *__RPC_FAR *ppVolumeChanges,
    /* [out] */ FILETIME __RPC_FAR *pft)
{
    return E_NOTIMPL;
}

HRESULT
StubGetFileTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                /*[in]*/ CDomainRelativeObjId droidCurrent,
                                /*[in]*/ TrkInfoScope scope,
                                /*[out]*/ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    return E_NOTIMPL;
}

HRESULT
StubGetVolumeTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                  /*[in]*/ CVolumeId volid,
                                  /*[in]*/ TrkInfoScope scope,
                                  /*[out]*/ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    return E_NOTIMPL;
}

HRESULT StubLnkRestartDcSynchronization(
    RPC_BINDING_HANDLE IDL_handle
    )
{
    return E_NOTIMPL;
}


HRESULT StubLnkSetVolumeId(
    handle_t IDL_handle,
    ULONG iVolume,
    const CVolumeId VolId)
{
    RPC_STATUS rpcstatus;
    RPC_BINDING_HANDLE hBinding = NULL;
    HRESULT hr = E_FAIL;
    BOOL fImpersonating = FALSE;

    hr = GetBinding( s_tszTrkWksRemoteRpcProtocol,
                     s_tszTrkWksRemoteRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {
        hr = LnkSetVolumeId( hBinding, iVolume, VolId );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    return hr;
}

HRESULT
StubTriggerVolumeClaims(          RPC_BINDING_HANDLE IDL_handle,
                         /*[in]*/ ULONG cVolumes,
                         /*[in]*/ const CVolumeId *rgvolid )
{
    return E_NOTIMPL;
}


HRESULT StubLnkOnRestore(/*[in]*/ RPC_BINDING_HANDLE IDL_handle)
{
    return E_NOTIMPL;
}

HRESULT Stubold_LnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD __RPC_FAR *pMsg)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkcom\filelink.cxx ===
#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkcom.hxx"
#include "trklib.hxx"

#if !defined(_UNICODE) || defined(OLE2ANSI)
#error This ILinkTrack implementation is only compatible on a Unicode build
#endif

//+----------------------------------------------------------------------------
//
//  Method:     CTrackFile/~CTrackFile
//
//  Synopsis:   Construction/Destruction
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

CTrackFile::CTrackFile()
{
    _cRefs = 0;
    _fDirty = FALSE;
    _fLoaded = FALSE;
    memset( &_PersistentState, 0, sizeof(_PersistentState) );
}

CTrackFile::~CTrackFile()
{
}


//+----------------------------------------------------------------------------
//
//  Method:     IUnknown methods
//
//  Synopsis:   IUnknown
//
//+----------------------------------------------------------------------------

ULONG
CTrackFile::AddRef()
{
    long cNew;
    cNew = InterlockedIncrement( &_cRefs );
    return( cNew );
}

ULONG
CTrackFile::Release()
{
    long cNew;
    cNew = InterlockedDecrement( &_cRefs );
    if( 0 == cNew )
        delete this;

    return( cNew >= 0 ? cNew : 0 );
}

HRESULT
CTrackFile::QueryInterface( REFIID iid, void ** ppvObject )
{
    HRESULT hr = E_NOINTERFACE;

    // Parameter validation

    if( NULL == ppvObject )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }


    *ppvObject = NULL;

    if( IID_IUnknown == iid
        ||
        IID_ITrackFile == iid )
    {
        AddRef();
        *ppvObject = (void*) (IUnknown*) (ITrackFile*) this;
        hr = S_OK;
    }
    else if( IID_ITrackFileRestricted == iid )
    {
        AddRef();
        *ppvObject = (void*) (ITrackFileRestricted*) this;
        hr = S_OK;
    }
    else if( IID_IPersistMemory == iid )
    {
        AddRef();
        *ppvObject = (void*) (IPersistMemory*) this;
        hr = S_OK;
    }
    else if( IID_IPersistStreamInit == iid )
    {
        AddRef();
        *ppvObject = (void*) (IPersistStreamInit*) this;
        hr = S_OK;
    }

Exit:

    return( hr );

}


//+----------------------------------------------------------------------------
//
//  Method:     CreateFromPath (ITrack*)
//
//  Synopsis:   Create a link client for a link source file.
//
//  Arguments:  [poszPath] (in)
//                  The file to which to link.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------  

HRESULT
CTrackFile::CreateFromPath( const OLECHAR * poszPath )
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    CDomainRelativeObjId droidCurrent, droidBirth;

    // Parameter validation

    if( NULL == poszPath )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    __try
    {
        status = GetDroids( poszPath, &droidCurrent, &droidBirth, RGO_GET_OBJECTID );
        if( !NT_SUCCESS(status) )
        {
            hr = HRESULT_FROM_NT(status);
            goto Exit;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    if( FAILED(hr) ) goto Exit;

    _fLoaded = FALSE;
    InitNew();

    _fDirty = TRUE;
    _PersistentState.droidCurrent = droidCurrent;
    _PersistentState.droidBirth = droidBirth;

Exit:

    if( SUCCEEDED(hr) )
        TrkLog(( TRKDBG_CREATE, TEXT("Link created to %s"), poszPath ));

    hr = MapTR2HR( hr );

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  Method:     Resolve (ITrack*)
//  
//  Synopsis:   Determine the current path of a link source.
//
//  Arguments:  [pcbPath] (in/out)
//                  In:  The size of the poszPath buffer
//                  Out: The actual path length (including the null terminator)
//              [poszPath] (out)
//                  The link source's current path.
//              [dwMillisecondTimeout] (in)
//                  A suggestion as to when this method should give up
//                  and return if it hasn't yet found the file.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

// BUGBUG P1:  Optionally return the GetFileAttributesEx info, so that the
// shell doesn't have to re-open the file.

HRESULT
CTrackFile::Resolve( DWORD *pcbPath, OLECHAR * poszPath, DWORD dwMillisecondTimeout )
{
    return( Resolve( pcbPath, poszPath, dwMillisecondTimeout, TRK_MEND_DEFAULT ));
}


HRESULT
CTrackFile::Resolve( DWORD *pcbPath, OLECHAR * poszPath, DWORD dwMillisecondTimeout,
                     DWORD Restrictions )
{
    HRESULT hr = E_FAIL;
    CMachineId mcidLocal( MCID_LOCAL );
    CRpcClientBinding rc;
    CDomainRelativeObjId droidNew;
    CDomainRelativeObjId droidBirth;
    CDomainRelativeObjId droidCurrent;
    OLECHAR oszPathActual[ MAX_PATH + 1 ];
    DWORD cbPathActual = 0;
    CFILETIME cftDue;

    // Parameter validation

    if( NULL == pcbPath
        ||
        NULL == poszPath )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
        else if( !_fLoaded )
        {
                hr = E_UNEXPECTED;
                goto Exit;
        }

        __try
        {
                cftDue.IncrementMilliseconds( dwMillisecondTimeout );

                droidBirth = _PersistentState.droidBirth;
                droidCurrent = _PersistentState.droidCurrent;

                rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint );

                RpcTryExcept
                {
                        CMachineId mcidLast, mcidCurrent;
                        ULONG cbFileName = (MAX_PATH + 1) * sizeof(TCHAR);
                        CDomainRelativeObjId droidBirthNew;

                        hr = LnkMendLink( rc,
                                          cftDue,
                                          Restrictions,
                                          &droidBirth,
                                          &droidCurrent,
                                          &mcidLast,
                                          &droidBirthNew,
                                          &droidNew,
                                          &mcidCurrent,
                                          &cbFileName,
                                          oszPathActual );
                }
                RpcExcept( BreakOnDebuggableException() )
                {
                        hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
                }
                RpcEndExcept;

                if( FAILED(hr) ) goto Exit;


                // Compare droidBirth and droidCurrent with the ones in _PersistentState.
                // If the same, do not set _fDirty.
                if(droidBirth != _PersistentState.droidBirth)
                {
                        _PersistentState.droidBirth = droidBirth;
                        _fDirty = TRUE;
                }
                if(droidNew != _PersistentState.droidCurrent)
                {
                        _PersistentState.droidCurrent = droidNew;
                        _fDirty = TRUE;
                }

                cbPathActual = ( ocslen(oszPathActual) + 1 ) * sizeof(OLECHAR);
                if( cbPathActual > *pcbPath )
                        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                else
                        ocscpy( poszPath, oszPathActual );

                *pcbPath = cbPathActual;
                if( FAILED(hr) ) goto Exit;
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
                hr = GetExceptionCode();
                goto Exit;
        }


Exit:

    return( hr );

}



//+----------------------------------------------------------------------------
//
//  Method:     Open (ITrackFile)
//  
//  Synopsis:   Open the referent file ensure that its object ID is 
//              correct.  If the object ID is not correct, or the
//              file could not be found, then perform a Resolve.
//
//  Arguments:  [pcbPathHint] (in/out)
//                  In:  The size of the poszPathHint buffer
//                  Out: The actual path length (including the null terminator)
//              [poszPathHint] (in/out)
//                  The suggested path to the file.  If the path turns out not
//                  to be correct, an updated path is returned.
//              [dwMillisecondTimeout] (in)
//                  A suggestion as to when this method should give up
//                  and return if it hasn't yet found the file.
//              [dwDesiredAccess] (in)
//                  Access mode for the open file (see Win32 CreateFile)
//              [dwShareMode] (in)
//                  Sharing for the open file (see Win32 CreateFile)
//              [dwFlags] (in)
//                  Specifies the flags for the file (see the FILE_FLAG_*
//                  values in the Win32 CreateFile).
//              [phFile] (out)
//                  The open file handle.  It is because of this parameter
//                  That the ITrackFile interface is [local].
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP CTrackFile::Open( /*in, out*/ DWORD * pcbPathHint,
                               /*in, out, size_is(*pcbPathHint), string*/ OLECHAR * poszPathHint,
                               /*in*/ DWORD dwMillisecondTimeout,
                               /*in*/ DWORD dwDesiredAccess,    // access (read-write) mode 
                               /*in*/ DWORD dwShareMode,        // share mode 
                               /*in*/ DWORD dwFlags,
                               /*out*/ HANDLE * phFile )
{
    return E_NOTIMPL;

/*

    HRESULT hr = S_OK;
    BOOL fTimeout = TRUE;
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK Iosb;
    CObjId cobjidFile;
    DWORD dwTickCountTimeout, dwTickCountNow;

    //  ----------
    //  Initialize
    //  ----------

    *phFile = INVALID_HANDLE_VALUE;

    // Ensure we have an ObjectID to check against.

    if( !_fLoaded )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Calculate the absolute deadline.

    dwTickCountNow = GetTickCount();
    dwTickCountTimeout = dwTickCountNow + dwMillisecondTimeout;
    if( dwTickCountTimeout < dwTickCountNow )
    {
        // Bad dwMillisecondTimeout value
        hr = E_INVALIDARG;
        goto Exit;
    }

    //  -------------
    //  Open the File
    //  -------------

    do
    {
        // Open the file

        hFile = CreateFile( poszPathHint, dwDesiredAccess, dwShareMode, NULL,
                            OPEN_EXISTING, dwFlags, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        // Get the object ID

        status = NtFsControlFile(
                     hFile,
                     NULL,
                     NULL,
                     NULL,
                     &Iosb,
                     FSCTL_GET_OBJECT_ID,
                     NULL,                  // In buffer
                     0,                     // In buffer size
                     &fobOID,               // Out buffer
                     sizeof(fobOID) );      // Out buffer size

        if( !NT_SUCCESS(status) )
        {
            hr = HRESULT_FROM_NT( status );
            goto Exit;
        }

        // Verify the object ID

        cobjidFile.Load( fobOID, LINK_TYPE_FILE );

        if( cobjidFile == _PersistentState.droidCurrent.GetObjId() )
        {
            // We found a good file and we're done.
            fTimeout = FALSE;
            break;
        }
        else
        {
            // Try to find the correct file.
            hr = Resolve( pcbPathHint, poszPathHint, dwTickCountTimeout - GetTickCount() );
            if( FAILED(hr) ) goto Exit;
        }
    
    }   while( GetTickCount() < dwTickCountTimeout );

    // Did the previous loop end because of a timeout?

    if( fTimeout )
    {
        hr = HRESULT_FROM_WIN32( ERROR_TIMEOUT );
        goto Exit;
    }

    // We completed successfully.

    *phFile = hFile;
    hFile = INVALID_HANDLE_VALUE;
    hr = S_OK;

    //  ----
    //  Exit
    //  ----

Exit:

    if( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );

    return( hr );
*/
}   // CTrackFile::Open()



//+----------------------------------------------------------------------------
//
//  Method:     GetClassID (IPersistMemory & IPersistStreamInit)
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::GetClassID( CLSID *pClassID )
{
    if(NULL == pClassID)
    {
        return E_POINTER;
    }
    *pClassID = IID_ITrackFile;
    return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  Method:     IsDirty (IPersistMemory & IPersistStreamInit)
//
//  Returns:    HRESULT
//                  S_OK => Dirty, S_FALSE => clean
//
//+----------------------------------------------------------------------------


STDMETHODIMP
CTrackFile::IsDirty()
{
    return( _fDirty ? S_OK : S_FALSE );
}


//+----------------------------------------------------------------------------
//
//  Method:     Load (IPersistMemory)
//
//  Synopsis:   Load the TrackFile object from persistent state.
//
//  Arguments:  [pvMem]
//                  Points to the serialization buffer.
//              [cbSize]
//                  Size of the serialization buffer.
//  
//  Returns:    None
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Load( void * pvMem, ULONG cbSize )
{
    LinkTrackPersistentState PersistentState;

    if( NULL == pvMem )
        return( E_POINTER );

    else if( _fLoaded )
        return( E_UNEXPECTED );

    else if( sizeof(_PersistentState) > cbSize )
        return( E_INVALIDARG );

    else if( ( (LinkTrackPersistentState*) pvMem )->clsid != IID_ITrackFile )
        return( E_INVALIDARG );

    else if( ( (LinkTrackPersistentState*) pvMem )->cbSize < sizeof(_PersistentState) )
        return( E_INVALIDARG );

    else
    {
        _PersistentState = *(LinkTrackPersistentState*) pvMem;
        _fLoaded = TRUE;
        return( S_OK );
    }
        
}


//+----------------------------------------------------------------------------
//
//  Method:     Save(IPersistMemory)
//
//  Synopsis:   Save the persistent state to a memory buffer.
//
//  Arguments:  [pvMem]
//                  The buffer to which we'll save.
//              [fClearDirty]
//                  TRUE => we'll set _fDirty to FALSE on a successful save.
//              [cbSize]
//                  The available buffer in pvMem.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Save( void* pvMem, BOOL fClearDirty, ULONG cbSize )
{
    if( NULL == pvMem )
        return( E_POINTER );

    else if( !_fLoaded )
        return( E_UNEXPECTED );

    else if( sizeof(_PersistentState) > cbSize )
        return( E_INVALIDARG );

    else
    {
        *(LinkTrackPersistentState*) pvMem = _PersistentState;

        if( fClearDirty )
            _fDirty = FALSE;

        return( S_OK );
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     InitNew
//
//  Synopsis:   Initialize the TrackFile object.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::InitNew()
{
    if( _fLoaded )
        return( E_UNEXPECTED );
    else
    {
        memset( &_PersistentState, 0, sizeof(_PersistentState) );
        _PersistentState.cbSize = sizeof(_PersistentState);
        _PersistentState.clsid = IID_ITrackFile;
        _fLoaded = TRUE;
        return( S_OK );
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     GetSizeMax (IPersistMemory)
//
//  Synopsis:   Returns the size necessary to pass to IPersist:Save
//
//  Arguments:  [pcbSize]
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::GetSizeMax( ULONG *pcbSize )
{
    if( NULL == pcbSize )
        return( E_POINTER );
    else
    {
        *pcbSize = sizeof(_PersistentState);
        return( S_OK );
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSizeMax (IPersistStreamInit)
//
//  Synopsis:   Returns the size necessary.
//
//  Arguments:  [pcbSize]
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::GetSizeMax( ULARGE_INTEGER* pcbSize )
{
    if( NULL == pcbSize )
        return( E_POINTER );
    else
    {
        pcbSize->QuadPart = sizeof(_PersistentState);
        return( S_OK );
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     Load (IPersistStreamInit)
//
//  Synopsis:   Load the TrackFile object from a stream.
//
//  Arguments:  [pStm]
//                  Points to the IStream interface.
//  
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Load(IStream* pStm)
{
    HRESULT                     hr;                     // return value
    LinkTrackPersistentState    PersistentState;        // tmp storage
    ULONG                       cbRead;                 // # of bytes read
    LARGE_INTEGER               cbOffset;               // = -cbRead
    ULONG                       cbSize = sizeof(_PersistentState);

    if(NULL == pStm)
        return(E_POINTER);

    else if(_fLoaded)
        return(E_UNEXPECTED);

    // Read _PersistentState from the stream and check if the read is
    // successful. If not, revert back the seek pointer in pStm, and
    // return the HRESULT.
    hr = pStm->Read((byte*)&PersistentState, cbSize, &cbRead);
    if(FAILED(hr) || cbSize != cbRead)
    {
        cbOffset.QuadPart = -static_cast<LONGLONG>(cbRead);
        goto Exit;
    }

    // So now we successfully read the _PersistentState into memory, check to
    // see if we read garbage. If so, revert and return the error.
    // xxx What error message should be returned for this?
    if(PersistentState.clsid != IID_ITrackFile)
    {
        cbOffset.QuadPart = -static_cast<LONGLONG>(cbRead);
        hr = E_FAIL;
        goto Exit;
    }

    // Everything went well. Now we can copy _PersistentState from its
    // temporary storage to its real storage.
    _PersistentState = PersistentState;
    _fLoaded = TRUE;
    return(S_OK);

Exit:
        
    pStm->Seek(cbOffset, STREAM_SEEK_CUR, NULL);
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     Save (IPersistStreamInit)
//
//  Synopsis:   Save the persistent state to a stream.
//
//  Arguments:  [pStm]
//                  The IStream interface we use to save.
//              [fClearDirty]
//                  TRUE => we'll set _fDirty to FALSE on a successful save.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Save(IStream* pStm, BOOL fClearDirty)
{
    HRESULT         hr;
    ULONG           cbSize = sizeof(_PersistentState);
    ULONG           cbWritten;                          // # of bytes written
    LARGE_INTEGER   cbOffset;                           // same as cbWritten

    if(NULL == pStm)
        return(E_POINTER);

    else if( !_fLoaded )
        return(E_UNEXPECTED);

    else
    {
        // Write the _PersistentState to the stream and check the return value.
        // If failed, revert the changes in IStream and return the HRESULT.
        hr = pStm->Write((byte*)&_PersistentState, cbSize, &cbWritten);
        if(FAILED(hr))
        {
            cbOffset.QuadPart = -static_cast<LONGLONG>(cbWritten);
            pStm->Seek(cbOffset, STREAM_SEEK_CUR, NULL);
            return hr;
        }

        if(fClearDirty)
            _fDirty = FALSE;

        return(S_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\crossdom.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       crossdom.cxx
//
//  Contents:   Cross-domain table.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"

void
CCrossDomainTable::Initialize()
{
    _fInitializeCalled = TRUE;
}

void
CCrossDomainTable::UnInitialize()
{
    _fInitializeCalled = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\makefile.inc ===
trksvr_s.c : $(BASEDIR)\private\genx\types\tracking\idl\trksvr_s.c
   copy $? $@

clean:
   -del /q /f $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\dbconn.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       dbconn.cxx
//
//  Contents:   Shared database initialization code.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"

// LDAP version
void
CDbConnection::Initialize(CSvcCtrlInterface * psvc, OPTIONAL const TCHAR *ptszHostName )
{
    int err;
    LDAPMessage *pRes = NULL;
    TCHAR ** ppszNamingContexts = NULL;
    int tries = 0;
    TCHAR tszLocalHostName[ MAX_COMPUTERNAME_LENGTH + 1 ];

    _fInitializeCalled = TRUE;
    _pszBaseDn = NULL;

    __try
    {
        if( NULL == ptszHostName )
        {
            CMachineId(MCID_LOCAL).GetName( tszLocalHostName, ELEMENTS(tszLocalHostName) );
            ptszHostName = tszLocalHostName;
        }

        TrkLog((TRKDBG_SVR, TEXT("ldap_init(%s, LDAP_PORT)"), ptszHostName ));
        _pldap = ldap_init( const_cast<TCHAR*>(ptszHostName), LDAP_PORT);
        if( NULL == _pldap )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("CDbConnection failed ldap_init (%lu)"),
                     GetLastError() ));
            TrkRaiseLastError();
        }

        // Set the option telling LDAP that we gave it an explicit DC name and
        // that it can avoid the DsGetDcName.

        LONG LdapOption = PtrToLong(LDAP_OPT_ON);
        err = ldap_set_optionW( _pldap, LDAP_OPT_AREC_EXCLUSIVE, &LdapOption );
        if( LDAP_SUCCESS != err  )
        {
            TrkLog(( TRKDBG_ERROR,
                     TEXT("Failed ldap_set_option (LDAP_OPT_AREC_EXCLUSIVE) - %ld"),
                     err ));
            TrkRaiseException( LdapMapErrorToWin32(err) );
        }
    
        // Note:  This method used to do an ldap_open, but that function has been
        // deprecated.  The problem in NT5, was that during bootup call to ldap_open
        // the DS occasionally wasn't yet available.  Thus the logic below was added
        // to do retries.
        // Really, all of this code should go away except for the ldap_init, since
        // ldap_connect is called implicitely by all the ldap apis.  But to minimize
        // the risk, the code has been left basically unchanged, other than using
        // ldap_init/ldap_connect rather than ldap_open.  If this code needs to be
        // modified at any point, it should be reworked to remove the ldap_connect.

        LDAP_TIMEVAL Timeout;
        Timeout.tv_sec = 2;
        Timeout.tv_usec = 0;

retry:

        err = ldap_connect( _pldap, &Timeout );
        if( LDAP_SUCCESS != err )
        {
            if (tries++ < 10)
            {
                TrkLog((TRKDBG_ERROR, TEXT("ldap_open returned NULL, now sleeping...")));
                if (psvc != NULL)
                    psvc->UpdateWaitHint(30000);
                goto retry;
            }

            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - failed :-(")));
            TrkRaiseLastError( );
        }


        // search to get default base DN
    
        err = ldap_bind_s(_pldap,
                    NULL,       // DN of what ? system account object ?
                    NULL,       // we're running as system, so use our credentials
                    LDAP_AUTH_SSPI);
        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_bind_s failed")));
            TrkRaiseWin32Error( LdapMapErrorToWin32(err) );
        }
    
        TCHAR *aszNamingContexts[2] = { TEXT("NamingContexts"), NULL };
    
        err = ldap_search_s(_pldap,
                      NULL, // searching of tree
                      LDAP_SCOPE_BASE,
                      TEXT("(objectclass=*)"),
                      aszNamingContexts,
                      0,
                      &pRes);
    
        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_search_s failed (%lu)"), err ));
            TrkRaiseException( TRK_E_DB_CONNECT_ERROR );
        }
    
        if (ldap_count_entries(_pldap, pRes) == 0)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_count_entries found no entries (%lu)"), err ));
            TrkRaiseException( TRK_E_DB_CONNECT_ERROR );
        }
    
        LDAPMessage * pEntry = ldap_first_entry(_pldap, pRes);
        if (pEntry == NULL)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_first_entry failed (%lu)"), err ));
            TrkRaiseWin32Error(LdapMapErrorToWin32(_pldap->ld_errno));
        }

        int l;
        ppszNamingContexts = ldap_get_values(_pldap, pEntry, TEXT("NamingContexts"));
        if (ppszNamingContexts == NULL ||
            ppszNamingContexts[0] == NULL ||
            (l=_tcslen(ppszNamingContexts[0])) == 0)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - couldn't find 'NamingContexts'")));
            TrkRaiseWin32Error(LdapMapErrorToWin32(_pldap->ld_errno));
        }

        for (int i=0; i<l-4; i++)
        {
            if (memcmp(&ppszNamingContexts[0][i],
                       TEXT("DC="),
                       3*sizeof(TCHAR)) == 0)
            {
                break;
            }
        }

        if (i == l-3)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - couldn't find 'DC'")));
            TrkRaiseException( TRK_E_DB_CONNECT_ERROR );
        }

        _pszBaseDn = new TCHAR [l-i+1];
        if (_pszBaseDn == NULL)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - out of memory")));
            TrkRaiseWin32Error(ERROR_NOT_ENOUGH_MEMORY);
        }

        _tcscpy(_pszBaseDn, &ppszNamingContexts[0][i]);
    }
    __finally
    {
        if (pRes)
            ldap_msgfree(pRes);
        if (ppszNamingContexts)
            ldap_value_free(ppszNamingContexts);
    }
}

void
CDbConnection::UnInitialize()
{
    if (_fInitializeCalled)
    {
        if (_pldap != NULL)
        {
            // There is no ldap_close.  Call ldap_unbind, even if ldap_bind
            // wasn't called.
            ldap_unbind( _pldap );
            _pldap = NULL;
        }

        if (_pszBaseDn)
        {
            delete [] _pszBaseDn;
            _pszBaseDn = NULL;
        }

        _fInitializeCalled = FALSE;
    }
}

LDAP *
CDbConnection::Ldap()
{
    // The critsec initialization may have failed.
    if( !_cs.IsInitialized() )
        _cs.Initialize();   // Raises on error

    _cs.Enter();

    if (!_fInitializeCalled)
    {
        __try
        {
            Initialize(NULL);
        }
        __finally
        {
            if (AbnormalTermination())
            {
                UnInitialize();
                _cs.Leave();
            }
        }
    }

    _cs.Leave();

    return(_pldap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\denial.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       denial.cxx
//
//  Contents:   Code to detect denial of service attacks.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "trksvr.hxx"

#define MAX_HISTORY_PERIODS     8   // best to make this a power of two for easy division
#define HISTORY_PERIOD          10  // seconds
#define MAX_MOVING_AVERAGE      20  // 20 notifications per HISTORY_PERIOD

struct ACTIVECLIENT
{
    ACTIVECLIENT(const CMachineId & mcidClient) : _mcidClient(mcidClient)
    {
        _pNextClient = NULL;
        memset(_aRequestHistory, 0, sizeof(_aRequestHistory));
        _iWrite = 0;
        _cNonZero = 0;
    }

    inline void     CountEvent();
    inline BOOL     IsActive();
    inline void     NewPeriod();
    ULONG           Average();

    struct ACTIVECLIENT *  _pNextClient;
    CMachineId             _mcidClient;
    ULONG                  _aRequestHistory[MAX_HISTORY_PERIODS];
    ULONG                  _iWrite;
    ULONG                  _cNonZero;
};


void
CDenialChecker::Initialize( ULONG ulHistoryPeriod )
{

    _cs.Initialize();
    _fInitializeCalled = TRUE;
    _pListHead = NULL;

#if DBG
    _lAllocs = 0;
#endif


    _timer.Initialize(this,
                      NULL,         // No name (non-persistent)
                      0,            // Context ID
                      ulHistoryPeriod,
                      CNewTimer::NO_RETRY,
                      0, 0, 0 );

}

// must be called after the worker thread has exitted
// RPC server stopped already

void
CDenialChecker::UnInitialize()
{
    if (_fInitializeCalled)
    {
        _fInitializeCalled = FALSE;

        _timer.UnInitialize();
        _cs.UnInitialize();

        ACTIVECLIENT * pDel = _pListHead;

        while (pDel)
        {
            ACTIVECLIENT * pNext = pDel->_pNextClient;

            delete pDel;
#if DBG
            _lAllocs--;
#endif
            pDel = pNext;
        }
        TrkLog((TRKDBG_DENIAL, TEXT("CDenialChecker::UnInitialize _lAllocs = %d"), _lAllocs));
    }
}

void
CDenialChecker::CheckClient(const CMachineId & mcidClient)
{

    __try
    {
        _cs.Enter();

        ACTIVECLIENT * pSearch = _pListHead;
        ACTIVECLIENT * pPrevious = NULL;

        while (pSearch)
        {
            if (pSearch->_mcidClient == mcidClient)
            {
                // move to head of list so that we can quickly find the abuser
                // next time
                if ( pSearch != _pListHead )
                {
                    TrkAssert(pPrevious != NULL);
                    pPrevious->_pNextClient = pSearch->_pNextClient;
                    pSearch->_pNextClient = _pListHead;
                    _pListHead = pSearch;
                }
    
                pSearch->CountEvent();
                if (pSearch->Average() > MAX_MOVING_AVERAGE)
                {
                    TrkRaiseException(TRK_E_DENIAL_OF_SERVICE_ATTACK);
                }
                break;
            }

            pPrevious = pSearch;
            pSearch = pSearch->_pNextClient;
        }

        if (pSearch == NULL)
        {
            ACTIVECLIENT * pNew = new ACTIVECLIENT(mcidClient);

            TrkLog(( TRKDBG_DENIAL, TEXT("Adding to denial list (%d)"), _lAllocs+1 ));


            if (!pNew)
            {
                TrkRaiseWin32Error(ERROR_NOT_ENOUGH_MEMORY);
            }
#if DBG
            _lAllocs++;
#endif

            // If the list had gone empty, then the timer was stopped,
            // so start it back up again.

            if( NULL == _pListHead )
            {
                TrkLog(( TRKDBG_DENIAL, TEXT("Starting denial-checker timer") ));
                _timer.SetRecurring();
            }

            pNew->_pNextClient = _pListHead;
            _pListHead = pNew;
        }
    }
    __finally
    {
        _cs.Leave();
    }
}

PTimerCallback::TimerContinuation
CDenialChecker::Timer( ULONG ulTimerId )
{
    //
    // periodically increment iWrite in each entry
    // and throw out entries that are now too old
    // (this is when all counters go to zero i.e.
    // no activity for MAX_HISTORY_PERIODS periods)

    _cs.Enter();

    ACTIVECLIENT * pSearch = _pListHead;
    ACTIVECLIENT * pPrevious = NULL;
    TimerContinuation continuation = CONTINUE_TIMER;

    while (pSearch)
    {
        pSearch->NewPeriod();
        if (!pSearch->IsActive())
        {
            // remove from list and free
            ACTIVECLIENT * pNext = pSearch->_pNextClient;

            TrkLog(( TRKDBG_DENIAL, TEXT("Paring denial list (%d)"), _lAllocs-1 ));

            if (pPrevious)
            {
                pPrevious->_pNextClient = pNext;
            }
            else
            {
                _pListHead = pNext;
            }
            delete pSearch;
#if DBG
            _lAllocs--;
#endif
            pSearch = pNext;
        }
        else
        {
            pPrevious = pSearch;
            pSearch = pSearch->_pNextClient;
        }
    }

    if( NULL == _pListHead )
    {
        TrkLog(( TRKDBG_DENIAL, TEXT("Stopping denial checker timer") ));
        continuation = BREAK_TIMER;
    }

    _cs.Leave();

    //TrkLog((TRKDBG_DENIAL, TEXT("CDenialChecker: SimpleTimer _lAllocs = %d"), _lAllocs));

    TrkAssert( CNewTimer::NO_RETRY == _timer.GetRetryType() );
    TrkAssert( _timer.IsRecurring() );

    return( continuation );
}

inline void
ACTIVECLIENT::CountEvent()
{
    _aRequestHistory[_iWrite] ++;
    if (_aRequestHistory[_iWrite] == 1)
    {
        TrkAssert(_cNonZero < MAX_HISTORY_PERIODS);
        _cNonZero ++;
    }
}

// returns FALSE if we should discard this ACTIVECLIENT

inline void
ACTIVECLIENT::NewPeriod()
{
    // skip the write pointer to next
    if (_iWrite >= sizeof(_aRequestHistory)/sizeof(_aRequestHistory[0]))
        _iWrite = 0;
    else
        _iWrite ++;

    // if what we're writing over is not zero, then keep track of # of zero entries
    if (_aRequestHistory[_iWrite] != 0)
    {
        TrkAssert(_cNonZero != 0);
        _cNonZero --;
    }

    _aRequestHistory[_iWrite] = 0;

}

inline BOOL
ACTIVECLIENT::IsActive()
{
    return(_cNonZero != 0);
}

inline ULONG
ACTIVECLIENT::Average()
{
    ULONG Sum=0;
    for ( ULONG i=0; i<MAX_HISTORY_PERIODS; i++ )
        Sum += _aRequestHistory[i];
    return(Sum / MAX_HISTORY_PERIODS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\intradom.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       intradom.cxx
//
//  Contents:   Intra-domain table.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\idt_ldap.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       idt_ldap.cxx
//
//  Contents:   Intra-domain table based on LDAP.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------



#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"


CLdapOMTAddModify::CLdapOMTAddModify(
                const CDomainRelativeObjId & ldKey,
                const CDomainRelativeObjId & ldNew,
                const CDomainRelativeObjId & ldBirth,
                const ULONG & seqRefresh,
                BYTE bFlags,
                int   mod_op )
                :
                 
    _lsmClass(s_objectClass, s_linkTrackOMTEntry, 0),

    _lbmCurrentLocation( s_currentLocation, reinterpret_cast<PCCH>(&ldNew), sizeof(ldNew), mod_op ),
    _lbmBirthLocation( s_birthLocation, reinterpret_cast<PCCH>(&ldBirth), sizeof(ldBirth), mod_op ),
    _ltvRefresh( seqRefresh ),
    _lsmRefresh( s_timeRefresh, _ltvRefresh, mod_op ),
    _lbmFlags( s_oMTIndxGuid, reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), mod_op )

{
    int i = 0;
    if (mod_op == LDAP_MOD_ADD)
    {
        _mods[i++] = &_lsmClass._mod;
        _mods[i++] = &_lbmFlags._mod;
    }
    _mods[i++] = &_lbmCurrentLocation._mod;

    if (ldKey != ldBirth)
        _mods[i++] = &_lbmBirthLocation._mod;

    _mods[i++] = &_lsmRefresh._mod;
    _mods[i++] = NULL;

    TrkAssert(i <= sizeof(_mods)/sizeof(_mods[0]));
}

void
CIntraDomainTable::Initialize( CTrkSvrConfiguration *pTrkSvrConfiguration, CQuotaTable* pqtable )
{
    _fInitializeCalled = TRUE;
    _pqtable = pqtable;
    _pTrkSvrConfiguration = pTrkSvrConfiguration;
    _QuotaReported.Initialize();
}

void
CIntraDomainTable::UnInitialize()
{
    if (_fInitializeCalled)
    {
    }
    _fInitializeCalled = FALSE;
}


//+----------------------------------------------------------------------------
//
//  CIntraDomainTable::Add
//
//  Add an entry to the move table.  Return TRUE if the entry was added, but
//  didn't already exist.  Return FALSE if the entry already exists.  If
//  there's an error, raise an exception.
//
//+----------------------------------------------------------------------------

BOOL
CIntraDomainTable::Add(const CDomainRelativeObjId &ldKey, 
                       const CDomainRelativeObjId &ldNew, 
                       const CDomainRelativeObjId &ldBirth,
                       BOOL  *pfQuotaExceeded OPTIONAL )
{
    int     err;
    BYTE    bFlags = QFLAG_UNCOUNTED;

    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);

    // The following constructor sets up the mods array for
    // the ldap_add_s call that we're about to do.

    CLdapOMTAddModify  lam( ldKey,              // Key
                            ldNew,              // New droid
                            ldBirth,            // Birth droid
                                                // Current sequence number
                            _pRefreshSequenceStorage->GetSequenceNumber(),
                            bFlags,             // Flags, will be pointed to
                                                //   (so can't e.g. use a #define value)
                            LDAP_MOD_ADD);      // Add this element

    // Return FALSE here means that we pretend to the caller that the entry
    // already exists. We don't want to raise an exception here. Our caller
    // always tries to add the entry, if the add fails because the entry
    // already exists, the caller will then try to modify the entry. If the
    // quota has been exceeded, we don't want to add more entries, but we
    // still want entries already in the table to be modifiable. So instead of
    // raising an exception, we really want the caller to try to modify the
    // entry instead.

    if(_pqtable->IsMoveQuotaExceeded())
    {
        if( NULL != pfQuotaExceeded )
            *pfQuotaExceeded = TRUE;

        if( !_QuotaReported.IsSet() )
        {
            _QuotaReported.Set();
            TrkReportEvent( EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED, EVENTLOG_WARNING_TYPE,
                            TRKREPORT_LAST_PARAM );
        }

        return FALSE;
    }
    else
    {
        _QuotaReported.Clear();
    }

    err = ldap_add_s(Ldap(), dnKey, lam._mods);
    if (err == LDAP_SUCCESS)
    {
        {
            LDAPMod*        mods[2];
            BYTE bFlags = QFLAG_UNCOUNTED;
            CLdapBinaryMod  lbm(s_oMTIndxGuid, reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), LDAP_MOD_REPLACE);

            mods[0] = &lbm._mod;
            mods[1] = NULL;

            err = ldap_modify_s(Ldap(), dnKey, mods);
        }

        _pqtable->IncrementMoveCountCache();
        return(TRUE);
    }
    else
    if (err == LDAP_ALREADY_EXISTS)
    {
        return(FALSE);
    }
    else
    {
        TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        return(FALSE);
    }

}

// TRUE if found and deleted, FALSE if not found, exception on other errors

BOOL
CIntraDomainTable::Delete(const CDomainRelativeObjId &ldKey)
{
    int err;
    CLdapIdtKeyDn       dnKey(GetBaseDn(), ldKey);
    BOOL fFound;

    fFound = _pqtable->UpdateFlags(Ldap(), dnKey, QFLAG_DELETED);
    if( fFound )
        _pqtable->DecrementMoveCountCache();
    return fFound;
}

// TRUE if entry exists and modified, FALSE if not existent, exception otherwise
BOOL
CIntraDomainTable::Modify(const CDomainRelativeObjId &ldKey, 
                          const CDomainRelativeObjId &ldNew, 
                          const CDomainRelativeObjId &ldBirth )
{
    int             err;
    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);
    CLdapOMTAddModify  lam( ldKey,
                            ldNew, 
                            ldBirth, 
                            _pRefreshSequenceStorage->GetSequenceNumber(), 
                            0, // Only used with LDAP_MOD_ADD
                            LDAP_MOD_REPLACE);

    err = ldap_modify_s(Ldap(), dnKey, lam._mods);

    if (err == LDAP_SUCCESS)
    {
        return(TRUE);
    }
    else
    if (err == LDAP_NO_SUCH_OBJECT)
    {
        return(FALSE);
    }
    else
    {
        TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        return(FALSE);
    }
}

// must leave outputs unchanged if returning FALSE
BOOL
CIntraDomainTable::Query(const CDomainRelativeObjId &ldKey, 
                         CDomainRelativeObjId *pldNew,
                         CDomainRelativeObjId *pldBirth,
                         BOOL *pfDeleted OPTIONAL,
                         BOOL *pfCounted OPTIONAL )
{
    int             err;
    TCHAR           *aptszAttrs[] = { const_cast<TCHAR*>(s_currentLocation),
                                      const_cast<TCHAR*>(s_birthLocation),
                                      const_cast<TCHAR*>(s_oMTIndxGuid),
                                      NULL };
    LDAPMessage *   pRes = NULL;
    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);
    BOOL            fFound = FALSE;

    __try
    {
        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_BASE,
                             TEXT("(objectclass=*)"),
                             aptszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        if (err == LDAP_SUCCESS)
        {
            // found it, lets get the attributes out

            if (ldap_count_entries(Ldap(), pRes) == 1)
            {
                LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
                if (pEntry == NULL)
                {
                    TrkRaiseWin32Error(LdapMapErrorToWin32(Ldap()->ld_errno));
                }

                fFound = Query( Ldap(), pEntry, ldKey, pldNew, pldBirth, pfDeleted, pfCounted );
            }
        }
        else
        if (err != LDAP_NO_SUCH_OBJECT)
        {
            TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        }
    }
    __finally
    {
        if (NULL != pRes)
            ldap_msgfree(pRes);
    }

    return(fFound);
}


BOOL
CIntraDomainTable::Query( LDAP* pLdap,
                          LDAPMessage *pEntry,
                          const CDomainRelativeObjId ldKey,
                          CDomainRelativeObjId *pldNew,
                          CDomainRelativeObjId *pldBirth,
                          BOOL *pfDeleted OPTIONAL,
                          BOOL *pfCounted OPTIONAL )
{
    BOOL fFound = FALSE;
    struct berval **ppbvCurrentLocation = NULL;
    struct berval **ppbvBirthLocation = NULL;
    struct berval **ppbvQuotaFlags = NULL;
    BYTE bQuotaFlags = 0;

    if( NULL != pfDeleted )
        *pfDeleted = FALSE;

    __try
    {
        ppbvBirthLocation = ldap_get_values_len(pLdap, pEntry,
                                                const_cast<TCHAR*>(s_birthLocation) );

        if (NULL != ppbvBirthLocation
            &&
            sizeof(*pldBirth) > (*ppbvBirthLocation)->bv_len)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get current location for %s"),
                               (const TCHAR*)CDebugString(ldKey) ));
            TrkRaiseWin32Error( LdapMapErrorToWin32(pLdap->ld_errno) );
        }

        ppbvCurrentLocation = ldap_get_values_len(pLdap, pEntry,
                                                  const_cast<TCHAR*>(s_currentLocation) );
        if (NULL == ppbvCurrentLocation
            ||
            sizeof(*pldNew) > (*ppbvCurrentLocation)->bv_len)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get current location for %s"),
                    (const TCHAR*)CDebugString(ldKey) ));
            TrkRaiseWin32Error( LdapMapErrorToWin32(pLdap->ld_errno) );
        }

        ppbvQuotaFlags = ldap_get_values_len(pLdap, pEntry,
                                             const_cast<TCHAR*>(s_oMTIndxGuid) );

        if (NULL != ppbvQuotaFlags
            &&
            sizeof(BYTE) <= (*ppbvQuotaFlags)->bv_len)
        {
            bQuotaFlags = *(BYTE*)(*ppbvQuotaFlags)->bv_val;
        }

        if( NULL != pfCounted )
        {
            if( bQuotaFlags & QFLAG_UNCOUNTED )
                *pfCounted = FALSE;
            else
                *pfCounted = TRUE;
        }
    

        if( bQuotaFlags & QFLAG_DELETED )
        {
            if( NULL != pfDeleted )
                *pfDeleted = TRUE;

            TrkLog(( TRKDBG_IDT, TEXT("IdtQuery: Entry marked deleted will be ignored (0x%x): %s"),
                     bQuotaFlags, 
                     (const TCHAR*)CDebugString(ldKey) ));
        }
        else
        {
            *pldNew   = *reinterpret_cast<CDomainRelativeObjId*>( (*ppbvCurrentLocation)->bv_val );

            if (NULL != ppbvBirthLocation)
                *pldBirth = *reinterpret_cast<CDomainRelativeObjId*>( (*ppbvBirthLocation)->bv_val );
            else
                *pldBirth = ldKey;

            fFound = TRUE;
        }
    }
    __finally
    {
        if (NULL != ppbvCurrentLocation)
            ldap_value_free_len(ppbvCurrentLocation);

        if (NULL != ppbvBirthLocation)
            ldap_value_free_len(ppbvBirthLocation);

        if (NULL != ppbvQuotaFlags)
            ldap_value_free_len(ppbvQuotaFlags);
    }

    return( fFound );
}



//+----------------------------------------------------------------------------
//
//  CIntraDomainTable::Touch
//
//  Update the refresh attribute for an entry in the move table.
//  Return TRUE if the entry exists and was touched, FALSE if it
//  doesn't exist, and raise an exception if there's an error.
//
//+----------------------------------------------------------------------------

// BUGBUG: if we ever move to per-user quotas,
// check ownership of entry being touched.

BOOL
CIntraDomainTable::Touch(
    const CDomainRelativeObjId &ldKey
    )
{
    BOOL            fReturn = FALSE;
    int             err;
    CLdapTimeValue  ltvRefresh( _pRefreshSequenceStorage->GetSequenceNumber());
    CLdapStringMod  lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_REPLACE );
    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);
    TCHAR **        pptszRefresh = NULL;
    LDAPMessage   * pEntry = NULL;
    LDAPMessage*    pRes = NULL;

    LDAPMod *       mods[2];
    CObjId          objZero;

    __try
    {
        //
        // if the birth id is zero, then it is invalid and not worth doing a refresh
        //

        if (ldKey.GetObjId() == objZero)
        {
            __leave;
        }

        //
        // Check to see if the object already has a recent sequence number.
        //

        TCHAR*          rgptszAttrs[2];
        rgptszAttrs[0] = const_cast<TCHAR*>(s_timeRefresh);
        rgptszAttrs[1] = NULL;

        err = ldap_search_s(Ldap(),
                            dnKey,
                            LDAP_SCOPE_BASE,
                            TEXT("(ObjectClass=*)"),
                            rgptszAttrs,
                            0,
                            &pRes);

        if (err == LDAP_SUCCESS)
        {
            // The search call worked, but did we find an object?
            if( 1 == ldap_count_entries(Ldap(), pRes) )
            {
                // The object already exists
                pEntry = ldap_first_entry(Ldap(), pRes);
                if( NULL != pEntry )
                {
                    // Get the refresh counter
                    pptszRefresh = ldap_get_values( Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
                    if( NULL != pptszRefresh )
                    {
                        SequenceNumber seqRefresh = 0;
                        if( 1 == _stscanf( *pptszRefresh, TEXT("%d"), &seqRefresh ))
                        {
                            // Is the refresh counter already set to a recent value?
                            // We'll consider it recent enough if it's within half of the
                            // refresh cycle (15 days)

                            // First, how long is the GC timer in seconds?
                            LONG lGCTimerInSeconds = _pTrkSvrConfiguration->GetGCPeriod()     // 30 days in seconds
                                                     / _pTrkSvrConfiguration->GetGCDivisor(); // => 1 day in seconds

                            // Next, how many ticks is half the period?
                            LONG lWindow =  _pTrkSvrConfiguration->GetGCPeriod()    // 30 days (in seconds)
                                            / 2                                     // => 15 days (in seconds)
                                            / lGCTimerInSeconds;                    // => 15

                            TrkLog(( TRKDBG_WARNING, TEXT("Window = %d"), lWindow ));

                            if( seqRefresh + lWindow
                                >= _pRefreshSequenceStorage->GetSequenceNumber()
                              )
                            {
                                TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                                         TEXT("Not touching %s with %d, seq %d already set"),
                                         (const TCHAR*)CDebugString(ldKey),
                                         _pRefreshSequenceStorage->GetSequenceNumber(),
                                         seqRefresh ));
                                __leave;
                            }
                        }
                    }
                }
            }
        }
        else if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s not found"),
                (const TCHAR*) CDebugString(ldKey) ));
            __leave;
        }


        //
        // Set the correct sequence number
        //

        mods[0] = &lsmRefresh._mod;
        mods[1] = NULL;

        err = ldap_modify_s(Ldap(), dnKey, mods);

        if (err == LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s touched"),
                (const TCHAR*) CDebugString(ldKey) ));
            fReturn = TRUE;
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s not found"),
                (const TCHAR*) CDebugString(ldKey) ));
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_ATTRIBUTE)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch: object %s attribute not found"),
                (const TCHAR*) CDebugString(ldKey) ));

            // deal with old server data
            CLdapStringMod lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_ADD );
            mods[0] = &lsmRefresh._mod;

            err = ldap_modify_s(Ldap(), dnKey, mods);
        }

        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s --> exceptional error"),
                (const TCHAR*) CDebugString(ldKey) ));
            __leave;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception during IDT::Touch (%08x)"), GetExceptionCode() ));
    }

    if (pptszRefresh != NULL)
        ldap_value_free(pptszRefresh);
    if(pRes != NULL)
        ldap_msgfree(pRes);

    return( fReturn );
}




ULONG
CIntraDomainTable::GarbageCollect( SequenceNumber seqCurrent, SequenceNumber seqOldestToKeep, const BOOL * pfAbort )
{
    CLdapIdtKeyDn       dn(GetBaseDn());
    TCHAR *             apszAttrs[3];
    GC_ENUM_CONTEXT     EnumContext;

    apszAttrs[0] = const_cast<TCHAR*>(s_Cn);
    apszAttrs[1] = const_cast<TCHAR*>(s_timeRefresh);
    apszAttrs[2] = 0;

    TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT, TEXT("GC-ing move table (%d/%d)"),
             seqCurrent, seqOldestToKeep ));

    memset( &EnumContext, 0, sizeof(EnumContext) );
    EnumContext.seqOldestToKeep = seqOldestToKeep;
    EnumContext.seqCurrent = seqCurrent;
    EnumContext.pfAbort = pfAbort;
    EnumContext.dwRepetitiveTaskDelay = _pTrkSvrConfiguration->GetRepetitiveTaskDelay();
    EnumContext.pqtable = _pqtable;

    if (!LdapEnumerate(
        Ldap(),
        dn,
        LDAP_SCOPE_ONELEVEL,
        TEXT("(objectClass=*)"),
        apszAttrs,
        GcEnumerateCallback,
        &EnumContext ))
    {
        TrkRaiseException(TRK_E_SERVICE_STOPPING);
    }

    TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
             TEXT("GC-ed %d entries from the move table"),
             EnumContext.cEntries ));

    _pqtable->OnMoveTableGcComplete( EnumContext.cEntries );


    return EnumContext.cEntries;
}

#if DBG
void
CIntraDomainTable::PurgeAll()
{
    int             err;
    TCHAR            *apszAttrs[2] = { TEXT("cn"), NULL };
    LDAPMessage *   pRes;
    TCHAR           tszObjectMoveTable[MAX_PATH+1];
    
    __try
    {
        _tcscpy(tszObjectMoveTable, s_ObjectMoveTableRDN);
        _tcscat(tszObjectMoveTable, GetBaseDn());

        err = ldap_search_s( Ldap(),
                             tszObjectMoveTable,
                             LDAP_SCOPE_ONELEVEL,
                             TEXT("(objectclass=*)"),
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        if (err == LDAP_SUCCESS)
        {
            // found it, lets get the attributes out
    
            int cEntries = ldap_count_entries(Ldap(), pRes);
            LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
            if (pEntry != NULL)
            {
                do
                {
                    TCHAR * ptszDn = ldap_get_dn(Ldap(), pEntry);

                    int errd = ldap_delete_s(Ldap(),ptszDn);

                    TrkLog((TRKDBG_ERROR, TEXT("Purged %s status=%d"), ptszDn, errd));
                    ldap_memfree(ptszDn);

                } while ( pEntry = ldap_next_entry(Ldap(), pEntry));
            }
        }
    }
    __finally
    {
        if (err == LDAP_SUCCESS)
        {
            ldap_msgfree(pRes);
        }
    }
}
#endif

void
CDomainRelativeObjId::FillLdapIdtKeyBuffer(TCHAR * const pchCN,
                                DWORD cch) const
{
    TCHAR *pchBuf = pchCN;
    _tcscpy(pchBuf, TEXT("CN="));
    pchBuf = pchBuf + 3;
    _volume.Stringize(pchBuf);
    _object.Stringize(pchBuf);
    TrkAssert(pchBuf <= pchCN+cch);
}

void
CDomainRelativeObjId::ReadLdapIdtKeyBuffer(const TCHAR * pchCN )
{
    const TCHAR *pchBuf;
    Init();
    if( 0 == _tcsncmp( pchCN, TEXT("CN="), 3 ))
    {
        pchBuf = &pchCN[3];
        if( !_volume.Unstringize(pchBuf)
            ||
            !_object.Unstringize(pchBuf) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't unstringize droid from %s"), pchCN ));
            Init();
        }
    }
}

void
CDomainRelativeObjId::InitFromLdapBuffer(char * pVolumeId, int cbVolumeId,
                              char * pObjId, int cbObjId)
{
    DWORD iBuf = 0;

    if (cbVolumeId != sizeof(_volume) ||
        cbObjId != sizeof(_object))
    {
        TrkRaiseException(TRK_E_CORRUPT_IDT);
    }

    memcpy(&_volume, pVolumeId, sizeof(_volume));
    memcpy(&_object, pObjId, sizeof(_object));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\res.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

#ifndef NT_BUILD
#include <afxres.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\quota.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       quota.cxx
//
//  Contents:   quota table
//
//  Classes:
//
//  Functions:
//
//  Notes:      This table is hidden in the volume table
//
//  History:    18-Nov-97  WeiruC Created.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
#include <commctrl.h>
#include <time.h>

CQuotaTable::CQuotaTable(CDbConnection& dbc) :
    _dbc(dbc),
#if DBG
    _cLocks(0),
#endif
    _mcid(MCID_LOCAL),
    _cftCacheLastUpdated(0),
    _cftDesignatedDc(0),
    _pvoltab(NULL)
{
    _fIsDesignatedDc = FALSE;
    _fInitializeCalled = FALSE;
    _fStopping = FALSE;
    _dwMoveLimit = 0;

    _lCachedMoveTableCount = _lCachedVolumeTableCount = 0;

}

CQuotaTable::~CQuotaTable()
{
    UnInitialize();
}

void
CQuotaTable::Initialize(CVolumeTable      *pvoltab,
                        CIntraDomainTable *pidt,
                        CTrkSvrSvc        *psvrsvc,
                        CTrkSvrConfiguration *pcfgsvr )
{
    CMachineId      mcid;
    HRESULT         hr;

    _cs.Initialize();
#if DBG
    _cLocks = 0;
#endif

    _fInitializeCalled = TRUE;

    _pvoltab = pvoltab;
    _pcfgsvr = pcfgsvr;
    _pidt = pidt;
    _psvrsvc = psvrsvc;

    _timer.Initialize(this,
                      TEXT("NextDcSyncTime"),   // Name (this is a persistent timer)
                      QUOTA_TIMER,                        // Context ID
                      _pcfgsvr->GetDcUpdateCounterPeriod(),  // Period
                      CNewTimer::NO_RETRY,
                      0, 0, 0 );                // Ignored for non-retrying timers
    _timer.SetRecurring();
    TrkLog(( TRKDBG_VOLUME, TEXT("DC sync timer: %s"),
             (const TCHAR*) CDebugString(_timer) ));


    // The Reset* routines assume that an entry already exists for
    // this DC. If the operation fails because the entry doesn't exist, it
    // will add the entry. We ignore any error because if we can't add
    // the entry it only means that we are not participating in the race
    // for the designated DC.
}

void
CQuotaTable::UnInitialize()
{
    if(_fInitializeCalled)
    {
        _timer.UnInitialize();
        _lCachedMoveTableCount = 0;
        _lCachedVolumeTableCount = 0;
        _cftCacheLastUpdated = CFILETIME(0);
        _cs.UnInitialize();
        _fInitializeCalled = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CQuotaTable::Timer
//
//  This method is called when _timer fires.  If we're the designated
//  DC, we'll go through the move table and count the uncounted entries, 
//  delete the deleted entries, and shorten any moves chains.
//
//+----------------------------------------------------------------------------

PTimerCallback::TimerContinuation
CQuotaTable::Timer(ULONG ulTimer)
{
    DWORD       dwTrueCount = 0;

    Lock();

    __try
    {
        TrkLog((TRKDBG_QUOTA, TEXT("DC synchronization time")));
        g_ptrksvr->RaiseIfStopped();

        TrkAssert( QUOTA_TIMER == ulTimer );

        if( QUOTA_TIMER == ulTimer )
        {
            if( IsDesignatedDc() )
            {
                GetTrueCount( &dwTrueCount, BACKGROUND );
                TrkLog((TRKDBG_QUOTA, TEXT("Updated counter")));
                _psvrsvc->_OperationLog.Add( COperationLog::TRKSVR_QUOTA, S_OK, CMachineId(MCID_INVALID), dwTrueCount );
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
        // This timer fires often enough that we'll just
        // wait until it fires again.
        TrkLog(( TRKDBG_WARNING,
                 TEXT("Ignoring exception in CQuotaTable::Timer (%08x)"),
                 GetExceptionCode() ));
        _psvrsvc->_OperationLog.Add( COperationLog::TRKSVR_QUOTA, GetExceptionCode() );
    }
    Unlock();

    TrkAssert( _timer.IsRecurring() );
    return( CONTINUE_TIMER );
}

BOOL
CQuotaTable::IsMoveQuotaExceeded()
{
    BOOL    fExceeded = TRUE;

    Lock();

    __try
    {
        ValidateCache();

        // Compare the cached counter with the limit.  The cached value should
        // never be negative.  But if for some reason it is, don't get confused by it
        // (i.e. bottom it out at zero).  The cached value will get automatically
        // corrected when the cache gets refreshed.

        if( (DWORD) max(0,_lCachedMoveTableCount) < _dwMoveLimit )
        {
            fExceeded = FALSE;
        }
        else
        {
            // Try to force the cache to be updated
            ValidateCache( TRUE );
            if( (DWORD) max(0,_lCachedMoveTableCount) < _dwMoveLimit)
            {
                fExceeded = FALSE;
            }
        }

        if(fExceeded)
        {
            TrkLog((TRKDBG_QUOTA, TEXT("*** Move table quota exceeded (%li/%lu)"), _lCachedMoveTableCount, _dwMoveLimit ));
        }
        else
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Move quota not exceeded (%li/%lu)"), _lCachedMoveTableCount, _dwMoveLimit ));
        }
    }
    __finally
    {
        Unlock();
    }

    return fExceeded;
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::IsVolumeQuotaExceeded
//
//  See if this machine is at or over its quota (it can go over in a replicated
//  environment).  The total number of
//  volumes it has is the count of DS entries for the machine, plus
//  cUncountedVolumes.  cUncountedVolumes is non-zero when a machine
//  sends up a request to create multiple volumes, and increments
//  as the service iterates through the requests.
//
//+----------------------------------------------------------------------------

BOOL
CQuotaTable::IsVolumeQuotaExceeded( const CMachineId& mcid, ULONG cUncountedVolumes )
{
    Lock();

    __try
    {
        // How many entries does this machine have in the DS?
        ULONG cVolumes = _pvoltab->CountVolumes(mcid);

        // Is it at/over quota?
        if( cVolumes + cUncountedVolumes >= _pcfgsvr->GetVolumeLimit() )
        {
            TrkLog((TRKDBG_QUOTA, TEXT("VOLUME QUOTA EXCEEDED for %s (%d+%d)"),
                    (const TCHAR*) CDebugString(mcid), 
                    cVolumes, cUncountedVolumes ));
            return TRUE;
        }
        else
            TrkLog(( TRKDBG_QUOTA, TEXT("Volume quota not exceeded for %s (%d+%d, %d)"),
                     (const TCHAR*) CDebugString(mcid), 
                     cVolumes, cUncountedVolumes, _pcfgsvr->GetVolumeLimit() ));
    }
    __finally
    {
        Unlock();
    }

    return FALSE;
}




//+----------------------------------------------------------------------------
//
//  ReadAttribute
//
//  Given an LDAP pointer, a DN, and an attribute name, read the attribute
//  for the entry with that DN.
//
//+----------------------------------------------------------------------------

int
ReadAttribute( LDAP* pldap, const TCHAR *ptszDN, const TCHAR *ptszAttributeName,
               TCHAR ***ppptszAttributeValue )
{
    int           ldapRV = 0;
    const TCHAR   *rgptszAttrs[] = { ptszAttributeName, NULL };
    int           cEntries = 0;
    LDAPMessage   *pRes = NULL;
    LDAPMessage   *pEntry = NULL;

    __try
    {
        ldapRV = ldap_search_s(pldap,
                               const_cast<TCHAR*>(ptszDN),
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               const_cast<TCHAR**>(rgptszAttrs),
                               0,
                               &pRes);
        if( LDAP_SUCCESS != ldapRV )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find %s (%lu)"), ptszDN, ldapRV ));
            __leave;
        }

        cEntries = ldap_count_entries(pldap, pRes);
        if( cEntries < 1 )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("No entries returned for %s in %s"), ptszAttributeName, ptszDN ));
            ldapRV = LDAP_NO_SUCH_OBJECT;
            __leave;
        }

        pEntry = ldap_first_entry(pldap, pRes);
        if(NULL == pEntry)
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Entries couldn't be read from result for %s"), ptszDN ));
            ldapRV = LDAP_NO_SUCH_OBJECT;
            __leave;
        }

        *ppptszAttributeValue = ldap_get_values(pldap, pEntry, const_cast<TCHAR*>(ptszAttributeName) );
        if( NULL == *ppptszAttributeValue )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find %s in %s"), ptszAttributeName, ptszDN ));
            ldapRV = LDAP_NO_SUCH_OBJECT;
            __leave;
        }
    }
    __finally
    {
        if(NULL != pRes)
        {
            ldap_msgfree(pRes);
        }
    }

    return( ldapRV );

}


//+----------------------------------------------------------------------------
//
//  CQuotaTable::IsDesignatedDc
//
//  Determine if this machine is the designated DC.  (The designated DC is
//  responsible for all modifications to link tracking data in the DS that
//  requires a single master).  The "RID Master" DC is used as the designated
//  DC.
//
//+----------------------------------------------------------------------------

BOOL
CQuotaTable::IsDesignatedDc( BOOL fRaiseOnError )
{
    BOOL          fSuccess = FALSE;
    BOOL          fDesignatedDc = FALSE;
    HRESULT       hr = E_FAIL;
    int           ldapRV = 0;
    int           cEntries = 0;
    TCHAR         **pptszRidManagerReference = NULL;
    TCHAR         **pptszRoleOwner = NULL;
    const TCHAR   *rgtszAttrs[] = { s_rIDManagerReference, NULL };
    TCHAR         *ptszDesignatedDC = NULL, *ptszAfterDesignatedDC = NULL;
    CMachineId    mcidDesignated, mcidLocal(MCID_LOCAL);
    CFILETIME     cftNow;
    LONGLONG      llDelta;

    // How old (in seconds) is the _fIsDesignatedDc value?

    llDelta = (LONGLONG) cftNow - (LONGLONG) _cftDesignatedDc;
    llDelta /= 10000000;
    if( llDelta < _pcfgsvr->GetDesignatedDcCacheTTL() )
    {
        // The cached value is young enough.
        //TrkLog(( TRKDBG_QUOTA, TEXT("Cache: %s designated DC"),
        //         _fIsDesignatedDc ? TEXT("is") : TEXT("isn't") ));
        return( _fIsDesignatedDc );
    }
    // The cached value is too old.  Recalculate.

    __try
    {
        // Read the "rIDManagerReference" from the root DC=<domain> object.

        ldapRV = ReadAttribute(Ldap(), GetBaseDn(), s_rIDManagerReference, &pptszRidManagerReference );

        if( LDAP_SUCCESS != ldapRV )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(ldapRV) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't get RID manager reference (%lu)"), ldapRV ));
            __leave;
        }
        TrkLog(( TRKDBG_QUOTA, TEXT("RID manager reference: %s"), *pptszRidManagerReference ));

        // The value of the rIDManagerReference is a DN.  Read the "fSMORoleOwner" attribute
        // from that object.

        ldapRV = ReadAttribute( Ldap(), *pptszRidManagerReference, s_fSMORoleOwner, &pptszRoleOwner );
        if( LDAP_SUCCESS != ldapRV )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(ldapRV) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't get RID role owner (%lu)"), ldapRV ));
            __leave;
        }
        TrkLog(( TRKDBG_QUOTA, TEXT("Role owner: %s"), *pptszRoleOwner ));


        // The role owner is of the form
        // "CN=NTDS Settings,CN=mikehill4,CN=Servers,CN=Default-FirstSite-Name,CN=Sites,CN=Configuration,DC=trkmikehill,DC=nttest,DC=microsoft,DC=com"
        // Pull out the DC's machine name by getting the second "CN=".

        ptszDesignatedDC = _tcsstr( *pptszRoleOwner, TEXT("CN=") );
        if( NULL == ptszDesignatedDC )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find first component of FSMO role owner") ));
            __leave;
        }

        ptszDesignatedDC = _tcsstr( &ptszDesignatedDC[1], TEXT("CN=") );
        if( NULL == ptszDesignatedDC )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find second component of FSMO role owner") ));
            __leave;
        }

        ptszDesignatedDC += 3;
        ptszAfterDesignatedDC = _tcsstr( ptszDesignatedDC, TEXT(",CN=") );
        if( NULL == ptszAfterDesignatedDC )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find third component of FSMO role owner") ));
            __leave;
        }
        *ptszAfterDesignatedDC = TEXT('\0');

        // Are we the same (and therefore the designated) DC?

        mcidDesignated = CMachineId(ptszDesignatedDC );
        if( mcidDesignated == mcidLocal )
            fDesignatedDc = TRUE;

        TrkLog(( TRKDBG_QUOTA, TEXT("Designated DC is %s %s"), ptszDesignatedDC,
                 fDesignatedDc ? TEXT("(this DC)") : TEXT("") ));

        _fIsDesignatedDc = fDesignatedDc;
        _cftDesignatedDc = cftNow;

        fSuccess = TRUE;
    }
    __finally
    {
        if( NULL != pptszRidManagerReference )
            ldap_value_free( pptszRidManagerReference );

        if( NULL != pptszRoleOwner )
            ldap_value_free( pptszRoleOwner );
    }

    if( !fSuccess && fRaiseOnError )
        TrkRaiseException( hr );

    return( fDesignatedDc );
}

// Returns TRUE if successful, FALSE if entry doesn't exist, raise exception
// otherwise.
BOOL
CQuotaTable::ReadCounter(DWORD* pdwCounter)
{
    BOOL                    fSuccess = FALSE;
    struct berval**         ppbvCounter = NULL;
    TCHAR*                  rgtszAttrs[2];
    LDAPMessage*            pRes = NULL;
    int                     ldapRV;
    int                     cEntries = 0;
    LDAPMessage*            pEntry = NULL;
    CLdapQuotaCounterKeyDn  dnKeyCounter(GetBaseDn());

    __try
    {
        *pdwCounter = 0;
        rgtszAttrs[0] = const_cast<TCHAR*>(s_volumeSecret);
        rgtszAttrs[1] = NULL;
        ldapRV = ldap_search_s(Ldap(),
                               dnKeyCounter,
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               rgtszAttrs,
                               0,
                               &pRes);
        if( LDAP_NO_SUCH_OBJECT == ldapRV )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Move table counter doesn't exist") ));
            __leave;
        }
        else if( LDAP_SUCCESS != ldapRV )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't read move table counter (%d)"), ldapRV ));
            __leave;
        }

        cEntries = ldap_count_entries(Ldap(), pRes);
        if( cEntries != 1 )
        {
            // This should never happen, the counter has an explicit name.
            // We'll assume that when the designated DC does a WriteCounter, this
            // will be fixed.
            TrkLog(( TRKDBG_ERROR, TEXT("Too many move table counters!") ));
            __leave;
        }

        pEntry = ldap_first_entry(Ldap(), pRes);
        if(NULL == pEntry)
        {
            // This should also never happen, we already know the entry count for
            // this search result is 1.  Again assume that when the designated DC does
            // a WriteCounter, this will be fixed.
            TrkLog(( TRKDBG_ERROR, TEXT("Entries couldn't be read from result") ));
            __leave;
        }

        ppbvCounter = ldap_get_values_len(Ldap(), pEntry, const_cast<TCHAR*>(s_volumeSecret) );
        if (ppbvCounter == NULL)
        {
            // The designated DC will fix this in WriteCounter.
            TrkLog(( TRKDBG_ERROR, TEXT("Move table counter is corrupt, missing %s attribute"),
                     s_volumeSecret ));
            __leave;
        }

        if ((*ppbvCounter)->bv_len < sizeof(DWORD))
        {
            // The designated DC will fix this in WriteCounter
            TrkLog(( TRKDBG_ERROR, TEXT("Move table counter attribute %s has wrong type (%d)"),
                     s_volumeSecret, (*ppbvCounter)->bv_len ));
            __leave;
        }

        memcpy( (PCHAR)pdwCounter, (*ppbvCounter)->bv_val, sizeof(DWORD) );
        fSuccess = TRUE;
    }
    __finally
    {
        if(NULL != pRes)
        {
            ldap_msgfree(pRes);
        }
        if (ppbvCounter != NULL)
        {
            ldap_value_free_len(ppbvCounter);
        }
    }

    return fSuccess;
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::GetTrueCount
//
//  Update our cached count of the move table entries.  If we're the designated
//  DC, this will also clean up the move table: count uncounted entries, delete
//  deleted entries, and shorten any move chains.
//
//  This routine can be called to run in the background or foreground.  In the
//  background it does periodic sleeps so that we don't use up the CPU.
//
//+----------------------------------------------------------------------------

void
CQuotaTable::GetTrueCount( DWORD* pdwTrueCount,
                           EBackgroundForegroundTask eBackgroundForegroundTask )
{
    CLdapIdtKeyDn       dnKey(GetBaseDn());
    int                 ldapRV;
    TCHAR*              rgptszAttrs[3];
    TCHAR               ldapSearchFilter[256];
    DWORD               dwCounter = 0;
    BOOL                fDoWriteCounter = FALSE;
    BOOL                fNoExistingCounter = FALSE;
    TRUE_COUNT_ENUM_CONTEXT Context;

    __try
    {
        // Read the current counter.

        if( !ReadCounter( &dwCounter ) )
        {
            // There is no counter.  We'll enumerate everything.
            TrkLog(( TRKDBG_QUOTA, TEXT("Getting move table count") ));

            _tcscpy( ldapSearchFilter, TEXT("(ObjectClass=*)") );
            fDoWriteCounter = TRUE;
            Context.fCountAll = TRUE;
            fNoExistingCounter = TRUE;
        }
        else
        {
            // Only enumerate the uncounted and/or deleted entries.
            TrkLog(( TRKDBG_QUOTA, TEXT("Getting delta move table count") ));

            _tcscpy(ldapSearchFilter, TEXT("("));
            _tcscat(ldapSearchFilter, s_oMTIndxGuid);
            _tcscat(ldapSearchFilter, TEXT("=*"));
            _tcscat(ldapSearchFilter, TEXT(")"));
            Context.fCountAll = FALSE;
        }

        rgptszAttrs[0] = const_cast<TCHAR*>(s_currentLocation);
        rgptszAttrs[1] = const_cast<TCHAR*>(s_birthLocation);
        rgptszAttrs[2] = NULL;


        Context.cDelta = 0;
        Context.dwRepetitiveTaskDelay = (BACKGROUND == eBackgroundForegroundTask)
                                         ? _pcfgsvr->GetRepetitiveTaskDelay()
                                         : 0;
        Context.dwPass = Context.FIRST_PASS;

        // Enumerate the move table, subject to the search filter determined
        // above.

        if( !LdapEnumerate( Ldap(),
                            dnKey,
                            LDAP_SCOPE_ONELEVEL,
                            ldapSearchFilter,
                            rgptszAttrs,
                            MoveTableEnumCallback,
                            &Context,
                            this) )
        {
            TrkRaiseException(TRK_E_SERVICE_STOPPING);
        }

        // If we're the designated DC, we need to do a second pass.
        // The first pass may have done some string shortening,
        // and in the process marked some entries for delete.  We need to
        // go through now and remove those entries.

        if( IsDesignatedDc() )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Getting delta move table count (pass 2)") ));
            Context.dwPass = Context.SECOND_PASS;

            // We only need to count the delta this time

            _tcscpy(ldapSearchFilter, TEXT("("));
            _tcscat(ldapSearchFilter, s_oMTIndxGuid);
            _tcscat(ldapSearchFilter, TEXT("=*"));
            _tcscat(ldapSearchFilter, TEXT(")"));
            Context.fCountAll = FALSE;

            if( !LdapEnumerate( Ldap(),
                                dnKey,
                                LDAP_SCOPE_ONELEVEL,
                                ldapSearchFilter,
                                rgptszAttrs,
                                MoveTableEnumCallback,
                                &Context,
                                this) )
            {
                TrkRaiseException(TRK_E_SERVICE_STOPPING);
            }
        }

        TrkLog((TRKDBG_QUOTA, TEXT("Uncounted entries ---- %d"), Context.cDelta));
        TrkLog((TRKDBG_QUOTA, TEXT("Counter ---- %d"), dwCounter));
    }
    __finally
    {
        if( Context.cDelta != 0 )
            fDoWriteCounter = TRUE;

        *pdwTrueCount = max( 0, (LONG)dwCounter + Context.cDelta );

        // If we're the designated DC, we may need to write the counter.
        // But only do so if this is a normal termination, or if there
        // wasn't already a counter.  This covers the three cases:
        //
        // 1) The counter didn't already exist, so we were enumerating everything.
        //    a) Normal termination, so we should update the counter
        //       with the newly calculated value.
        //    b) Abnormal termination, so we shouldn't update the counter.
        //       That way we'll know to do the count again later.
        //
        // 2) The counter already existed, so we were counting the uncounted
        //    entries.  In this case, the entries were being updated to
        //    be counted as we went through the enumeration.  So whether
        //    or not we had a normal termination, we need to updated the
        //    counter with what we did so far.
        //
        // The only reason we expect an exception is in the case of a
        // service stop.

        if( IsDesignatedDc()
            &&
            fDoWriteCounter
            &&
            ( !AbnormalTermination() || !fNoExistingCounter ) )
        {
            WriteCounter(*pdwTrueCount);
        }

        TrkLog((TRKDBG_QUOTA, TEXT("True count ---- %d"), *pdwTrueCount));
    }
}


//+----------------------------------------------------------------------------
//
//  CQuotaTable::OnMoveTableGcComplete
//
//  This method is called after a GC of the move table, telling us how
//  many entries were deleted.  We use this to update the move counter
//  (if it still exists).
//
//+----------------------------------------------------------------------------

void
CQuotaTable::OnMoveTableGcComplete( ULONG cEntriesDeleted )
{
    DWORD dwCounter = 0;

    if( 0 == cEntriesDeleted )
        return;

    if( ReadCounter( &dwCounter ) )
    {
        TrkLog(( TRKDBG_QUOTA, TEXT("Old move counter was %d"), dwCounter ));

        if( dwCounter >= cEntriesDeleted )
            dwCounter -= cEntriesDeleted;
        else
            dwCounter = 0;

        WriteCounter(dwCounter);

        TrkLog(( TRKDBG_QUOTA, TEXT("New move counter is %d"), dwCounter ));
    }

}


void
CQuotaTable::WriteCounter(DWORD dwCounter)
{
    LDAPMod*    mods[3];
    int         ldapRV;
    CLdapQuotaCounterKeyDn  dnKeyCounter(GetBaseDn());

    CLdapBinaryMod  lbmCounter(s_volumeSecret, (PCHAR)&dwCounter, sizeof(DWORD), LDAP_MOD_REPLACE);
    mods[0] = &lbmCounter._mod;
    mods[1] = NULL;
    ldapRV = ldap_modify_s(Ldap(), dnKeyCounter, mods);
    if( LDAP_SUCCESS != ldapRV )
    {
        if( LDAP_NO_SUCH_OBJECT != ldapRV )
        {
            // There's some kind of problem with the existing counter.
            // Delete and re-create it.
            ldap_delete_s( Ldap(), dnKeyCounter );
        }

        CLdapStringMod  lsmClass(s_objectClass, s_linkTrackVolEntry, LDAP_MOD_ADD);
        CLdapBinaryMod  lbmCounter(s_volumeSecret, (PCHAR)&dwCounter, sizeof(DWORD), LDAP_MOD_ADD);
        mods[0] = &lsmClass._mod;
        mods[1] = &lbmCounter._mod;
        mods[2] = NULL;

        ldapRV = ldap_add_s(Ldap(), dnKeyCounter, mods);
        TrkLog(( TRKDBG_QUOTA, TEXT("Created counter %d, ldap returned %d"), dwCounter, ldapRV ));
    }
    else
        TrkLog((TRKDBG_QUOTA, TEXT("Wrote counter %d, ldap returned %d"), dwCounter, ldapRV));
}

HRESULT
CQuotaTable::DeleteCounter()
{
    HRESULT hr = S_OK;
    int LdapError = 0;
    CLdapQuotaCounterKeyDn  dnKeyCounter(GetBaseDn());

    LdapError = ldap_delete_s(Ldap(), dnKeyCounter);
    if( LDAP_SUCCESS == LdapError )
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LdapError) );

    if( FAILED(hr) )
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't delete move-table counter (%08x)"), hr ));
    else
        TrkLog(( TRKDBG_QUOTA, TEXT("Deleted move-table counter") ));

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::ValidateCache
//
//  Validate the cached move and volume counts.  They are valid if they exist
//  and are newer than the max time-to-live.  If they aren't valid, they are
//  re-calculated.  They are also recalculated if the caller sets the
//  fForceHint parameter, and the cache is at least of minimum age.
//
//+----------------------------------------------------------------------------

void
CQuotaTable::ValidateCache( BOOL fForceHint )
{
    // How old is the cache in seconds?
    DWORD dwDelta = ( (LONGLONG)CFILETIME() - (LONGLONG)_cftCacheLastUpdated ) / 10000000;

    // The cache should be updated if any of the following are true

    if( 0 == _cftCacheLastUpdated                   // We have no cached values
        ||
        dwDelta > _pcfgsvr->GetCacheMaxTimeToLive() // The cached values are too old
        ||
                                                    // The cached values are old enough, and the
                                                    // the caller wants us to be aggressive.
        fForceHint && (dwDelta > _pcfgsvr->GetCacheMinTimeToLive()) )
    {
        // Yes, we need to update the cached values.

        CLdapVolumeKeyDn    dnKey(GetBaseDn());
        TCHAR*              rgptszAttrs[2];
        DWORD               cVolumeTableEntries = 0;

        TrkLog(( TRKDBG_QUOTA, TEXT("Updating quota caches (%s)"),
                 fForceHint ? TEXT("forced") : TEXT("not forced") ));

        // Get the true count of move table entries.
        GetTrueCount( (DWORD*) &_lCachedMoveTableCount, FOREGROUND );
        TrkAssert( _lCachedMoveTableCount >= 0 );

        // Get the count of volume table entries

        rgptszAttrs[0] = const_cast<TCHAR*>(s_Cn);
        rgptszAttrs[1] = NULL;

        if( !LdapEnumerate( Ldap(),
                            dnKey,
                            LDAP_SCOPE_ONELEVEL,
                            TEXT("(&(ObjectClass=*)(!(cn=QT*)))"),
                            rgptszAttrs,
                            VolumeTableEnumCallback,
                            &cVolumeTableEntries,
                            this) )
        {
            TrkRaiseException( TRK_E_SERVICE_STOPPING );
        }
        _lCachedVolumeTableCount = (LONG) cVolumeTableEntries;

        // Calculate the move table limit
        _dwMoveLimit = CalculateMoveLimit();


        // Show that the cache is up-to-date
        _cftCacheLastUpdated.SetToUTC();
    }

    TrkLog(( TRKDBG_QUOTA, TEXT("Cache: MoveCount=%d, MoveLimit=%d, VolCount=%d"),
             _lCachedMoveTableCount, _dwMoveLimit, _lCachedVolumeTableCount ));

}


DWORD
CQuotaTable::CalculateMoveLimit()   // Doesn't raise
{
    DWORD dwMoveLimit = 0;
    LONG lVolumeCount = max( 0, _lCachedVolumeTableCount );

    if( lVolumeCount <= _pcfgsvr->GetMoveLimitTransition() )
        dwMoveLimit = lVolumeCount * _pcfgsvr->GetMoveLimitPerVolumeLower();
    else
    {
        dwMoveLimit = _pcfgsvr->GetMoveLimitTransition()
                      *
                      _pcfgsvr->GetMoveLimitPerVolumeLower();

        dwMoveLimit += ( lVolumeCount - _pcfgsvr->GetMoveLimitTransition() )
                       *
                       _pcfgsvr->GetMoveLimitPerVolumeUpper();
    }


    return( dwMoveLimit );
}


HRESULT
CQuotaTable::ReadFlags(LDAP* pLdap, TCHAR* dnKey, BYTE* bFlags)
{
    struct berval** ppbvFlags = NULL;
    TCHAR*          rgptszAttrs[2];
    LDAPMessage*    pRes = NULL;
    int             ldapRV;
    int             cEntries;
    LDAPMessage*    pEntry = NULL;
    HRESULT         hr = S_OK;

    __try
    {
        *bFlags = 0x0;
        rgptszAttrs[0] = const_cast<TCHAR*>(s_oMTIndxGuid);
        rgptszAttrs[1] = NULL;
        ldapRV = ldap_search_s(pLdap,
                               dnKey,
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               rgptszAttrs,
                               0,
                               &pRes);
        hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV));
        if(ldapRV != LDAP_SUCCESS)
            __leave;

        cEntries = ldap_count_entries(pLdap, pRes);
        if(cEntries != 1)
        {
            // This shouldn't happen.  The caller asked for flags on an entry
            // which doesn't exist.
            TrkLog(( TRKDBG_ERROR, TEXT("ReadFlags, entry doesn't exist: %s"), dnKey ));
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT));
            __leave;
        }

        pEntry = ldap_first_entry(pLdap, pRes);
        if(NULL == pEntry)
        {
            // This should never happen.  We already know that there's an entry.
            TrkLog(( TRKDBG_ERROR, TEXT("ReadFlags, couldn't get first entry on %s"), dnKey ));
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT));
            __leave;
        }

        ppbvFlags = ldap_get_values_len(pLdap, pEntry, const_cast<TCHAR*>(s_oMTIndxGuid) );
        if(NULL == ppbvFlags)
        {
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_ATTRIBUTE));
            __leave;
        }

        if( (*ppbvFlags)->bv_len < sizeof(BYTE)
            ||
            ((*ppbvFlags)->bv_val == NULL) )
        {
            // The best we can do is pretend the attribute doesn't exist.
            TrkLog(( TRKDBG_ERROR, TEXT("ReadFlags, attribute is wrong type or missing (%d/%p)"),
                     (*ppbvFlags)->bv_len, (*ppbvFlags)->bv_val ));
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_ATTRIBUTE));
            __leave;
        }

        *bFlags = *(BYTE*)(*ppbvFlags)->bv_val;
        hr = S_OK;
    }
    __finally
    {
        if(pRes != NULL)
        {
            ldap_msgfree(pRes);
        }
        if(ppbvFlags != NULL)
        {
            ldap_value_free_len(ppbvFlags);
        }
    }


    return hr;
}

void
CQuotaTable::DeleteFlags(LDAP* pLdap, TCHAR* dnKey)
{
    BYTE                bFlags = 0x0;
    int                 err;

    Lock();

    __try
    {
        CLdapBinaryMod      lbm(s_oMTIndxGuid, NULL, 0, LDAP_MOD_DELETE );//reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), LDAP_MOD_DELETE);
        LDAPMod*            mods[2];

        mods[0] = &lbm._mod;
        mods[1] = NULL;

        err = ldap_modify_s(pLdap, dnKey, mods);
        TrkLog((TRKDBG_QUOTA, TEXT("Deleted flag %x on entry %s, ldap returned %d"), bFlags, dnKey, err));
    }
    __finally
    {
        Unlock();
    }
}


// TRUE => Found, FALSE => Not found, Raise otherwise
BOOL
CQuotaTable::UpdateFlags(LDAP* pLdap, TCHAR* dnKey, BYTE bFlags)
{
    BOOL            fFound = FALSE;
    BYTE            bOrigFlags;
    HRESULT         hr;
    LDAPMod*        mods[2];
    int     err;

    TrkAssert(!(bFlags & QFLAG_UNCOUNTED && bFlags & QFLAG_DELETED));

    Lock();

    __try
    {
        hr = ReadFlags(pLdap, dnKey, &bOrigFlags);
        if(hr == (HRESULT) HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_ATTRIBUTE)))
        {
            CLdapBinaryMod  lbm(s_oMTIndxGuid, reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), LDAP_MOD_ADD);

            mods[0] = &lbm._mod;
            mods[1] = NULL;

            err = ldap_modify_s(pLdap, dnKey, mods);
            TrkLog((TRKDBG_QUOTA, TEXT("Added flag %01x on entry %s, ldap returned %d"), bFlags, dnKey, err));
        }
        else if(hr == S_OK)
        {
            if(bOrigFlags == QFLAG_UNCOUNTED && bFlags == QFLAG_DELETED)
            {
                bOrigFlags = bOrigFlags | bFlags;
                CLdapBinaryMod  lbm(s_oMTIndxGuid, reinterpret_cast<PCCH>(&bOrigFlags), sizeof(BYTE), LDAP_MOD_REPLACE);
                mods[0] = &lbm._mod;
                mods[1] = NULL;
                err = ldap_modify_s(pLdap, dnKey, mods);
                TrkLog((TRKDBG_QUOTA, TEXT("Updated flag to %01x on entry %s, ldap returned %d"), bOrigFlags, dnKey, err));
            }
            else if(bOrigFlags == QFLAG_DELETED && bFlags == QFLAG_UNCOUNTED)
            {
                DeleteFlags(pLdap, dnKey);
            }
        }

        else
        {
            __leave;
        }

        fFound = TRUE;
    }
    __finally
    {
        Unlock();
    }


    return( fFound );
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::DeleteOrphanedEntries
//
//  This routine is given a list of move table entries.  The birth entry has
//  been updated by the caller to point to the final entry.  As a result, all
//  the other entries are orphaned and must be deleted.
//
//+----------------------------------------------------------------------------

BOOL
CQuotaTable::DeleteOrphanedEntries( const CDomainRelativeObjId rgdroidList[], ULONG cSegments,
                                    const CDomainRelativeObjId &droidBirth,
                                    const CDomainRelativeObjId &droidCurrent )
{
    BOOL fCurrentNeedsToBeDeleted = FALSE;

    for( int j=0; j < cSegments; j++ )
    {
        // Don't do anything if this is the birth entry

        if( rgdroidList[j] != droidBirth )
        {
            // If this is the current entry we don't delete it, but tell the
            // caller about it.
            if( rgdroidList[j] == droidCurrent )
            {
                fCurrentNeedsToBeDeleted = TRUE;
            }

            // Otherwise, we delete it directly
            else if( _pidt->Delete( rgdroidList[j] ) )
            {
                TrkLog((TRKDBG_QUOTA,
                        TEXT("Orphaned segment deleted %s"),
                        static_cast<const TCHAR*>(CAbbreviatedIDString(rgdroidList[j])) ));
            }
            else
            {
                TrkLog((TRKDBG_QUOTA|TRKDBG_WARNING,
                        TEXT("Orphaned segment failed to delete %s"),
                        static_cast<const TCHAR*>(CAbbreviatedIDString(rgdroidList[j])) ));
            }
        }
    }

    return( fCurrentNeedsToBeDeleted );
}




//+----------------------------------------------------------------------------
//
//  CQuotaTable::ShortenString
//
//  Given an entry in the move table, see if it is part of a string that
//  needs to be shortened, and if so do the shortening.
//
//+----------------------------------------------------------------------------


void
CQuotaTable::ShortenString( LDAP* pLdap, LDAPMessage* pMessage, BYTE *pbFlags,
                            const CDomainRelativeObjId &droidCurrent )
{

    CDomainRelativeObjId droidBirth;
    CDomainRelativeObjId droidScan;
    CDomainRelativeObjId droidNext;
    CDomainRelativeObjId rgdroidList[MAX_SHORTENABLE_SEGMENTS];
    int                  cSegments = 0;
    TCHAR                *ptszCurrentCN = NULL;

    __try
    {
        // Attempt to read the entry and get its birth ID.

        if( _pidt->Query( pLdap, pMessage, droidCurrent, &droidNext, &droidBirth ) )
        {
            // We have a successful read.

            BOOL fStringDeleted = FALSE;

            // Scan forward from that birth to see if we can find multiple entries.

            droidScan = droidBirth;
            _psvrsvc->Scan( NULL, NULL, droidBirth,
                            rgdroidList, ELEMENTS(rgdroidList), &cSegments,
                            &droidScan, &fStringDeleted );

            // If this is a multi-segment string, reduce it to a single segment.

            if( cSegments > 1 )
            {
                // Was the last segment of the string deleted?
                if( fStringDeleted )
                {
                    // Yes, that means that the entired string has been deleted.
                    TrkLog(( TRKDBG_QUOTA, TEXT("Deleting string starting at %s"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)) ));

                    if( droidCurrent == droidBirth )
                        *pbFlags |= QFLAG_DELETED;
                    else
                        _pidt->Delete( droidBirth );
                }

                // Otherwise, map from the birth to the last droid.
                else if( !_pidt->Modify( droidBirth, droidScan, droidBirth ))
                {
                    TrkLog(( TRKDBG_QUOTA|TRKDBG_WARNING, TEXT("Couldn't shorten %s -> %s"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidScan)) ));
                    __leave;
                }
                else
                {
                    TrkLog(( TRKDBG_QUOTA, TEXT("Shortened %s -> %s [%s]"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidScan)),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)) ));
                }

                // The birth entry has been shortened, or deleted.  So we can delete the
                // rest of the entries.

                if( DeleteOrphanedEntries( rgdroidList, cSegments,
                                           droidBirth,    // Don't delete this one
                                           droidCurrent   // Or this one
                                         ))
                {
                    // Amongst the orphans in need of a delete is the current
                    // entry.  Set the deleted flag, and the caller will take
                    // care of removing the entry.

                    TrkLog(( TRKDBG_QUOTA, TEXT("Current is orphaned and will be deleted") ));
                    *pbFlags |= QFLAG_DELETED;
                }

            }   // if( cSegments > 1 )

        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_QUOTA, TEXT("Ignoring exception from Scan in FlaggedEntriesEnumCallback (%08x)"),
                 GetExceptionCode() ));
    }

    if( NULL != ptszCurrentCN )
        ldap_memfree(ptszCurrentCN);
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::MoveTableEnumCallback
//
//  When the move table is enumerated, this routine is passed to LdapEnumerate
//  as the callback function.  If we're the designated DC, this function
//  takes care of uncounted/deleted entries and shortens move table strings.
//  Whether or not we're the designated DC, we update the count value,
//  according to the uncounted/deleted entries, in the pvContext structure.
//
//+----------------------------------------------------------------------------


ENUM_ACTION // static
CQuotaTable::MoveTableEnumCallback(LDAP* pLdap, LDAPMessage* pMessage, void* pvContext, void* pvThis )
{
    struct berval **    ppbvFlags = NULL;
    BYTE bFlags = 0;
    ENUM_ACTION         action = ENUM_KEEP_ENTRY;
    TRUE_COUNT_ENUM_CONTEXT *pContext = (TRUE_COUNT_ENUM_CONTEXT*) pvContext;
    CQuotaTable *pThis = (CQuotaTable*)pvThis;
    TCHAR *ptszCurrentDN = NULL;
    CDomainRelativeObjId droidCurrent;

    if( pThis->_fStopping )
        return( ENUM_ABORT );

    __try
    {
        // Read the quota flags for this entry.  We can't read them out of the
        // enumeration buffer, because the flags can get updated by the enumeration
        // and the enumeration buffer doesn't reflect the change.

        ptszCurrentDN = ldap_get_dn( pLdap, pMessage );
        if (ptszCurrentDN == NULL)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get DN") ));
            TrkRaiseLastError();
        }
        droidCurrent.ReadLdapIdtKeyBuffer(ptszCurrentDN);
        TrkLog(( TRKDBG_QUOTA, TEXT("Enumerating %s"),
                 static_cast<const TCHAR*>(CAbbreviatedIDString(droidCurrent)) ));

        pThis->ReadFlags(pLdap, ptszCurrentDN, &bFlags );

        // Count this entry if we're counting everything, or if we're only
        // counting flagged values and this one is flagged as uncounted.

        if( pContext->fCountAll || (bFlags & QFLAG_UNCOUNTED) )
            pContext->cDelta++;

        // If this is uncounted and we're the designated DC, then it's
        // counted now and we can delete the flags attribute.

        if( (bFlags & QFLAG_UNCOUNTED) && pThis->IsDesignatedDc() )
            action = ENUM_DELETE_QUOTAFLAGS;

        // If we're the designated DC, we can do some additional cleanup here.
        // It's because of this work that we need two passes; one to do the 
        // cleanup, and one to delete the entries that this cleanup marked
        // for deletion (by calling _pidt->Delete).

        if( pThis->IsDesignatedDc() && pContext->FIRST_PASS == pContext->dwPass )
        {
            pThis->ShortenString( pLdap, pMessage, &bFlags, droidCurrent );
        }

        // If this entry is marked for delete, decrement the count.
        // Note that if the entry was marked uncounted and deleted,
        // we incremented at the top and will decrement here for the
        // correct change of zero.

        if( bFlags & QFLAG_DELETED )
        {
            pContext->cDelta--;

            // If we're the designated DC, we can delete the entry.
            if( pThis->IsDesignatedDc() )
                action = ENUM_DELETE_ENTRY;
        }
    }
    __finally
    {
        if(ppbvFlags != NULL)
        {
            ldap_value_free_len(ppbvFlags);
        }

        if( NULL != ptszCurrentDN )
            ldap_memfree( ptszCurrentDN );
    }

    // Be nice to the DS
    if( 0 != pContext->dwRepetitiveTaskDelay )
        Sleep( pContext->dwRepetitiveTaskDelay );

    return action;
}


ENUM_ACTION // static
CQuotaTable::VolumeTableEnumCallback( LDAP * pLdap, LDAPMessage * pResult, void* pcEntries, void* pvThis )
{
    CQuotaTable* pThis = (CQuotaTable*)pvThis;

    if( pThis->_fStopping )
        return( ENUM_ABORT );

    (*((DWORD*)pcEntries))++;
    return ENUM_KEEP_ENTRY;
}


void
CQuotaTable::Statistics( TRKSVR_STATISTICS *pTrkSvrStatistics )
{
    pTrkSvrStatistics->dwMoveLimit = _dwMoveLimit;
    pTrkSvrStatistics->dwCachedVolumeTableCount = (DWORD) _lCachedVolumeTableCount;
    pTrkSvrStatistics->dwCachedMoveTableCount = (DWORD) _lCachedMoveTableCount;
    pTrkSvrStatistics->ftCacheLastUpdated = _cftCacheLastUpdated;
    pTrkSvrStatistics->fIsDesignatedDc = IsDesignatedDc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\resource.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by linkui.rc
//
#define IDS_RESTOREMACHINE              1
#define IDS_RESTORESTATUS               2
#define IDS_RESTOREDATE                 3
#define IDS_PENDING                     4
#define IDS_CALLING                     5
#define IDS_UNAVAILABLE                 6
#define IDS_DATAUNAVAILABLE             7
#define IDS_SUCCESS                     8
#define IDS_ACCESSDENIED                9
#define IDS_WORKING                     10
#define IDS_CONFIRMRESTORE              11
#define IDS_RESTOREFROM                 12
#define IDS_MERGE_FORMAT                13
#define IDD_DIALOG1                     101
#define IDD_DIALOG2                     102
#define IDC_EDIT1                       1000
#define IDC_LIST1                       1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\svrmain.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       svrmain.cxx
//
//  Contents:   Main startup for Tracking (Server) Service
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:   UnInitialize RPC.
//              LnkSvrMoveNotify must not be passed machine id.
//              RPC stub routines should not catch exceptions.
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#define THIS_FILE_NUMBER    SVRMAIN_CXX_FILE_NO

#define TRKDATA_ALLOCATE
#include "trksvr.hxx"
#undef TRKDATA_ALLOCATE



//+----------------------------------------------------------------------------
//
//
//+----------------------------------------------------------------------------

HANDLE g_hWait = NULL;

void
ServiceStopCallback( PVOID pContext, BOOLEAN fTimeout )
{
    CTrkSvrSvc *ptrksvr = reinterpret_cast<CTrkSvrSvc*>(pContext);

    __try
    {
        UnregisterWait( g_hWait );
        g_hWait = NULL;

        // Close down the service.  This could block while threads are
        // completed.

        ptrksvr->UnInitialize( S_OK );
        TrkLog((TRKDBG_SVR, TEXT("TrkSvr service stopped") ));
        CTrkRpcConfig::_fInitialized = FALSE;
        delete ptrksvr;

        TrkAssert( NULL == g_ptrksvr );
        TrkAssert( 0 == g_cThreadPoolRegistrations );

        // Uninitialize the DLL since it's never actually unloaded.

        CommonDllUnInit( &g_ctrksvr );
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception during service stop - %08x"), GetExceptionCode() ));
    }

#if DBG
    TrkDebugDelete( );
#endif

}


//+----------------------------------------------------------------------------
//
//  ServiceMain
//
//  This function is exported from the dll, and is called when we run
//  under svchost.exe.
//
//+----------------------------------------------------------------------------

VOID WINAPI
ServiceMain(DWORD dwArgc, LPTSTR *lptszArgv)
{
    SVCS_ENTRY_POINT( dwArgc, lptszArgv, NULL, NULL );
}




//+----------------------------------------------------------------------------
//
//  ServiceEntry
//
//  This function is also exported from the dll, and is called directly when
//  we run under services.exe (the normal case), but is also called by
//  ServiceMain when we run under svchost.exe.  We distinguish between the
//  two by checking pSvcsGlobalData (non-NULL iff running under services.exe).
//
//  Since we use the Win32 thread pool, this routine returns after some
//  initialization, it isn't held for the lifetime of the service (except
//  when run under svchost.exe).
//
//+----------------------------------------------------------------------------

VOID
SVCS_ENTRY_POINT(
    DWORD NumArgs,
    LPTSTR *ArgsArray,
    PSVCHOST_GLOBAL_DATA pSvcsGlobalData,
    IN HANDLE  SvcRefHandle
    )
{

    HRESULT     hr = S_OK;
    BOOL fDllInitialized = FALSE;
    CTrkSvrSvc *ptrksvr = NULL;

    __try
    {
        #if DBG
            {
                CTrkConfiguration cTrkConfiguration;
                cTrkConfiguration.Initialize();

                TrkDebugCreate( cTrkConfiguration._dwDebugStoreFlags, "TrkSvr" );
                cTrkConfiguration.UnInitialize();
            }
        #endif

        // Initialize the DLL itself.  This raises if there is already an instance
        // of this service running.

        CommonDllInit( &g_ctrksvr );
        fDllInitialized = TRUE;

        TrkLog(( TRKDBG_SVR, TEXT("\n") ));

        // Create and initialize the primary service object

        ptrksvr = new CTrkSvrSvc;
        if( NULL == ptrksvr )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc CTrkSvrSvc") ));
            return;
        }
        ptrksvr->Initialize( pSvcsGlobalData );    // sets g_ptrksvr

    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
        TrkLog((TRKDBG_ERROR, TEXT("couldn't initialize, hr=%08X"),hr));

        if( NULL != ptrksvr )
        {
            __try
            {
                ptrksvr->UnInitialize( hr );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                TrkAssert( !TEXT("Unexpected exception in trksvr!ServiceEntry") );
            }
            TrkAssert( NULL == g_ptrksvr );
            delete ptrksvr;
            ptrksvr = NULL;
        }

        if( fDllInitialized )
            CommonDllUnInit( &g_ctrksvr );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\seqstg.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       seqstg.cxx
//
//  Contents:   Refresh sequence number storage
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    03-Oct-97  BillMo   Created
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"

class CLdapRefreshSeqDn
{
public:
    // specific volume
    CLdapRefreshSeqDn( const TCHAR * ptszBaseDn )
    {
        // Compose, the following DN:
        //    "CN=RefreshSequence,CN=VolumeTable,CN=FileLinks,DC=TRKDOM"

        _tcscpy(_szDn, TEXT("CN=RefreshSequence,CN=VolumeTable,"));
        _tcscat(_szDn, ptszBaseDn );

        TrkAssert(_tcslen(_szDn) < ELEMENTS(_szDn));
    }

    inline operator TCHAR * () { return _szDn; }

private:
    TCHAR _szDn[MAX_PATH];
};



//+----------------------------------------------------------------------------
//
//  CRefreshSequenceStorage::GetSequenceNumber
//
//  Get the current value of the sequence number.  If the cached value is
//  old and we're not the designated DC, then re-read it from the DS.  (Since
//  the designated DC is the only one that writes this value, it needn't
//  ever refresh its cache).
//
//+----------------------------------------------------------------------------

SequenceNumber
CRefreshSequenceStorage::GetSequenceNumber()
{
    CVolumeId volidZero;
    CMachineId mcidZero(MCID_INVALID);
    CVolumeSecret secretZero;
    CFILETIME cft;  // Initializes to current time

    _cs.Enter();
    __try
    {
        // See if our cached value is young enough.

        cft.DecrementSeconds( _psvrconfig->GetRefreshStorageTTL() );
        if ( _pQuotaTab->IsDesignatedDc() && _cftLastRead != 0
            ||
            _cftLastRead >= cft )
        {
            // Yes, we can just return _seq as is.

            //TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
            //         TEXT("CRefreshSequenceStorage using cached value (%d)"), _seq ));
            __leave;
        }

        // We need to read the sequence number from the DS.

        if ( _pVolTab->GetVolumeInfo( volidZero, &mcidZero, &secretZero, &_seq, &cft ) ==
             TRK_S_VOLUME_NOT_FOUND )
        {
            // volidZero doesn't exist, so we'll assume the sequence number is zero.
            // If we're the designated DC, write this out.

            if( _pQuotaTab->IsDesignatedDc() )
            {
                TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                    TEXT("CRefreshSequenceStorage::GetSequenceNumber - creating volume id 0")));

                _pVolTab->AddVolidToTable( volidZero, mcidZero, secretZero );
            }
            _seq = 0;
        }
        #if DBG
        else
        {
            // We read it successfully.
            TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                     TEXT("CRefreshSequenceStorage read %d"), _seq ));
        }
        #endif

        _cftLastRead = CFILETIME();

    }
    __finally
    {
        _cs.Leave();
    }

    return(_seq);
}

void
CRefreshSequenceStorage::IncrementSequenceNumber()
{
    SequenceNumber seq;
    CVolumeId volidZero;

    _cs.Enter();
    __try
    {
        TrkAssert( _pQuotaTab->IsDesignatedDc() );

        if( _cftLastRead == CFILETIME(0) )
            GetSequenceNumber();

        _pVolTab->SetSequenceNumber( volidZero, ++_seq );
        _cftLastRead = CFILETIME();
    }
    __finally
    {
        _cs.Leave();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\trksvr_sp.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <windows.h>
#include <rpc.h>
#include <rpcasync.h>
#include "trksvr_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\voltab.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       voltab.cxx
//
//  Contents:   volumes table
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    16-Dec-96  MikeHill Created.
//              23-Jan-97  BillMo   Added support for synchronizing clients
//                                  after a DC restore.
//
//  Notes:      There are two sequence numbers that pertain to each volume.
//
//              The first sequence number is used to synchronize the machine
//              move logs with the object move table. This sequence number
//              is relevant to QueryVolume, ClaimVolume, GetVolumeInfo.
//
//              The second sequence number is used to synchronize the
//              automatic backup of the volume to machine table.
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
#include <commctrl.h>
#include <time.h>

#define MAX_MACHINE_BUF_CHARS 256

TCHAR s_RestoreVolumes[] = TEXT("Software\\Microsoft\\LinkTrack\\RestoreVolumes");

class CLdapTimeVolChange
{
public:
    CLdapTimeVolChange()
    {
        memset(_abPad,0,sizeof(_abPad));
    }

    CLdapTimeVolChange(const CFILETIME &cft)
    {
        _cft = cft;
        memset(_abPad,0,sizeof(_abPad));
    }

    void Swap();

    inline BYTE & Byte(int i)
    {
        return( ((BYTE*)this)[i] );
    }

    CFILETIME _cft;
    BYTE _abPad[sizeof(GUID) - sizeof(CFILETIME)];
};

void
CLdapTimeVolChange::Swap()
{
    BYTE b;

    for (int i=0; i<sizeof(*this)/2; i++)
    {
        b = Byte(i);
        Byte(i) = Byte(sizeof(*this)-i-1);
        Byte(sizeof(*this)-i-1) = b;
    }
}

class CLdapSecret
{
public:
    CLdapSecret()
    {
        memset(_abPad,0,sizeof(_abPad));
    }

    CLdapSecret(const CVolumeSecret &secret)
    {
        _secret = secret;
        memset(_abPad,0,sizeof(_abPad));
    }

    CVolumeSecret _secret;
    BYTE _abPad[sizeof(GUID) - sizeof(CVolumeSecret)];
};


void
CVolumeTable::Initialize(CTrkSvrConfiguration *pconfigSvr, CQuotaTable* pqtable)
{
    _fInitializeCalled = TRUE;

    _pqtable = pqtable;
    _pconfigSvr = pconfigSvr;

#ifdef VOL_REPL
    //  Can raise an NTSTATUS so put before fInitializeCalled=TRUE
    InitializeCriticalSection(&_csQueryCache);  

    if (pwm != NULL)
    {

        //
        // Initialize the cache immediately ready for client queries
        // Service start time, query may take a while. Dependency on ldap being available.
        // => Make this lazy.
        //

        _SecondsPreviousToNow = _pconfigSvr->GetVolumeQueryPeriod()
                                *  _pconfigSvr->GetVolumeQueryPeriods();

        _cftCacheLowest.SetToUTC();
        _cftCacheLowest.DecrementSeconds( _SecondsPreviousToNow );

        // search for all changes since now-period*numperiods (may throw on out of memory)
        _QueryVolumeChanges( _cftCacheLowest, &_VolMap );

        // timer should go off in about 6 hrs
        CFILETIME cft;
        cft.IncrementSeconds(VolumeQueryPeriodSeconds);
        _timerQueryCache.Initialize(this, pwm, 0, VolumeQueryPeriodSeconds, &cft);
    }
#endif
}

void
CVolumeTable::UnInitialize()
{
    if (_fInitializeCalled)
    {
        _fInitializeCalled = FALSE;

#ifdef VOL_REPL
        _timerQueryCache.UnInitialize();

        DeleteCriticalSection(&_csQueryCache);

        _VolMap.UnInitialize();
#endif
    }
}

#ifdef VOL_REPL
void
CVolumeTable::Timer( DWORD dwTimerId )
{
    // redo the query - will leave _VolMap unchanged on error
    // On low memory exception we should retry the timer.

    Raise if stopped

    CFILETIME cftHighest;
    CFILETIME cft;
    cft.DecrementSeconds( _SecondsPreviousToNow );

    CVolumeMap VolMap;

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE, TEXT("Volume table cache timer")));

    // search for all changes since now-period*numperiods (may throw on out of memory)
    _QueryVolumeChanges( cft, &VolMap );

    EnterCriticalSection(&_csQueryCache);

    _cftCacheLowest = cft;
    VolMap.MoveTo(&_VolMap);

    LeaveCriticalSection(&_csQueryCache);
}

#if DBG
void
CVolumeTable::PurgeCache()
{
    EnterCriticalSection(&_csQueryCache);

    _cftCacheLowest = CFILETIME(0);
    _VolMap.UnInitialize();

    LeaveCriticalSection(&_csQueryCache);
}
#endif

#endif

HRESULT
CVolumeTable::MapResult(int err) const
{
    if (err == LDAP_SUCCESS)
    {
        return(S_OK);
    }
    else
    if (err == LDAP_NO_SUCH_OBJECT)
    {
        return(TRK_S_VOLUME_NOT_FOUND);
    }
    else
    {
        TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        return(TRK_S_VOLUME_NOT_FOUND);
    }
}


HRESULT
CVolumeTable::AddVolidToTable( const CVolumeId & volume,
                               const CMachineId & mcidClient,
                               const CVolumeSecret & secret )
{
    CVolumeId          volidZero;
    CLdapVolumeKeyDn   dnKey(GetBaseDn(), volume);
    CLdapStringMod     lsmClass(s_objectClass, s_linkTrackVolEntry, LDAP_MOD_ADD);
    CLdapSecret        ls(secret);
    CLdapBinaryMod     lbmVolumeSecret(s_volumeSecret, (PCHAR)&ls, sizeof(ls), LDAP_MOD_ADD);
    CLdapBinaryMod     lbmMachineId(s_currMachineId, (PCHAR)&mcidClient, sizeof(mcidClient), LDAP_MOD_ADD);
    CLdapSeqNum        lsn;
    CLdapStringMod     lsmSequence(s_seqNotification, lsn, LDAP_MOD_ADD );
    CLdapTimeValue     ltv;    // current time
    CLdapStringMod     lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_ADD);

    // When writing the zero volume (the refresh sequence number itself), write a 0 for the
    // sequence number.  (Calling _pRefreshSequenceStorage would cause an infinite loop).
    CLdapRefresh       ltvRefresh( volidZero == volume ? 0 : _pRefreshSequenceStorage->GetSequenceNumber() );
    CLdapStringMod     lsmRefresh(s_timeRefresh, ltvRefresh, LDAP_MOD_ADD);

    LDAPMod * mods[7];

    mods[0] = &lsmClass._mod;
    mods[1] = &lbmVolumeSecret._mod;
    mods[2] = &lbmMachineId._mod;
    mods[3] = &lsmSequence._mod;
    mods[4] = &lsmTimeVolChange._mod;

    // Don't write a refresh time for the null volume (this entry is used
    // to store the current global refresh counter).

    if( CVolumeId() != volume )
    {
        mods[5] = &lsmRefresh._mod;
        mods[6] = 0;
    }
    else
        mods[5] = 0;

    int err = ldap_add_s( Ldap(), dnKey, mods );

    if( LDAP_ALREADY_EXISTS == err )
    {
        ldap_delete_s( Ldap(), dnKey );
        err = ldap_add_s( Ldap(), dnKey, mods );
    }

    if( LDAP_SUCCESS == err )
        _pqtable->IncrementVolumeCountCache();
    else
        TrkLog(( TRKDBG_ERROR, TEXT("Failed AddVolidToDs (%d)"), err ));

    return MapResult(err);
}

HRESULT
CVolumeTable::PreCreateVolume( const CMachineId & mcidClient,
                               const CVolumeSecret & secret,
                               ULONG cUncountedVolumes,
                               CVolumeId * pvolume )
{
    int             err;
    RPC_STATUS      Status;
    CMachineId      mcidZero(MCID_INVALID);
    ULONG           cVolumes = 0;

    if(mcidClient != mcidZero && _pqtable->IsVolumeQuotaExceeded(mcidClient, cUncountedVolumes))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Volume quota exceeded for %s"),
                (const TCHAR*) CDebugString(mcidClient) ));
        return TRK_E_VOLUME_QUOTA_EXCEEDED;
    }

    Status = pvolume->UuidCreate();
    if (Status != RPC_S_OK )
    {
        // Since we use the randomized-guid generation algorithm,
        // we should never get a local guid.
        TrkAssert( RPC_S_UUID_LOCAL_ONLY != Status );

        TrkRaiseWin32Error(Status);
    }

    return S_OK;
}

HRESULT
CVolumeTable::QueryVolume( const CMachineId & mcidClient,
                           const CVolumeId & volume,
                           SequenceNumber * pseq,
                           FILETIME * pftLastRefresh )
{
    HRESULT hr;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secret;
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo(volume, &mcidTable, &secret, &seq, &cftRefresh );

    if (S_OK == hr)
    {
        // if (its not the right machine), or (it is the right machine and a nul secret)
        if (mcidTable != mcidClient || secret == CVolumeSecret())
        {
            return(TRK_S_VOLUME_NOT_OWNED);
        }
        *pseq = seq;
        *pftLastRefresh = cftRefresh;
    }

    return(hr);
}

HRESULT
CVolumeTable::FindVolume( const CVolumeId & volume, CMachineId * pmcid )
{
    HRESULT hr;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secret;
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo(volume, &mcidTable, &secret, &seq, &cftRefresh );

    if (S_OK == hr)
    {
        *pmcid = mcidTable;
    }

    return(hr);

}



#if DBG
void
CVolumeTable::PurgeAll()
{
    int             err;
    TCHAR            *apszAttrs[2] = { TEXT("cn"), NULL };
    LDAPMessage *   pRes;
    TCHAR           tszVolumeTable[MAX_PATH+1];

    __try
    {
        _tcscpy(tszVolumeTable, s_VolumeTableRDN);
        _tcscat(tszVolumeTable, GetBaseDn());

        err = ldap_search_s( Ldap(),
                             tszVolumeTable,
                             LDAP_SCOPE_ONELEVEL,
                             TEXT("(objectclass=*)"),
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        if (err == LDAP_SUCCESS)
        {
            // found it, lets get the attributes out

            int cEntries = ldap_count_entries(Ldap(), pRes);
            LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
            if (pEntry != NULL)
            {
                do
                {
                    TCHAR * ptszDn = ldap_get_dn(Ldap(), pEntry);

                    int errd = ldap_delete_s(Ldap(),ptszDn);

                    TrkLog((TRKDBG_ERROR, TEXT("Purged %s status %d"), ptszDn, errd));
                    ldap_memfree(ptszDn);

                } while ( pEntry = ldap_next_entry(Ldap(), pEntry));
            }
        }
    }
    __finally
    {
        if (err == LDAP_SUCCESS)
        {
            ldap_msgfree(pRes);
        }
    }
}
#endif

HRESULT
CVolumeTable::ClaimVolume( const CMachineId & mcidClient,
                           const CVolumeId & volume,
                           const CVolumeSecret & secretOld,
                           const CVolumeSecret & secretNew,
                           SequenceNumber * pseq,
                           FILETIME * pftLastRefresh )
{
    HRESULT hr;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secretCurrent;
    CVolumeSecret nullSecret;
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo( volume, &mcidTable, &secretCurrent, &seq, &cftRefresh );
    if ( S_OK == hr )
    {
        hr = TRK_E_VOLUME_ACCESS_DENIED;

        if( mcidTable == mcidClient )
            hr = SetSecret( volume, secretNew );
        else if( secretOld == secretCurrent)
            hr = SetMachineAndSecret( volume, mcidClient, secretNew );
    }

    if ( S_OK == hr )
    {
        *pseq = seq;
    }

    TrkAssert( hr == TRK_E_VOLUME_ACCESS_DENIED ||
               hr == S_OK ||
               hr == TRK_S_VOLUME_NOT_FOUND );

    return(hr);
}




//+----------------------------------------------------------------------------
//
//  CVolumeTable::DeleteVolume
//
//  Delete an entry from the volume table, but only if the volume is owned
//  by the calling machine.
//
//+----------------------------------------------------------------------------

HRESULT
CVolumeTable::DeleteVolume( const CMachineId & mcidClient,
                            const CVolumeId & volume )
{
    HRESULT hr;
    int LdapError;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secret;
    CLdapVolumeKeyDn dnVolume(GetBaseDn(), volume);
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo( volume, &mcidTable, &secret, &seq, &cftRefresh );
    if ( S_OK == hr )
    {
        if( mcidTable == mcidClient )
        {
            TrkLog(( TRKDBG_VOLTAB, TEXT("Deleting volume %s"),
                     (const TCHAR*) CDebugString(volume) ));

            LdapError = ldap_delete_s(Ldap(), dnVolume);
            if( LDAP_SUCCESS == LdapError )
            {
                hr = S_OK;
                _pqtable->DecrementVolumeCountCache();
            }
            else
                hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LdapError) );
        }
        else
            hr = TRK_E_VOLUME_ACCESS_DENIED;
    }
#if DBG
    if( FAILED(hr) )
        TrkLog(( TRKDBG_ERROR, TEXT("Failed attempt to delete volume %s"),
                 (const TCHAR*) CDebugString(volume) ));
#endif
    return(hr);
}


HRESULT
CVolumeTable::GetMachine(const CVolumeId & volume, CMachineId * pmcid)
{
    CVolumeSecret secret;
    SequenceNumber seq;
    CFILETIME cftRefresh(0);

    return GetVolumeInfo( volume, pmcid, &secret, &seq, &cftRefresh );
}

HRESULT
CVolumeTable::SetMachine(const CVolumeId & volume, const CMachineId & mcid)
{
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    CLdapTimeValue      ltv;   // Defaults to current UTC
    //ltvc.Swap();
    CLdapStringMod      lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_REPLACE);
    CLdapBinaryMod      lbmMachineId(s_currMachineId, (PCHAR)&mcid, sizeof(mcid), LDAP_MOD_REPLACE);
    LDAPMod *           mods[3];
    HRESULT             hr;
    int                 err;

    mods[0] = &lbmMachineId._mod;
    mods[1] = &lsmTimeVolChange._mod;
    mods[2] = NULL;

    err = ldap_modify_s(Ldap(), dnKey, mods);

    hr = MapResult(err);

    return(hr);
}

HRESULT
CVolumeTable::SetSecret(const CVolumeId & volume, const CVolumeSecret & secret)
{
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    CLdapTimeValue      ltv;   // Defaults to current UTC
    CLdapStringMod      lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_REPLACE);
    CLdapSecret         ls(secret);
    CLdapBinaryMod      lbmVolumeSecret(s_volumeSecret, (PCHAR)&ls, sizeof(ls), LDAP_MOD_REPLACE);
    LDAPMod *           mods[3];
    HRESULT             hr;
    int                 err;

    mods[0] = &lbmVolumeSecret._mod;
    mods[1] = &lsmTimeVolChange._mod;
    mods[2] = NULL;

    err = ldap_modify_s(Ldap(), dnKey, mods);

    hr = MapResult(err);

    return(hr);
}


HRESULT
CVolumeTable::SetMachineAndSecret(const CVolumeId & volume, const CMachineId & mcid, const CVolumeSecret & secret)
{
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    CLdapTimeValue      ltv;   // Defaults to current UTC
    CLdapStringMod      lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_REPLACE);
    CLdapBinaryMod      lbmMachineId(s_currMachineId, (PCHAR)&mcid, sizeof(mcid), LDAP_MOD_REPLACE);
    CLdapSecret         ls(secret);
    CLdapBinaryMod      lbmVolumeSecret(s_volumeSecret, (PCHAR)&ls, sizeof(ls), LDAP_MOD_REPLACE);
    LDAPMod *           mods[4];
    HRESULT             hr;
    int                 err;

    mods[0] = &lbmMachineId._mod;
    mods[1] = &lbmVolumeSecret._mod;
    mods[2] = &lsmTimeVolChange._mod;
    mods[3] = NULL;

    err = ldap_modify_s(Ldap(), dnKey, mods);

    hr = MapResult(err);

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  CVolumeTable::SetSequenceNumber
//  
//  Set the sequence number of a volume entry.  This is the value
//  of we expect to get in the next move-notification for this volume.
//  (This is used to detect if the trksvr & trkwks get out of sync.)
//
//+----------------------------------------------------------------------------

HRESULT
CVolumeTable::SetSequenceNumber(const CVolumeId & volume, SequenceNumber seq)
{
    int                err;
    HRESULT            hr;

    CLdapVolumeKeyDn   dnKey(GetBaseDn(), volume);
    CLdapSeqNum        lsn(seq);
    CLdapStringMod     lsmSequence(s_seqNotification, lsn, LDAP_MOD_REPLACE );

    LDAPMod * mods[2];

    // Set up the MODs array.

    mods[0] = &lsmSequence._mod;
    mods[1] = 0;

    // Perform the modification.

    err = ldap_modify_s(Ldap(), dnKey, mods);

    // Debug output

#if DBG
    if( LDAP_SUCCESS != err )
        TrkLog(( TRKDBG_SVR, TEXT("Couldn't set sequence number (%d)"), err ));
    else
        TrkLog(( TRKDBG_SVR, TEXT("Set seq %d on %s"), seq,
                 (const TCHAR*) CDebugString(volume) ));
#endif

    // Map back to an HRESULT

    hr = MapResult(err);

    return(hr);
}

HRESULT
CVolumeTable::GetVolumeInfo( const CVolumeId & volume,
                             CMachineId * pmcid,
                             CVolumeSecret * psecret,
                             SequenceNumber * pseq,
                             CFILETIME *pcftRefresh )
{
    // lookup the volume and get the current machine and sequence number if any
    HRESULT             hr;
    int                 err;
    LDAPMessage *       pRes = NULL;
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    struct berval **    ppbvMachineId = NULL;
    //struct berval **  ppbvSeq = NULL;
    TCHAR **            pptszSeq = NULL;
    struct berval **    ppbvSecret = NULL;
    TCHAR **            pptszRefresh = NULL;

    TCHAR       *       apszAttrs[5];

    __try
    {

        apszAttrs[0] = const_cast<TCHAR*>(s_currMachineId);
        apszAttrs[1] = const_cast<TCHAR*>(s_seqNotification);
        apszAttrs[2] = const_cast<TCHAR*>(s_volumeSecret);
        apszAttrs[3] = const_cast<TCHAR*>(s_timeRefresh);
        apszAttrs[4] = 0;

        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_BASE,
                             TEXT("(objectclass=*)"),
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );


        hr = MapResult(err);

        if (S_OK == hr)
        {
            // found it, lets get the attributes out
            int cEntries;

            cEntries = ldap_count_entries(Ldap(), pRes);

            // Get the entry from the search results.

            if (cEntries < 1)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("GetVolumeInfo: ldap_search for %s succeeded, but with %d entries"),
                         (TCHAR*) dnKey /*CDebugString(volume)._tsz*/, cEntries ));
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }

            LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
            if (pEntry == NULL)
            {
                // This should also never happen.  We know at this point that we have
                // 1 entry in the search result.  We'll pretend that it doesn't exist.
                TrkLog(( TRKDBG_ERROR, TEXT("GetVolumeInfo: ldap_search has one entry, but it couldn't be retrieved") ));
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }

            // Get the machine ID attribute.

            ppbvMachineId = ldap_get_values_len(Ldap(), pEntry, const_cast<TCHAR*>(s_currMachineId) );
            if( NULL == ppbvMachineId
                ||
                sizeof(CMachineId) > (*ppbvMachineId)->bv_len )
            {
                // This entry is corrupt, there should always be a mcid attribute.
                // We'll pretend it doesn't exist for now, and let GC clean it up.
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }
            memcpy( pmcid, (*ppbvMachineId)->bv_val, sizeof(*pmcid) );

            // Get the volume secret attribute

            ppbvSecret = ldap_get_values_len(Ldap(), pEntry, const_cast<TCHAR*>(s_volumeSecret) );
            if( NULL == ppbvSecret
                ||
                sizeof(CLdapSecret) > (*ppbvSecret)->bv_len )
            {
                // This entry is corrupt, there should always be a secret attribute.
                // We'll pretend it doesn't exist for now, and let GC clean it up.
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }
            memcpy( psecret, (*ppbvSecret)->bv_val, sizeof(*psecret) );

            // Get the sequence number attribute

            *pseq = 0;
            pptszSeq = ldap_get_values(Ldap(), pEntry, const_cast<TCHAR*>(s_seqNotification) );
            if (NULL == pptszSeq || CCH_UINT32 < _tcslen(*pptszSeq))
            {
                // The sequence number is missing or invalid.  We'll just assume it's zero.

                TrkLog((TRKDBG_ERROR, TEXT("Sequence number string too long in vol table (vol=%s)"),
                                   (const TCHAR*) CDebugString(volume) ));
            }
            else if( 1 != _stscanf( *pptszSeq, TEXT("%d"), pseq ))
            {
                // Again, assume the sequnce number is zero.
                TrkLog((TRKDBG_ERROR, TEXT("Invalid sequence number string in vol table (seq=%s, vol=%s)"),
                                   *pptszSeq, 
                                   (const TCHAR*) CDebugString(volume) ));
                *pseq = 0;
            }

            // Get the refresh counter, if it exists.

            *pcftRefresh = 0;
            pptszRefresh = ldap_get_values( Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
            if( NULL != pptszRefresh )
            {
                SequenceNumber seqRefresh = 0;
                if( 1 == _stscanf( *pptszRefresh, TEXT("%d"), &seqRefresh ))
                    *pcftRefresh = seqRefresh;
            }

        }
    }
    __finally
    {
        if (NULL != pRes)
        {
            ldap_msgfree(pRes);
        }

        if (ppbvMachineId != NULL)
        {
            ldap_value_free_len(ppbvMachineId);
        }

        if (pptszSeq != NULL)
        {
            ldap_value_free(pptszSeq);
        }

        if (ppbvSecret != NULL)
        {
            ldap_value_free_len(ppbvSecret);
        }

        if (pptszRefresh != NULL)
            ldap_value_free(pptszRefresh);

        if (AbnormalTermination())
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Exception in CVolumeTable::GetVolumeInfo") ));
        }
    }

    return(hr);
}

// TRUE if exists and touched, FALSE if not existent, exception otherwise.
// BUGBUG P2: check ownership of entry being touched.

BOOL
CVolumeTable::Touch(
    const CVolumeId & volid
    )
{

    if (volid == CVolumeId())
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Null volid passed to CVolumeTable::Touch") ));
        return( FALSE );
    }

    BOOL            fReturn = FALSE;
    int             err;
    CLdapRefresh    ltvRefresh( _pRefreshSequenceStorage->GetSequenceNumber());
    CLdapStringMod  lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_REPLACE );
    CLdapVolumeKeyDn
                    dnKey(GetBaseDn(), volid);

    LDAPMod *       mods[2];
    TCHAR **        pptszRefresh = NULL;
    LDAPMessage   * pEntry = NULL;
    LDAPMessage*    pRes = NULL;


    __try
    {


        //
        // Check to see if the object already has this sequence number.
        //

        TCHAR*          rgptszAttrs[2];
        rgptszAttrs[0] = const_cast<TCHAR*>(s_timeRefresh);
        rgptszAttrs[1] = NULL;

        err = ldap_search_s(Ldap(),
                            dnKey,
                            LDAP_SCOPE_BASE,
                            TEXT("(ObjectClass=*)"),
                            rgptszAttrs,
                            0,
                            &pRes);


        if (err == LDAP_SUCCESS)
        {
            // The search call worked, but did we find an object?
            if( 1 == ldap_count_entries(Ldap(), pRes) )
            {
                // The object already exists
                pEntry = ldap_first_entry(Ldap(), pRes);
                if( NULL != pEntry )
                {
                    // Get the refresh counter
                    pptszRefresh = ldap_get_values( Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
                    if( NULL != pptszRefresh )
                    {
                        SequenceNumber seqRefresh = 0;
                        if( 1 == _stscanf( *pptszRefresh, TEXT("%d"), &seqRefresh ))
                        {
                            // First, long is the GC timer in seconds?
                            LONG lGCTimerInSeconds = _pconfigSvr->GetGCPeriod()     // 30 days in seconds
                                                     / _pconfigSvr->GetGCDivisor(); // 30

                            // Next, how many ticks is half the period?
                            LONG lWindow =  _pconfigSvr->GetGCPeriod()        // 30 days (in seconds)
                                            / 2                               // => 15 days (in seconds)
                                            / lGCTimerInSeconds;              // => 15
                            if( seqRefresh + lWindow
                                >= _pRefreshSequenceStorage->GetSequenceNumber()
                              )
                            {
                                TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_VOLTAB,
                                         TEXT("Not touching volume %s with %d, seq %d already set"),
                                         (const TCHAR*) CDebugString(volid),
                                         _pRefreshSequenceStorage->GetSequenceNumber(),
                                         seqRefresh ));
                                __leave;
                            }
                        }
                    }
                }
            }
        }
        else if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_VOLTAB,
                TEXT("Touch: volume %s not found"), 
                (const TCHAR*) CDebugString(volid)));
            __leave;
        }


        //
        // Set the correct sequence number
        //

        mods[0] = &lsmRefresh._mod;
        mods[1] = NULL;

        err = ldap_modify_s(Ldap(), dnKey, mods);

        if (err == LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch: volume %s touched"), 
                (const TCHAR*) CDebugString(volid)));
            fReturn = TRUE;
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch:: volume %s doesn't exist"), 
                (const TCHAR*) CDebugString(volid)));
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_ATTRIBUTE)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch: volume %s attribute not found"), 
                (const TCHAR*) CDebugString(volid)));

            // deal with old server data
            CLdapStringMod lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_ADD );
            mods[0] = &lsmRefresh._mod;

            err = ldap_modify_s(Ldap(), dnKey, mods);
        }

        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch:: volume %s gives exceptional error"), 
                (const TCHAR*) CDebugString(volid)));

            __leave;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolumeTable::Touch (%08x)"), GetExceptionCode() ));
    }

    if (pptszRefresh != NULL)
        ldap_value_free(pptszRefresh);
    if(pRes != NULL)
        ldap_msgfree(pRes);

    return( fReturn );
}


//+----------------------------------------------------------------------------
//
//  CVolumeTable::GarbageCollect
//
//  This is called by CTrkSvrSvc when it's time to GC the volume table (daily).
//  The entries are enumerated, and if too old they are deleted.
//
//+----------------------------------------------------------------------------

ULONG
CVolumeTable::GarbageCollect( SequenceNumber seqCurrent, SequenceNumber seqOldestToKeep, const BOOL * pfAbort )
{
    CLdapVolumeKeyDn    dn(GetBaseDn());
    TCHAR *             apszAttrs[3];
    GC_ENUM_CONTEXT     EnumContext;

    TrkLog(( TRKDBG_VOLTAB | TRKDBG_GARBAGE_COLLECT, TEXT("GC-ing volume table (%d/%d)"),
             seqCurrent, seqOldestToKeep ));

    // Set up the attributes for the ldap_search_init_page call.

    apszAttrs[0] = const_cast<TCHAR*>(s_Cn);
    apszAttrs[1] = const_cast<TCHAR*>(s_timeRefresh);
    apszAttrs[2] = 0;

    // Set up all the info that the LdapEnumerate call needs.

    memset( &EnumContext, 0, sizeof(EnumContext) );
    EnumContext.seqOldestToKeep = seqOldestToKeep;
    EnumContext.seqCurrent = seqCurrent;
    EnumContext.pfAbort = pfAbort;
    EnumContext.dwRepetitiveTaskDelay = _pconfigSvr->GetRepetitiveTaskDelay();
    EnumContext.pqtable = _pqtable;

    // Do an ldap_search, calling GcEnumerateCallback for each of the
    // returned values.

    if (!LdapEnumerate(
        Ldap(),                     // LDAP handle
        dn,                         // Base DN
        LDAP_SCOPE_ONELEVEL,        // No recursion
        TEXT("(objectClass=*)"),    // Filter
        apszAttrs,                  // Attributes (get CN & refresh time)
        GcEnumerateCallback,        // Called for each iteration
        &EnumContext ))             // Info for GcEnuemrateCallback
    {
        TrkRaiseException(TRK_E_SERVICE_STOPPING);
    }

    TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
             TEXT("GC-ed %d entries from the volume table"),
             EnumContext.cEntries ));

    // If we actually deleted anything, the cached values
    // in the quota object are no longer valid.  Mark it as
    // such, so that it will know to re-generate it the next
    // time it's needed.

    if( 0 != EnumContext.cEntries )
        _pqtable->InvalidateCache();

    return EnumContext.cEntries;
}

ENUM_ACTION
GcEnumerateCallback( LDAP * pLdap, LDAPMessage *pMessage, PVOID pvContext, PVOID )
{
    GC_ENUM_CONTEXT * pContext = (GC_ENUM_CONTEXT *) pvContext;
    TCHAR * ptszDn = NULL;
    TCHAR ** pptszValue = NULL;
    ENUM_ACTION Action = ENUM_KEEP_ENTRY;
    ULONG ulSequence = 0;

    // See if we should abort.  We shouldn't even be here if we're not
    // the designated DC.  The only way it can happen is if the designated
    // DC is changed during the enumeration.

    if( *(pContext->pfAbort)
        ||
        !pContext->pqtable->IsDesignatedDc() )
    {
        Action = ENUM_ABORT;
        goto Exit;
    }

    // Get the DN of this entry so that we can check for special entries.

    ptszDn = ldap_get_dn( pLdap, pMessage );
    if (ptszDn == NULL)
    {
        TrkLog((TRKDBG_GARBAGE_COLLECT,
                TEXT("Couldn't get DN during GcEnumerateCallback") ));
        goto Exit;
    }

    // CQuotaTable stores special values in the volume table, all prefixed by "QT".
    // Don't delete those.

    if( !_tcsnicmp( TEXT("CN=QT"), ptszDn, 5 ))
    {
        TrkLog(( TRKDBG_GARBAGE_COLLECT,
                 TEXT("Skipping quota entry in GC (%s)"),
                 ptszDn ));
        goto Exit;
    }

    // The current value of the Refresh counter is stored in volume ID 0.  So
    // don't delete that either.

    if( !_tcsnicmp( TEXT("CN=00000000000000000000000000000000,"), ptszDn, 35 ))
    {
        TrkLog(( TRKDBG_GARBAGE_COLLECT,
                 TEXT("Skipping volid 0 GC (%s)"),
                 ptszDn ));
        goto Exit;
    }

    // Get the refresh time value.

    pptszValue = ldap_get_values( pLdap, pMessage, const_cast<TCHAR*>(s_timeRefresh) );

    if (pptszValue == NULL)
    {
        TrkLog((TRKDBG_GARBAGE_COLLECT,
                TEXT("Can't find sequence number in %s"),
                ptszDn));

        // This is a corrupted entry that will never get GC-ed,
        // so we'll delete it now.

        pContext->cEntries++;
        Action = ENUM_DELETE_ENTRY;
        goto Exit;
    }

    _stscanf( *pptszValue, TEXT("%d"), &ulSequence );

    // Determine if we should delete this entry.

    if( ulSequence < (ULONG)pContext->seqOldestToKeep )
    {
        Action = ENUM_DELETE_ENTRY;
        pContext->cEntries++;
    }
    else
        Action = ENUM_KEEP_ENTRY;


#if DBG
    if( ENUM_DELETE_ENTRY == Action )
        TrkLog(( TRKDBG_QUOTA, TEXT("Seq to delete:  %d/%d"),
                 ulSequence, (ULONG)pContext->seqOldestToKeep ));
#endif

    // Check to see if the entry has an invalid sequence number.  It's
    // invalid if it's bigger than the current value.  This can happen if the
    // special zero entry gets deleted from the volume table for some reason.

    if( ulSequence > (ULONG)pContext->seqCurrent )
    {
        // Reset the entry's sequence number to the current value.  Otherwise it
        // could be a very long time before it gets GCed.  This case should never
        // happen, but there's no guarantee that someone won't delete the 
        // entry accidentally.

        CLdapRefresh    ltvRefresh( pContext->seqCurrent );
        CLdapStringMod  lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_REPLACE );
        int err;

        LDAPMod *       mods[2];

        mods[0] = &lsmRefresh._mod;
        mods[1] = NULL;

        err = ldap_modify_s( pLdap, ptszDn, mods );

        TrkLog(( TRKDBG_SVR | TRKDBG_GARBAGE_COLLECT,
                 TEXT("Touched entry with invalid sequence number (%d, %s)"),
                 ulSequence, ptszDn ));

    }

Exit:

    if( NULL != pptszValue )
        ldap_value_free( pptszValue );

    if( NULL != ptszDn )
        ldap_memfree( ptszDn );

    // Be nice to the DS
    if( 0 != pContext->dwRepetitiveTaskDelay )
        Sleep( pContext->dwRepetitiveTaskDelay );

    return( Action );
}

// returns FALSE if aborted

BOOL
LdapEnumerate(
    LDAP * pLdap,
    TCHAR * ptszBaseDn,
    ULONG Scope,
    TCHAR * Filter,
    TCHAR * Attributes[],
    PFN_LDAP_ENUMERATE_CALLBACK pCallback,
    void* UserParam1,
    void* UserParam2)
{
    LDAPMessage * pResults;
    LDAPSearch * pSearch;
    ENUM_ACTION EnumAction = ENUM_KEEP_ENTRY;

    // Start a paged enumeration using the specified base DN & filter.

    pSearch = ldap_search_init_page( pLdap,
                                  ptszBaseDn,
                                  Scope,
                                  Filter,
                                  Attributes,
                                  FALSE,
                                  NULL,
                                  NULL,
                                  0,
                                  20000,
                                  NULL );

    if (pSearch != NULL)
    {
        int err;
        ULONG totalCount;

        // Get the next page of the enumeration

        while ( EnumAction != ENUM_ABORT &&
                LDAP_SUCCESS == (err = ldap_get_next_page_s( pLdap,
                                     pSearch,
                                     NULL,
                                     10,
                                     &totalCount,
                                     &pResults ) && pResults != NULL))
        {

            LDAPMessage * pMessage;
            LDAPMessage * pFirstMessage;

            // Loop through the entries on this page.

            pFirstMessage = pMessage = ldap_first_entry( pLdap, pResults );
            while ( EnumAction != ENUM_ABORT
                    && 
                    pMessage != NULL )
            {
                // Call the callback to process this entry.

                EnumAction = (*pCallback)(
                        pLdap,
                        pMessage,
                        UserParam1,
                        UserParam2);

                if ( EnumAction == ENUM_DELETE_ENTRY )
                {
                    // This entry is to be deleted.  Increment the entry
                    // count, and if we're not just counting, actually delete it.


                    TCHAR * ptszDn = ldap_get_dn( pLdap, pMessage );

                    if (ptszDn != NULL)
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("Deleting Dn=%s"), ptszDn));
                        ldap_delete_s( pLdap, ptszDn );
                        ldap_memfree( ptszDn );
                    }
                }
                else if(EnumAction == ENUM_KEEP_ENTRY)
                {
                }
                else if(EnumAction == ENUM_DELETE_QUOTAFLAGS)
                {
                    TCHAR*          ptszDn = ldap_get_dn(pLdap, pMessage);

                    if(NULL != ptszDn)
                    {
                        if(UserParam2)
                        {
                            ((CQuotaTable*)UserParam2)->DeleteFlags(pLdap, ptszDn);
                        }
                    }
                }
                pMessage = ldap_next_entry( pLdap, pMessage );
            }

            ldap_msgfree( pResults );

            if (pFirstMessage == NULL)
                break;
        }
        ldap_search_abandon_page( pLdap, pSearch );
    }
    return(EnumAction != ENUM_ABORT);
}


#ifdef VOL_REPL
void
CVolumeTable::QueryVolumeChanges( const CFILETIME & cftFirstChange, CVolumeMap * pVolMap )
{
    // protect against the data changing under us
    BOOL fCacheHit;

    __try
    {

        EnterCriticalSection(&_csQueryCache);

        if (fCacheHit = _cftCacheLowest <= cftFirstChange)
        {
            TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
                TEXT("CVolumeTable::QueryVolumeChanges(cftFirstChange=%s) HIT, returning %d change entries from cache"),
                    (const TCHAR*) CDebugString(cftFirstChange),
                    _VolMap.Count()));
            _VolMap.CopyTo( pVolMap );
        }
    }
    _finally
    {
        LeaveCriticalSection(&_csQueryCache);
    }

    if (!fCacheHit)
    {
        // the cache was missed... go to the real database.

        CFILETIME cftHighest;
        _QueryVolumeChanges( cftFirstChange, pVolMap );

        TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
                TEXT("CVolumeTable::QueryVolumeChanges(cftFirstChange=%s) MISS, returning %d entries from full query"),
                    (const TCHAR*) CDebugString(cftFirstChange),
                    pVolMap->Count()));
    }
}
#endif

// if there are more than zero volume entries, then pVolMap->SetSize and pVolMap->Add will be called,
// otherwise pVolMap will not be called and so must be initialized by the caller

#ifdef VOL_REPL

void
CVolumeTable::_QueryVolumeChanges( const CFILETIME & FirstChangeRequested,
                                   CVolumeMap * pVolMap )
{
    // lookup the volume and get the current machine and sequence number if any
    int                 err;
    LDAPMessage *       pRes = NULL;
    CLdapVolumeKeyDn    dnKey(GetBaseDn());
    struct berval **    ppbvMachineId = NULL;
    TCHAR **            pptszCnVolumeId = NULL;
    TCHAR               szSearchFilter[256];
    TCHAR *             apszAttrs[4];
    HRESULT             hr;
    CLdapTimeValue      ltv(FirstChangeRequested);

    __try
    {
        //
        // Build up a search filter looking for objects with timeVolChange >= FirstChangeRequested
        //
        // (timeVolChange=XXX)
        //

        _tcscpy(szSearchFilter, s_timeVolChangeSearch);

        _tcscat(szSearchFilter, ltv);

        _tcscat(szSearchFilter, TEXT(")"));

        //
        // Build up the list of attributes to query
        //

        apszAttrs[0] = s_currMachineId;
        apszAttrs[1] = s_Cn;
        apszAttrs[2] = 0;

        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_ONELEVEL,
                             szSearchFilter,
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        hr = MapResult(err);

        //
        // Depending on whether DS sets up a maximum query size, we will need to iterate
        // performing multiple searches. Initially just use a single query.
        //

        if (hr == S_OK)
        {
            // found it, lets get the attributes out

            int cEntries = ldap_count_entries(Ldap(), pRes);
            if (cEntries != 0)
            {
                pVolMap->SetSize(cEntries);

                LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
                if (pEntry != NULL)
                {
                    do
                    {
                        //
                        // for each entry get the
                        //   volume id from the CN
                        //   machine id
                        //   time of last volume change
                        //

                        pptszCnVolumeId = ldap_get_values(Ldap(), pEntry, s_Cn);
                        if (pptszCnVolumeId == NULL)
                        {
                            TrkRaiseException(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
                        }

                        if (_tcslen(*pptszCnVolumeId) != 32) // length of stringized volume id
                        {
                            // Add code to recover from this.
                            TrkRaiseException(TRK_E_CORRUPT_VOLTAB);
                        }

                        ppbvMachineId = ldap_get_values_len(Ldap(), pEntry, s_currMachineId);
                        if (ppbvMachineId == NULL)
                        {
                            TrkRaiseException(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
                        }

                        if ((*ppbvMachineId)->bv_len < sizeof(CMachineId))
                        {
                            // Add code to recover from this
                            TrkRaiseException(TRK_E_CORRUPT_VOLTAB);
                        }

                        CVolumeId volume( *pptszCnVolumeId, TRK_E_CORRUPT_VOLTAB );

                        CMachineId machine( (*ppbvMachineId)->bv_val,
                            (*ppbvMachineId)->bv_len,
                            TRK_E_CORRUPT_VOLTAB );

                        pVolMap->Add( volume, machine );

                        ldap_value_free(pptszCnVolumeId);
                        pptszCnVolumeId = NULL;

                        ldap_value_free_len(ppbvMachineId);
                        ppbvMachineId = NULL;

                    } while ( pEntry = ldap_next_entry(Ldap(), pEntry));
                }

                pVolMap->Compact();
            }
        }
    }
    __finally
    {
        if (pRes != NULL)
        {
            ldap_msgfree(pRes);
        }

        if (pptszCnVolumeId != NULL)
        {
            ldap_value_free(pptszCnVolumeId);
        }

        if (ppbvMachineId != NULL)
        {
            ldap_value_free_len(ppbvMachineId);
        }
    }

    TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
            TEXT("_QueryVolumeChanges(filter=%s) got %d changes since %s"),
                szSearchFilter,
                pVolMap->Count(),
                (const TCHAR*) CDebugString(FirstChangeRequested)));

}

#endif

// raises on error, returns number of volumes on this machine

DWORD
CVolumeTable::CountVolumes( const CMachineId & mcid )
{
    // lookup the volume and get the current machine and sequence number if any
    int                 err;
    LDAPMessage *       pRes = NULL;
    CLdapVolumeKeyDn    dnKey(GetBaseDn());
    TCHAR               szSearchFilter[256];
    TCHAR *             pszAppend;
    TCHAR *             aptszAttrs[2];
    HRESULT             hr;
    DWORD               cVolumes = 0;

    __try
    {
        //
        // Build up a search filter looking for objects with currMachineId == mcid
        //
        // (volTableIdxGUID;binary=XXX)
        //

        _tcscpy(szSearchFilter, s_currMachineIdSearch);
        pszAppend = szSearchFilter + _tcslen(szSearchFilter);

        // mcid.Stringize(pszAppend);
        mcid.StringizeAsGuid(pszAppend);

        *pszAppend++ = TEXT(')');
        *pszAppend++ = TEXT('\0');

        TrkAssert(_tcslen(szSearchFilter)+1 < ELEMENTS(szSearchFilter));

        //
        // Build up the list of attributes to query
        // If we ever update to allow large numbers of volumes on a machine,
        // this should be a paged enumeration.
        //

        aptszAttrs[0] = const_cast<TCHAR*>(s_Cn);
        aptszAttrs[1] = 0;

        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_ONELEVEL,
                             szSearchFilter,
                             aptszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        hr = MapResult(err);

        if (hr == S_OK)
        {
            // found it, lets get the attributes out

            cVolumes = ldap_count_entries(Ldap(), pRes);
        }
    }
    __finally
    {
        if (pRes != NULL)
        {
            ldap_msgfree(pRes);
        }
    }

    TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
            TEXT("CountVolumes(filter=%s) got %d volumes"),
                szSearchFilter,
                cVolumes));

    return(cVolumes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trksvr\svrsvc.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       svrsvc.cxx
//
//  Contents:   Code for CTrkSvrSvc
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
#include "ntlsa.h"

#define THIS_FILE_NUMBER    SVRSVC_CXX_FILE_NO

#if DBG
DWORD g_Debug = 0;
#endif

const extern  TCHAR s_tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkSvr\\Parameters");


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::Initialize
//
//  Initialize the TrkSvr service.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{

    __try
    {
        _cLowestAvailableThreads = _cAvailableThreads = MAX_SVR_THREADS;

        _fInitializeCalled = TRUE;
        g_ptrksvr = this;
        _pSvcsGlobalData = pSvcsGlobalData;

        // Initialize the object that manages the SCM.
        _svcctrl.Initialize(TEXT("TrkSvr"), this);
    
        // Initialize registry-configurable parameters.
        _configSvr.Initialize();

        // If requested, prepare to log all operations (to a file)
        if( _configSvr.UseOperationLog() )
            _OperationLog.Initialize( _configSvr.GetOperationLog() );

        TrkLog(( TRKDBG_SVR, TEXT("Distributed Link Tracking (Server) service starting on thread=%d(0x%x)"),
                             GetCurrentThreadId(), GetCurrentThreadId() ));

        // This is a hacked stub that looks and acts like the Win32 thread pool services
        #ifdef PRIVATE_THREAD_POOL
        {
            HRESULT hr = S_OK;
            g_pworkman2 = new CThreadPoolStub;
            if( NULL == g_pworkman2 )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create the thread pool manager") ));
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
            }

            hr = g_pworkman2->Initialize();
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't initialize the thread pool manager") ));
                TrkRaiseException( hr );
            }
        }
        #endif

        // The denial checker provides protection against a denial-of-service
        // attack, where a client floods us with calls.
        _denial.Initialize(_configSvr.GetHistoryPeriod() );

        // This critsec protects _cWritesPerHour & _cftWritesPerHour.
        // See CTrkSvrSvc::CheckWritesPerHour
        _csWritesPerHour.Initialize();

        // This maintains the "time" for purposes of refreshing entries.
        _refreshSequence.Initialize();

        // The cross-domain table
        _cdt.Initialize();

        // The intra-domain table
        _idt.Initialize( &_configSvr, &_qtable );

        // The volume table
        _voltab.Initialize( &_configSvr, &_qtable );

        // The quota manager
        _qtable.Initialize(&_voltab, &_idt, this, &_configSvr );

        // Set the quota timer.  This was originally every 30 days, but is now
        // every day.  In order to maintain compatibility with the tests, we 
        // still use the GCPeriod value (30 days), but divide it by the new
        // GCDivisor value (30) to get the correct period.
        // This timer doesn't have a standard retry, because of the way
        // we hesitate 30 minutes before doing anything.  So retries are
        // done explicitely.

        _timerGC.Initialize(this,
                            TEXT("NextGarbageCollectTime"),   // This is a persistent timer
                            0,     // Context ID
                            _configSvr.GetGCPeriod() / _configSvr.GetGCDivisor(),
                            CNewTimer::NO_RETRY,
                            0, 0, 0 );    // No retries or max lifetime
        _timerGC.SetRecurring();
        TrkLog(( TRKDBG_VOLUME, TEXT("GC timer: %s"),
                 (const TCHAR*) CDebugString(_timerGC) ));

        // Used in the Timer method to determine if we should reset the
        // move table counter value.
        _MoveCounterReset.Initialize();

        // Initialize ourself as an RPC server
        _rpc.Initialize( _pSvcsGlobalData, &_configSvr );

        // Tell the SCM that we're running.

        _svcctrl.SetServiceStatus(SERVICE_RUNNING,
                                  SERVICE_ACCEPT_STOP |
                                   SERVICE_ACCEPT_SHUTDOWN,
                                  NO_ERROR);

        _OperationLog.Add( COperationLog::TRKSVR_START );
    }

    __except( BreakOnDebuggableException() )
    {
        // Don't log an event for protseq-not-supported; this happens during a normal
        // setup.
        if( HRESULT_FROM_WIN32(RPC_S_PROTSEQ_NOT_SUPPORTED) != GetExceptionCode() )
        {
            TrkReportEvent( EVENT_TRK_SERVICE_START_FAILURE, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CHexStringize( GetExceptionCode() )),
                            NULL );
        }
        TrkRaiseException( GetExceptionCode() );
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::UnInitialize
//
//  Cancel any out-going RPCs, stop all timers, close everything down,
//  and send a service_stopped to the SCM.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::UnInitialize(HRESULT hr)
{
    if (_fInitializeCalled)
    {
        _fInitializeCalled = FALSE;

        // Cancel any out-going RPCs on threads in this service

        if( NULL != g_pActiveThreadList )
            g_pActiveThreadList->CancelAllRpc();

        // stop classes that use threads first ...
        _rpc.UnInitialize( _pSvcsGlobalData );
        _timerGC.UnInitialize();
        _csWritesPerHour.UnInitialize();

        // ... then release used resources
        _qtable.UnInitialize();
        _voltab.UnInitialize();
        _idt.UnInitialize();
        _cdt.UnInitialize();
        _dbc.UnInitialize();
        _denial.UnInitialize();

        if (_configSvr.GetTestFlags() & TRK_TEST_FLAG_WAIT_ON_EXIT)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Waiting 60 seconds before exitting for heap dump")));
            Sleep(60000);
        }

        #if PRIVATE_THREAD_POOL
        {
            g_pworkman2->UnInitialize();
            delete g_pworkman2;
            g_pworkman2 = NULL;
        }
        #endif

        g_ptrksvr = NULL;

        // If the error is protseq-not-supported, ignore it.  This is normal
        // during setup.

        if( (hr & 0x0FFF0000) == FACILITY_WIN32 )
            hr = hr & ~(0x0FFF0000);

        _svcctrl.SetServiceStatus(SERVICE_STOPPED, 0,
            HRESULT_FROM_WIN32(RPC_S_PROTSEQ_NOT_SUPPORTED) == hr ? 0 : hr
            );
        //_svcctrl.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::ServiceHandler
//
//  This method gets called by the SCM for notification of all service
//  activity.
//
//  NOTE:   In services.exe, this method is called on the one and only ServiceHandler
//          thread.  So while we execute, no other service in this process can 
//          receive notifications.  Thus it is important that we do nothing
//          blocking or time-consuming here.
//
//+----------------------------------------------------------------------------

DWORD
CTrkSvrSvc::ServiceHandler(DWORD dwControl,
                           DWORD dwEventType,
                           PVOID EventData,
                           PVOID pData)
{
    DWORD       dwRet = NO_ERROR;


    switch (dwControl)
    {
    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:

        _fStopping = TRUE;
        _qtable.OnServiceStopRequest();
        
        ServiceStopCallback( this, FALSE );

        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    default:
        dwRet = ERROR_CALL_NOT_IMPLEMENTED;
        break;
    }

    return(dwRet);
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::RaiseIfStopped
//
//  This method raises an exception if a global flag is set indicating
//  that we've received a service stop/shutdown request.  This is used
//  in places where we have a thread that could run for a while; we periodically
//  call this method to prevent service stop from blocking.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::RaiseIfStopped()
{
    if ( * _svcctrl.GetStopFlagAddress() )
        TrkRaiseException( TRK_E_SERVICE_STOPPING );
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::CheckWritesPerHour
//
//  Check _cWritesPerHour to see if we're writing to much to the DS.
//  This is a simplistic algorithm in an effort to reduce risk.  We
//  just let _cWritesPerHour increment until it hits the max, then
//  check to see when that count was started.  If more than an
//  hour ago, then reset the count & the clock.
//
//+----------------------------------------------------------------------------

BOOL
CTrkSvrSvc::CheckWritesPerHour()
{
    BOOL fExceeded = FALSE;

    if( _cWritesPerHour >= _configSvr.GetMaxDSWritesPerHour() )
    {
        _csWritesPerHour.Enter();
        __try
        {
            // Check the count again, as it may have changed whil we
            // were waiting for the critsec.
            if( _cWritesPerHour >= _configSvr.GetMaxDSWritesPerHour() )
            {
                CFILETIME cft;  // Defaults to current time

                // Did the "hour" for _cWritesPerHour actually start more
                // than an hour ago?

                cft.DecrementSeconds( _configSvr.GetMaxDSWritesPeriod() );   // An hour

                if( cft > _cftWritesPerHour )
                {
                    TrkLog(( TRKDBG_SVR, TEXT("Resetting writes-per-hour clock (%d)"),
                             _cWritesPerHour ));

                    // Yes, this write is OK, and we should reset the write time.
                    _cftWritesPerHour = CFILETIME();
                    _cWritesPerHour = 0;
                    _Stats.cCurrentFailedWrites = 0;
                }
                else
                {
                    TrkLog(( TRKDBG_WARNING,
                             TEXT("Exceeded writes-per-hour (started at %s)"),
                             (const TCHAR*) CDebugString(_cftWritesPerHour) ));

                    if( 0 == _Stats.cCurrentFailedWrites )
                        _Stats.cMaxDsWriteEvents++;
                    _Stats.cCurrentFailedWrites++;

                    fExceeded = TRUE;
                }
            }
        }
        __finally
        {
            _csWritesPerHour.Leave();
        }
    }

    return fExceeded;
}

void
CTrkSvrSvc::Scan(
    IN     const CDomainRelativeObjId * pdroidNotificationCurrent, OPTIONAL
    IN     const CDomainRelativeObjId * pdroidNotificationNew,     OPTIONAL
    IN     const CDomainRelativeObjId & droidBirth,
    OUT    CDomainRelativeObjId * pdroidList,
    IN     int cdroidList,
    OUT    int * pcSegments,
    IN OUT CDomainRelativeObjId * pdroidScan,
    OUT    BOOL * pfStringDeleted
    )
{
    CDomainRelativeObjId droidNextBirth, droidNextNew;
    BOOL      fFound = FALSE;
    BOOL      fBirthSame = FALSE;
    BOOL      fCycle = FALSE;

    *pfStringDeleted = FALSE;

    //
    // loop through the string until the birth ids don't match, or
    // we've run out of buffer space, or we get to the end of the string
    //

    do
    {
        if (pdroidNotificationCurrent && *pdroidScan == *pdroidNotificationCurrent)
        {
            TrkAssert(pdroidNotificationNew);

            droidNextNew = *pdroidNotificationNew;
            droidNextBirth = droidBirth;
            fFound = TRUE;
            *pfStringDeleted = FALSE;
        }
        else
        {
            fFound = _idt.Query(*pdroidScan, &droidNextNew, &droidNextBirth, pfStringDeleted );
            RaiseIfStopped();
        }

        if (fFound)
        {
            TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::Scan() -  iSegment=%d, %s --> %s [%s] found"),
                *pcSegments,
                static_cast<const TCHAR*>(CAbbreviatedIDString(*pdroidScan)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(droidNextNew)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(droidNextBirth)) ));

            // Check to see if we've already been here before.
            // E.g., don't loop forever on A->Ba, B->Aa.

            for( int j = 0; j < *pcSegments; j++ )
            {
                if( pdroidList[ j ] == droidNextNew )
                {
                    TrkLog(( TRKDBG_MEND, TEXT("Cycle detected during mend (on %s)"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(*pdroidScan)) ));
                    fCycle = TRUE;
                    break;
                }
            }

            if( !fCycle )
            {
                fBirthSame = droidNextBirth == droidBirth;
                if (fBirthSame)
                {
                    pdroidList[ (*pcSegments)++ ] = *pdroidScan;
                    *pdroidScan = droidNextNew;
                }
                else
                {
                    // We can stop searching.  We found a segment that starts
                    // with *pdroidScan, but it's from another string because
                    // it has a different birth ID.

                    TrkLog(( TRKDBG_MEND, TEXT("Birth IDs don't match: %s, %s"),
                             (const TCHAR*) CDebugString(droidBirth),
                             (const TCHAR*) CDebugString(droidNextBirth) ));
                }
            }
        }
    } while ( *pcSegments < cdroidList && fFound && fBirthSame && !fCycle );

    if ( *pcSegments == cdroidList || fCycle )
    {
        TrkRaiseException(TRK_E_TOO_MANY_UNSHORTENED_NOTIFICATIONS);
    }

}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::MoveNotify
//
//  Handle a move notify request from trkwks.
//
//  This routine is complicated by DS replication.  It is possible that two trksvr
//  services may modify the same entry in the IDT within a replication window.
//  The only way to prevent this is to design such that only the designated DC
//  modifies entries.  For this MoveNotify routine, that would mean that an
//  entry would be added for each notification, the designated DC would then
//  shorten the base entry, and delete this new one.  That's not friendly
//  to the DS, however, because deleted objects must continue to be stored
//  for an extended period of time.
//
//  Consequently, if this notify modifies an existing entry, this routine
//  performs a modify rather than an add.  For example, if a file is
//  moved from A to B to C, and this routine is being called for that
//  second move, it would just modify the existing entry from A->B to
//  A->C.
//
//  The risk here is that another DC will attempt to modify this entry
//  within the same replication window.  We don't have to worry though
//  about another DC doing a notify; trkwks only sends to one DC.  
//  There are two cases to worry about.  One is the case where another DC
//  marks an entry to be deleted.  If that happens after we do the modify
//  here, then there is no problem; the entry is no longer needed anyway.
//  If that happens before we do our modify here, then the delete flag
//  will be lost.  This case is rare, and the unnecessary entry won't
//  stay in the table forever; it will be garbage collected.
//
//  The other case of potential conflict is if an entry has not
//  yet been counted; in this case the designated DC might count
//  it and clear the uncounted flag.  If our modify causes that
//  flag to be uncleared, then the move table count would be corrupted.
//  So if the uncounted flag is set, we do an add rather than a modify.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::MoveNotify(const CDomainRelativeObjId &droidCurrent,
                       const CDomainRelativeObjId &droidBirth,
                       const CDomainRelativeObjId &droidNew,
                       BOOL *pfQuotaExceeded )
{
    BOOL fAdded = FALSE, fModified = FALSE, fExists = FALSE;
    BOOL fDeleted = FALSE, fCounted = FALSE;

    // ignore cross-domain moves for now

    CDomainRelativeObjId droidNextNew;
    CDomainRelativeObjId droidNextBirth;
    CDomainRelativeObjId droidNewIDT, droidBirthIDT;

    TrkLog((TRKDBG_MOVE, TEXT("CTrkSvrSvc::MoveNotify\n   curr = %s\n   new = %s\n   birth = %s"),
             (const TCHAR*)CDebugString(droidCurrent),
             (const TCHAR*) CDebugString(droidNew),
             (const TCHAR*) CDebugString(droidBirth) ));

    // Does the entry exist already?

    fExists = _idt.Query( droidBirth, &droidNewIDT, &droidBirthIDT, &fDeleted, &fCounted );


#if DBG
    if( fExists )
        TrkLog(( TRKDBG_MOVE, TEXT("Birth entry already exists (%s, %s)"),
        fDeleted ? TEXT("deleted") : TEXT("not deleted"),
        fCounted ? TEXT("counted") : TEXT("not counted") ));
#endif

    if( fExists
        && 
        fCounted
        &&
        droidNewIDT == droidCurrent )
    {
        TrkLog(( TRKDBG_MOVE, TEXT("Attempting to modify existing entry") ));

        // The birth entry for this file already points to the source
        // of the notify.  We can just modify it.

        fModified = _idt.Modify( droidBirth, droidNew, droidBirth );
    }

    // If the modify didn't work or wasn't attempted, then just add this
    // new entry

    if( !fModified )
        fAdded = _idt.Add( droidCurrent, droidNew, droidBirth, pfQuotaExceeded );

    TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::MoveNotify() %s %s --> %s [%s]"),
        fModified ? TEXT("modified")
                  : (fAdded ? TEXT("added") : TEXT("couldn't be added") ),
        static_cast<const TCHAR*>(CAbbreviatedIDString(droidCurrent)),
        static_cast<const TCHAR*>(CAbbreviatedIDString(droidNew)),
        static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)) ));

}




//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::Search
//
//  Given a droid, look up the new droid for that object, and look up
//  the mcid of the machine that owns that droid's volume.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::Search(/*in, out*/ TRK_FILE_TRACKING_INFORMATION *pSearch)
{
    HRESULT                 hr = S_OK;                        
    CDomainRelativeObjId    droidNew;
    CDomainRelativeObjId    droidBirth;
    CMachineId              mcidNew;
    BOOL                    fFoundObject;

    IFDBG( TCHAR * ptszRoute=TEXT(""); )

    TrkLog(( TRKDBG_MEND, TEXT("Searching for %s"),
             static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidLast)) ));

    // If all the move notifies for a file have reached the DC, we can do a 
    // lookup based on the birth ID.  But if one segment is missing, this would fail.
    // So we look up based on the last ID first, and if that files try the birth ID.

    // Try to map the last ID to the current droid.

    fFoundObject = _idt.Query( pSearch->droidLast, &droidNew, &droidBirth);
    if ( fFoundObject )
    {
        IFDBG( ptszRoute = TEXT("'last' found in IDT"); )
    }
    else
    {
        // We couldn't find the last known ID.  Try mapping
        // from the birth ID.

        fFoundObject = _idt.Query( pSearch->droidBirth, &droidNew, &droidBirth );
        if( fFoundObject )
        {
            IFDBG( ptszRoute = TEXT("'birth' found in IDT"); )
        }
    }


    // Did we find the new droid for the file?

    if ( fFoundObject )
    {
        // Yes, we found it.  Is it really the same file (the birth ID matches)?

        if( droidBirth != pSearch->droidBirth )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Birth ID unexpected:\n   %s,\n   %s,\n   %s"),
                     (const TCHAR*) CDebugString(droidBirth),
                     (const TCHAR*) CDebugString(pSearch->droidBirth),
                     (const TCHAR*) CDebugString(droidNew) ));
            pSearch->hr = TRK_E_NOT_FOUND;
            goto Exit;
        }
        
        // We have a good ID.  This file may have multiple segments in the DS.
        // Starting with the one we have, scan across any additional segments
        // to find the most up-to-date droid.

        CDomainRelativeObjId droidList[MAX_SHORTENABLE_SEGMENTS];
        int       cSegments = 0;
        BOOL fStringDeleted = FALSE;
    
        Scan(
            NULL,
            NULL,
            droidBirth,
            droidList,
            sizeof(droidList)/sizeof(droidList[0]),
            &cSegments,
            &droidNew,
            &fStringDeleted
            );

    }
    else
    {
        // We couldn't find either the birth or last ID.

        pSearch->hr = TRK_E_NOT_FOUND;
        TrkLog(( TRKDBG_MEND, TEXT("neither 'birth' nor 'last' found") ));
    }

    // If we found the object in the move table, look up the machine ID in the
    // volume table.

    if (fFoundObject)
    {
        TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::Search( birth=%s last=%s ) successful, 'new=%s', %s"),
                static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidBirth)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidLast)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(droidNew)),
                ptszRoute ));

        // Find the volume that holds this droid.

        pSearch->hr = _voltab.FindVolume( droidNew.GetVolumeId(),
                                          &mcidNew );
        if( S_OK == pSearch->hr )
        {
            // We found the volume.

            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, volid found (%s -> %s)"),
                     (const TCHAR*) CDebugString(droidNew.GetVolumeId()),
                     (const TCHAR*) CDebugString(mcidNew) ));

            pSearch->hr = S_OK;
            pSearch->droidLast = droidNew;
            pSearch->mcidLast = mcidNew;
        }
        else
        {
            // We were able to find the object in the move table, but couldn't
            // find the volume in the volume table.

            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, volid not found (%s, %08x)"),
                     (const TCHAR*) CDebugString(droidNew.GetVolumeId()),
                     pSearch->hr ));
            pSearch->hr = TRK_E_NOT_FOUND;
        }

    }
    else
    {
        HRESULT hr = S_OK;

        // We couldn't find the object in the move table.

        TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::Search( birth=%s last=%s ) not found, %s"),
                    static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidBirth)),
                    static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidLast)),
                    ptszRoute));


        // As an optimization, try looking up the last volume anyway.  When this
        // search request fails, the trkwks service typically looks up the location
        // of the volume ID in droidLast, so we do that lookup now instead of forcing
        // trkwks to make a separate request.

        hr = _voltab.FindVolume( pSearch->droidLast.GetVolumeId(),
                                 &mcidNew );
        if( S_OK == hr )
        {
            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, but last volid found (%s -> %s)"),
                     (const TCHAR*) CDebugString(pSearch->droidLast.GetVolumeId()),
                     (const TCHAR*) CDebugString(mcidNew) ));

            pSearch->hr = TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND;
            pSearch->mcidLast = mcidNew;
        }
        else
        {
            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, volid not found either (%s, %08x)"),
                     (const TCHAR*) CDebugString(pSearch->droidLast.GetVolumeId()),
                     pSearch->hr ));
            pSearch->hr = TRK_E_NOT_FOUND_AND_LAST_VOLUME_NOT_FOUND;
        }
    
    
    }

Exit:

    return;
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::old_Search
//
//  This method is provided for compatibility with NT5/Beta2 clients.  Those
//  clients would do two RPCs, one to get the new droid, then another to map
//  the volid in that droid to an mcid.  In the modern SEARCH request, the 
//  client gets both back in a single call.
//
//  The distinction between the two kinds of clients is made by the 
//  TRKSVR_MESSAGE_TYPE in the request.  Old clients pass the value
//  now defined as old_SEARCH, new clients pass the value SEARCH.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::old_Search(/*in, out*/ old_TRK_FILE_TRACKING_INFORMATION *pSearch)
{
    TRK_FILE_TRACKING_INFORMATION FileTrkInfo;

    FileTrkInfo.droidBirth = pSearch->droidBirth;
    FileTrkInfo.droidLast = pSearch->droidLast;

    Search(&FileTrkInfo);
    
    pSearch->hr = FileTrkInfo.hr;
    pSearch->droidLast = FileTrkInfo.droidLast;
}




//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::Timer
//
//  This callback method is called by the GC timer when it's time to do a
//  GC.
//
//  This method doesn't raise.
//
//+----------------------------------------------------------------------------


PTimerCallback::TimerContinuation
CTrkSvrSvc::Timer( ULONG ulTimerContext )
{
    HRESULT hr = S_OK;
    BOOL fInvalidateCache = FALSE;
    TimerContinuation continuation = CONTINUE_TIMER;
    NTSTATUS Status = STATUS_SUCCESS;

    TrkLog(( TRKDBG_SVR, TEXT("\nGC timer has fired") ));

    __try
    {
        // Only the designated DC does garbage collecting.
        if( !_qtable.IsDesignatedDc( TRUE ) ) // TRUE => raise on error
        {
            TrkLog(( TRKDBG_SVR, TEXT("Not GC-ing; not the designated DC") ));
            continuation = CONTINUE_TIMER;
            __leave;
        }

        // See if this domain is too young to do anything.

        if( _refreshSequence.GetSequenceNumber()
            < 
            static_cast<SequenceNumber>(_configSvr.GetGCMinCycles()) )
        {
            TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                     TEXT("Nothing to GC (%d)"),
                     _refreshSequence.GetSequenceNumber() ));

            continuation = CONTINUE_TIMER;
            __leave;
        }

        // Is this the part one of the timer ?

        if( !_fHesitatingBeforeGC )
        {
            // Yes, this is part one.  We'll do some work, then 
            // reset the timer for a small delay (so that we don't
            // do a bunch of work during system initialization).

            #if DBG
            {
                if( _configSvr.GetGCHesitation() > (5*60) )
                    TrkLog(( TRKDBG_SVR, TEXT("Hesitating for %d minutes before running GC"),
                             _configSvr.GetGCHesitation() / 60 ));
                else
                    TrkLog(( TRKDBG_SVR, TEXT("Hesitating for %d seconds before running GC"),
                             _configSvr.GetGCHesitation() ));
            }
            #endif


            _fHesitatingBeforeGC = TRUE;

            _timerGC.ReInitialize( _configSvr.GetGCHesitation() ); // Doesn't raise
            continuation = CONTINUE_TIMER;

        }
        else
        {
            _fHesitatingBeforeGC = FALSE;

            _Stats.cEntriesGCed = 0;

            // Update the sequence number

            _refreshSequence.IncrementSequenceNumber();
            TrkLog(( TRKDBG_SVR, TEXT("Updated the GC counter to %d"),
                     _refreshSequence.GetSequenceNumber() ));

            // See if we need to invalidate the move table count cache (once a month).
            // This is done for robustness, so that if the count gets out of sync for any
            // reason, we self-correct. _MoveCounterReset holds the sequence number
            // of the last time we did an invalidate.

            if( (SequenceNumber) _MoveCounterReset.GetValue()
                >=
                _refreshSequence.GetSequenceNumber() )
            {
                // Invalid value
                TrkLog(( TRKDBG_WARNING,
                         TEXT("_MoveCounterReset is invalid (%d, %d), resetting"),
                         _MoveCounterReset.GetValue(),
                         _refreshSequence.GetSequenceNumber() ));
                _MoveCounterReset.Set
                    ( (DWORD) _refreshSequence.GetSequenceNumber() );
            }
            else if( _MoveCounterReset.GetValue() + _configSvr.GetGCDivisor()
                     <= _refreshSequence.GetSequenceNumber()
                   )
            {
                TrkLog(( TRKDBG_SVR | TRKDBG_GARBAGE_COLLECT,
                         TEXT("Cache will be invalidated (%d)"), _MoveCounterReset.GetValue() ));
                fInvalidateCache = TRUE;
            }

            // Calculate the seq number of the oldest entry to keep.

            ULONG seqOldestToKeep = _refreshSequence.GetSequenceNumber() - _configSvr.GetGCMinCycles() + 1;

            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("\nGarbage collecting all entries older than %d"),
                seqOldestToKeep));

            // Delete old entries from the move table

            _Stats.cEntriesGCed
                += (SHORT)_idt.GarbageCollect( _refreshSequence.GetSequenceNumber(),
                                               seqOldestToKeep, 
                                               _svcctrl.GetStopFlagAddress() );

            // And delete old entries from the volume table

            _Stats.cEntriesGCed
                += (SHORT)_voltab.GarbageCollect( _refreshSequence.GetSequenceNumber(),
                                                  seqOldestToKeep, 
                                                  _svcctrl.GetStopFlagAddress() );

            _OperationLog.Add( COperationLog::TRKSVR_GC, S_OK, CMachineId(MCID_INVALID),
                               seqOldestToKeep, _Stats.cEntriesGCed );

            // Reset the timer to its normal period.

            _timerGC.ReInitialize( _configSvr.GetGCPeriod() / _configSvr.GetGCDivisor() );
            continuation = CONTINUE_TIMER;
        
        }

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkLog(( TRKDBG_WARNING,
                 TEXT("Ignoring exception in CTrkSvrSvc::Timer (%08x)"),
                 hr ));
        _OperationLog.Add( COperationLog::TRKSVR_GC, hr, CMachineId(MCID_INVALID) );
    }

    // The Quota table's cached counts may be bad now that we've deleted
    // entries from the tables.

    if( fInvalidateCache )
    {
        _qtable.InvalidateCache();
        _MoveCounterReset.Set( (DWORD) _refreshSequence.GetSequenceNumber() );
    }

    TrkAssert( _timerGC.IsRecurring() );
    return( continuation );
}





SequenceNumber
CTrkSvrSvc::GetSequenceNumber( const CMachineId & mcidClient, const CVolumeId & volume )
{
    HRESULT hr;
    SequenceNumber seq;
    FILETIME ftLastRefresh;
    
    hr = _voltab.QueryVolume(mcidClient, volume, &seq, &ftLastRefresh);

    if( S_OK != hr )
    {
        // Raise on error.  E.g. if mcidClient doesn't own this volume.
        TrkLog(( TRKDBG_ERROR,
                TEXT("CTrkSvrSvc::GetSequenceNumber --> %08x"), hr ));
        TrkRaiseException(hr);
    }

    return(seq);
}

void
CTrkSvrSvc::SetSequenceNumber( const CVolumeId & volume,    // must ensure that validation already done for volume
                               SequenceNumber seq )
{
    HRESULT hr;

    hr = _voltab.SetSequenceNumber( volume, seq );
    if (hr != S_OK)
    {
        TrkRaiseException( hr );
    }
}

HRESULT
CTrkSvrSvc::MoveNotify( const CMachineId & mcidClient,
                        TRKSVR_CALL_MOVE_NOTIFICATION * pMove )
{
    HRESULT hr = S_OK;
    SequenceNumber seqExpected;
    CVolumeId volid;

    InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyRequests) );

    pMove->cProcessed = 0;

    //
    // ensure we have at least one notification because we assume that
    // the current volume of the first notification is the same for all
    // of the notifications in this rpc.
    //

    if (pMove->cNotifications == 0)
    {
        return(S_OK);
    }

    // Get the machine for this volume and the sequence number expected
    // ensure that the machine is actually the owner of the volume.
    // (This will raise if mcidClient doesn't own this volid.)

    volid = *pMove->pvolid;
    seqExpected = GetSequenceNumber(mcidClient, volid);
    

    // Is this the sequence number we were expecting for this client volume?

    TrkLog((TRKDBG_MOVE, TEXT("sequence no %d %sexpected for %s (%sforcing, expected %d)"),
            pMove->seq,
            seqExpected != pMove->seq ? TEXT("un") : TEXT(""),
            (const TCHAR*) CDebugString(volid),
            pMove->fForceSeqNumber ? TEXT("") : TEXT("not "),
            seqExpected
            ));


    if( seqExpected != pMove->seq )
    {
        // No, it's not the right sequence number.

        if( !pMove->fForceSeqNumber )
        {
            // The caller hasn't requested an override, so this is an error.

            pMove->seq = seqExpected;
            return TRK_S_OUT_OF_SYNC;
        }
    }

    //
    // Before processing the actual move notifications, ensure that we
    // have enough quota... assume that each move notify is going to
    // to need one unit of quota (the writes will actually update
    // the quota accurately.)
    //
#ifdef VOL_QUOTA
    if (pMove->cNotifications > GetAvailableNotificationQuota( ) )
    {
        TrkRaiseException( TRK_E_NOTIFICATION_QUOTA_EXCEEDED );
    }
#endif

    while (pMove->cProcessed < pMove->cNotifications)
    {
        // the only errors are fatal since we always make a record of
        // a notification or merge it with an existing record

        BOOL fQuotaExceeded = FALSE;

        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_SVR, TEXT("Stopping move-notifications due to too many writes (%d)"),
                     NumWritesThisHour() ));
            break;
        }

        MoveNotify(CDomainRelativeObjId( volid, pMove->rgobjidCurrent[pMove->cProcessed] ),
                   pMove->rgdroidBirth[pMove->cProcessed],
                   pMove->rgdroidNew[pMove->cProcessed],
                   &fQuotaExceeded
                   );

        if( fQuotaExceeded )
        {
            hr = TRK_S_NOTIFICATION_QUOTA_EXCEEDED;
            break;
        }

        pMove->cProcessed++;
        IncrementWritesPerHour();

        RaiseIfStopped();
    }

    if( 0 != pMove->cProcessed )
    {
        SetSequenceNumber( volid, pMove->seq + pMove->cProcessed );
        TrkLog(( TRKDBG_SVR, TEXT("Updated sequence number to %d"), pMove->seq+pMove->cProcessed ));
    }

    if( 0 != pMove->cNotifications )
    {
        //TrkLog(( TRKDBG_WARNING, TEXT("pMove = %p"), pMove ));
        pMove->cNotifications = 0;  // don't need to send the data back

        //TrkLog(( TRKDBG_WARNING, TEXT("Free rgdroidNew (%p)"), pMove->rgdroidNew ));
        //MIDL_user_free( pMove->rgdroidNew );
        pMove->rgdroidNew = NULL;

        //TrkLog(( TRKDBG_WARNING, TEXT("Free rgobjidCurrent (%p)"), pMove->rgobjidCurrent ));
        //MIDL_user_free( pMove->rgobjidCurrent );
        pMove->rgobjidCurrent = NULL;

        //TrkLog(( TRKDBG_WARNING, TEXT("Free rgdroidBirth (%p)"), pMove->rgdroidBirth ));
        //MIDL_user_free( pMove->rgdroidBirth );
        pMove->rgdroidBirth = NULL;
    }

    return(hr);
}



BOOL
CTrkSvrSvc::VerifyMachineOwnsVolume( const CMachineId &mcid, const CVolumeId & volid )
{
    HRESULT hr;
    SequenceNumber       seq;
    FILETIME             ft;

    hr = _voltab.QueryVolume(
                mcid,
                volid,
                &seq,
                &ft);
    if (hr != S_OK)
        return FALSE;
    else
        return TRUE;
}



//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::DeleteNotify
//
//  Process a delete-notify request from a client.  This request provides
//  information about a file that has been deleted, so that we can purge
//  it from the move table.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::DeleteNotify( const CMachineId & mcidClient, TRKSVR_CALL_DELETE * pDelete )
{
    CVolumeId            vol;
    HRESULT              hr = TRK_S_VOLUME_NOT_FOUND;

    // Loop through all of the notifications in this batch.

    for (ULONG i=0; i < pDelete->cdroidBirth; i++)
    {
        // Look up the current location of the file, and if it
        // is on an owned volume, then allow the delete.

        CDomainRelativeObjId droidCurrent;
        CDomainRelativeObjId droidBirth;

        // Don't embark on a slow operation if the service is stopping.
        RaiseIfStopped();

        // If we've already written a lot to the DS in the past hour,
        // abort so we don't flood the replication queue.

        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Stopping delete-notify due to too many writes") ));
            TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
        }

        // Read the existing entry for this file.

        if (_idt.Query(pDelete->adroidBirth[i], &droidCurrent, &droidBirth))
        {
            // The entry exists.

            TrkAssert(droidBirth == pDelete->adroidBirth[i]);

            // See if this is the same volume that we checked on the
            // previous iteration through the loop.  If so, no need to
            // look up again.

            if (vol == droidCurrent.GetVolumeId())
            {
                hr = S_OK;
            }
            else
            {
                // We need to check that whoever sent this delete-notify
                // request really owns the volume.

                vol = droidCurrent.GetVolumeId();
                if( !VerifyMachineOwnsVolume( mcidClient, vol ))
                {
                    TrkLog((TRKDBG_OBJID_DELETIONS,
                        TEXT("DeleteNotify _voltab.QueryVolume( %s ) -> %s\n"),
                        (const TCHAR*) CDebugString( vol ),
                        GetErrorString(hr) ));

                    vol = CVolumeId();
                }
            }

            // If the volume is owned, go ahead with the deletion.

            if (hr == S_OK)
            {
                BOOL f = _idt.Delete( pDelete->adroidBirth[i] );

                TrkLog((TRKDBG_OBJID_DELETIONS,
                    TEXT("DeleteNotify _idt.Delete( %s ) -> %s\n"),
                    (const TCHAR*) CDebugString( pDelete->adroidBirth[i] ),
                    f ? TEXT("Ok") : TEXT("Not Found") ));

                if( f )
                    IncrementWritesPerHour();
            }
        }   // if (_idt.Query(pDelete->adroidBirth[i], &droidCurrent, &droidBirth))

        else
        {
            // Attempted to delete an entry that doesn't exist.

            TrkLog((TRKDBG_OBJID_DELETIONS,
                TEXT("DeleteNotify _idt.Query( droidBirth=%s ) not found\n"),
                (const TCHAR*) CDebugString( pDelete->adroidBirth[i] ) ));
        }
    }

    if( 0 != pDelete->cdroidBirth )
    {
        //MIDL_user_free( pDelete->adroidBirth );
        //pDelete->adroidBirth = NULL;
        pDelete->cdroidBirth = 0;
    }

}

void
CTrkSvrSvc::Refresh( const CMachineId &mcidClient, TRKSVR_CALL_REFRESH * pRefresh )
{
    // save away the input and zero the output so we don't marshall a
    // ton of refresh info back to the client

    ULONG cSources = pRefresh->cSources;
    ULONG cVolumes = pRefresh->cVolumes;

    InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshRequests) );

    pRefresh->cSources = 0;
    pRefresh->cVolumes = 0;

    // Touch the move table entries

    for (ULONG i=0; i < cSources ; i++)
    {
        // Ensure we're not overloading the replication log
        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_SVR, TEXT("Aborting refresh due to writes-per-hour") ));
            TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
        }

        // Touch the entry in the move table.
        if( _idt.Touch( pRefresh->adroidBirth[i] ))
            IncrementWritesPerHour();
    }

    // Touch the volume table entries

    for (i=0; i < cVolumes ; i++)
    {
        // Ensure we're not overloading the replication log
        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_SVR, TEXT("Aborting refresh due to writes-per-hour") ));
            TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
        }

        // Ensure this volume is owned by the machine.
        // mikehill_test

        if( !VerifyMachineOwnsVolume( mcidClient, pRefresh->avolid[i] ))
        {
            TrkLog(( TRKDBG_WARNING,
                     TEXT("Machine can't touch volume it doesn't own (%s, %s)"),
                     (const TCHAR*) CDebugString(mcidClient),
                     (const TCHAR*) CDebugString(pRefresh->avolid[i]) ));
            continue;
        }

        // Touch the entry in the volume table
        if( _voltab.Touch( pRefresh->avolid[i] ))
            IncrementWritesPerHour();
    }


}

void
CTrkSvrSvc::Statistics( TRKSVR_STATISTICS *pStatistics )
{
    pStatistics->cSyncVolumeRequests      = _Stats.cSyncVolumeRequests;
    pStatistics->cSyncVolumeErrors        = _Stats.cSyncVolumeErrors;
    pStatistics->cSyncVolumeThreads       = _Stats.cSyncVolumeThreads;

    pStatistics->cCreateVolumeRequests    = _Stats.cCreateVolumeRequests;
    pStatistics->cCreateVolumeErrors      = _Stats.cCreateVolumeErrors;
    pStatistics->cClaimVolumeRequests     = _Stats.cClaimVolumeRequests;
    pStatistics->cClaimVolumeErrors       = _Stats.cClaimVolumeErrors;
    pStatistics->cQueryVolumeRequests     = _Stats.cQueryVolumeRequests;
    pStatistics->cQueryVolumeErrors       = _Stats.cQueryVolumeErrors;
    pStatistics->cFindVolumeRequests      = _Stats.cFindVolumeRequests;
    pStatistics->cFindVolumeErrors        = _Stats.cFindVolumeErrors;
    pStatistics->cTestVolumeRequests      = _Stats.cTestVolumeRequests;
    pStatistics->cTestVolumeErrors        = _Stats.cTestVolumeErrors;

    pStatistics->cSearchRequests          = _Stats.cSearchRequests;
    pStatistics->cSearchErrors            = _Stats.cSearchErrors;
    pStatistics->cSearchThreads           = _Stats.cSearchThreads;

    pStatistics->cMoveNotifyRequests      = _Stats.cMoveNotifyRequests;
    pStatistics->cMoveNotifyErrors        = _Stats.cMoveNotifyErrors;
    pStatistics->cMoveNotifyThreads       = _Stats.cMoveNotifyThreads;

    pStatistics->cRefreshRequests         = _Stats.cRefreshRequests;
    pStatistics->cRefreshErrors           = _Stats.cRefreshErrors;
    pStatistics->cRefreshThreads          = _Stats.cRefreshThreads;
    pStatistics->lRefreshCounter          = _refreshSequence.GetSequenceNumber();

    pStatistics->cDeleteNotifyRequests    = _Stats.cDeleteNotifyRequests;
    pStatistics->cDeleteNotifyErrors      = _Stats.cDeleteNotifyErrors;
    pStatistics->cDeleteNotifyThreads     = _Stats.cDeleteNotifyThreads;

    pStatistics->ftLastSuccessfulRequest  = _Stats.cftLastSuccessfulRequest;
    pStatistics->ftServiceStart           = _Stats.cftServiceStartTime;

    //pStatistics->ulGCIterationPeriod      = _Stats.ulGCIterationPeriod;
    //pStatistics->cEntriesToGC             = _Stats.cEntriesToGC;
    pStatistics->cEntriesGCed             = _Stats.cEntriesGCed;

    pStatistics->hrLastError              = _Stats.hrLastError;
    pStatistics->ftNextGC                 = _timerGC.QueryOriginalDueTime();
    pStatistics->cLowestAvailableRpcThreads=_cLowestAvailableThreads;
    pStatistics->cAvailableRpcThreads     = _cAvailableThreads;
    pStatistics->cMaxRpcThreads           = MAX_SVR_THREADS;

    pStatistics->cNumThreadPoolThreads    = g_cThreadPoolThreads;
    pStatistics->cMostThreadPoolThreads   = g_cThreadPoolMaxThreads;
    //pStatistics->SvcCtrlState             = _svcctrl.GetState();
    pStatistics->cMaxDsWriteEvents        = _Stats.cMaxDsWriteEvents;
    pStatistics->cCurrentFailedWrites     = _Stats.cCurrentFailedWrites;

    _qtable.Statistics( pStatistics );

    OSVERSIONINFO verinfo;
    memset( &verinfo, 0, sizeof(verinfo) );
    verinfo.dwOSVersionInfoSize = sizeof(verinfo);

    if( GetVersionEx( &verinfo ))
    {
        pStatistics->Version.dwMajor      = verinfo.dwMajorVersion;
        pStatistics->Version.dwMinor      = verinfo.dwMinorVersion;
        pStatistics->Version.dwBuildNumber  = verinfo.dwBuildNumber;
    }
    else
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed GetVersionInfo (%lu)"), GetLastError() ));
    }

    return;

}

HRESULT
CTrkSvrSvc::SyncVolume(const CMachineId & mcidClient, TRKSVR_SYNC_VOLUME * pSyncVolume,
                       ULONG cUncountedCreates )
{
    HRESULT hr = S_OK;

    switch (pSyncVolume->SyncType)
    {
    case CREATE_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cCreateVolumeRequests) );

        if( CheckWritesPerHour() )
        {
            hr = TRK_E_SERVER_TOO_BUSY;
            TrkLog(( TRKDBG_VOLTAB | TRKDBG_WARNING,
                     TEXT("Rejected CreateVolume, too many writes (%d)"),
                     NumWritesThisHour() ));
        }
        else
        {
            hr = _voltab.PreCreateVolume(
                    mcidClient,
                    pSyncVolume->secret,
                    cUncountedCreates,
                    &pSyncVolume->volume );
            if( SUCCEEDED(hr) )
                IncrementWritesPerHour();
        }

        if(hr == S_OK)
        {
            TrkLog((TRKDBG_VOLTAB,
                TEXT("CreateVolume(machine=%s secret=%s volid(out)=%s) -> VOLUME_OK"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->secret),
                (const TCHAR*) CDebugString(pSyncVolume->volume) ));
        }
        else
        {
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cCreateVolumeErrors) );

            TrkLog((TRKDBG_VOLTAB,
                TEXT("CreateVolume(machine=%s secret=%s) -> CreateFailed (%08x)"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->secret),
                hr ));
        }
        break;

    case QUERY_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cQueryVolumeRequests) );

        hr = _voltab.QueryVolume(
                mcidClient,
                pSyncVolume->volume,
                &pSyncVolume->seq,
                &pSyncVolume->ftLastRefresh
                );

        TrkLog((TRKDBG_VOLTAB,
                TEXT("QueryVolume(machine=%s volid=%s seq(out)=%d ftLastRefresh(out)=%d) -> %s"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                pSyncVolume->seq,
                pSyncVolume->ftLastRefresh.dwLowDateTime,
                GetErrorString(hr)));

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cQueryVolumeErrors) );

        break;

    case FIND_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cFindVolumeRequests) );

        hr = _voltab.FindVolume(
                pSyncVolume->volume,
                &pSyncVolume->machine
                );

        TrkLog((TRKDBG_VOLTAB,
                TEXT("FindVolume(volid=%s machine(out)=%s) -> %s"),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                (const TCHAR*) CDebugString(pSyncVolume->machine),
                GetErrorString(hr)));

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cFindVolumeErrors) );

        break;

    case CLAIM_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cClaimVolumeRequests) );

        if( CheckWritesPerHour() )
        {
            hr = TRK_E_SERVER_TOO_BUSY;
            TrkLog(( TRKDBG_VOLTAB | TRKDBG_WARNING,
                     TEXT("Rejected ClaimVolume, too many writes (%d)"),
                     NumWritesThisHour() ));
        }
        else
        {
            hr = _voltab.ClaimVolume(
                    mcidClient,
                    pSyncVolume->volume,
                    pSyncVolume->secretOld,
                    pSyncVolume->secret,
                    &pSyncVolume->seq,
                    &pSyncVolume->ftLastRefresh
                    );
            if( S_OK == hr )    // Might return TRK_S_VOLUME_NOT_FOUND
                IncrementWritesPerHour();
        }

        TrkLog((TRKDBG_VOLTAB,
                TEXT("ClaimVolume(machine=%s volid=%s secret=%s->%s seq(out)=%d ftLastRefresh(out)=%s) -> %s"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                (const TCHAR*) CDebugString(pSyncVolume->secretOld),
                (const TCHAR*) CDebugString(pSyncVolume->secret),
                pSyncVolume->seq,
                (const TCHAR*) CDebugString(pSyncVolume->ftLastRefresh),
                GetErrorString(hr)));

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cClaimVolumeErrors) );

        break;

    case TEST_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cTestVolumeRequests) );
    
        if( !(_configSvr.GetTestFlags() & TRK_TEST_FLAG_ALLOC_TEST_VOLUME) )
        {
            hr = E_NOTIMPL;
            break;
        }

        if( CVolumeSecret() != pSyncVolume->secret )
        {
            hr = _voltab.SetSecret( pSyncVolume->volume, pSyncVolume->secret );
            if( FAILED(hr) ) break;
        }

        hr = _voltab.SetSequenceNumber( pSyncVolume->volume, pSyncVolume->seq );
        if( FAILED(hr) ) break;

        if( CMachineId() != pSyncVolume->machine )
        {
            hr = _voltab.SetMachine( pSyncVolume->volume, pSyncVolume->machine );
            if ( FAILED(hr) ) break;
        }

        if( SUCCEEDED(hr) )
            IncrementWritesPerHour();

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cTestVolumeErrors) );

        break;

    case DELETE_VOLUME:

        //InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteVolumeRequests) );

        if( CheckWritesPerHour() )
        {
            hr = TRK_E_SERVER_TOO_BUSY;
            TrkLog(( TRKDBG_VOLTAB | TRKDBG_WARNING,
                     TEXT("Rejected DeleteVolume, too many writes (%d)"),
                     NumWritesThisHour() ));
        }
        else
        {
            hr = _voltab.DeleteVolume(
                    mcidClient,
                    pSyncVolume->volume
                    );
            if( SUCCEEDED(hr) )
                IncrementWritesPerHour();
        }

        TrkLog((TRKDBG_VOLTAB,
                TEXT("DeleteVolume(machine=%s volid=%s  -> %s"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                GetErrorString(hr)));

        /*
        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cClaimVolumeErrors) );
        */

        break;

    default:
        TrkAssert(0 && "unknown switch type in SyncVolume");
        hr = TRK_S_VOLUME_NOT_FOUND;
        break;
    }

    return(hr);
}


//
// If we have 0 threads, then accept any pri <=9
// If we have 1 thread, then accept  any pri <=9
// If we have 2 threads, then accept any pri <=7
// If we have 3 threads, then accept any pri <=6
// If we have 4 threads, then accept any pri <=5
// If we have 5 threads, then accept any pri <=4
// If we have 6 threads, then accept any pri <=3
// If we have 7 threads, then accept any pri <=0
// If we have 8 threads, then accept any pri <=0
// If we have 9 threads, then accept any pri <=0
// If we have 10 threads, don't accept any
//

BOOL
CTrkSvrSvc::CountPrioritizedThread( const TRKSVR_MESSAGE_UNION * pMsg )
{

    static LONG Accept[10] = { 0, 0, 0, 3, 4, 5, 6, 7, 9, 9 };

    TrkAssert( ELEMENTS(Accept) == MAX_SVR_THREADS );

    LONG l = InterlockedDecrement( &_cAvailableThreads ); 

    // It's not worth a lock to protect this statistic, we'll just hope that we
    // don't get pre-empted during the update.
    _cLowestAvailableThreads = min( _cLowestAvailableThreads, l );

    TrkAssert( l >= -1 && l < MAX_SVR_THREADS );

    if (l == -1 || pMsg->Priority > Accept[ l ])
    {
        InterlockedIncrement( &_cAvailableThreads );
        return( FALSE );
    }

    return(TRUE);
}

void
CTrkSvrSvc::ReleasePrioritizedThread()
{
    LONG l = InterlockedIncrement( &_cAvailableThreads );

    TrkAssert( l >= 0 && l <= MAX_SVR_THREADS );
}

HRESULT
CTrkSvrSvc::CreateVolume(const CMachineId & mcidClient, const TRKSVR_SYNC_VOLUME& pSyncVolume)
{
    return _voltab.AddVolidToTable(pSyncVolume.volume, mcidClient, pSyncVolume.secret );
}


void
CTrkSvrSvc::OnRequestStart( TRKSVR_MESSAGE_TYPE MsgType )
{
    switch( MsgType )
    {
    case SEARCH:
    case old_SEARCH:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSearchRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSearchThreads) );
        break;

    case MOVE_NOTIFICATION:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyThreads) );
        break;

    case REFRESH:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshThreads) );
        break;

    case SYNC_VOLUMES:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeThreads) );
        break;

    case DELETE_NOTIFY:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyThreads) );
        break;

    case STATISTICS:
        break;

    default:
        TrkLog(( TRKDBG_ERROR, TEXT("Invalid MsgType in CTrkSvrSvc::OnRequestStart(%d)"),
                 MsgType ));
        TrkAssert( FALSE );
    }
}


void
CTrkSvrSvc::OnRequestEnd( TRKSVR_MESSAGE_UNION * pMsg, const CMachineId &mcid, HRESULT hr )
{
    int i = 0;

    __try
    {
        switch( pMsg->MessageType )
        {
        case SEARCH:
        case old_SEARCH:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cSearchThreads) );
            if( FAILED(hr)
                ||
                ( 1 <= pMsg->Search.cSearch && S_OK != pMsg->Search.pSearches->hr ))
            {
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSearchErrors) );
            }
            _OperationLog.Add( COperationLog::TRKSVR_SEARCH, hr, mcid, pMsg->Search.pSearches->droidBirth );

            break;

        case MOVE_NOTIFICATION:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyThreads) );
            if( S_OK != hr  )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_MOVE_NOTIFICATION, hr, mcid );

            break;

        case REFRESH:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cRefreshThreads) );
            if( FAILED(hr) )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_REFRESH, hr, mcid, pMsg->Refresh.cSources, pMsg->Refresh.cVolumes );

            break;

        case SYNC_VOLUMES:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeThreads) );
            if( FAILED(hr) )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_SYNC_VOLUMES, hr, mcid );
            break;

        case DELETE_NOTIFY:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyThreads) );
            if( FAILED(hr) )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_DELETE_NOTIFY, hr, mcid );

            break;

        case STATISTICS:
            break;

        }

        if( FAILED(hr) )
            SetLastError( hr );
        else if( STATISTICS != pMsg->MessageType )
            _Stats.cftLastSuccessfulRequest = CFILETIME();
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in OnRequestEnd") ));
    }

    return;
}



//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::SvrMessage
//
//  This is the primary starting point for processing of the trksvr
//  service's LnkSvrMessage RPC method.  For the most part, it looks
//  at the MessageType (the request is in the form of a union, with
//  a message-type and type-appropriate parameters), then switches
//  to specific handler routine.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkSvrSvc::SvrMessage(
    handle_t IDL_handle,
    TRKSVR_MESSAGE_UNION * pMsg)
{
    HRESULT hr = S_OK;
    ULONG i;
    ULONG cSources;
    CMachineId mcidClient;
    SThreadFromPoolState OriginalThreadFromPoolState;

    if (GetState() != SERVICE_RUNNING)
    {
        return(TRK_E_SERVICE_NOT_RUNNING);
    }

    // If we're getting busy (wrt active threads), we may have 
    // to reject this request, based on how busy we are and the
    // priority of the request.

    if (!CountPrioritizedThread( pMsg ))
    {
        return(TRK_E_SERVER_TOO_BUSY);
    }


    __try
    {

        // Set thread-specific settings, saving the old settings.
        OriginalThreadFromPoolState = InitializeThreadFromPool();

        // Update statistics
        OnRequestStart( pMsg->MessageType );

        // Query the IDL handle for the client's mcid.  Don't do it, though, if
        // we're not using secure RPC (which only happens in testing),
        // or if the message type is statistics.

        if( STATISTICS == pMsg->MessageType )
        {
            // All messages that come in to this routine are from a machine account
            // (in which trkwks runs).  The exception to this rule is the Statistics
            // request, which comes from a user.  We'll allow all Authenticated Users
            // access to the statistics (they can access the DS tables by default
            // anyway).

            if( RequireSecureRPC() )
            {
                RPC_STATUS RpcStatus;

                RpcStatus = RpcImpersonateClient(IDL_handle);
                if (RpcStatus != RPC_S_OK)
                    TrkRaiseWin32Error(RpcStatus);
                RpcRevertToSelf();
            }
            mcidClient = CMachineId( MCID_LOCAL );
        }
        else
        {
            mcidClient = NULL != pMsg->ptszMachineID && !g_ptrksvr->RequireSecureRPC()
                                    ? CMachineId(pMsg->ptszMachineID)
                                    : CMachineId(IDL_handle);
        }


        // Check for a client doing a denial-of-service attack.

        if( RequireSecureRPC() )    // Always true except in testing
            CheckClient(mcidClient);

        // Switch on the message type.

        switch (pMsg->MessageType)
        {

        case SEARCH:

            TrkLog((TRKDBG_MEND|TRKDBG_SVR, TEXT("SEARCH from \\\\%s"),    
                    (const TCHAR*) CDebugString( mcidClient )));

            for (i=0; i<pMsg->Search.cSearch; i++)
            {
                TrkAssert( NULL != pMsg->Search.pSearches );
                pMsg->Search.pSearches[i].hr = TRK_E_UNAVAILABLE;
            }
        
            for (i=0; i<pMsg->Search.cSearch; i++)
            {
                Search(&pMsg->Search.pSearches[i]);
            }
            break;

        case old_SEARCH:

            TrkLog((TRKDBG_MEND|TRKDBG_SVR, TEXT("old_SEARCH from \\\\%s"),
                    (const TCHAR*) CDebugString( mcidClient )));

            for (i=0; i<pMsg->old_Search.cSearch; i++)
            {
                pMsg->old_Search.pSearches[i].hr = TRK_E_UNAVAILABLE;
            }
        
            for (i=0; i<pMsg->old_Search.cSearch; i++)
            {
                old_Search(&pMsg->old_Search.pSearches[i]);
            }
            break;

        case MOVE_NOTIFICATION:

            TrkLog((TRKDBG_MOVE|TRKDBG_SVR, TEXT("MOVE_NOTIFICATION from \\\\%s (%d notifications)"),
                    (const TCHAR*) CDebugString( mcidClient ),
                    pMsg->MoveNotification.cNotifications ));

            hr = MoveNotify( mcidClient, &pMsg->MoveNotification );
            break;

        case REFRESH:

            TrkLog((TRKDBG_GARBAGE_COLLECT|TRKDBG_SVR, TEXT("REFRESH from \\\\%s"),
                    (const TCHAR*) CDebugString( mcidClient )));

            Refresh( mcidClient, &pMsg->Refresh );

            break;

        case SYNC_VOLUMES:
        {

            BOOL                fHaveCreateVolume = FALSE;
            TRKSVR_SYNC_VOLUME  rgCopyOfSyncVolumes[NUM_VOLUMES];
            ULONG cUncountedCreates = 0;

            // Validate the number of volumes in this request to protect against an unruly
            // client.

            if(pMsg->SyncVolumes.cVolumes > NUM_VOLUMES)
            {
                TrkLog((TRKDBG_ERROR, TEXT("Number of volumes exceeded per machine limit %d"), pMsg->SyncVolumes.cVolumes));
                TrkRaiseException( E_INVALIDARG );
            }

            // Pre-initialize the return buffer.

            for (i=0; i < pMsg->SyncVolumes.cVolumes; i++)
            {
                pMsg->SyncVolumes.pVolumes[i].hr = TRK_S_VOLUME_NOT_FOUND;
            }

            // Perform the sync for each of the volumes.

            for (i=0; i < pMsg->SyncVolumes.cVolumes; i++)
            {
                // Perform the sync.

                pMsg->SyncVolumes.pVolumes[i].hr
                    = SyncVolume(mcidClient, pMsg->SyncVolumes.pVolumes + i, cUncountedCreates );

                // Keep track of the number of CREATE_VOLUME sub-requests.

                if(CREATE_VOLUME == pMsg->SyncVolumes.pVolumes[i].SyncType &&
                   pMsg->SyncVolumes.pVolumes[i].hr == S_OK)
                {
                    fHaveCreateVolume = TRUE;
                    cUncountedCreates++;
                }

                // Make a copy of the newly generated volume id so that we can
                // add it to the DS later.  We want to make sure we don't 
                // add the entry to the DS until we're sure it made it onto
                // the client.
                // (There once was a bug where the newly created
                // volid was written to the DS, then returned to the client,
                // but the client wasn't receiving the response due to an
                // security problem.  Consequently, the client kept asking
                // and asking for the volume ID, all of which went into the DS.
                // So now we make sure the client gets it, and we have a
                // per-client volume quota.)

                rgCopyOfSyncVolumes[i] = pMsg->SyncVolumes.pVolumes[i];
            }


#ifdef VOL_REPL
            if (pMsg->SyncVolumes.ppVolumeChanges != NULL)
            {
                CFILETIME ftChangesUntilThisTime;
                CVolumeMap VolMap;

                if (CFILETIME(-1) != CFILETIME(pMsg->SyncVolumes.ftFirstChange))
                {
                    _voltab.QueryVolumeChanges(
                        CFILETIME(pMsg->SyncVolumes.ftFirstChange),
                        &VolMap );

                    VolMap.MoveTo( &pMsg->SyncVolumes.cChanges, pMsg->SyncVolumes.ppVolumeChanges );

                    pMsg->SyncVolumes.ftFirstChange = ftChangesUntilThisTime;
                }
            }
#endif

            // If there were successful CREATE_VOLUME sub-requests in this
            // SYNC_VOLUME request, send the new IDs back to the client now,
            // and write the volids to the DS.

            if(TRUE == fHaveCreateVolume)
            {
                TrkLog((TRKDBG_LOG, TEXT("Calling back to trkwks")));
                __try
                {
                    // Note: A trkwks could tie up several threads by blocking
                    // in this callback.  Worse case this DOS attack blocks
                    // trksvr, but it can't cause any great harm to the DC or DS.

                    hr = LnkSvrMessageCallback(pMsg);
                    TrkLog(( TRKDBG_SVR, TEXT("LnkSvrMessageCallback returned %08x"), hr ));
                }
                __except(BreakOnDebuggableException())
                {
                    hr = GetExceptionCode();
                    TrkLog((TRKDBG_ERROR, TEXT("Exception in Callback, %08x"), hr));
                }

                // If callback is successful, add the created volumes into the DS. Otherwise don't do
                // anything.

                TrkAssert(pMsg->SyncVolumes.cVolumes <= 26);
                if( SUCCEEDED(hr) )
                {
                    for (i=0; i < pMsg->SyncVolumes.cVolumes; i++)
                    {
                        if(CREATE_VOLUME == pMsg->SyncVolumes.pVolumes[i].SyncType && S_OK == pMsg->SyncVolumes.pVolumes[i].hr)
                        {
                            pMsg->SyncVolumes.pVolumes[i].hr = 
                                CreateVolume(mcidClient, rgCopyOfSyncVolumes[i]);
                        }
                    }
                }

                pMsg->SyncVolumes.cVolumes = 0;
            }

            break;
        }

        case DELETE_NOTIFY:

            TrkLog((TRKDBG_OBJID_DELETIONS|TRKDBG_SVR,
                TEXT("DELETE_NOTIFY from \\\\%s"),
                     (const TCHAR*) CDebugString( mcidClient )));

            DeleteNotify( mcidClient, &pMsg->Delete );
            break;

        case STATISTICS:

            TrkLog(( TRKDBG_SVR, TEXT("TRKSVR_STATISTICS"),
                     (const TCHAR*) CDebugString(mcidClient) ));

            memset( &pMsg->Statistics, 0, sizeof(TRKSVR_STATISTICS) );
            Statistics( &pMsg->Statistics );

            break;

        default:
            hr = TRK_E_UNKNOWN_SVR_MESSAGE_TYPE;
            break;
        }
    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
        TrkLog((TRKDBG_ERROR, TEXT("LnkSvrMessage exception %08X caught during %s"),
                                   hr, 
                                   (const TCHAR*) CDebugString(pMsg->MessageType) ));
    }

    // Update statistics
    OnRequestEnd( pMsg, mcidClient, hr );

    ReleasePrioritizedThread();

    // Restore the thread-specif settings.
    UnInitializeThreadFromPool( OriginalThreadFromPoolState );

    return(hr);
}




HRESULT
StubLnkSvrMessage_Old(
    handle_t IDL_handle,
    TRKSVR_MESSAGE_UNION_OLD * pMsg)
{
    HRESULT hr;

    TrkLog((TRKDBG_SVR, TEXT("Received downlevel call: ... thunking")));

    TRKSVR_MESSAGE_UNION Msg2;

    Msg2.MessageType = pMsg->MessageType;
    Msg2.Priority = PRI_5;

    switch (Msg2.MessageType)
    {
        case (SEARCH):
            Msg2.Search = pMsg->Search;
            break;
        case (MOVE_NOTIFICATION):
            Msg2.MoveNotification = pMsg->MoveNotification;
            break;
        case (REFRESH):
            Msg2.Refresh = pMsg->Refresh;
            break;
        case (SYNC_VOLUMES):
            Msg2.SyncVolumes = pMsg->SyncVolumes;
            break;
        case (DELETE_NOTIFY):
            Msg2.Delete = pMsg->Delete;
            break;
    }

    Msg2.ptszMachineID = pMsg->ptszMachineID;

    hr = StubLnkSvrMessage( IDL_handle, &Msg2 );

    switch (Msg2.MessageType)
    {
        case (SEARCH):
            pMsg->Search = Msg2.Search;
            break;
        case (MOVE_NOTIFICATION):
            pMsg->MoveNotification = Msg2.MoveNotification;
            break;
        case (REFRESH):
            pMsg->Refresh = Msg2.Refresh;
            break;
        case (SYNC_VOLUMES):
            pMsg->SyncVolumes = Msg2.SyncVolumes ;
            break;
        case (DELETE_NOTIFY):
            pMsg->Delete = Msg2.Delete;
            break;
    }

    pMsg->ptszMachineID = Msg2.ptszMachineID;

    return(hr);

}

// must return a positive number (success code) if it doesn't want the caller
// to find another DC to do it on.

HRESULT
StubLnkSvrMessage(
    handle_t IDL_handle,
    TRKSVR_MESSAGE_UNION * pMsg)
{
    return( g_ptrksvr->SvrMessage( IDL_handle, pMsg ));
}


void
CTrkSvrRpcServer::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData, CTrkSvrConfiguration * pTrkSvrConfig )
{
    RPC_STATUS          rpcstatus;
    NET_API_STATUS      netstatus;

    // Ensure there's a tcp/ip binding handle

    rpcstatus = RpcServerUseProtseq( const_cast<TCHAR*>(s_tszTrkSvrRpcProtocol),
                                     pTrkSvrConfig->GetSvrMaxRpcCalls(), NULL);

    if (rpcstatus != RPC_S_OK &&
        rpcstatus != RPC_S_DUPLICATE_ENDPOINT)
    {
        // Log an event, unless it's a not-supported error, which happens during
        // a normal setup.
        if( RPC_S_PROTSEQ_NOT_SUPPORTED != rpcstatus )
        {
            TrkLog((TRKDBG_ERROR, TEXT("RpcServerUseProtseqEp %08x"), rpcstatus));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus),
                                    TRKREPORT_LAST_PARAM );
        }
        TrkRaiseWin32Error(rpcstatus);
    }

    // If we don't have a pSvcsGlobalData (we're not running in services.exe),
    // tell RpcServerRegisterIfEx to automatically set up a listen thread.

    CRpcServer::Initialize( Stubtrksvr_v1_0_s_ifspec, 
                            NULL == pSvcsGlobalData ? RPC_IF_AUTOLISTEN : 0,
                            pTrkSvrConfig->GetSvrMaxRpcCalls(),
                            RpcSecurityEnabled(),     // fSetAuthInfo
                            s_tszTrkSvrRpcProtocol );

    TrkLog(( TRKDBG_RPC, TEXT("Registered TrkSvr RPC server %s (%d)"),
             RpcSecurityEnabled() ? TEXT("") : TEXT("(without authorization)"),
             pTrkSvrConfig->GetSvrMaxRpcCalls() ));

}


void
CTrkSvrRpcServer::UnInitialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{
    TrkLog(( TRKDBG_RPC, TEXT("Unregistering TrkSvr RPC server") ));
    CRpcServer::UnInitialize( );
    TrkLog(( TRKDBG_RPC, TEXT("Unregistered TrkSvr RPC server") ));
}



CMachineId::CMachineId(handle_t ClientBinding)
{
    RPC_STATUS  RpcStatus;
    NTSTATUS    status;
    BOOL        f;
    HANDLE      hToken = NULL;
    PTOKEN_USER pToken;
    BYTE *      pbToken = NULL;
    PSID        LocalSystemSid = NULL;

    PUNICODE_STRING pUserName   = NULL;
    PUNICODE_STRING pUserDomainName = NULL;

    NET_API_STATUS NetStatus;

    WCHAR       *pwszDomain = NULL;
    BOOLEAN     fIsWorkGroup;
    LPBYTE      pbAccountInfo = NULL;
    BOOL        fImpersonating = FALSE;

    // Begin impersonating the user.

    RpcStatus = RpcImpersonateClient(ClientBinding);
    if (RpcStatus != RPC_S_OK)
        TrkRaiseWin32Error(RpcStatus);
    fImpersonating = TRUE;

    __try
    {
        WCHAR wszCurrentUser[ UNLEN+1 ];
        WCHAR wszDomainName[ CNLEN+1 ];

        // Get the local domain name (so we can verify it against the user's).

        NetStatus = NetpGetDomainNameEx(&pwszDomain, &fIsWorkGroup);
        if (NetStatus != NO_ERROR)
        {
            pwszDomain = NULL;
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(NetStatus),
                                    TRKREPORT_LAST_PARAM );
            TrkRaiseWin32Error(NetStatus);
        }
        TrkAssert( !fIsWorkGroup );

        // Get the user's name & domain (possible because we're
        // impersonating).

        status = LsaGetUserName( &pUserName, &pUserDomainName );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get user name (%08x)"), status ));
            TrkRaiseNtStatus( status );
        }

        memcpy( wszCurrentUser, pUserName->Buffer, pUserName->Length );
        wszCurrentUser[ pUserName->Length / sizeof(WCHAR) ] = L'\0';

        // Ensure this is a user in this domain
        {
            UNICODE_STRING LocalDomainName = { 0, 0, NULL };
            RtlInitUnicodeString( &LocalDomainName, pwszDomain );

            if( 0 != RtlCompareUnicodeString( pUserDomainName, &LocalDomainName, TRUE ))
            {
                TrkLog(( TRKDBG_WARNING, TEXT("User %s is from another domain"),
                         wszCurrentUser ));
                TrkRaiseException( TRK_E_UNKNOWN_SID );
            }
        }

        // The user name should end in a '$', since it should be a
        // machine account.

        if (wszCurrentUser[ pUserName->Length / sizeof(WCHAR) - 1] != L'$')
        {
            // No dollar suffix, it's probably local system on the DC

            DWORD SizeRequired;
            
            // Get the user's SID

            if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open thread token for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }
            
            if (!GetTokenInformation( hToken,
                     TokenUser,
                     NULL,
                     0,
                     &SizeRequired ) && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get thread token information (1) for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }

            pbToken = new BYTE [SizeRequired];
            if (pbToken == NULL)
                TrkRaiseWin32Error(ERROR_NOT_ENOUGH_MEMORY);

            pToken = (PTOKEN_USER) pbToken;

            if (!GetTokenInformation( hToken,
                     TokenUser,
                     pToken,
                     SizeRequired,
                     &SizeRequired ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get thread token information (2) for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }

            // Get the local system SID

            SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;

            if (! AllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't Alloc/Init SID for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }

            // Verify that the user is local system.

            BOOL fEqual = EqualSid( pToken->User.Sid, LocalSystemSid );

            if (!fEqual)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Unknown SID:  %ws"), wszCurrentUser ));
                TrkRaiseException(TRK_E_UNKNOWN_SID);
            }

            *this = CMachineId(MCID_LOCAL);
            Normalize();
            AssertValid();
            
        }   // if (wszCurrentUser[ pUserName->Length / sizeof(WCHAR) - 1] != L'$')

        else
        {
            // We don't need to be impersonating any longer, potentially (though
            // not likely) ACLs on the SAM could prevent the impersonated user
            // from making this call.  So we might as well revert now.

            TrkAssert( fImpersonating );
            if( fImpersonating )
            {
                RpcRevertToSelf();
                fImpersonating = FALSE;
            }

            // Get account info for this user, so we can
            // verify that it's a machine account.

            NetStatus = NetUserGetInfo( NULL, // Check on this server
                                        wszCurrentUser,
                                        1, // Get USER_INFO_1
                                        &pbAccountInfo );
    
    
            if (NetStatus != 0)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get user %s info (%08x)"),
                         wszCurrentUser,
                         NetStatus));
                TrkRaiseWin32Error(NetStatus);
            }
    
            TrkLog(( TRKDBG_SVR, TEXT("\nUser is %s"), wszCurrentUser));
    
            if ((((USER_INFO_1*)pbAccountInfo)->usri1_flags &
                (UF_WORKSTATION_TRUST_ACCOUNT | UF_SERVER_TRUST_ACCOUNT)) == 0)
            {
                // if the account is not a workstation or backup dc account, fail
                TrkRaiseException( TRK_E_CALLER_NOT_MACHINE_ACCOUNT );
            }
    
            // overwrite the $
            wszCurrentUser[ pUserName->Length / sizeof(WCHAR) - 1] = L'\0';
            
            if (_tcslen(wszCurrentUser) + 1 > sizeof(_szMachine))
                TrkRaiseException(TRK_E_IMPERSONATED_COMPUTERNAME_TOO_LONG);
            else if( TEXT('\0') == wszCurrentUser[0] )
                TrkRaiseException( TRK_E_NULL_COMPUTERNAME );
    
            memset(&_szMachine, 0, sizeof(_szMachine));


            // Convert the Unicode computer name into Ansi, using
            // the OEMCP codepage (NetBios/computer names are always
            // in OEMCP, not Window/Ansi).

            if( 0 == WideCharToMultiByte( CP_OEMCP, 0,
                                          wszCurrentUser,
                                          -1,
                                          _szMachine,
                                          sizeof(_szMachine),
                                          NULL, NULL ))
            {
                TrkLog(( TRKDBG_ERROR,
                         TEXT("Couldn't convert machine name %s to multi-byte (%lu)"),
                         wszCurrentUser, GetLastError() ));
                TrkRaiseLastError();
            }

            TrkLog(( TRKDBG_WARNING,
                     TEXT("Converted machine name: %hs (from %s, ")
                     MCID_BYTE_FORMAT_STRING,
                     _szMachine, wszCurrentUser,
                     (BYTE)_szMachine[0], (BYTE)_szMachine[1], (BYTE)_szMachine[2], (BYTE)_szMachine[3],
                     (BYTE)_szMachine[4], (BYTE)_szMachine[5], (BYTE)_szMachine[6], (BYTE)_szMachine[7],
                     (BYTE)_szMachine[8], (BYTE)_szMachine[9], (BYTE)_szMachine[10], (BYTE)_szMachine[11],
                     (BYTE)_szMachine[12], (BYTE)_szMachine[13], (BYTE)_szMachine[14], (BYTE)_szMachine[15] ));

            Normalize();
            AssertValid();
        
        }   // if (wszCurrentUser[ pUserName->Length / ... else
    }
    __finally
    {
        if( fImpersonating )
        {
            RpcRevertToSelf();
            fImpersonating = FALSE;
        }

        if (hToken != NULL)
        {
            CloseHandle(hToken);
        }
        if (pbToken != NULL)
        {
            delete [] pbToken;
        }
        if (LocalSystemSid != NULL)
        {
            FreeSid( LocalSystemSid );
        }

        if (pUserName != NULL)
        {
            LsaFreeMemory(pUserName->Buffer);
            LsaFreeMemory(pUserName);
        }
        if (pUserDomainName != NULL)
        {
            LsaFreeMemory(pUserDomainName->Buffer);
            LsaFreeMemory(pUserDomainName);
        }

        if (pbAccountInfo != NULL)
        {
            NetApiBufferFree(pbAccountInfo);
        }

        if( NULL != pwszDomain )
            NetApiBufferFree(pwszDomain);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\loghead.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  File:       LogHead.cxx
//
//  Classes:    CLogFileHeader
//
//  This class represents the header (the first sector) of the Tracking
//  (Workstation) Service's log file.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Synopsis:   Initialize the header class.  We allocate a buffer here to
//              hold sectors.  This is the only allocation we perform
//              in this class.
//
//  Inputs:     [cbSector] (in)
//                  The size of the file sectors.
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::Initialize( ULONG cbSector )
{
    TrkAssert( 0 != cbSector );
    TrkAssert( NULL == _hFile );

    // Initialize flags

    _fDirty = FALSE;

    // Store the input

    if( sizeof(*_plogheader) + CB_EXTENDED_HEADER > cbSector )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Sector size isn't large enough for log header") ));
        TrkRaiseWin32Error( ERROR_BAD_CONFIGURATION );
    }
    _cbSector = cbSector;

    // Allocate a buffer to hold the header sector

    if( NULL != _plogheader && _cbSector != cbSector )
    {
        delete [] _plogheader;
        _plogheader = NULL;
    }

    if( NULL == _plogheader )
    {
        _plogheader = reinterpret_cast<LogHeader*>( new BYTE[ cbSector ] );
        if( NULL == _plogheader )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't alloc %d bytes in CLogFileHeader::Initialize"), cbSector ));
            TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    // The "extended header" is that portion beyond the regular header
     
    _pextendedheader = &_plogheader[1];

}   // CLogFileHeader::Initialize


//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Synopsis:   Free the sector buffer.
//
//  Inputs:     None
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::UnInitialize()
{
    if( NULL != _plogheader )
    {
        if( IsOpen() )
            OnClose();

        LogHeader *plogheader = _plogheader;
        _plogheader = NULL;
        delete [] plogheader;
    }

}   // CLogFileHeader::UnInitialize()



//+----------------------------------------------------------------------------
//
//  Method:     LoadHeader
//
//  Synopsis:   Load the header sector from the log file.
//
//  Inputs:     None
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::LoadHeader( HANDLE hFile )
{
    NTSTATUS status;
    LARGE_INTEGER liOffset;
    IO_STATUS_BLOCK IoStatusBlock;

    // _hFile must not be set until we've successfully loaded the header.
    TrkAssert( NULL == _hFile );

    // Read the header sector from the file

    liOffset.QuadPart = 0;

    status = NtReadFile( hFile, NULL, NULL, NULL,
                         &IoStatusBlock, _plogheader, _cbSector,
                         &liOffset, NULL );

    if ( STATUS_PENDING == status )
    {
        // Wait for the operation to complete.  The resulting status
        // will be put in the IOSB

        status = NtWaitForSingleObject( hFile, FALSE, NULL );

        if( NT_SUCCESS(status) )
            status = IoStatusBlock.Status;
    }

    // Validate the results of the read

    if ( !NT_SUCCESS(status) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed NtReadFile (%08x)"), status ));
        if(STATUS_VOLUME_DISMOUNTED == status)
        {
            TrkRaiseNtStatus(status);
        }
        else
        {
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }
    }

    if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
        g_ptrkwks->_entropy.Put();

    if( _cbSector != IoStatusBlock.Information )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't read header from log") ));
        TrkRaiseException( TRK_E_CORRUPT_LOG );
    }
    _hFile = hFile;

}   // CLogFileHeader::LoadHeader()


//+----------------------------------------------------------------------------
//
//  Method:     ReadExtended
//
//  Synopsis:   Read bytes from the extended header to the caller's
//              buffer.
//  
//  Inputs:     [iOffset] (in)
//                  0-relative offset into the extended header.
//              [pv] (out)
//                  Buffer to receive the extended header bytes
//              [cb] (in)
//                  Size of this extended header segment.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::ReadExtended( ULONG iOffset, void *pv, ULONG cb )
{
    TrkAssert( NULL != _plogheader );
    RaiseIfNotOpen();

    // Validate the request

    if( sizeof(*_plogheader) + iOffset + cb > _cbSector )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Attempt to read too much data from the extended log header (%d bytes at %d)\n"),
                            iOffset, cb ));
        TrkAssert( !TEXT("Invalid parameters to CLogFileHeader::ReadExtended") );
        TrkRaiseException( TRK_E_CORRUPT_LOG );
    }

    // Read the bytes

    memcpy( pv, &static_cast<BYTE*>(_pextendedheader)[ iOffset ], cb );

}   // CLogFileHeader::ReadExtended()


//+----------------------------------------------------------------------------
//
//  Method:     WriteExtended
//
//  Synopsis:   Writes bytes to the caller-specified portion of the log's
//              extended header area.
//
//  Inputs:     [iOffset] (in)
//                  0-relative index into the extended header
//              [pv] (in)
//                  The bytes to write.
//              [cb] (in)
//                  The number of bytes to write.
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::WriteExtended( ULONG iOffset, const void *pv, ULONG cb )
{
    TrkAssert( NULL != _plogheader );
    TrkAssert( sizeof(*_plogheader) + iOffset + cb <= 512 );
    RaiseIfNotOpen();

    // Validate the request

    if( sizeof(*_plogheader) + iOffset + cb > _cbSector )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Attempt to read too much data from the extended log header (%d bytes at %d)\n"),
                            iOffset, cb ));
        TrkAssert( !TEXT("Invalid parameters to CLogFileHeader::WriteExtended") );
        TrkRaiseException( TRK_E_CORRUPT_LOG );
    }

    // Write the bytes

    memcpy( &static_cast<BYTE*>(_pextendedheader)[ iOffset ], pv, cb );
    SetDirty();

}   // CLogFileHeader::WriteExtended



//+----------------------------------------------------------------------------
//
//  Method:     SetExpansionData
//
//  Synopsis:   Write information about an expansion to the log header.
//
//  Inputs:     [cbLogFile] (in)
//                  The current size of the file.
//              [ilogStart] (in)
//                  The index of the current starting point in the circular
//                  linked-list.
//              [ilogEnd] (in)
//                  The index of the current ending point in the circular
//                  linked-list.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::SetExpansionData( ULONG cbLogFile, ULONG ilogStart, ULONG ilogEnd )
{
    TrkAssert( NULL != _plogheader );
    RaiseIfNotOpen();

    // Save the expansion data

    _plogheader->expand.cbFile = cbLogFile;
    _plogheader->expand.ilogStart = ilogStart;
    _plogheader->expand.ilogEnd = ilogEnd;

    // Flush straight to disk

    Flush( );

}   // CLogFileHeader::SetExpansionData()


//+----------------------------------------------------------------------------
//
//  Method:     Flush
//
//  Synopsis:   Flush the current header sector to the underlying file.
//
//  Inputs:     [FlushFlags] (in)
//                  From the FLUSH_* defines.  Used to indicate if we
//                  should flush regardless of the dirty flag, and if
//                  we should flush to cache or to disk.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::Flush( )
{
    NTSTATUS status = STATUS_SUCCESS;
    RaiseIfNotOpen();

    // Is there anything loaded to even flush?

    if( NULL != _hFile )
    {
        IO_STATUS_BLOCK IoStatusBlock;
        TrkAssert( NULL != _plogheader );

        // Is the in-memory header dirty?

        if( _fDirty )
        {
            LARGE_INTEGER liOffset;

            TrkAssert( NULL != _hFile );

            // Write the header sector to the file

            liOffset.QuadPart = 0;


            status = NtWriteFile( _hFile, NULL, NULL, NULL,
                                  &IoStatusBlock, _plogheader, _cbSector,
                                  &liOffset, NULL );

            if ( STATUS_PENDING == status )
            {
                // Wait for the operation to complete.  The resulting status
                // will be put in the IOSB

                status = NtWaitForSingleObject( _hFile, FALSE, NULL );

                if( NT_SUCCESS(status) )
                    status = IoStatusBlock.Status;
            }


            // Validate the results of the write

            if ( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't write the log file header")));
                TrkRaiseNtStatus( status );
            }

            if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
                g_ptrkwks->_entropy.Put();

            if( _cbSector != IoStatusBlock.Information )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't write all of the log file header (%d)"),
                                   IoStatusBlock.Information ));
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }

            SetDirty( FALSE );

        }   // if( _fDirty || FLUSH_UNCONDITIONALLY == flush_type )
    }   // if( NULL != _hFile )

}   // CLogFileHeader::Flush
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\logfile.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  File:       logfile.cxx
//
//              This file contains the definition of the CLogFile class.
//
//  Purpose:    This class represents the file which contains the
//              Tracking/Workstation move notification log.  Clients
//              of this class may request one entry or header at a time,
//              using based on a log entry index.
//
//              Entries in the log file are joined by a linked-list,
//              so this class includes methods that clients use to
//              advance their log entry index (i.e., traverse the list).
//
//  Notes:      CLogFile reads/writes a sector at a time for reliability.
//              When a client modifies a log entry in one sector, then
//              attempts to access another sector, CLogFile automatically
//              flushes the changes.  This is dependent, however, on the
//              client properly calling the SetDirty method whenever it
//              changes a log entry or header.
//
//+============================================================================


#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"



const GUID s_guidLogSignature = { /* 6643a7ec-effe-11d1-b2ae-00c04fb9386d */
                                0x6643a7ec, 0xeffe, 0x11d1,
                                {0xb2, 0xae, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d} };


NTSTATUS
CSecureFile::CreateSecureDirectory( const TCHAR *ptszDirectory )
{
    HANDLE hDir = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    CSystemSD   ssd;
    SECURITY_ATTRIBUTES security_attributes;

    LONG cLocks = Lock();
    __try
    {
        memset( &security_attributes, 0, sizeof(security_attributes) );

        ssd.Initialize( CSystemSD::SYSTEM_ONLY );  // No Administrator access
        security_attributes.nLength = sizeof(security_attributes);
        security_attributes.bInheritHandle = FALSE;
        security_attributes.lpSecurityDescriptor = static_cast<const PSECURITY_DESCRIPTOR>(ssd);

        // Create the directory.  Make it system|hidden so that the NT5 shell
        // won't ever display it.

        status = TrkCreateFile( ptszDirectory,
                                FILE_LIST_DIRECTORY,
                                FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_OPEN_IF,
                                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                                &security_attributes,
                                &hDir );

        if( !NT_SUCCESS(status) )
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create secure directory(status=%08x)"), status ));
        else
            NtClose(hDir);
    }
    __finally
    {
        ssd.UnInitialize();
#if DBG
        TrkVerify( Unlock() == cLocks );
#else
        Unlock();
#endif
    }

    return( status );
}


// Assuming that tszFile is a file under a directory that is under a root
// directory. Try to create tszFile first. If not successful, create its
// parent directory. And then try create the file again.

NTSTATUS
CSecureFile::CreateAlwaysSecureFile(const TCHAR * ptszFile)
{
    NTSTATUS status = STATUS_SUCCESS;
    CSystemSD   ssd;
    SECURITY_ATTRIBUTES security_attributes;

    memset( &security_attributes, 0, sizeof(security_attributes) );

    LONG cLocks = Lock();
    __try
    {
        TrkAssert(!IsOpen());

        ssd.Initialize();
        security_attributes.nLength = sizeof(security_attributes);
        security_attributes.bInheritHandle = FALSE;
        security_attributes.lpSecurityDescriptor = static_cast<const PSECURITY_DESCRIPTOR>(ssd);

        for(int cTries = 0; cTries < 2; cTries++)
        {
            // Create the file, deleting an existing file if there is one.
            // We make it system|hidden so that it's "super-hidden"; the NT5
            // shell won't ever display it.

            status = TrkCreateFile( ptszFile,
                                    FILE_GENERIC_READ|FILE_GENERIC_WRITE,          // Access
                                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, // Attributes
                                    0,                                             // Share
                                    FILE_SUPERSEDE,                                // Creation/distribution
                                    0,                                             // Options
                                    &security_attributes,                          // Security
                                    &_hFile );

            if(NT_SUCCESS(status))
                break;
            _hFile = NULL;

            if( STATUS_OBJECT_PATH_NOT_FOUND == status )
            {
                // The create failed because the directory ("System Volume Information")
                // didn't exist.

                CDirectoryName dirname;
                TrkVerify( dirname.SetFromFileName( ptszFile ));
                status = CreateSecureDirectory( dirname );
                if( !NT_SUCCESS(status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create directory %s"),
                             static_cast<const TCHAR*>(dirname) ));
                    break;
                }

            }   // path not found
            else
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create file(status=%08x)"), status ));
                _hFile = NULL;
                break;
            }
        }   // for
    }
    __finally
    {
        ssd.UnInitialize();
#if DBG
        TrkVerify( Unlock() == cLocks );
#else
        Unlock();
#endif
    }

    return( status );
}

NTSTATUS
CSecureFile::OpenExistingSecureFile( const TCHAR * ptszFile, BOOL fReadOnly )
{
    NTSTATUS status = STATUS_SUCCESS;

    LONG cLocks = Lock();
    __try
    {
        TrkAssert(!IsOpen());

        // From the point of view of CSecureFile, we might as well open share_read,
        // since the file's still protected by the ACLs.  From the point of view
        // of the CLogFile derivation, we want to open share_read in order to
        // allow the dltadmin tool to read the log.  We add DELETE access so
        // that the file can be renamed (necessary for migrating pre-nt5beta3 files).

        // Note - this is an async open

        status = TrkCreateFile( ptszFile,
                                fReadOnly                                      // Access
                                    ? FILE_GENERIC_READ
                                    : FILE_GENERIC_READ|FILE_GENERIC_WRITE|DELETE,   
                                FILE_ATTRIBUTE_NORMAL,                         // Attributes
                                FILE_SHARE_READ,                               // Share
                                FILE_OPEN,                                     // Creation/distribution
                                0,                                             // Options (async)
                                NULL,                                          // Security
                                &_hFile );

        if( !NT_SUCCESS(status) )
            _hFile = NULL;
    }
    __finally
    {
#if DBG
        TrkVerify( Unlock() == cLocks );
#else
        Unlock();
#endif
    }

    return( status );
}


NTSTATUS
CSecureFile::RenameSecureFile( const TCHAR *ptszFile )
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK Iosb;
    FILE_RENAME_INFORMATION *pfile_rename_information = NULL;
    UNICODE_STRING      uPath;
    PVOID               pFreeBuffer = NULL;
    ULONG cbSize = 0;

    LONG cLocks = Lock();
    __try
    {

        // Convert the Win32 path name to an NT name

        if( !RtlDosPathNameToNtPathName_U( ptszFile, &uPath, NULL, NULL ))
        {
            status = STATUS_OBJECT_NAME_INVALID;
            __leave;
        }
        pFreeBuffer = uPath.Buffer;

        // Fill in the rename information

        cbSize = sizeof(*pfile_rename_information) + uPath.Length;
        pfile_rename_information = reinterpret_cast<FILE_RENAME_INFORMATION*>
                                   (new BYTE[ cbSize ]);
        if( NULL == pfile_rename_information )
        {
            status = STATUS_NO_MEMORY;
            __leave;
        }

        pfile_rename_information->ReplaceIfExists = TRUE;
        pfile_rename_information->RootDirectory = NULL;
        pfile_rename_information->FileNameLength = uPath.Length;
        memcpy( pfile_rename_information->FileName, uPath.Buffer, uPath.Length );

        // Rename the file

        status = NtSetInformationFile( _hFile, &Iosb,
                                       pfile_rename_information, cbSize,
                                       FileRenameInformation );
        if( !NT_SUCCESS(status) )
            __leave;
    }
    __finally
    {
#if DBG
        TrkVerify( Unlock() == cLocks );
#else
        Unlock();
#endif
    }


    if( NULL != pfile_rename_information )
        delete [] pfile_rename_information;

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );


    return( status );

}

//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Purpose:    Initialize a CLogFile object.
//
//  Arguments:  [hFile] (in)
//                  The file in which the log should be stored.
//              [dwCreationDistribution] (in)
//                  Either CREATE_ALWAYS or OPEN_EXISTING.
//              [pcTrkWksConfiguration] (in)
//                  Configuration parameters for the log.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::Initialize( const TCHAR *ptszVolumeDeviceName,
                      const CTrkWksConfiguration *pcTrkWksConfiguration,
                      PLogFileNotify *pLogFileNotify,
                      TCHAR tcVolume
                      )
{
    LogHeader logheader;
    TCHAR tszRootPathName[ MAX_PATH + 1];
    DWORD dwSectorsPerCluster, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
    HANDLE hFile = NULL;
    FILE_FS_SIZE_INFORMATION FileSizeInformation;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS status = STATUS_SUCCESS;

    CSecureFile::Initialize();

    // Save caller-provided values

    TrkAssert( NULL != pcTrkWksConfiguration || NULL != _pcTrkWksConfiguration );
    if( NULL != pcTrkWksConfiguration )
        _pcTrkWksConfiguration = pcTrkWksConfiguration;
    TrkAssert( 0 < _pcTrkWksConfiguration->GetLogFileOpenTime() );


    TrkAssert( NULL != ptszVolumeDeviceName || NULL != _ptszVolumeDeviceName );
    if( NULL != ptszVolumeDeviceName )
        _ptszVolumeDeviceName = ptszVolumeDeviceName;

    TrkAssert( NULL != pLogFileNotify || NULL != _pLogFileNotify );
    if( NULL != pLogFileNotify )
        _pLogFileNotify = pLogFileNotify;

    _tcVolume = tcVolume;

    // Calculate the bytes/sector of the log file's volume.
    //
    // It would be easier to use the Win32 GetDiskFreeSpace here, but that
    // API requires a root path name of the form "A:\\", which we don't have.
    // That requirement only exists, though, for some historic reason.

    // Postpend a whack to get a root path.

    TCHAR tszVolumeName[ MAX_PATH + 1 ] = { TEXT('\0') };
    TrkAssert( NULL != _ptszVolumeDeviceName );
    _tcscpy( tszVolumeName, _ptszVolumeDeviceName );
    _tcscat( tszVolumeName, TEXT("\\") );

    // Open the root

    status = TrkCreateFile( tszVolumeName, FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ|FILE_SHARE_DELETE|FILE_SHARE_WRITE,
                            FILE_OPEN,
                            FILE_OPEN_FOR_FREE_SPACE_QUERY | FILE_SYNCHRONOUS_IO_NONALERT, 
                            NULL,
                            &hFile );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open volume root to query free space") ));
        TrkRaiseNtStatus(status);
    }

    // Query the volume for the free space and unconditionally close the handle.

    status = NtQueryVolumeInformationFile( hFile, &IoStatusBlock, &FileSizeInformation,
                                           sizeof(FileSizeInformation), FileFsSizeInformation );
    NtClose( hFile );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query volume information from log file") ));
        TrkRaiseNtStatus(status);
    }

    // Save the free space away

    _cbLogSector = FileSizeInformation.BytesPerSector;
    if( MIN_LOG_SECTOR_SIZE > _cbLogSector )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Volume sector sizes too small") ));
        TrkRaiseNtStatus( STATUS_INVALID_BUFFER_SIZE );
    }

    // Initialize members

    _header.Initialize( _cbLogSector );
    _sector.Initialize( _header.NumSectors(), _cbLogSector );

    if( INVALID_HANDLE_VALUE == _heventOplock )
    {
        _heventOplock = CreateEvent( NULL,     // Security Attributes.
                                     FALSE,    // Manual Reset Flag.
                                     FALSE,    // Inital State = Signaled, Flag.
                                     NULL );   // Name
        if( INVALID_HANDLE_VALUE == _heventOplock )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create event for logfile") ));
            TrkRaiseLastError();
        }
    }


    // Open the log file here. We open the log file at initialization time and
    // keeps it open unless the handle is broken or we are notified to give up
    // the volume.

    ActivateLogFile();

}   // CLogFile::Initialize()



//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Purpose:    Free resources
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::UnInitialize( )
{
    __try
    {
        CloseLog( );

        if( INVALID_HANDLE_VALUE != _heventOplock )
        {
            CloseHandle( _heventOplock );
            _heventOplock = INVALID_HANDLE_VALUE;
        }

    }
    __finally
    {
        _header.UnInitialize();
        _sector.UnInitialize();
    }

}   // CLogFile::UnInitialize()


//+----------------------------------------------------------------------------
//
//  PRobustlyCreateableFile::RobustlyCreateFile
//
//  Open the specified file on the specified volume.  If the file is corrupt,
//  delete it.  If the file doesn't exist (or was deleted), create a new
//  one.
//
//+----------------------------------------------------------------------------

void
PRobustlyCreateableFile::RobustlyCreateFile( const TCHAR * ptszFile, TCHAR tcVolumeDriveLetter )
{
    // Attempt to open the file

    RCF_RESULT r = OpenExistingFile( ptszFile );

#if DBG
    if( r == OK )
        TrkLog(( TRKDBG_LOG, TEXT("Opened log file %s"), ptszFile ));
#endif

    if( r == CORRUPT )
    {
#if DBG
        TCHAR tszFileBak[ MAX_PATH + 1 ];

        // Generate a backup name for the existing log file.

        _tcscpy( tszFileBak, ptszFile );
        _tcscat( tszFileBak, TEXT(".bak") );

        // Rename the existing logfile to the backup location.

        if (!MoveFileEx(ptszFile, tszFileBak, MOVEFILE_REPLACE_EXISTING))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't make backup of corrupted file name\n   (\"%s\" to \"%s\")"),
                               ptszFile, tszFileBak ));
            TrkRaiseLastError( );
        }
#else

        // Delete the file.
        RobustlyDeleteFile( ptszFile );


#endif // #if DBG

        TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                        static_cast<const TCHAR*>( CStringize(tcVolumeDriveLetter) ),
                        NULL );

        // Go into the file-not-found mode.

        r = NOT_FOUND;
    }

    if( r == NOT_FOUND )
    {
        TCHAR tszLogFileTmp[MAX_PATH+1];

        // Create a temporary file name.  We'll do everything here, and switch it
        // to the real name when everything's set up.

        _tcscpy( tszLogFileTmp, ptszFile );
        _tcscat( tszLogFileTmp, TEXT(".tmp") );

        TrkLog(( TRKDBG_LOG, TEXT("Creating new file %s"), ptszFile ));

        CreateAlwaysFile( tszLogFileTmp );

        // Move the log file into its final name

        if (!( MoveFile(tszLogFileTmp, ptszFile) ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't rename file (\"%s\" to \"%s\")"), tszLogFileTmp, ptszFile ));
            TrkRaiseLastError( );
        }

        SetLastError(0);
        r = OpenExistingFile( ptszFile );
    }

    if( r != OK )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't create/open file (%s)"), ptszFile ));
        TrkRaiseLastError();
    }

}


void
PRobustlyCreateableFile::RobustlyDeleteFile( const TCHAR * ptszFile )
{
    TCHAR tszFileBak[ MAX_PATH + 1 ];
    BOOL fDeleted = FALSE;

    // Generate a backup name for the existing log file.

    _tcscpy( tszFileBak, ptszFile );
    _tcscat( tszFileBak, TEXT(".bak") );

    // Delete the file.
    // First rename it, though, so we don't get held up by the case where
    // e.g. backup has the file open.

    if (!MoveFileEx(ptszFile, tszFileBak, MOVEFILE_REPLACE_EXISTING))
    {
        if( ERROR_PATH_NOT_FOUND == GetLastError()
            ||
            ERROR_FILE_NOT_FOUND == GetLastError() )
        {
            fDeleted = TRUE;
        }
        else
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't rename existing log file (%lu, \"%s\")"),
                    GetLastError(), ptszFile ));
            TrkRaiseLastError( );
        }
    }

    if( !fDeleted && !DeleteFile( tszFileBak ))
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't delete backup log file\n   (%lu, \"%s\")"),
                 GetLastError(), tszFileBak ));
    }


}



void
CLogFile::CloseLog()    // doesn't raise
{
    if( IsOpen() )
    {
        _header.OnClose();
        _sector.OnClose();
        UnregisterOplockFromThreadPool();
        CloseFile();

        TrkLog(( TRKDBG_LOG, TEXT("Log file closed on volume %c"), _tcVolume ));
    }

}

//+----------------------------------------------------------------------------
//
//  Method:     InitializeLogEntries (private)
//
//  Synopsis:   Given a contiguous set of log entries in the log file,
//              initialize all of the fields.  The entries are initialized
//              to link to their neighbors in a circular queue.
//
//  Arguments:  [ilogFirst] (in)
//                  The first log entry in the list.
//              [ilogLast] (in)
//                  The last log entry in the list.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::InitializeLogEntries( LogIndex ilogFirst, LogIndex ilogLast )
{
    LogEntry *ple = NULL;
    LogIndex ilogEntry;

    ULONG cEntries = ilogLast - ilogFirst + 1;

    TrkAssert( cEntries > 0 );

    // Initialize the first log entry.

    ple = _sector.GetLogEntry( ilogFirst );

    _sector.SetDirty( TRUE );
    _sector.InitSectorHeader();
    memset( ple, 0, sizeof(*ple) );

    ple->ilogNext = ilogFirst + 1;
    ple->ilogPrevious = ilogLast;
    ple->move.type = LE_TYPE_EMPTY;

    // Initialize all log entries except for the first and last.

    for( ilogEntry = ilogFirst + 1; ilogEntry < ilogLast; ilogEntry++ )
    {
        ple = _sector.GetLogEntry( ilogEntry );

        _sector.InitSectorHeader();
        memset( ple, 0, sizeof(*ple) );

        ple->ilogNext = ilogEntry + 1;
        ple->ilogPrevious = ilogEntry - 1;
        ple->move.type = LE_TYPE_EMPTY;
    }

    // Initialize the last log entry.

    ple = _sector.GetLogEntry( ilogLast );

    _sector.InitSectorHeader();
    memset( ple, 0, sizeof(*ple) );

    ple->ilogNext = ilogFirst;
    ple->ilogPrevious = ilogLast - 1;
    ple->move.type = LE_TYPE_EMPTY;

    Flush( );

    return;

}   // CLogFile::InitializeLogEntries()


//+----------------------------------------------------------------------------
//
//  Method:     Validate (private)
//
//  Synopsis:   Validate the log file by verifying the linked-list pointers,
//              the log file expansion data,
//              and by verifying the Signature and Format IDs in the headers.
//
//  Arguments:  None
//
//  Returns:    None (raises on error)
//
//+----------------------------------------------------------------------------

BOOL
CLogFile::Validate( )
{
    BOOL fValid = FALSE;

    BOOL fFirstPass;
    LogIndex ilog;
    ULONG cEntries;
    ULONG cEntriesSeen;


    //  ---------------
    //  Simple Checking
    //  ---------------

    // Do some quick checking, and only continue if this exposes a problem.

    // Check the signature & format in the first sector's header.

    if( s_guidLogSignature != _header.GetSignature()
        ||
        CLOG_MAJOR_FORMAT != _header.GetMajorFormat()
      )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Corrupted log file on volume %c (Signature=%s, Format=0x%X)"),
                 _tcVolume,
                 (const TCHAR*)CDebugString(_header.GetSignature()),
                 _header.GetFormat() ));
        goto Exit;
    }

    // If this log has an uplevel minor version format, then set a bit
    // to show that the log has been touched by someone that doesn't fully
    // understand it.  This won't actually make the header dirty, but if
    // some other change takes place that does make it dirty, this bit
    // will be included in the flush.

    if( CLOG_MINOR_FORMAT < _header.GetMinorFormat() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Setting downlevel-dirtied (0x%x, 0x%x)"),
                 CLOG_MINOR_FORMAT, _header.GetMinorFormat() ));
        _header.SetDownlevelDirtied();
    }

    // Check for proper shutdown.  The shutdown flag is always stored in the
    // first sector's header, since the log may not be in a state where we can
    // read for the most recent sector's header.  If the header wasn't shutdown,
    // we go into Recovering mode.  If it was shut down, we don't clear the
    // recovery flag, since the there may have been a shutdown during a previous recovery.
    // I.e., CLogFile's responsibility is to set the recovery flag automatically,
    // but to clear it only on request.

    if( _header.IsShutdown() )
    {
        if(_header.IsExpansionDataClear())
        {
            fValid = TRUE;
        }
        else
            goto Exit;

        // On debug builds, go ahead and run the validation code
#if DBG
        fValid = FALSE; // Fall through
#else
        goto Exit;
#endif

    }
    else
        TrkLog(( TRKDBG_ERROR, TEXT("Log was not properly shut down on volume %c:"), _tcVolume ));

    //  -----------------------------------------
    //  Recover after a crash during an expansion
    //  -----------------------------------------

    if( 0 != _header.ExpansionInProgress() )
    {

        TrkLog(( TRKDBG_ERROR, TEXT("Recovering from a previous log expansion attempt on volume %c"), _tcVolume ));
        TrkAssert( _header.GetPreExpansionStart() != _header.GetPreExpansionEnd() );
        TrkAssert( _header.GetPreExpansionSize() <= _cbLogFile );

        // Validate the expansion header.  We'll just ensure that the size is reasonable;
        // the linked-list pointers will be validated below.

        if( _header.GetPreExpansionSize() > _cbLogFile ) {
            TrkLog(( TRKDBG_ERROR, TEXT("Pre-expansion size is corrupted") ));
        }

        // Throw away the extra, uninitialized portion at the end of the file.

        if( !SetSize( _header.GetPreExpansionSize() ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed SetSize during validation of log on %c:"), _tcVolume ));
            TrkRaiseLastError();
        }

        // Ensure that the linked list is still circular.

        _sector.GetLogEntry( _header.GetPreExpansionEnd() )->ilogNext
            = _header.GetPreExpansionStart();

        _sector.GetLogEntry( _header.GetPreExpansionStart() )->ilogPrevious
            = _header.GetPreExpansionEnd();

        // Now that we're back in a good state, we can throw away the expansion
        // information.

        _sector.Flush( );
        _header.ClearExpansionData(); // flush through cache

    }   // if( 0 != _header.ExpansionInProgress() )


    //  ----------------------
    //  Check forward pointers
    //  ----------------------

    TrkAssert( 0 == _header.GetPreExpansionSize() );
    TrkAssert( 0 == _header.GetPreExpansionStart() );
    TrkAssert( 0 == _header.GetPreExpansionEnd() );

    // Walk through the next pointers, and verify each of the headers.

    cEntries = _cEntriesInFile;

    fFirstPass = TRUE;
    for( ilog = 0, cEntriesSeen = 0;
         cEntriesSeen < cEntries;
         ilog = _sector.ReadLogEntry(ilog)->ilogNext, cEntriesSeen++ )
    {
        // Ensure that the index is within range

        if( ilog >= cEntries )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Invalid index in log on volume %c (%d)"), _tcVolume, ilog ));
            goto Exit;
        }

        // We should never see index zero after the first pass through this
        // for loop.  If we do, then we have a cycle.

        if( fFirstPass )
            fFirstPass = FALSE;

        else if( 0 == ilog )
        {
            // We have a cycle
            TrkLog(( TRKDBG_ERROR, TEXT( "Forward cycle in log file on volume %c (%d of %d entries)"),
                     _tcVolume, ilog - 1, cEntries ));
            goto Exit;
        }

    }   // for( ilog = 0; ilog < cEntries; ilog = GetLogEntry(ilog)->ilogNext )

    // If the forward pointers are valid, we should have arrived back where
    // we started ... at index 0.

    if( 0 != ilog )
    {
        TrkLog(( TRKDBG_ERROR, TEXT( "Forward cycle in log file on volume %c"), _tcVolume ));
        goto Exit;
    }

    //  -----------------------
    //  Check backward pointers
    //  -----------------------

    // Walk through the prev pointers.  This time, we needn't check
    // the headers.

    fFirstPass = TRUE;
    for( ilog = 0, cEntriesSeen = 0;
         cEntriesSeen < cEntries;
         ilog = _sector.ReadLogEntry(ilog)->ilogPrevious, cEntriesSeen++ )
    {
        // Again, we should never see index zero after the first pass

        if( fFirstPass )
            fFirstPass = FALSE;

        else if( 0 == ilog )
        {
            TrkLog(( TRKDBG_ERROR, TEXT( "Backward cycle in log file on volume %c (%d of %d entries)"),
                     _tcVolume, ilog - 1, cEntries ));
            goto Exit;
        }

    }   // for( ilog = 0; ilog < cEntries; ilog = GetLogEntry(ilog)->ilogPrevious )

    // Ensure that we got back to where we started.

    if( 0 != ilog )
    {
        TrkLog(( TRKDBG_ERROR, TEXT( "Backward cycle in log file on volume %c"), _tcVolume ));
        goto Exit;
    }

    // If we reach this point, the log was valid.
    fValid = TRUE;


    //  ----
    //  Exit
    //  ----

Exit:

    return( fValid );

}   // CLogFile::Validate()


//+----------------------------------------------------------------------------
//
//  Method:     CreateNewLog (private)
//
//  Synopsis:   Create and initialize a new log file.  The file is created
//              so that only Administrators and the system can access it.
//
//  Arguments:  [ptszLogFile] (in)
//                  The name of the log file.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::CreateAlwaysFile( const TCHAR *ptszTempName )
{
    NTSTATUS status = STATUS_SUCCESS;

    //  --------------
    //  Initialization
    //  --------------

    HRESULT hr = S_OK;

    DWORD dw = 0;
    DWORD dwWritten = 0;
    ULONG iLogEntry = 0;

    LogEntry *ple;

    //  --------------------------------------
    //  Create and Initialize the New Log File
    //  --------------------------------------

    status = CreateAlwaysSecureFile(ptszTempName);
    if( !NT_SUCCESS(status) )
        TrkRaiseException( status );

    //  ------------------------------
    //  Initialize the CLogFile object
    //  ------------------------------

    // Initialize the file.  Sets _cEntriesInFile.
    if( !SetSize( _pcTrkWksConfiguration->GetMinLogKB() * 1024 ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed SetSize of %s"), ptszTempName ));
        TrkRaiseLastError();
    }

    // We must always have at least 2 entries; an entry to hold data, and a margin
    // entry.

    if( 2 >= _cEntriesInFile )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Log file is too small (%d entries)"), _cEntriesInFile));
        TrkRaiseException( E_FAIL );
    }

    // Initialize the log header and sector

    _header.OnCreate( _hFile );
    _sector.OnCreate( _hFile );

    InitializeLogEntries( 0, _cEntriesInFile - 1 );

    // Since all the clients of the logfile have been notified, we can set the
    // shutdown flag.  This causes the first flush.  If we crash prior to this point,
    // a subsequent open attempt will find a corrupt file and re-create it.

    SetShutdown( TRUE );

    // Close the file
    CloseLog();

}   // CLogFile::CreateNewLog


//+----------------------------------------------------------------------------
//
//  Method:     OpenExistingFile (derived from PRobustlyCreateableFile)
//
//  Synopsis:   Open the log file and use it to initialize our state
//              (such as indices).
//
//  Arguments:  [ptszFile] (in)
//                  The name of the log file.
//
//  Returns:    [RCF_RESULT]
//                  OK  -       file now open
//                  CORRUPT -   file corrupt (and closed)
//                  NOT_FOUND - file not found
//
//              All other conditions result in an exception..
//
//+----------------------------------------------------------------------------

RCF_RESULT
CLogFile::OpenExistingFile( const TCHAR * ptszFile )
{
    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;

    RCF_RESULT r = OK;
    ULONG cEntries = 0;
    ULONG cbRead = 0;

    SequenceNumber seqMin;
    SequenceNumber seqMax;
    BOOL fLogEmpty = TRUE;
    BOOL fWriteProtected;

    LogIndex ilogMin;
    LogIndex ilogMax;
    LogIndex ilogEntry;

    LogEntryHeader entryheader;
    const LogMoveNotification *plmn = NULL;

    //  --------------------------
    //  Open and Validate the File
    //  --------------------------

    __try
    {
        // See if the volume is read-only

        status = CheckVolumeWriteProtection( _ptszVolumeDeviceName, &fWriteProtected );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't check if volume was write-protected for %s"),
                     ptszFile ));
            TrkRaiseNtStatus(status);
        }
        _fWriteProtected = fWriteProtected;
        TrkLog(( TRKDBG_VOLUME, TEXT("Volume is%s write-protected"),
                 _fWriteProtected ? TEXT("") : TEXT(" not") ));

        // Open the file

        status = OpenExistingSecureFile( ptszFile, _fWriteProtected );
        if( !NT_SUCCESS(status))
        {
            if (status != STATUS_OBJECT_NAME_NOT_FOUND && status != STATUS_OBJECT_PATH_NOT_FOUND)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open %s"), ptszFile ));
                TrkRaiseNtStatus(status);
            }
            r = NOT_FOUND;
        }

        // If we didn't find it, see if the pre-beta3 file exists.

        if( NOT_FOUND == r )
        {
            TCHAR tszOldLogAbsoluteName[ MAX_PATH + 1 ];

            _tcscpy( tszOldLogAbsoluteName, _ptszVolumeDeviceName );
            _tcscat( tszOldLogAbsoluteName, s_tszOldLogFileName );
            TrkAssert( _tcslen(tszOldLogAbsoluteName) <= MAX_PATH );

            // Try to open the old log file.

            status = OpenExistingSecureFile( tszOldLogAbsoluteName, _fWriteProtected );
            if( !NT_SUCCESS(status))
                __leave;    // r == NOT_FOUND

            // Move that old file from its current location ("\~secure.nt") to
            // the modern location ("\System Volume Information").

            TrkLog(( TRKDBG_VOLUME, TEXT("Found pre-beta3 log file, renaming") ));

            CDirectoryName dirnameOld, dirnameNew;
            TrkVerify( dirnameNew.SetFromFileName( ptszFile ) );
            TrkVerify( dirnameOld.SetFromFileName( tszOldLogAbsoluteName ) );

            // Create or open the new directory.
            status = CreateSecureDirectory( dirnameNew );
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create (%08x) %s"),
                         status, static_cast<const TCHAR*>(dirnameNew) ));
                TrkRaiseNtStatus(status);
            }

            // Rename the old logfile into the new directory
            status = RenameSecureFile( ptszFile );  // To the new directory
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't rename (%08x) old log file to %s"),
                         status, ptszFile ));
                TrkRaiseNtStatus(status);
            }

            // If there was a .bak logfile in the old directory, remove it.
            _tcscat( tszOldLogAbsoluteName, TEXT(".bak") );
            DeleteFile( tszOldLogAbsoluteName );

            // Delete the old directory.
            RemoveDirectory( dirnameOld );

            r = OK;

        }

        // Oplock the file

        TrkAssert( INVALID_HANDLE_VALUE != _heventOplock );

        SetOplock();

        _header.OnOpen( _hFile );
        _sector.OnOpen( _hFile );

        // Determine the size of the file.
        GetSize();

        // Validate the log file.  If it's corrupt, the _fRecovering
        // flag will be set in the Validate method.

        if( !Validate() )
        {
            r = CORRUPT;
        }

    }
    __finally
    {
        if( AbnormalTermination() || r == CORRUPT )
        {
            CloseLog( );
            TrkAssert(!IsOpen());
        }
    }

    //  ----
    //  Exit
    //  ----


    return( r );

}   // CLog::OpenExistingFile()



//+----------------------------------------------------------------------------
//
//  Method:     ReadMoveNotification
//
//  Synopsis:   Return a move notification entry from the log.
//
//  Arguments:  [ilogEntry] (in)
//                  The desired entry's index in the physical file.
//
//  Returns:    [LogMoveNotificatoin]
//
//+----------------------------------------------------------------------------

void
CLogFile::ReadMoveNotification( LogIndex ilogEntry, LogMoveNotification *plmn )
{
    const LogEntry *ple = NULL;

    // Load the sector which contains this log entry, if necessary
    // (also if necessary, this will flush the currently loaded
    // sector).

    *plmn = _sector.ReadLogEntry( ilogEntry )->move;

    return;

}   // CLogFile::ReadMoveNotification()


//+----------------------------------------------------------------------------
//
//  Method:     WriteMoveNotification
//
//  Synopsis:   Write a move notification entry to the log.
//
//  Arguments:  [ilogEntry] (in)
//                  The desired entry's index in the physical file.
//              [lmn] (in)
//                  The move notification data.
//              [entryheader] (in)
//                  The new LogEntryHeader
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::WriteMoveNotification( LogIndex ilogEntry,
                                 const LogMoveNotification &lmn,
                                 const LogEntryHeader &entryheader )
{
    // Load the sector from the file, put the new data into it,
    // and flush it.

    _sector.WriteMoveNotification( ilogEntry, lmn );
    _sector.WriteEntryHeader( ilogEntry, entryheader );
    _sector.Flush( );

}   // CLogFile::WriteMoveNotification()


//+----------------------------------------------------------------------------
//
//  Method:     ReadEntryHeader
//
//  Purpose:    Get the log header, which is stored in the sector of a given
//              log entry.
//
//  Arguments:  [ilogEntry] (in)
//                  The entry whose sector's header is to be loaded.
//
//  Returns:    [LogHeader]
//
//+----------------------------------------------------------------------------

LogEntryHeader
CLogFile::ReadEntryHeader( LogIndex ilogEntry )
{
    return _sector.ReadEntryHeader( ilogEntry );

}   // CLogFile::ReadEntryHeader()


//+----------------------------------------------------------------------------
//
//  Method:     WriteEntryHeader
//
//  Purpose:    Write the log header, which is stored in the sector of a given
//              log entry.
//
//  Arguments:  [ilogEntry] (in)
//                  The entry whose sector's header is to be loaded.
//              [logheader]
//                  The new header.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::WriteEntryHeader( LogIndex ilogEntry, const LogEntryHeader &EntryHeader )
{
    _sector.WriteEntryHeader( ilogEntry, EntryHeader );

}   // CLogFile::WriteEntryHeader()




//+----------------------------------------------------------------------------
//
//  Method:     ReadExtendedHeader
//
//  Purpose:    Get a portion of the extended log header.  The offset is
//              relative to the extended portion of the header, not to the
//              start of the sector.
//
//  Arguments:  [iOffset] (in)
//                  The offset into the header.
//              [pv] (out)
//                  The buffer to which to read.
//              [cb] (in)
//                  The amount to read.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::ReadExtendedHeader( ULONG iOffset, void *pv, ULONG cb )
{
    __try
    {
        ULONG cbRead;

        _header.ReadExtended( iOffset, pv, cb );

    }
    __finally
    {
        if( AbnormalTermination() )
            memset( pv, 0, cb );

    }


}   // CLogFile::ReadEntryHeader()


//+----------------------------------------------------------------------------
//
//  Method:     WriteExtendedHeader
//
//  Purpose:    Write to the extended portion of the log header.
//              log entry.  The offset is
//              relative to the extended portion of the header, not to the
//              start of the sector.
//
//  Arguments:  [iOffset] (in)
//                  The entry whose sector's header is to be loaded.
//              [pv] (in)
//                  The data to be written
//              [cb] (in)
//                  The size of the buffer to be written
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::WriteExtendedHeader( ULONG iOffset, const void *pv, ULONG cb )
{
    ULONG cbWritten;

    _header.WriteExtended( iOffset, pv, cb );

}   // CLogFile::WriteExtendedHeader()



//+----------------------------------------------------------------------------
//
//  Method:     AdjustLogIndex
//
//  Synopsis:   Moves a log entry index (requiring a linked-list
//              traversal).  We adjust by the number of entries specified
//              by the caller, or until we reach an optionally-provided limiting index,
//              whichever comes first.
//
//  Arguments:  [pilog] (in/out)
//                  A pointer to the index to be adjusted.
//              [iDelta] (in)
//                  The amount to adjust.
//              [adjustLimitEnum] (in)
//                  If set, then abide by ilogLimit.
//              [ilogLimit] (in)
//                  Stop if we reach this index.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::AdjustLogIndex( LogIndex *pilog, LONG iDelta,
                          AdjustLimitEnum adjustLimitEnum, LogIndex ilogLimit )
{
    LogIndex ilogEntry = *pilog;
    LogIndex ilogEntryNew;

    while( iDelta != 0
           &&
           ( ilogEntry != ilogLimit || ADJUST_WITHOUT_LIMIT == adjustLimitEnum ) )
    {
        if( iDelta > 0 )
        {
            ilogEntryNew = _sector.ReadLogEntry( ilogEntry )->ilogNext;
            iDelta--;
        }
        else
        {
            ilogEntryNew = _sector.ReadLogEntry( ilogEntry )->ilogPrevious;
            iDelta++;
        }

        if( ilogEntryNew >= _cEntriesInFile || ilogEntryNew == ilogEntry )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Invalid Next index in log file (%d, %d)"), ilogEntry, ilogEntryNew ));
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }

        ilogEntry = ilogEntryNew;
    }

    *pilog = ilogEntry;

}   // CLogFile::AdjustLogIndex()


//+----------------------------------------------------------------------------
//
//  Method:     SetSize (private)
//
//  Synopsis:   Sets the size of the log file.
//
//  Arguments:  [cbLogFile] (in)
//                  The new file size.
//
//  Returns:    TRUE iff successfully.  Sets GetLastError otherwise.
//
//+----------------------------------------------------------------------------

BOOL
CLogFile::SetSize( DWORD cbLogFile )
{
    TrkAssert( cbLogFile >= 2 * _cbLogSector );

    if ( 0xFFFFFFFF == SetFilePointer( cbLogFile, NULL, FILE_BEGIN )
         ||
         !SetEndOfFile() )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't reset log file size to %lu (%08x)"),
                cbLogFile, HRESULT_FROM_WIN32(GetLastError()) ));
        return( FALSE );
    }

    _cbLogFile = cbLogFile;
    CalcNumEntriesInFile(); // Sets _cEntriesInFile

    return( TRUE );

}   // CLogFile::SetSize()




//+----------------------------------------------------------------------------
//
//  CLogFile::DoWork
//
//  Called when the log file's oplock breaks.  This calls up to the
//  host CVolume, which in turn calls and closes all handles.
//
//+----------------------------------------------------------------------------

void
CLogFile::DoWork()
{
    NTSTATUS status;
    TrkLog(( TRKDBG_VOLUME,
             TEXT("Logfile oplock broken for %c:\n")
             TEXT("    (info=0x%08x, status=0x%08x, _hreg=%x, this=%p)"),
             _tcVolume,
             _iosbOplock.Status,
             _iosbOplock.Information,
             _hRegisterWaitForSingleObjectEx,
             this ));

    // This is a register-once registration, so we must unregister it now.
    // Unregister with no completion event, since this would cause us to hang
    // (we're executing in the wait thread upon which it would wait).

    UnregisterOplockFromThreadPool( NULL );

    if( STATUS_CANCELLED == _iosbOplock.Status )
    {
        // The thread on which the oplock was created is gone.
        // We should be running on an IO thread now, so reset
        // the oplock.

        SetOplock();
    }
    else if( !NT_SUCCESS(_iosbOplock.Status) )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Oplock failed (0x%08x)"), _iosbOplock.Status ));
    }
    else
    {
        // The oplock broke because someone tried to open the
        // log file.

        _pLogFileNotify->OnHandlesMustClose();
    }
}



void
CLogFile::SetOplock()
{
    NTSTATUS status;
    TrkAssert( INVALID_HANDLE_VALUE != _heventOplock );
    TrkAssert( NULL == _hRegisterWaitForSingleObjectEx );
    RegisterOplockWithThreadPool();

    status = NtFsControlFile(
                 _hFile,
                 _heventOplock,
                 NULL, NULL,
                 &_iosbOplock,
                 FSCTL_REQUEST_BATCH_OPLOCK,
                 NULL, 0, NULL, 0 );
    if( STATUS_PENDING != status )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't oplock logfile (%08x)"), status ));
    }
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("Log file oplocked") ));
}



//+----------------------------------------------------------------------------
//
//  Method:     GetSize (private)
//
//  Synopsis:   Determine the size of the log file.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::GetSize()
{
    ULONG cbFile = 0;

    cbFile = GetFileSize( );
    if( 0xffffffff == cbFile )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't get log file size")));
        TrkRaiseLastError( );
    }

    _cbLogFile = cbFile;
    CalcNumEntriesInFile(); // Sets _cEntriesInFile

}   // CLogFile::GetSize()



//+----------------------------------------------------------------------------
//
//  CLogFile::RegisterOplockWithThreadPool
//
//  Register the logfile oplock with the thread pool.  When this event fires,
//  we need to close the log.
//
//+----------------------------------------------------------------------------

void
CLogFile::RegisterOplockWithThreadPool()
{
    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        // Between the time the event was previously unregistered and the
        // time the oplocked handle was closed, the event may have signaled.
        // Clear this irrelevant state now.

        ResetEvent( _heventOplock );

        // Register the event with the thread pool.

        _hRegisterWaitForSingleObjectEx
            = TrkRegisterWaitForSingleObjectEx( _heventOplock, ThreadPoolCallbackFunction,
                                                static_cast<PWorkItem*>(this), INFINITE,
                                                WT_EXECUTEONLYONCE | WT_EXECUTEINIOTHREAD );
        if( NULL == _hRegisterWaitForSingleObjectEx )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed to register log oplock with thread pool (%lu) for %c:"),
                     GetLastError(), _tcVolume ));
            TrkRaiseLastError();
        }
        else
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Registered log oplock event (h=%p, this=%p)"),
                     _hRegisterWaitForSingleObjectEx, this ));
        }
    }
}


//+----------------------------------------------------------------------------
//
//  CLogFile::UnregisterOplockFromThreadPool
//
//  Unregister the log file oplock from the thread pool.  This should be done
//  before closing the log file, so that we don't get an oplock break
//  notification during the close itself.
//
//+----------------------------------------------------------------------------

void
CLogFile::UnregisterOplockFromThreadPool( HANDLE hCompletionEvent  )
{
    HANDLE hToUnregister1 = NULL;
    HANDLE hToUnregister2 = NULL;

    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("No oplock wait to unregister") ));
        return;
    }

    // We don't want to use any kind of locking mechanism, in order to 
    // avoid the risk of blocking during the oplock break (while we're 
    // in this code, someone on the system is indefinitely blocked).

    // Get the current value of the handle.

    hToUnregister1 = _hRegisterWaitForSingleObjectEx;

    // If the handle hasn't changed between the previous line and the
    // following call, set it to null.

    hToUnregister2 = InterlockedCompareExchangePointer( &_hRegisterWaitForSingleObjectEx,
                                                        NULL,
                                                        hToUnregister1 );

    // If _hRegisterWaitForSingleObjectEx was unchanged as of the previous
    // call, we've got a local copy of it now, and we can safely unregister it.

    if( hToUnregister1 == hToUnregister2 )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Unregistering oplock wait (%x, %p)"), hToUnregister2, this ));

        if( !TrkUnregisterWait( hToUnregister2, hCompletionEvent ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for log oplock event (%lu)"),
                     GetLastError() ));
        }
        else
            TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered wait for log oplock (%p)"), hToUnregister2 ));
    }
#if DBG
    else
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("No need to unregister wait for log oplock") ));
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Method:     Expand
//
//  Synopsis:   Grows the underlying log file, initializes the linked-list
//              entries in this new area, and links the new sub-list into
//              the existing list.  The previous end of the list points
//              to the new sub-list, and the last entry in the new
//              sub-list becomes the new end of the total list.
//
//  Arguments:  [cbDelta] (in)
//                  The amount by which to grow (rounded down to a sector
//                  boundary).
//              [ilogStart] (in)
//
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::Expand( LogIndex ilogStart )
{
    ULONG cbLogFileNew;
    ULONG cEntriesOld, cEntriesNew;
    LogIndex ilogEnd = 0, ilogEntry = 0;
    LogHeader logheader;

    //  -------------
    //  Grow the file
    //  -------------

    // Find the end index

    ilogEnd = ilogStart;
    AdjustLogIndex( &ilogEnd, -1 );

    // We'll grow the log file by cbDelta, with a GetLogMaxKB ceiling, and
    // rounded down to an integral number of sectors.

    cbLogFileNew = _cbLogFile + _pcTrkWksConfiguration->GetLogDeltaKB() * 1024;
    cbLogFileNew = min( cbLogFileNew, _pcTrkWksConfiguration->GetMaxLogKB() * 1024 );
    cbLogFileNew = (cbLogFileNew / _cbLogSector) * _cbLogSector;

    TrkAssert( cbLogFileNew > _cbLogFile );

    // Put our current state in the log header, so that we can
    // recover if there is a crash during the remaining code.

    _header.SetExpansionData( _cbLogFile, ilogStart, ilogEnd ); // flush through cache

    // Grow the log file, keeping track of the old and new entry count.

    TrkLog(( TRKDBG_LOG, TEXT("Expanded log on volume %c (%d to %d bytes)"),
             _tcVolume, _cbLogFile, cbLogFileNew ));

    cEntriesOld = _cEntriesInFile;

    if( !SetSize( cbLogFileNew ))   // Updates _cEntriesInFile
    {
        LONG lError = GetLastError();
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't expand log on %c:"), _tcVolume ));
        _header.ClearExpansionData();
        TrkRaiseWin32Error( lError );
    }


    cEntriesNew = _cEntriesInFile;
    TrkAssert( cEntriesNew - cEntriesOld >= 1 );

    //  -----------------------------------------------------
    //  Initialize the new entries and link into current list
    //  -----------------------------------------------------

    // Initialize the new entries

    InitializeLogEntries( cEntriesOld, cEntriesNew - 1 );

    // Link the last new entry and the overall start entry.

    _sector.GetLogEntry( cEntriesNew - 1 )->ilogNext = ilogStart;
    _sector.GetLogEntry( ilogStart )->ilogPrevious = cEntriesNew - 1;


    // Link the end to the first new entry.

    _sector.GetLogEntry( ilogEnd )->ilogNext = cEntriesOld;
    _sector.GetLogEntry( cEntriesOld )->ilogPrevious = ilogEnd;

    // Show that we finished the expansion without crashing.

    _sector.Flush( );
    _header.ClearExpansionData();   // flush through cache

}   // CLogFile::Expand()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\entropy.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  File:   entropy.cxx
//
//  This file implements the CEntropyRecorder class.  That class is used
//  to generate truly random secrets.  It does this by maintaining some
//  state whenever the Put method is called.  It is the responsibility of
//  the caller to call this at non-predictable times, such as based on
//  the timing of user keystrokes or on non-solid-state disk latency.
//
//+============================================================================




#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"

#define THIS_FILE_NUMBER    ENTROPY_CXX_FILE_NO

//+----------------------------------------------------------------------------
//
//  CEntropyRecord::Initialize
//
//  Init the critsec and entropy array.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::Initialize()
{
    DWORD dwType;
    DWORD cb;
    HKEY hKey;

    _cs.Initialize();
    _fInitialized = TRUE;

    _cbTotalEntropy = _iNext = 0;

    memset(_abEntropy, 0, sizeof(_abEntropy));

}

//+----------------------------------------------------------------------------
//
//  CEntropyRecord::UnInitialize
//
//  Delete the critsec.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::UnInitialize()
{
    if (_fInitialized)
    {
        _cs.UnInitialize();
        _fInitialized = FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::Put
//
//  This method is called at random times.  The performance counter is
//  queries, munged, and put into the entropy array.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::Put()
{
    LARGE_INTEGER li;

    QueryPerformanceCounter(&li);

    DWORD dw = li.LowPart ^ li.HighPart;
    WORD w = HIWORD(dw) ^ LOWORD(dw);

    _cs.Enter();

    PutEntropy(HIBYTE(w));
    PutEntropy(LOBYTE(w));

    _cs.Leave();
}


//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::PutEntropy
//
//  Add a byte of entropy (from Put) to the entropy array.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::PutEntropy( BYTE b )
{
    //
    // Entries are written into the buffer in a circular fashion.
    // A count, _cbTotalEntropy, records total number of writes.
    // If _cbTotalEntropy > buffer size, then we have wrapped and
    // the entire buffer has entropy.
    //


    DWORD iNext = _iNext;

    iNext %= sizeof(_abEntropy);

    TrkAssert(iNext < sizeof(_abEntropy));

    _abEntropy[iNext] ^= b;

    _iNext = iNext+1;

    _cbTotalEntropy ++;
}


//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::GetEntropy
//
//  Get the specified number of bytes of entropy.  If we don't already have 
//  enough bytes, we'll generate them here.
//
//+----------------------------------------------------------------------------

BOOL
CEntropyRecorder::GetEntropy( void * pv, ULONG cb )
{
    BOOL fGotIt = FALSE;

    _cs.Enter();
    __try
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Getting entropy (%d/%d)"), cb, _cbTotalEntropy ));

        // Do we already have enough entropy?

        if( _cbTotalEntropy <= cb )
        {
            // No, we need to generate it.

            TrkLog(( TRKDBG_VOLUME, TEXT("Generating entropy") ));
            TCHAR tszSysDir[ MAX_PATH + 1 ];
            NTSTATUS Status = STATUS_SUCCESS;
            ULONG cPuts = 0;

            // Get the system directory.

            UINT cchPath = GetSystemDirectory( tszSysDir, ELEMENTS(tszSysDir) );
            if( 0 == cchPath || MAX_PATH < cchPath )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get system directory (%lu, %lu)"),
                         cchPath, GetLastError() ));
                __leave;
            }

            // Keep opening the system directory, capturing entropy each time (with the call to Put),
            // until we have enough.

            while( _cbTotalEntropy <= cb )
            {
                HANDLE hSysDir = NULL;

                Status = TrkCreateFile( tszSysDir, FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                        FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, &hSysDir );
                if( !NT_SUCCESS(Status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open system directory (%08x)"),
                             Status ));
                    __leave;
                }

                NtClose( hSysDir );
                hSysDir = NULL;
                Put();

                // This is just a cautionary measure.  Never let this loop eat all the
                // CPU forever.

                if( ++cPuts > 100 )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("CEntropy::GetEntropy in infinite loop") ));
                    __leave;
                }
            }
            TrkLog(( TRKDBG_VOLUME, TEXT("Generated enough entropy") ));

        }   // if( _cbTotalEntropy <= cb )


        if (_cbTotalEntropy >= ELEMENTS(_abEntropy))
        {
            // Never allow _cbTotalEntropy to exceed ELEMENTS(_abEntropy)
            // if we're reading out, otherwise we'd get non-random data returned.

            _cbTotalEntropy = ELEMENTS(_abEntropy);
        }

        _cbTotalEntropy -= cb;
        _iNext = _cbTotalEntropy;

        memcpy(pv, _abEntropy, cb);

        memcpy(_abEntropy, _abEntropy+cb, sizeof(_abEntropy)-cb);
        memset(_abEntropy+sizeof(_abEntropy)-cb, 0, cb);

        fGotIt = TRUE;
    }
    __finally
    {
        _cs.Leave();
    }

    return(fGotIt);
}


//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::InitializeSecret
//
//  Create a volume secret, using the entropy buffer.
//
//+----------------------------------------------------------------------------

BOOL
CEntropyRecorder::InitializeSecret( CVolumeSecret * pSecret )
{
    return GetEntropy( pSecret, sizeof(*pSecret) );
}

//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::ReturnUnusedSecret
//
//  Return entropy that was taken with InitializeSecret but not used.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::ReturnUnusedSecret( CVolumeSecret * pSecret )
{
    TrkAssert( *pSecret != CVolumeSecret() );

    _cs.Enter();

    if (_cbTotalEntropy <= sizeof(_abEntropy) - sizeof(*pSecret))
    {
        memcpy( _abEntropy+sizeof(*pSecret), _abEntropy, _cbTotalEntropy);
        memcpy( _abEntropy, pSecret, sizeof(CVolumeSecret) );
        _iNext = (_iNext + sizeof(*pSecret)) % sizeof(_abEntropy);
        _cbTotalEntropy += sizeof(*pSecret);
    }

    *pSecret = CVolumeSecret();

    _cs.Leave();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\log.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       log.cxx
//
//  Contents:   Implementation of Tracking (Workstation) Service log of moves.
//
//  Classes:    CLog
//
//  Functions:  
//              
//  Notes:      The log is composed of a header and a linked-list of move
//              notification entries.  This structure is provided by the
//              CLogFile class.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Synopsis:   Initialize a CLog object.
//
//  Arguments:  [pLogCallback] (in)
//                  A PLogCallback object, which we'll call when we have new
//                  data.
//              [pcTrkWksConfiguration] (in)
//                  Configuration parameters for the log.
//              [pcLogFile] (in)
//                  The object representing the log file.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Initialize( PLogCallback *pLogCallback,
                  const CTrkWksConfiguration *pcTrkWksConfiguration,
                  CLogFile *pcLogFile )
{
    LogInfo loginfo;

    // Save the inputs

    TrkAssert( NULL != pcLogFile || NULL != _pcLogFile );
    if( NULL != pcLogFile )
        _pcLogFile = pcLogFile;

    TrkAssert( NULL != pcTrkWksConfiguration || NULL != _pcTrkWksConfiguration );
    if( NULL != pcTrkWksConfiguration )
        _pcTrkWksConfiguration = pcTrkWksConfiguration;

    TrkAssert( NULL != pLogCallback || NULL != _pLogCallback );
    if( NULL != pLogCallback )
        _pLogCallback = pLogCallback;


    // Read the log info from the log header.

    _pcLogFile->ReadExtendedHeader( CLOG_LOGINFO_START, &loginfo, CLOG_LOGINFO_LENGTH );

    // If the log hadn't been shut down properly, it's been fixed by now, but
    // we can't trust the loginfo we just read from the header.  We also
    // can't trust it if it doesn't make sense.  So if for some reason we
    // can't trust it, we'll recalculate it (this can be slow, though).

    if( !_pcLogFile->IsShutdown() || loginfo.ilogStart == loginfo.ilogEnd )
    {
        _fDirty = TRUE;
        loginfo = QueryLogInfo();
    }

    // Save the now-good information.
    _loginfo = loginfo;

}   // CLog::Initialize()


//+----------------------------------------------------------------------------
//
//  Method:     QueryLogInfo
//
//  Synopsis:   Read the log entries and determine the indices and sequence
//              numbers.
//
//  Arguments:  None
//
//  Returns:    A LogInfo structure
//
//+----------------------------------------------------------------------------

LogInfo
CLog::QueryLogInfo()
{

    SequenceNumber seqMin, seqMax;
    ULONG cEntries;
    LogIndex ilogMin, ilogMax, ilogEntry;
    LogInfo loginfo;
    LogMoveNotification lmn;
    BOOL fLogEmpty = TRUE;
    LogEntryHeader entryheader;

    TrkLog(( TRKDBG_LOG, TEXT("Reading log to determine correct indices") ));

    //  ------------
    //  Scan the log
    //  ------------

    seqMin = 0;
    seqMax = 0;

    cEntries = _pcLogFile->NumEntriesInFile();

    ilogMin = 0;
    ilogMax = cEntries - 1;

    // Scan the log and look at the sequence numbers to find
    // the start and end indices.

    for( ilogEntry = 0; ilogEntry < cEntries; ilogEntry++ )
    {
        _pcLogFile->ReadMoveNotification( ilogEntry, &lmn );

        if( LE_TYPE_MOVE == lmn.type )
        {
            SequenceNumber seq = lmn.seq;

            // If this is the first move notification that we've
            // found, then it is currently both the min and the max.

            if( fLogEmpty )
            {
                fLogEmpty = FALSE;
                seqMin = seqMax = seq;
                ilogMin = ilogMax = seq;
            }

            // If this isn't the first entry we've found, then see
            // if it is a new min or max.

            else
            {
                if( seq <= seqMin )
                {
                    seqMin = seq;
                    ilogMin = ilogEntry;
                }
                else if( seq >= seqMax )
                {
                    seqMax = seq;
                    ilogMax = ilogEntry;
                }
            }
        }   // if( LE_TYPE_MOVE == _pcLogFile->ReadMoveNotification( ilogEntry )->type )
    }   // for( ilogEntry = 0; ilogEntry < cEntries; ilogEntry++ )


    //  -------------------------------
    //  Determine the log indices, etc.
    //  -------------------------------

    // Were there any entries in the log?

    if( fLogEmpty )
    {
        // No, the log is empty.

        loginfo.ilogStart = loginfo.ilogWrite = 0;
        loginfo.ilogLast = loginfo.ilogEnd = cEntries - 1;
    }
    else
    {
        // Yes, the log is non-empty.

        // Point the start index to the oldest move in the log.
        loginfo.ilogStart = ilogMin;

        // Point the last index to the oldest move in the log,
        // and point the write index to the entry after that
        // (which is the first available entry).

        loginfo.ilogLast = loginfo.ilogWrite = ilogMax;
        _pcLogFile->AdjustLogIndex( &loginfo.ilogWrite, 1 );

        // The write & start indices should only be the same 
        // in an empty log.  We know we're not empty at this point,
        // so if they're the same, then the start index must have
        // actually advanced (otherwise, the write index wouldn't be
        // allowed to be here).  So we advance the start index.

        if( loginfo.ilogWrite == loginfo.ilogStart )
        {
            _pcLogFile->AdjustLogIndex( &loginfo.ilogStart, 1 );
        }
    }   // if( fLogEmpty ) ... else

    // The end if the log is just before the start in the circular list.

    loginfo.ilogEnd = loginfo.ilogStart;
    _pcLogFile->AdjustLogIndex( &loginfo.ilogEnd, -1 );


    // The read index and next available
    // sequence number are stored in the last entry header.

    entryheader = _pcLogFile->ReadEntryHeader( loginfo.ilogLast );

    loginfo.ilogRead = entryheader.ilogRead;
    loginfo.seqNext = entryheader.seq;

    // The sequence number of the entry last read is one below the sequence number
    // of the entry currently at the read pointer.  If everything is read 
    // (the read pointer is beyond the last entry) or if the entry at the
    // read pointer is invalid, then we'll assume that the last read seq
    // number is seqNext-1.

    _pcLogFile->ReadMoveNotification( loginfo.ilogRead, &lmn );
    loginfo.seqLastRead = ( loginfo.ilogWrite != loginfo.ilogRead && LE_TYPE_MOVE == lmn.type )
                             ? lmn.seq - 1 : loginfo.seqNext-1;

    TrkAssert( seqMax + 1 == loginfo.seqNext || 0 == loginfo.seqNext );
    TrkAssert( loginfo.seqLastRead < loginfo.seqNext );

    return( loginfo );

}   // CLog::QueryLogInfo()


//+----------------------------------------------------------------------------
//
//  Method:     GenerateDefaultLogInfo
//
//  Synopsis:   Calculates the default _loginfo structure, based only on
//              the last index.  This requires no calls to CLogFile.
//
//  Arguments:  [ilogEnd] (in)
//                  The index of the last entry in the logfile.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::GenerateDefaultLogInfo( LogIndex ilogEnd )
{
    SetDirty( TRUE );   // Must be called before changing _loginfo

    _loginfo.ilogStart = _loginfo.ilogWrite = _loginfo.ilogRead = 0;
    _loginfo.ilogLast = _loginfo.ilogEnd = ilogEnd;

    _loginfo.seqNext = 0;
    _loginfo.seqLastRead = _loginfo.seqNext - 1;

}



//+----------------------------------------------------------------------------
//
//  Method:     Flush
//
//  Synopsis:   Write the _loginfo structure to the CLogFile.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Flush( )
{
    if( _fDirty )
        _pcLogFile->WriteExtendedHeader( CLOG_LOGINFO_START, &_loginfo, CLOG_LOGINFO_LENGTH );

    SetDirty( FALSE );
}


//+----------------------------------------------------------------------------
//
//  Method:     ExpandLog
//
//  Synopsis:   Grow the log file, initialize the new entries, and update
//              our indices.  We determine how much to grow based on
//              configuration parameters in CTrkWksConfiguration.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLog::ExpandLog()
{
    TrkAssert( !_pcLogFile->IsMaxSize() );
    TrkAssert( IsFull() );

    SetDirty( TRUE );   // Must be called before changing _loginfo

    // Grow the file, initialize the new log entries, and link the new
    // entries into the existing linked list.  We only need to tell
    // the CLogFile where the start of the circular linked-list is.

    _pcLogFile->Expand( _loginfo.ilogStart );

    // Update the end pointer.

    _loginfo.ilogEnd = _loginfo.ilogStart;
    _pcLogFile->AdjustLogIndex( &_loginfo.ilogEnd, -1 );


}   // CLog::Expand



//+----------------------------------------------------------------------------
//
//  Method:     Read
//
//  Synopsis:   Read zero or more entries from the log, starting at the
//              Read index.  Read until we reach the end of the data in
//              the log, or until we've read as many as the caller
//              requested.
//
//              Note that we don't update the read index after this read,
//              the caller must call Seek to accomplish this.  This was done
//              so that if the caller encountered an error after the Read,
//              the log would still be unchanged for a retry.
//
//  Arguments:  [pNotifications] (in/out)
//                  Receives the move notification records.
//              [pseqFirst] (out)
//                  The sequence number of the first notification returned.
//              [pcRead] (in/out)
//                  (in)  the number of notifications desired
//                  (out) the number of notifications actually read
//                  If the number read is less than the number requested,
//                  the caller may assume that there are no more entries
//                  to read.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Read(CObjId rgobjidCurrent[],
           CDomainRelativeObjId rgdroidBirth[],
           CDomainRelativeObjId rgdroidNew[],
           SequenceNumber *pseqFirst,
           IN OUT ULONG *pcRead)
{

    //  --------------
    //  Initialization
    //  --------------

    LogIndex ilogEntry;
    ULONG cRead = 0;
    ULONG iRead = 0;
    SequenceNumber seqExpected = 0;

    ilogEntry = _loginfo.ilogRead;

    //  ----------------
    //  Read the entries
    //  ----------------

    // We can NOOP if the call request no entries, or if there
    // are no entries in the log, or if all the entries have
    // been read already.

    if( *pcRead != 0 && !IsEmpty() && !IsRead() )
    {
        LogMoveNotification lmn;

        // There are entries which we can read.

        // Save the sequence number of the first entry that
        // we'll return to the caller.

        _pcLogFile->ReadMoveNotification( ilogEntry, &lmn );
        *pseqFirst = lmn.seq;
        seqExpected = lmn.seq;

        // Read the entries from the log in order, validating
        // the sequence numbers as we go.

        do
        {
            // Copy the move information into the caller's buffer.
            // ReadMoveNotification doesn't make the CLogFile dirty.

            _pcLogFile->ReadMoveNotification( ilogEntry, &lmn );

            TrkAssert( seqExpected == lmn.seq );

            if( seqExpected != lmn.seq )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Invalid sequence numbers reading log (%d, %d)"),
                         seqExpected, lmn.seq ));
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }
            seqExpected++;

            rgobjidCurrent[iRead] = lmn.objidCurrent;   
            rgdroidNew[iRead]     = lmn.droidNew;
            rgdroidBirth[iRead]   = lmn.droidBirth;

            cRead++;
            iRead++;

            // Move on to the next entry.

            _pcLogFile->AdjustLogIndex( &ilogEntry, 1 );

            // Continue as long as there's still room in the caller's buffer
            // and we haven't reached the last entry.

        } while ( cRead < *pcRead && ilogEntry != _loginfo.ilogWrite );
    }

    *pcRead = cRead;

}   // CLog:Read()



//+----------------------------------------------------------------------------
//
//  CLog::DoSearch
//
//  This is a private worker method that searches the log, either for a
//  sequence number, or an object ID (which to use is determined by the
//  fSearchUsingSeq parameter).
//
//  The log entry data and index are returned.
//
//+----------------------------------------------------------------------------

// NOTE! *piFound is not modified if Search returns FALSE

BOOL
CLog::DoSearch( BOOL fSearchUsingSeq,
                SequenceNumber seqSearch,     // Use this if fSearchUsingSeq
                const CObjId &objidCurrent,   // Use this if !fSearchUsingSeq
                ULONG                *piFound,
                CDomainRelativeObjId *pdroidNew,
                CMachineId           *pmcidNew,
                CDomainRelativeObjId *pdroidBirth )
{
    BOOL fFound = FALSE;
    BOOL fFirstPass = TRUE;
    SequenceNumber seqPrevious = 0;


#if DBG
    LONG l = GetTickCount();
#endif

    // Only bother to look if there's entries in the log.

    if (!IsEmpty())
    {
        // Determine the max entries in the log so that we can
        // detect if we're in an infinite loop.

        ULONG cEntriesMax = _pcLogFile->NumEntriesInFile();
        ULONG cEntryCurrent = 0;

        LogIndex ilogSearch = _loginfo.ilogWrite;

        // Search from the end, until we find what we're looking for,
        // or we reach the beginning of the log.

        // It's important that we search backwards because of tunneling.
        // Here's the scenario ... An object is moved from machine A to
        // B, quickly back to A, and then to C.  Since it reappeared on A
        // quickly after it first disappeared, tunneling will give it the
        // same Object ID that it had before.  So when it moves to C,
        // we end up with two entries in the log for the object.  We want
        // to search backwards so that we see the move to C, not the move
        // to B.

        while( !fFound && ilogSearch != _loginfo.ilogStart )
        {
            // Check to see if we're in an infinite loop.

            if( ++cEntryCurrent > cEntriesMax )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Corrupt log file: cycle found during search")));
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }

            // Read the previous entry.

            _pcLogFile->AdjustLogIndex( &ilogSearch, -1 );
            LogMoveNotification lmnSearch;
            _pcLogFile->ReadMoveNotification( ilogSearch, &lmnSearch );

            // If this isn't a move entry, then there's nothing left to search.
            if( LE_TYPE_MOVE != lmnSearch.type )
                goto Exit;

            // Or, if this isn't the first pass, ensure that the sequence numbers
            // are consequtive.
            else if( !fFirstPass )
            {
                fFirstPass = FALSE;

                TrkAssert( seqPrevious - 1 == lmnSearch.seq );

                if( seqPrevious - 1 != lmnSearch.seq )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Corrupt log file: non-consequtive sequence numbers (%d %d)"),
                             seqPrevious, lmnSearch.seq ));
                    TrkRaiseException( TRK_E_CORRUPT_LOG );
                }

            }

            // Is this the entry we're looking for?

            if( fSearchUsingSeq && seqSearch == lmnSearch.seq
                ||
                !fSearchUsingSeq && objidCurrent == lmnSearch.objidCurrent )
            {
                if( NULL != piFound )
                    *piFound = ilogSearch;

                if( NULL != pdroidNew )
                {
                    *pdroidNew = lmnSearch.droidNew;
                    *pmcidNew = lmnSearch.mcidNew;
                    *pdroidBirth = lmnSearch.droidBirth;
                }

                fFound = TRUE;
            }
        }   // while( !fFound && ilogSearch != _loginfo.ilogStart )
    }   // if (!IsEmpty())


Exit:

    return( fFound );

}   // CLog::DoSearch



//+----------------------------------------------------------------------------
//
//  Method:     Search
//
//  Synopsis:   Search the log for an Object ID.  Once found, return that
//              entry's LinkData and BirthID.
//
//  Arguments:  [droidCurrent] (in)
//                  The ObjectID for which to search.
//              [pdroidNew] (out)
//                  The entry's LinkData
//              [pdroidBirth] (out)
//                  The entry's Birth ID.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------


BOOL
CLog::Search( const CObjId &objidCurrent,
              CDomainRelativeObjId *pdroidNew,
              CMachineId           *pmcidNew,
              CDomainRelativeObjId *pdroidBirth )
{
    ULONG iFound;
    return DoSearch( FALSE, // => Use objidCurrent
                     0,     // Therefore, we don't need a seq number
                     objidCurrent,
                     &iFound,
                     pdroidNew,
                     pmcidNew,
                     pdroidBirth );

}   // CLog::Search( CDomainRelativeObjId& ...


//+----------------------------------------------------------------------------
//
//  Method:     CLog::Search
//
//  Synopsis:   Search the log for the entry with a particular sequence
//              number.
//
//  Arguments:  [seqSearch] (in)
//                  The sequence number for which to search.
//              [piFound] (out)
//                  The index with this sequence number (if found).
//
//  Returns:    [BOOL]
//                  TRUE if found, FALSE otherwise.
//
//+----------------------------------------------------------------------------

BOOL
CLog::Search( SequenceNumber seqSearch, ULONG *piFound )
{
    CObjId oidNull;
    return DoSearch( TRUE,       // => Use seqSearch
                     seqSearch,
                     oidNull,    // We don't need to pass an objid
                     piFound,
                                 // And we don't need out-droids & mcid.
                     NULL, NULL, NULL );

}   // CLog::Search( SequenceNumber ...




//+----------------------------------------------------------------------------
//
//  Method:     Append
//
//  Synopsis:   Add a move notification to the log.  If the log is full,
//              either overwrite an old entry, or grow the log.
//
//  Arguments:  [droidCurrent] (in)
//                  The link information of the file which was moved.
//              [droidNew] (in)
//                  The link information of the new file.
//              [droidBirth] (in)
//                  The Birth ID of the file.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

// Perf optimization:  Tell the caller if the log is now full.  The service can then lazily
// expand it, hopefully before the next move occurs.

void
CLog::Append(const CVolumeId &volidCurrent,
             const CObjId &objidCurrent,
             const CDomainRelativeObjId &droidNew,
             const CMachineId           &mcidNew,
             const CDomainRelativeObjId &droidBirth)
{
    LogMoveNotification lmnWrite;

    CFILETIME cftNow;   // Defaults to current UTC
    BOOL fAdvanceStart = FALSE;
    LogEntryHeader entryheader;
    LogInfo loginfoZero;

    //  -----------------
    //  Handle a Full Log
    //  -----------------

    if( IsFull() )
    {
        // Is the log already maxed?  If so, we wrap.

        if( _pcLogFile->IsMaxSize() )
        {
            fAdvanceStart = TRUE;
            TrkLog(( TRKDBG_VOLUME, TEXT("Wrapping log") ));
        }

        // Otherwise, we'll handle it by growing the log file.

        else
            ExpandLog();
    }

    //  -------------------------
    //  Write the data to the log
    //  -------------------------

    // Before anything else, we must mark ourselves dirty.  If the logfile is
    // currently in the ProperShutdown state, this SetDirty call will take it
    // out of that state and do a flush.

    SetDirty( TRUE );

    // Mark our loginfo cache in the header as invalid,
    // in case we get pre-empted.

    memset( &loginfoZero, 0, sizeof(loginfoZero) );
    _pcLogFile->WriteExtendedHeader( CLOG_LOGINFO_START, &loginfoZero, CLOG_LOGINFO_LENGTH );

    // Collect the move-notification information

    memset( &lmnWrite, 0, sizeof(lmnWrite) );
    lmnWrite.seq = _loginfo.seqNext;
    lmnWrite.type = LE_TYPE_MOVE;

    lmnWrite.objidCurrent = objidCurrent;
    lmnWrite.droidNew = droidNew;
    lmnWrite.mcidNew = mcidNew;
    lmnWrite.droidBirth = droidBirth;
    lmnWrite.DateWritten = TrkTimeUnits( cftNow );

    // Collect the entry header information

    memset( &entryheader, 0, sizeof(entryheader) );
    entryheader.ilogRead = _loginfo.ilogRead;
    entryheader.seq = _loginfo.seqNext + 1; // Reflect that we'll increment after the write

    // Write everything to the log (this will do a flush).  If this fails, it will raise.

    _pcLogFile->WriteMoveNotification( _loginfo.ilogWrite, lmnWrite, entryheader );

    // Update the sequence number and last & write indices now that we
    // know the write was successful (all the way to the disk).

    _loginfo.seqNext++;  
    _loginfo.ilogLast = _loginfo.ilogWrite;
    _pcLogFile->AdjustLogIndex( &_loginfo.ilogWrite, 1 );

    // Do we need to advance the start pointer?
    // We save this for the end, because it may cause us to access
    // the disk.

    if( fAdvanceStart )
    {
        // We're about to advance the start index, and thus effectively
        // lose an entry.  If the read index points to the same place,
        // then we should advance it as well.

        if( _loginfo.ilogStart == _loginfo.ilogRead )
            _pcLogFile->AdjustLogIndex( &_loginfo.ilogRead, 1 );

        // Advance the start/end indices.

        _pcLogFile->AdjustLogIndex( &_loginfo.ilogEnd, 1 );
        _pcLogFile->AdjustLogIndex( &_loginfo.ilogStart, 1 );
    }

    TrkLog(( TRKDBG_VOLUME, TEXT("Appended %s to log (seq=%d)"),
             (const TCHAR*)CDebugString(objidCurrent), lmnWrite.seq ));

    // Notify the callback object that there is data available.
    // Note:  This must be the last operation of this method.

    _pLogCallback->OnEntriesAvailable();

}


//+----------------------------------------------------------------------------
//
//  Method:     Seek( SequenceNumber ...
//
//  Synopsis:   Moves the Read index to a the log entry with the specified 
//              sequence number.  If the seq number doesn't exist, we back
//              up to the start of the log.
//
//              If this seek causes us to back up the Read index, we notify
//              the PLogCallback object, since we now have data available
//              to read.
//
//  Arguments:  [seqSeek] (in)
//                  The sequence number to which to seek.
//
//  Returns:    [BOOL]
//                  TRUE if the sequence number was found, FALSE otherwise.
//
//+----------------------------------------------------------------------------

BOOL
CLog::Seek( const SequenceNumber &seqSeek )
{
    BOOL fFound = FALSE;
    SequenceNumber seqReadOriginal, seqReadNew;
    LogMoveNotification lmn;

    LogIndex ilogSearch = 0;

    // Are we seeking to the end of the log?

    if( seqSeek == _loginfo.seqNext )
    {
        // We found what we're looking for.
        fFound = TRUE;

        // Are we already at seqNext?
        if( !IsRead() )
        {
            // No, update the read index.
            SetDirty( TRUE );
            _loginfo.ilogRead = _loginfo.ilogWrite;
        }

        goto Exit;
    }

    // If the log is empty, then there's nothing we need do.

    if( IsEmpty() )
        goto Exit;

    // Or, if the caller wishes to seek beyond the end of our log, then
    // again there's nothing to do.  This could be the case, for example,
    // if the log has been restored.

    if( seqSeek >= _loginfo.seqNext )
        goto Exit;

    // Keep track of the current seq number at the read pointer, so that
    // we can later tell if it's necessary to notify the client that
    // there is "new" data.

    if( IsRead() )
    {
        seqReadOriginal = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadOriginal = lmn.seq;
    }

    // If this seq number is in the log, set the Read index
    // to it.  Otherwise set it to the oldest entry in the
    // log (that's the best we can do).

    SetDirty( TRUE );   // Must be called before changing _loginfo

    if( fFound = Search( seqSeek, &ilogSearch ))
        _loginfo.ilogRead = ilogSearch;
    else
        _loginfo.ilogRead = _loginfo.ilogStart;

    // Calculate the sequence number of the entry now at the read pointer, and
    // use it to cache the seq number of the last-read entry (recall that
    // the read pointer points to the next entry to be read, not the
    // last entry read).

    if( IsRead() )
    {
        seqReadNew = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadNew = lmn.seq;
    }

    _loginfo.seqLastRead = seqReadNew - 1;  // We already set _fDirty

    // Update the entry headers with the new read pointer.
    WriteEntryHeader();

    // If we've backed up the read pointer, notify the registered callback.

    if ( seqReadOriginal > seqReadNew )
    {
         // Note:  This must be the last operation of this method.
        _pLogCallback->OnEntriesAvailable();
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return( fFound );

}   // CLog::Seek( SequenceNumber ...



//+----------------------------------------------------------------------------
//
//  Method:     Seek( origin ...
//
//  Synopsis:   Move the read pointer relative to an origin (begin, current, end).
//
//              There are two differences between a CLog seek and a file seek:
//              -  If you seek from the beginning (SEEK_SET), and seek beyond the
//                 end of the log, the pointer is wrapped, rather than growing
//                 the log.
//              -  If you seek from the current location (SEEK_CUR), and seek
//                 beyond the end of the log, the log is not grown, and there
//                 is no wrap, the index simply stops there (either at _loginfo.ilogWrite
//                 or _loginfo.ilogStart).
//
//  Arguments:  [origin]
//                  Must be either SEEK_SET or SEEK_CUR (there is currently no
//                  support for SEEK_END).
//              [iSeek]
//                  The amount to move relative to the origin.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Seek( int origin, int iSeek )
{

    SequenceNumber seqReadOriginal = 0, seqReadNew = 0;

    LogMoveNotification lmn;

    // Early exit if there's nothing to do

    if( IsEmpty() )
        goto Exit;

    // Keep track of where we are now, so that we can determine if
    // we've gone overall backwards or forwards.

    if( IsRead() )
    {
        seqReadOriginal = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadOriginal = lmn.seq;
    }

    // Seek based on the origin.

    switch( origin )
    {
    case SEEK_SET:
        {
            // Advance from the start index.

            LogIndex ilogRead = _loginfo.ilogStart;

            _pcLogFile->AdjustLogIndex( &ilogRead, iSeek );

            SetDirty( TRUE );   // Must be called before changing _loginfo
            _loginfo.ilogRead = ilogRead;
        }
        break;

    case SEEK_CUR:
        {
            // Advance or retreat from the current read index.  

            LogIndex ilogRead = _loginfo.ilogRead;

            _pcLogFile->AdjustLogIndex( &ilogRead, iSeek, CLogFile::ADJUST_WITHIN_LIMIT,
                                        iSeek >= 0 ? _loginfo.ilogWrite : _loginfo.ilogStart );

            SetDirty( TRUE );   // Must be called before changing _loginfo
            _loginfo.ilogRead = ilogRead;
        }
        break;

    default:

        TrkAssert( FALSE && TEXT("Unexpected origin in CLog::Seek") );
        break;
    }

    // Calculate the sequence number of the entry at the read pointer, and
    // use it to store the seq number of the last-read entry (recall that
    // the read pointer points to the next entry to be read, not the
    // last entry read).

    if( IsRead() )
    {
        seqReadNew = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadNew = lmn.seq;
    }

    SetDirty( TRUE );   // Must be called before changing _loginfo
    _loginfo.seqLastRead = seqReadNew - 1;

    // Update the entry headers with the new read pointer.
    WriteEntryHeader();


    // If we've backed up the read pointer, notify the registered callback.

    if ( seqReadOriginal > seqReadNew )
    {
         // Note:  This must be the last operation of this method.
        _pLogCallback->OnEntriesAvailable();
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CLog::Seek( origin ...



//+----------------------------------------------------------------------------
//
//  Method:     CLog::IsRead( LogIndex ) (private)
//
//  Synopsis:   Determine if the specified entry has been read.  See also
//              the IsRead(void) overload, which checks to see if the whole
//              log has been read.
//
//  Inputs:     [ilog] (in)
//                  The index in the log to be checked.  It is assumed
//                  that this index points to a valid move notification
//                  entry.
//
//  Outputs:    [BOOL]
//                   True if and only if the entry has been marked as read.
//
//+----------------------------------------------------------------------------

BOOL
CLog::IsRead( LogIndex ilog )
{
    LogMoveNotification lmn;

    // Has the whole log been read?

    if( IsRead() )
        return( TRUE );

    // Or, has this entry been read?

    _pcLogFile->ReadMoveNotification( ilog, &lmn );

    if( _loginfo.seqLastRead >= lmn.seq )
        return( TRUE );

    // Otherwise, we know the entry hasn't been read.

    else
        return( FALSE );

}   // CLog::IsRead( LogIndex )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\delmgr.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  delmgr.cxx
//
//  Implementation of CDeletionsManager, which watches file deletes on
//  NTFS5 to determine if a link source delete notification should be
//  sent to trksvr.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::Initialize
//
//  Initialize the delete-notify timer.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::Initialize( const CTrkWksConfiguration *pconfigWks )
{
    _pLatestDeletions = NULL;
    _pOldestDeletions = NULL;
    _cLatestDeletions = 0;
    _pconfigWks = pconfigWks;

    _csDeletions.Initialize();

    _fInitialized = TRUE;

    _timerDeletions.Initialize( this,
                                NULL,           // No name (non-persistent timer)
                                                // Context ID
                                DELTIMER_DELETE_NOTIFY,
                                pconfigWks->GetDeleteNotifyTimeout(),
                                CNewTimer::NO_RETRY,
                                0, 0, 0 );      // Ignored for non-retrying timer
}


//+----------------------------------------------------------------------------
//
//  CDeleteionsManager::UnInitialize
//
//  Free the lists of deletions, and free the timer.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::UnInitialize()
{
    if (_fInitialized)
    {
        _fInitialized = FALSE;
        _timerDeletions.Cancel();


        FreeDeletions();
        _pOldestDeletions = _pLatestDeletions;
        FreeDeletions();

        _timerDeletions.UnInitialize();

        _csDeletions.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::NotifyAddOrDelete
//
//  This method is called (by the CObjIdIndexChangeNotifier) when an object
//  ID has been added, or been removed by a delete (not removed by a move).
//  When an objid is deleted, we add the birth ID to a list, and after a time
//  we'll send it up to trksvr.  When an objid is added, we see if its birth
//  ID is in our list of delete-notifies (this happens after tunnelling), and
//  remove it if it is.
//
//  Since we hold on to deletes for at least 5 minutes (configurable), and
//  the tunnelling windows is 15 seconds (though also configurable), we don't
//  worry about a add (tunnel) message coming in after we've already sent
//  a delete notification to trksvr.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::NotifyAddOrDelete( ULONG Action, const CDomainRelativeObjId & droid )
{
    // Note: this function must not access _pOldestDeletions

    DROID_LIST_ELEMENT * Element;

    // Ignore if we're uninitialized (this will happen if the machine is
    // in a workgroup).

    if( !_fInitialized )
        return;

    // If bit 0 if the volume id is clear, then the file hasn't moved off the
    // volume and there's nothing we need do.

    if (! droid.GetVolumeId().GetUserBitState())
    {
        if( FILE_ACTION_REMOVED_BY_DELETE == Action )
        {
            TrkLog(( TRKDBG_OBJID_DELETIONS,
                     TEXT("Ignoring droid=%s because bit 0 is clear\n"),
                     (const TCHAR*)CDebugString(droid) ));
        }
        return;
    }

    // Take the lock and see if we care about the action

    _csDeletions.Enter();

    __try
    {
        // Object ID Removed by DeleteFile
        if( FILE_ACTION_REMOVED_BY_DELETE == Action )
        {
            // Add this droid to the list of delete-notifies we need to send to the DC.

            if( _pconfigWks->GetParameter( IGNORE_MOVES_AND_DELETES_CONFIG ) )
            {
                TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Ignoring delete due to configuration") ));
            }
            else if( _cLatestDeletions < _pconfigWks->GetParameter( MAX_DELETE_NOTIFY_QUEUE_CONFIG ))
            {
                Element = new DROID_LIST_ELEMENT;
                if( Element )
                {
                    _cLatestDeletions++;

                    Element->droid = droid;
                    Element->droid.GetVolumeId().Normalize();

                    // Insert the deletion onto the head of the first list.

                    if (_pLatestDeletions == NULL)
                    {
                        _timerDeletions.SetRecurring( );
                        TrkLog(( TRKDBG_OBJID_DELETIONS,
                                 TEXT("DeleteNotify Timer: %s"),
                                 (const TCHAR*)CDebugString(_timerDeletions) ));
                    }

                    Element->pNext = _pLatestDeletions;
                    _pLatestDeletions = Element;

                    TrkLog(( TRKDBG_OBJID_DELETIONS,
                             TEXT("Inserted droid=%s into DROID_LIST_ELEMENT at %08x"),
                             (const TCHAR*)CDebugString(droid), Element));
                }
            }
            #if DBG
            else
            {
                TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Ignoring delete-notify due to max queue size") ));
            }
            #endif
        }   // if( FILE_ACTION_REMOVED_BY_DELETE == Action )

        else if( FILE_ACTION_ADDED == Action )
        {
            // See if this droid is in our delete-list.  When a document does a safe-save,
            // the first thing we see is the file getting deleted, and we add the droid
            // to our list of delete-notifies to send to the DC.  But when the ID gets
            // tunnelled, we need to remove it from that list.

            BOOL fDone = FALSE;
            DROID_LIST_ELEMENT **ppScan;
            CDomainRelativeObjId droidBirth = droid;
            droidBirth.GetVolumeId().Normalize();

            // Start with the first list
            ppScan = &_pLatestDeletions;

            for( int i = 0; i < 2; i++ )
            {
                while( NULL != *ppScan )
                {
                    if( (*ppScan)->droid == droidBirth )
                    {
                        // This is the entry we're looking for.
                        // Remove it.

                        DROID_LIST_ELEMENT *pDel = *ppScan;
                        *ppScan = (*ppScan)->pNext;
                        delete pDel;
                        fDone = TRUE;

                        TrkLog((TRKDBG_OBJID_DELETIONS,
                                TEXT("Removed droid=%s delete-notify list"),
                                (const TCHAR*)CDebugString(droid) ));

                        break;  // while
                    }

                    // Move to the next element in this list.
                    ppScan = &(*ppScan)->pNext;
                }

                // If we're done then break out.  Otherwise, move on
                // to the other linked list.

                if( fDone )
                    break;
                else
                    ppScan = &_pOldestDeletions;

            }   // for( int i = 0; i < 2; i++ )
        }   // else if( FILE_ACTION_ADDED == Action )
    }
    __finally
    {
        _csDeletions.Leave();
    }
}

//+----------------------------------------------------------------------------
//
//  CDeletionsManager::OnDeleteNotifyTimeout
//
//  Process the delete notifications in the linked list at _pOldestDeletions.
//  The notifications from this list are sent to trksvr, then the entries
//  in that list are freed, and the entries from _pLatestDeletions are
//  moved to _pOldestDeletions.
//
//  Note:  This method assumes it is non-reentrant, since it is only
//  called when the single delete notify timer fires.
//
//+----------------------------------------------------------------------------

PTimerCallback::TimerContinuation
CDeletionsManager::OnDeleteNotifyTimeout()
{

    CAvailableDc adc;
    PTimerCallback::TimerContinuation continuation = CONTINUE_TIMER;

    // Keep track of the number of attempts to send a single
    // batch.
    static cAttempts = 0;


    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Delete notify timeout") ));

    __try   // __finally
    {

        // Are there deletions that need to be sent to trksvr?

        if( _pOldestDeletions != NULL && !_pconfigWks->_fIsWorkgroup )
        {
            TRKSVR_MESSAGE_UNION Msg;
            CDomainRelativeObjId adroidBirth[ 32 ];
            DROID_LIST_ELEMENT * pScan;
            ULONG cdroidBirth;

            pScan = _pOldestDeletions;

            // Send the delete notifications in batches.

            do
            {
                g_ptrkwks->RaiseIfStopped();

                //
                // Count the number of list elements and put into the
                // array format for the RPC call.
                //

                for ( cdroidBirth = 0;
                      pScan != NULL && cdroidBirth < ELEMENTS(adroidBirth);
                      cdroidBirth++, pScan = pScan->pNext )
                {
                    adroidBirth[cdroidBirth] = pScan->droid;
                    TrkAssert( pScan != pScan->pNext && pScan->pNext != _pOldestDeletions );
                }

                if( cdroidBirth != 0 )
                {
                    // As a sanity check, make sure we don't stick on a single
                    // batch forever.
                    if( cAttempts >= _pconfigWks->GetParameter( MAX_DELETE_NOTIFY_ATTEMPTS_CONFIG ) )
                    {
                        TrkLog(( TRKDBG_WARNING,
                                 TEXT("Aborting delete-notify list") ));
                        break;
                    }

                    // Send the delete notifications to trksvr

                    Msg.MessageType = DELETE_NOTIFY;
                    Msg.Priority = PRI_5;
                    Msg.Delete.cVolumes = 0;
                    Msg.Delete.pVolumes = NULL;

                    Msg.Delete.adroidBirth = adroidBirth;
                    Msg.Delete.cdroidBirth = cdroidBirth;

                    // if the DC is down -> exception (really can't do anything about it)

                    cAttempts++;
                    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Sending %d delete notifications"), cdroidBirth ));
                    adc.CallAvailableDc(&Msg);
                    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Sent %d delete notifications"), cdroidBirth ));

                    // Free the entries that we've sent so far.
                    FreeDeletions( pScan );
                }

                // Reset the per-batch retry count.
                cAttempts = 0;

            } while (pScan != NULL);
        }
    }
    __finally
    {
        if( AbnormalTermination() )
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't send deletions") ));
        else
        {
            // Free the old deletions, and swap the list so that the
            // "new" deletions become "old" (to be sent the next time
            // this timer fires).

            FreeDeletions();
            cAttempts = 0;

            _csDeletions.Enter();

            if (_pLatestDeletions == NULL)
            {
                //
                // If there is nothing to notify, cancel the timer
                //

                continuation = BREAK_TIMER;
            }

            _pOldestDeletions = _pLatestDeletions;
            _pLatestDeletions = NULL;
            _cLatestDeletions = 0;

            _csDeletions.Leave();
        }

        adc.UnInitialize();
    }

    return( continuation );
}


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::FreeDeletions
//
//  Free the delete notifications from the "old" list
//  up to (but not including) pStop or the end.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::FreeDeletions( DROID_LIST_ELEMENT *pStop )
{
    DROID_LIST_ELEMENT * pScan = _pOldestDeletions;
    while (pScan && pStop != pScan)
    {
        DROID_LIST_ELEMENT * pNext = pScan->pNext;
        delete pScan;
        pScan = pNext;
    }

    _pOldestDeletions = pStop;
}


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::Timer
//
//  Called when the delete timer fires.  This triggers us to send the
//  notifications from the old list, and then to move the "new" items to
//  the old list.
//
//+----------------------------------------------------------------------------

PTimerCallback::TimerContinuation
CDeletionsManager::Timer( ULONG ulTimerId )
{
    TimerContinuation continuation = CONTINUE_TIMER;

    TrkAssert( ulTimerId == DELTIMER_DELETE_NOTIFY );
    TrkAssert( _timerDeletions.IsRecurring() );

    __try
    {
        // This will raise if service is stopping
        continuation = OnDeleteNotifyTimeout();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
    }

    return( continuation );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\makefile.inc ===
$(O)\trkwks_s.c : $(PROJECT_ROOT)\genx\types\tracking\idl\$(O)\trkwks_s.c
   copy $? $@

clean:
   -del /q /f $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\logsect.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+----------------------------------------------------------------------------
//
//  File:       LogSect.cxx
//
//  Classes:    CLogFileSector
//
//+----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Synopsis:   Initialize CLogFileSector.  This is called once for the object,
//              not for every sector it touches.
//
//  Inputs:     [cSkipSectors] (in)
//                  The number of sectors at the front of the file we're not
//                  allowed to touch.
//              [cbSector] (in)
//                  The size of a disk sector.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::Initialize( ULONG cSkipSectors, ULONG cbSector )
{
    // Is the sector large enough?

    if( sizeof(LogEntry) + sizeof(LogEntryHeader) > cbSector )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Sector size isn't large enough for log sectors") ));
        TrkRaiseWin32Error( ERROR_BAD_CONFIGURATION );
    }

    // Allocate enough memory to hold a single sector.  This is the
    // only alloc in the class.

    if( NULL != _pvSector && _cbSector != cbSector )
    {
        delete [] _pvSector;
        _pvSector = NULL;
    }

    if( NULL == _pvSector )
    {
        _pvSector = static_cast<void*>( new BYTE[ cbSector ] );
        if( NULL == _pvSector )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't alloc a sector in CLogFileSector")));
            TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    // The entry header is at the end of every sector, always in the same place.

    _pEntryHeader = reinterpret_cast<LogEntryHeader*>( reinterpret_cast<BYTE*>(_pvSector)
                                                       +
                                                       cbSector
                                                       -
                                                       sizeof(*_pEntryHeader) );

    // Initialize the flags

    _fValid = FALSE;
    _fDirty = FALSE;

    // Save the inputs

    _cSkipSectors = cSkipSectors;
    _cbSector = cbSector;

    // Calculate how many entries can fit in a sector.

    _cEntriesPerSector = ( _cbSector - sizeof(*_pEntryHeader) ) / sizeof(LogEntry);

}   // CLogFileSector::Initialize


//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Synopsis:   Free resources and re-initialize data members.
//
//  Inputs:     None
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::UnInitialize()
{
    if( NULL != _pvSector )
    {
        if( IsOpen() )
            OnClose();

        void *pvSector = _pvSector;
        _pvSector = NULL;
        delete [] pvSector;
    }

    _fValid = FALSE;

}   // CLogFileSector::UnInitialize



//+----------------------------------------------------------------------------
//
//  Method:     LoadSector
//
//  Synopsis:   Load a data sector from the log file.
//
//  Inputs:     [ilogEntry] (in)
//                  The index of the entry to load.  This is a 0-relative
//                  index, relative to the first data sector in the file.
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::LoadSector( LogIndex ilogEntry )
{
    ULONG iSector = 0;
    LARGE_INTEGER liOffset;
    NTSTATUS status = STATUS_SUCCESS;

    TrkAssert( _pvSector );
    TrkAssert( NULL != _hFile );

    // We can skip everything if the correct sector is already loaded

    if( !_fValid 
        ||
        ilogEntry < _ilogCurrentFirst
        ||
        ilogEntry >= _ilogCurrentFirst + _cEntriesPerSector
      )
    {
        // No, the sector isn't currently loaded.

        ULONG cbRead = 0;
        IO_STATUS_BLOCK IoStatusBlock;

        // If the current sector is dirty, flush it now, because we're
        // about to lose it.

        Flush();

        // Which sector contains this log entry?

        iSector = ilogEntry / _cEntriesPerSector + _cSkipSectors;

        // What is the byte index of this sector?

        liOffset.QuadPart = iSector * _cbSector;

        // Read the sector

        status = NtReadFile( _hFile, NULL, NULL, NULL,
                             &IoStatusBlock, _pvSector, _cbSector,
                             &liOffset, NULL );


        if ( STATUS_PENDING == status )
        {
            // Wait for the operation to complete.  The resulting status
            // will be put in the IOSB

            status = NtWaitForSingleObject( _hFile, FALSE, NULL );

            if( NT_SUCCESS(status) )
                status = IoStatusBlock.Status;
        }

        // Validate the results of the read

        if ( !NT_SUCCESS(status) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't read data sector from log file")));
            if(STATUS_VOLUME_DISMOUNTED == status)
            {
                TrkRaiseNtStatus(status);
            }
            else
            {
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }
        }

        if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
            g_ptrkwks->_entropy.Put();

        if( _cbSector != IoStatusBlock.Information )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't read enough data bytes from log (%d)"),
                               IoStatusBlock.Information ));
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }

        // Remember what sector we've got (we keep the index of the first
        // entry in this sector).

        _ilogCurrentFirst = ( iSector - _cSkipSectors ) * _cEntriesPerSector;
        _fValid = TRUE;

    }   // if( !_fValid ...
}   // CLogFileSector::LoadSector



//+----------------------------------------------------------------------------
//
//  Method:     Flush
//
//  Synopsis:   Flush the current sector (if there is one) to the underlying
//              log file.
//
//  Inputs:     None
//  
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::Flush( )
{
    NTSTATUS status = STATUS_SUCCESS;
    RaiseIfNotOpen();

    // Is the sector loaded & dirty?

    if( _fValid && _fDirty )
    {
        // Yes, we need to flush it

        ULONG iSector = 0;
        LARGE_INTEGER liOffset;
        IO_STATUS_BLOCK IoStatusBlock;

        TrkAssert( NULL != _hFile );

        // Which sector contains the currently-loaded log entry?

        iSector = _ilogCurrentFirst / _cEntriesPerSector + _cSkipSectors;

        // Write the sector to the file

        liOffset.QuadPart = iSector * _cbSector;


        status = NtWriteFile( _hFile, NULL, NULL, NULL,
                              &IoStatusBlock, _pvSector, _cbSector,
                              &liOffset, NULL );

        if ( STATUS_PENDING == status )
        {
            // Wait for the operation to complete.  The resulting status
            // will be put in the IOSB

            status = NtWaitForSingleObject( _hFile, FALSE, NULL );

            if( NT_SUCCESS(status) )
                status = IoStatusBlock.Status;
        }

        // Validate the results of the write

        if ( !NT_SUCCESS(status) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't write data to the log file")));
            TrkRaiseNtStatus( status );
        }

        if( _cbSector != IoStatusBlock.Information )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't write enough data bytes to the log (%d)"),
                               IoStatusBlock.Information ));
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }

        if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
            g_ptrkwks->_entropy.Put();

        SetDirty( FALSE );

    }   // if( _fValid && _fDirty )

}   // CLogFileSector::Flush
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\main.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       main.cxx
//
//  Contents:   Main startup for Tracking (Workstation) Service
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"
#undef TRKDATA_ALLOCATE

#include "svcs.h"

#define THIS_FILE_NUMBER    MAIN_CXX_FILE_NO



//+----------------------------------------------------------------------------
//
//  SvcsWorkerCallback
//
//  This is the callback routine that we register with the services.exe
//  thread pool.  We only register one item with that thread pool, an
//  event that gets signaled when the service has been stopped.
//
//+----------------------------------------------------------------------------

//HANDLE g_hWait = NULL;

void
ServiceStopCallback( PVOID pContext, BOOLEAN fTimeout )
{
    CTrkWksSvc *ptrkwks = reinterpret_cast<CTrkWksSvc*>(pContext);

    __try
    {
        /*
        UnregisterWait( g_hWait );
        g_hWait = NULL;
        */

        // Close down the service.  This could block while threads are
        // completed.

        ptrkwks->UnInitialize( S_OK );
        CTrkRpcConfig::_fInitialized = FALSE;
        delete ptrkwks;

        TrkAssert( NULL == g_ptrkwks );

        // Close the stop event and the debug log

        // Uninitialize the DLL, since it's never actually unloaded.
        CommonDllUnInit( &g_ctrkwks );
#if DBG
        TrkDebugDelete( );
#endif

        TrkLog((TRKDBG_WKS, TEXT("TrkWks service stopped") ));
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception during service stop - %08x"), GetExceptionCode() ));
    }


}

//+----------------------------------------------------------------------------
//
//  ServiceMain
//
//  This function is exported from the dll, and is called when we run
//  under svchost.exe.
//
//+----------------------------------------------------------------------------

VOID WINAPI
ServiceMain(DWORD dwArgc, LPTSTR *lptszArgv)
{
    SVCS_ENTRY_POINT( dwArgc, lptszArgv, NULL, NULL );
}


//+----------------------------------------------------------------------------
//
//  ServiceEntry
//
//  This function is also exported from the dll, and is called directly when
//  we run under services.exe (the normal case), but is also called by
//  ServiceMain when we run under svchost.exe.  We distinguish between the
//  two by checking pSvcsGlobalData (non-NULL iff running under services.exe).

//  Since we use the Win32 thread pool, this routine returns after some
//  initialization, it isn't held for the lifetime of the service (except
//  when run under svchost.exe).
//
//+----------------------------------------------------------------------------

VOID
SVCS_ENTRY_POINT(
    DWORD NumArgs,
    LPTSTR *ArgsArray,
    PSVCHOST_GLOBAL_DATA pSvcsGlobalData,
    IN HANDLE  SvcRefHandle
    )
{


    HRESULT     hr = S_OK;
    BOOL fDllInitialized = FALSE;
    CTrkWksSvc *ptrkwks = NULL;

#if DBG
    BOOL fDbgLogInitialized = FALSE;
#endif

    __try
    {
        #if DBG
            {
                CTrkConfiguration cTrkConfiguration;
                cTrkConfiguration.Initialize();

                TrkDebugCreate( cTrkConfiguration._dwDebugStoreFlags, "TrkWks" );
                cTrkConfiguration.UnInitialize();
                fDbgLogInitialized = TRUE;
            }
        #endif

        // Initialize the DLL itself.  This raises if there is already a running
        // trkwks service.

        CommonDllInit( &g_ctrkwks );

        TrkLog(( TRKDBG_WKS, TEXT("\n") ));

        // Create and initialize the primary service object

        ptrkwks = new CTrkWksSvc;
        if( NULL == ptrkwks )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc CTrkWksSvc") ));
            return;
        }

        ptrkwks->Initialize( pSvcsGlobalData );
        TrkAssert( NULL != g_ptrkwks );

        // Are we in services.exe?

        /*
        if( NULL != pSvcsGlobalData )
        {
            // Yes.  Register the stop event with the thread pool.
            // Register as a long function, so that when we do an LPC connect
            // in CPort::UnInitialize, the thread pool will be willing to create
            // a thread for CPort::DoWork to process the connect.

            if( !RegisterWaitForSingleObject( &g_hWait,
                                              g_hServiceStopEvent,
                                              ServiceStopCallback,
                                              g_ptrkwks, INFINITE,
                                              WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION  ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't add service stop event to thread pool") ));
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                        HRESULT_FROM_WIN32(GetLastError()),
                                        TRKREPORT_LAST_PARAM );
                TrkRaiseLastError();
            }

        }
        else
        {
            // No, we're running in svchost.exe.  We'll use this thread to wait
            // on the stop event.

            if( WAIT_OBJECT_0 != WaitForSingleObject( g_hServiceStopEvent, INFINITE ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't wait for g_hServiceStopEvent (%lu)"),
                         GetLastError() ));
                TrkRaiseLastError();
            }

            // The service is stopping.  Call the same callback routine that's called
            // by the services thread pool when we run under services.exe.

            ServiceStopCallback( ptrkwks, FALSE );
        }
        */

        ptrkwks = NULL;
    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
#if DBG
        if( fDbgLogInitialized )
            TrkLog((TRKDBG_ERROR, TEXT("couldn't initialize, hr=%08X"),hr));
#endif

        if( NULL != ptrkwks )
        {
            __try
            {
                ptrkwks->UnInitialize( hr );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                TrkAssert( !TEXT("Unexpected exception in trkwks!ServiceEntry") );
            }
            TrkAssert( NULL == g_ptrkwks );
            delete ptrkwks;
            ptrkwks = NULL;
        }

        if( fDllInitialized )
            CommonDllUnInit( &g_ctrkwks );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\stub_trkwks_c.c ===
#undef RPC_NO_WINDOWS_H
#include <trkwks_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\munglog.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

// This is not production code

#include <stdio.h>
#include <tchar.h>
#include <windows.h>

#include "munglog.hxx"


HRESULT
OpenLog( int vol, HANDLE *phFile )
{
    TCHAR tszPath[ MAX_PATH + 1 ];

    _tcscpy( tszPath, TEXT("A:\\~secure.nt\\tracking.log" ));
    *tszPath += vol;

    *phFile = CreateFile( tszPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                          NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if( INVALID_HANDLE_VALUE == *phFile )
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    else
        return( S_OK );
}

HRESULT
WriteLog( HANDLE hFile, ULONG ulOffset, void *pv, const ULONG cb )
{
    HRESULT hr = S_OK;
    ULONG cbWritten;

    if( !SetFilePointer( hFile, ulOffset, NULL, FILE_BEGIN ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }


    if( !WriteFile( hFile, pv, cb, &cbWritten, NULL )
        ||
        cb != cbWritten
        )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

Exit:

    return( hr );
}


HRESULT
MungeLog( EnumMunge enumMunge, void *pv, int vol )
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    hr = OpenLog( vol, &hFile );
    if( FAILED(hr) ) goto Exit;

    if( MUNGE_MACHINE_ID == enumMunge )
        hr = WriteLog( hFile, MUNGELOG_MACHINEID_OFFSET, pv, MUNGELOG_CB_MACHINEID );
    else
        hr = WriteLog( hFile, MUNGELOG_VOLSECRET_OFFSET, pv, MUNGELOG_CB_VOLSECRET );

Exit:

    if( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );

    return( hr );

}


/*
extern "C" void wmain()
{
    HRESULT hr;
    BYTE mcid[ 16 ];
    BYTE secret[ 16 ];

    strncpy( (char*)&mcid, "abcdefghijklmnopqrstuvwxyz", sizeof(mcid) );
    strncpy( (char*)&secret, "zyxwvutsrqponmlkjihgfedcba", sizeof(secret) );

    hr = MungeLog( MUNGE_VOLUME_SECRET, &secret, 4 );
    printf( "Secret = %08x\n", hr );

    hr = MungeLog( MUNGE_MACHINE_ID, &mcid, 4 );
    printf( "Machine = %08x\n", hr );

}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\stub_trksvr_c.c ===
#undef RPC_NO_WINDOWS_H
#include <trksvr_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\oidindex.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  oidindex.cxx
//
//  Implementation of CObjIdIndexChangeNotifier, which moniters the
//  object ID index for changes.  When a change is received, the
//  CVolume is notified.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"

//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::DoWork
//
//  Called by the work manager - on the primary thread - when we've received
//  a notification from the object ID index.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::DoWork()
{
    LPBYTE pbScan = _Buffer;    
    FILE_NOTIFY_INFORMATION * pNotifyInfo;

    // Get the size and ntstatus of the notification.

    DWORD dwNumberOfBytesTransfered = static_cast<DWORD>(_Overlapped.InternalHigh);
    NTSTATUS status = static_cast<NTSTATUS>(_Overlapped.Internal);

    _cs.Enter();
    __try   // __except
    {
        // Is this a good notification?

        if( NT_SUCCESS(status) )
        {
            // Did we get data in this notification?
            if( dwNumberOfBytesTransfered >= sizeof(FILE_NOTIFY_INFORMATION) )
            {
                // Yes.  Loop through the entries, calling to special handlers
                // for delete notifications and tunnelling-failure notifications.

                do
                {
                    pNotifyInfo = (FILE_NOTIFY_INFORMATION*)pbScan;
                    FILE_OBJECTID_INFORMATION *poi = (FILE_OBJECTID_INFORMATION*) pNotifyInfo->FileName;
    
                    TrkLog((TRKDBG_OBJID_DELETIONS,
                            TEXT("NTFS ObjId Index: %s"),
                            (const TCHAR*)CDebugString( _pVolume->GetVolIndex(),
                            pNotifyInfo) ));

                    // Check for adds/deletes

                    if (pNotifyInfo->Action == FILE_ACTION_REMOVED_BY_DELETE
                        ||
                        pNotifyInfo->Action == FILE_ACTION_ADDED)
                    {
                        // Notify the general add/deletions handler

                        CDomainRelativeObjId droidBirth( *poi );
                        _pObjIdIndexChangedCallback->NotifyAddOrDelete( pNotifyInfo->Action, droidBirth );
                    }

                    else if( pNotifyInfo->Action == FILE_ACTION_REMOVED )
                    {
                        // The volume needs to know about direct OID removals
                        // (it has special code to protect the volid).

                        CObjId objid( FOI_OBJECTID, *poi );
                        _pVolume->NotifyAddOrDelete( pNotifyInfo->Action, objid );

                    }

                    // Check for tunnelling notifications
                    else
                    if (pNotifyInfo->Action == FILE_ACTION_ID_NOT_TUNNELLED)
                    {
                        // An attempt to tunnel an object ID failed because another file on the
                        // same volume was already using it.
                        _pVolume->FileActionIdNotTunnelled( (FILE_OBJECTID_INFORMATION*) pNotifyInfo->FileName );
                    }

                } while ( pNotifyInfo->NextEntryOffset != 0 &&
                          ( pbScan += pNotifyInfo->NextEntryOffset) );
            }   // if( dwNumberOfBytesTransfered >= sizeof(FILE_NOTIFY_INFORMATION) )

            // We didn't get any data.  Is this notification telling us that the IRP was
            // cancelled?

            else if( STATUS_NOTIFY_CLEANUP == status )
            {
                TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("OverlappedCompletionRoutine on %c: cleaning up"),
                         VolChar( _pVolume->GetIndex() ) ));
            }
        }   // if( NT_SUCCESS(status) )

        else if( STATUS_CANCELLED == status )
        {
            // The thread on which we made the ReadDirectoryChanges call terminated,
            // thus terminating our IRP.  We should now be running on an IO thread, since
            // we register with WT_EXECUTEINIOTHREAD, so we just fall through and
            // re-issue the IRP.

            TrkLog(( TRKDBG_OBJID_DELETIONS,
                     TEXT("OverlappedCompletionRoutine on %c: ignoring status_cancelled"),
                     VolChar( _pVolume->GetIndex() ) ));
        }
        else
        {
            // If we failed for any other reason, there's something wrong.  We don't
            // want to call ReadDirectoryChanges again, because it might give us the
            // same failure right away, and we'd thus be in an infinite loop.

            TrkLog(( TRKDBG_ERROR, TEXT("OverlappedCompletionRoutine on %c: aborting due to %08x"),
                      status ));
            CloseHandle( _hDir );
            _hDir = INVALID_HANDLE_VALUE;
        }

        // When StopListeningAndClose is called, CancelIo is called, which triggers
        // this DoWork routine.  But we don't run until we get the critical section,
        // after which time _hDir will be invalid.

        if( INVALID_HANDLE_VALUE != _hDir )
        {
            StartListening();
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        // We should never get any kind of an error here.  If we do, the simplest
        // recourse is just to reinit the volume.

        _pVolume->OnHandlesMustClose();
    }

    _cs.Leave();

    return;
}

//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::Initialize
//
//  Initialize the critical section and register with the work manager.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::Initialize(
    TCHAR *ptszVolumeDeviceName,
    PObjIdIndexChangedCallback * pObjIdIndexChangedCallback,
    CVolume * pVolumeForTunnelNotification
    )
{
    TrkAssert( !_fInitialized );

    _cs.Initialize();
    _fInitialized = TRUE;

    _ptszVolumeDeviceName = ptszVolumeDeviceName;
    _pObjIdIndexChangedCallback = pObjIdIndexChangedCallback;
    _hDir = INVALID_HANDLE_VALUE;
    _pVolume = pVolumeForTunnelNotification;

    TrkAssert( NULL == _hCompletionEvent );
    _hCompletionEvent = CreateEvent( NULL, FALSE, FALSE, NULL );    // Auto-reset, not signaled
    if( NULL == _hCompletionEvent )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create completion event for objid index change notify (%lu)"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

    // Register the completion event with the thread pool.

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hCompletionEvent, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTEINWAITTHREAD );
    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CObjIdIndexChangeNotifier (%lu) for %s"),
                 GetLastError(), ptszVolumeDeviceName ));
        TrkRaiseLastError();
    }
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("Registered objid index change notification (%p)"),
                 _hRegisterWaitForSingleObjectEx ));
}




//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::StartListening
//
//  Call ReadDirectoryChangesW on the handle to the object ID index.
//  This is an event-based async call, so it returns immediately, and
//  NTFS signals the event when there's a notification ready.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::StartListening()
{
    // NTFS will write the notification into the _Overlapped structure.

    memset(&_Overlapped, 0, sizeof(_Overlapped));
    _Overlapped.hEvent = _hCompletionEvent;
    _Overlapped.Internal = STATUS_INTERNAL_ERROR;

    if (!ReadDirectoryChangesW( _hDir,
        _Buffer,                      // pointer to the buffer to receive the read results
        sizeof(_Buffer),              // length of lpBuffer
        FALSE,                        // flag for monitoring directory or directory tree
        FILE_NOTIFY_CHANGE_FILE_NAME, // filter conditions to watch for
        &_dwDummyBytesReturned,       // number of bytes returned
        &_Overlapped,                 // pointer to structure needed for overlapped I/O
        NULL ))                       // pointer to completion routine
    {
        CloseHandle(_hDir);
        _hDir = INVALID_HANDLE_VALUE;

        TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("AsyncListen failed to ReadDirectoryChanges %d"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

    // Ordinarily, the previous call will leave an IO pending.  If, however,
    // it actually returns right away with data, set the event as if the data came
    // back async.

    if( GetOverlappedResult( _hDir, &_Overlapped, &_dwDummyBytesReturned, FALSE /*Don't Wait*/ ))
    {
        // There was data immediately available.  Handle it in the normal way.
        TrkVerify( SetEvent( _Overlapped.hEvent ));
    }
    else if( ERROR_IO_INCOMPLETE != GetLastError() )    // STATUS_PENDING
    {
        // This should never occur
        TrkLog(( TRKDBG_ERROR, TEXT("GetOverlappedResult failed in CObjIdIndexChangeNotifier::AsyncListen (%lu)"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

}


//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::AsyncListen
//
//  This method begins listening for changes to the NTFS object ID index
//  directory.  It does not block; when notifications are available an
//  event is signaled and handled in DoWork.
//
//+----------------------------------------------------------------------------


BOOL
CObjIdIndexChangeNotifier::AsyncListen( )
{
    TCHAR tszDirPath[MAX_PATH];
    BOOL fStartedListening = FALSE;

    _cs.Enter();
    __try   // __finally
    {
        if( INVALID_HANDLE_VALUE != _hDir )
        {
            TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("CObjIdIndexChangeNotifier already listening to %s:"),
                     _ptszVolumeDeviceName ));
            __leave;
        }

        _tcscpy( tszDirPath, _ptszVolumeDeviceName );
        _tcscat( tszDirPath, TEXT("\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION") );

        //
        // Should use TrkCreateFile and NtNotifyChangeDirectoryFile
        // but NtNotifyChangeDirectoryFile means writing an APC routine
        // so I'm punting for now.
        // None of these Win32 error codess need to be raised to the user.
        //

        _hDir = CreateFile (
              tszDirPath,
              FILE_LIST_DIRECTORY,
              FILE_SHARE_WRITE|FILE_SHARE_READ|FILE_SHARE_DELETE,
              NULL,                        
              OPEN_EXISTING,               
              FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
              NULL );

        if (_hDir == INVALID_HANDLE_VALUE)
        {
            TrkLog((TRKDBG_OBJID_DELETIONS,
                TEXT("AsyncListen failed to open objid index %s %d"),
                tszDirPath,
                GetLastError()));

            TrkRaiseLastError();
        }

        StartListening();    // Call ReadDirectoryChangesW
        fStartedListening = TRUE;

        TrkLog((TRKDBG_OBJID_DELETIONS,
            TEXT("AsyncListen succeeded ReadDirectoryChanges on %c:"), VolChar(_pVolume->GetIndex()) ));


    }
    __finally
    {
        _cs.Leave();
    }

    return fStartedListening;

}



//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::StopListeningAndClose
//
//  Cancel the previous call to ReadDirectoryChangesW, and close the
//  handle to the object ID index directory.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::StopListeningAndClose()
{
    if( !_fInitialized )
        return;

    _cs.Enter();
    TrkLog((TRKDBG_OBJID_DELETIONS, TEXT("StopListeningAndClose() on %c:"),
            VolChar(_pVolume->GetIndex())));

    if (_hDir != INVALID_HANDLE_VALUE)
    {

        // Cancel the IO, which will trigger once last completion with
        // STATUS_NOTIFY_CLEANUP (why isn't it STATUS_CANCELLED?)
        // Note that this one last completion won't be able to execute
        // until we leave the critical section.  When it does execute,
        // it will see that _hDir has been closed, and won't attempt
        // to re-use it.

        CancelIo(_hDir);

        CloseHandle(_hDir);
        _hDir = INVALID_HANDLE_VALUE;
    }
    _cs.Leave();
}


//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::UnInitialize
//
//  Cancel the notification IRP and close the handle to the
//  object ID index directory.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::UnInitialize()
{
    if( _fInitialized )
    {
        StopListeningAndClose();

        // Unregister from the thread pool.  This must be done before closing
        // _hCompletionEvent, because that's the event on which the thread
        // pool is waiting.

        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CObjIdIndexChangeNotifier (%lu)"),
                         GetLastError() ));
            }
            else
                TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered wait for CObjIdIndexChangeNotifier (%p)"),
                         _hRegisterWaitForSingleObjectEx ));

            _hRegisterWaitForSingleObjectEx = NULL;
        }

        if( NULL != _hCompletionEvent )
        {
            CloseHandle( _hCompletionEvent );
            _hCompletionEvent = NULL;
        }

        // Delete the critical section.  This must be done after unregistering from
        // the thread pool, because until that time we have to worry about a thread
        // coming in to DoWork.

        _cs.UnInitialize();
        _fInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\trkwks_sp.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <windows.h>
#include <rpc.h>
#include <rpcasync.h>
#include "trkwks_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\stubs.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       stubs.cxx
//
//  Contents:   RPC stub routines that call CTrkWksSvc
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"

#define THIS_FILE_NUMBER    STUBS_CXX_FILE_NO


//+----------------------------------------------------------------------------
//
//  StubLnkCallSvrMessage
//
//  Calls CTrkWksSvc::CallSvrMessage.
//
//+----------------------------------------------------------------------------

HRESULT StubLnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [switch_is][out][in] */ TRKSVR_MESSAGE_UNION __RPC_FAR *pMsg)
{
    HRESULT hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        hr = g_ptrkwks->CallSvrMessage( IDL_handle, pMsg );
    }
    __except (BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  Stubold_LnkCallSvrMessage
//
//  Backward compatibility, calls StubLnkCallSvrMessage with new msg
//  structure.
//
//+----------------------------------------------------------------------------

HRESULT Stubold_LnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD __RPC_FAR *pMsg)
{
    TRKSVR_MESSAGE_UNION Msg2;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    Msg2.MessageType = pMsg->MessageType;
    Msg2.Priority = PRI_5;

    switch (Msg2.MessageType)
    {
        case (SEARCH):
            Msg2.Search = pMsg->Search;
            break;
        case (MOVE_NOTIFICATION):
            Msg2.MoveNotification = pMsg->MoveNotification;
            break;
        case (REFRESH):
            Msg2.Refresh = pMsg->Refresh;
            break;
        case (SYNC_VOLUMES):
            Msg2.SyncVolumes = pMsg->SyncVolumes;
            break;
        case (DELETE_NOTIFY):
            Msg2.Delete = pMsg->Delete;
            break;
    }

    Msg2.ptszMachineID = pMsg->ptszMachineID;

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return StubLnkCallSvrMessage( IDL_handle, &Msg2 );
}


//+----------------------------------------------------------------------------
//
//  StubLnkMendLink
//
//  Calls CTrkWksSvc::MendLink.  This stub is caled from within the local machine.
//
//+----------------------------------------------------------------------------

/*
// Version 1.2 (added pdroidBirthCurrent)
HRESULT
StubLnkMendLink(RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirthLast,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId           *pmcidLast,
                CDomainRelativeObjId       *pdroidBirthCurrent,
                CDomainRelativeObjId       *pdroidCurrent,
                CMachineId                 *pmcidCurrent,
                ULONG                      *pcbPath,
                WCHAR                      *pwsz )
{
    HRESULT hr = g_ptrkwks->MendLink( IDL_handle, static_cast<CFILETIME>(ftLimit), RestrictionsIn,
                                      *pdroidBirthLast,   *pdroidLast,   *pmcidLast,
                                      pdroidBirthCurrent, pdroidCurrent, pmcidCurrent,
                                      pcbPath, pwsz );

    TrkAssert( TRK_E_POTENTIAL_FILE_FOUND != hr
               ||
               *pdroidBirthLast != *pdroidBirthCurrent );

    TrkAssert( FAILED(hr) || *pdroidBirthLast == *pdroidBirthCurrent
               || *pdroidBirthLast == CDomainRelativeObjId() );

    return( MapTR2HR(hr) );

}
*/

// Version 1.1 (added pmcidLast and pmcidCurrent)
void
StubLnkMendLink(PRPC_ASYNC_STATE            pAsync_handle,
                RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirth,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId *          pmcidLast,
                CDomainRelativeObjId *      pdroidCurrent,
                CMachineId *                pmcidCurrent,
                ULONG *                     pcbPath,
                WCHAR *                     wsz)
{
#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    CDomainRelativeObjId droidBirthCurrent;
    HRESULT hr = S_OK;
    SThreadFromPoolState state;

    __try
    {
        state = InitializeThreadFromPool();

        // Convert the time limit into a tick-count limit, so that we're reslient
        // to clock updates.  Perf: Since this is always a intra-machine call,
        // the interface really ought to be changed so that it just passes
        // in a tick count, but it's not worth changing the interface just
        // for that.

        CFILETIME cftNow, cftLimit(ftLimit);
        DWORD dwTickCountDeadline = GetTickCount();

        if( cftLimit > cftNow )
            dwTickCountDeadline += (DWORD) ( (cftLimit - cftNow)/10000 );


        hr = g_ptrkwks->MendLink( IDL_handle, dwTickCountDeadline, RestrictionsIn,
                                  *pdroidBirth,   *pdroidLast,   *pmcidLast,
                                  &droidBirthCurrent, pdroidCurrent, pmcidCurrent,
                                  pcbPath, wsz );

        TrkAssert( FAILED(hr)
                   ||
                   *pdroidBirth == droidBirthCurrent );


#if DBG
        InterlockedDecrement( &g_cTrkWksRpcThreads );
        TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

    hr = MapTR2HR(hr);

    // If this request came in on Async RPC, complete the call and
    // pass back the return code.

    if( NULL != pAsync_handle )
    {
        HRESULT hrT = RpcAsyncCompleteCall( pAsync_handle, &hr );
#if DBG
        if( ERROR_SUCCESS != hrT )
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcAsyncCompleteCall (%lu)"), hrT ));
#endif
    }

}

// Version 1.0
HRESULT Stubold_LnkMendLink(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidCurrent,
    /* [string][out] */ WCHAR __RPC_FAR wsz[ MAX_PATH + 1 ] )
{
    TrkLog(( TRKDBG_ERROR, TEXT("Stubold_LnkMendLink was called") ));
    return( E_FAIL );
}


//+----------------------------------------------------------------------------
//
//  StubLnkSearchMachine
//
//  Calls CTrkWksSvc::SearchMachine.  This is called from the trkwks service
//  on another machine, or directly (i.e. not by RPC) from within this
//  service.
//
//+----------------------------------------------------------------------------

// Version 1.2 (added pdroidBirthLast, pdroidBirthNext)
// S_OK || TRK_E_REFERRAL || TRK_E_NOT_FOUND || TRK_E_POTENTIAL_FILE_FOUND
HRESULT StubLnkSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                             ULONG                       RestrictionsIn,
                             const CDomainRelativeObjId *pdroidBirthLast,
                             const CDomainRelativeObjId *pdroidLast,
                             CDomainRelativeObjId       *pdroidBirthNext,
                             CDomainRelativeObjId       *pdroidNext,
                             CMachineId                 *pmcidNext,
                             TCHAR                      *ptsz )
{
    HRESULT hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        hr = g_ptrkwks->SearchMachine(
                IDL_handle,
                RestrictionsIn,
                *pdroidBirthLast, *pdroidLast,
                pdroidBirthNext, pdroidNext, pmcidNext, ptsz
                );

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );
}


// Version 1.1 (added pmcidNext)
HRESULT Stubold2_LnkSearchMachine(  RPC_BINDING_HANDLE           IDL_handle,
                                    ULONG                        RestrictionsIn,
                                    const CDomainRelativeObjId  *pdroidLast,
                                    CDomainRelativeObjId        *pdroidNext,
                                    CMachineId                  *pmcidNext,
                                    TCHAR                       *tsz )
{
    CDomainRelativeObjId droidBirthLast, droidBirthNext;

    return( StubLnkSearchMachine( IDL_handle, RestrictionsIn,
                                  &droidBirthLast, pdroidLast,
                                  &droidBirthNext, pdroidNext, pmcidNext,
                                  tsz ));
}

// Version 1.0
HRESULT Stubold_LnkSearchMachine(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidReferral,
    /* [string][out] */ TCHAR __RPC_FAR tsz[ MAX_PATH + 1 ])
{
    CMachineId mcidNext;

    return Stubold2_LnkSearchMachine( IDL_handle, Restrictions, pdroidLast, pdroidReferral, &mcidNext, tsz );
}






HRESULT
StubLnkGetBackup(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ DWORD __RPC_FAR *pcVolumes,
    /* [size_is][size_is][out] */ VolumeMapEntry __RPC_FAR *__RPC_FAR *ppVolumeChanges,
    /* [out] */ FILETIME __RPC_FAR *pft)
{

    return(E_NOTIMPL);
}


HRESULT
StubGetFileTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                /*[in]*/ CDomainRelativeObjId droidCurrent,
                                /*[in]*/ TrkInfoScope scope,
                                /*[out]*/ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    HRESULT hr = E_FAIL;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        TCHAR tszUncPath[ MAX_PATH + 1 ];
        ULONG cbPath = sizeof(tszUncPath);

        state = InitializeThreadFromPool();
        hr = g_ptrkwks->GetFileTrackingInformation( droidCurrent, scope, pipeFileInfo );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );

}   // StubGetFileTrackingInformation()


HRESULT
StubGetVolumeTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                  /*[in]*/ CVolumeId volid,
                                  /*[in]*/ TrkInfoScope scope,
                                  /*[out]*/ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    HRESULT hr = E_FAIL;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        hr = g_ptrkwks->GetVolumeTrackingInformation( volid, scope, pipeVolInfo );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );

}   // StubGetVolumes()

HRESULT StubLnkOnRestore(/*[in]*/ RPC_BINDING_HANDLE IDL_handle)
{
    HRESULT         hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        hr = g_ptrkwks->OnRestore();
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return hr;
}

HRESULT StubLnkRestartDcSynchronization(
    RPC_BINDING_HANDLE IDL_handle
    )
{
    return(E_NOTIMPL);
}

HRESULT StubLnkSetVolumeId(
    handle_t IDL_handle,
    ULONG iVolume,
    const CVolumeId VolId)
{
    HRESULT hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        hr = g_ptrkwks->SetVolumeId( iVolume, VolId );
    }
    __except (BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return(hr);
}


HRESULT
StubTriggerVolumeClaims(          RPC_BINDING_HANDLE IDL_handle,
                         /*[in]*/ ULONG cVolumes,
                         /*[in]*/ const CVolumeId *rgvolid )
{
    HRESULT hr = E_FAIL;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        hr = g_ptrkwks->TriggerVolumeClaims( cVolumes, rgvolid );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );


#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );

}   // StubTriggerVolumeClaims
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\sid.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  sid.cxx
//
//  Implementation of CSID, which is a wrapper class for a SID.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CSID::Initialize
//  
//  Alloc and initialize a SID
//
//+----------------------------------------------------------------------------

VOID
CSID::Initialize( enumCSIDAuthority enumcsidAuthority,
                  BYTE  cSubAuthorities ,
                  DWORD dwSubAuthority0 = 0,
                  DWORD dwSubAuthority1 = 0,
                  DWORD dwSubAuthority2 = 0,
                  DWORD dwSubAuthority3 = 0,
                  DWORD dwSubAuthority4 = 0,
                  DWORD dwSubAuthority5 = 0,
                  DWORD dwSubAuthority6 = 0,
                  DWORD dwSubAuthority7 = 0 )
{
    SID_IDENTIFIER_AUTHORITY rgsid_identifier_authority[] = { SECURITY_NT_AUTHORITY };

    if( NULL != _psid )
    {
        FreeSid( _psid );
        _psid = NULL;
    }


    if( !AllocateAndInitializeSid( &rgsid_identifier_authority[ enumcsidAuthority ],
                               cSubAuthorities,
                               dwSubAuthority0,
                               dwSubAuthority1,
                               dwSubAuthority2,
                               dwSubAuthority3,
                               dwSubAuthority4,
                               dwSubAuthority5,
                               dwSubAuthority6,
                               dwSubAuthority7,
                               &_psid ))
        TrkRaiseLastError();

    _fInitialized = TRUE;

            
}

//+----------------------------------------------------------------------------
//
//  CSID::operator PSID
//
//  Return the SID
//
//+----------------------------------------------------------------------------

CSID::operator PSID()
{
    return( _psid );
}


//+----------------------------------------------------------------------------
//
//  CSID::UnInitialize
//
//  Free the SID.
//
//+----------------------------------------------------------------------------

VOID
CSID::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _psid )
        {
            FreeSid( _psid );
            _psid = NULL;
        }

        _fInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\port.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       port.cxx
//
//  Contents:   Code that receives notifications of moves from
//              kernel.
//
//  Classes:
//
//  Functions:
//
//
//
//  History:
//
//  Notes:
//
//  Codework:   Security on semaphore and port objects
//              _hDllReference when put in services.exe
//              InitializeObjectAttributes( &oa, &name, 0, NULL, NULL /* &sd */ );
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"

#define THIS_FILE_NUMBER    PORT_CXX_FILE_NO

DWORD WINAPI
PortThreadStartRoutine( LPVOID lpThreadParameter );

//+----------------------------------------------------------------------------
//
//  CSystemSD::Initialize
//  CSystemSD::UnInitialize
//
//  Init and uninit the security descriptor that gives access only
//  to System, or to System and Administrators.
//
//+----------------------------------------------------------------------------

void
CSystemSD::Initialize( ESystemSD eSystemSD )
{
    // Add ACEs to the DACL in a Security Descriptor which give the
    // System and Administrators full access.

    _csd.Initialize();

    if( SYSTEM_AND_ADMINISTRATOR == eSystemSD )
    {
        _csidAdministrators.Initialize( CSID::CSID_NT_AUTHORITY,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS );

        _csd.AddAce( CSecDescriptor::ACL_IS_DACL, CSecDescriptor::AT_ACCESS_ALLOWED,
                    FILE_ALL_ACCESS, _csidAdministrators );
    }
    else
        TrkAssert( SYSTEM_ONLY == eSystemSD );

    _csidSystem.Initialize( CSID::CSID_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID );

    _csd.AddAce( CSecDescriptor::ACL_IS_DACL, CSecDescriptor::AT_ACCESS_ALLOWED,
                    FILE_ALL_ACCESS, _csidSystem );
}

void
CSystemSD::UnInitialize()
{
    _csidAdministrators.UnInitialize();
    _csidSystem.UnInitialize();
    _csd.UnInitialize();
}



//+----------------------------------------------------------------------------
//
//  CPort::Initialize
//
//  Create an LPC port to which the kernel will send move notifications,
//  and open an event created by the kernel with which we'll signal
//  our readiness to receive requests.
//
//+----------------------------------------------------------------------------

void
CPort::Initialize( CTrkWksSvc *pTrkWks,
                   DWORD dwThreadKeepAliveTime )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING name;
    CSystemSD ssd;
    DWORD dwThreadId;

    __try
    {
        _hListenPort = NULL;
        _hEvent = NULL;
        _pTrkWks = pTrkWks;
        _hLpcPort = NULL;
        _hRegisterWaitForSingleObjectEx = NULL;
        _fTerminating = FALSE;

        // Create an LPC port to which the kernel will send move-notification requests

        RtlInitUnicodeString( &name, TRKWKS_PORT_NAME );
        ssd.Initialize();
        InitializeObjectAttributes( &oa, &name, 0, NULL, ssd.operator const PSECURITY_DESCRIPTOR() );

        Status = NtCreateWaitablePort(&_hListenPort, &oa,
            sizeof(ULONG),          // IN ULONG MaxConnectionInfoLength
            sizeof(TRKWKS_PORT_REQUEST), // IN ULONG MaxMessageLength
            0);                     // not used : IN ULONG MaxPoolUsage

        if (!NT_SUCCESS(Status))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create LPC connect port") ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, Status, TRKWKS_PORT_NAME );
            TrkRaiseException(Status);
        }

        // Show that we need to do work in the UnInitialize method.
        _fInitializeCalled = TRUE;


        // Open the event which is created by the kernel for synchronization.
        // We tell the kernel that we're available for move-notification requests
        // by setting this event.

        RtlInitUnicodeString( &name, TRKWKS_PORT_EVENT_NAME );

        Status = NtOpenEvent( &_hEvent, EVENT_ALL_ACCESS, &oa );
        if (!NT_SUCCESS(Status))
        {
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, Status, TRKWKS_PORT_EVENT_NAME );
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open %s event"), TRKWKS_PORT_EVENT_NAME ));
            TrkRaiseException(Status);
        }

        // Register our LPC connect port with the thread pool.  When that handle signals,
        // we'll run CPort::DoWork (it signals when we get any message, including
        // LPC_CONNECT_REQUEST).

        if( !RegisterWorkItemWithThreadPool() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CPort::Initialize (%lu)"),
                     GetLastError() ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, Status, TRKREPORT_LAST_PARAM );
            TrkRaiseLastError();
        }

        // When we receive a move notification and we get a thread from the pool,
        // we'll keep that thread until we've gone idle for this amount of time.
        // So if we receive several requests in a short period of time, we won't
        // have to get a thread out of the pool for each.

        _ThreadKeepAliveTime.QuadPart = -static_cast<LONGLONG>(dwThreadKeepAliveTime) * 10000000;

    }
    __finally
    {
        ssd.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CPort::RegisterWorkItemWithThreadPool
//
//  Register the LPC connect port (_hListenPort) with the thread pool.
//
//+----------------------------------------------------------------------------

BOOL
CPort::RegisterWorkItemWithThreadPool()
{
    // This is an execute-only-once work item, so it's inactive now.
    // Delete it, specifying that there should be no completion event
    // (if a completion event were used, this call would hang forever).

    if( NULL != _hRegisterWaitForSingleObjectEx )
        TrkUnregisterWait( _hRegisterWaitForSingleObjectEx, NULL );

    // Now register it again.

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hListenPort, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTEONLYONCE );

    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CPort::DoWork (%lu)"),
                 GetLastError() ));
        return( FALSE );
    }
    else
        TrkLog(( TRKDBG_PORT, TEXT("Registered LPC port work item") ));

    return( TRUE );
}




//+----------------------------------------------------------------------------
//
//  CPort::OnConnectionRequest
//
//  Called when a connection request has been received.  It is either
//  accepted or rejected, depending on the request and the current state
//  of the service.
//
//  When the service is shutting down, CPort::UnInitialize posts a connection
//  request with some connection information.  When that connection request
//  is received, it is rejected, and the pfStopPortThread is set True.
//
//+----------------------------------------------------------------------------

NTSTATUS
CPort::OnConnectionRequest( TRKWKS_PORT_CONNECT_REQUEST *pPortConnectRequest, BOOL *pfStopPortThread )
{
    HANDLE hLpcPortT = NULL;
    HANDLE *phLpcPort = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fAccept = TRUE;

    *pfStopPortThread = FALSE;

    // Determine if we should accept or reject this connection request.

    if( pPortConnectRequest->PortMessage.u1.s1.DataLength
        >=
        sizeof(pPortConnectRequest->Info) )
    {
        // There's extra connection info in this request.  See if it's a request
        // code that indicates that we should close down the port.

        if( TRKWKS_RQ_EXIT_PORT_THREAD == pPortConnectRequest->Info.dwRequest )
        {
            fAccept = FALSE;
            *pfStopPortThread = TRUE;
            TrkLog(( TRKDBG_PORT, TEXT("Received port shutdown connection request") ));
        }
        else
        {
            fAccept = FALSE;
            TrkLog(( TRKDBG_ERROR, TEXT("CPort: unknown Info.dwRequest (%d)"),
                     pPortConnectRequest->Info.dwRequest ));
        }

    }
    else if( _fTerminating )
    {
        // We're shutting down, reject the request
        fAccept = FALSE;
        TrkLog(( TRKDBG_PORT, TEXT("Received connect request during service shutdown") ));
    }


    // Point phLpcPort to the real communications handle, or the dummy one used
    // for rejections.

    if( fAccept )
    {
        phLpcPort = &_hLpcPort;

        // Close out any existing communication port
        if( NULL != _hLpcPort )
        {
            NtClose( _hLpcPort );
            _hLpcPort = NULL;
        }
    }
    else
    {
        phLpcPort = &hLpcPortT;
    }

    // Accept or reject the new connection.
    // In the reject case, this could create a race condition.  After we make the
    // NtAcceptConnectPort call, the CPort::UnInitialize thread might wake up and
    // delete the CPort before this thread runs again.  So, after making this
    // call, we cannot touch anything in 'this'.

    TrkLog(( TRKDBG_PORT, TEXT("%s connect request"),
             fAccept ? TEXT("Accepting") : TEXT("Rejecting") ));

    TRKWKS_PORT_REQUEST *pPortRequest = (TRKWKS_PORT_REQUEST*) pPortConnectRequest;
    pPortRequest->PortMessage.u1.s1.TotalLength = sizeof(*pPortRequest);
    pPortRequest->PortMessage.u1.s1.DataLength = sizeof(pPortRequest->Request); // MaxMessageLength

    Status = NtAcceptConnectPort(
        phLpcPort,              // PortHandle,
        NULL,                   // PortContext OPTIONAL,
        &pPortRequest->PortMessage,
        (BOOLEAN)fAccept,       // AcceptConnection,
        NULL,                   // ServerView OPTIONAL,
        NULL);                  // ClientView OPTIONAL

    if( !NT_SUCCESS(Status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed NtAcceptConnectPort(%s) %08x"),
                 fAccept ? TEXT("accept"):TEXT("reject"),
                 Status ));
        goto Exit;
    }

    // If we rejected it, then phLpcPort was hLpcPortT, and it's just
    // a dummy argument which must be present but isn't set by NtAcceptConnectPort.
    TrkAssert( NULL != *phLpcPort || !fAccept );

    // Wake up the client thread (unblock its call to NtConnectPort)

    if( fAccept  )
    {

        Status = NtCompleteConnectPort( _hLpcPort );
        if( !NT_SUCCESS(Status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed NtCompleteConnectPort %08x"), Status ));
            goto Exit;
        }
    }

Exit:

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  CPort::DoWork
//
//  This method is called by the thread pool when our LPC connect port
//  (_hLpcListenPort) is signaled to indicate that a request is available.
//  If the request is a connection request, we accept or reject it and continue.
//  If the request is a move notification request, we send it to
//  CTrkWksSvc for processing.
//
//  This work item is registerd with the thread pool with the
//  WT_EXECUTEONLYONCE flag, since the connection port isn't
//  auto-reset.  So after processing, we must
//  re-register.  Before doing so, or if re-registration fails,
//  we keep the thread in a NtReplyWaitReceiveEx call for several
//  (configurable) seconds.  This way, if several requests arrive
//  in a short amount of time, we don't have to thrash the thread pool.
//
//  During service termination, _fTerminate is set, and a connection
//  request is made by CPort::UnInitialize.  This request is rejected,
//  and in that case we don't re-register the connect port with the thread
//  pool.
//
//+----------------------------------------------------------------------------

void
CPort::DoWork()
{
    NTSTATUS                Status = STATUS_SUCCESS;
    TRKWKS_PORT_REQUEST     PortRequest;
    TRKWKS_PORT_REPLY       PortReply;

    PortRequest.PortMessage.u1.s1.TotalLength = sizeof(PortRequest.PortMessage);
    PortRequest.PortMessage.u1.s1.DataLength = (CSHORT)0;

    BOOL fReuseThread = FALSE;

    // The fact that we're running indicates that there's a request
    // waiting for us, and the first NtReplyWaitReceivePortEx below will
    // immediately return.  We loop until nothing is received for 30
    // seconds.

    while( TRUE )
    {
        BOOL fTerminating = FALSE;      // TRUE => service is shutting down
        BOOL fStopPortThread = FALSE;   // TRUE => we should shut down this port

        Status = NtReplyWaitReceivePortEx( _hListenPort, //_hLpcPort,
                                           NULL,
                                           NULL,
                                           &PortRequest.PortMessage,
                                           &_ThreadKeepAliveTime
                                         );

        // Cache a local copy of _fTerminating.  In the shutdown case, there's
        // a race condition where the CPort object gets deleted before this routine
        // can finish.  By caching this flag, we don't have to touch this 'this'
        // pointer in that case, and therefore avoid the problem.

        fTerminating = _fTerminating;

        // If we timeed out, then let the thread return to the thread pool.

        if( STATUS_TIMEOUT != Status )
        {
            // We didn't time out.

#if DBG
            if( fReuseThread )
                TrkLog(( TRKDBG_PORT, TEXT("CPort re-using thread") ));
#endif
            fReuseThread = TRUE;

            // Is this a request for a new connection?

            if( NT_SUCCESS(Status)
                &&
                LPC_CONNECTION_REQUEST == PortRequest.PortMessage.u2.s2.Type )
            {
                TrkLog(( TRKDBG_PORT, TEXT("Received LPC connect request") ));

                Status = OnConnectionRequest( (TRKWKS_PORT_CONNECT_REQUEST*) &PortRequest,
                                               &fStopPortThread );
#if DBG
                if( !NT_SUCCESS(Status) )
                    TrkLog(( TRKDBG_ERROR, TEXT("CPort::DoWork couldn't handle connection request %08x"), Status ));
#endif

            }   // if( ... LPC_CONNECTION_REQUEST == PortRequest.PortMessage.u2.s2.Type )

            // Or, is this a good move notification?

            else if( NT_SUCCESS(Status) && NULL != _hLpcPort )
            {

                // Process the move notification in CTrkWksSvc.  If we're in the proces,
                // though, of shutting the service down, then return the same error that
                // the kernel would see if DisableKernelNotifications had been called
                // in time.

                if( _fTerminating )
                    PortReply.Reply.Status = STATUS_OBJECT_NAME_NOT_FOUND;
                else
                    // The following doesn't raise.
                    PortReply.Reply.Status = _pTrkWks->OnPortNotification( &PortRequest.Request );

                // Send the resulting Status back to the kernel.

                PortReply.PortMessage = PortRequest.PortMessage;
                PortReply.PortMessage.u1.s1.TotalLength = sizeof(PortReply);
                PortReply.PortMessage.u1.s1.DataLength = sizeof(PortReply.Reply);

                Status = NtReplyPort( _hLpcPort, &PortReply.PortMessage );
#if DBG
                if( !NT_SUCCESS(Status) )
                    TrkLog(( TRKDBG_ERROR, TEXT("Failed NtReplyPort (%08x)"), Status ));
#endif
            }

            // Otherwise, we either got an error, or a non-connect message on an
            // unconnected port.

            else
            {
                if( NT_SUCCESS(Status) )
                    Status = STATUS_CONNECTION_INVALID;

                TrkLog(( TRKDBG_ERROR, TEXT("CPort::PortThread - NtReplyWaitReceivePortEx failed %0X/%p"),
                         Status, _hLpcPort ));
            }

            // To be robust against some unknown bug causing thrashing, sleep
            // if there was an error.

            if( !NT_SUCCESS(Status) && !fTerminating && !fStopPortThread )
                Sleep( 1000 );

            // Unless the service is shutting down, we don't want to fall
            // through and re-register yet.  We should go back to the
            // NtReplyWaitReceivePortEx to see if there are more requests
            // or will be soon.

            if( !fStopPortThread )
                continue;


        }   // if( STATUS_TIMEOUT != Status )

        // Re-register the connect port with the thread pool, unless we're supposed
        // to stop the port thread.

        if( fStopPortThread )
        {
            TrkLog(( TRKDBG_PORT, TEXT("Stopping port work item") ));
        }
        else
        {
            // If we can't re-register for some reason, just continue back to the top
            // and sit in the NtReplyWaitReceiveEx for a while.

            if( !RegisterWorkItemWithThreadPool() )
            {
                TrkLog(( TRKDBG_PORT, TEXT("Re-using port thread due to registration error (%lu)"), GetLastError() ));
                continue;
            }
            else
                TrkLog(( TRKDBG_PORT, TEXT("Returning port thread to pool") ));
        }

        // We're either terminating or we've successfully re-registered.  In either case, we can let
        // the thread go back to the pool.

        break;

    }   // while( TRUE )

}



//+----------------------------------------------------------------------------
//
//  CPort::UnInitialize
//
//  Remove the LPC connect port work item from the thread pool, and
//  clean everything up.
//
//  To remove the work item, we can't safely call UnregisterWait, because
//  we register with WT_EXECUTEONLYONCE.  Thus when we call UnregisterWait,
//  the wait may have already been deleted.  So, instead, we attempt a connection
//  to the LPC connect port, after first setting _fTerminating.  This will be
//  picked up on a thread pool thread in DoWork, the connection will be
//  rejected, and the work item will not be re-registered.
//
//+----------------------------------------------------------------------------

void
CPort::UnInitialize()
{
    if (_fInitializeCalled)
    {
        NTSTATUS status = STATUS_SUCCESS;
        UNICODE_STRING usPortName;
        OBJECT_ATTRIBUTES oa;
        HANDLE hPort = NULL;
        ULONG cbMaxMessage = 0;
        TRKWKS_CONNECTION_INFO ConnectionInformation = { TRKWKS_RQ_EXIT_PORT_THREAD };
        ULONG cbConnectionInformation = sizeof(ConnectionInformation);

        _fTerminating = TRUE;

        // Attempt to connect to _hLpcListenPort

        RtlInitUnicodeString( &usPortName, TRKWKS_PORT_NAME );

        SECURITY_QUALITY_OF_SERVICE dynamicQos;
        dynamicQos.ImpersonationLevel = SecurityImpersonation;
        dynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        dynamicQos.EffectiveOnly = TRUE;

        TrkLog(( TRKDBG_PORT, TEXT("CPort::UnInitialize doing an NtConnectPort to %s"), TRKWKS_PORT_NAME ));
        status = NtConnectPort( &hPort, &usPortName, &dynamicQos, NULL, NULL,
                                &cbMaxMessage, &ConnectionInformation, &cbConnectionInformation );
        TrkLog(( TRKDBG_PORT, TEXT("CPort::UnInitialize, NtConnectPort completed (0x%08x)"), status ));

        if( NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_PORT, TEXT("CPort::UnInitialize NtConnectPort unexpectedly succeeded"), status ));
            if( NULL != hPort )
                NtClose( hPort );
        }
#if DBG
        else
        {
            TrkAssert( NULL == hPort );
            if( STATUS_PORT_CONNECTION_REFUSED != status )
                TrkLog(( TRKDBG_ERROR, TEXT("CPort::UnInitialize NtConnectPort failed (%08x)"), status ));
        }
#endif

        // DoWork has been called and is done.  Unregister the work item, waiting for the thread
        // to complete.

        if( NULL != _hRegisterWaitForSingleObjectEx )
            TrkUnregisterWait( _hRegisterWaitForSingleObjectEx );
        _hRegisterWaitForSingleObjectEx = NULL;

        // Clean up the port.

        if (_hLpcPort != NULL)
            TrkVerify( NT_SUCCESS( NtClose(_hLpcPort) ) );
        _hLpcPort = NULL;

        if (_hListenPort != NULL)
            TrkVerify( NT_SUCCESS( NtClose(_hListenPort) ) );
        _hListenPort = NULL;

        if( NULL != _hEvent )
            NtClose( _hEvent );
        _hEvent = NULL;


        _fInitializeCalled = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CPort::EnableKernelNotifications
//  CPort::DisableKernelNotifications
//
//  Set/clear the event which tells nt!IopConnectLinkTrackingPort that we're
//  up and ready to receive a connection.
//
//+----------------------------------------------------------------------------

void
CPort::EnableKernelNotifications()
{
    NTSTATUS Status;

    Status = NtSetEvent( _hEvent, NULL );

    TrkVerify( NT_SUCCESS( Status ) );
}

void
CPort::DisableKernelNotifications()
{
    if (_fInitializeCalled)
    {
        NTSTATUS Status;

        Status = NtClearEvent( _hEvent );

        TrkVerify( NT_SUCCESS( Status ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\volmap.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

// Not currently implemented


#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


#ifdef VOL_REPL
void
CPersistentVolumeMap::Initialize()
{
    InitializeCriticalSection(&_cs);
    _fInitializeCalled = TRUE;
}

void
CPersistentVolumeMap::UnInitialize()
{
    if (IsOpen())
        CloseFile();
    CVolumeMap::UnInitialize();
    if (_fInitializeCalled)
    {
        DeleteCriticalSection(&_cs);
        _fInitializeCalled = FALSE;
    }
}

CFILETIME
CPersistentVolumeMap::GetLastUpdateTime( )
{
    CFILETIME cft(0);

    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );
        }

        cft = _cft;
    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }

    return(cft);
}

void
CPersistentVolumeMap::CopyTo(DWORD * pcVolumes, VolumeMapEntry ** ppVolumeChanges)
{
    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );    // BUGBUG: we may want to close this file after a period and free the map
        }

        CVolumeMap VolMap;

        CVolumeMap::CopyTo( &VolMap );
        VolMap.MoveTo( pcVolumes, ppVolumeChanges );

    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }

}

BOOL
CPersistentVolumeMap::FindVolume( const CVolumeId & volume, CMachineId * pmcid )
{
    ULONG i;

    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );    // BUGBUG: we may want to close this file after a period
        }

        for (i=0; i < _cVolumeMapEntries; i++)
        {
            if (_pVolumeMapEntries[i].volume == volume)
            {
                *pmcid = _pVolumeMapEntries[i].machine;
                break;
            }
        }

    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }

    return( i != _cVolumeMapEntries );
}

void
CPersistentVolumeMap::Merge( CVolumeMap * pOther )
{
    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );
        }

        _fMergeDirtiedMap |= CVolumeMap::Merge( pOther );
    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }
}

void
CPersistentVolumeMap::SetLastUpdateTime( const CFILETIME & cft )
{
    _cft = cft;
    Save();
}

// format:
//  DWORD Version
//  DWORD cVolumeMapEntries
//  CFILETIME time of last query on DC
//  VolumeMapEntry[cVolumeMapEntries]
//  CFILETIME time of last query on DC

void
CPersistentVolumeMap::Load()
{
    TCHAR tsz[MAX_PATH+1];
    DWORD cch = ExpandEnvironmentStrings( TEXT("%systemroot%\\system32\\volumes.trk"),
                    tsz,
                    ELEMENTS(tsz) );

    if (cch >= ELEMENTS(tsz))
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Load path too long")));
        TrkRaiseException(TRK_E_PATH_TOO_LONG);
    }

    TrkAssert(!IsOpen());

    RobustlyCreateFile(tsz);

    // after RobustlyCreateFile has succeeded without an exception we know that
    // OpenExistingFile has just returned OK (even after recreating the file.)

    TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
        TEXT("CPersistentVolumeMap::Load() - _cftFirstChange = %s"),
        CDebugString(_cft)._tsz));
}

void
CPersistentVolumeMap::Save()
{
    TrkAssert(IsOpen());

    DWORD Version = PVM_VERSION;
    DWORD cbWritten;

    if (0 != SetFilePointer(0, NULL, FILE_BEGIN) ||
        !WriteFile(&Version, sizeof(Version), &cbWritten) ||
        cbWritten != sizeof(Version) ||
        !WriteFile(&_cVolumeMapEntries, sizeof(_cVolumeMapEntries), &cbWritten) ||
        cbWritten != sizeof(_cVolumeMapEntries) ||

        // the following part of the header is read in Load()
        !WriteFile(&_cft, sizeof(_cft), &cbWritten) ||
        cbWritten != sizeof(_cft))
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed")));
        TrkRaiseLastError();
    }

    if (_fMergeDirtiedMap)
    {
        TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
            TEXT("CPersistentVolumeMap::Save() - writing map data, _cftFirstChange = %s"),
            CDebugString(_cft)._tsz));
        if (!WriteFile(_pVolumeMapEntries, _cVolumeMapEntries * sizeof(VolumeMapEntry), &cbWritten) ||
             cbWritten != _cVolumeMapEntries * sizeof(VolumeMapEntry))
        {
            TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed 2")));
            TrkRaiseLastError();
        }
    }
    else
    {
        TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
            TEXT("CPersistentVolumeMap::Save() - seeking past map data, _cftFirstChange = %s"),
            CDebugString(_cft)._tsz));

        if (!SetFilePointer(_cVolumeMapEntries * sizeof(VolumeMapEntry), NULL, FILE_CURRENT))
        {
            TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed 3")));
            TrkRaiseLastError();
        }
    }

    if (!WriteFile(&_cft, sizeof(_cft), &cbWritten) ||
             cbWritten != sizeof(_cft) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed 4")));
        TrkRaiseLastError();
    }

    _fMergeDirtiedMap = FALSE;
}

// BUGBUG P2: checksum, header alignment


RCF_RESULT
CPersistentVolumeMap::OpenExistingFile( const TCHAR * ptszFile )
{
    RCF_RESULT r;

    DWORD cVolumeMapEntries;
    DWORD Version;
    NTSTATUS status;

    status = OpenExistingSecureFile(ptszFile);
    if ( NT_SUCCESS(status) )
    {
        TrkAssert(IsOpen());
        DWORD cbRead;

        r = CORRUPT;

        if (ReadFile(&Version, sizeof(Version), &cbRead) &&
            cbRead == sizeof(Version) &&
            Version == PVM_VERSION &&
            ReadFile(&cVolumeMapEntries, sizeof(cVolumeMapEntries), &cbRead) &&
            cbRead == sizeof(cVolumeMapEntries) &&
            cVolumeMapEntries < 100000 &&
            GetFileSize() == sizeof(Version) +
                             sizeof(cVolumeMapEntries) +
                             sizeof(CFILETIME) +
                             cVolumeMapEntries * sizeof(VolumeMapEntry) +
                             sizeof(CFILETIME) )
        {
            CFILETIME cft1, cft2;

            SetSize(cVolumeMapEntries);

            if ( ReadFile( &cft1, sizeof(cft1), &cbRead ) &&
                cbRead == sizeof(cft1)  &&
                (_cVolumeMapEntries == 0 ||
                    ( ReadFile(_pVolumeMapEntries, _cVolumeMapEntries * sizeof(VolumeMapEntry), &cbRead) &&
                      cbRead == _cVolumeMapEntries * sizeof(VolumeMapEntry) ) ) &&
                ReadFile( &cft2, sizeof(cft2), &cbRead ) &&
                cbRead == sizeof(cft2) &&
                memcmp(&cft1, &cft2, sizeof(cft1)) == 0)
            {
                _cft = cft1;
                r = OK;
            }
        }

        if (r != OK)
        {
            CloseFile();
        }
    }
    else
    if (status != STATUS_OBJECT_NAME_NOT_FOUND)
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::OpenExistingFile() failed %08x"), status));
        TrkRaiseNtStatus(status);
    }
    else
    {
        r = NOT_FOUND;
    }

    TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
        TEXT("CPersistentVolumeMap::OpenExistingFile() -> %s"),
        (r == NOT_FOUND ? TEXT("NOT_FOUND") : r == OK ? TEXT("OK") : r == CORRUPT ? TEXT("CORRUPT") : TEXT("unknown"))));

    return (r);
}

// BUGBUG P1: CPersistentVolumeMap::UnInitialize

void
CPersistentVolumeMap::CreateAlwaysFile( const TCHAR * ptszFile )
{
    NTSTATUS status = CreateAlwaysSecureFile(ptszFile);

    if( !NT_SUCCESS(status) )
        TrkRaiseNtStatus( status );

    CVolumeMap::SetSize(0);

    _cft = CFILETIME(0);
    Save();

    CloseFile();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\volcache.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  volcache.cxx
//
//  Implementation for CVolumeLocationCache.  This class is used by trkwks
//  to keep a cache of volid->mcid mappings.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::Initialize
//
//  Init the critsec and set the lifetime value.
//
//+----------------------------------------------------------------------------

void
CVolumeLocationCache::Initialize( DWORD dwEntryLifetimeSeconds )
{
    _cs.Initialize();
    _fInitialized = TRUE;
    _cVols = 0;

    _cftEntryLifetime = 0;
    _cftEntryLifetime.IncrementSeconds( dwEntryLifetimeSeconds );
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::UnInitialize
//
//  Free the critsec.
//
//+----------------------------------------------------------------------------

void
CVolumeLocationCache::UnInitialize()
{
    if (_fInitialized)
    {
        _fInitialized = FALSE;
        _cs.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::_FindVolume
//
//  Search the cache for a volid.  If it's found, return it's index in the
//  cache array.
//
//+----------------------------------------------------------------------------

int
CVolumeLocationCache::_FindVolume(const CVolumeId & volid)
{
    for (int i=0; i<_cVols; i++)
    {
        if (_vl[i].volid == volid)
        {
            return(i);
        }
    }

    return(-1);
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::FindVolume
//
//  search the cache for a volid.  If found, return the machine ID it was
//  last known to be on, and a bool indicating if this entry in the cache
//  is old or new.  If it's old and doesn't work, the caller shouldn't
//  trust the cache.  If it's new and doesn't work, the caller shouldn't
//  bother the DC trying to find it.
//
//+----------------------------------------------------------------------------

BOOL
CVolumeLocationCache::FindVolume(const CVolumeId & volid, CMachineId * pmcid, BOOL *pfRecentEntry )
{
    int i;

    _cs.Enter();

    i=_FindVolume(volid );
    if (i != -1)
    {
        // We found the volume.  Load the data.

        CFILETIME cftNow;
        *pmcid=_vl[i].mcid;
        *pfRecentEntry = ( (cftNow - _vl[i].cft) <= _cftEntryLifetime );
    }

    _cs.Leave();
    return(i != -1);
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::AddVolume
//
//  Add a volid->mcid mapping to the cache.  The entry in the cache is
//  timestamped so we know how trustworthy it is.  If the entry is already
//  in the cache, we just update the timestamp.  In either case, this entry
//  will be at the front of the array.
//
//+----------------------------------------------------------------------------

void
CVolumeLocationCache::AddVolume(const CVolumeId & volid, const CMachineId & mcid)
{
    int i;

    if( CVolumeId() == volid )
        return;

    _cs.Enter();

    i = _FindVolume(volid);
    if (i == -1)
    {
        // This volid isn't already in the cache.  Shift back the existing
        // entries so that this entry can be in front.

        BOOL fFull = _cVols >= MAX_CACHED_VOLUME_LOCATIONS;
        memcpy(&_vl[1], &_vl[0], sizeof(VolumeLocation)*(fFull ? _cVols-1 : _cVols));
        if (!fFull)
        {
            _cVols++;
        }

    }
    else
    {
        // Move the prior part of the array back, overwriting
        // the this entry.  That way we can put this entry
        // at the front.

        memcpy(&_vl[1], &_vl[0], sizeof(VolumeLocation)*i);
    }

    // Put this entry at the front of the array.

    _vl[0].volid = volid;
    _vl[0].mcid = mcid;
    _vl[0].cft = CFILETIME();

#if DBG
    for (i=0; i<_cVols; i++)
    {
        TrkLog((TRKDBG_VOLCACHE,
                TEXT("%02d: %s -> %s") MCID_BYTE_FORMAT_STRING,
                i,
                (const TCHAR*)CDebugString(_vl[i].volid),
                (const TCHAR*)CDebugString(_vl[i].mcid),
                ((BYTE*)&(_vl[i].mcid))[0], ((BYTE*)&(_vl[i].mcid))[1], ((BYTE*)&(_vl[i].mcid))[2], ((BYTE*)&(_vl[i].mcid))[3],
                ((BYTE*)&(_vl[i].mcid))[4], ((BYTE*)&(_vl[i].mcid))[5], ((BYTE*)&(_vl[i].mcid))[6], ((BYTE*)&(_vl[i].mcid))[7],
                ((BYTE*)&(_vl[i].mcid))[8], ((BYTE*)&(_vl[i].mcid))[9], ((BYTE*)&(_vl[i].mcid))[10], ((BYTE*)&(_vl[i].mcid))[11],
                ((BYTE*)&(_vl[i].mcid))[12], ((BYTE*)&(_vl[i].mcid))[13], ((BYTE*)&(_vl[i].mcid))[14], ((BYTE*)&(_vl[i].mcid))[15] ));

    }
#endif

    _cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\wkssvc.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  wkssvc.cxx
//
//  Top level class for Tracking (Workstation) Service
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#define INITGUID
#include <guiddef.h>
#include <ioevent.h>
#include <mountmgr.h>   // MOUNTMGR_CHANGE_NOTIFY_INFO, MOUNTDEV_MOUNTED_DEVICE_GUID
#include "trkwks.hxx"
#include <dbt.h>
#include <lmconfig.h>

#define THIS_FILE_NUMBER    WKSSVC_CXX_FILE_NO


#if DBG
DWORD g_Debug = 0;
int CVolume::_cVolumes = 0;
#endif

const extern  TCHAR s_tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

#if TRK_OWN_PROCESS
#pragma message("Building TrkWks for services.exe")
#else
#pragma message("Building TrkWks for separate process")
#endif

//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::Initialize/UnInitialize
//
//  Initialize the tracking service (trkwks).
//
//+----------------------------------------------------------------------------

#if DBG
#include <locale.h>
#endif

void
CTrkWksSvc::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{
    NTSTATUS Status;


    __try
    {
        g_ptrkwks = this;
        _csDomainNameChangeNotify.Initialize();
        _csmcidDC.Initialize();
        _fInitializeCalled = TRUE;
        _MoveQuotaReached.Initialize();

        // Initialize the entropy object, which is used to generate volume secrets.

        _entropy.Initialize();
        _entropy.Put();

        // Get configuration information from HKLM\System\CurrentControlSet\Services\TrkWks\Parameters
        // This can't be initialized until _entropy is.

        _configWks.Initialize();

        /*
        if( _configWks.UseOperationLog() )
            _OperationLog.Initialize( _configWks.GetOperationLog() );
        */

        #if DBG
        {
            CMachineId mcidLocal( MCID_LOCAL );
            TrkLog(( TRKDBG_WKS,
                     TEXT("Distributed Link Tracking service starting on thread=%d(0x%x) for %hs"),
                     GetCurrentThreadId(), GetCurrentThreadId(),
                     (CHAR*)&mcidLocal ));
            TrkLog(( TRKDBG_WKS, TEXT("Locale:  %hs"), setlocale( LC_ALL, NULL ) ));
        }
        #endif

        // This is a hacked stub that looks and acts like the Win32 thread pool services
        #ifdef PRIVATE_THREAD_POOL
        {
            HRESULT hr = S_OK;
            g_pworkman2 = new CThreadPoolStub;
            if( NULL == g_pworkman2 )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create the thread pool manager") ));
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
            }

            hr = g_pworkman2->Initialize();
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't initialize the thread pool manager") ));
                TrkRaiseException( hr );
            }
        }
        #endif

        // Disable popup dialogs during critical errors
        // (i.e., during NtRaiseHardError).

        NtCurrentTeb()->HardErrorsAreDisabled = TRUE;

        // Save the global structure for the services.exe process (though we don't currently
        // use it).
        _pSvcsGlobalData = pSvcsGlobalData;

        // Initialize the object that manages the SCM.
        _svcctrl.Initialize(TEXT("TrkWks"), this);

    #ifdef VOL_REPL
        _persistentVolumeMap.Initialize();
    #endif

        // Initialize our local cache of the VolId->MachineID table (the
        // real table is maintained in the DS)

        _volumeLocCache.Initialize( _configWks.GetParameter( VOLCACHE_TIME_TO_LIVE_CONFIG ));

        _entropy.Put();

        // See if we're in a domain, and initialize timers, etc., accordingly

        CheckForDomainOrWorkgroup();

        // These synchronization objects are used during test to emulate
        // race conditions.

        #if DBG
        if (_configWks.GetTestFlags() & TRK_TEST_FLAG_MOVE_BATCH_SYNC)
            _testsyncMoveBatch.Initialize(TEXT("MoveBatchTimeout"));

        if (_configWks.GetTestFlags() & TRK_TEST_FLAG_TUNNEL_SYNC)
            _testsyncTunnel.Initialize(TEXT("TunnelSync"));
        #endif


        // Build up a linked list of volume structures.

        _volumes.Initialize( static_cast<CTrkWksSvc*>(this), &_configWks, this,
                             _svcctrl._ssh
                             #if DBG
                             ,&_testsyncTunnel
                             #endif
                             );

        /*
        if( !_configWks._fIsWorkgroup )
        {
            _volumes.InitializeDomainObjects();
            _volumes.StartDomainTimers();
        }
        */

        //_mountmanager.Initialize( this, &_volumes );

        // Initialize the LPC port which receives the up-calls from the kernel
        // during a MoveFile notification

        _port.Initialize(this, _configWks.GetPortThreadKeepAliveTime() );

        // Initialize our RPC server, which receives requests to mend from shell shortcuts,
        // and requests to search from other trkwks instances (on other machines).

        _rpc.Initialize( _pSvcsGlobalData, &_configWks );

        // Initialize an object that handles changes to the domain name (i.e., when
        // we move into a new domain).

        _dnchnotify.Initialize();


        // Register with PNP to be notified of events from the volume mount manager
        // (i.e. drives appearing and disappearing).
        /*
        DEV_BROADCAST_DEVICEINTERFACE  DevClass;
        memset( &DevClass, 0, sizeof(DevClass) );
        DevClass.dbcc_size=sizeof(DEV_BROADCAST_DEVICEINTERFACE);
        DevClass.dbcc_devicetype=DBT_DEVTYP_DEVICEINTERFACE;
        memcpy( &DevClass.dbcc_classguid, &MOUNTDEV_MOUNTED_DEVICE_GUID, sizeof(DevClass.dbcc_classguid) );

        _hdnDeviceInterface = RegisterDeviceNotification( reinterpret_cast<HANDLE>(_svcctrl._ssh),
                                                          &DevClass,
                                                          DEVICE_NOTIFY_SERVICE_HANDLE);
        if( NULL == _hdnDeviceInterface )
        {
            // There's nothing we can do, so we'll just ignore the error.
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't register w/PNP for DeviceInterface broadcasts (%08x)"),
                     HRESULT_FROM_WIN32(GetLastError()) ));
        }
        else
            TrkLog(( TRKDBG_WKS, TEXT("Registered for device interface notifications") ));
        */


        // Start the port that receives move notifications from ntos
        _port.EnableKernelNotifications();

        // Let that SCM know that we're running

        _svcctrl.SetServiceStatus(SERVICE_RUNNING,
                                  SERVICE_ACCEPT_STOP |
                                  SERVICE_ACCEPT_SHUTDOWN,    // for log safe closedown
                                  NO_ERROR);
    }
    __except( BreakOnDebuggableException() )
    {
        TrkReportEvent( EVENT_TRK_SERVICE_START_FAILURE, EVENTLOG_ERROR_TYPE,
                        static_cast<const TCHAR*>( CHexStringize( GetExceptionCode() )),
                        NULL );
        TrkRaiseException( GetExceptionCode() );
    }

}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::UnInitialize
//
//  Called during service stop to close everything down and clean up.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::UnInitialize(HRESULT hr)
{
    if (_fInitializeCalled)
    {
        TrkLog(( TRKDBG_WKS, TEXT("Stopping TrkWks Service") ));


        /*
        UnregisterDeviceNotification( _hdnDeviceInterface );
        _hdnDeviceInterface = NULL;
        */

        // Force the volumes to close their handles.  We do this now because
        // some of the following calls could block

        _volumes.FlushAllVolumes( TRUE );   // TRUE => fServiceShutdown
        _volumes.CloseVolumeHandles();

        IFDBG( _testsyncTunnel.UnInitialize(); )
        IFDBG( _testsyncMoveBatch.UnInitialize(); )

        // Cancel any out-going RPCs on threads in this service

        if( NULL != g_pActiveThreadList )
            g_pActiveThreadList->CancelAllRpc();

        // Close down our RPC server and LPC port.  Each will block until
        // all active threads have exited.  Once these two calls have completed,
        // we know that the current thread is the only thread in the service.

        _rpc.UnInitialize( _pSvcsGlobalData );
        _port.UnInitialize();

        //_mountmanager.UnInitialize();
        _dnchnotify.UnInitialize();


        // Stop the timers before stopping the volumes.  That way we don't have
        // a Refresh or MoveNotify going on while the volumes are being deleted.

        _volumes.UnInitializeDomainObjects();

        _volumes.UnInitialize();
        _volumeLocCache.UnInitialize();

#ifdef VOL_REPL
        _persistentVolumeMap.UnInitialize();
#endif

        _entropy.UnInitialize();

        #if PRIVATE_THREAD_POOL
        {
            g_pworkman2->UnInitialize();
            delete g_pworkman2;
            g_pworkman2 = NULL;
        }
        #endif

        _csDomainNameChangeNotify.UnInitialize();
        _fInitializeCalled = FALSE;

        if (_configWks.GetTestFlags() & TRK_TEST_FLAG_WAIT_ON_EXIT)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Waiting 60 seconds before exitting for heap dump")));
            Sleep( 60 * 1000 );
        }


        TrkAssert( 0 == g_cTrkWksRpcThreads );
        g_ptrkwks = NULL;
        _fInitialized = FALSE;

        TrkLog((TRKDBG_WKS, TEXT("CVolume::_cVolumes = %d"), CVolume::_cVolumes ));
        TrkAssert( 0 == CVolume::_cVolumes );

        // This must be the last call.

        if( (hr & 0x0FFF0000) == FACILITY_WIN32 )
            hr = hr & ~(0x0FFF0000);
        _svcctrl.SetServiceStatus(SERVICE_STOPPED, 0, hr);

        //_svcctrl.UnInitialize();
    }
}





//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::CheckForDomainOrWorkgroup
//
//  Determine if this computer is a member of a domain or just a workgroup.
//  Even if we're in a domain, there might be a policy setting in the registry
//  that tells us that we should behave as if we're in a workgroup (i.e. don't
//  talk to the DC for anything).
//
//  The result of this check is stored in _configWks._fIsWorkgroup.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::CheckForDomainOrWorkgroup()
{
    NET_API_STATUS NetStatus;
    WCHAR * pwszDomain = NULL;
    BOOLEAN fIsWorkGroup;
    ULONG   lResult;
    HKEY    hkey = NULL;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   cbValue = sizeof(dwValue);

    __try
    {
        // Check to see if we're in a domain or a workgroup.

        NetStatus = NetpGetDomainNameEx(&pwszDomain, &fIsWorkGroup);

        if (NetStatus != NO_ERROR)
        {
            pwszDomain = NULL;
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(NetStatus),
                                    TRKREPORT_LAST_PARAM );
            TrkRaiseWin32Error(NetStatus);
        }

        TrkLog(( TRKDBG_WKS, TEXT("In %s %s"), fIsWorkGroup ? TEXT("workgroup") : TEXT("domain"), pwszDomain ));

        // If we're in a workgroup, we don't need to check the behave-like-your-in-a-workgroup
        // policy setting.

        if( fIsWorkGroup )
            __leave;

        // Read registry to see if DC tracking is disabled, in which case we'll just
        // act like we're in a workgroup.  This key is set by the policy manager
        // (part of the machine\ntfs policies).

        lResult = RegCreateKey(HKEY_LOCAL_MACHINE,
                               TEXT("System\\CurrentControlSet\\Control\\FileSystem"),
                               &hkey);
        if(ERROR_SUCCESS == lResult)
        {
            lResult = RegQueryValueEx(hkey,
                                      TEXT("NtfsDisableDomainLinkTracking"),
                                      NULL,
                                      &dwType,
                                      (LPBYTE)&dwValue,
                                      &cbValue);
            if(ERROR_SUCCESS == lResult)
            {
                if(REG_DWORD == dwType)
                {
                    fIsWorkGroup = fIsWorkGroup || dwValue;
                    if( dwValue )
                    {
                        TrkLog((TRKDBG_WKS, TEXT("Domain link tracking disabled by policy")));
                    }
                }
            }
        }

    }
    __finally
    {
        if( NULL != hkey )
            RegCloseKey(hkey);

        if( NULL != pwszDomain )
            NetApiBufferFree(pwszDomain);
    }

    _configWks._fIsWorkgroup = fIsWorkGroup;

}





//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnPortNotification
//
//  This method is called when the service receives a message at its
//  LPC port from the kernel.  This message is always a move notification,
//  and its comes here via a CPort object.  The message is handled
//  off to the CVolumeManager object, which finds the correct CVolume
//  object to ultimately handle the notification.
//
//+----------------------------------------------------------------------------

NTSTATUS
CTrkWksSvc::OnPortNotification(const TRKWKS_REQUEST *pRequest)
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    _entropy.Put();

    // Test hook:  return an error on the port notification rather than
    // doing any processing.

    if( 0 != _configWks.GetPortNotifyError() )
    {
        TrkLog(( TRKDBG_PORT, TEXT("Returning explicit error per configuration (0x%x)"),
                 _configWks.GetPortNotifyError() ));
        return( _configWks.GetPortNotifyError() );
    }
    else if( _configWks.GetIgnoreMovesAndDeletes() )
    {
        TrkLog(( TRKDBG_PORT, TEXT("Ignoring move due to configuration") ));
        return( STATUS_SUCCESS );
    }

    __try   // __except
    {
        LARGE_INTEGER liDueTime;

        // Abort if the service is being stopped.
        RaiseIfStopped();

        // Verify that the machine ID has a zero in it.

        for( int i = 0; i < sizeof(pRequest->MoveMessage.MachineId); i++ )
        {
            if( '\0' == ((BYTE*)&pRequest->MoveMessage.MachineId)[i] )
                break;
        }
        if( i == sizeof(pRequest->MoveMessage.MachineId) )
            TrkRaiseWin32Error( ERROR_INVALID_COMPUTERNAME );

        // Append this notification to the end of the appropriate volume log.

        switch (pRequest->dwRequest)
        {
        case TRKWKS_RQ_MOVE_NOTIFY:

            CLogMoveMessage lm( pRequest->MoveMessage );
            CDomainRelativeObjId droidZero;

            // Verify that the IDs are non-zero.

            if( droidZero == lm._droidCurrent||
                droidZero == lm._droidNew ||
                droidZero == lm._droidBirth )
            {
                TrkLog(( TRKDBG_WKS, TEXT("Invalid ID in move notification: %s %s %s"),
                    droidZero == lm._droidCurrent ? TEXT("Current") : TEXT(""),
                    droidZero == lm._droidNew     ? TEXT("New")     : TEXT(""),
                    droidZero == lm._droidBirth   ? TEXT("Birth")   : TEXT("") ));
                TrkRaiseWin32Error( ERROR_INVALID_DATA );
            }


            TrkLog((TRKDBG_PORT | TRKDBG_MOVE,
                TEXT("Port:\n      Current=%s\n      New    =%s:%s\n      Birth  =%s"),
                (const TCHAR*)CDebugString(lm._droidCurrent),
                (const TCHAR*)CDebugString(lm._mcidNew),
                (const TCHAR*)CDebugString(lm._droidNew),
                (const TCHAR*)CDebugString(lm._droidBirth) ));

            g_ptrkwks->_volumes.Append(
                lm._droidCurrent,
                lm._droidNew,
                lm._mcidNew,
                lm._droidBirth
                );

            // Take this opportunity to cache the volid-to-mcid mapping,
            // so we might be able to avoid a DC call later.

            _volumeLocCache.AddVolume( lm._droidNew.GetVolumeId(), lm._mcidNew );

            break;
        }
    }
    __except(BreakOnDebuggableException())
    {
        Status = GetExceptionCode();
    }

    return Status;
}



//+----------------------------------------------------------------------------
//
//  GetSvrMessagePriority
//
//  This method is used to determine the priority of a message that's going
//  to be sent to trksvr (priority 9 is the low, 0 is high).  When trksvr
//  gets too busy, it uses these priorities to determine which requests
//  to reject.
//
//  The priority is based on the length of time the caller's activity is
//  past due; the further it is past due (relative to the frequency of the
//  activity), the higher it's priority.
//
//  For example, a once-per-month activity that's one week past due will
//  get a moderate priority, while a once-per-week activity that's one
//  week past due will get the highest priority.
//
//+----------------------------------------------------------------------------


TRKSVR_MESSAGE_PRIORITY
GetSvrMessagePriority(
    LONGLONG llLastDue,
    LONGLONG llPeriod ) // pass in in seconds
{
    LONGLONG llDiff = CFILETIME() - llLastDue;

    TrkAssert( 0 != llLastDue );

    llPeriod *= 10000000;

    if ( llDiff < 0 )
    {
        return(PRI_9);
    }
    else
    if ( llDiff >= llPeriod )
    {
        return(PRI_0);
    }
    else
    {
        return (TRKSVR_MESSAGE_PRIORITY) ( 9 - (llDiff * 10) / llPeriod );
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetDcName
//
//  Get the appropriate DC computer name for this domain.  If fForce, we'll
//  do a domain-rediscovery, otherwise we'll return the cached value (assuming
//  it exists).  
//
//+----------------------------------------------------------------------------

CMachineId
CTrkWksSvc::GetDcName( BOOL fForce )
{
    CMachineId mcid;
    
    if( _rpc.UseCustomDc() )
        // The registry specifies which DC to use (and that we shouldn't use Kerberos).
        mcid = CMachineId( _rpc.GetCustomDcName() );
    else if( _rpc.UseCustomSecureDc() )
        // The registry specifies which DC to use
        mcid = CMachineId( _rpc.GetCustomSecureDcName() );
    else
        mcid = CMachineId( fForce ? MCID_DOMAIN_REDISCOVERY : MCID_DOMAIN );

    return mcid;
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnRefreshTimeout
//
//  Called when the refresh timer signals.  Upload all volume IDs and
//  birth IDs on this system to the DC, so that it can mark them in
//  its tables as active.  The DC (trksvr) automatically garbage collects
//  objects which are not active for a period of time.
//
//  The first time this routine is called, it does nothing and restarts the
//  timer for a randome amount of time.  That way, if a large number
//  of machines are booted at once, and they all need to send a refresh,
//  they will not all do so at the same time.
//
//+----------------------------------------------------------------------------


PTimerCallback::TimerContinuation
CTrkWksSvc::OnRefreshTimeout( CFILETIME cftOriginalDueTime,
                              ULONG ulPeriodInSeconds )
{
    PTimerCallback::TimerContinuation continuation = PTimerCallback::RETRY_TIMER;

    __try
    {
        TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT, TEXT("CTrkWksSvc::OnRefreshTimeout")));


        // We'ave already hesitated.  Now is the time to upload all the IDs.

        const ULONG      cBatch = 128;
        CVolumeId        *avolid = new CVolumeId[26];
        ULONG            cVolumes;
        CObjId           *aobjid = new CObjId[cBatch];
        CAvailableDc     adc;
        int              cSources=0;

        CDomainRelativeObjId       *adroid = new CDomainRelativeObjId[cBatch];
        CAllVolumesObjIdEnumerator *pAllSources = new CAllVolumesObjIdEnumerator;


        __try
        {
            // Get an array of all the volume IDs.

            cVolumes = _volumes.GetVolumeIds( avolid, 26 );

            if( NULL == avolid || NULL == aobjid || NULL == adroid || NULL == pAllSources )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Out of memory in OnRefreshTimeout") ));
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
            }

            // The AllSources enumerator enums all the files on all the volumes.

            if (pAllSources->FindFirst( &_volumes, &aobjid[cSources], &adroid[cSources] ))
            {
                do  // while ( pAllSources->FindNext( &aobjid[cSources], &adroid[cSources]) );
                {

                    RaiseIfStopped();

                    // If this link source has been in a cross-volume move, then we
                    // need to upload it.  Normalize the value, and increment the count
                    // (so that we'll keep it).

                    if (adroid[cSources].GetVolumeId().GetUserBitState()) // if moved across volumes
                    {
                        adroid[cSources].GetVolumeId().Normalize();
                        cSources ++;
                    }

                    // If we have enough link sources for a batch, send them up now.

                    if (cSources == cBatch)
                    {
                        TRKSVR_MESSAGE_UNION Msg;

                        Msg.MessageType = REFRESH;

                        // Set the priority based on how long we're overdue.

                        Msg.Priority = GetSvrMessagePriority(
                            cftOriginalDueTime,
                            ulPeriodInSeconds );

                        Msg.Refresh.cSources = cSources;
                        Msg.Refresh.adroidBirth = adroid;

                        Msg.Refresh.cVolumes = cVolumes;
                        Msg.Refresh.avolid = cVolumes == 0 ? NULL : avolid;

                        TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
                            TEXT("CTrkWksSvc::OnRefreshTimeout calling DC with %d volumes, ")
                            TEXT("%d sources, %d priority"), cVolumes, cSources, Msg.Priority ));

                        // If the DC is down we'll get an exception.  This will cause the
                        // timer to go into a retry.

                        adc.CallAvailableDc(&Msg);

                        cSources = 0;
                        cVolumes = 0;
                    }
                } while ( pAllSources->FindNext( &aobjid[cSources], &adroid[cSources]) );
            }

            // Upload the final block of link sources (which is smaller than a normal
            // batch size).

            if (cVolumes != 0 || cSources != 0)
            {
                TRKSVR_MESSAGE_UNION Msg;

                Msg.MessageType = REFRESH;

                TrkLog(( TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
                         TEXT("Refresh priority based on %I64i"),
                         static_cast<LONGLONG>( CFILETIME() - cftOriginalDueTime ) ));

                Msg.Priority = GetSvrMessagePriority(
                    cftOriginalDueTime,
                    ulPeriodInSeconds );

                Msg.Refresh.cSources = cSources;
                Msg.Refresh.adroidBirth = cSources == 0 ? NULL : adroid;

                Msg.Refresh.cVolumes = cVolumes;
                Msg.Refresh.avolid = cVolumes == 0 ? NULL : avolid;

                TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
                    TEXT("CTrkWksSvc::OnRefreshTimeout calling DC with %d volumes, ")
                    TEXT("%d sources, %d priority"), cVolumes, cSources, Msg.Priority ));

                adc.CallAvailableDc(&Msg);
            }
        }
        __finally
        {
            pAllSources->UnInitialize();

            adc.UnInitialize();

            if( NULL != avolid )
                delete[] avolid;
            if( NULL != aobjid )
                delete[] aobjid;
            if( NULL != adroid )
                delete[] adroid;
            if( NULL != pAllSources )
                delete pAllSources;
        }

        // Put the timer back into it's original mode, so that it will go
        // off in the next period (one month?).

        continuation = PTimerCallback::CONTINUE_TIMER;

        TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
            TEXT("CTrkWksSvc::OnRefreshTimeout successfully refreshed DC")));

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING,
                 TEXT("Ignoring exception in CVolumeManager::OnRefreshTimeout (%08x)"),
                 GetExceptionCode() ));
    }


    return( continuation );
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnEntriesAvailable
//
//  Pass this on to the volume manager.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::OnEntriesAvailable()
{
    _volumes.OnEntriesAvailable();
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnMoveBatchTimeout
//
//  Called by the _timerNotify when it expires so that we can send all
//  move notifications to the DC that haven't been sent.
//
//+----------------------------------------------------------------------------

#define MOVE_BATCH_SIZE 64

PTimerCallback::TimerContinuation
CTrkWksSvc::OnMoveBatchTimeout( EAggressiveness eAggressiveness )
{
    HRESULT hr;
    BOOL fSuccess = FALSE;
    SequenceNumber seqLog;
    CAvailableDc     adc;
    CVolume * pVol = NULL;
    ULONG cSendsToServer = 0;
    PTimerCallback::TimerContinuation continuation = PTimerCallback::BREAK_TIMER;

    TrkLog((TRKDBG_MOVE | TRKDBG_WKS, TEXT("CTrkWksSvc::OnMoveBatchTimeout")));

    IFDBG( _testsyncMoveBatch.ReleaseAndWait(); )

    // If we found ourselves to be above quota recently, and we're not
    // being aggressive, then do nothing.

    if( PASSIVE == eAggressiveness && _MoveQuotaReached.IsSet() )
    {
        TrkLog(( TRKDBG_LOG, TEXT("Skipping OnMoveBatchTimeout, move quota was exceeded before") ));
        return( PTimerCallback::BREAK_TIMER );
    }

    // Ensure that we're the only thread trying to do a MoveNotify.
    // If we're not, then simple abort this call; we'll assume
    // that the other thread will take care of things.

    if( !BeginSingleInstanceTask( &_cOnMoveBatchTimeout ))
    {
        TrkLog(( TRKDBG_LOG, TEXT("Skipping OnMoveBatchTimeout") ));
        return( PTimerCallback::BREAK_TIMER );
    }

    //
    // The move batch timeout has expired. We are in a different thread to
    // that which may be concurrently writing the log and starting another
    // move batch time period.
    // We then get the current range of log entries that need to be sent to
    // the DC. The range may be empty because we may have read everything out
    // of the log during a thread switch at NoteXXXX in OnPortNotification.
    //

    __try
    {

        CVolumeEnumerator VolumeEnum;
        ULONG cPerVolumePasses = 0;

        // Iterate through an enumeration of the volumes.

        VolumeEnum = _volumes.Enum();
        while (pVol = VolumeEnum.GetNextVolume())
        {

            CObjId rgobjidCurrent[MOVE_BATCH_SIZE];
            CDomainRelativeObjId rgdroidBirth[MOVE_BATCH_SIZE];
            CDomainRelativeObjId rgdroidNew[MOVE_BATCH_SIZE];

            // Don't do anything if the volumes isn't owned.

            if( CVolume::VOL_STATE_OWNED != pVol->GetState() )
            {
                TrkLog(( TRKDBG_WKS, TEXT("Skipping MoveNotify on volume %c:; it is not in the owned state"),
                    VolChar(pVol->GetVolIndex()) ));

                // Skip to the next volume.

                pVol->Release();
                continue;
            }

            ULONG   cNotifications = sizeof(rgobjidCurrent)/sizeof(rgobjidCurrent[0]);
            BOOL fForceSeqNumber = FALSE;

            __try   // __except
            {
                // Read a batch of move notifications from this volume's log.

                pVol->Read(rgobjidCurrent, rgdroidBirth, rgdroidNew, &seqLog, &cNotifications);

                // Process entries from the log
#if DBG
                if( 0 == cNotifications )
                    TrkLog(( TRKDBG_LOG, TEXT("Nothing to send for %c:"), VolChar(pVol->GetVolIndex()) ));
#endif

                while( cNotifications )
                {
                    // Pass the entries up to the server.

                    // Abort if the service is stopping
                    RaiseIfStopped();

                    // Also abort if we're putting too much strain on the server

                    if( ++cSendsToServer > _configWks.GetMaxSendsPerMoveNotify() )
                    {
                        TrkLog(( TRKDBG_LOG, TEXT("Too many moves are going to the server, aborting for now") ));
                        TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
                    }

                    TRKSVR_MESSAGE_UNION Msg;
                    CVolumeId volid = pVol->GetVolumeId();

                    Msg.MessageType = MOVE_NOTIFICATION;
                    Msg.Priority = PRI_0;

                    Msg.MoveNotification.cNotifications = cNotifications;
                    Msg.MoveNotification.seq = seqLog;
                    Msg.MoveNotification.fForceSeqNumber = fForceSeqNumber;
                    Msg.MoveNotification.pvolid = &volid;
                    Msg.MoveNotification.rgobjidCurrent = rgobjidCurrent;
                    Msg.MoveNotification.rgdroidBirth = rgdroidBirth;
                    Msg.MoveNotification.rgdroidNew = rgdroidNew;
                    Msg.MoveNotification.cProcessed = 0;

                    TrkLog(( TRKDBG_MOVE | TRKDBG_WKS, TEXT("Sending %d move %s for %c: (seq=%d)."),
                             cNotifications,
                             cNotifications > 1 ? TEXT("notifications") : TEXT("notification"),
                             VolChar(pVol->GetVolIndex()), seqLog ));

                    hr = adc.CallAvailableDc(&Msg);
                    TrkAssert( SUCCEEDED(hr) );

                    // If the upload was successful (even if not complete),
                    // advance the read pointer in the log.

                    if( S_OK == hr )
                    {
                        TrkLog(( TRKDBG_MOVE | TRKDBG_WKS, TEXT("MoveNotify succeeded") ));
                        _MoveQuotaReached.Clear();

                        // Advance the read cursor in the log.
                        pVol->Seek(SEEK_CUR, Msg.MoveNotification.cProcessed );

                        if( Msg.MoveNotification.cProcessed != cNotifications )
                        {
                            // The server is being over-loaded, and not everything
                            // was uploaded.  Try again later to upload the rest.

                            hr = TRK_E_SERVER_TOO_BUSY;
                            TrkLog(( TRKDBG_ERROR,
                                     TEXT("OnMoveBatchTimeout server too busy (%d entries processed)"),
                                     Msg.MoveNotification.cProcessed ));
                            __leave;
                        }
                        else
                        {
                            // After a good upload, we don't expect the sequence
                            // numbers to be out of sync.

                            fForceSeqNumber = FALSE;
                        }
                    }

                    // We had an error.  See if it's because we're out
                    // of sync with the server

                    else
                    if ( hr == TRK_S_OUT_OF_SYNC )
                    {

                        TrkAssert( seqLog != Msg.MoveNotification.seq );
                        TrkAssert( !fForceSeqNumber );

                        // Are we ahead or behind the server?

                        if( seqLog < Msg.MoveNotification.seq )
                        {
                            // We're behind the server (probably because we were restored).
                            // Just tell the server to take our sequence number.

                            TrkAssert( !fForceSeqNumber );
                            fForceSeqNumber = TRUE;
                        }
                        else
                        {
                            // We're ahead of the server.  Let's back up our log
                            // so that everything the server needs will get uploaded.
                            // If this sequence number isn't in the log, then just
                            // force the server to take everything we have.

                            if( !pVol->Seek( Msg.MoveNotification.seq ))
                                fForceSeqNumber = TRUE;
                        }
                    }

                    // Or maybe the error is that we don't currently own the volume
                    // from which this file was moved.

                    else
                    if( TRK_S_VOLUME_NOT_FOUND == hr
                        ||
                        TRK_S_VOLUME_NOT_OWNED == hr
                      )
                    {
                        TrkLog(( TRKDBG_LOG, TEXT("Volume %c: found to be not-owned during MoveNotify"),
                                 TEXT('A')+pVol->GetVolIndex() ));
                        pVol->SetState( CVolume::VOL_STATE_NOTOWNED );
                        break; // Move on to the next volume
                    }

                    // Or maybe we hit the move notification quota limit

                    else
                    if( TRK_S_NOTIFICATION_QUOTA_EXCEEDED == hr )
                    {
                        TrkLog(( TRKDBG_MOVE|TRKDBG_WKS, TEXT("Hit move limit after %d entries"),
                                 Msg.MoveNotification.cProcessed ));
                        _MoveQuotaReached.Set();

                        // Advance the read cursor in the log.
                        if( 0 != Msg.MoveNotification.cProcessed )
                            pVol->Seek(SEEK_CUR, Msg.MoveNotification.cProcessed );

                        __leave;
                    }


                    else
                        TrkRaiseException(hr);

                    // Get the next batch of data to be uploaded.

                    Sleep( 5000 );  // Pause a little to be sure we're not overloading.

                    cNotifications = sizeof(rgobjidCurrent)/sizeof(rgobjidCurrent[0]);
                    pVol->Read(rgobjidCurrent, rgdroidBirth, rgdroidNew, &seqLog, &cNotifications);

                }   // while( cNotifications )

                pVol->Flush();

            }   // __try
            __except( IsErrorDueToLockedVolume(GetExceptionCode())
                      ? EXCEPTION_EXECUTE_HANDLER
                      : EXCEPTION_CONTINUE_SEARCH )
            {
                // This volume is locked, so there's nothing we can do other
                // than just carry on to the next volume.
            }

            pVol->Release();
            pVol = NULL;

            // If we're at quota, there's no point in continuing
            if( _MoveQuotaReached.IsSet() )
            {
                TrkLog(( TRKDBG_MOVE|TRKDBG_WKS, TEXT("Stopping move notifications due to quota") ));
                break;
            }

        } // while (pVol = VolumeEnum.GetNextVolume())

    }   // __try
    __except (BreakOnDebuggableException())
    {
        hr = GetExceptionCode();

        // Restart the timer for a retry (with backoff).
        continuation = PTimerCallback::RETRY_TIMER;
        TrkLog((TRKDBG_MOVE | TRKDBG_WKS, TEXT("Retrying move notify (%08x)"), GetExceptionCode() ));
    }

    EndSingleInstanceTask( &_cOnMoveBatchTimeout  );

    if (pVol)
    {
        pVol->Release();
    }


    // If we failed because the server is too busy, don't do a normal continuation

    if( TRK_E_SERVER_TOO_BUSY == hr )
        TrkRaiseException( hr );

    return( continuation );

}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::ServiceHandler
//
//  This method is the service control handler callback function, which is
//  called by the SCM.  We handle service messages (start/stop/shutdown),
//  and PNP messages.
//
//  NOTE:   In services.exe, this method is called on the one and only ServiceHandler
//          thread.  So while we execute, no other service in this process can
//          receive notifications.  Thus it is important that we do nothing
//          blocking or time-consuming here.
//
//+----------------------------------------------------------------------------

DWORD
CTrkWksSvc::ServiceHandler(DWORD dwControl,
                           DWORD dwEventType,
                           PVOID EventData,
                           PVOID pData)
{
    DWORD       dwRet = NO_ERROR;
    NTSTATUS    status;

    switch (dwControl)
    {

    //  ----------------
    //  Service Messages
    //  ----------------

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:

        // Stop receiving move notifications from NTOS
        _port.DisableKernelNotifications();

        /*
        // Run the service cleanup on a worker thread.  Run it
        // as a long function, so that when we do an LPC connect
        // in CPort::UnInitialize, the thread pool will be willing to create
        // a thread for CPort::DoWork to process the connect.

        status = TrkQueueWorkItem( (PWorkItem*)this, WT_EXECUTELONGFUNCTION );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't queue service stop to thread pool") ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                    status,
                                    TRKREPORT_LAST_PARAM );
        }
        */

        ServiceStopCallback( this, FALSE );

        break;

    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;

    //  ------------
    //  PNP messages
    //  ------------

    case SERVICE_CONTROL_DEVICEEVENT:

        switch( dwEventType )
        {
        
        // PNP events identified by GUID:  Volume lock/unlock/lockfail, plus
        // volume mount/dismount.

        case DBT_CUSTOMEVENT:
            {

                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);

                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    TrkAssert(pbh->dbch_hdevnotify);

                    if( pbh->dbch_eventguid == GUID_IO_VOLUME_LOCK )
                    {
                        // Never raises
                        TrkLog(( TRKDBG_WKS, TEXT("Received volume lock notification (%p)"),
                                 pbh->dbch_hdevnotify ));
                        _volumes.OnVolumeLock( pbh->dbch_hdevnotify );
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_UNLOCK )
                    {
                        // Doesn't raise or block
                        TrkLog(( TRKDBG_WKS, TEXT("Received volume unlock notification (%p)"),
                                 pbh->dbch_hdevnotify ));
                        _volumes.OnVolumeUnlock( pbh->dbch_hdevnotify );
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_LOCK_FAILED )
                    {
                        // Doesn't raise or block
                        TrkLog(( TRKDBG_WKS, TEXT("Received volume lock fail notification (%p)"),
                                 pbh->dbch_hdevnotify ));
                        _volumes.OnVolumeLockFailed(pbh->dbch_hdevnotify);
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_DISMOUNT )
                    {
                        TrkLog(( TRKDBG_WKS, TEXT("Volume Dismount") ));
                        _volumes.OnVolumeDismount( pbh->dbch_hdevnotify );
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_MOUNT )
                    {
                        TrkLog(( TRKDBG_WKS, TEXT("Volume Mount") ));
                        _volumes.OnVolumeMount( pbh->dbch_hdevnotify );
                    }
                }

            }
            break;


        case DBT_DEVICEQUERYREMOVE:

            // We treat this like a dismount and close all of our handles.

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEQUERYREMOVE") ));
            {
                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);
                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    _volumes.OnVolumeDismount( pbh->dbch_hdevnotify );
                }
            }
            break;

        case DBT_DEVICEQUERYREMOVEFAILED:

            // We can reopen the handles, because someone else made the 
            // query fail.

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEQUERYREMOVEFAILED") ));
            {
                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);
                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    _volumes.OnVolumeDismountFailed( pbh->dbch_hdevnotify );
                }
            }
            break;

        case DBT_DEVICEREMOVECOMPLETE:

            // The volume was successfully removed.

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEREMOVECOMPLETE") ));
            {
                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);
                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    // The volume handles should have been closed already
                    // in the DBT_DEVICEQUERYREMOVE, in which case the following
                    // call will have no effect.
                    _volumes.OnVolumeDismount( pbh->dbch_hdevnotify );
                }
                else
                {
                    PDEV_BROADCAST_DEVICEINTERFACE pintf
                        = reinterpret_cast<PDEV_BROADCAST_DEVICEINTERFACE>(EventData);

                    if( MOUNTDEV_MOUNTED_DEVICE_GUID == pintf->dbcc_classguid )
                    {
                        TrkLog(( TRKDBG_WKS, TEXT("Received mounted device remove complete") ));
                        TrkLog(( TRKDBG_WKS, TEXT("DeviceType=%08x, Name=%s"), pintf->dbcc_devicetype, pintf->dbcc_name ));
                    }
                }
                break;
            }

        case DBT_DEVICEARRIVAL:

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEARRIVAL") ));
            /*  Need to figure out what device-type to check for
            {
                PDEV_BROADCAST_DEVICEINTERFACE pintf
                    = reinterpret_cast<PDEV_BROADCAST_DEVICEINTERFACE>(EventData);

                if( MOUNTDEV_MOUNTED_DEVICE_GUID == pintf->dbcc_classguid )
                {
                    TrkLog(( TRKDBG_WKS, TEXT("Received mounted device arrival") ));
                    TrkLog(( TRKDBG_WKS, TEXT("DeviceType=%08x, Name=%s"), pintf->dbcc_devicetype, pintf->dbcc_name ));
                }
            }
            */
            break;

        }   // switch( dwEventType )

    }
    return(dwRet);
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::CallDcSyncVolumes
//
//  Send a SYNC_VOLUMES request to the DC.  There are multiple types if
//  SYNC_VOLUMES requests, for example it can be used to create or claim
//  volumes, or to verify sequence numbers for volumes.
//
//  This implementation is part of CTrkWksSvc, even though it is only
//  called from CVolumeManager.  This was done because during the request
//  we also get information that's used to update the _persistentVolumeMap
//  table, which is part of CTrkWksSvc.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::CallDcSyncVolumes(ULONG cVolumes, TRKSVR_SYNC_VOLUME rgSyncVolumes[])
{
    TRKSVR_MESSAGE_UNION Msg;
    CAvailableDc         adc;
    VolumeMapEntry *     pVolumeChanges = NULL;
#ifdef VOL_REPL
    CVolumeMap           VolumeMapNew;
#endif
    __try
    {
        HRESULT hr;

        // Compose the SyncVolumes message buffer

        Msg.MessageType = SYNC_VOLUMES;
        Msg.Priority = PRI_0;
        Msg.SyncVolumes.cVolumes = cVolumes;
        Msg.SyncVolumes.pVolumes = rgSyncVolumes;

#ifdef VOL_REPL
        // pass in the DC time that we last got volume changes
        Msg.SyncVolumes.ftFirstChange = _persistentVolumeMap.GetLastUpdateTime( );
        Msg.SyncVolumes.cChanges = 0;
        Msg.SyncVolumes.ppVolumeChanges = & pVolumeChanges;
#endif
        // Call the DC

        adc.CallAvailableDc(&Msg);

#ifdef VOL_REPL
        // Process volume table updates
        if (Msg.SyncVolumes.cChanges != 0 && pVolumeChanges != NULL)
        {
            // takes ownership of *pVolumeChanges
            VolumeMapNew.Initialize(Msg.SyncVolumes.cChanges, &pVolumeChanges);

            // ftFirstChange is now the time that we pass back into the DC next time
            _persistentVolumeMap.Merge(&VolumeMapNew);
        }
        _persistentVolumeMap.SetLastUpdateTime( CFILETIME(Msg.SyncVolumes.ftFirstChange) );
#endif

    }
    __finally
    {
        adc.UnInitialize();
#ifdef VOL_REPL
        midl_user_free(pVolumeChanges);
        VolumeMapNew.UnInitialize();
#endif
    }
}

// Always returns a success code (positive number), exception if RPC error or service
// returns a negative number.

//+----------------------------------------------------------------------------
//
//  CAvailableDc::CallAvailableDc
//
//  Find a DC and call TrkSvr's LnkSvrMessage method with the caller-provided
//  message.  All communications between the trkwks & trksvr services goes
//  through this method.  This routine raises if LnkSvrMessage returns an
//  error.
//
//+----------------------------------------------------------------------------


HRESULT
CAvailableDc::CallAvailableDc(
    TRKSVR_MESSAGE_UNION * pMsg,
    RC_AUTHENTICATE auth )
{
    HRESULT hr = E_FAIL;
    CMachineId mcidLocal( MCID_LOCAL );
    TCHAR tszMachineID[ MAX_PATH + 1 ];
    CMachineId mcidFirstTry;

    // Set the machine ID in the message.  Ordinarily this is set to NULL;
    // trksvr infers the machine ID by impersonating us.  It's non-NULL
    // if the registry is configured to use a custom DC.

    if( UseCustomDc() )
    {
        mcidLocal.GetName( tszMachineID, sizeof(tszMachineID) );
        pMsg->ptszMachineID = tszMachineID;
    }
    else
        pMsg->ptszMachineID = NULL;

    // Try twice to talk to the DC.  If it fails the first time, we'll try
    // another DC.

    for (int tries=0; tries<2; tries++)
    {

        // If the service is stopping, don't even attempt to make a call that
        // could hang indefinitely.

        g_ptrkwks->RaiseIfStopped();

        // If we don't have an association with the DC, establish it now.

        if (! _rcDomain.IsConnected())
        {

            _mcidDomain = g_ptrkwks->GetDcName( 1 == tries ); // Force on the second try
            TrkLog(( TRKDBG_WKS, TEXT("Connecting to DC %s"),
                     (const TCHAR*)CDebugString(_mcidDomain) ));
            _rcDomain.RcInitialize( _mcidDomain,
                                    s_tszTrkSvrRpcProtocol, s_tszTrkSvrRpcEndPoint,
                                    auth );

            TrkAssert( _rcDomain.IsConnected() );
        }

        // If this is the second try, and we're about to try the same DC as
        // the first time, then don't bother.

        if (tries == 1 && mcidFirstTry == _mcidDomain)
        {
            break;
        }

        // Call the DC
        __try
        {
            if (tries == 0)
            {
                // Remember which DC we try first, so we don't bother to try
                // it a second time.
                mcidFirstTry = _mcidDomain;
            }

            TrkLog(( TRKDBG_WKS, TEXT("Calling LnkSvrMessage on %s"),
                     (const TCHAR*)CDebugString(_mcidDomain) ));

            hr = LnkSvrMessage(_rcDomain, pMsg);
        }
        __except (BreakOnDebuggableException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            TrkLog(( TRKDBG_WKS, TEXT("Couldn't call DC %s (%08x)"),
                     (const TCHAR*)CDebugString(_mcidDomain),
                     HRESULT_FROM_WIN32(GetExceptionCode()) ));
        }


        // If the call succeeded, we're done.

        if (SUCCEEDED(hr))
        {
            break;
        }

        if( NULL != g_ptrkwks )
            g_ptrkwks->RaiseIfStopped();

        _rcDomain.UnInitialize();

    }   // for (int tries=0; tries<2; tries++)

    if (FAILED(hr))
    {
        TrkLog((TRKDBG_WKS, TEXT("CallAvailableDc failed %08X"), hr));
        TrkRaiseException(hr);
    }

    return hr;

}   // CAvailableDc::CallAvailableDc



//+----------------------------------------------------------------------------
//
//  CAvailableDc::UnInitialize
//
//  Uninitialize the RPC association and registry configuration.
//
//+----------------------------------------------------------------------------

void
CAvailableDc::UnInitialize()
{
    _rcDomain.UnInitialize();
    CTrkRpcConfig::UnInitialize();
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::CallSvrMessage
//
//  This method is the implementation within CTrkWksSvc of the
//  LnkCallSvrMessage RPC request.  This purpose of this request is to
//  provide a means for a utility to send a message to trksvr via trkwks,
//  no pre- or post-processing is done by trkwks.  This is only provided
//  for testing purposes, and is disabled unless a flag is set in the
//  registry.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::CallSvrMessage( handle_t IDL_handle, TRKSVR_MESSAGE_UNION * pMsg )
{
    HRESULT hr = S_OK;
    CAvailableDc adc;
    BOOL fAllowCall = FALSE;

    TrkLog(( TRKDBG_MEND, TEXT("CallSvrMessage request") ));

    // Is the special registry flag set that allows us to perform this call?

    if( _configWks.GetTestFlags() & TRK_TEST_FLAG_CALL_SERVER )
    {
        fAllowCall = TRUE;
    }
    else
    {
        // Otherwise, see if the client is running as an administrator.
        // If so, then it's OK to make this call.

        RPC_STATUS rpc_status = RpcImpersonateClient( IDL_handle );
        if( S_OK == rpc_status )
        {
            if( RunningAsAdministratorHack() )
            {
                fAllowCall = TRUE;

                TCHAR tszCurrentUser[ 200 ] = { TEXT("") };
                ULONG cchCurrentUser = sizeof(tszCurrentUser);
                GetUserName( tszCurrentUser, &cchCurrentUser );
                TrkLog(( TRKDBG_MEND, TEXT("CallSvrMessage from %s"), tszCurrentUser ));
            }
            RpcRevertToSelf();
        }
    }

    if( !fAllowCall )
        return( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED) );

    __try
    {
        // Is this a request to modify our configuration?

        if( WKS_CONFIG == pMsg->MessageType )
        {
            // Yes, this is a trkwks configuration change request.  Are we
            // attempt to change a dynamic parameter?

            if( !_configWks.IsParameterDynamic( pMsg->WksConfig.dwParameter ) )
            {
                // No, this parameter is static and can't be changed.

                TrkLog(( TRKDBG_WARNING, TEXT("Attempt to modify a static parameter (%d)"),
                         pMsg->WksConfig.dwParameter ));
                hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            }

            // Otherwise, we can change the parameter.

            else if( !_configWks.SetParameter( pMsg->WksConfig.dwParameter,
                                               pMsg->WksConfig.dwNewValue ) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set parameter %d to %d"),
                         pMsg->WksConfig.dwParameter, pMsg->WksConfig.dwNewValue ));
                hr = E_FAIL;
            }
            else
            {
                hr = S_OK;
                TrkLog(( TRKDBG_WKS, TEXT("Set parameter %s to %d"),
                         _configWks.GetParameterName( pMsg->WksConfig.dwParameter ),
                         pMsg->WksConfig.dwNewValue ));
            }

        }   // if( WKS_CONFIG == pMsg->MessageType )

        // Or, is it a request to refresh the volume list (to look for new volumes)?

        else if( WKS_VOLUME_REFRESH == pMsg->MessageType )
        {
            _volumes.RefreshVolumes( (PLogCallback*) this, _svcctrl._ssh
                                     #if DBG
                                     , &_testsyncTunnel
                                     #endif
                                     );
            hr = S_OK;
        }

        else
        {
            // No, this isn't a request to change trkwks configuration.  Just pass
            // the request up to trksvr unchanged.

            hr = adc.CallAvailableDc(pMsg);
        }
    }
    __finally
    {
        adc.UnInitialize();
    }

    return(hr);

}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetBackup
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#ifdef VOL_REPL
HRESULT
CTrkWksSvc::GetBackup(DWORD *           pcVolumes,
                      VolumeMapEntry ** ppVolumeChanges,
                      FILETIME          *pft)
{
    HRESULT hr = S_OK;

    __try
    {
        _persistentVolumeMap.CopyTo( pcVolumes, ppVolumeChanges );
        *pft = _persistentVolumeMap.GetLastUpdateTime();
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = GetExceptionCode();
    }

    return(hr);
}
#endif



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::SearchMachine
//
//  This is the implementation witthin CTrkWksSvc of LnkSearchMachine.  This
//  request is sent by other instances of CTrkWksSvc (trkwks) on remote
//  machines.
//
//  Give a link source's last known droid and birth droid, find the file
//  on this machine, or a referral to the file from the logs.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::SearchMachine(
    RPC_BINDING_HANDLE           IDL_handle,
    DWORD                        Restrictions,
    const CDomainRelativeObjId  &droidBirthLast,
    const CDomainRelativeObjId  &droidLast,
    CDomainRelativeObjId *       pdroidBirthNext,
    CDomainRelativeObjId *       pdroidNext,
    CMachineId *                 pmcidNext,
    TCHAR* ptszPath )
{
    HRESULT hr = S_OK;
    TCHAR                   tszLocalPath[MAX_PATH+1];

    // Abort if the service is being stopped
    RaiseIfStopped();

    // Show who made the call in the debugger.

    #if 1==DBG
    {
        RPC_STATUS rpc_status = RpcImpersonateClient( IDL_handle );
        if( S_OK == rpc_status )
        {
            TCHAR tszCurrentUser[ 200 ] = { TEXT("") };
            ULONG cchCurrentUser = sizeof(tszCurrentUser);
            GetUserName( tszCurrentUser, &cchCurrentUser );
            TrkLog(( TRKDBG_MEND, TEXT("Searching on behalf of %s, Restrictions = %08x"),
                     tszCurrentUser, Restrictions ));
            RpcRevertToSelf();
        }
    }
    #endif // #if 1==DBG

    // Search all the local volumes

    hr = g_ptrkwks->_volumes.Search( Restrictions, droidBirthLast, droidLast,
                                     pdroidBirthNext, pdroidNext, pmcidNext,
                                     tszLocalPath );

    // Did we find the file?

    if( SUCCEEDED(hr) || TRK_E_POTENTIAL_FILE_FOUND == hr )
    {
        // Yes, we either found the link source, or a potential match for
        // the link source (potential means that the objid was right, but the birth
        // ID didn't match).

        TrkLog((TRKDBG_MEND | TRKDBG_WKS, TEXT("CVolumeManager::Search returned local %spath %s"),
                TRK_E_POTENTIAL_FILE_FOUND == hr ? TEXT("potential ") : TEXT(""),
                tszLocalPath ));

        RPC_STATUS rpc_status;
        UINT uiRpcTransportType;
        BOOL fPotential = TRK_E_POTENTIAL_FILE_FOUND == hr;

        // See if the client is on the local machine.  If so, we'll simply
        // return this local path (e.g. "C:\path\file").  Otherwise, we have
        // to generate a UNC path.  We know it's local if the rpc client came to
        // us over the LRPC protocol.

        rpc_status = I_RpcBindingInqTransportType (IDL_handle, &uiRpcTransportType );
        if( RPC_S_OK != rpc_status )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't inq the RPC transport type (%lu)"), rpc_status ));
            TrkRaiseWin32Error( rpc_status );
        }

        if( TRANSPORT_TYPE_LPC != uiRpcTransportType )
        {
            // It's not local.  Map the local path to the "best" UNC path.
            hr = MapLocalPathToUNC( IDL_handle, tszLocalPath, ptszPath );
            if( SUCCEEDED(hr) && fPotential )
                hr = TRK_E_POTENTIAL_FILE_FOUND;
        }
        else
            // Just return this local path.
            _tcscpy( ptszPath, tszLocalPath );

    }   // if (hr == S_OK)


    TrkLog(( TRKDBG_MEND | TRKDBG_WKS,
             TEXT("LnkSearchMachine returns %s %s"),
             GetErrorString(hr),
             ( (hr == S_OK || hr == TRK_E_POTENTIAL_FILE_FOUND) ? ptszPath : TEXT("")) ));

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::SetVolumeId
//
//  Implementation of LnkSetVolumeId RPC request.  This is test-only code.
//  BUGBUG:  Is this used?
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::SetVolumeId(
    ULONG iVolume,
    const CVolumeId VolId)
{
    NTSTATUS status = E_FAIL;

    if (g_ptrkwks->_configWks.GetTestFlags() & TRK_TEST_FLAG_SET_VOLUME_ID)
    {
        CVolumeEnumerator VolumeEnum;
        CVolume * pVol = NULL;

        // We have to ask the volume to set the ID, otherwise the volid
        // protection code will restore the old ID after we set it.

        VolumeEnum = _volumes.Enum();
        while (pVol = VolumeEnum.GetNextVolume())
        {
            if( iVolume == pVol->GetVolIndex() )
            {
                status = pVol->SetVolIdOnVolume( VolId );
                pVol->Release();
                break;
            }

            pVol->Release();
        }
    }

    return status;
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::MendLink
//
//  Implementation of the LnkMendLink RPC request.
//
//  Given the last known droid, machine, and birth droid, this method
//  searches for a link source.  The client may also specify a time
//  limit and certain restrictions on how the search will be performed.
//
//  The result returned is the new droid, machine, and path.  Also, the new
//  birth ID is returned, though it is normally unchanged (it is only changed
//  if TRK_E_POTENTIAL_FILE is returned).
//
//  The search algorithm is:
//
//      -   Search the last known machine.  The identity of the last known
//          machine is as specified by the caller in mcidLast, though if
//          the volid in droidLast shows up in our volume cache, we'll use that.
//
//      -   Contact the DC to find what it believes is the latest droid and
//          that droid's host machine ID.  Search that machine.
//
//      -   Starting with the last known machine, search for the file
//          by following referrals provided in the logs.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::MendLink(
                RPC_BINDING_HANDLE          IDL_handle,
                DWORD                       dwTickCountDeadline,
                DWORD                       Restrictions,

                IN const CDomainRelativeObjId  &droidBirthLast,
                IN const CDomainRelativeObjId  &droidLast,
                IN const CMachineId            &mcidLast,
                OUT CDomainRelativeObjId       *pdroidBirthNew,
                OUT CDomainRelativeObjId       *pdroidNew,
                OUT CMachineId                 *pmcidNew,

                IN OUT ULONG                   *pcbPath,
                OUT WCHAR                      *pwsz )
{
    HRESULT     hr = S_OK, hrFirst = S_OK;

    // Temp values to be used within this routine
    SAllIDs                 allidsFromLog( droidBirthLast, droidLast, mcidLast );
    SAllIDs                 allidsFromDC     = allidsFromLog;

    TCHAR                   tsz[ MAX_PATH + 1 ];

    // Temp values to hold a potential match while we continue to look for
    // a perfect match.
    SAllIDs                 allidsPotential, allidsResult;
    TCHAR                   tszPotential[ MAX_PATH + 1 ];
    BOOL                    fPotential = FALSE;


    wcstotcs(tsz, pwsz);

    TrkLog(( TRKDBG_MEND, TEXT("\nMending birth=%s, last=%s"),
             (const TCHAR*)CDebugString(droidBirthLast),
             (const TCHAR*)CDebugString(droidLast) ));

    __try
    {
        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        //  -----------------------
        //  Search the last machine
        //  -----------------------

        TrkLog(( TRKDBG_MEND, TEXT("Mend: search last machine") ));

        hrFirst = hr = SearchChain( IDL_handle, 1, dwTickCountDeadline, &Restrictions,
                                    USE_SPECIFIED_MCID,
                                    &allidsFromLog, tsz);
        if( SUCCEEDED(hr) || TRK_E_TIMEOUT == hrFirst )
        {
            allidsResult = allidsFromLog;

            // If we succeeded and the droids don't match, then we must
            // have been searching all the volumes on the machine (if
            // we failed with a timeout, the droids shouldn't have changed).

            TrkAssert( !(TRK_MEND_DONT_SEARCH_ALL_VOLUMES & Restrictions)
                       ||
                       allidsFromLog.droidRevised == droidLast );

            __leave;
        }
        else if( TRK_E_POTENTIAL_FILE_FOUND == hrFirst )
        {
            // We have a potential hit (the object ID matched, but the birth ID didn't).

            fPotential = TRUE;

            TrkAssert( allidsFromLog.droidBirth != droidBirthLast );
            TrkAssert( 0 < _tcslen(tsz) );

            // Save these potential values

            allidsPotential = allidsFromLog;
            _tcscpy( tszPotential, tsz );

        }

        //  (droidLastT/mcidLastT always contains last referral)

        //  --------------------------------
        //  Get an updated droid from the DC
        //  --------------------------------

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        hr = TRK_E_NOT_FOUND;
        if( !(TRK_MEND_DONT_USE_DC & Restrictions) )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Mend: ConnectAndSearchDomain") ));
            hr = ConnectAndSearchDomain( droidBirthLast,
                                         &Restrictions,
                                         &allidsFromDC.droidRevised,
                                         &allidsFromDC.mcid );

        }

        //  ---------------------------------
        //  Search using the info from the DC
        //  ---------------------------------

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        if( SUCCEEDED(hr) )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Mend: SearchChain using IDs from DC") ));
            allidsResult = allidsFromDC;

            // Specify USE_SPECIFIED_MCID so that we don't look up the volid
            // in the DC; the DC already mapped the volid to the mcid in the
            // ConnectAndSearchDomain call.

            hr = SearchChain( IDL_handle, -1, dwTickCountDeadline, &Restrictions,
                              USE_SPECIFIED_MCID,
                              &allidsResult, tsz );

        }

        //  ---------------------
        //  Search using the logs
        //  ---------------------

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        if( FAILED(hr) && TRK_E_REFERRAL == hrFirst )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Mend: SearchChain using IDs from Log") ));
            allidsResult = allidsFromLog;
            hr = SearchChain( IDL_handle, -1, dwTickCountDeadline, &Restrictions, SEARCH_FLAGS_DEFAULT,
                              &allidsResult, tsz );
        }

        // If we still haven't found it, try searching the last known machine
        // for potential files.  Potential files are ignored if a referral is found
        // in the log, so we block usage of the log.

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        if( TRK_E_NOT_FOUND == hr && TRK_E_UNAVAILABLE != hrFirst )
        {
            allidsResult.droidBirth = droidBirthLast;
            allidsResult.droidRevised = droidLast;
            allidsResult.mcid = mcidLast;

            TrkLog(( TRKDBG_MEND, TEXT("Mend: SearchChain using IDs from client, don't use log") ));
            Restrictions |= TRK_MEND_DONT_USE_LOG;
            hr = SearchChain( IDL_handle, 1, dwTickCountDeadline, &Restrictions, SEARCH_FLAGS_DEFAULT,
                              &allidsResult, tsz );
        }
    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
    }
    //} while (ft.Redo(hr));

    // If the birth ID doesn't look correct, consider this a potential
    // hit.

    if( SUCCEEDED(hr) )
    {
        if( CVolumeId() == allidsResult.droidBirth.GetVolumeId()
            ||
            CObjId() == allidsResult.droidBirth.GetObjId() )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Birth ID doesn't look valid, flagging as potential hit") ));
            hr = TRK_E_POTENTIAL_FILE_FOUND;
        }
    }


    // Did the last search step succeed, or return a potential file?

    if( SUCCEEDED(hr) || TRK_E_POTENTIAL_FILE_FOUND == hr )
    {
        TrkAssert( 0 < _tcslen(tsz) );

        if( *pcbPath > _tcslen(tsz) * sizeof(WCHAR) )
        {
            tcstowcs(pwsz, tsz);
            *pdroidBirthNew = allidsResult.droidBirth;
            *pdroidNew = allidsResult.droidRevised;
            *pmcidNew = allidsResult.mcid;

        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            *pcbPath = ( _tcslen(tsz) + 1 ) * sizeof(WCHAR);
        }
    }

    // Or, did an earlier search step return a potential file?
    else if( fPotential )
    {
        hr = TRK_E_POTENTIAL_FILE_FOUND;

        if( *pcbPath > _tcslen(tszPotential) * sizeof(WCHAR) )
        {
            tcstowcs(pwsz, tszPotential);
            *pdroidBirthNew = allidsPotential.droidBirth;
            *pdroidNew = allidsPotential.droidRevised;
            *pmcidNew = allidsPotential.mcid;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            *pcbPath = ( _tcslen(tszPotential) + 1 ) * sizeof(WCHAR);
        }
    }

    // Test hook:  If requested, pause here to allow timeout testing

    if( Restrictions & TRK_MEND_SLEEP_DURING_MEND )
    {
        TrkLog(( TRKDBG_MEND, TEXT("Mend: sleep 15 seconds (for testing)") ));
        Sleep( 15 * 1000 );
    }

    TrkLog(( TRKDBG_MEND, TEXT("MendLink returned %s(%08x) \"%ws\""),
             GetErrorString(hr), hr,
             (S_OK == hr || TRK_E_POTENTIAL_FILE_FOUND == hr) ? pwsz : L""
          ));

    return(hr);

}   // CTrkWksSvc::MendLink()


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetVolumeTrackingInformation
//
//  This method is unused (it was being used by a utility that ran on the DC
//  and called down to a workstation to get info about its volumes).
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::GetVolumeTrackingInformation( const CVolumeId & volid,
                                          TrkInfoScope scope,
                                          TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    return( E_NOTIMPL );

#if 0
    HRESULT hr = S_OK;
    CVolumeEnumerator VolEnum;
    CVolume *pvol = NULL;
    TRK_VOLUME_TRACKING_INFORMATION rgvolinfo[10];
    int iVolInfo = -1;

    TrkLog(( TRKDBG_WKS, TEXT("Getting volume-tracking information") ));

    TrkAssert( (TRKINFOSCOPE_MACHINE == scope) ^ (TRKINFOSCOPE_VOLUME == scope) );

    __try
    {
        //  -----------------
        //  Get *all* volumes
        //  -----------------

        if( TRKINFOSCOPE_MACHINE == scope )
        {

            // Get an enumerator

            VolEnum = _volumes.Enum();

            // Get the first volume

            pvol = VolEnum.GetNextVolume();

            // Loop until we run out of volumes

            while( NULL != pvol )
            {
                // Load the data for this volume

                iVolInfo++;
                rgvolinfo[iVolInfo].volindex = pvol->GetVolIndex();
                rgvolinfo[iVolInfo].volume   = pvol->GetVolumeId();

                // Get the next volume

                pvol->Release();

                pvol = VolEnum.GetNextVolume();

                // If there are no more volumes, or if we've got a full load,
                // then send the data we have in rgvolinfo

                if( NULL == pvol
                    ||
                    sizeof(rgvolinfo)/sizeof(*rgvolinfo) - 1 == iVolInfo )
                {
                    // Send the volume information
                    pipeVolInfo.push( pipeVolInfo.state, rgvolinfo, iVolInfo + 1 );

                    // Reset to the start of rgvolinfo.
                    iVolInfo = -1;
                }
            }

        }   // if( NULL == ptszShareName )


        //  ---------------------
        //  Get a *single* volume
        //  ---------------------

        else
        {
            TrkAssert( TRKINFOSCOPE_VOLUME == scope );
            TrkAssert( CVolumeId() != volid );

            NTSTATUS status = STATUS_SUCCESS;

            // Get the CVolume for this volume

            pvol = _volumes.FindVolume( volid );
            if( NULL == pvol )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't find volid %s"),
                         (const TCHAR*)CDebugString(volid) ));
                TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
            }

            // Send the volume info

            rgvolinfo[0].volindex = pvol->GetVolIndex();
            rgvolinfo[0].volume = pvol->GetVolumeId();

            pipeVolInfo.push( pipeVolInfo.state, rgvolinfo, 1 );


        }   // if( NULL == ptszShareName ) ... else

        // Show that we're done with the pipe

        pipeVolInfo.push( pipeVolInfo.state, NULL, 0 );

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    if (pvol)
        pvol->Release();

    return( hr );

#endif // #if 0

}   // CTrkWksSvc::GetVolumeTrackingInformation()


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetFileTrackingInformation
//
//  This method is unused (it was being used by a utility that ran on the DC
//  and called down to a workstation to get info about its link sources).
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::GetFileTrackingInformation( const CDomainRelativeObjId & droidCurrent,
                                        TrkInfoScope scope,
                                        TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    return( E_NOTIMPL );

#if 0

    HRESULT hr = S_OK;
    NTSTATUS status;
    CVolumeEnumerator VolEnum;
    CVolume *pvol = NULL;    // Doesn't need to be freed
    HANDLE hFile = NULL;

    TRK_FILE_TRACKING_INFORMATION rgfileinfo[10];
    int iFileInfo = -1;
    TCHAR tszRelativePathBase[ MAX_PATH ];

    TrkLog(( TRKDBG_WKS, TEXT("Getting file-tracking information") ));

    __try
    {
        if( TRKINFOSCOPE_ONE_FILE == scope )
        {
            CDomainRelativeObjId droidT, droidBirth;

            pvol = _volumes.FindVolume( droidCurrent.GetVolumeId() );
            if( NULL == pvol )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't find volid %s"),
                        (const TCHAR*)CDebugString(droidCurrent.GetVolumeId()) ));
                TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
            }
            if( !pvol->OpenFile( droidCurrent.GetObjId(),
                                 SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 &hFile ) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open file")));
                TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
            }

            status = QueryVolRelativePath( hFile, &rgfileinfo[0].tszFilePath[2] );
            if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't query file for vol-relative path")));
                TrkRaiseNtStatus( status );
            }
            rgfileinfo[0].tszFilePath[0] = (TCHAR)(0 <= pvol->GetVolIndex() ? TEXT('A') + pvol->GetVolIndex() : TEXT('?'));
            rgfileinfo[0].tszFilePath[1] = TEXT(':');

            // BUGBUG P2:  Optimize so we don't have to get droidT

            status = GetDroids( hFile, &droidT, &droidBirth, RGO_READ_OBJECTID );
            if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't get droids in GetFileTrkInfo")));
                TrkRaiseNtStatus( status );
            }
            TrkAssert( droidT == droidCurrent );

            NtClose( hFile ); hFile = NULL;

            rgfileinfo[0].droidBirth = droidBirth;
            rgfileinfo[0].droidLast = droidCurrent;

            rgfileinfo[0].hr = S_OK;

            pipeFileInfo.push( pipeFileInfo.state, rgfileinfo, 1 );
        }
        else if( TRKINFOSCOPE_DIRECTORY == scope )
        {
            TrkRaiseException( E_NOTIMPL );
        }
        else
        {
            if( TRKINFOSCOPE_VOLUME == scope )
            {
                // Get the volume object
                TrkAssert(!pvol);
                pvol = _volumes.FindVolume( droidCurrent.GetVolumeId() );
                if( NULL == pvol )
                {
                    TrkLog((TRKDBG_ERROR, TEXT("Couldn't find volid %s"),
                            (const TCHAR*)CDebugString(droidCurrent.GetVolumeId()) ));
                    TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
                }
            }
            else if( TRKINFOSCOPE_MACHINE == scope )
            {
                VolEnum = _volumes.Enum();
                TrkAssert(!pvol);
                pvol = VolEnum.GetNextVolume(); // BUGBUG P1: ref count on enum
                if( NULL == pvol )
                {
                    TrkLog((TRKDBG_ERROR, TEXT("Couldn't find first volume in enumerator")));
                    TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
                }
            }
            else
            {
                TrkRaiseException( E_NOTIMPL );
            }


            while( NULL != pvol )
            {
                CObjIdEnumerator objidenum;
                CObjId VolRelativeFileTrackingInfoObjId;
                CDomainRelativeObjId VolRelativeFileTrackingInfoDroid;

                if( !pvol->EnumObjIds( &objidenum ))
                {
                    pvol->Release();
                    pvol = VolEnum.GetNextVolume();
                    continue;
                }

                iFileInfo = -1;
                if( objidenum.FindFirst( &VolRelativeFileTrackingInfoObjId,
                                         &VolRelativeFileTrackingInfoDroid))
                {
                    TCHAR tszRelativePathFile[ MAX_PATH ]; // BUGBUG P1: path

                    do
                    {
                        if( !pvol->OpenFile( VolRelativeFileTrackingInfoObjId,
                                             SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE, &hFile ))
                        {
                            TrkAssert( FALSE && TEXT("File is in object directory but doesn't exist") );
                            hFile = NULL;
                            continue;
                        }

                        status = QueryVolRelativePath( hFile, &tszRelativePathFile[2] );
                        NtClose( hFile ); hFile = NULL;
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get vol-relative path for objid %s"),
                                    (const TCHAR*)CDebugString(VolRelativeFileTrackingInfoObjId) ));
                            TrkRaiseNtStatus( status );
                        }

                        tszRelativePathFile[0] = (TCHAR)(0 <= pvol->GetVolIndex() ? TEXT('A') + pvol->GetVolIndex() : TEXT('?'));
                        tszRelativePathFile[1] = TEXT(':');

                        ++iFileInfo;

                        _tcscpy( rgfileinfo[ iFileInfo ].tszFilePath, tszRelativePathFile );
                        rgfileinfo[ iFileInfo ].droidBirth = VolRelativeFileTrackingInfoDroid;
                        rgfileinfo[ iFileInfo ].droidLast
                            = CDomainRelativeObjId( pvol->GetVolumeId(),
                                                    VolRelativeFileTrackingInfoObjId );

                        if( iFileInfo == sizeof(rgfileinfo)/sizeof(*rgfileinfo) - 1)
                        {
                            pipeFileInfo.push( pipeFileInfo.state, rgfileinfo, iFileInfo + 1 );
                            iFileInfo = -1;
                        }

                    } while( objidenum.FindNext( &VolRelativeFileTrackingInfoObjId,
                        &VolRelativeFileTrackingInfoDroid ));

                    if( iFileInfo >= 0 )
                        pipeFileInfo.push( pipeFileInfo.state, rgfileinfo, iFileInfo );

                }   // if( objidenum.FindFirst( ))

                if (pvol)
                {
                    pvol->Release();
                }
                pvol = VolEnum.GetNextVolume();

            }   // while( NULL != pVol )
        }   // if( NULL != hFile ) ... else
    }   // __try

    __finally
    {
        // Show that we're done with the pipe
        pipeFileInfo.push( pipeFileInfo.state, NULL, 0 );

        if( NULL != hFile )
            NtClose( hFile );

        if ( NULL != pvol )
            pvol->Release();
    }


    return( hr );

#endif // #if 0

}   // CTrkWksSvc::GetFileTrackingInformation()



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::TriggerVolumeClaims
//
//  This method is not currently used.  (It was being used by a utility run
//  on the DC that would trigger volume claim requests after updating
//  the DS.)
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::TriggerVolumeClaims( ULONG cVolumes, const CVolumeId *rgvolid )
{
    return( E_NOTIMPL );

#if 0

    CVolume *pvol = NULL;
    CAvailableDc adc;
    HRESULT hr = E_FAIL;
    ULONG iVol;
    TRKSVR_SYNC_VOLUME rgsyncvol[ NUM_VOLUMES ]; // BUGBUG:  fix number of volumes
    TRKSVR_MESSAGE_UNION Msg;

    TrkLog(( TRKDBG_WKS, TEXT("Triggering %d volume claims"), cVolumes ));

    if( 0 == cVolumes || NUM_VOLUMES < cVolumes )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    __try
    {
        for( iVol = 0; iVol < cVolumes; iVol++ )
        {
            pvol = _volumes.FindVolume( rgvolid[iVol] );
            if( NULL == pvol )
            {
                // We don't handle the case where a volume is removed during the call
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't find volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = TRK_E_NOT_FOUND;
                goto Exit;
            }

            if( !pvol->LoadSyncVolume( /* CLAIM_VOLUME, */ &rgsyncvol[iVol] ) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't load volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = E_FAIL;
                goto Exit;
            }

            pvol->Release();
            pvol = NULL;
        } // for( iVol = 0; iVol < cVolumes; iVol++ )

        Msg.MessageType = SYNC_VOLUMES;
        Msg.Priority = PRI_0;
        Msg.SyncVolumes.cVolumes = cVolumes;

        Msg.SyncVolumes.pVolumes = rgsyncvol;

#ifdef VOL_REPL
        Msg.SyncVolumes.cChanges = 0;
        Msg.SyncVolumes.ppVolumeChanges = NULL;
#endif


        adc.CallAvailableDc(this, &Msg);

        for( iVol = 0; iVol < cVolumes; iVol++ )
        {
            pvol = _volumes.FindVolume( rgvolid[iVol] );
            if( NULL == pvol )
            {
                // We don't handle the case where a volume is removed during this call.
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't find volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = TRK_E_NOT_FOUND;
                goto Exit;
            }

            if( !pvol->UnloadSyncVolume( &rgsyncvol[iVol] ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't unload volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = E_FAIL;
                goto Exit;
            }

            pvol->Release();
            pvol = NULL;
        }
    }
    __finally
    {
        if( AbnormalTermination() && NULL != pvol )
            pvol->Release();

        adc.UnInitialize();
    }

    hr = S_OK;

Exit:

    if (pvol != NULL)
        pvol->Release();

    return( hr );

#endif // #if 0

}   // CTrkWksSvc::TriggerVolumeClaims


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::ConnectAndSearchDomain
//
//  This method looks up a birth ID in the DC (trksvr).  If it was
//  found, it returns the new droid, and the machine that owns that
//  droid.
//
//  Arguments:
//      [droidBirth]
//          The ID of the file to look up.
//      [pRestrictions]
//          The TrkMendRestrictions flags.  If we can't talk to the
//          DC for some reason, TRK_MEND_DONT_USE_DC will be set.
//      [pdroidLast]
//          On successful return, holds the file's last known droid.
//      [pmcidLast]
//          On successful return, identifies the machine that holds
//          the volume specified in pdroidLast.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::ConnectAndSearchDomain(IN const CDomainRelativeObjId &droidBirth,
                                   IN OUT DWORD                  *pRestrictions,
                                   IN OUT CDomainRelativeObjId   *pdroidLast,
                                   OUT CMachineId                *pmcidLast )
{
    TRKSVR_MESSAGE_UNION Msg;
    TRK_FILE_TRACKING_INFORMATION TrkFileInfo;

    HRESULT hr = TRK_E_UNAVAILABLE;
    CAvailableDc adc;

    // If the volid in the birth ID isn't specified, then there's nothing
    // we can look up.

    if( CVolumeId() == droidBirth.GetVolumeId() )
        return( TRK_E_NOT_FOUND );

    // Also, if there is no DC, then there's no need trying to RPC to it.

    else if( _configWks._fIsWorkgroup )
        return( TRK_E_UNAVAILABLE );

    __try
    {
        memset( &TrkFileInfo, 0, sizeof(TrkFileInfo) );
        TrkFileInfo.droidBirth = droidBirth;
        TrkFileInfo.droidLast = *pdroidLast;
        TrkFileInfo.mcidLast = CMachineId();

        Msg.MessageType = SEARCH;
        Msg.Priority = PRI_0;
        Msg.Search.cSearch = 1;
        Msg.Search.pSearches = &TrkFileInfo;

        // Send the search request to trksvr.

        adc.CallAvailableDc(&Msg);

        // Was it found?

        if( TrkFileInfo.hr == S_OK )
        {
            // Get the last known droid & mcid for return.
            *pdroidLast = TrkFileInfo.droidLast;
            *pmcidLast = TrkFileInfo.mcidLast;
            hr = S_OK;
            _volumeLocCache.AddVolume( TrkFileInfo.droidLast.GetVolumeId(), TrkFileInfo.mcidLast );
        }
        else
        {
            // Either the last/birth DROIDs weren't found, or they mapped
            // to a volume that didn't exist.

            hr = TRK_E_NOT_FOUND;

            if( TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND     == TrkFileInfo.hr
                ||
                TRK_E_NOT_FOUND_AND_LAST_VOLUME_NOT_FOUND == TrkFileInfo.hr )
            {
                // The last/birth DROIDs weren't found.  If the error was
                // TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND, then the volume
                // for droidLast did exist as was looked up.  If the error
                // was just TRK_E_NOT_FOUND, then the volume for droidLast
                // couldn't be found.  In either case, take this opportunity
                // to add it to the volume cache, because we're probably about
                // to use it in a fallback search.

                _volumeLocCache.AddVolume( TrkFileInfo.droidLast.GetVolumeId(), TrkFileInfo.mcidLast );
            }

        }
    }
    __except (BreakOnDebuggableException())
    {
        hr = TRK_E_UNAVAILABLE;
        if( HRESULT_FROM_WIN32(RPC_S_INVALID_TAG) == GetExceptionCode() )
        {
            // We get this error when we talk to a beta2 DC.  Retry
            // the request using the old two-call mechanism.
            TrkLog(( TRKDBG_MEND, TEXT("Trying downlevel ConnectAndSearchDomain") ));
            hr = OldConnectAndSearchDomain( droidBirth, pdroidLast, pmcidLast );
        }
        else
        {
            // Something's wrong with the DC and there's no point
            // trying to call it again during this mend operation.
            *pRestrictions |= TRK_MEND_DONT_USE_DC;
        }

    }

    TrkLog((TRKDBG_MEND, TEXT("ConnectAndSearchDomain returning %s"), GetErrorString(hr)));

    TrkAssert(hr == S_OK ||
        hr == TRK_E_NOT_FOUND ||
        hr == TRK_E_UNAVAILABLE);

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OldConnectAndSearchDomain
//
//  This method is functionally equivalent to ConnectAndSearchDomain.
//  The difference is that it uses an older interface, it makes
//  an old_SEARCH request followed by a FIND_VOLUME request (the
//  modern SEARCH request returns the volume, making the FIND_VOLUME
//  request unecessary).
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::OldConnectAndSearchDomain(IN const CDomainRelativeObjId & droidBirth,
                                      IN OUT CDomainRelativeObjId *pdroidLast,
                                      OUT CMachineId *pmcidLast )
{
    HRESULT hr = S_OK;
    CAvailableDc adc;

    __try
    {
        TRKSVR_MESSAGE_UNION Msg;
        old_TRK_FILE_TRACKING_INFORMATION OldTrkFileInfo;
        TRKSVR_SYNC_VOLUME SyncVolume;

        // Search for the the latest droid.

        OldTrkFileInfo.droidBirth = droidBirth;
        OldTrkFileInfo.droidLast = *pdroidLast;

        Msg.MessageType = old_SEARCH;
        Msg.Priority = PRI_0;
        Msg.old_Search.cSearch = 1;
        Msg.old_Search.pSearches = &OldTrkFileInfo;

        adc.CallAvailableDc(&Msg);
        if( S_OK != OldTrkFileInfo.hr )
        {
            hr = TRK_E_NOT_FOUND;
            __leave;
        }

        // Search for the location of the volume in the droid just returned.

        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = FIND_VOLUME;
        SyncVolume.volume = OldTrkFileInfo.droidLast.GetVolumeId();

        Msg.MessageType = SYNC_VOLUMES;
        Msg.Priority = PRI_0;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;

        hr = adc.CallAvailableDc(&Msg);

        if( S_OK != hr || S_OK != SyncVolume.hr )
        {
            hr = TRK_E_NOT_FOUND;
            __leave;
        }

        // We found both the droid and the machine.

        TrkLog(( TRKDBG_MEND, TEXT("Downlevel ConnectAndSearchDomain finds %s, %s"),
                 (const TCHAR*)CDebugString(OldTrkFileInfo.droidLast),
                 (const TCHAR*)CDebugString(SyncVolume.machine) ));

        *pdroidLast = OldTrkFileInfo.droidLast;
        *pmcidLast = SyncVolume.machine;

    }
    __except( BreakOnDebuggableException() )
    {
    }

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::ConnectAndSearchMachine
//
//  RPC to the machine specified by the mcid parameter, and execute the
//  LnkSearchMachine method.  If the target is actually the local machine,
//  this method just calls StubLnkSearchMachine directly.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::ConnectAndSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                                    const CMachineId            &mcid,
                                    IN OUT DWORD                *pRestrictions,
                                    IN OUT CDomainRelativeObjId *pdroidBirthLast,
                                    IN OUT CDomainRelativeObjId *pdroidLast,
                                    OUT CMachineId              *pmcidLast,
                                    OUT TCHAR                   *ptsz)
{
    CRpcClientBinding    rc;
    HRESULT              hr;
    CDomainRelativeObjId droidBirthNext, droidNext;
    CMachineId           mcidNext;
    RPC_STATUS           rpc_status = S_OK;
    BOOL                 fImpersonating = FALSE;

    __try
    {
        //FAILTEST();

        // Are we calling the local machine?
        if( CMachineId(MCID_LOCAL) == mcid )
        {
            // Yes, don't bother going through RPC.
            // (Actually, this isn't just for performance; this is also so that
            // a local path may be returned.)

            hr = StubLnkSearchMachine( IDL_handle, *pRestrictions,
                                       pdroidBirthLast, pdroidLast,
                                       &droidBirthNext, &droidNext, &mcidNext, ptsz );
        }

        // Or, is this an unservicable request?

        else if( CMachineId() == mcid )
            hr = TRK_E_UNAVAILABLE;

        // Otherwise, RPC to mcid.

        else
        {
            // Impersonate the client during this call, so that the target
            // can determine what UNC path is best for this user.

            if( RpcSecurityEnabled() )  // Normal case
            {
                rpc_status = RpcImpersonateClient( IDL_handle );
                if( STATUS_SUCCESS != rpc_status )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't impersonate client") ));
                    TrkRaiseWin32Error( rpc_status );
                }
                fImpersonating = TRUE;
            }
            else    // Test case
            {
                if( !ImpersonateSelf( SecurityImpersonation ))
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't impersonate self") ));
                    TrkRaiseLastError();
                }
                fImpersonating = TRUE;
            }

            //
            // Set up the client binding after the impersonation so that RPC
            // picks up the right user security info - but specify no Rpc auth
            // so that we get named pipes auth
            //

            for( int cRetries = 0; cRetries < 2; cRetries++ )
            {
                BOOL fContinue = FALSE;

                // We'll try the normal endpoint name (trkwks) first.  If that gives
                // us rpc_s_server_unavailable, we'll try the Win2K name (ntsvcs).
                // (This change happened when we moved from services.exe to svchost.)

                rc.RcInitialize(mcid,
                    s_tszTrkWksRemoteRpcProtocol,
                    0 == cRetries
                        ? s_tszTrkWksRemoteRpcEndPoint
                        : s_tszTrkWksRemoteRpcEndPointOld,
                    NO_AUTHENTICATION);

                TrkLog(( TRKDBG_MEND, TEXT("Attempting LnkSearchMachine on %s"),
                         0 == cRetries
                             ? s_tszTrkWksRemoteRpcEndPoint
                             : s_tszTrkWksRemoteRpcEndPointOld ));

                __try
                {
                    hr = LnkSearchMachine(rc, *pRestrictions,
                                          const_cast<const CDomainRelativeObjId*>(pdroidBirthLast),
                                          const_cast<const CDomainRelativeObjId*>(pdroidLast),
                                          &droidBirthNext, &droidNext, &mcidNext, ptsz );
                }
                __except( (0 == cRetries && RPC_S_SERVER_UNAVAILABLE == GetExceptionCode())
                            ? EXCEPTION_EXECUTE_HANDLER 
                            : EXCEPTION_CONTINUE_SEARCH )
                {
                    // On the first attempt, we got an error consistent with calling
                    // a Win2K box.  Try again (and this time we'll use the endpoint name
                    // that was used back then).

                    rc.UnInitialize();
                    fContinue = TRUE;
                }

                if( !fContinue )
                    break;
            }

            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_MEND, TEXT("LnkSearchMachine(%s) returns %08x"),
                         (const TCHAR*)CDebugString(mcid), hr ));
            }

        }    // if( CMachineId( MCID_LOCAL ) == mcid ) ... else

        // Did we find the file?

        if( SUCCEEDED(hr) || TRK_E_REFERRAL == hr || TRK_E_POTENTIAL_FILE_FOUND == hr )
        {
            *pdroidBirthLast = droidBirthNext;
            *pdroidLast = droidNext;
            *pmcidLast = mcidNext;
        }
        else
        if (hr != S_OK && hr != TRK_E_NOT_FOUND && hr != TRK_S_VOLUME_NOT_FOUND)
        {
            hr = TRK_E_UNAVAILABLE;
        }

    }
    __except(BreakOnDebuggableException())
    {
        hr = TRK_E_UNAVAILABLE;
    }

    // Revert to self

    if( fImpersonating )
    {
        if( RpcSecurityEnabled() )
            RpcRevertToSelf();
        else
            RevertToSelf();
    }


    TrkLog((TRKDBG_MEND, TEXT("ConnectAndSearchMachine returning %s"), GetErrorString(hr)));

    TrkAssert(hr == S_OK ||
        hr == TRK_E_REFERRAL ||
        hr == TRK_E_NOT_FOUND ||
        hr == TRK_E_UNAVAILABLE ||
        hr == TRK_S_VOLUME_NOT_FOUND ||
        hr == TRK_E_POTENTIAL_FILE_FOUND );

    return(hr);
}


/*
CMachineId::CMachineId(handle_t ClientBinding)
{
    TrkAssert( !TEXT("CMachineId(handle_t)") );
}
*/




//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::FindAndSearchVolume
//
//  Find the location of a volume, and send a search request to that
//  machine.  The machine is located by using either the volume ID
//  in pdroidLast, or by using the machine ID in pmcidLast, depending
//  on what works, what the client specified in pRestrictions, and
//  depending on what the caller specified in SearchFlags.
//
//  Assuming no special Restrictions or SearchFlags, the algorithm for
//  locating a volume is:
//
//      -   Search the local machine.
//
//      -   Search the local cache that maps volumes to machines.  If
//          that fails, or the subsequent call to the machine fails
//          with a volume error, continue to the next step.
//
//      -   Call to the DC and ask it to map the volume ID to the
//          current machine ID.
//
//  If a search of a remote machine is successful, we add the volid->mcid
//  mapping to the local cache for later use.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::FindAndSearchVolume(RPC_BINDING_HANDLE  IDL_handle,
                                IN OUT DWORD *pRestrictions,
                                IN SEARCH_FLAGS SearchFlags,
                                IN OUT CDomainRelativeObjId *pdroidBirthLast,
                                IN OUT CDomainRelativeObjId *pdroidLast,
                                IN OUT CMachineId           *pmcidLast,
                                TCHAR                       *ptsz)
{
    HRESULT hr = TRK_E_NOT_FOUND;
    HRESULT hrFromSearchUsingCachedVolId = TRK_E_NOT_FOUND;
    BOOL fFoundVolumeOnThisMachine = FALSE;
    BOOL fRecentVolCacheEntryFound = FALSE;
    CMachineId mcidSearch;
    CMachineId mcidFromVolumeCache;
    CAvailableDc adc;
    CVolume * pVol = NULL;
    CVolumeId volid;

    __try
    {
        //  ------------------------------------------------------
        //  Determine what machine to search and put in mcidSearch
        //  ------------------------------------------------------

        // If this isn't a meaningfull volid, or we don't have a DC in which to
        // look up volids, then just use the last machine ID.

        if( CVolumeId() == pdroidLast->GetVolumeId()
            ||
            _configWks._fIsWorkgroup
            ||
            (*pRestrictions & TRK_MEND_DONT_USE_VOLIDS)
            ||
            (USE_SPECIFIED_MCID & SearchFlags) )
        {
            mcidSearch = *pmcidLast;
            hr = TRK_E_NOT_FOUND;

            TrkLog(( TRKDBG_MEND, TEXT("Didn't search for %s, using machine %s"),
                     _configWks._fIsWorkgroup ? TEXT("volume in workgroup") : TEXT("volume"),
                     (const TCHAR*)CDebugString(mcidSearch) ));
        }

        // Try to find the volume locally

        else if( !(TRK_MEND_DONT_SEARCH_ALL_VOLUMES & *pRestrictions)
                 &&
                 NULL != (pVol = _volumes.FindVolume( pdroidLast->GetVolumeId()) ))
        {
            // found the volume on this machine
            fFoundVolumeOnThisMachine = TRUE;
            mcidSearch = CMachineId(MCID_LOCAL);
            hr = S_OK;

            TrkLog((TRKDBG_MEND, TEXT("Found volume %s on THIS (%s) machine."),
                    (const TCHAR*)CDebugString(pdroidLast->GetVolumeId()),
                    (const TCHAR*)CDebugString(mcidSearch) ));
        }

        else
        {
            // The volume isn't on the local machine.  See if we can find it in the
            // local volume cache.

            if( TRK_MEND_DONT_SEARCH_ALL_VOLUMES & *pRestrictions )
                hr = TRK_E_NOT_FOUND;
            else
                hr = _volumeLocCache.FindVolume( pdroidLast->GetVolumeId(),
                                                 &mcidFromVolumeCache,
                                                 &fRecentVolCacheEntryFound )
                        ? S_OK
                        : TRK_E_NOT_FOUND;

            if (hr == S_OK)
            {
                // Yes, the volid-to-mcid mapping is in the local cache.

                CDomainRelativeObjId droidBirthLast = *pdroidBirthLast;
                CDomainRelativeObjId droidLast = *pdroidLast;
                CMachineId           mcidLast = *pmcidLast;
                TCHAR                tsz[ MAX_PATH + 1 ];

                TrkLog((TRKDBG_MEND, TEXT("LocalCache--> %s (%s)"),
                        (const TCHAR*)CDebugString(mcidFromVolumeCache),
                        fRecentVolCacheEntryFound
                            ? TEXT("young cache entry") 
                            : TEXT("old cache entry") ));

                mcidSearch = mcidFromVolumeCache;
                volid = pdroidLast->GetVolumeId();

                // Search using temporaries, so that we can ignore the result if
                // we just get a TRK_E_POTENTIAL_FILE_FOUND.

                hr = ConnectAndSearchMachine(IDL_handle, mcidSearch, pRestrictions,
                                             &droidBirthLast, &droidLast, &mcidLast, tsz);

                // If the volume is good, put it back into the cache.  This
                // refreshes it so that it's least likely to be removed in a trim.

                if (hr != TRK_S_VOLUME_NOT_FOUND
                    &&
                    hr != TRK_E_UNAVAILABLE)
                {
                    TrkLog((TRKDBG_MEND, TEXT("%s --> %s"),
                            (const TCHAR*)CDebugString(mcidSearch),
                            GetErrorString(hr) ));

                    _volumeLocCache.AddVolume(volid, mcidSearch);
                }

                if( SUCCEEDED(hr) )
                {
                    // We found the file and we're done.

                    *pdroidBirthLast = droidBirthLast;
                    *pdroidLast = droidLast;
                    *pmcidLast = mcidLast;
                    _tcscpy( ptsz, tsz );
                    __leave;
                }

                // We didn't find the file.  Save this result.
                // We might look up the volid in the DC to handle
                // the case where the cache is out of date.  But if the DC agrees on
                // where that volume lives, we won't bother to search again.
                hrFromSearchUsingCachedVolId = hr;

            }   // if (hr == S_OK)

#ifdef VOL_REPL
            if (hr != S_OK)
            {
                hr = _persistentVolumeMap.FindVolume(pdroidLast->GetVolumeId(), &mcidSearch) ? S_OK : TRK_E_NOT_FOUND;
                if (hr == S_OK)
                {
                    TrkLog((TRKDBG_MEND, TEXT("FindAndSearchVolume: Volume on machine %s, (found in local persist volume map)"),
                        CDebugString(mcidSearch)._tsz));
                }
            }
#endif

            // The volume isn't local, or wasn't in the local cache, or if it was in the
            // local cache the cache is out of date.  So, we'll ask the TrkSvr (DC).

            if( hr != S_OK )
            {
                BOOL fSearchedDC = FALSE;
                TRKSVR_SYNC_VOLUME SyncVolume;
                SyncVolume.hr = TRK_S_VOLUME_NOT_FOUND;

                // Not found on this machine ... go look in the DC for the volume.
                // Don't look in the DC, however, if restricted to avoid it,
                // or if we had a good (recent) entry for it in the volume cache.

                if( !fRecentVolCacheEntryFound
                    &&
                    !(TRK_MEND_DONT_USE_DC & *pRestrictions)
                    &&
                    !(DONT_USE_DC & SearchFlags) )
                {
                    TRKSVR_MESSAGE_UNION Msg;
                    VolumeMapEntry * pVolumeChanges = NULL;

                    SyncVolume.hr = S_OK;
                    SyncVolume.SyncType = FIND_VOLUME;
                    SyncVolume.volume = pdroidLast->GetVolumeId();
                    SyncVolume.machine = CMachineId();

                    Msg.MessageType = SYNC_VOLUMES;
                    Msg.Priority = PRI_0;
                    Msg.SyncVolumes.cVolumes = 1;
                    Msg.SyncVolumes.pVolumes = &SyncVolume;

#ifdef VOL_REPL
                    Msg.SyncVolumes.ppVolumeChanges = &pVolumeChanges;
                    Msg.SyncVolumes.cChanges = 0;
                    Msg.SyncVolumes.ftFirstChange = CFILETIME(-1);
#endif

                    __try
                    {
                        hr = adc.CallAvailableDc(&Msg);
                        fSearchedDC = TRUE;
                    }
                    __except( EXCEPTION_EXECUTE_HANDLER )
                    {
                        hr = GetExceptionCode();

                        // Something's wrong with the DC and there's no point
                        // trying to call it again during this mend operation.

                        *pRestrictions |= TRK_MEND_DONT_USE_DC;
                    }

                }   // if( !(TRK_MEND_DONT_USE_DC & *pRestrictions) )

#if DBG
                else
                {
                    TrkLog(( TRKDBG_MEND, TEXT("Not searching for volume on DC because of %s, %s, %s"),
                        fRecentVolCacheEntryFound ? TEXT("VolCache") : TEXT(""),
                        (TRK_MEND_DONT_USE_DC & *pRestrictions) ? TEXT("Restrictions") : TEXT(""),
                        (DONT_USE_DC & SearchFlags) ? TEXT("SearchFlags") : TEXT("") ));
                }
#endif

                // Did we successfully get a mcid back from the DC
                // that's different than the one we found in the volume cache?

                if( S_OK == hr && S_OK == SyncVolume.hr )
                {
                    // We got an mcid back from the DC

                    if( SyncVolume.machine != mcidFromVolumeCache )
                    {
                        // And the mcid from the DC differs from the one in the
                        // volume cache (the volume has moved since the time we cached it).

                        mcidSearch = SyncVolume.machine;
                        hr = S_OK;
                        TrkLog((TRKDBG_MEND, TEXT("Found volume %s in DC on %s"),
                                (const TCHAR*)CDebugString(pdroidLast->GetVolumeId()),
                                (const TCHAR*)CDebugString(mcidSearch) ));
                    }
                    else
                    {
                        // We've already searched this volume.

                        TrkLog((TRKDBG_MEND, TEXT("DC matches volume cache") ));

                        hr = hrFromSearchUsingCachedVolId;
                        __leave;
                    }

                }
                else
                {
                    // We couldn't find the volume in the DC.
#if DBG
                    if( fSearchedDC )
                    {
                        TrkLog((TRKDBG_MEND, TEXT("DC--> %s -> %s,%s."),
                                (const TCHAR*)CDebugString(pdroidLast->GetVolumeId()),
                                GetErrorString(hr),
                                GetErrorString(SyncVolume.hr) ));
                    }
#endif

                    mcidSearch = *pmcidLast;
                    hr = TRK_E_NOT_FOUND;
                }

                // Save this result in the volume cache.  If we didn't find the volume,
                // then we'll be putting a null machine ID into the cache as a way
                // of remembering not to ask the DC again in the near future.

                if( fSearchedDC )
                    _volumeLocCache.AddVolume( SyncVolume.volume, SyncVolume.machine );


            }   // if (hr != S_OK)
        }   // if (pVol != NULL)

        //  -------------------------------------------------
        //  We've found a machine.  Connect to it and search.
        //  -------------------------------------------------

        // Save the volid from pdroidLast before it gets overwritten.
        volid = pdroidLast->GetVolumeId();

        if( !(TRK_MEND_DONT_SEARCH_LAST_MACHINE & *pRestrictions)
            ||
            mcidSearch != *pmcidLast )
        {
            hr = ConnectAndSearchMachine(IDL_handle, mcidSearch, pRestrictions,
                                         pdroidBirthLast, pdroidLast, pmcidLast, ptsz);
        }
        else
            hr = TRK_E_NOT_FOUND;

        // Take advantage of our work to find the owner of this volume, and
        // add it to the cache.

        if( S_OK == hr && !fFoundVolumeOnThisMachine )
            _volumeLocCache.AddVolume(volid, mcidSearch);

        // S_OK || TRK_E_REFERRAL || TRK_E_NOT_FOUND || TRK_E_UNAVAILABLE
    }
    __finally
    {
        if (pVol != NULL)
        {
            pVol->Release();
        }

        if (AbnormalTermination())
        {
            TrkLog((TRKDBG_MEND, TEXT("FindAndSearchVolume: abnormal termination")));
        }

        adc.UnInitialize();

    }

    TrkLog((TRKDBG_MEND, TEXT("Call to %s to FindAndSearchVolume returned %s"),
            (const TCHAR*)CDebugString(mcidSearch),
            GetErrorString(hr) ));

    return(hr);
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::SearchChain
//
//  Search for a link source, possibly searching a chain of moves using
//  referrals from the log.  The caller can specify how many referrals
//  (links in the chain) to follow.  The search starts at the location
//  specified by the IDs in the pallidsLast parameter.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::SearchChain(RPC_BINDING_HANDLE IDL_handle,
                        int             cMaxReferrals,
                        DWORD           dwTickCountDeadline,
                        IN OUT DWORD    *pRestrictions,
                        IN SEARCH_FLAGS SearchFlags,
                        IN OUT SAllIDs  *pallidsLast,
                        OUT TCHAR       *ptsz)
{
    int cReferrals = 0;
    HRESULT hr;
    IFDBG( CDomainRelativeObjId droidBirthOriginal = pallidsLast->droidBirth );

    struct CDroidList
    {
        CDomainRelativeObjId droid;
        CDroidList  *pNext;
    };
    CDroidList *pdroidList = NULL;

    // As a sanity check, never search over (100) places.
    if( -1 == cMaxReferrals )
        cMaxReferrals = _configWks.GetMaxReferrals();


    __try
    {
        while (TRUE)
        {
            CDroidList *pdroidNode = NULL;

            // Abort if the service has been requested to stop.
            RaiseIfStopped();

            if( GetTickCount() >= dwTickCountDeadline )
            {
                TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
                hr = TRK_E_TIMEOUT;
                __leave;
            }

            // Have we searched this droid before?

            for( pdroidNode = pdroidList; NULL != pdroidNode; pdroidNode = pdroidNode->pNext )
            {
                if( pdroidNode->droid == pallidsLast->droidRevised )
                {
                    // Yes, we've see this droid before.  Abort.

                    TrkLog(( TRKDBG_MEND | TRKDBG_WKS,
                             TEXT("Aborting SearchChain; cycle found at %s"),
                             (const TCHAR*)CDebugString( pdroidNode->droid ) ));

                    hr = TRK_E_NOT_FOUND;
                    goto Exit;
                }
            }

            // Add a new node to the list for this volume (this is used above
            // for cycle detection).

            pdroidNode = new CDroidList;
            if( NULL == pdroidNode )
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );

            pdroidNode->droid = pallidsLast->droidRevised;
            pdroidNode->pNext = pdroidList;
            pdroidList = pdroidNode;
            pdroidNode = NULL;

            // Now find the volume and search it for the file.

            hr = FindAndSearchVolume( IDL_handle, pRestrictions, SearchFlags,
                                      &pallidsLast->droidBirth, &pallidsLast->droidRevised,
                                      &pallidsLast->mcid, ptsz);

            // If we got anything other than a referral (including S_OK) we're done.

            if( TRK_E_REFERRAL != hr )
            {
                TrkLog((TRKDBG_MEND | TRKDBG_WKS, TEXT("SearchChain - %s != TRK_E_REFERRAL so returning (%s)"),
                        GetErrorString(hr),
                        droidBirthOriginal == pallidsLast->droidBirth
                            ? TEXT("birth IDs match")
                            : TEXT("birth IDs don't match")

                        ));
                goto Exit;
            }

            // We got a referral.  Either return the referral, or follow it.

            if( ++cReferrals >= cMaxReferrals )
            {
                // Return the referral.
                TrkLog((TRKDBG_MEND, TEXT("SearchChain: Reached chain limit.")));
                goto Exit;
            }
        }
    }
    __finally
    {
        while( NULL != pdroidList )
        {
            CDroidList *pdroidNext = pdroidList->pNext;
            delete pdroidList;
            pdroidList = pdroidNext;
        }
    }

Exit:

    TrkAssert( NULL == pdroidList );
    return( hr );
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnDomainNameChange
//
//  This method is called when we receive a notification that the domain
//  name has changed (which also happens if we move between a workgroup
//  and domain).  We handle this by putting all the volumes in the
//  not-owned state.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::OnDomainNameChange()
{
    BOOL fWasWorkgroup;
    TrkLog(( TRKDBG_WKS, TEXT("Domain name change notification") ));

    _csDomainNameChangeNotify.Enter();
    __try
    {
        RaiseIfStopped();

        fWasWorkgroup = _configWks._fIsWorkgroup;
        CheckForDomainOrWorkgroup();    // Sets _configWks._fIsWorkgroup

        // Workgroup => Domain
        if( fWasWorkgroup && !_configWks._fIsWorkgroup )
        {
            _volumes.InitializeDomainObjects();
            StartDomainTimers();
            _volumes.StartDomainTimers();
        }

        // Domain => Workgroup
        else if( !fWasWorkgroup && _configWks._fIsWorkgroup )
        {
            _volumes.UnInitializeDomainObjects();
        }

        // If we switched into a domain, or between domains, claim
        // our volumes to get in sync with the DC or begin the process
        // of re-creating the volume.

        if( !_configWks._fIsWorkgroup )
            _volumes.ForceVolumeClaims();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception %08x in OnDomainNameChange"),
                 GetExceptionCode() ));
    }
    _csDomainNameChangeNotify.Leave();
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::DoWork
//
//  This is an override of the PWorkItem base class.  This method is called
//  on a thread pool thread, and is queued when the service needs to stop.
//
//+----------------------------------------------------------------------------


void
CTrkWksSvc::DoWork()
{
    ServiceStopCallback( this, FALSE );
}


//+----------------------------------------------------------------------------
//
//  CTestSync::Initialize
//
//  Open the test sync semaphores.
//
//+----------------------------------------------------------------------------

#if DBG

void
CTestSync::Initialize(const TCHAR * ptszBaseName)
{
    TCHAR tsz[MAX_PATH];
    TCHAR * ptszSuffix;

    _tcscpy(tsz, ptszBaseName);
    ptszSuffix = _tcschr(tsz, 0);

    _tcscat(ptszSuffix, TEXT("Reached"));
    _hSemReached = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, tsz);

    _tcscat(ptszSuffix, TEXT("Wait"));
    _hSemWait    = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, tsz);

    _tcscat(ptszSuffix, TEXT("Flag"));
    _hSemFlag    = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, tsz);

    if (_hSemFlag != NULL && _hSemWait != NULL && _hSemReached != NULL)
    {
        Beep(2000,500);
        Sleep(500);
        Beep(2000,500);
    }
}

#endif // #if DBG

//+----------------------------------------------------------------------------
//
//  CTestSync::UnInitialize
//
//  Close down the semaphores.
//
//+----------------------------------------------------------------------------

#if DBG

void
CTestSync::UnInitialize()
{
    if (_hSemFlag != NULL)
    {
        CloseHandle(_hSemFlag);
        _hSemFlag = NULL;
    }
    if (_hSemWait != NULL)
    {
        CloseHandle(_hSemWait);
        _hSemWait = NULL;
    }
    if (_hSemReached != NULL)
    {
        CloseHandle(_hSemReached);
        _hSemReached = NULL;
    }
}

#endif // #if DBG

//+----------------------------------------------------------------------------
//
//  CTestSync::ReleaseAndWait
//
//  Wait for "Flag", release "Reached", then wait for "Wait".
//
//+----------------------------------------------------------------------------

#if DBG
void
CTestSync::ReleaseAndWait()
{
    if (_hSemFlag != NULL && _hSemWait != NULL && _hSemReached != NULL)
    {
        TrkLog(( TRKDBG_WARNING, TEXT("About to wait for test sync") ));
        DWORD dw;
        if ((dw = WaitForSingleObject(_hSemFlag, 0)) == WAIT_OBJECT_0)
        {
            TrkVerify(ReleaseSemaphore(_hSemReached, 1, NULL));
            TrkVerify(WAIT_OBJECT_0 == WaitForSingleObject(_hSemWait, INFINITE));
        }
        else
        {
            TrkVerify(dw == WAIT_TIMEOUT);
        }
    }
}
#endif // #if DBG



//+----------------------------------------------------------------------------
//
//  CTrkWksRpcServer::Initialize
//
//  Register the interface with RPC.
//+----------------------------------------------------------------------------

void
CTrkWksRpcServer::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData, CTrkWksConfiguration *pTrkWksConfig )
{
    RPC_STATUS          rpcstatus;
    NET_API_STATUS      netstatus;

    // Register the ncacn_np protocol sequence with RPC (used when we're 
    // called by another trkwks) as well as ncalrpc (used when we're called
    // by CTracker::Search in shell32).

    rpcstatus = RpcServerUseProtseqEp( const_cast<TCHAR*>(s_tszTrkWksRemoteRpcProtocol),  // ncacn_np
                                       pTrkWksConfig->GetWksMaxRpcCalls(),
                                       const_cast<TCHAR*>(s_tszTrkWksRemoteRpcEndPoint),
                                       NULL );
    if( RPC_S_OK != rpcstatus && RPC_S_DUPLICATE_ENDPOINT != rpcstatus )
    {
        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                HRESULT_FROM_WIN32(rpcstatus), s_tszTrkWksRemoteRpcProtocol );
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't register %s/%s(%lu)"),
                 s_tszTrkWksRemoteRpcProtocol,
                 s_tszTrkWksRemoteRpcEndPoint,
                 rpcstatus ));
        TrkRaiseWin32Error( rpcstatus );
    }
    TrkLog(( TRKDBG_RPC, TEXT("UseProtseqEp on %s, %s"),
             s_tszTrkWksRemoteRpcProtocol,
             s_tszTrkWksRemoteRpcEndPoint ));

    rpcstatus = RpcServerUseProtseqEp( const_cast<TCHAR*>(s_tszTrkWksLocalRpcProtocol), // ncalrpc
                                       pTrkWksConfig->GetWksMaxRpcCalls(),
                                       const_cast<TCHAR*>(s_tszTrkWksLocalRpcEndPoint),
                                       NULL );
    if( RPC_S_OK != rpcstatus && RPC_S_DUPLICATE_ENDPOINT != rpcstatus )
    {
        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                HRESULT_FROM_WIN32(rpcstatus), s_tszTrkWksLocalRpcProtocol );
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't register %s/%s (%lu)"),
                 s_tszTrkWksLocalRpcProtocol,
                 s_tszTrkWksLocalRpcEndPoint,
                 rpcstatus ));
        TrkRaiseWin32Error( rpcstatus );
    }
    TrkLog(( TRKDBG_RPC, TEXT("UseProtseqEp on %s, %s"),
             s_tszTrkWksLocalRpcProtocol,
             s_tszTrkWksLocalRpcEndPoint ));

    // If we don't have a pSvcsGlobalData (we're not running in services.exe),
    // tell RpcServerRegisterIfEx to automatically set up a listen thread
    // (by specifying RPC_IF_AUTOLISTEN).  Also, since we use static endpoints,
    // we don't need to register with the endpoint mapper.

    CRpcServer::Initialize( Stubtrkwks_v1_2_s_ifspec,
                            NULL == pSvcsGlobalData ? RPC_IF_AUTOLISTEN : 0,
                            pTrkWksConfig->GetWksMaxRpcCalls(),
                            FALSE,  // fSetAuthInfo
                            NULL ); // Don't register with the endpoint mapper

    TrkLog(( TRKDBG_RPC, TEXT("Registered TrkWks RPC server (%d)"), pTrkWksConfig->GetWksMaxRpcCalls() ));
}

//+----------------------------------------------------------------------------
//  
//  CTrkWksRpcServer::UnInitialize
//
//  Unregister the server interface.
//
//+----------------------------------------------------------------------------

void
CTrkWksRpcServer::UnInitialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{
    TrkLog(( TRKDBG_RPC, TEXT("Unregistering TrkWks RPC server") ));
    CRpcServer::UnInitialize( );
    TrkLog(( TRKDBG_RPC, TEXT("Unregistered TrkWks RPC server") ));
}

//+----------------------------------------------------------------------------
//
//  CMountManager::Initialize
//
//  Not currently implemented
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::Initialize(CTrkWksSvc * pTrkWksSvc, CVolumeManager *pVolMgr )
{
    LONG lErr;
    UNICODE_STRING ustrMountManagerDriverName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status = STATUS_SUCCESS;

    _pTrkWksSvc = pTrkWksSvc;
    _pVolMgr = pVolMgr;
    _hMountManager = NULL;
    _hRegisterWaitForSingleObjectEx = NULL;


    _hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if( NULL == _hCompletionEvent )
        TrkRaiseLastError();

    _info.EpicNumber = 0;

    // Open the MountManager device driver

    RtlInitUnicodeString( &ustrMountManagerDriverName, MOUNTMGR_DEVICE_NAME );
    InitializeObjectAttributes( &ObjectAttributes,
                                &ustrMountManagerDriverName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                            );

    status = NtCreateFile( &_hMountManager,
                           FILE_READ_ATTRIBUTES|FILE_READ_DATA|SYNCHRONIZE,
                           &ObjectAttributes,
                           &IoStatusBlock, NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_OPEN_IF,
                           FILE_CREATE_TREE_CONNECTION,
                           NULL,
                           0 );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the mount manager") ));
        TrkRaiseNtStatus(status);
    }

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hCompletionEvent, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTEDEFAULT );
    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CDomainNameChangeNotify (%lu)"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

    AsyncListen();

}
#endif // #if 0


//+----------------------------------------------------------------------------
//
//  CMountManager::UnInitialize
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::UnInitialize()
{
    if( NULL != _hRegisterWaitForSingleObjectEx )
    {
        if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CMountManager (%lu)"),
                     GetLastError() ));
        }
        _hRegisterWaitForSingleObjectEx = NULL;

    }
    if( NULL != _hCompletionEvent )
    {
        CloseHandle( _hCompletionEvent );
        _hCompletionEvent = NULL;
    }

    if( NULL != _hMountManager )
    {
        NtClose( _hMountManager );
        _hMountManager = NULL;
    }
}
#endif // #if 0


//+----------------------------------------------------------------------------
//
//  CMountManager::DoWork
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::DoWork()
{
    Raise If Stopped

    TrkLog((TRKDBG_WKS, TEXT("CMountManager received a notification (Epic=%d)"), _info.EpicNumber ));

    __try
    {
        // Update drive letters if they've changed, pick up any new volumes,
        // and delete the CVolume objects for volumes that have gone away.

        //_pVolMgr->RefreshVolumes();

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception in CMountManager::DoWork (%08x)"), GetExceptionCode() ));
    }

    AsyncListen();
}
#endif // #if 0



//+----------------------------------------------------------------------------
//
//  CMountManager::AsyncListen
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::AsyncListen(  )
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    MOUNTMGR_CHANGE_NOTIFY_INFO infoIn = _info;

    for( int i = 0; i < 2; i++ )
    {
        TrkAssert( 0 == i || 0 != infoIn.EpicNumber );

        status = NtDeviceIoControlFile(
                    _hMountManager,
                    _hCompletionEvent,          // Event
                    NULL,                       // ApcRoutine
                    NULL,                       // ApcContext
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_CHANGE_NOTIFY,
                    &infoIn,                    // InputBuffer
                    sizeof(infoIn),             // InputBufferLength
                    &_info,                     // OutputBuffer
                    sizeof(_info)               // OutputBufferLength
                    );


        if( STATUS_SUCCESS == status )
        {
            // The MountManager is at a newer EpicNumber than we are.  This means that
            // changes have occurred for which we didn't receive a notification
            // (i.e., we were processing one notification when another was sent).
            // This is always the case, though, during service initialization.

            if( 0 == infoIn.EpicNumber )
            {
                // We must be in service initialization.  Just resend the ioctl
                // with the latest EpicNumber.

                infoIn = _info;
                TrkAssert( 0 != _info.EpicNumber );
            }
            else
            {
                // Fire the event as if it came from an ioctl completion
                if( !SetEvent( _hCompletionEvent ))
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't fire mount manager completion event") ));
                    TrkRaiseLastError();
                }

                break; // for
            }
        }

        // Ordinarily, we'll get status_pending

        else if( STATUS_PENDING )
            break;
        else
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't send mount manager notify ioctl") ));
            TrkRaiseNtStatus(status);
        }

    }   // for( int i = 0; i < 2; i++ )


    return;

}
#endif



/*
HRESULT
GetTCharsFromPipe( TCHAR_PIPE *ppipe, TCHAR *ptsz, ULONG *pcb )
{
    return( E_FAIL );

#if 0

    ULONG cbActual = 0;
    TCHAR tszVerify[ 1 ];

    ppipe->pull( ppipe->state, ptsz, *pcb, &cbActual );
    *pcb = cbActual;

    if( 0 == cbActual )
        return( HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME) );

    ppipe->pull( ppipe->state, tszVerify, sizeof(tszVerify), &cbActual );
    if( 0 != cbActual )
        return( HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) );

    return( S_O );

#endif // #if 0
}
*/


//+----------------------------------------------------------------------------
//
//  CDomainNameChangeNotify::Initialize
//
//  Call NetRegisterDomainNameChangeNotification, and then register that
//  handle with the NTDLL thread pool.
//
//+----------------------------------------------------------------------------

void
CDomainNameChangeNotify::Initialize()
{
    NET_API_STATUS NetStatus;

    _fInitialized = TRUE;
    _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;

    __try
    {
        // Register for domain name change notification

        NetStatus = NetRegisterDomainNameChangeNotification(&_hDomainNameChangeNotification);
        if(NetStatus != NO_ERROR)
        {
            _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, NetStatus, TRKREPORT_LAST_PARAM );
            TrkLog((TRKDBG_ERROR, TEXT("Can't register domain name change notification, %08x"), NetStatus));
            TrkRaiseWin32Error( NetStatus );
        }
        else
        {
            // Register the change handle with the thread pool.

            TrkLog((TRKDBG_LOG, TEXT("NetRegisterDomainNameChangeNotification succeeded")));
            TrkAssert(_hDomainNameChangeNotification != INVALID_HANDLE_VALUE);


            _hRegisterWaitForSingleObjectEx
                = TrkRegisterWaitForSingleObjectEx( _hDomainNameChangeNotification, ThreadPoolCallbackFunction,
                                                    static_cast<PWorkItem*>(this), INFINITE,
                                                    WT_EXECUTEDEFAULT );
            if( NULL == _hRegisterWaitForSingleObjectEx )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CDomainNameChangeNotify (%lu)"),
                         GetLastError() ));
                TrkRaiseLastError();
            }
        }
    }
    __except(BreakOnDebuggableException())
    {
        if(_hDomainNameChangeNotification != INVALID_HANDLE_VALUE)
        {
            NetUnregisterDomainNameChangeNotification(_hDomainNameChangeNotification);
            _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;
        }
        _fInitialized = FALSE;
    }
}



//+----------------------------------------------------------------------------
//
//  CDomainNameChangeNotify::UnInitialize
//
//  Unregister with the thread pool, then unregister the change notify.
//
//+----------------------------------------------------------------------------

void
CDomainNameChangeNotify::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CDomainNameChangeNotify (%lu)"),
                         GetLastError() ));
            }
            else
                TrkLog(( TRKDBG_WKS, TEXT("Unregistered wait for CDomainNameChangeNotify") ));

            _hRegisterWaitForSingleObjectEx = NULL;

        }

        if( INVALID_HANDLE_VALUE != _hDomainNameChangeNotification )
            NetUnregisterDomainNameChangeNotification(_hDomainNameChangeNotification);

        _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;
        _fInitialized = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CDomainNameChangeNotify::DoWork
//  
//  This is called when we move into a new domain.  Just calls CTrkWksSvc
//  to do the work.
//
//+----------------------------------------------------------------------------

void
CDomainNameChangeNotify::DoWork()
{
    g_ptrkwks->OnDomainNameChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\wksconfig.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  wksconfig.cxx
//
//  This file implements the CTrkWksConfiguration class, which maintains
//  run-time configuration parameters for the trkwks service.
//
//+============================================================================

#include "pch.cxx"
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::_Parameters
//
//  This array holds all the configurable parameters for the trkwks service.
//  It holds the registry value name, the default value, etc.  Static
//  configuration values may only 
//
//+----------------------------------------------------------------------------

STrkConfigRecord CTrkWksConfiguration::_Parameters[] =
{ 
    TRKCONFIGRECORD( TEXT("Refresh"),                  ( 30 * TRKDAY ),    0, TRKCONFIG_STATIC, REFRESH_PERIOD_CONFIG ),
    TRKCONFIGRECORD( TEXT("RefreshHesitation"),        ( 6 * TRKHOUR ),    0, TRKCONFIG_STATIC, REFRESH_HESITATION_CONFIG ),
    TRKCONFIGRECORD( TEXT("RefreshRetryMin"),          ( 1 * TRKHOUR ),    0, TRKCONFIG_STATIC, REFRESH_RETRY_MIN_CONFIG ),
    TRKCONFIGRECORD( TEXT("RefreshRetryMax"),          ( 1 * TRKDAY ),     0, TRKCONFIG_STATIC, REFRESH_RETRY_MAX_CONFIG ),

    TRKCONFIGRECORD( TEXT("PortThreadKeepAliveTime"),  30,                 0, TRKCONFIG_STATIC, PORT_THREAD_KEEP_ALIVE_TIME_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxReferrals"),             100,                0, TRKCONFIG_STATIC, MAX_REFERRALS_CONFIG ),
    TRKCONFIGRECORD( TEXT("PortNotifyError"),          0,                  0, TRKCONFIG_STATIC, PORT_NOTIFY_ERROR_CONFIG ),

    TRKCONFIGRECORD( TEXT("MinLogKB"),                 20,                 0, TRKCONFIG_STATIC, MIN_LOG_KB_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxLogKB"),                 1000,               0, TRKCONFIG_STATIC, MAX_LOG_KB_CONFIG ),
    TRKCONFIGRECORD( TEXT("LogDeltaKB"),               10,                 0, TRKCONFIG_STATIC, LOG_DELTA_KB_CONFIG ),
    TRKCONFIGRECORD( TEXT("LogOverwriteAge"),          ( 30 * TRKDAY ),    0, TRKCONFIG_STATIC, LOG_OVERWRITE_AGE_CONFIG ),
    TRKCONFIGRECORD( TEXT("LogFileOpenTime"),          10 /*seconds*/,     0, TRKCONFIG_STATIC, LOG_FILE_OPEN_TIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("VolFrequentTasksPeriod"),   TRKDAY,             0, TRKCONFIG_STATIC, VOL_FREQUENT_TASKS_PERIOD_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInfrequentTasksPeriod"), TRKWEEK,            0, TRKCONFIG_STATIC, VOL_INFREQUENT_TASKS_PERIOD_CONFIG ),

    TRKCONFIGRECORD( TEXT("VolInitInitialDelay"),      TRKMINUTE,          0, TRKCONFIG_STATIC, VOL_INIT_INITIAL_DELAY_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInitRetryDelay1"),       (30*TRKMINUTE),     0, TRKCONFIG_STATIC, VOL_INIT_RETRY_DELAY1_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInitRetryDelay2"),       (2*TRKHOUR),        0, TRKCONFIG_STATIC, VOL_INIT_RETRY_DELAY2_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInitLifetime"),          (6*TRKHOUR),        0, TRKCONFIG_STATIC, VOL_INIT_LIFETIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("VolNotOwnedExpireLimit"),   TRKWEEK,            0, TRKCONFIG_STATIC, VOL_NOT_OWNED_EXPIRE_LIMIT_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolPeriodicTasksHesitation"), 2*TRKHOUR,        0, TRKCONFIG_STATIC, VOL_PERIODIC_TASKS_HESITATION_CONFIG ),

    TRKCONFIGRECORD( TEXT("MoveNotifyTimeout"),        30,                 0, TRKCONFIG_STATIC, MOVE_NOTIFY_TIMEOUT_CONFIG ),

    TRKCONFIGRECORD( TEXT("MinMoveNotifyRetry"),       30,                 0, TRKCONFIG_STATIC, MIN_MOVE_NOTIFY_RETRY_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxMoveNotifyRetry"),       ( 4 * TRKHOUR ),    0, TRKCONFIG_STATIC, MAX_MOVE_NOTIFY_RETRY_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxMoveNotifyLifetime"),    TRKDAY,             0, TRKCONFIG_STATIC, MAX_MOVE_NOTIFY_LIFETIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("ObjIdIndexReopen"),         TRKMINUTE,          0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_CONFIG ),
    TRKCONFIGRECORD( TEXT("ObjIdIndexReopenRetryMax"), TRKMINUTE,          0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_RETRY_MAX_CONFIG ),
    TRKCONFIGRECORD( TEXT("ObjIdIndexReopenRetryMin"), TRKMINUTE,          0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_RETRY_MIN_CONFIG ),
    TRKCONFIGRECORD( TEXT("ObjIdIndexReopenLifetime"), ( 20 * TRKMINUTE ), 0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_LIFETIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("IgnoreMovesAndDeletes"),    0,                  0, TRKCONFIG_DYNAMIC,IGNORE_MOVES_AND_DELETES_CONFIG ),

    TRKCONFIGRECORD( TEXT("BreakOnErrors"),            0,                  0, TRKCONFIG_STATIC, BREAK_ON_ERRORS_CONFIG ), // Treated as a bool
    TRKCONFIGRECORD( TEXT("DeleteNotifyTimeout"),      ( 5 * TRKMINUTE ),  0, TRKCONFIG_STATIC, DELETE_NOTIFY_TIMEOUT_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxTunnelDelay"),           3,                  0, TRKCONFIG_STATIC, MAX_TUNNEL_DELAY_CONFIG ), // Seconds
    TRKCONFIGRECORD( TEXT("MaxSendsPerMoveNotify"),    26,                 0, TRKCONFIG_STATIC, MAX_SENDS_PER_MOVE_NOTIFY_CONFIG ),
    TRKCONFIGRECORD( TEXT("WksMaxRpcCalls"),           20,                 0, TRKCONFIG_STATIC, WKS_MAX_RPC_CALLS_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolCacheTimeToLive"),       ( 5 * TRKMINUTE ),  0, TRKCONFIG_DYNAMIC,VOLCACHE_TIME_TO_LIVE_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxDeleteNotifyQueue"),     5000,               0, TRKCONFIG_STATIC, MAX_DELETE_NOTIFY_QUEUE_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxDeleteNotifyAttempts"),  100,                0, TRKCONFIG_STATIC, MAX_DELETE_NOTIFY_ATTEMPTS_CONFIG )


};


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::SetParameter
//
//  Set a DWORD parameter in the _Parameters array, but don't update
//  the registry value.
//
//+----------------------------------------------------------------------------

BOOL
CTrkWksConfiguration::SetParameter( DWORD dwParameter, DWORD dwValue )
{
    if( dwParameter >= ELEMENTS( _Parameters ))
        return( FALSE );

    _Parameters[ dwParameter ].dwValue = dwValue;
    return( TRUE );
}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::PersistParameter
//
//  Set a DWORD parameter value in the registry, but don't update it
//  in the _Parameters array.
//
//+----------------------------------------------------------------------------

BOOL
CTrkWksConfiguration::PersistParameter( DWORD dwParameter, DWORD dwValue )
{
    if( dwParameter >= _cParameters )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Attempt to set invalid parameter (%d/%d)"),
                 dwParameter, _cParameters ));
        return( FALSE );
    }

    return( Write( _Parameters[dwParameter].ptszName, dwValue ));

}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::ProcessInvalidParameter
//
//  Common code for handling an attempt to set/get a parameter that does
//  not exist.
//
//+----------------------------------------------------------------------------

void
CTrkWksConfiguration::ProcessInvalidParameter( DWORD dwParameter ) const
{
    // This is a non-inline routine so that we can use TrkLog & TrkRaise
    TrkLog(( TRKDBG_WARNING, TEXT("Invalid parameter request (%d)"), dwParameter ));
    TrkRaiseException( E_FAIL );

}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::Initialize
//
//  Initialize this trkwks configuration class by initializing the base
//  CTrkConfiguration class and reading in all the parameters.  If
//  fPersistable is set, we'll keep the registry key open so that
//  we can later do writes.
//
//+----------------------------------------------------------------------------

void
CTrkWksConfiguration::Initialize( BOOL fPersistable )
{
    ULONG cb;

    _fInitialized = TRUE;
    _cParameters = sizeof(_Parameters)/sizeof(_Parameters[0]);

    CTrkConfiguration::Initialize( );

    for( int i = 0; i <= MAX_TRKWKS_CONFIG; i++ )
    {
        Read( _Parameters[i].ptszName, &_Parameters[i].dwValue, _Parameters[i].dwDefault );
        TrkAssert( _Parameters[i].Index == i );
    }
    TrkAssert( MAX_TRKWKS_CONFIG + 1 == ELEMENTS(_Parameters) );

    if( !fPersistable )
        // Allow the base class to close it's registry key.
        CTrkWksConfiguration::UnInitialize();

}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::UnInitialize
//
//  Uninit the base CTrkConfiguration class.
//
//+----------------------------------------------------------------------------

VOID
CTrkWksConfiguration::UnInitialize()
{
    if( _fInitialized )
    {
        CTrkConfiguration::UnInitialize();
        _fInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\tlog.cxx ===
//
// The following tests need to be added:
//
//  -   Run the bad-shutdown test on an empty log (forcing a special path
//      in CalcLogInfo).
//



#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"



BOOL g_fNotified = FALSE;
extern ULONG g_Debug;
BOOL g_fTLogDebug = FALSE;
CTrkWksConfiguration g_cTrkWksConfiguration;
CWorkManager g_WorkManager;
CTestLog g_cTestLog( &g_cTrkWksConfiguration, &g_WorkManager );

inline void TestRaise( HRESULT hr, TCHAR *ptszMessage, va_list Arguments )
{
    CHAR szHR[8];

    sprintf( szHR, "%#08X", hr );

    if( NULL != ptszMessage )
        TrkLogErrorRoutineInternal( TRKDBG_ERROR, szHR, ptszMessage, Arguments );

    RaiseException( hr, 0, 0, NULL );
}

inline void TestRaiseException( HRESULT hr, TCHAR *ptszMessage = NULL, ... )
{
    va_list Arguments;
    va_start( Arguments, ptszMessage );

    TestRaise( hr, ptszMessage, Arguments );
}

class CTestLogCallback : public PLogCallback
{
    void OnEntriesAvailable();
};

void
CTestLogCallback::OnEntriesAvailable()
{
    g_fNotified = TRUE;
}



CTestLog::CTestLog( CTrkWksConfiguration *pTrkWksConfiguration, CWorkManager *pWorkManager )
{

    _pTrkWksConfiguration = pTrkWksConfiguration;
    _pWorkManager = pWorkManager;
    *_tszLogFile = TEXT('\0');

}   // CTestLog::CTestLog


void
CTestLog::ReInitialize()
{
    _cLogFile.UnInitialize();
    DeleteFile( _tszLogFile );
    _cLogFile.Initialize( _tszLogFile, _pTrkWksConfiguration, &_cSimpleTimer );
    _cLog.Initialize( NULL, _pTrkWksConfiguration, &_cLogFile );
}

void
CTestLog::GenerateLogName()
{
    DWORD dw;
    TCHAR tszRootPath[ MAX_PATH + 1 ];
    DWORD cSectorsPerCluster, cNumberOfFreeClusters, cTotalNumberOfClusters;

    if( TEXT('\0') != *_tszLogFile )
        return;

    // Generate a log file name

    if( !GetCurrentDirectory( sizeof(_tszLogFile), _tszLogFile ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get the current directory") ));
        TrkRaiseLastError( );
    }

    if( TEXT('\\') != _tszLogFile[ _tcslen(_tszLogFile) ] )
        _tcscat( _tszLogFile, TEXT("\\") );
    _tcscat( _tszLogFile, TEXT("TLog.log") );

    // Calculate the sector size

    TrkAssert( TEXT(':') == _tszLogFile[1] );

    _tcsncpy( tszRootPath, _tszLogFile, sizeof("a:\\") - 1 );
    tszRootPath[ sizeof("a:\\") - 1 ] = TEXT('\0');

    if( !GetDiskFreeSpace( tszRootPath,
                           &cSectorsPerCluster, &_cbSector,
                           &cNumberOfFreeClusters, &cTotalNumberOfClusters ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get bytes-per-sector value on %s"), tszRootPath ));
        TrkRaiseLastError( );
    }

}   // CTestLog::GenerateLogName()


const TCHAR*
CTestLog::LogFileName()
{
    return( _tszLogFile );
}

ULONG
CTestLog::DataSectorOffset() const
{
    return( _cLogFile._header.NumSectors() * CBSector() );
}

void
CTestLog::CreateLog( PLogCallback *pLogCallback, BOOL fValidate )
{
    TCHAR tszLogFile[ MAX_PATH + 1 ];

    GenerateLogName();
    DeleteFile( _tszLogFile );

    _pWorkManager->Initialize();
    _cSimpleTimer.Initialize( this, _pWorkManager, 0, 0, NULL );
    _cLogFile.Initialize( _tszLogFile, _pTrkWksConfiguration, &_cSimpleTimer );
    _cLog.Initialize( pLogCallback, _pTrkWksConfiguration, &_cLogFile );
    StartTestWorkerThread(_pWorkManager);

    if( fValidate )
        ValidateLog();

}   // CTestLog::CreateLog()



void
CTestLog::Timer( DWORD dwTimerId )
{
    _cLog.Flush( FLUSH_TO_CACHE );
    _cLogFile.SetShutdown( TRUE );
    _cLogFile.Flush( FLUSH_THROUGH_CACHE );
    _cLogFile.OnLogCloseTimer();
}


void
CTestLog::OpenLog( PLogCallback *pLogCallback, BOOL fValidate )
{
    GenerateLogName();

    _pWorkManager->Initialize();
    _cSimpleTimer.Initialize( this, _pWorkManager, 0, 0, NULL );
    _cLogFile.Initialize( _tszLogFile, _pTrkWksConfiguration, &_cSimpleTimer );
    _cLog.Initialize( pLogCallback, _pTrkWksConfiguration, &_cLogFile );
    StartTestWorkerThread(_pWorkManager);

    if( fValidate )
        ValidateLog();

}   // CTestLog::CreateLog()



void
CTestLog::CloseLog()
{
    _pWorkManager->StopWorkerThread();
    WaitTestThreadExit();

    _cLog.Flush( FLUSH_TO_CACHE );
    _cLogFile.SetShutdown( TRUE );
    _cLogFile.Flush( FLUSH_THROUGH_CACHE );

    _cLogFile.UnInitialize();
    _cSimpleTimer.UnInitialize();
    _pWorkManager->UnInitialize();
}



void
CTestLog::Append( ULONG cMoves, const TRKSVR_MOVE_NOTIFICATION rgNotifications[] )
{
    LogMoveNotification lmn;
    SequenceNumber seqOriginal, seqFinal;

    if( _cLog.IsEmpty() )
        seqOriginal = -1;
    else
    {
        _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogLast, &lmn );
        seqOriginal = lmn.seq;
    }

    g_fNotified = FALSE;

    for( ULONG i = 0; i < cMoves; i++ )
    {
        _cLog.Append( rgNotifications[i].droidCurrent,
                      rgNotifications[i].droidNew,
                      rgNotifications[i].droidBirth );
    }

    _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogLast, &lmn );
    seqFinal = lmn.seq;

    if( seqFinal != (SequenceNumber)(seqOriginal + cMoves) )
        TestRaiseException( E_FAIL, TEXT("Incorrect sequence numbers after Append (%d + %d = %d?)\n"),
                           seqOriginal, cMoves, seqFinal );

    if( !g_fNotified )
        TestRaiseException( E_FAIL, TEXT("Didn't receive a notification during an append\n") );

}   // CTestLog::Append()



ULONG
CTestLog::Read( ULONG cRead, TRKSVR_MOVE_NOTIFICATION rgNotifications[], SequenceNumber *pseqFirst  )
{
    _cLog.Read( rgNotifications, pseqFirst, &cRead );
    return( cRead );

}   // CTestLog::ReadLog()

void
CTestLog::ReadExtendedHeader( ULONG iOffset, void *pv, ULONG cb )
{
    _cLogFile.ReadExtendedHeader( iOffset, pv, cb );
}


void
CTestLog::WriteExtendedHeader( ULONG iOffset, const void *pv, ULONG cb )
{
    _cLogFile.WriteExtendedHeader( iOffset, pv, cb );
}

void
CTestLog::ReadAndValidate( ULONG cToRead, ULONG cExpected,
                           const TRKSVR_MOVE_NOTIFICATION rgNotificationsExpected[],
                           TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[],
                           SequenceNumber seqExpected )
{
    ULONG cLogEntriesRead = 0;
    SequenceNumber seq;

    memset( rgNotificationsRead, 0, sizeof(*rgNotificationsRead) * cExpected );

    cLogEntriesRead = Read( cToRead, rgNotificationsRead, &seq );

    if( cLogEntriesRead != cExpected )
    {
        TestRaiseException( E_FAIL, TEXT("Bad read from log; expected %d entries, got %d\n"),
                           cExpected, cLogEntriesRead );
    }

    if( seq != seqExpected
        &&
        0 != cExpected 
       )
    {
        TestRaiseException( E_FAIL, TEXT("Invalid sequence number from log (got %d, expected %d)\n"),
                           seq, seqExpected );
    }

    if( 0 != cExpected )
    {

        for( ULONG i = 0; i < cExpected; i++ )
            if( memcmp( &rgNotificationsExpected[i], &rgNotificationsRead[i], sizeof(rgNotificationsRead[i]) ))
            {
                TestRaiseException( E_FAIL, TEXT("Log entries read don't match that which was expected\n") );
            }
    }

}   // CTestLog::ReadAndValidate()


SequenceNumber
CTestLog::GetNextSeqNumber( )
{
    return( _cLog.GetNextSeqNumber() );

}   // CTestLog::GetLatestSeqNumber()


BOOL
CTestLog::Search( const CDomainRelativeObjId &droid, TRKSVR_MOVE_NOTIFICATION *pNotification )
{
    pNotification->droidCurrent = droid;

    return(  _cLog.Search( pNotification->droidCurrent,
                           &pNotification->droidNew,
                           &pNotification->droidBirth ) );


}   // CTestLog::Search()


void
CTestLog::Seek( SequenceNumber seq )
{

    SequenceNumber seqOriginal;
    LogIndex ilogOriginal;
    LogMoveNotification lmn;

    ilogOriginal = _cLog._loginfo.ilogRead;
    if( ilogOriginal != _cLog._loginfo.ilogWrite )
    {
        _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );
        seqOriginal = lmn.seq;
    }

    g_fNotified = FALSE;
    _cLog.Seek( seq );

    if( seq != _cLog._loginfo.seqNext )
    {
        _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );

        if( ilogOriginal == _cLog._loginfo.ilogWrite
            ||
            seqOriginal > lmn.seq
          )
        {

            if( !g_fNotified && !_cLog.IsEmpty() )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Didn't receive a notification after a backwards seek") ));
                TrkRaiseException( E_FAIL );
            }
        }
    }
}   // CTestLog::Seek( SequenceNumber ... )


void
CTestLog::Seek( int origin, int iSeek )
{
    SequenceNumber seqOriginal;
    LogMoveNotification lmn;

    _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );

    seqOriginal = _cLog._loginfo.ilogRead == _cLog._loginfo.ilogWrite
                  ? _cLog._loginfo.seqNext
                  : lmn.seq;

    g_fNotified = FALSE;
    _cLog.Seek( origin, iSeek );

    _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );

    if( !_cLog.IsRead()
        &&
        seqOriginal > lmn.seq
      )
    {
        if( !g_fNotified && !_cLog.IsEmpty() )
            TestRaiseException( E_FAIL, TEXT("Didn't receive a notification after a backwards seek") );
    }

}   // CTestLog::Seek( origin ... )






void
CTestLog::ValidateLog()
{
    ULONG cEntries = _cLogFile.NumEntriesInFile();
    LogIndex ilogEntry, i, j;
    ULONG *rgiNext = NULL;
    ULONG *rgiPrev = NULL;

    __try
    {
        rgiNext = (ULONG*) new ULONG[ cEntries ];
        rgiPrev = (ULONG*) new ULONG[ cEntries ];

        for( ilogEntry = 0; ilogEntry < cEntries; ilogEntry++ )
        {
            rgiNext[ ilogEntry ] = _cLogFile._sector.GetLogEntry( ilogEntry )->ilogNext;
            rgiPrev[ ilogEntry ] = _cLogFile._sector.GetLogEntry( ilogEntry )->ilogPrevious;
        }


        for( i = 0; i < cEntries; i++ )
        {
            // Validate that the entry pointed to by i->next, points
            // back to i with its prev pointer.

            if( rgiPrev[ rgiNext[i] ] != i )
                TestRaiseException( E_FAIL, TEXT("Two entries don't point to each other:  %d, %d, %d\n"),
                                   i, rgiNext[i], rgiPrev[ rgiNext[i] ] );

            // Verify that noone else's next/prev pointers point to
            // i's next/prev pointers.

            for( j = i+1; j < cEntries; j++ )
            {
                if( rgiNext[i] == rgiNext[j] )
                    TestRaiseException( E_FAIL, TEXT("Two entries in the log have the same next pointer:  %d and %d (point to %d)\n"),
                                       i, j, rgiNext[i] );

                if( rgiPrev[i] == rgiPrev[j] )
                    TestRaiseException( E_FAIL, TEXT("Two entries in the log have the same prev pointer:  %d and %d (point to %d)\n"),
                                       i, j, rgiPrev[i] );

            }
        }


    }
    __finally
    {
        delete[] rgiNext;
        delete[] rgiPrev;
    }


}   // CTestLog::ValidateLog()


ULONG
CTestLog::GetCbLog()
{
    return( _cLogFile._cbLogFile );
}

void
CTestLog::DelayUntilClose()
{
    _tprintf( TEXT("    Sleeping so that the log auto-closes\n") );
    Sleep( 1500 * _pTrkWksConfiguration->GetLogFileOpenTime() );

    if( _cLogFile.IsOpen() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("After delaying, log file did not close") ));
        TrkRaiseException( E_FAIL );
    }
}


void
CTestLog::MakeEntryOld()
{
    _cLogFile._sector.GetLogEntry( _cLog._loginfo.ilogStart )->move.DateWritten
        -= _pTrkWksConfiguration->_dwLogOverwriteAge + 1;
    _cLogFile.Flush( FLUSH_UNCONDITIONALLY );

}   // CTestLog::MakeStartOld()


ULONG
CTestLog::GetNumEntries()
{
    return( _cLogFile.NumEntriesInFile() );

}   // CTestLog::GetNumEntries()


LogIndex
CTestLog::GetStartIndex()
{
    return( _cLog._loginfo.ilogStart );
}

LogIndex
CTestLog::GetEndIndex()
{
    return( _cLog._loginfo.ilogEnd );
}

LogIndex
CTestLog::GetReadIndex()
{
    return( _cLog._loginfo.ilogRead );
}

void
CTestLog::SetReadIndex( LogIndex ilogRead )
{
    _cLog._loginfo.ilogRead = ilogRead;
    _cLog.RefreshHeader();
    _cLogFile.Flush();
}

BOOL
CTestLog::IsEmpty()
{
    BOOL fReturn;
    fReturn = _cLog.IsEmpty();
    return( fReturn );
}
    

ULONG
CTestLog::NumEntriesInFile( )
{
    ULONG cSectors = _cLogFile._cbLogFile / _cbSector - NUM_HEADER_SECTORS;
    ULONG cEntriesPerSector = (_cbSector-sizeof(LogEntryHeader)) / sizeof(LogEntry);

    return( cSectors * cEntriesPerSector );
}

ULONG
CTestLog::NumEntriesPerSector()
{
    return( ( _cbSector-sizeof(LogEntryHeader) ) / sizeof(LogEntry) );
}

ULONG
CTestLog::NumEntriesPerKB()
{
    return( (1024 / _cbSector) * NumEntriesPerSector() );
}

ULONG
CTestLog::CBSector() const
{
    return( _cbSector );
}



void ReadTest( ULONG cEntries,
               TRKSVR_MOVE_NOTIFICATION rgNotificationsExpected[],
               TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[],
               SequenceNumber seqExpected )
{   
    g_cTestLog.ReadAndValidate( cEntries + 1, cEntries,
                                rgNotificationsExpected, rgNotificationsRead,
                                seqExpected );

    g_cTestLog.ReadAndValidate( cEntries, cEntries,
                                rgNotificationsExpected, rgNotificationsRead,
                                seqExpected );

    if( cEntries > 1 )
    {
        g_cTestLog.ReadAndValidate( cEntries - 1, cEntries - 1,
                                    rgNotificationsExpected, rgNotificationsRead,
                                    seqExpected );


        g_cTestLog.ReadAndValidate( 1, 1,
                                    rgNotificationsExpected, rgNotificationsRead,
                                    seqExpected );
    }
}



void
ExerciseLog( ULONG cEntries, SequenceNumber seqFirst, 
             TRKSVR_MOVE_NOTIFICATION rgNotificationsExpected[],
             TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[] )
{
    SequenceNumber seqExpected = seqFirst;
    SequenceNumber seqRead;
    ULONG cRead;

    ULONG iReadOriginal = g_cTestLog.GetReadIndex();

    ReadTest( cEntries, rgNotificationsExpected, rgNotificationsRead, seqExpected );

    if( 0 != cEntries )
    {
        // Skip forward by one entry

        g_cTestLog.Seek( SEEK_CUR, 1 );
        seqExpected++;

        ReadTest( cEntries-1, &rgNotificationsExpected[1], &rgNotificationsRead[1], seqExpected );

        if( cEntries > 1 )
        {
            // Skip forward by one entry, but using an absolute seek.

            g_cTestLog.Seek( SEEK_SET, 2 );
            seqExpected++;

            ReadTest( cEntries-2, &rgNotificationsExpected[2], &rgNotificationsRead[2], seqExpected );

            // Do a relative seek back in the log.

            g_cTestLog.Seek( SEEK_CUR, -1 );
            seqExpected--;

            ReadTest( cEntries-1, &rgNotificationsExpected[1], &rgNotificationsRead[1], seqExpected );

        }

        // Do a relative seek back to the beginning of the log

        g_cTestLog.Seek( SEEK_CUR, -1000 );
        seqExpected--;

        ReadTest( cEntries, &rgNotificationsExpected[0], &rgNotificationsRead[0], seqExpected );

        // Skip forward by the remaining entries

        g_cTestLog.Seek( SEEK_CUR, cEntries );
        seqExpected += cEntries;

        cRead = g_cTestLog.Read( 1, rgNotificationsRead, &seqRead );
        if( 0 != cRead )
            TestRaiseException( E_FAIL, TEXT("Shouldn't have been able to read an already-read log\n") );

        // Seek to the end (which is where the read index already is), to ensure
        // that nothing happens.

        g_fNotified = FALSE;
        g_cTestLog.Seek( seqFirst + cEntries );

        if( g_fNotified )
            TestRaiseException( E_FAIL, TEXT("A seek-to-current shouldn't have caused a notification") );

        cRead = g_cTestLog.Read( 1, rgNotificationsRead, &seqRead );
        if( 0 != cRead )
            TestRaiseException( E_FAIL, TEXT("Shouldn't have been able to read an already-read log\n") );

        // Over-seek to the end.

        g_fNotified = FALSE;
        g_cTestLog.Seek( SEEK_CUR, 1000 );

        if( g_fNotified )
            TestRaiseException( E_FAIL, TEXT("A seek-to-current shouldn't have caused a notification") );

        cRead = g_cTestLog.Read( 1, rgNotificationsRead, &seqRead );
        if( 0 != cRead )
            TestRaiseException( E_FAIL, TEXT("Shouldn't have been able to read an already-read log\n") );

    }

    // Seek to the start of the log

    g_cTestLog.Seek( seqFirst );
    seqExpected = seqFirst;
    ReadTest( cEntries, rgNotificationsExpected, rgNotificationsRead, seqExpected );

    if( 0 != cEntries )
    {
        // Seek to the end of the log

        seqExpected = seqFirst + (ULONG)(cEntries - 1);
        g_cTestLog.Seek( seqExpected );
        ReadTest( 1, &rgNotificationsExpected[cEntries-1], &rgNotificationsRead[cEntries-1], seqExpected );

        g_cTestLog.Seek( SEEK_CUR, 1 );
    }

    // Search for each of the log entries

    for( ULONG i = 0; i < cEntries; i++ )
    {
        if( !g_cTestLog.Search( rgNotificationsExpected[i].droidCurrent,
                                rgNotificationsRead ))
        {
            TestRaiseException( E_FAIL, TEXT("Search failed to find entry") );
        }

        if( memcmp( &rgNotificationsExpected[i], rgNotificationsRead, sizeof(*rgNotificationsRead) ))
            TestRaiseException( E_FAIL, TEXT("Search failed on entry %d"), i );
    }

    g_cTestLog.SetReadIndex( iReadOriginal );

}   // ExerciseLog()


void
FillAndExerciseLog( ULONG cEntriesOriginal, ULONG cEntriesTotal, SequenceNumber seqFirst,
                    TRKSVR_MOVE_NOTIFICATION rgNotificationsWrite[],
                    TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[] )
{
    // Test the log as-is

    ExerciseLog( cEntriesOriginal, seqFirst, rgNotificationsWrite, rgNotificationsRead );

    // Add an entry to the log and re-test

    g_cTestLog.Append( 1, &rgNotificationsWrite[ cEntriesOriginal ] );
    ExerciseLog( cEntriesOriginal + 1, seqFirst,
                 rgNotificationsWrite, rgNotificationsRead );

    // Test a full log

    g_cTestLog.Append( cEntriesTotal - cEntriesOriginal - 2,
                       &rgNotificationsWrite[ cEntriesOriginal + 1] );
    ExerciseLog( cEntriesTotal - 1, seqFirst,
                 rgNotificationsWrite, rgNotificationsRead );

}


ULONG
LogIndex2SectorIndex( ULONG cbSector, LogIndex ilog )
{
    ULONG cEntriesPerSector = ( cbSector - sizeof(LogEntryHeader) ) / sizeof(LogEntry);
    return( ilog / cEntriesPerSector + NUM_HEADER_SECTORS );
}



void
ReadLogSector( HANDLE hFile, LogIndex ilog, ULONG cbSector, BYTE rgbSector[] )
{
    ULONG iSector = LogIndex2SectorIndex( cbSector, ilog );
    ULONG cb;

    if( 0xFFFFFFFF == SetFilePointer(hFile, iSector * cbSector, NULL, FILE_BEGIN ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek file to %lu (in test)"), iSector*cbSector ));
        TrkRaiseLastError( );
    }

    if( !ReadFile( hFile, rgbSector, cbSector, &cb, NULL )
        ||
        cbSector != cb
      )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
        TrkRaiseLastError( );
    }
}

void
WriteLogSector( HANDLE hFile, LogIndex ilog, ULONG cbSector, BYTE rgbSector[] )
{
    ULONG iSector = LogIndex2SectorIndex( cbSector, ilog );
    ULONG cb;

    if( 0xFFFFFFFF == SetFilePointer(hFile, iSector * cbSector, NULL, FILE_BEGIN ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek file to %lu (in test)"), iSector*cbSector ));
        TrkRaiseLastError( );
    }

    if( !WriteFile( hFile, rgbSector, cbSector, &cb, NULL )
        ||
        cbSector != cb
      )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
        TrkRaiseLastError( );
    }
}


void
CreateNewLog( CTestLogCallback *pcTestLogCallback, ULONG *pcLogEntries, ULONG *piNotifications,
              SequenceNumber *pseqFirst)
{

    _tprintf( TEXT("    Creating a log") );

    g_cTrkWksConfiguration._dwMinLogKB = 1;
    g_cTrkWksConfiguration._dwMaxLogKB = 1;

    g_cTestLog.CreateLog( pcTestLogCallback );

    *pcLogEntries = g_cTestLog.NumEntriesInFile();
    *piNotifications = 0;
    *pseqFirst = 0;

    if( 0 != g_cTestLog.GetNextSeqNumber( ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Next sequence number should be zero after a create") ));
        TrkRaiseException( E_FAIL );
    }

    _tprintf( TEXT(" (%d entries)\n"), *pcLogEntries );

}



EXTERN_C void __cdecl _tmain( int argc, TCHAR *argv[] )
{
    CTestLogCallback cTestLogCallback;

    TRKSVR_MOVE_NOTIFICATION rgNotificationsWritten[ 50 ];
    TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[ 50 ];
    TRKSVR_MOVE_NOTIFICATION tempNotificationWrite, tempNotificationRead;

    __try
    {

        ULONG cLogEntries = 0;
        ULONG i;
        DWORD dw;
        ULONG cRead, cb, cbFile;
        SequenceNumber seqFirst = 0;
        BOOL fAppendFailed;
        HANDLE hFile = INVALID_HANDLE_VALUE;
        BYTE rgbSector[ 2048 ];
        LogHeader *plogheader = NULL;
        LogEntry *plogentry = NULL;
        ULONG iNotifications = 0;

        BYTE rgbExtendedHeaderWrite[ 16 ];
        BYTE rgbExtendedHeaderRead[ 16 ];

        LogIndex ilogStart, ilogEnd;


        //  --------------
        //  Initialization
        //  --------------

        _tprintf( TEXT("\nCLog Unit Test\n") );
        _tprintf( TEXT(  "==============\n\n") );

        if( argc > 1 )
        {
            if( !_tcscmp( TEXT("/D"), argv[1] )
                ||
                !_tcscmp( TEXT("/d"), argv[1] )
                ||
                !_tcscmp( TEXT("-D"), argv[1] )
                ||
                !_tcscmp( TEXT("-d"), argv[1] )
              )
            {
                g_fTLogDebug = TRUE;
            }
        }   // if( argc > 1 )


        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | (g_fTLogDebug ? TRK_DBG_FLAGS_WRITE_TO_STDOUT : 0), "TLog" );

        g_cTrkWksConfiguration.Initialize();

        g_cTrkWksConfiguration._dwMinLogKB = 1;
        g_cTrkWksConfiguration._dwMaxLogKB = 1;
        g_cTrkWksConfiguration._dwLogDeltaKB = 1;
        g_cTrkWksConfiguration._dwLogOverwriteAge = 10;
        g_cTrkWksConfiguration._dwLogFileOpenTime = 10;
        g_cTrkWksConfiguration._dwDebugFlags = (0xFFFFFFFF & ~TRKDBG_WORKMAN);

        g_Debug = g_cTrkWksConfiguration._dwDebugFlags;

        for( i = 0; i < sizeof(rgNotificationsWritten); i++ )
            ((BYTE*) rgNotificationsWritten)[ i ] = (BYTE) i;



        //  -----------
        //  Basic Tests
        //  -----------

        _tprintf( TEXT("Basic exercises\n") );

        CreateNewLog( &cTestLogCallback, &cLogEntries, &iNotifications, &seqFirst );

        // Test the initial log

        FillAndExerciseLog( 0, cLogEntries, seqFirst, rgNotificationsWritten, rgNotificationsRead );

        // Seek to a non-existent entry in the log

        g_cTestLog.Seek( 1 );
        g_cTestLog.Seek( -1 );
        ExerciseLog( cLogEntries-1, 0,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );

        // Cause the log to expand.  Note that in this case, the start/end indices are
        // currently at the start/end of the file.

        _tprintf( TEXT("Cause the log to expand") );

        g_cTrkWksConfiguration._dwLogDeltaKB = 1;
        g_cTrkWksConfiguration._dwMaxLogKB = g_cTrkWksConfiguration._dwMaxLogKB + 1;

        g_cTestLog.Append( 1, &rgNotificationsWritten[ cLogEntries - 1] );

        _tprintf( TEXT(" (%d entries)\n"), g_cTestLog.NumEntriesInFile() );

        g_cTestLog.DelayUntilClose();

        FillAndExerciseLog( cLogEntries,
                            g_cTestLog.NumEntriesInFile(),
                            seqFirst,
                            &rgNotificationsWritten[ iNotifications ],
                            &rgNotificationsRead[ iNotifications ] );
        cLogEntries = g_cTestLog.NumEntriesInFile();

        // Close and re-open the log

        _tprintf( TEXT("Close and re-open the log\n") );

        g_cTestLog.CloseLog();
        g_cTestLog.OpenLog( &cTestLogCallback );

        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );

        // Ensure that we can't add to a full log (where the log can't be expanded,
        // the start entry isn't old enough to throw away, and the start entry
        // hasn't yet been read).

        __try
        {
            fAppendFailed = FALSE;
            TrkLog(( TRKDBG_ERROR, TEXT("TLog Unit Test:  Causing an intentional Append exception") ));
            g_cTestLog.Seek( SEEK_SET, 0 ); // Make the start entry un-read
            g_cTestLog.Append( 1, rgNotificationsWritten );
        }
        __except( BreakOnAccessViolation() )
        {
            if( GetExceptionCode() != STATUS_LOG_FILE_FULL )
                TestRaiseException( GetExceptionCode(), TEXT("Wrong exception raised when attempting to write to a full log") );
            fAppendFailed = TRUE;
        }

        if( !fAppendFailed )
            TestRaiseException( E_FAIL, TEXT("Append to a full log should have failed") );

        // Overwrite an entry in the log that's overwritable since it's been read already.

        _tprintf( TEXT("Try to add to a max log (the start entry's been read)\n") );

        g_cTestLog.Seek( SEEK_SET, 1 );
        g_cTestLog.Append( 1, &rgNotificationsWritten[ cLogEntries - 1 ] );

        seqFirst++;
        iNotifications++;

        ExerciseLog( cLogEntries-1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );
        
        g_cTestLog.ValidateLog();

        // Overwrite an old entry in the log

        _tprintf( TEXT("Try to add to a max log (the start entry's old)\n") );
        g_cTestLog.Seek( SEEK_SET, 0 );
        g_cTestLog.MakeEntryOld();
        g_cTestLog.Append( 1, &rgNotificationsWritten[cLogEntries] );

        seqFirst++;
        iNotifications++;

        ExerciseLog( cLogEntries-1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );

        g_cTestLog.ValidateLog();

        // Grow again (note that this time, the start/end indices are in the middle of
        // the file).  Also, this time, we show that the log can grow to up to the max
        // size, even if it means we can't grow an entire delta.

        _tprintf( TEXT("Cause the log to expand again") );

        g_cTrkWksConfiguration._dwLogDeltaKB = 10;
        g_cTrkWksConfiguration._dwMaxLogKB = g_cTrkWksConfiguration._dwMaxLogKB + 1;

        g_cTestLog.Append( 1, &rgNotificationsWritten[ cLogEntries+1 ] );

        if( g_cTestLog.NumEntriesInFile()
            >
            cLogEntries + g_cTestLog.NumEntriesPerKB()
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Log grew by more than the max allowable") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        _tprintf( TEXT(" (%d entries)\n"), g_cTestLog.NumEntriesInFile() );

        FillAndExerciseLog( cLogEntries, g_cTestLog.NumEntriesInFile(),
                            seqFirst,
                            &rgNotificationsWritten[ iNotifications ],
                            &rgNotificationsRead[ iNotifications ] );
        cLogEntries = g_cTestLog.NumEntriesInFile();

        g_cTestLog.ValidateLog();


        //  --------------
        //  Extended Tests
        //  --------------

        // Test the extended header

        _tprintf( TEXT("Extended header area\n") );

        for( i = 0; i < sizeof(rgbExtendedHeaderWrite); i++ )
            rgbExtendedHeaderWrite[ i ] = (BYTE)i;

        g_cTestLog.WriteExtendedHeader( 32, (void*) rgbExtendedHeaderWrite, sizeof(rgbExtendedHeaderWrite) );
        g_cTestLog.ReadExtendedHeader(  32, (void*) rgbExtendedHeaderRead,  sizeof(rgbExtendedHeaderRead) );

        for( i = 0; i < sizeof(rgbExtendedHeaderWrite); i++ )
            rgbExtendedHeaderWrite[ i ] = (BYTE)(i + 1);

        g_cTestLog.WriteExtendedHeader( 32, (void*) rgbExtendedHeaderWrite, sizeof(rgbExtendedHeaderWrite) );
        g_cTestLog.DelayUntilClose();
        g_cTestLog.ReadExtendedHeader(  32, (void*) rgbExtendedHeaderRead,  sizeof(rgbExtendedHeaderRead) );


        if( memcmp( rgbExtendedHeaderWrite, rgbExtendedHeaderRead, sizeof(rgbExtendedHeaderWrite) ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Extended header information couldn't be written/read") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        // Make the log look abnormally shutdown, then open it.

        _tprintf( TEXT("Make log look abnormally shut down\n") );

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;
        plogheader->fProperShutdown = FALSE;

        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );


        // Make the log look like it crashed during an expansion.

        _tprintf( TEXT("Expansion crash recovery\n") );

        ilogStart = g_cTestLog.GetStartIndex();
        ilogEnd = g_cTestLog.GetEndIndex();

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        cbFile = GetFileSize( hFile, NULL );
        if( 0xffffffff == cbFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get log file size (in test)") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;

        plogheader->fProperShutdown = FALSE;
        plogheader->expand.cbFile = cbFile;
        plogheader->expand.ilogStart = ilogStart;
        plogheader->expand.ilogEnd = ilogEnd;

        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        ReadLogSector( hFile, ilogStart, g_cTestLog.CBSector(), rgbSector );
        plogentry = &( (LogEntry*)rgbSector )[ ilogStart % (g_cTestLog.CBSector()/sizeof(LogEntry)) ];
        plogentry->ilogPrevious = -1;
        WriteLogSector( hFile, ilogStart, g_cTestLog.CBSector(), rgbSector );
        
        ReadLogSector( hFile, ilogEnd, g_cTestLog.CBSector(), rgbSector );
        plogentry = &( (LogEntry*)rgbSector )[ ilogEnd % (g_cTestLog.CBSector()/sizeof(LogEntry)) ];
        plogentry->ilogNext = -1;
        WriteLogSector( hFile, ilogEnd, g_cTestLog.CBSector(), rgbSector );
        

        cbFile += g_cTestLog.CBSector();
        if ( 0xFFFFFFFF == SetFilePointer(hFile, cbFile, NULL, FILE_BEGIN)
             ||
             !SetEndOfFile(hFile) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't reset log file size to %lu (in test)"), cbFile ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );


        // Corrupt the log header, but in a way that is recoverable.

        _tprintf( TEXT("Make log look corrupted (recoverable)\n") );

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;
        plogheader->fProperShutdown = FALSE;

        memset( &reinterpret_cast<BYTE*>(plogheader)[CLOG_LOGINFO_START], 0, CLOG_LOGINFO_LENGTH );


        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        if( g_cTestLog.IsEmpty() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("We got a new log file after what should have been a recoverable corruption") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );
        

        // Make the log look corrupted and un-recoverable in the header

        _tprintf( TEXT("Make log header look corrupted (un-recoverable)\n") );

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;
        plogheader->fProperShutdown = FALSE;
        plogheader->ulSignature = 0;

        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        if( !g_cTestLog.IsEmpty() )
        {
            TrkLog(( TRKDBG_ERROR,TEXT("After opening a corrupt log, we should have a new log file") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        
        // Make the log look corrupted and un-recoverable in the sectors

        _tprintf( TEXT("Make log sectors look corrupted (un-recoverable)\n") );

        g_cTestLog.CloseLog();

        CreateNewLog( &cTestLogCallback, &cLogEntries, &iNotifications, &seqFirst );
        FillAndExerciseLog( 0, cLogEntries, seqFirst, rgNotificationsWritten, rgNotificationsRead );
        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( 0xFFFFFFFF == SetFilePointer( hFile,
                                          g_cTestLog.DataSectorOffset(),
                                          NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile to start of first sector (in test)") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        memset( rgbSector, 0, sizeof(rgbSector) );

        if( 0xFFFFFFFF == SetFilePointer( hFile, 
                                          g_cTestLog.DataSectorOffset(),
                                          NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't re-seek logfile to start of first sector (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;

        BOOL fExceptionRaised = FALSE;
        __try
        {
            TrkLog(( TRKDBG_ERROR, TEXT("About to open a corrupted log (this should raise)") ));

            // The open should succeed
            g_cTestLog.OpenLog( &cTestLogCallback,
                                FALSE // => Don't validate
                              );

            // This should raise
            ExerciseLog( cLogEntries - 1, seqFirst,
                         &rgNotificationsWritten[ iNotifications ],
                         &rgNotificationsRead[ iNotifications ] );

        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fExceptionRaised = TRUE;
            if( GetExceptionCode() != TRK_E_CORRUPT_LOG )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("After corrupting a sector, Open should have raised TRK_E_CORRUPT_LOG") ));
                TrkRaiseException( GetExceptionCode() );
            }
        }

        if( !fExceptionRaised )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("We should have gotten an exception after corrupting log sectors") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        g_cTestLog.ReInitialize();

        if( !g_cTestLog.IsEmpty() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("After opening a corrupt log, we should have a new log file") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        cLogEntries = g_cTestLog.NumEntriesInFile();
        iNotifications = 0;
        seqFirst = 0;

        FillAndExerciseLog( 0, cLogEntries, seqFirst, rgNotificationsWritten, rgNotificationsRead );

        // Test that tunneling works correctly (if there are duplicate entries, we should
        // get the most recent).

        _tprintf( TEXT("Test tunneling\n") );

        tempNotificationWrite = rgNotificationsWritten[0];

        g_cTestLog.Append( 1, &tempNotificationWrite );

        strncpy( (LPSTR) &tempNotificationWrite.droidBirth, "abcdefghijklmnopqrstuvwxyznowiknowmyabcsnexttimewontyousingwithme",
                 sizeof(tempNotificationWrite.droidBirth) );

        g_cTestLog.Append( 1, &tempNotificationWrite );
        g_cTestLog.Search( tempNotificationWrite.droidCurrent, &tempNotificationRead );


        if( memcmp( &tempNotificationWrite, &tempNotificationRead, sizeof(tempNotificationWrite) ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Didn't get the tunneled move notification") ));
            TrkRaiseWin32Error( E_FAIL );
        }



        _tprintf( TEXT("\nTests Passed\n") );

        g_cTestLog.CloseLog();

    }   // __try

    __finally
    {
    }

}   // _tmain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\vol.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  vol.cxx
//
//  This file implements the CVolume class.  This class maintains all activities
//  for a volume, such as the the log, log file, and deletions manager classes.
//
//+============================================================================




#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"
#include <dbt.h>

#define THIS_FILE_NUMBER    VOL_CXX_FILE_NO

//+----------------------------------------------------------------------------
//
//  CVolume::AddRef
//
//+----------------------------------------------------------------------------

ULONG
CVolume::AddRef()
{
    long cNew;
    cNew = InterlockedIncrement( &_lRef );
    //TrkLog(( TRKDBG_VOLUME, TEXT("+++ Vol %c: refs => %d"), VolChar(_iVol), cNew ));
    return( cNew );
}

//+----------------------------------------------------------------------------
//
//  CVolume::Release
//
//+----------------------------------------------------------------------------

ULONG
CVolume::Release()
{
    long cNew;
    cNew = InterlockedDecrement( &_lRef );
    //TrkLog(( TRKDBG_VOLUME, TEXT("--- Vol %c: refs => %d"), VolChar(_iVol), cNew ));
    if( 0 == cNew )
        delete this;

    return( cNew >= 0 ? cNew : 0 );
}

//+----------------------------------------------------------------------------
//
//  CVolume::Initialize
//
//  Initialize CVolume and open a handle to the volume itself, but nothing
//  more (e.g. don't open the log or verify volume IDs).  The remainder of
//  the initialization will occur later the first time ReopenVolumeHandles
//  is called.  This gets that heavy IO work out of the service initialization
//  path.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::Initialize( TCHAR *ptszVolumeName,
                     const CTrkWksConfiguration * pTrkWksConfiguration,
                     CVolumeManager *pVolMgr,
                     PLogCallback * pLogCallback,
                     PObjIdIndexChangedCallback * pObjIdIndexChangedCallback,
                     SERVICE_STATUS_HANDLE ssh
                     #if DBG
                     , CTestSync * pTunnelTest
                     #endif
                     )
{
    HANDLE              hFile = NULL;
    // const CVolumeId     volNULL;
    // CVolumeId           volidVolume;
    NTSTATUS            status;
    BOOL                fSuccess = FALSE;

    _iVol = -1;
    memset( &_volinfo, 0, sizeof(_volinfo) );

    // Save the volume name, without the trailing whack
    // Volume names are in the form \\?\Volume{guid}\ 

    _tcscpy( _tszVolumeDeviceName, ptszVolumeName );
    TrkAssert( TEXT('\\') == _tszVolumeDeviceName[ _tcslen(_tszVolumeDeviceName)-1 ] );
    _tszVolumeDeviceName[ _tcslen(_tszVolumeDeviceName)-1 ] = TEXT('\0');

    // Save the inputs

    _pTrkWksConfiguration = pTrkWksConfiguration;
    _pVolMgr = pVolMgr;
    _pLogCallback = pLogCallback;
    _ssh = ssh;
    _hdnVolumeLock = NULL;
    _fVolumeDismounted = _fVolumeLocked = FALSE;

    IFDBG( _pTunnelTest = pTunnelTest; )

    __try   // __except
    {

        // Create critical sections

        _csVolume.Initialize();
        _csHandles.Initialize();
        _fInitialized = TRUE;


        Lock();

        __try // __finally
        {
            _VolQuotaReached.Initialize();

            // Open the volume (not a directory in the volume, but the volume itself).
            // We'll use this to do relative-opens by object ID

            status = OpenVolume( _tszVolumeDeviceName, &_hVolume );
            if (!NT_SUCCESS(status))
                TrkRaiseNtStatus(status);

            // Initialize, but don't start, the objid index change notifier.  When started,
            // this will watch for adds/deletes/tunnels/etc. in the index.

            _ObjIdIndexChangeNotifier.Initialize( _tszVolumeDeviceName,
                                                  pObjIdIndexChangedCallback,
                                                  this );


            fSuccess = TRUE;
        }
        __finally
        {
            Unlock();
        }

    }
    __except ( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed initializaion of volume %s (%08x)"),
                 ptszVolumeName, GetExceptionCode() ));

        if( TRK_E_VOLUME_NOT_DRIVE != GetExceptionCode() )
        {
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                    GetExceptionCode(), TRKREPORT_LAST_PARAM );
        }
    }

    return fSuccess;
}


//+----------------------------------------------------------------------------
//
//  CVolume::SetLocallyGeneratedVolId
//
//  Generate a volume ID and set it on the volume.  If we're in a domain,
//  this will later get replaced with a volume ID from trksvr.
//
//+----------------------------------------------------------------------------

void
CVolume::SetLocallyGeneratedVolId()
{
    NTSTATUS status = STATUS_SUCCESS;

    // Ensure the volume is writeable
    RaiseIfWriteProtectedVolume();

    _fDirty = TRUE;

    // Create the ID

    // Call _volinfo.volid.UuidCreate()
    RPC_STATUS rpc_status = GenerateVolumeIdInVolInfo();
    if( RPC_S_OK != rpc_status )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create a local volid for new volume") ));
        TrkRaiseWin32Error(rpc_status);
    }

    // Set the ID on the volume.
    status = SetVolIdOnVolume( _volinfo.volid );
    g_ptrkwks->_entropy.Put();

    if( NT_SUCCESS(status) )
        TrkLog(( TRKDBG_VOLUME, TEXT("Locally generated a new volid for %c:, %s"),
                 VolChar(_iVol), (const TCHAR*)CDebugString(_volinfo.volid) ));
    else
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set new volid on %c: (%08x)"), VolChar(_iVol), status ));
        TrkRaiseNtStatus(status);
    }

    // Get rid of the log and existing object IDs since we have a new volid.
    DeleteAndReinitializeLog();
    MarkForMakeAllOidsReborn();

}

//+----------------------------------------------------------------------------
//
//  CVolume::VolumeSanityCheck
//
//  This routine is called when the volume handles are opened,
//  The caller is responsible for calling CLogFile::Initialize and
//  CLog::Initialize.  The caller must ensure that _volinfo is
//  properly loaded prior to the call.
//
//+----------------------------------------------------------------------------


const GUID s_guidInvalidVolId = { /* {d2a2ac27-b89a-11d2-9335-00805ffe11b8} */
                                0xd2a2ac27, 0xb89a, 0x11d2,
                                {0x93, 0x35, 0x00, 0x80, 0x5f, 0xfe, 0x11, 0xb8} };


void
CVolume::VolumeSanityCheck( BOOL fVolIndexSetAlready )
{
    NTSTATUS            status;
    CVolumeId           volidVolume;
    const CVolumeId     volNULL;
    const CMachineId    mcidLocal( MCID_LOCAL );
    TCHAR               tszVolumeName[ CCH_MAX_VOLUME_NAME + 1 ];

    // Get the volume name that the mount manager has associated with this
    // volume.

    LONG iVolOld = _iVol;

    if( !fVolIndexSetAlready )
    {
        _iVol = MapVolumeDeviceNameToIndex( _tszVolumeDeviceName );
        if( -1 == _iVol )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Volume %s does not appear any longer to have a drive letter (was %c:)"),
                     _tszVolumeDeviceName, VolChar( iVolOld ) ));
            MarkSelfForDelete();
            TrkRaiseException( TRK_E_VOLUME_NOT_DRIVE );
        }
        else if( iVolOld != _iVol )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Volume %c: is now %c:"), VolChar(iVolOld), VolChar(_iVol) ));
        }
    }


    // Get the filesystem-maintained volume ID

    TCHAR tszRoot[ MAX_PATH ];
    _tcscpy( tszRoot, _tszVolumeDeviceName );
    _tcscat( tszRoot, TEXT("\\") );
    status = QueryVolumeId(tszRoot, &volidVolume);
    g_ptrkwks->_entropy.Put();

    if( !NT_SUCCESS(status) && STATUS_OBJECT_NAME_NOT_FOUND != status )
    {
        // For some reason we couldn't read the NTFS volid
        // (e.g. it's been dismounted).
        TrkLog(( TRKDBG_VOLUME, TEXT("Couldn't get filesys volid for %c:"), VolChar(_iVol) ));
        TrkRaiseNtStatus(status);
    }

    TrkLog(( TRKDBG_VOLUME, TEXT("VolId (from NTFS) for %c: is %s"),
             VolChar(_iVol), (const TCHAR*)CDebugString(volidVolume) ));


    // Compare the volume IDs from the filesystem (volume) and from
    // the VolInfo structure we keep in the log file.  If one is
    // set but not the other, then we'll adopt the one that's set.
    // If they're both set, but to different values, then we'll
    // take the one from NTFS.

    if( volNULL == volidVolume && volNULL != _volinfo.volid )
    {
        // Assume the volid in the VolInfo structure is correct.
        // This scenario occurs after a volume is formatted while the service
        // is running.  In that case, we have the volume info in memory and think
        // it's not dirty, but in fact the log file is gone.  So, just to be safe,
        // we'll go dirty, and the flush at the end will put the latest state out
        // to the file.

        RaiseIfWriteProtectedVolume();
        _fDirty = TRUE;

        TrkLog(( TRKDBG_ERROR, TEXT("Duping the volid from the logfile to the volume for %c:"),
                 VolChar(_iVol) ));
        status = SetVolIdOnVolume(_volinfo.volid);
        g_ptrkwks->_entropy.Put();
        if(!NT_SUCCESS(status))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set a volume ID on %c:"), VolChar(_iVol) ));
            TrkRaiseNtStatus(status);
        }

        SetState( VOL_STATE_NOTOWNED );

    }
    else if( volidVolume != _volinfo.volid || volNULL == volidVolume)
    {
        // Either the two volids don't match, or they're both NULL.

        if( volNULL != volidVolume && s_guidInvalidVolId != volidVolume )
        {
            // Assume the volid on the volume (NTFS) is correct.

            // If the log has a different volid, it may have invalid move entries.
            // So we delete it.
            if( volNULL != _volinfo.volid )
                DeleteAndReinitializeLog();

            _volinfo.Initialize();

            // Set _volinfo.volid = volidVolume
            SetVolIdInVolInfo( volidVolume );

            _volinfo.machine = mcidLocal;

            SetState( VOL_STATE_NOTOWNED );
        }
        else
        {
            // Both the volume and the _volinfo (the log) are null.  We're going to
            // go into the not-created state, but first put on a volid so that we
            // never have a volume with no ID.

            _volinfo.Initialize();
            _volinfo.machine = mcidLocal;

            // Create a new ID and put it on the volume.

            SetLocallyGeneratedVolId(); // Updates _volinfo.volid

            // Put ourselves in the not-created state.

            TrkAssert( VOL_STATE_OWNED == GetState() );
            SetState( VOL_STATE_NOTCREATED );
        }
    }

    // If the machine ID in the log isn't the current machine, then go into
    // the not-created state so that we'll re-claim the volume.

    if( mcidLocal != _volinfo.machine )
        SetState( VOL_STATE_NOTOWNED );

    // See if this volume duplicates any other on this system.

    CVolume *pvolDuplicate = _pVolMgr->IsDuplicateVolId( this, GetVolumeId() );
    if( NULL != pvolDuplicate )
    {
        // This should never happen; there should never be two
        // volumes on the same machine with the same ID.
        // When this happens on different machines it gets caught during
        // CheckSequenceNumbers, but on the same machine this doesn't work,
        // because TrkSvr accepts the Claim of both machines.

        TrkLog(( TRKDBG_WARNING,
                 TEXT("Volume %c: and %c: have duplicate volume IDs.  Resetting %c:"),
                 VolChar(GetIndex()),
                 VolChar(pvolDuplicate->GetIndex()),
                 VolChar(GetIndex()) ));
        TrkReportEvent( EVENT_TRK_SERVICE_DUPLICATE_VOLIDS, EVENTLOG_ERROR_TYPE,
                        static_cast<const TCHAR*>(CStringize( VolChar(GetIndex()))),
                        static_cast<const TCHAR*>(CStringize( VolChar(pvolDuplicate->GetIndex()) )),
                        TRKREPORT_LAST_PARAM );

        SetLocallyGeneratedVolId(); // Updates _volinfo.volid
        SetState( CVolume::VOL_STATE_NOTCREATED );

        pvolDuplicate->SetState( CVolume::VOL_STATE_NOTOWNED );
        pvolDuplicate->Release();
    }

    // If anything's dirty, flush it now.  In the normal initialization path,
    // this will have no effect.

    Flush();
}


//+----------------------------------------------------------------------------
//
//  CVolume::Refresh
//
//+----------------------------------------------------------------------------

void
CVolume::Refresh()
{
    HANDLE hVolume = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    Lock();
    __try
    {
        status = OpenVolume( _tszVolumeDeviceName, &hVolume );

        if( NT_SUCCESS(status) )
            _iVol = MapVolumeDeviceNameToIndex( _tszVolumeDeviceName );
        else if( !IsErrorDueToLockedVolume(status) )
            _iVol = -1;

        if( -1 == _iVol )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Drive not found in CVolume::Refresh") ));
            MarkSelfForDelete();
        }
    }
    __except( BreakOnDebuggableException() )
    {
    }

    if( NULL != hVolume )
        NtClose( hVolume );

    Unlock();

}   // CVolume::Refresh


//+----------------------------------------------------------------------------
//
//  CVolume::MarkSelfForDelete
//
//  Mark this CVolume to be deleted (not the volume, but the class).  The
//  delete will actually occur when this object is completely released
//  and unlocked.  We do, however, as part of this method remove ourself
//  from the volume manager's list.
//
//+----------------------------------------------------------------------------

void
CVolume::MarkSelfForDelete()
{
    AssertLocked();

    if( !_fDeleteSelfPending )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Marking %c: for delete"), VolChar(_iVol) ));

        // Show that we need to be deleted.  We can't actually delete now, because there
        // may be threads active in the object.

        _fDeleteSelfPending = TRUE;

        // On the final UnLock, Release will be called to counter this AddRef and
        // cause the actual delete.

        AddRef();

        // Take this object out of the Volume Manager's linked list (which will do
        // a Release, thus the need for the above AddRef);

        _pVolMgr->RemoveVolumeFromLinkedList( this );
    }
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("%c: is already marked for delete"), VolChar(_iVol) ));
}


//+----------------------------------------------------------------------------
//
//  CVolume::RegisterPnpVolumeNotification
//
//  Register to receive PNP notifications for this volume.  If already
//  registered, register again (since the volume handle against which 
//  we'd previously registered may no longer exist).
//
//+----------------------------------------------------------------------------


void
CVolume::RegisterPnPVolumeNotification()
{
    DEV_BROADCAST_HANDLE    dbchFilter;
    HDEVNOTIFY              hdnVolumeLock = _hdnVolumeLock;

    dbchFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    dbchFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
    dbchFilter.dbch_handle = _ObjIdIndexChangeNotifier._hDir; // _hVolume;

    __try
    {
        // Register against the oid index handle (as a representative of
        // the volume).
        hdnVolumeLock = RegisterDeviceNotification((HANDLE)_ssh,
                                         &dbchFilter,
                                         DEVICE_NOTIFY_SERVICE_HANDLE);
        if(hdnVolumeLock == NULL)
        {
            TrkLog((TRKDBG_VOLUME, TEXT("Can't register for volume notifications, %08x"), GetLastError()));
            TrkRaiseLastError();
        }

        // Get rid of our old registration, if we had one.

        UnregisterPnPVolumeNotification();

        // Keep the new registration.

        _hdnVolumeLock = hdnVolumeLock;
        TrkLog(( TRKDBG_VOLUME, TEXT("Registered for volume lock/unlock notification on %c: (%p)"),
                 VolChar(_iVol), _hdnVolumeLock ));
    }
    __except(BreakOnDebuggableException())
    {
        TrkLog((TRKDBG_VOLUME, TEXT("Can't register for volume notification, %08x"), GetExceptionCode()));
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::UnregisterPnpVolumeNotification
//
//  Unregister the device notification handle for this volume (if we have
//  one).
//
//+----------------------------------------------------------------------------

void
CVolume::UnregisterPnPVolumeNotification()
{
    if(_hdnVolumeLock)
    {
        if( !UnregisterDeviceNotification(_hdnVolumeLock)) {
            TrkLog(( TRKDBG_ERROR, TEXT("UnregisterDeviceNotification failed: %lu"), GetLastError() ));
        }

        TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered for volume lock/unlock notification on %c: (%p)"),
                 VolChar(_iVol), _hdnVolumeLock ));

        _hdnVolumeLock = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::DeleteAndReinitializeLog
//
//  Delete the volume log and reinitialize it.
//
//+----------------------------------------------------------------------------

void
CVolume::DeleteAndReinitializeLog()
{
    // Delete and reinitialize the log

    __try
    {
        RaiseIfWriteProtectedVolume();

        TrkLog(( TRKDBG_VOLUME, TEXT("DeleteAndReinitializeLog (%s)"),
                 _tszVolumeDeviceName ));

        if( IsHandsOffVolumeMode() )
            // Volume is locked
            TrkRaiseNtStatus( STATUS_ACCESS_DENIED );

        // Delete the log

        _cLogFile.Delete();

        // Reinitialize the log file, then the log itself.

        _cLogFile.Initialize( NULL, NULL, NULL, VolChar(_iVol) );
        _cLog.Initialize( _pLogCallback, _pTrkWksConfiguration, &_cLogFile );
    }
    __except( IsErrorDueToLockedVolume( GetExceptionCode() )
              ? EXCEPTION_EXECUTE_HANDLER
              : EXCEPTION_CONTINUE_SEARCH )
    {
        // If the volume is locked, start the reopen timer and abort.
        CloseVolumeHandles();   // Never raises
        g_ptrkwks->SetReopenVolumeHandlesTimer();
        TrkRaiseException( GetExceptionCode() );
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::DeleteLogAndReInitializeVolume
//
//  Delete and reinit the log, then reinitialize the rest of the volume.
//
//+----------------------------------------------------------------------------

void
CVolume::DeleteLogAndReInitializeVolume()
{
    AssertLocked();

    // There's the remote possibility that the VolumeSanityCheck
    // call below will call this routine.  Just to be paranoid, we
    // add protection against an infinite recursion.

    if( _fDeleteLogAndReInitializeVolume )
        TrkRaiseWin32Error( ERROR_OPEN_FAILED );
    _fDeleteLogAndReInitializeVolume = TRUE;

    __try
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Re-initializing volume %c:"), VolChar(_iVol) ));

        // Re-initialize the CLogFile.
        DeleteAndReinitializeLog();

        // Recreate the volinfo in the new log's header
        _fDirty = TRUE; // Force a flush
        VolumeSanityCheck();
    }
    __finally
    {
        _fDeleteLogAndReInitializeVolume = FALSE;
    }

}


//+----------------------------------------------------------------------------
//
//  CVolume::UnInitialize
//
//  Unregister our PNP handle, free critical sections, etc.
//
//+----------------------------------------------------------------------------

void
CVolume::UnInitialize()
{
    if( _fInitialized )
    {
        IFDBG( _cLocks++; )

        UnregisterPnPVolumeNotification();
        _ssh = NULL;

        if (_hVolume != NULL)
            NtClose(_hVolume);

        __try
        {
            _cLogFile.UnInitialize();
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) // BreakOnDebuggableException() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolume::UnInitialize after _cLogFile.UnInitialize for %c: %08x"),
                     VolChar(_iVol), GetExceptionCode() ));
        }


        _fInitialized = FALSE;
        _csHandles.UnInitialize();
        _csVolume.UnInitialize();

        IFDBG( _cLocks--; )

        TrkAssert( 0 == _cLocks );
    }
    _ObjIdIndexChangeNotifier.UnInitialize();
}


//+----------------------------------------------------------------------------
//
//  CVolume::Flush
//
//  Flush the volinfo structure, the log, and the logfile.  In the process,
//  mark the logfile header to show a proper shutdown.  If we're in the middle
//  of a service shutdown, and there's a problem with the log, don't run
//  the recovery code.
//
//+----------------------------------------------------------------------------

void
CVolume::Flush(BOOL fServiceShutdown)
{
    Lock();
    __try
    {
        if( _fDirty )
            SaveVolInfo();

        __try
        {
            _cLog.Flush( );                 // Flushes to CLogFile
            _cLogFile.SetShutdown( TRUE );  // Causes a flush to disk if necessary
        }
        __except( !fServiceShutdown
                  &&
                  0 == _cHandleLocks
                  &&
                  IsRecoverableDiskError( GetExceptionCode() )
                    ? EXCEPTION_EXECUTE_HANDLER
                    : EXCEPTION_CONTINUE_SEARCH )
        {
            // Note that we don't handle this exception if the _cHandleLocks is non-zero.
            // In this case we're in fast-path and must complete quickly, and the following
            // calls could be too time consuming.  We must complete quickly because 
            // CloseVolumeHandles uses that lock, and that call might be called on the 
            // SCM thread (for e.g. a volume lock event).  The SCM thread is shared by
            // all services in the process, so we must fast-path anything on it.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail
                _cLog.Flush();
                _cLogFile.SetShutdown( TRUE );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                DeleteLogAndReInitializeVolume();
            }
        }
    }
    __finally
    {
        Unlock();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::OpenFile
//
//  Open a file on this volume, given the file's object ID.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::OpenFile( const CObjId           &objid,
                   ACCESS_MASK            AccessMask,
                   ULONG                  ShareAccess,
                   HANDLE                 *ph)
{
    NTSTATUS status;

    Lock();
    __try
    {
        status = OpenFileById( _tszVolumeDeviceName, objid, AccessMask, ShareAccess, 0, ph );

        if( NT_SUCCESS(status) )
            return TRUE;
        else if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            return FALSE;
        else
            TrkRaiseNtStatus( status );
    }
    __finally
    {
        Unlock();
    }

    return( FALSE );

}   // CVolume::OpenFile()



//+----------------------------------------------------------------------------
//
//  CVolume::LoadSyncVolume
//
//  Load the TRKSVR_SYNC_VOLUME message request for this volume, if necessary.
//  The call of this message to trksvr is actually sent by the caller.  On
//  return of that request, UnloadSyncVolume method will be called.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::LoadSyncVolume( TRKSVR_SYNC_VOLUME *pSyncVolume, EAggressiveness eAggressiveness, BOOL* pfSyncNeeded )
{
    CVOL_STATE      state = GetState();
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        if( !_fVolInfoInitialized )
            TrkRaiseException( E_UNEXPECTED );

        memset( pSyncVolume, 0, sizeof(*pSyncVolume) );
        if(pfSyncNeeded)
        {
            *pfSyncNeeded = FALSE;
        }

        // See if it's time to transition from not-owned to not-created.

        if( NotOwnedExpired() )
            SetState( state = VOL_STATE_NOTCREATED );

        // Load the message request, if necessary, based on our current state.

        if(state == VOL_STATE_NOTCREATED)
        {
            // Ordinarily, if we were unable to create this volume due to volume
            // quota, we won't try again.  But if we're told to be aggressive,
            // we'll try anyway.

            if( PASSIVE == eAggressiveness && _VolQuotaReached.IsSet() )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Not attempting to create new volume ID on %c:; quota reached"),
                         VolChar(_iVol) ));
            }
            else
            {
                // Generate a new secret for authentication of this volume.

                g_ptrkwks->_entropy.Put();

                if( !g_ptrkwks->_entropy.InitializeSecret( & _tempSecret ) )
                {
                    // This should never happen - even if there hasn't been enough
                    // entropy yet, more will be generated.
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't generate secret for volume %c:"), VolChar(_iVol) ));
                    goto Exit;
                }

                TrkLog((TRKDBG_VOLUME, TEXT("Generated secret %s for volume %c"),
                        (const TCHAR*)CDebugString(_tempSecret), VolChar( _iVol )));

                // Put the secret in the request, and set the request type to "create"

                pSyncVolume->secret = _tempSecret;
                pSyncVolume->SyncType = CREATE_VOLUME;

                // Show that we put data into the request that should be sent
                // to trksvr.

                if (pfSyncNeeded != NULL)
                    *pfSyncNeeded = TRUE;
            }

        }   // case CREATE_VOLUME

        else if(state == VOL_STATE_NOTOWNED)
        {
            // Attempt to claim this volume.

            pSyncVolume->volume = _volinfo.volid;
            pSyncVolume->secretOld = _volinfo.secret;
            pSyncVolume->SyncType = CLAIM_VOLUME;

            // Generate a new secret.

            if( !g_ptrkwks->_entropy.InitializeSecret( &_tempSecret ) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't generate secret for volume %c:"), VolChar(_iVol) ));
                goto Exit;
            }

            TrkLog((TRKDBG_VOLUME, TEXT("Generated secret %s for volume %c"),
                    (const TCHAR*)CDebugString(_tempSecret), VolChar( _iVol )));
            pSyncVolume->secret = _tempSecret;

            // Show that the request should be sent.

            if (pfSyncNeeded != NULL)
                *pfSyncNeeded = TRUE;

        }   // case CLAIM_VOLUME
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in LoadSyncVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    Unlock();
    return( fSuccess );

}


//+----------------------------------------------------------------------------
//
//  CVolume::OnRestore
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CVolume::OnRestore()
{
    return( E_NOTIMPL );

#if 0
    HRESULT             hr = E_FAIL;
    CVolumeId           volidVolume;
    const CMachineId    mcidLocal( MCID_LOCAL );
    NTSTATUS            status;

    memset( &_volinfo, 0, sizeof(_volinfo) );
    hr = S_OK;

    Lock();
    __try // __finally
    {
        __try
        {

            // Get volume id from two different places: in the log file, and on
            // the volume. If the two
            // disagree, use the object id in the log file, overwrite the other
            // one. Put the volume into NOTOWNED state.

            TrkLog(( TRKDBG_VOLUME,
                     TEXT("Checking for recorded id's on volume %c:"),
                     VolChar(_iVol) ));

            LoadVolInfo();

            TrkLog(( TRKDBG_VOLUME, TEXT("volume id in log file ---- (%s) %c:"),
                     CDebugString(_volinfo.volid)._tsz, VolChar(_iVol) ));

            status = QueryVolumeId(_tszVolumeDeviceName, &volidVolume);
            if(!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND)
            {
                TrkLog((TRKDBG_ERROR, TEXT("Can't get id from volume %c"), VolChar(_iVol)));
                SetState(VOL_STATE_NOTCREATED);
            }
            // if no id is set on the volume, adopt from the log file
            if(volidVolume == CVolumeId() && _volinfo.volid != CVolumeId())
            {
                status = SetVolIdOnVolume(_volinfo.volid);
                g_ptrkwks->_entropy.Put();
                if(!NT_SUCCESS(status))
                {
                    TrkRaiseNtStatus(status);
                }
                SetState( VOL_STATE_NOTOWNED );
            }
            else if(volidVolume != _volinfo.volid)
            // The log file could have been copied or moved before the restore
            // happened, in order to be safe we trash the volume.
            {
                SetState(VOL_STATE_NOTCREATED);
            }

            hr = S_OK;
        }
        __except (BreakOnDebuggableException())
        {
            TrkLog((TRKDBG_ERROR, TEXT("OnRestore failed")));
            hr = GetExceptionCode();
        }

        // If an un-recoverable log error was raised, re-initialize everything

        if( TRK_E_CORRUPT_LOG == hr )
        {
            TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                            NULL );
            __try
            {
                DeleteLogAndReInitializeVolume();
            }
            __except( BreakOnDebuggableException())
            {
                hr = GetExceptionCode();
            }
        }
        else if( IsErrorDueToLockedVolume(hr) )
        {
            CloseAndReopenVolumeHandles();  // Reopen might fail
            TrkRaiseException( hr );
        }
    }
    __finally
    {
        Unlock();
    }

    return hr;

#endif // #if 0

}

//+----------------------------------------------------------------------------
//
//  CVolume::LoadQueryVolume
//
//  Load a TRKSVR_SYNC_VOLUME request for this volume, if necessary.  If we
//  load it, the caller will send it to trksvr.  On return of that request,
//  UnloadQueryVolume method will be called.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::LoadQueryVolume( TRKSVR_SYNC_VOLUME *pQueryVolume )
{
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        // Don't do anything we're not even in trksvr.

        if(GetState() == VOL_STATE_NOTCREATED)
        {
            goto Exit;
        }

        // Put our volid & log sequence number into the request.

        memset( pQueryVolume, 0, sizeof(*pQueryVolume) );

        pQueryVolume->SyncType = QUERY_VOLUME;
        pQueryVolume->volume = _volinfo.volid;
        pQueryVolume->seq = _cLog.GetNextSeqNumber();   // Never raises
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in LoadQueryVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    Unlock();
    return( fSuccess );
}

// Originally, trkwks bundle up volume requests (sync, claim, create) and call the DC. After the
// DC returns, this function is called to put necessary information back on the volume. Now the
// DC callback mechanism is added. When there are create volume requests, the DC will callback and
// this function is called by the DC callback function. The DC needs to know if each create volume
// request is successfully finished by the trkwks, so this function has to put an HRESULT to
// indicate that in the hr field of the TRKSVR_SYNC_VOLUME structure.

//+----------------------------------------------------------------------------
//
//  CVolume::UnloadSyncVolume
//
//  A sync-volume request was loaded in LoadSyncVolume, sent to trksvr, and
//  we now need to interpret the result.  If we successfully completed
//  a create or claim, we'll go into the owned state.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::UnloadSyncVolume( TRKSVR_SYNC_VOLUME *pSyncVolume )
{
    BOOL fSuccess = FALSE;
    BOOL fWrite = FALSE;
    CMachineId mcidLocal( MCID_LOCAL );

    Lock();
    __try
    {
        if( !_fVolInfoInitialized )
            TrkRaiseException( E_UNEXPECTED );

        if(pSyncVolume->hr == S_OK)
        {
            // Clear the bit that indicates we've reported a vol quota event.
            // That way, the next time we get a volume quota error, we'll report
            // to the event log.
            _VolQuotaReached.Clear();

            switch( pSyncVolume->SyncType )
            {
            case CREATE_VOLUME:
                {
                    NTSTATUS status = STATUS_SUCCESS;

                    // Write the volume ID to the volume meta-data.

                    status = SetVolIdOnVolume( pSyncVolume->volume );
                    g_ptrkwks->_entropy.Put();
                    if( !NT_SUCCESS(status) ) 
                        __leave;

                    TrkLog(( TRKDBG_VOLUME, TEXT("Newly-created vol id = %s, %c:"),
                            (const TCHAR*)CDebugString(pSyncVolume->volume),
                            VolChar(_iVol) ));

                    // Create a fresh log
                    DeleteAndReinitializeLog();

                    // Update _volinfo

                    _fDirty = TRUE;
                    _volinfo.cftLastRefresh = pSyncVolume->ftLastRefresh;

                    // Set _volinfo.volid = pSyncVolume->volume

                    SetVolIdInVolInfo( pSyncVolume->volume );

                    _volinfo.machine = mcidLocal;
                    _volinfo.secret = _tempSecret;

                    // And update our state.

                    SetState( VOL_STATE_OWNED );    // Flushes _volinfo
                    TrkAssert( VOL_STATE_OWNED == GetState() );

                    TrkReportEvent( EVENT_TRK_SERVICE_VOLUME_CREATE, EVENTLOG_INFORMATION_TYPE,
                                    static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                    static_cast<const TCHAR*>( CStringize( _volinfo.volid )),
                                    NULL );
                }   // case CREATE_VOLUME

                break;

            case CLAIM_VOLUME:
                {
                    RaiseIfWriteProtectedVolume();
                    _fDirty = TRUE;

                    _volinfo.machine = mcidLocal;
                    _volinfo.cftLastRefresh = pSyncVolume->ftLastRefresh;
                    _volinfo.secret = _tempSecret;

                    SetState( VOL_STATE_OWNED );    // Flushes _volinfo
                    TrkAssert( VOL_STATE_OWNED == GetState() );
                    Seek( pSyncVolume->seq );

                    TrkReportEvent( EVENT_TRK_SERVICE_VOLUME_CLAIM, EVENTLOG_INFORMATION_TYPE,
                                    static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                    static_cast<const TCHAR*>( CStringize( _volinfo.volid )),
                                    TRKREPORT_LAST_PARAM );

                }   // case CLAIM_VOLUME

                break;


            default:

                TrkAssert( FALSE && TEXT("Invalid SyncType given to CVolume::Serialize") );
                break;

            }   // switch

            fSuccess = TRUE;

        }   // if(pSyncVolume->hr == S_OK)

        else
        {
            // If this is a quota error, log it (but only log it once
            // per machine per transition).
            if( TRK_E_VOLUME_QUOTA_EXCEEDED == pSyncVolume->hr )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Vol quota reached") ));
                if( !_VolQuotaReached.IsSet() )
                {
                    _VolQuotaReached.Set();
                    TrkReportEvent( EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED, EVENTLOG_WARNING_TYPE,
                                    TRKREPORT_LAST_PARAM );
                }

                // We'll call this success so that we don't retry.  We'll try again
                // later when the infrequent timer goes off.
                fSuccess = TRUE;
            }

            SetState(VOL_STATE_NOTOWNED);
            __leave;
        }


    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in UnloadSyncVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
    }



    if( !fSuccess && pSyncVolume->SyncType == CREATE_VOLUME )
    {
        g_ptrkwks->_entropy.ReturnUnusedSecret( & _tempSecret );
        _tempSecret = CVolumeSecret();

        if( SUCCEEDED(pSyncVolume->hr) )
            pSyncVolume->hr = E_FAIL;
    }

    Unlock();
    return( fSuccess );

}   // CVolume::UnloadSyncVolume



//+----------------------------------------------------------------------------
//
//  CVolume::UnloadQueryVolume
//
//  The volume manager called LoadQueryVolume, sent the request to trskvr,
//  and is now giving us the result.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::UnloadQueryVolume( const TRKSVR_SYNC_VOLUME *pQueryVolume )
{
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        // Was the request successful?

        if(pQueryVolume->hr == S_OK)
        {
            // Go into the owned state, if we're not there
            // already.

            SetState( VOL_STATE_OWNED );

            // Seek the log to match what trksvr expects.  If this causes the
            // seek pointer to be backed up, it will set the timer to trigger
            // a new move-notification to trksvr.

            Seek( pQueryVolume->seq );
        }
        else    // DC didn't return VOLUME_OK
        {
            TrkLog((TRKDBG_VOLUME, TEXT("DC returned %s for QueryVolume of volume %s (%c:) -> VOL_STATE_NOTOWNED"),
                    GetErrorString(pQueryVolume->hr),
                    (const TCHAR*)CDebugString(pQueryVolume->volume),
                    VolChar(_iVol) ));

            // If there was a problem, go into the not-owned state.

            SetState(VOL_STATE_NOTOWNED);
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in UnloadQueryVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    Unlock();
    return( fSuccess );

}



//+----------------------------------------------------------------------------
//
//  CVolume::Append
//
//  Append a move notification to the end of this volume's log.
//
//+----------------------------------------------------------------------------

void
CVolume::Append( const CDomainRelativeObjId &droidCurrent,
                 const CDomainRelativeObjId &droidNew,
                 const CMachineId           &mcidNew,
                 const CDomainRelativeObjId &droidBirth)
{
    //TrkLog((TRKDBG_VOL_REFCNT, TEXT("CVolume(%08x)::Append refcnt=%d (should be 2, sometimes >2)"), this, _lRef));

    Lock();
    __try   // __finally
    {
        // Validate the IDs

        const CVolumeId volidZero;
        const CObjId objidZero;

        if( volidZero == droidCurrent.GetVolumeId()
            ||
            objidZero == droidCurrent.GetObjId()
            ||
            volidZero == droidNew.GetVolumeId()
            ||
            objidZero == droidNew.GetObjId()
            ||
            volidZero == droidBirth.GetVolumeId()
            ||
            objidZero == droidBirth.GetObjId() )
        {
            // In the append path, we only raise NTSTATUS errors, not HRESULTs
            TrkRaiseException( STATUS_OBJECT_NAME_INVALID );
        }

        __try   // __except
        {
            _cLog.Append( droidCurrent.GetVolumeId(), droidCurrent.GetObjId(), droidNew, mcidNew, droidBirth );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // We had a potentially recoverable exception.  Try to handle it
            // and retry the append.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ) )
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize, then attempt the Append again.
                // If this raises, it's an unrecoverable exception, so we just pass
                // it up.
                DeleteLogAndReInitializeVolume();
            }

            // Retry the Append, which could raise again, but this time we won't catch it.
            _cLog.Append( droidCurrent.GetVolumeId(), droidCurrent.GetObjId(), droidNew, mcidNew, droidBirth );

        }
    }
    __finally
    {
        Unlock();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::Read
//
//  Read one or more entries from the log, from the current seek position.
//
//+----------------------------------------------------------------------------

void
CVolume::Read(CObjId *pobjidCurrent,
              CDomainRelativeObjId *pdroidBirth,
              CDomainRelativeObjId *pdroidNew,
              SequenceNumber *pseqFirst,
              ULONG *pcRead)
{

    Lock();
    __try   // __finally
    {
        __try
        {
            _cLog.Read( pobjidCurrent, pdroidBirth, pdroidNew,
                        pseqFirst, pcRead );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Try to recover from this error and if possible retry
            // the read.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the read, which could raise again, but this time we won't
                // catch it.
                TrkLog(( TRKDBG_VOLUME, TEXT("Retrying CLog::Read") ));
                _cLog.Read( pobjidCurrent, pdroidBirth, pdroidNew,
                            pseqFirst, pcRead );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize, then pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::Search
//
//  Search the log for a move-notification (from droidCurrent).
//
//+----------------------------------------------------------------------------

BOOL
CVolume::Search( const CDomainRelativeObjId & droidCurrent, CDomainRelativeObjId * pdroidNew,
                 CMachineId *pmcidNew, CDomainRelativeObjId * pdroidBirth )
{
    BOOL fFound = FALSE;

    Lock();
    __try   // __finally
    {
        __try
        {
            // Perfbug:  Don't hold the log locked during the whole search such that
            // it locks out Appends.
            fFound = _cLog.Search( droidCurrent.GetObjId(), pdroidNew, pmcidNew, pdroidBirth );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Try to recover from this error and retry the search.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the search, which could raise again, but this time we won't catch it.
                fFound = _cLog.Search( droidCurrent.GetObjId(), pdroidNew, pmcidNew, pdroidBirth );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize, and pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }

    return( fFound );
}


//+----------------------------------------------------------------------------
//
//  CVolume::Seek
//
//  Seek the log to a particular sequence number.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::Seek( SequenceNumber seq )
{
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        __try
        {
            fSuccess = _cLog.Seek( seq );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Try to recover from this error and retry the seek.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the Seek, which could raise again, but this time we won't catch it.
                fSuccess = _cLog.Seek( seq );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize and pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }

    if( fSuccess )
        TrkLog(( TRKDBG_VOLUME, TEXT("Log on %c: sought to seq %d"),
                 VolChar(_iVol), seq ));
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("Log on %c: couldn't be sought to seq %d"),
                 VolChar(_iVol), seq ));

    return( fSuccess );
}


//+----------------------------------------------------------------------------
//
//  CVolume::Seek
//
//  Seek to a relative (e.g. back up 2) or absolute (e.g. first) position.
//
//+----------------------------------------------------------------------------

void
CVolume::Seek( int origin, int iSeek )
{
    Lock();
    __try   // __finally
    {
        __try
        {
            _cLog.Seek( origin, iSeek );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Attempt to recover from this error and retry the seek.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the Seek, which could raise again, but this time we won't catch it.
                _cLog.Seek( origin, iSeek );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize and pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }

}




//+----------------------------------------------------------------------------
//
//  CVolume::GetVolumeId
//
//  Get the volume ID without taking the lock.  This was done
//  so that CVolumeManager::IsDuplicateID can check the volid
//  of other volumes without deadlocking.  Otherwise we run the
//  risk of one volume holding its locks and trying to get
//  another volume's lock (using GetVolumeId on that volume)
//  while another thread is in that volume doing the same for
//  this volume.
//
//+----------------------------------------------------------------------------

const CVolumeId
CVolume::GetVolumeId()
{
    CVolumeId       volid;
    ULONG           cAttempts = 0;

    // Spin until we get a good volid.

    while( TRUE )
    {
        // Get the update counter before and after reading
        // from the volid.  (This assumes that
        // reading the long is atomic.)

        LONG lVolidUpdatesBefore = _lVolidUpdates;

        volid = _volinfo.volid;

        LONG lVolidUpdatesAfter = _lVolidUpdates;

        // When the _volinfo is updated, the _lVolidUpdates is
        // incremented before and after the update.  So if there
        // was an update in progress when we started, it will
        // be an odd number.
        //
        // Ensure there was no update in progress when we read
        // the volid, and there was no update started while we
        // were reading the volid.


        if( (lVolidUpdatesBefore & 1)
            ||
            lVolidUpdatesBefore != lVolidUpdatesAfter )
        {
            // Check for timeout (30 seconds)
            if( 3000 < ++cAttempts )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed spin in GetVolumeId") ));
                TrkRaiseWin32Error( WAIT_TIMEOUT );
            }

            // Wait for the update to complete then try again.
            Sleep( 10 );
            continue;
        }
        else
            break;
    }

    return( volid );
}



//+----------------------------------------------------------------------------
//
//  CVolume::GetState
//
//  Get the current state of this volume (owned, not-owned, or not-created).
//
//+----------------------------------------------------------------------------

CVolume::CVOL_STATE
CVolume::GetState()
{
    CVolumeId       volNULL;
    CVOL_STATE      state = VOL_STATE_UNKNOWN;

    Lock();
    __try
    {

        if( _volinfo.fNotCreated )
        {
            state = VOL_STATE_NOTCREATED;
        }

        // If the time we entered the not-owned state is non-zero, then
        // we're certainly in the not-owned state.  Also, if the machine ID
        // in the _volinfo header doesn't match the local machine, we're
        // not owned.

        else if(_volinfo.cftEnterNotOwned != 0
                ||
                _volinfo.machine != CMachineId(MCID_LOCAL)
               )
        {
            // Is this the first time that we realized we're not owned?
            if( !IsWriteProtectedVolume() && 0 == _volinfo.cftEnterNotOwned )
            {
                _volinfo.cftEnterNotOwned.SetToUTC();
                _fDirty = TRUE;
                Flush();
            }

            state = VOL_STATE_NOTOWNED;
        }

        // Otherwise, we must be properly owned.

        else
        {
            state = VOL_STATE_OWNED;
        }
    }
    __finally
    {
        Unlock();
    }

    return state;
}


//+----------------------------------------------------------------------------
//
//  CVolume::SetState
//
//  Change the current state of the volume.  This checks for valid transitions.
//  For example, you can't transition from not-created to not-owned (such
//  a request is silently ignored).  This alleviates the caller from having
//  to perform this logic.
//
//+----------------------------------------------------------------------------

void
CVolume::SetState(CVOL_STATE volstateTarget)
{
    CVOL_STATE  volstateCurrent = GetState();
    NTSTATUS    status = STATUS_SUCCESS;
    VolumePersistentInfo volinfoNew = _volinfo;
    BOOL fDirtyNew = _fDirty;

    // Make sure the volume is writeable
    RaiseIfWriteProtectedVolume();

    Lock();
    __try
    {
        switch( volstateTarget )
        {

        case VOL_STATE_NOTOWNED:

            // We can only go to not-owned from owned.

            if( VOL_STATE_OWNED == volstateCurrent )
            {
                TrkAssert( !volinfoNew.fNotCreated );
                TrkLog(( TRKDBG_VOLUME, TEXT("Entering not-owned state on vol %c:"), VolChar(_iVol) ));

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.cftEnterNotOwned.SetToUTC();
            }
            break;

        case VOL_STATE_NOTCREATED:

            // We can always go to not-created.

            if( volstateCurrent != VOL_STATE_NOTCREATED )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Entering not-created state on vol %c:"), VolChar(_iVol) ));

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.fNotCreated = TRUE;
                volinfoNew.cftEnterNotOwned = CFILETIME(0);
            }

            break;

        case VOL_STATE_OWNED:

            if( VOL_STATE_NOTCREATED == volstateCurrent )
            {
                // We're going from not-created to owned, so we need to make
                // all our OIDs reborn.

                TrkLog(( TRKDBG_VOLUME, TEXT("Entering owned state (from not-created) on vol %c:"), VolChar(_iVol) ));

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.fNotCreated = FALSE;
                TrkAssert( CFILETIME(0) == volinfoNew.cftEnterNotOwned );

                // Since we now have a new volid, we must give all the existing
                // files new object IDs.

                //MarkForMakeAllOidsReborn();
                volinfoNew.fDoMakeAllOidsReborn = TRUE;
            }
            else if( VOL_STATE_NOTOWNED == volstateCurrent )
            {
                // We're going from not-owned to owned.

                TrkLog(( TRKDBG_VOLUME, TEXT("Entering owned state (from not-owned) on vol %c:"), VolChar(_iVol) ));
                TrkAssert( !volinfoNew.fNotCreated );

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.cftEnterNotOwned = CFILETIME(0);
            }

            TrkAssert( CVolumeId() != _volinfo.volid );
            break;

        default:
            TrkAssert( !TEXT("Bad target state in CVolume::SetState") );

        }   // switch( volstateTarget )

        // If we modified the volinfo, write it back out.

        _volinfo = volinfoNew;
        _fDirty |= fDirtyNew;

        Flush();

    }
    __finally
    {
        Unlock();
    }

    return;

}


//+----------------------------------------------------------------------------
//
//  CVolume::NotOwnedExpired
//
//  Have we been in the not-owned state for long enough that we should be
//  in the not-created state?
//
//+----------------------------------------------------------------------------

BOOL
CVolume::NotOwnedExpired()
{
    Lock();
    __try
    {
        if(_volinfo.cftEnterNotOwned != 0)
        {
            CFILETIME   cftDiff = CFILETIME() - _volinfo.cftEnterNotOwned;
            ULONG SecondsDiff = static_cast<ULONG>((LONGLONG)cftDiff/10000000);

            if(SecondsDiff > _pTrkWksConfiguration->GetVolNotOwnedExpireLimit())
            {
                return TRUE;
            }
        }
    }
    __finally
    {
        Unlock();
    }

    return FALSE;
}



//+----------------------------------------------------------------------------
//
//  CVolume::MakeAllOidsReborn
//
//  Reset (zero out) the birth IDs (actually, all 48 extended bytes) of
//  all the files on this volume.  That makes the file no longer a link source,
//  so we won't try to track it.  If someone subsequently makes a link
//  to it, NTFS will fill in a new birth ID.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::MakeAllOidsReborn()
{
    CObjIdEnumerator        oie;
    BOOL                    fSuccess = FALSE;
    CObjId                  objid;
    CDomainRelativeObjId    droidBirth;
    NTSTATUS                status;
    CVolumeId               vidNull;
    BOOL                    fLocked = FALSE;

    __try
    {
        // Give all the files with object IDs a fresh birth ID, as if the
        // file had first been linked to on this volume.

        TrkLog(( TRKDBG_VOLUME, TEXT("Making OIDs reborn on volume %c:"), VolChar(_iVol) ));

        if(oie.Initialize(_tszVolumeDeviceName))
        {
            if(oie.FindFirst(&objid, &droidBirth))
            {
                do
                {
                    g_ptrkwks->RaiseIfStopped();

                    // If this has what looks like an invalid birth ID, ignore it.

                    if( CObjId() == droidBirth.GetObjId() )
                        continue;

                    // We only take the lock directly around the make-reborn
                    // call, since with the sleep below we could be in this routine
                    // for a while.

                    Lock();   fLocked = TRUE;
                    TrkAssert( 1 == _cLocks );
                    MakeObjIdReborn( _tszVolumeDeviceName, objid );
                    Unlock(); fLocked = FALSE;

                    Sleep( 100 );   // don't hog the machine
                } while(oie.FindNext(&objid, &droidBirth));
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
        __try
        {
            if( TRK_E_CORRUPT_LOG == GetExceptionCode() )
            {
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );
                BreakIfRequested();
                DeleteLogAndReInitializeVolume();
            }
            else if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();
                TrkRaiseException( GetExceptionCode() );
            }

            TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolume::MakeAllOidsReborn for %c: %08x"),
                     VolChar(_iVol), GetExceptionCode() ));
        }
        __finally
        {
            if( fLocked )
                Unlock();
        }

        goto Exit;
    }


    fSuccess = TRUE;

Exit:

    oie.UnInitialize();

    if(!fSuccess)
    {
        TrkLog((TRKDBG_ERROR,
                TEXT("Can't delete all object ids on volume %c:"),
                VolChar(_iVol)  ));
    }

    return fSuccess;
}





//+----------------------------------------------------------------------------
//
//  CVolume::OnHandlesMustClose
//
//  This routine is called from CLogFile if it discovers that the log file
//  needs to be closed (an oplock break).  We close all handles on the volume
//  and start the reopen timer.
//
//+----------------------------------------------------------------------------

void
CVolume::OnHandlesMustClose()
{
    CloseVolumeHandles();   // Doesn't raise
    g_ptrkwks->SetReopenVolumeHandlesTimer();
}





//+----------------------------------------------------------------------------
//
//  CVolume::FileActionIdNotTunnelled
//
//  This method is called as an event notification, indicating that NTFS has
//  notified us that a file could not be tunnelled.  We do the tunnelling manually
//  here.
//
//+----------------------------------------------------------------------------

#define ON_NOT_TUNNELLED_DELAY   500 // .5 seconds

void
CVolume::FileActionIdNotTunnelled( FILE_OBJECTID_INFORMATION * poi )
{
    ULONG  ulMillisecondsSleptSoFar = 0;
    HANDLE hFile = NULL;

    // We don't take the volume lock here.  So don't attempt to
    // do anything other than simple I/O.  We don't take the lock because
    // we want to ensure that tunnelling is resolved quickly without
    // getting blocked.

    //
    // Open the file being "tunnelled from" by OBJECTID
    // Delete the object id
    // Close
    // Open the file being "tunnelled to" by FileReference
    // Set the object id and extra data
    // Close

    // Test hook
    IFDBG( _pTunnelTest->ReleaseAndWait() );

    __try
    {
        if (_hVolume == NULL)
        {
            // Couldn't reopen the volume
            __leave;
        }

        NTSTATUS            Status;

        OBJECT_ATTRIBUTES   oa;
        UNICODE_STRING      uId;
        IO_STATUS_BLOCK     ios;
        CObjId              objid( FOI_OBJECTID, *poi );
        int                 i;

        // Ignore if this isn't a link tracking (e.g. it's an NTFRS) object ID.

        if( CObjId() == CObjId(FOI_BIRTHID, *poi) )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring not-tunneled notification for %s"),
                     (const TCHAR*)CDebugString( objid ) ));
            __leave;
        }

        uId.Length = sizeof(poi->ObjectId);
        uId.MaximumLength = sizeof(poi->ObjectId);
        uId.Buffer = (PWSTR) poi->ObjectId;

        InitializeObjectAttributes( &oa, &uId, OBJ_CASE_INSENSITIVE, _hVolume, NULL );

        //  -----------------
        //  Open the old file
        //  -----------------

        // Some kind of write access, along with restore privelege, is required
        // for set/delete OID calls.

        EnableRestorePrivilege();
        Status = NtCreateFile(
                    &hFile,
                    SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
                    &oa,
                    &ios,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    FILE_OPEN_BY_FILE_ID | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL
                        | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

        //  ------------------------------
        //  Delete the OID on the old file
        //  ------------------------------

        if (NT_SUCCESS(Status))
        {
            Status = NtFsControlFile(
                     hFile,
                     NULL,
                     NULL,
                     NULL,
                     &ios,
                     FSCTL_DELETE_OBJECT_ID,
                     NULL,  // in buffer
                     0,     // in buffer size
                     NULL,  // Out buffer
                     0);    // Out buffer size

            NtClose( hFile );
            hFile = NULL;

            if (NT_SUCCESS(Status))
            {
                TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %s - deleted from old file"),
                        (const TCHAR*)CDebugString(objid) ));
            }
            else
            {
                TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %c:%s - couldn't FSCTL_DELETE_OBJECT_ID ntstatus=%08x"),
                        VolChar(_iVol),
                        (const TCHAR*)CDebugString(objid),
                        Status ));
            }
        }   // if (NT_SUCCESS(Status))

        else
        {
            // We couldn't open the old file, so we'll ignore it and try to set the
            // object ID.
            TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %c:%s - couldn't open old file %08x"),
                    VolChar(_iVol),
                    (const TCHAR*)CDebugString(objid),
                    Status));
        }

        if( Status == STATUS_INVALID_DEVICE_REQUEST ||
            IsErrorDueToLockedVolume( Status ) )
        {
            // If we get STATUS_INVALID_DEVICE_REQUEST, then _hVolume is
            // broken.

            CloseVolumeHandles();
            g_ptrkwks->SetReopenVolumeHandlesTimer();
            __leave;
        }

        //  -----------------
        //  Open the new file
        //  -----------------

        uId.Length = sizeof(poi->FileReference);
        uId.MaximumLength = sizeof(poi->FileReference);
        uId.Buffer = (PWSTR) &poi->FileReference;

        Status = NtCreateFile(
                     &hFile,
                     SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
                     &oa,
                     &ios,
                     NULL,
                     FILE_ATTRIBUTE_NORMAL,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_OPEN,
                     FILE_OPEN_BY_FILE_ID | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL
                        | FILE_SYNCHRONOUS_IO_NONALERT,
                     NULL,
                     0 );

        //  ---------------------------
        //  Set the OID on the new file
        //  ---------------------------

        if (NT_SUCCESS(Status))
        {
            Status = NtFsControlFile(
                         hFile,
                         NULL,
                         NULL,
                         NULL,
                         &ios,
                         FSCTL_SET_OBJECT_ID,
                         poi->ObjectId,
                         sizeof(FILE_OBJECTID_BUFFER),
                         NULL,  // Out buffer
                         0);    // Out buffer size
            NtClose(hFile);
            hFile = NULL;

            TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %s: FSCTL_SET_OBJECT_ID %s %08x"),
                    (const TCHAR*)CDebugString(objid),
                    NT_SUCCESS(Status) ? TEXT("succeeded") : TEXT("failed"),
                    Status ));
        }
        else
        {
            TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %c:%s - couldn't OpenByFileReference ntstatus=%08x"),
                    VolChar(_iVol),
                    (const TCHAR*)CDebugString(objid),
                    Status ));
        }

        if(Status == STATUS_INVALID_DEVICE_REQUEST ||
           IsErrorDueToLockedVolume( Status ) )
        {
            // If we get STATUS_INVALID_DEVICE_REQUEST, then _hVolume is
            // broken.

            CloseVolumeHandles();
            g_ptrkwks->SetReopenVolumeHandlesTimer();
            __leave;
        }

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception %08x in CVolume::FileActionIdNotTunnelled"),
                 GetExceptionCode() ));
    }

    if( NULL != hFile )
        NtClose( hFile );


    return;
}





//+----------------------------------------------------------------------------
//
//  CVolume::NotifyAddOrDelete
//
//  This method is called as an event notification, indicating that NTFS has
//  notified us that the volume ID has been modified.  We use this to ensure
//  the volume ID doesn't get incorrectly modified.
//
//  If you watch the object ID notification queue while someone sets the
//  volume ID directly in NTFS, you'll see:
//  *   a remove of the old ID (setting a new ID shows up as a remove/add),
//  *   an add of the bogus ID,
//  *   a remove of the bogus ID (part of the SetVolid that we do in this routine),
//  *   an add of the correct ID.
//
//+----------------------------------------------------------------------------


void
CVolume::NotifyAddOrDelete( ULONG Action, const CObjId & objid )
{
    CVolumeId volidCorrect;

    // We don't take the volume lock here.  So don't attempt to
    // do anything other than simple I/O.  We don't take the lock because
    // we want to ensure the notifications from NTFS don't get backed up
    // (so we don't miss any tunnel notifications).

    // We only hook removes

    if( FILE_ACTION_REMOVED != Action )
        return;

    volidCorrect = GetVolumeId();
    if( volidCorrect == objid && !_fInSetVolIdOnVolume )
    {
        NTSTATUS status = 0;
        status = SetVolIdOnVolume( volidCorrect );

        TrkLog(( TRKDBG_WARNING|TRKDBG_VOLUME,
                 TEXT("Undoing delete of volume ID:\n   => %s (%08x)"),
                 (const TCHAR*)CDebugString( volidCorrect ),
                 status ));

    }

    return;
}







//+----------------------------------------------------------------------------
//
//  CVolume::LoadVolInfo
//
//  Load the _volinfo member from the log.
//
//+----------------------------------------------------------------------------

void
CVolume::LoadVolInfo()
{
    AssertLocked();
    TrkAssert( CVOLUME_HEADER_LENGTH == sizeof(_volinfo) );

    // Read _volinfo from the extended header portion of the log.

    __try
    {
        _cLogFile.ReadExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
    }
    __except( IsRecoverableDiskError( GetExceptionCode() )
              ? EXCEPTION_EXECUTE_HANDLER
              : EXCEPTION_CONTINUE_SEARCH )
    {
        // Attempt to recover from this error and retry the read.

        if( IsErrorDueToLockedVolume( GetExceptionCode() ))
        {
            CloseAndReopenVolumeHandles();
            _cLogFile.ReadExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
        }
        else
        {
            TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
            TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                            NULL );
            DeleteLogAndReInitializeVolume();
        }
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::SaveVolInfo
//
//  Write the _volinfo structure to the extended header portion of the log.
//  Clear _fDirty if successful.
//
//+----------------------------------------------------------------------------

void
CVolume::SaveVolInfo( )
{
    AssertLocked();

    __try
    {
        _cLogFile.WriteExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
        _fDirty = FALSE;
    }
    __except( IsRecoverableDiskError( GetExceptionCode() )
              ? EXCEPTION_EXECUTE_HANDLER
              : EXCEPTION_CONTINUE_SEARCH )
    {
        // Attempt to recover from this error and retry the write.

        if( IsErrorDueToLockedVolume( GetExceptionCode() ) )
        {
            CloseAndReopenVolumeHandles();
            _cLogFile.WriteExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
            _fDirty = FALSE;
        }
        else
        {
            TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
            TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                            NULL );
            DeleteLogAndReInitializeVolume();
        }
    }

}




//+----------------------------------------------------------------------------
//
//  CVolume::CloseVolumeHandles
//
//  This method close all handle that this object maintains on the volume.
//  This will allow e.g. format or chkdsk /f to run successfully.
//  We don't take the volume critsec, so we're guaranteed to run quickly
//  and not block.
//
//+----------------------------------------------------------------------------

void
CVolume::CloseVolumeHandles( HDEVNOTIFY hdnVolume, EHandleChangeReason eHandleChangeReason )
{
    HANDLE hVolToClose = NULL;

    // This routine never raises

    // Is this notification intended for everyone, or specifically
    // for us?
    if( hdnVolume != NULL && hdnVolume != _hdnVolumeLock )
        // No, it's just for another volume.
        return;

    // Are we already in a CloseVolumeHandles somewhere?
    // If so, there's no need to continue, and worse yet if we were
    // to continue we could deadlock (scenario:  one thread is in 
    // _cLogFile.Close below unregistering the oplock wait, which is
    // blocking, and another thread is executing an oplock break).

    if( !BeginSingleInstanceTask( &_cCloseVolumeHandlesInProgress ) )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Skipping CloseVolumeHandles, another instance already in progress") ));
        return;
    }


    // We don't want this method to take the normal _csVolume lock, because
    // we're called from threads that must not block (such as the service control handler
    // thread).  So we just take the limited lock that's used in this method
    // and in ReopenVolumeHandles.

    LockHandles();
    __try
    {
        BOOL fAlreadyLockedOrDismounted = _fVolumeLocked || _fVolumeDismounted;

        TrkLog(( TRKDBG_WARNING, TEXT("Closing volume handles on %c:"), VolChar(_iVol) ));

        // If this notification is specifically for us, then remember
        // if we're locked/dismounted.

        if( hdnVolume != NULL )
        {
            if( VOLUME_LOCK_CHANGE == eHandleChangeReason )
                _fVolumeLocked = TRUE;
            else if( VOLUME_MOUNT_CHANGE == eHandleChangeReason )
                _fVolumeDismounted = TRUE;
        }

        // Is this volume already locked or dismounted?
        if( fAlreadyLockedOrDismounted )
        {
            TrkAssert( NULL == _hVolume );
            __leave;
        }

        // Close the object ID index directory handle.

        _ObjIdIndexChangeNotifier.StopListeningAndClose();

        // Close the log.

        _cLogFile.Close();  // Doesn't raise

        // Prepare to close the volume handle.

        if (_hVolume != NULL)
        {
            hVolToClose = _hVolume;
            _hVolume = NULL;
        }

        TrkLog((TRKDBG_VOLUME, TEXT("Volume %c: closed"), VolChar(_iVol)));
    }

    __except( EXCEPTION_EXECUTE_HANDLER ) // BreakThenReturn( EXCEPTION_EXECUTE_HANDLER ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring unexpected exception in CVolume::CloseVolumeHandles (%08x)"),
                 GetExceptionCode() ));
    }

    UnlockHandles();
    EndSingleInstanceTask( &_cCloseVolumeHandlesInProgress );

    if( NULL != hVolToClose )
    {
        NtClose( hVolToClose );
        TrkLog((TRKDBG_VOLUME, TEXT("(Volume %c: fully closed)"), VolChar(_iVol)));
    }

}



//+----------------------------------------------------------------------------
//
//  CVolume::ReopenVolumeHandles
//
//  Reopen the handles that we maintain on the volume.  This is synchronized
//  with CloseVolumeHandles using the handle critsec.  This method does
//  nothing if the volume is locked (as indicated by _fVolumeLocked),
//  or if the volume handles are already opened.
//
//+----------------------------------------------------------------------------


BOOL
CVolume::ReopenVolumeHandles()
{
    NTSTATUS    status;
    BOOL        fHandlesLocked = FALSE;
    BOOL        fHandlesOpen = FALSE;
    BOOL        fReopenedLog = FALSE;
    BOOL        fStartedListening = FALSE;


    // Don't open if the service is stopping.
    g_ptrkwks->RaiseIfStopped();

    TrkLog(( TRKDBG_WARNING, TEXT("\nReopenVolumeHandles called on %c:"), VolChar(_iVol) ));

    // This method must acquire the _csVolumes critical section like every other
    // public method (via the Lock call).  It must also acquire the _csHandles
    // lock, in order to coordinate with the CloseVolumeHandles and SetUnlockVolume
    // methods, which have special needs.

    Lock();
    LockHandles(); fHandlesLocked = TRUE;
    __try
    {
        // Are we supposed to reopen?
        if( IsHandsOffVolumeMode() )
        {
            // Don't open yet, wait until we get an UnLock notification.
            TrkLog(( TRKDBG_VOLUME, TEXT("Didn't open handles on %c:, it's %s"),
                     VolChar(_iVol),
                     _fVolumeLocked
                        ? ( _fVolumeDismounted ? TEXT("locked & dismounted") : TEXT("locked") )
                        : TEXT("dismounted") ));
            __leave;
        }

        // Open the main volume handle.
        if( NULL == _hVolume )
        {
            status = OpenVolume(_tszVolumeDeviceName, &_hVolume);
            if(!NT_SUCCESS(status))
            {
                if( STATUS_OBJECT_NAME_NOT_FOUND == status )
                {
                    TrkLog(( TRKDBG_VOLUME, TEXT("Volume not found in ReopenVolumeHandles, deleting CVolume") ));
                    MarkSelfForDelete();
                }

                TrkRaiseNtStatus(status);
            }
        }


        // Start listening for objid index change notifications
        __try
        {
            fStartedListening = _ObjIdIndexChangeNotifier.AsyncListen( );
        }
        __except( BreakOnDebuggableException() )
        {
            // We should never get a path-not-found error, because meta-files always exist
            // on a good NTFS5 volume.  If we get one, it's probably because an NTFS5
            // volume has been reformatted as a FAT volume.

            HRESULT hr = GetExceptionCode();
            if( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("ObjId Index not found in ReopenVolumeHandles, deleting CVolume") ));
                MarkSelfForDelete();
            }

            TrkRaiseException( hr );

        }

        // Register for PNP notifications.  We don't hold the handle lock because this
        // call can take a while, and we don't want to block the service control
        // handler thread from doing a CloseVolumeHandles.

        if( fStartedListening )
        {

#if DBG
            TrkVerify( 0 == UnlockHandles() );
#else
            UnlockHandles();
#endif
            fHandlesLocked = FALSE;
            RegisterPnPVolumeNotification();
            LockHandles(); fHandlesLocked = TRUE;
        }

        // If CloseVolumeHandles came in after we released the handle lock just now,
        // then abort.

        if( NULL == _hVolume )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Aborting ReopenVolumeHandles") ));
            TrkRaiseException( E_FAIL );
        }

        // Open the log

        if( !_cLogFile.IsOpen() )
        {
            for( int i = 0; i < 2; i++ )
            {
                __try
                {
                    _cLogFile.Initialize( _tszVolumeDeviceName, _pTrkWksConfiguration, this, VolChar(_iVol) );
                    _cLog.Initialize( _pLogCallback, _pTrkWksConfiguration, &_cLogFile );
                }
                __except( (0 == i && TRK_E_CORRUPT_LOG == GetExceptionCode())
                          ? EXCEPTION_EXECUTE_HANDLER
                          : EXCEPTION_CONTINUE_SEARCH )
                {
                    BreakIfRequested();

                    // Get rid of the corrupt file
                    _cLogFile.Delete();

                    // Loop back and try again.
                    continue;
                }
                break;
            }

            fReopenedLog = TRUE;
        }

        // If we've never read in the volinfo, do so now.

        if( !_fVolInfoInitialized )
        {
            LoadVolInfo();
            _fVolInfoInitialized = TRUE;
            TrkLog(( TRKDBG_VOLUME, TEXT("VolId (from log file) for %c: is %s"),
                     VolChar(_iVol), (const TCHAR*)CDebugString(_volinfo.volid) ));
        }




        if( fReopenedLog )
        {
            // Reconcile our volinfo with the log.
            // BUGBUG (removable media): We haven't re-read the volinfo out of the log, we're still
            // using what we already had in memory.  This won't work for removeable
            // media, so we need to add some extra checking here.

            VolumeSanityCheck();

            // Start the move notify timer; we may have been trying to send
            // notifies when we discovered that the volume handles were bad.

            g_ptrkwks->OnEntriesAvailable();
        }

        TrkLog((TRKDBG_VOLUME, TEXT("Volume %c open"), VolChar(_iVol)));
        fHandlesOpen = TRUE;
    }
    __finally
    {
        if( fHandlesLocked )
            UnlockHandles();

        // We either open everything, or open nothing
        if( AbnormalTermination() )
        {
            CloseVolumeHandles();   // Doesn't raise
            g_ptrkwks->SetReopenVolumeHandlesTimer();   // Try again later
        }

        Unlock();
    }

    return( fHandlesOpen );
}


//+----------------------------------------------------------------------------
//
//  CVolume::CloseAndReopenVolumeHandles
//
//  One or more of the handles maintained on the volume are bad (for example,
//  the handle may have been broken by a dismount).  Close all of them, and
//  attempt to reopen new ones.
//
//+----------------------------------------------------------------------------

void
CVolume::CloseAndReopenVolumeHandles()
{

    Lock();

    __try
    {
        // There's the remote possibility that the ReopenVolumeHandles
        // call below will call this routine.  Just to be paranoid, we
        // add protection against an infinite recursion.

        if( _fCloseAndReopenVolumeHandles )
            TrkRaiseWin32Error( ERROR_OPEN_FAILED );
        _fCloseAndReopenVolumeHandles = TRUE;

        // Close then reopen the handles

        CloseVolumeHandles();
        ReopenVolumeHandles();
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog((TRKDBG_VOLUME, TEXT("Immediate reopen of volume handle failed, set the reopen timer")));
        g_ptrkwks->SetReopenVolumeHandlesTimer();
    }

    _fCloseAndReopenVolumeHandles = FALSE;
    Unlock();
}



//+----------------------------------------------------------------------------
//
//  CVolume::PrepareToReopenVolumeHandles
//
//  The handles to the volume were closed at some point, but they may now
//  be reopened.  Call CVolumeManager::OnVolumeToBeReopened, so that it can
//  call us in ReopenVolumeHandles on a worker thread (right now we're on
//  the services handler thread, which is shared by all of services.exe).
//
//+----------------------------------------------------------------------------

void
CVolume::PrepareToReopenVolumeHandles( HDEVNOTIFY hdnVolume, EHandleChangeReason eHandleChangeReason )
{
    // It is important that this method does not take the volume lock.
    // This method is called during the volume unlock notification
    // that we receive in CTrkWksSvc::ServiceHandler, and we can
    // never allow that thread to hang.

    LockHandles();
    if( _hdnVolumeLock == hdnVolume )
    {
        if( VOLUME_LOCK_CHANGE == eHandleChangeReason )
            _fVolumeLocked = FALSE;
        else if( VOLUME_MOUNT_CHANGE == eHandleChangeReason )
            _fVolumeDismounted = FALSE;

        if( !_fVolumeLocked && !_fVolumeDismounted )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Volume %c: is to be reopened"), VolChar(_iVol) ));
            _pVolMgr->OnVolumeToBeReopened();
        }
    }

    UnlockHandles();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\trkwks\volmgr.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  volmgr.cxx
//
//  This file implements the CVolumeManager class.  That class maintains
//  a list of CVolume objects.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"
#include <dbt.h>

#define THIS_FILE_NUMBER    VOLMGR_CXX_FILE_NO


void
CVolumeManager::Initialize(CTrkWksSvc * pTrkWks,
                        const CTrkWksConfiguration *pTrkWksConfiguration,
                        PLogCallback * pLogCallback,
                        SERVICE_STATUS_HANDLE ssh
                        #if DBG
                        , CTestSync * pTunnelTest
                        #endif
                        )
{
    BOOL fReg = FALSE;
    HKEY hKey;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING name;
    CSystemSD ssd;
    NTSTATUS Status;

    TrkLog(( TRKDBG_VOLUME, TEXT("Initializing the volume list") ));

    TrkAssert( !_fInitialized );

    _csVolumeNodeList.Initialize();
    _fInitialized = TRUE;

    _pTrkWks = pTrkWks;
    _pTrkWksConfiguration = pTrkWksConfiguration;
    _pVolumeNodeListHead = NULL;

    __try
    {
        // This timer is started when we unexpectedly lose our volume handles.
        // When it fires, we try to reopen them.  After a number of such retries,
        // we give up and stop the timer.

        _timerObjIdIndexReopen.Initialize(
            this,
            NULL,                           // No name (non-persistent timer)
            VOLTIMER_OBJID_INDEX_REOPEN,    // Context ID
            pTrkWksConfiguration->GetObjIdIndexReopen(),
            CNewTimer::RETRY_WITH_BACKOFF,
            pTrkWksConfiguration->GetObjIdIndexReopenRetryMin(),
            pTrkWksConfiguration->GetObjIdIndexReopenRetryMax(),
            pTrkWksConfiguration->GetObjIdIndexReopenLifetime()
            );

        // Create and register an event that we'll signal when a volume has been unlocked.
        // We have to run this on an IO thread so that the logfile oplock and
        // ReadDirectoryChanges on the objid index will work.

        _heventVolumeToBeReopened = CreateEvent( NULL, FALSE, FALSE, NULL );
        if( NULL == _heventVolumeToBeReopened )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create _hVolumeUnlockEvent") ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(GetLastError()),
                                    NULL );
            TrkRaiseWin32Error( GetLastError() );
        }

        _hRegisterWaitForSingleObjectEx
            = TrkRegisterWaitForSingleObjectEx( _heventVolumeToBeReopened, ThreadPoolCallbackFunction,
                                                static_cast<PWorkItem*>(this), INFINITE,
                                                WT_EXECUTEINIOTHREAD | WT_EXECUTELONGFUNCTION );

        if( NULL == _hRegisterWaitForSingleObjectEx )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CVolumeManager::Initialize (%lu)"),
                     GetLastError() ));
            TrkRaiseLastError();
        }

        // Create a list of CVolume objects, one for each local NTFS5 volume.
        InitializeVolumeList( pTrkWksConfiguration, pLogCallback, ssh
                              #if DBG
                              , pTunnelTest
                              #endif
                              );

        if( !pTrkWksConfiguration->_fIsWorkgroup )
        {
            InitializeDomainObjects();
            StartDomainTimers();
        }

        // Set the event that will get us to open the volume handles on an
        // IO thread.

        OnVolumeToBeReopened();


    }
    __finally
    {
        ssd.UnInitialize();
    }
}

void
CVolumeManager::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CVolumeManager (%lu)"),
                         GetLastError() ));
            }
            else
                TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered wait CVolumeManager") ));

            _hRegisterWaitForSingleObjectEx = NULL;
        }

        if( NULL != _heventVolumeToBeReopened )
        {
            CloseHandle( _heventVolumeToBeReopened );
            _heventVolumeToBeReopened = NULL;
        }

        UnInitializeDomainObjects();
        _timerObjIdIndexReopen.UnInitialize();

        CVolumeNode * pVolumeNode = _pVolumeNodeListHead;
        _pVolumeNodeListHead = NULL;

        while (pVolumeNode)
        {
            CVolumeNode * pNext = pVolumeNode->_pNext;

            // By this time, all timers and the LPC port are stopped and have unregistered
            // with the thread pool.  Therefore, there are no other threads running,
            // and each of the volume should have a ref count of only 1.  For robustness,
            // if any volumes have leaked, we release the extra refs here.

            while( 0 != pVolumeNode->_pVolume->Release() );

            delete pVolumeNode;
            pVolumeNode = pNext;
        }

        _fFrequentTaskHesitation = _fInfrequentTaskHesitation = FALSE;

        _csVolumeNodeList.UnInitialize();
        _fInitialized = FALSE;
    }
}

void
CVolumeManager::DoWork()
{
    // One of the volumes has been unlocked.  Just try to reopen them all
    // (those that aren't in need of opening will noop).

    __try
    {
        // These raise if the service is stopping.
        ReopenVolumeHandles();

        // If a volume has just been re-created, it may be necessary
        // to clean up some object IDs.

        CleanUpOids();
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring exception %08x in CVolumeManager::DoWork"),
                 GetExceptionCode() ));
    }
}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::InitializeDomainObjects
//
//  Initialize member objects that we don't use in a workgroup.  These
//  objects can come and go without restarting the service (thus we can
//  go between domains or move to/from domain without requiring a reboot).
//
//+----------------------------------------------------------------------------

void
CVolumeManager::InitializeDomainObjects()
{
    __try
    {
        TrkAssert( !_pTrkWksConfiguration->_fIsWorkgroup );

        // When this timer fires, we send all our IDs to trksvr so that the entries may
        // be touched (entries that are not touched will be GC-ed by trksvr).
        // Before actuallying doing the refresh, we sleep a random period, in order to
        // avoid too many workstations refreshing at the same time.

        _timerRefresh.Initialize( this,
                                  TEXT("NextRefreshTime"),      // Name (for persistent timer)
                                  VOLTIMER_REFRESH,             // Context ID
                                                                // Timer period
                                  _pTrkWksConfiguration->GetRefreshPeriod(),
                                  CNewTimer::RETRY_RANDOMLY,    //Retry values
                                  _pTrkWksConfiguration->GetRefreshRetryMin(),
                                  _pTrkWksConfiguration->GetRefreshRetryMax(),
                                  0 );                          // No max lifetime
        _timerRefresh.SetRecurring();
        TrkLog(( TRKDBG_VOLUME, TEXT("Refresh timer: %s"),
                 (const TCHAR*)CDebugString(_timerRefresh) ));

        // The Notify timer is set when we receive a move notification from ntos.
        // When it expires we send all unsent notifications up to trksvr.

        _timerNotify.Initialize( this,
                                 NULL,                          // No name (non-persistent timer)
                                 VOLTIMER_NOTIFY,               // Context ID
                                 _pTrkWksConfiguration->GetParameter( MOVE_NOTIFY_TIMEOUT_CONFIG ),
                                 CNewTimer::RETRY_WITH_BACKOFF,
                                 _pTrkWksConfiguration->GetParameter( MIN_MOVE_NOTIFY_RETRY_CONFIG ),
                                 _pTrkWksConfiguration->GetParameter( MAX_MOVE_NOTIFY_RETRY_CONFIG ),
                                 _pTrkWksConfiguration->GetParameter( MAX_MOVE_NOTIFY_LIFETIME_CONFIG ) );

        // The deletions manager watches for files with object IDs to get
        // deleted.  When they are, and they're not subsequently tunnelled back,
        // a notification is sent to trksvr so that it can remove that birth ID
        // from the object move table.

        _deletions.Initialize( _pTrkWksConfiguration );

        // When this timer fires, we do our ~daily tasks

        _timerFrequentTasks.Initialize( this,
                                        TEXT("NextVolFrequentTask"),    // Persistent timer
                                        VOLTIMER_FREQUENT,              // Context ID
                                        _pTrkWksConfiguration->GetVolFrequentTasksPeriod(),
                                        CNewTimer::NO_RETRY,
                                        0, 0, 0 );                      // Ignored for non-retrying timer

        // When this timer fires, we do our ~weekly tasks

        _timerInfrequentTasks.Initialize( this,
                                          TEXT("NextVolInfrequentTask"),//Persistent timer
                                          VOLTIMER_INFREQUENT,          // Context ID
                                          _pTrkWksConfiguration->GetVolInfrequentTasksPeriod(),
                                          CNewTimer::NO_RETRY,
                                          0, 0, 0 );                    // Ignored for non-retrying timer

        // When this timer fires, we do the initial volume synchronizations.
        // This timer is also used to do slow retries.  E.g, if we try to send
        // a move notification and get a busy error, we retry at this slow rate.

        _timerVolumeInit.Initialize( this,
                                     NULL,                // No name (non-persistent)
                                     VOLTIMER_INIT,       // Context ID
                                     _pTrkWksConfiguration->GetVolInitInitialDelay(),
                                     CNewTimer::RETRY_RANDOMLY,
                                                          // Initial retry period
                                     _pTrkWksConfiguration->GetVolInitRetryDelay1(),
                                                          // Max retry period
                                     _pTrkWksConfiguration->GetVolInitRetryDelay2(),
                                     _pTrkWksConfiguration->GetVolInitLifetime() );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception %08x in CVolumeManager::InitializeDomainObjects"),
                 GetExceptionCode() ));
    }

}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::UnInitializeObjects
//
//  Free the objects that we don't use in a workgroup.  This doesn't require
//  stopping the service.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::UnInitializeDomainObjects()
{
    __try
    {
        _timerRefresh.UnInitialize();
        _timerNotify.UnInitialize();

        _deletions.UnInitialize( );

        _timerInfrequentTasks.UnInitialize();
        _timerFrequentTasks.UnInitialize();
        _timerVolumeInit.UnInitialize();

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception %08x in CVolumeManager::UnInitializeDomainObjects"),
                 GetExceptionCode() ));
    }
}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::StartDomainTimers
//
//  Start the timers that we don't use in a workgroup.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::StartDomainTimers()
{
    if( !_pTrkWksConfiguration->_fIsWorkgroup )
    {
        _timerFrequentTasks.SetSingleShot();
        TrkLog(( TRKDBG_VOLUME, TEXT("Frequent timer: %s"),
                 (const TCHAR*)CDebugString(_timerFrequentTasks) ));

        _timerInfrequentTasks.SetSingleShot();
        TrkLog(( TRKDBG_VOLUME, TEXT("Infrequent timer: %s"),
                 (const TCHAR*)CDebugString(_timerInfrequentTasks) ));

        _timerVolumeInit.SetSingleShot();
        TrkLog(( TRKDBG_VOLUME, TEXT("VolInit timer: %s"),
                 (const TCHAR*)CDebugString(_timerVolumeInit) ));
    }
}



//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::RefreshVolumes
//
//  Refresh the CVolume objects.  This gives them the chance to
//  get an updated drive letter, and to delete themselves if the volume
//  they represent is now gone.
//
//+----------------------------------------------------------------------------


void
CVolumeManager::RefreshVolumes( PLogCallback *pLogCallback,
                                SERVICE_STATUS_HANDLE ssh
                                #if DBG
                                , CTestSync *pTunnelTest
                                #endif
                                )
{
    InitializeVolumeList( _pTrkWksConfiguration, pLogCallback, ssh
                          #if DBG
                          , pTunnelTest
                          #endif
                          );
    OnVolumeToBeReopened();
}



//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::InitializeVolumeList
//
//  This method initializes the linked list of CVolume objects.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::InitializeVolumeList( const CTrkWksConfiguration    *pTrkWksConfiguration,
                                      PLogCallback                  *pLogCallback,
                                      SERVICE_STATUS_HANDLE         ssh
                                      #if DBG
                                      , CTestSync                   *pTunnelTest
                                      #endif
                                      )
{
    ULONG               cVolumes = 0;
    TCHAR               tszVolumeName[ CCH_MAX_VOLUME_NAME + 1 ];
    HANDLE              hFindVolume = INVALID_HANDLE_VALUE;
    CVolumeNode         *pVolNode = NULL;

    __try
    {
        // Begin a physical volume enumeration using the mount manager.
        // Volume names represent the root in Win32 format, e.g.
        //      \\?\Volume{8baec120-078b-11d2-824b-000000000000}\ 

        hFindVolume = FindFirstVolume( tszVolumeName, sizeof(tszVolumeName) );
        if( INVALID_HANDLE_VALUE == hFindVolume )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("FindFirstVolume failed") ));
            TrkRaiseLastError();
        }

        // For each local NTFS5 volume, create a CVolume, add it to the linked-list,
        // and initialize.

        cVolumes = 1;
        while( NUM_VOLUMES >= cVolumes )
        {
            CVolume *pvolOpen = NULL;
            TCHAR tszVolumeDeviceName[ MAX_PATH + 1 ];
            ULONG cchVolumeName;

            TrkLog(( TRKDBG_VOLUME, TEXT("Initializing volume %s"), tszVolumeName ));

            // If we already have this volume open, continue on.

            cchVolumeName = wcslen(tszVolumeName);
            memcpy( tszVolumeDeviceName, tszVolumeName, cchVolumeName*sizeof(TCHAR) );
            tszVolumeDeviceName[ cchVolumeName - 1 ] = TEXT('\0');

            if( pvolOpen = FindVolume( tszVolumeDeviceName ))
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Volume already open" ) ));
                pvolOpen->Release();
                cVolumes++;
            }

            // If this isn't an NTFS5 volume, move on.

            else if( IsLocalObjectVolume(tszVolumeName) )
            {
                // Alloc a new node for the volume list

                pVolNode = new CVolumeNode;
                if (pVolNode == NULL)
                {
                    TrkRaiseException(E_OUTOFMEMORY);
                }

                // Put a volume into the node

                pVolNode->_pVolume = new CVolume();
                if (pVolNode->_pVolume == NULL)
                {
                    TrkRaiseException(E_OUTOFMEMORY);
                }


                // Initialize the volume.  Returns true if successful, raises on error.
                __try
                {
                    if( pVolNode->_pVolume->Initialize(tszVolumeName, _pTrkWksConfiguration, this,
                                                       pLogCallback, &_deletions, ssh
                                                       #if DBG
                                                       ,pTunnelTest
                                                       #endif
                                                       ))
                    {
                        cVolumes++;

                        // Add this volume node (and its associated CVolume) to the linked list.

                        AddNodeToLinkedList( pVolNode );
                        pVolNode = NULL;

                    }   // if( pVolNode->_pVolume->Initialize(v, _pTrkWksConfiguration, ...
                }
                __except( BreakOnDebuggableException() )
                {
                }

                if( NULL != pVolNode )
                {
                    TrkLog(( TRKDBG_VOLUME, TEXT("Volume initialization failed, deleting node") ));
                    pVolNode->_pVolume->Release();
                    delete pVolNode;
                    pVolNode = NULL;
                }

            }   // else if( IsLocalObjectVolume(tszVolumeName) )
            #if DBG
            else
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Skipping volume %s"), tszVolumeName ));
            }
            #endif

            // Move on to the next volume in the system.

            if( !FindNextVolume( hFindVolume, tszVolumeName, sizeof(tszVolumeName) ))
            {
                if( ERROR_NO_MORE_FILES == GetLastError() )
                    // We've enumerated all of the volumes.
                    break;
                else
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("FindNextVolume failed") ));
                    TrkRaiseLastError();
                }
            }

        }   // while( NUM_VOLUMES >= cVolumes )
    }
    __finally
    {
        if( INVALID_HANDLE_VALUE != hFindVolume )
            FindVolumeClose( hFindVolume );

        if( NULL != pVolNode )
            delete pVolNode;

    }

}

//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::AddNodeToLinkedList
//
//  Adds a CVolumeNode (and its embedded CVolume) to the volume manager's
//  linked list.
//
//  The CVolumeNode elements in the linked list are kept sorted in
//  increasing address order.  This is so a CVolumeEnumerator can handle a
//  node being deleted while such an enumeration is active.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::AddNodeToLinkedList( CVolumeNode *pVolNode )
{
    TrkAssert( _fInitialized );
    _csVolumeNodeList.Enter();
    __try
    {
        if( NULL == _pVolumeNodeListHead )
        {
            pVolNode->_pNext = NULL;
            _pVolumeNodeListHead = pVolNode;
        }
        else if( pVolNode < _pVolumeNodeListHead )
        {
            pVolNode->_pNext = _pVolumeNodeListHead;
            _pVolumeNodeListHead = pVolNode;
        }
        else
        {
            CVolumeNode *pNode = _pVolumeNodeListHead;
            while( NULL != pNode->_pNext && pNode->_pNext < pVolNode )
                pNode = pNode->_pNext;

            if( NULL == pNode->_pNext )
            {
                TrkAssert( pNode < pVolNode );
                pNode->_pNext = pVolNode;
                pVolNode->_pNext = NULL;
            }
            else
            {
                TrkAssert( pNode < pVolNode );
                TrkAssert( pNode->_pNext > pVolNode );
                pVolNode->_pNext = pNode->_pNext;
                pNode->_pNext = pVolNode;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkAssert( !TEXT("Unexpected exception in CVolumeManager::AddNodeToLinkedList") );
    }
    _csVolumeNodeList.Leave();
}



//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::RemoveVolumeFromLinkedList
//
//  Removes a volume from the volume manager's linked list.
//  The CVolume is Released (which may or may not make it go away, depending
//  on ref-counts), and the CVolumeNode is deleted.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::RemoveVolumeFromLinkedList( const CVolume *pvol )
{
    CVolumeNode **ppvolnodePrev = NULL;
    CVolumeNode *pvolnode = NULL;

    TrkAssert( _fInitialized );
    _csVolumeNodeList.Enter();
    __try
    {
        pvolnode = _pVolumeNodeListHead;
        ppvolnodePrev = &_pVolumeNodeListHead;

        while( NULL != pvolnode )
        {
            if( pvol == pvolnode->_pVolume )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Removing volume %p from the list"), pvolnode->_pVolume ));

                CVolumeNode *pvolnodeDel = pvolnode;
                *ppvolnodePrev = pvolnode->_pNext;

                // Releasing the volume will usually cause it to delete itself, unless
                // someone else is holding a ref on it.

                pvolnodeDel->_pVolume->Release();
                delete pvolnodeDel;

                break;
            }
            else
            {
                ppvolnodePrev = &pvolnode->_pNext;
                pvolnode = pvolnode->_pNext;
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
    }
    _csVolumeNodeList.Leave();

}

void
CVolumeManager::CloseVolumeHandles( HDEVNOTIFY hdnVolume )
{
    CVolumeEnumerator   volEnum = Enum();
    CVolume*            vol = volEnum.GetNextVolume();

    while (vol != NULL)
    {
        __try
        {
            vol->CloseVolumeHandles( hdnVolume );
        }
        __except( BreakOnDebuggableException() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CloseVolumeHandles (%08x)"),
                     GetExceptionCode() ));
        }

        vol->Release();
        vol = volEnum.GetNextVolume();
    }
}

void
CVolumeManager::CleanUpOids()
{
    CVolumeEnumerator   volEnum = Enum();
    CVolume*            vol = volEnum.GetNextVolume();

    while(vol != NULL)
    {
        if(vol->IsMarkedForMakeAllOidsReborn())
        {
            __try
            {
                if( vol->MakeAllOidsReborn() )
                    vol->ClearMarkForMakeAllOidsReborn();
            }
            __except( BreakOnDebuggableException() )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring exception in CVolumeManager::CleanUpOids") ));
            }
        }

        vol->Release();
        vol = volEnum.GetNextVolume();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::SyncVolumes
//
//  Give each active volume an opportunity to synchronize with trksvr.
//  This allows the volumes to create a new ID, claim an existing ID,
//  etc.
//
//  Note:: This routine is guaranteed not to raise.
//
//+----------------------------------------------------------------------------

BOOL
CVolumeManager::SyncVolumes( EAggressiveness eAggressiveness,
                             CFILETIME cftLastDue,
                             ULONG ulPeriodInSeconds )
{
    BOOL fSuccess = FALSE;
    BOOL fDoRetry = FALSE;
    CAvailableDc adc;
    CVolumeEnumerator   volEnum;
    CVolume*            pvol;
    BOOL                fIsOnlyInstance = FALSE;

    __try
    {

        TRKSVR_SYNC_VOLUME   rgSyncVolumes[ NUM_VOLUMES ];
        TRKSVR_MESSAGE_UNION Msg;
        ULONG                cVolumes = 0;
        const CVolumeId      volNULL;
        BOOL                 fSyncNeeded;

        // If there's already a thread doing a SyncVolumes, we don't need to
        // do it again simultaneously.

        fIsOnlyInstance = BeginSingleInstanceTask( &_cSyncVolumesInProgress );
        if( !fIsOnlyInstance )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Skipping SyncVolumes, another instance already in progress") ));
            fSuccess = TRUE;
            goto Exit;
        }

        // If we haven't fully initialized the volumes yet, do so now.
        ReopenVolumeHandles();

        // Start a CVolume enumeration

        volEnum = Enum();
        pvol = volEnum.GetNextVolume();

        // Loop through the enumerated volumes.
        // When we're done, cVolumes will show the count of volumes
        // that requested to sync with trksvr (could be zero).

        while ( NULL != pvol )
        {
            BOOL fFound = FALSE;

            // Add this volume to the array of volumes needing update with trksvr.
            // If this particular volume turns out not to need an update, we won't
            // increment cVolumes, consequently it will get overwritten on the
            // next pass.  If this volume does need an update, we'll addref it.

            _rgVolumesToUpdate[cVolumes] = pvol;

            // Call the volume to load the sync-volume request.

            if(TRUE == pvol->LoadSyncVolume(&rgSyncVolumes[cVolumes], eAggressiveness, &fSyncNeeded))
            {
                // The LoadSyncVolumes request succeeded.  
                // Does the volume need a sync with trksvr?

                if(fSyncNeeded == FALSE)
                {
                    // No, the volume doesn't need a sync.  It's
                    // apparantly neither new nor newly attached.

                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Volume %c is properly ID-ed already"),
                             'A'+pvol->GetIndex() ));
                }
                else if(rgSyncVolumes[cVolumes].SyncType == CREATE_VOLUME)
                {
                    // This is a newly-formatted volume.
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Having a new ID created for volume %c"),
                             TEXT('A')+pvol->GetIndex() ));
                    _rgVolumesToUpdate[cVolumes]->AddRef();
                    cVolumes++;
                }
                else
                {
                    // The volume is new to this machine
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Claiming volume %c"),
                             TEXT('A')+pvol->GetIndex() ));
                    _rgVolumesToUpdate[cVolumes]->AddRef();
                    cVolumes++;
                }
            }
            else
            {
                // The volume needs to be synced but failed for some reason
                TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                         TEXT("Volume %c can not be synced"),
                         'A'+pvol->GetIndex() ));
            }

            // Move on to the next item in the enumeration.
            // If this volumes needs an update, it's addref-ed in 
            // _rgVolumesToUpdate.

            pvol->Release();
            pvol = volEnum.GetNextVolume();

        }   // while ( vol != NULL )


        // Were there any volumes in need of a sync with trksvr?

        if( 0 != cVolumes )
        {
            // Yes, send the sync_volumes request.

            __try
            {
                HRESULT hr;

                // Construct the Msg union

                Msg.MessageType = SYNC_VOLUMES;

                Msg.Priority = (0 == ulPeriodInSeconds)
                                    ? PRI_6
                                    : GetSvrMessagePriority( cftLastDue, ulPeriodInSeconds );

                Msg.SyncVolumes.cVolumes = cVolumes;

                Msg.SyncVolumes.pVolumes = rgSyncVolumes;
#ifdef VOL_REPL
                Msg.SyncVolumes.cChanges = 0;
                Msg.SyncVolumes.ppVolumeChanges = NULL;
#endif

                // Send the request to trksvr.  We pass it under privacy encryption
                // because there could be a volume secret in it.
                // This will raise if there's an error.

                hr = adc.CallAvailableDc(&Msg, PRIVACY_AUTHENTICATION );

                // now we've successfully told the DC we should update the
                // DcInformed flags

                TrkLog((TRKDBG_VOLUME, TEXT("CallAvailableDc returned %d volumes (%08X)"),
                         Msg.SyncVolumes.cVolumes, hr ));

                // See if there were problems and we should do a retry
                // (This gets set in the DcCallback method).

                if( TRK_S_VOLUME_NOT_SYNCED == hr )
                    fDoRetry = TRUE;

                // Process the responses

                for( ULONG v = 0; v < Msg.SyncVolumes.cVolumes; v++ )
                {
                    // If the problem is server-too-busy, have the caller do 
                    // a retry.  Otherwise (e.g. quota error) ignore the error.
                    // E.g. for a quota error, we'll ignore the error, but the
                    // volume will still be in a not-created state, and we'll
                    // retry the next time the infrequent timer fires.

                    if( TRK_E_SERVER_TOO_BUSY == rgSyncVolumes[v].hr )
                        fDoRetry = TRUE;

                    if( _rgVolumesToUpdate[v]->UnloadSyncVolume( &rgSyncVolumes[v] )
                        &&
                        rgSyncVolumes[v].hr == S_OK
                      )
                    {
                        TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                                 TEXT("Volume %c successfully synced with server"),
                                 'A'+_rgVolumesToUpdate[v]->GetIndex() ));
                    }
                    else
                    {
                        TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                                 TEXT("Couldn't sync vol %c with server (%08x, %s)"),
                                 'A'+_rgVolumesToUpdate[v]->GetIndex(),
                                 rgSyncVolumes[v].hr, GetErrorString(rgSyncVolumes[v].hr) ));
                    }
                }   // for( v = 0; v < Msg.SyncVolumes.cVolumes; v++ )
            }
            __finally
            {
                for( ULONG v = 0; v < cVolumes; v++ )
                {
                    _rgVolumesToUpdate[v]->Release();
                }
            }

        }   // if( 0 != cVolumes )

        // If any volids have been changed, make all the existing object IDs
        // reborn.

        CleanUpOids();

        fSuccess = TRUE;

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't sync with server (0x%08x)"), GetExceptionCode() ));
    }

    if( pvol != NULL )
    {
        pvol->Release();
    }

Exit:

    if( fIsOnlyInstance )
        EndSingleInstanceTask( &_cSyncVolumesInProgress );

    return fSuccess && !fDoRetry;
}


void
CVolumeManager::Append( const CDomainRelativeObjId &droidCurrent,
                        const CDomainRelativeObjId &droidNew,
                        const CMachineId           &mcidNew,
                        const CDomainRelativeObjId &droidBirth)
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume*            cvolCur = enumerator.GetNextVolume();
    BOOL                fVolumeFound = FALSE;

    __try   // __finally
    {

        while ( cvolCur != NULL )
        {
            if( cvolCur->GetVolumeId() == droidCurrent.GetVolumeId())
            {
                fVolumeFound = TRUE;
                cvolCur->Append(droidCurrent, droidNew, mcidNew, droidBirth);
                break;
            }

            cvolCur->Release();
            cvolCur = enumerator.GetNextVolume();
        }
    }
    __finally
    {
        if (cvolCur != NULL)
        {
            cvolCur->Release();
        }
    }

    if( !fVolumeFound )
        TrkRaiseNtStatus( STATUS_NO_TRACKING_SERVICE );
}


// search all volumes (and each log) or just the given volume
//
// S_OK || TRK_E_NOT_FOUND || TRK_E_REFERRAL

HRESULT
CVolumeManager::Search( DWORD Restrictions,
                        const CDomainRelativeObjId & droidBirthLast,
                        const CDomainRelativeObjId & droidLast,
                        CDomainRelativeObjId * pdroidBirthNext,
                        CDomainRelativeObjId * pdroidNext,
                        CMachineId           * pmcidNext,
                        TCHAR                * ptszLocalPath )
{
    NTSTATUS status;
    HRESULT hr = TRK_E_NOT_FOUND;
    CVolumeEnumerator   enumerator;
    CVolume*            pvol = NULL;
    const CMachineId mcidLocal( MCID_LOCAL );
    BOOL fPotentialFile = FALSE;
    CDomainRelativeObjId droidZero;

    // Local working stores for what we'll return in pdroidNew & pmcidNew
    // if we have a referral.

    CDomainRelativeObjId droidBirthNext = droidBirthLast;
    CDomainRelativeObjId droidNext = droidLast;
    CMachineId           mcidNext = mcidLocal;

    __try   // __finally
    {

        g_ptrkwks->RaiseIfStopped();

        //  -------------------------------
        //  Search the volumes for the file
        //  -------------------------------

        // Search the last volume first, then search all the volumes.
        // Thus we'll end up searching droidLast.GetVolumeId() twice.
        // This is necessary, though, because there could be multiple
        // local volumes with this volid.

        if( !(Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES) )
            enumerator = Enum();

        if( !(Restrictions & TRK_MEND_DONT_USE_VOLIDS) )
            pvol = FindVolume( droidLast.GetVolumeId() );

        if( NULL == pvol )
            pvol = enumerator.GetNextVolume();

        for( ; NULL != pvol; pvol = enumerator.GetNextVolume() )
        {
            status = FindLocalPath( pvol->GetIndex(), droidLast.GetObjId(),
                                    &droidBirthNext, &ptszLocalPath[2] );
            if( NT_SUCCESS(status) )
            {
                // Is this in the SystemVolumeInformation directory?  If so, we'll
                // pretend we didn't find it (it's probably in the System Recovery
                // directory).

                if( IsSystemVolumeInformation( &ptszLocalPath[2] ))
                {
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND,
                             TEXT("CVolumeManager::Search ignoring %c:%s"),
                             VolChar(pvol->GetIndex()), &ptszLocalPath[2] ));
                }

                // Or, is this the correct birth ID (or the caller doesn't want us to check)?
                else if( droidBirthLast == droidBirthNext
                         ||
                         droidBirthLast == droidZero )
                {
                    // Yes.  We've found our file and we're done.

                    // Give the path a drive letter
                    TrkAssert( -1 != pvol->GetIndex() );
                    ptszLocalPath[0] = VolChar(pvol->GetIndex());
                    ptszLocalPath[1] = TEXT(':');

                    // droidBirthNext is already set by FindLocalPath
                    droidNext = CDomainRelativeObjId( pvol->GetVolumeId(), droidLast.GetObjId() );
                    mcidNext = mcidLocal;

                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND, TEXT("CVolumeManager::Search found %s"),
                             ptszLocalPath ));

                    hr = S_OK;
                    fPotentialFile = FALSE;
                    __leave;
                }

                // Otherwise, is it the first potential hit?
                else if( !fPotentialFile )
                {
                    // We found a file with the right object ID, but the wrong birth ID.
                    // By rule of law, it's therefore not the right file.  However, it could be
                    // the right file, but was re-born due to a volid change.  So we'll keep
                    // it and let the caller (eventually, the user) decide.

                    // Give the path a drive letter
                    ptszLocalPath[0] = VolChar(pvol->GetIndex());
                    ptszLocalPath[1] = TEXT(':');

                    // droidBirthNext is already set by FindLocalPath
                    droidNext = CDomainRelativeObjId( pvol->GetVolumeId(), droidLast.GetObjId() );
                    mcidNext = mcidLocal;

                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND,
                             TEXT("CVolumeManager::Search found *potential* %s"),
                             ptszLocalPath ));

                    fPotentialFile = TRUE;
                }
            }

            pvol->Release(); pvol = NULL;

        }   // for( ; NULL != pvol, pvol = enumerator.GetNextVolume() );
        enumerator.UnInitialize();

        // We didn't find the file on any of the volumes, let's search the logs
        // to see if they know where it went.

        //  ---------------------
        //  Search the local logs
        //  ---------------------

        if( Restrictions & TRK_MEND_DONT_USE_LOG )
            __leave;

        // Start by searching the log of the last volume, then enumerate through all the
        // volume logs.  Again we'll end up searching the last volume twice, because
        // there could be dup volids.

        if( !(Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES) )
            enumerator = Enum();

        if( !(Restrictions & TRK_MEND_DONT_USE_VOLIDS) )
            pvol = FindVolume( droidLast.GetVolumeId() );

        if( NULL == pvol )
            pvol = enumerator.GetNextVolume();

        for( ; NULL != pvol; pvol = enumerator.GetNextVolume() )
        {
            CDomainRelativeObjId droidNextT, droidBirthT;
            CMachineId mcidNextT;

            if (pvol->Search( droidLast, &droidNextT, &mcidNextT, &droidBirthT ))
            {
                // We found a match in the log.

                TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND, TEXT("Referral on vol %c: %s\n  => %s:%s"),
                         VolChar(pvol->GetVolIndex()),
                         (const TCHAR*)CDebugString(droidLast.GetObjId()),
                         (const TCHAR*)CDebugString(mcidNextT),
                         (const TCHAR*)CDebugString(droidNextT) ));

                // If the volid is useful (it's non-NULL and non-local), keep these IDs
                // as the best to return.

                if( CVolumeId() != droidNextT.GetVolumeId()
                    &&
                    (  !IsLocal( droidNextT.GetVolumeId() )
                       ||
                       droidLast.GetObjId() != droidNextT.GetObjId()
                       ||
                       (Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
                    )
                  )
                {
                    hr = TRK_E_REFERRAL;
                    droidBirthNext = droidBirthLast;
                    droidNext = droidNextT;
                    mcidNext = mcidNextT;

                    fPotentialFile = FALSE;
                    break;
                }

                // Or, if the mcid is useful (not this machine), keep the IDs as the
                // best to return

                else if( CMachineId() != mcidNextT
                         &&
                         ( mcidLocal != mcidNextT
                           ||
                           (Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
                         )
                       )
                {
                    hr = TRK_E_REFERRAL;
                    droidBirthNext = droidBirthLast;
                    mcidNext = mcidNextT;
                    droidNext = droidNextT;

                    fPotentialFile = FALSE;
                    break;
                }
            }

            pvol->Release(); pvol = NULL;

        }   // for( ; NULL != pvol, pvol = enumerator.GetNextVolume() );

    }   // __try
    _finally
    {
        if( NULL != pvol )
        {
            pvol->Release();
            pvol = NULL;
        }

        enumerator.UnInitialize();
    }

    // If we didn't find the file or a referral, but did find a potential hit,
    // return that potential hit.

    if( TRK_E_NOT_FOUND == hr && fPotentialFile )
        hr = TRK_E_POTENTIAL_FILE_FOUND;

    if( SUCCEEDED(hr) || TRK_E_REFERRAL == hr || TRK_E_POTENTIAL_FILE_FOUND == hr )
    {
        *pdroidBirthNext = droidBirthNext;
        *pmcidNext       = mcidNext;
        *pdroidNext      = droidNext;
    }

    return( hr );
}

PTimerCallback::TimerContinuation
CVolumeManager::Timer( DWORD dwTimerId )
{
    PTimerCallback::TimerContinuation continuation = CONTINUE_TIMER;

    __try
    {
        switch ( dwTimerId )
        {
        case VOLTIMER_OBJID_INDEX_REOPEN:
            TrkAssert( _timerObjIdIndexReopen.IsRecurring() );

            if( ReopenVolumeHandles() ) // Raises if service is stopped
                continuation = BREAK_TIMER;
            else
                continuation = RETRY_TIMER;

            break;

        case VOLTIMER_FREQUENT:
        case VOLTIMER_INFREQUENT:
        case VOLTIMER_INIT:

            TrkAssert( !_timerFrequentTasks.IsRecurring() );
            TrkAssert( !_timerInfrequentTasks.IsRecurring() );
            TrkAssert( !_timerVolumeInit.IsRecurring() );

            continuation = OnVolumeTimer( dwTimerId );
            break;

        // Time to send MoveNotifies to the DC
        case VOLTIMER_NOTIFY:

            TrkAssert( !_timerNotify.IsRecurring() );
            TrkAssert( CNewTimer::RETRY_WITH_BACKOFF == _timerNotify.GetRetryType() );

            __try
            {
                continuation = _pTrkWks->OnMoveBatchTimeout();
            }
            __except( BreakOnDebuggableException() )
            {
                // If there was an unexpected error, instead of retrying the
                // MoveNotify timer, use the slower (thus DC-friendlier) VolInit
                // timer.

                TrkLog(( TRKDBG_ERROR, TEXT("Server to busy to receive move notifications, starting VolInit timer") ));
                continuation = BREAK_TIMER;
                SetVolInitTimer();
            }

            break;

        // Time to refresh the DC with all our active IDs
        case VOLTIMER_REFRESH:

            // The first time we're called, we hesitate for a random amount of time.
            // This hesitation is implemented by setting a flag, then resetting the timer.
            // When the timer fires again a little later, we'll do the real work.

            if( !_fRefreshHesitation )
            {
                // This is the first time we've been called.

                ULONG ulHesitation = 0;

                // Delay a random number of seconds within an interval

                _fRefreshHesitation = TRUE;

                ulHesitation = QuasiRandomDword()
                               %
                               ( 1 + _pTrkWksConfiguration->GetRefreshHesitation() );

                TrkLog(( TRKDBG_LOG, TEXT("Hesitating %d seconds before executing refresh"), ulHesitation ));
                _timerRefresh.ReInitialize( ulHesitation );
                continuation = CONTINUE_TIMER;
            }
            else
            {
                TrkAssert( _timerRefresh.IsRecurring() );
                continuation = _pTrkWks->OnRefreshTimeout(
                                    _timerRefresh.QueryOriginalDueTime(),
                                    _pTrkWksConfiguration->GetRefreshPeriod() );

                if( CONTINUE_TIMER == continuation )
                {
                    _timerRefresh.ReInitialize( _pTrkWksConfiguration->GetRefreshPeriod() );
                    _fRefreshHesitation = FALSE;
                }
            }

            break;


        default:
            TrkAssert( 0 && "invalid timer id" );
            break;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring exception %08x in CVolumeManager::Timer"),
                 GetExceptionCode() ));
    }


    return( continuation );
}


BOOL
CVolumeManager::ReopenVolumeHandles()
{
    BOOL fAllOk = TRUE;

    // If there's another thread already executing this routine, we'll just skip out.
    // This is a reasonable idea, but really shouldn't be necessary; the volumes
    // can protect themselves, and one thread should basically noop.  However,
    // there was an iostress break where these two threads got each other into
    // a deadly embrace.  This was due to the fact that the win32 thread pool
    // has the tendency to put multiple IO work items on the same thread (since
    // it queues to IO threads using APCs).  So as a workaround, don't run
    // this method more than once at a time.

    if( !BeginSingleInstanceTask( &_cReopenVolumeHandles ))
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Skipping ReopenVolumeHandles, another instance is already in progress") ));
        return FALSE;
    }

    // Get a volume enumerator.  After initialization, none of the volumes 
    // have yet been opened.  Ordinarily the Enum method gives us nothing until
    // they've been opened once.  But this routine is the one that originally does
    // the opens, so we need the enumerator to give us everything.

    CVolumeEnumerator enumerator = Enum( ENUM_UNOPENED_VOLUMES );

    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("\nAttempting to reopen all volume handles") ));

    for( CVolume* pVol = enumerator.GetNextVolume();
         pVol != NULL;
         pVol = enumerator.GetNextVolume())
    {
        __try
        {
            if( !pVol->ReopenVolumeHandles() )
                fAllOk = FALSE;
        }
        __except(BreakOnDebuggableException())
        {
            fAllOk = FALSE;
        }
        pVol->Release();
    }

    // Show that at least an attempt has been made to open all
    // volume handles.  This is checked in Enum().
    _fVolumesHaveBeenOpenedOnce = TRUE;

    // Show that we're done with this method.
    EndSingleInstanceTask( &_cReopenVolumeHandles );

    TrkLog(( TRKDBG_OBJID_DELETIONS,
             fAllOk ? TEXT("All volume handles are open") : TEXT("Not all volume handles are open") ));
    return( fAllOk );
}


void
CVolumeManager::VolumeDeviceEvent( HDEVNOTIFY hdnVolume, EVolumeDeviceEvent eVolumeDeviceEvent )
{
    CVolumeEnumerator enumerator = Enum();
    BOOL fAllOk = TRUE;

    for( CVolume* pVol = enumerator.GetNextVolume();
         pVol != NULL;
         pVol = enumerator.GetNextVolume() )
    {
        __try
        {
            switch( eVolumeDeviceEvent )
            {
            case ON_VOLUME_LOCK:
                pVol->OnVolumeLock( hdnVolume );
                break;
            case ON_VOLUME_UNLOCK:
                pVol->OnVolumeUnlock( hdnVolume );
                break;
            case ON_VOLUME_LOCK_FAILED:
                pVol->OnVolumeLockFailed( hdnVolume );
                break;

            case ON_VOLUME_MOUNT:
                pVol->OnVolumeMount( hdnVolume );
                break;
            case ON_VOLUME_DISMOUNT:
                pVol->OnVolumeDismount( hdnVolume );
                break;

            case ON_VOLUME_DISMOUNT_FAILED:
                pVol->OnVolumeDismountFailed( hdnVolume );
                break;

            default:
                TrkLog(( TRKDBG_ERROR, TEXT("Invalid event to OnVolumeDeviceEvent (%d)"),
                         eVolumeDeviceEvent ));
                TrkAssert( !TEXT("Invalid event to OnVolumeDeviceEvent") );
                break;

            }   // switch( eVolumeDeviceEvent )
        }
        __except(BreakOnDebuggableException())
        {
        }
        pVol->Release();
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::OnEntriesAvailable
//
//  The CLog calls this routine when it has new data available
//  for us to read.  We don't read it right away, but start the Notify timer.
//  When it goes off, we'll upload all notifications to the DC that haven't
//  yet been sent.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::OnEntriesAvailable()
{
    if( !_pTrkWksConfiguration->_fIsWorkgroup )
    {
        _timerNotify.SetSingleShot();

        TrkLog(( TRKDBG_MOVE | TRKDBG_WKS,
                 TEXT("log called CVolumeManager::OnEntriesAvailable(), %s"),
                 (const TCHAR*)CDebugString(_timerNotify) ));
    }

}





//+----------------------------------------------------------------------------
//
//  CVolumeManager::ForceVolumeClaims
//
//  Put all of the volumes in the not-owned state so that they will
//  try to do a claim.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::ForceVolumeClaims()
{
    CVolumeEnumerator enumerator = Enum();

    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Force volume claims") ));

    for( CVolume* pVol = enumerator.GetNextVolume();
         pVol != NULL;
         pVol = enumerator.GetNextVolume())
    {
        __try
        {
            pVol->SetState(CVolume::VOL_STATE_NOTOWNED);
        }
        __except(BreakOnDebuggableException())
        {
        }
        pVol->Release();
    }

    // Do a SyncVolumes so that the volumes can all send up a
    // volume-claim request.  If it fails, just start the volinit
    // timer to have it called again later.

    if( !SyncVolumes( AGGRESSIVE ))    // Doesn't raise
        SetVolInitTimer();
}

PTimerCallback::TimerContinuation
CVolumeManager::OnVolumeTimer( DWORD dwTimerId )
{
    ULONG ulTimerResetPeriod = 0;
    BOOL  fTimerRetry = FALSE;
    CNewTimer * ptimer;
    PTimerCallback::TimerContinuation continuation = CONTINUE_TIMER;

    __try
    {
        switch( static_cast<VOLTIMERID>(dwTimerId) )
        {

        // Initialization tasks
        // This timer is started during initialization, and then usually stops after
        // one iteration.  It can be restarted, however, if a MoveNotify gets a
        // TRK_E_SERVER_TOO_BUSY error.

        case VOLTIMER_INIT:

            TrkLog(( TRKDBG_VOLUME, TEXT("VolInit timer has fired") ));

            ptimer = &_timerVolumeInit;
            TrkAssert( CNewTimer::RETRY_RANDOMLY == ptimer->GetRetryType() );
            TrkAssert( !ptimer->IsRecurring() );

            // Create/claim volumes as necessary.

            fTimerRetry = TRUE;
            if( SyncVolumes( PASSIVE,
                             _timerVolumeInit.QueryOriginalDueTime(),
                             _timerVolumeInit.QueryPeriodInSeconds() )) // Doesn't raise
                fTimerRetry = FALSE;

            // If we have a new volid, make the existing object IDs reborn.
            CleanUpOids();

            // Give each of the volumes an opportunity to upload any pending
            // MoveNotifies.

            // BUGBUG:  Move the MoveBatchTimeout controlling code into CVolumeManager,
            // so that all such control is in one place.

            __try
            {
                continuation = g_ptrkwks->OnMoveBatchTimeout();
            }
            __except( BreakOnDebuggableException() )
            {
                TrkAssert( TRK_E_SERVER_TOO_BUSY == GetExceptionCode() );
                TrkLog(( TRKDBG_ERROR, TEXT("VolInit timer caught %08x during MoveNotify"), GetExceptionCode() ));
                fTimerRetry = TRUE;
            }

            break;

        // Frequent tasks (i.e. ~daily)

        case VOLTIMER_FREQUENT:
            ptimer = &_timerFrequentTasks;

            if( _fFrequentTaskHesitation )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Executing frequent tasks") ));
                _fFrequentTaskHesitation = FALSE;
                ulTimerResetPeriod = _pTrkWksConfiguration->GetVolFrequentTasksPeriod() + 1;
                SyncVolumes( PASSIVE );  // Doesn't raise
                ReopenVolumeHandles();
            }
            else
            {
                // Delay a random number of seconds within an interval

                _fFrequentTaskHesitation = TRUE;
                ulTimerResetPeriod = QuasiRandomDword()
                                     %
                                     (1+_pTrkWksConfiguration->GetVolPeriodicTasksHesitation());
                ulTimerResetPeriod++;
                TrkLog(( TRKDBG_VOLUME, TEXT("Hesitating %d seconds before executing frequent tasks"), ulTimerResetPeriod ));
            }

            break;

        // Infrequent tasks (i.e. ~weekly)

        case VOLTIMER_INFREQUENT:
            ptimer = &_timerInfrequentTasks;

            if( _fInfrequentTaskHesitation )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Executing infrequent tasks") ));
                _fInfrequentTaskHesitation = FALSE;
                ulTimerResetPeriod = _pTrkWksConfiguration->GetVolInfrequentTasksPeriod() + 1;
                CheckSequenceNumbers();

                // Be aggressive about the sync; if we have not-created volumes, try
                // to create them again even if the last time we got a vol-quota-exceeded
                // error.

                SyncVolumes( AGGRESSIVE );  // Doesn't raise

                // Give each of the volumes an opportunity to upload any pending
                // MoveNotifies.  Again, be aggressive about it in the face of previous
                // quota errors.

                g_ptrkwks->OnMoveBatchTimeout( AGGRESSIVE );

            }
            else
            {
                // Delay a random number of seconds within an interval

                _fInfrequentTaskHesitation = TRUE;
                ulTimerResetPeriod = QuasiRandomDword()
                                     %
                                     (1+_pTrkWksConfiguration->GetVolPeriodicTasksHesitation());
                ulTimerResetPeriod++;
                TrkLog(( TRKDBG_VOLUME, TEXT("Hesitating %d seconds before executing infrequent tasks"), ulTimerResetPeriod ));
            }

            break;

        default:

            TrkAssert( FALSE && TEXT("Invalid timerID in CVolumeManager::Timer") );
            break;

        }   // switch
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolumeManager::OnVolumeTimer %08x"), GetExceptionCode() ));
    }

    if( fTimerRetry )
        continuation = RETRY_TIMER;
    else if( 0 != ulTimerResetPeriod )
    {
        ptimer->ReInitialize( ulTimerResetPeriod );
        ptimer->SetSingleShot();
        continuation = CONTINUE_TIMER;
    }

    return( continuation );
}

ULONG
CVolumeManager::GetVolumeIds( CVolumeId * pVolumeIds, ULONG cMax )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume*            pvol = enumerator.GetNextVolume();
    ULONG               cVolumes;
    CVolumeId           volidZero;

    __try
    {
        for( cVolumes = 0;
             cVolumes < cMax && NULL != pvol;
             pvol = enumerator.GetNextVolume()
           )
        {
            *pVolumeIds = pvol->GetVolumeId();
            if (*pVolumeIds != volidZero)
            {
                pVolumeIds ++;
                cVolumes ++;
            }
            pvol->Release();
            pvol = NULL;
        }
    }
    __finally
    {
        enumerator.UnInitialize();
        if(pvol)
        {
            pvol->Release();
            pvol = NULL;
        }
    }

    return(cVolumes);
}


HRESULT
CVolumeManager::OnRestore()
{
    return( E_NOTIMPL );
#if 0

    CVolumeEnumerator   enumerator = Enum();
    CVolume*            pvol = enumerator.GetNextVolume();
    HRESULT             hr = S_OK;
    HRESULT             hrRet = S_OK;

    __try
    {
        for(; NULL != pvol; pvol = enumerator.GetNextVolume())
        {
            hr = pvol->OnRestore();
            if(hr != S_OK && hrRet == S_OK)
            // Return the hr from the first failed volume.
            {
                hrRet = hr;
            }
            pvol->Release();
            pvol = NULL;
        }
    }
    __finally
    {
        enumerator.UnInitialize();
        if(pvol)
        {
            pvol->Release();
            pvol = NULL;
        }
    }


    return hr;

#endif // #if 0

}

BOOL
CVolumeManager::CheckSequenceNumbers()
{
    BOOL fSuccess = FALSE;
    HRESULT hr = S_OK;
    CAvailableDc adc;
    CVolume* rgVolsToCheck[ NUM_VOLUMES ];
    ULONG cVolumes = 0;

    __try
    {
        TRKSVR_SYNC_VOLUME      rgQueryVolumes[ NUM_VOLUMES ];
        ULONG                   v;
        const CVolumeId         volNULL;
        CVolumeEnumerator       enumerator = Enum();
        CVolume*                cvolCur = enumerator.GetNextVolume();

        for(; cvolCur != NULL; cvolCur = enumerator.GetNextVolume())
        {
            rgVolsToCheck[cVolumes] = cvolCur;
            if(cvolCur->LoadQueryVolume(&rgQueryVolumes[cVolumes]))
            {
                cVolumes++;
            }
            else
            {
                cvolCur->Release();
            }
        }

        if( 0 != cVolumes )
        {
            TrkLog(( TRKDBG_VOLUME  | TRKDBG_MOVE, TEXT("Verifying sequence numbers on %d volumes"), cVolumes ));

            _pTrkWks->CallDcSyncVolumes(cVolumes, rgQueryVolumes);


            for( v = 0; v < cVolumes; v++ )
            {
                if( rgVolsToCheck[v]->UnloadQueryVolume( &rgQueryVolumes[v] )
                    &&
                    S_OK == rgQueryVolumes[ v ].hr )
                {
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Seq number for volume %c should be %d"),
                             'A'+rgVolsToCheck[v]->GetIndex(),
                             rgQueryVolumes[v].seq ));
                }
                else
                {
                    TrkLog(( TRKDBG_ERROR,
                             TEXT("Couldn't verify the seq number on vol %c"),
                             'A'+rgVolsToCheck[v]->GetIndex() ));

                }
            }   // for( v = 0; v < cVolumes; v++ )

            fSuccess = TRUE;

        }   // if( cVolumes != 0 )
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Couldn't check sequence numbers against server"), GetExceptionCode() ));
    }

    for( ULONG v = 0; v < cVolumes; v++ )
    {
        rgVolsToCheck[v]->Release();
    }   // for( v = 0; v < cVolumes; v++ )

    return( fSuccess );

}

void
CVolumeManager::SetReopenVolumeHandlesTimer()
{
    CFILETIME ft;

    // Start the timer (if it's not already running).
    _timerObjIdIndexReopen.SetRecurring();

    TrkLog(( TRKDBG_VOLUME, TEXT("ReOpen timer: %s"),
             (const TCHAR*)CDebugString(_timerObjIdIndexReopen) ));
}

CVolumeEnumerator
CVolumeManager::Enum( EEnumType eEnumType )
{
    CVolumeEnumerator volenum;

    if( _fVolumesHaveBeenOpenedOnce
        ||
        _fInitialized
        &&
        ENUM_UNOPENED_VOLUMES == eEnumType )
    {
        volenum = CVolumeEnumerator( &_pVolumeNodeListHead, &_csVolumeNodeList );
    }

    return( volenum );
}

CVolume *
CVolumeManager::FindVolume( const CVolumeId &vol )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume             *pvol = enumerator.GetNextVolume();

    for(; pvol != NULL; pvol = enumerator.GetNextVolume())
    {
        if( pvol->GetVolumeId() == vol )
        {
            break;
        }
        pvol->Release();
    }   // for(; pvol != NULL; pvol = enumerator.GetNextVolume())

    return( pvol );
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::FlushAllVolumes
//
//  Flush all of the volumes.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::FlushAllVolumes( BOOL fServiceShutdown )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume             *pvol = enumerator.GetNextVolume();

    for(; pvol != NULL; pvol = enumerator.GetNextVolume())
    {
        __try
        {
            pvol->Flush( fServiceShutdown );
        }
        __except( BreakOnDebuggableException() )
        {
        }
        pvol->Release();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::FindVolume
//  
//  Find a volume in the linked-list, given it's device name,
//  and return its CVolume*.
//
//+----------------------------------------------------------------------------

CVolume *
CVolumeManager::FindVolume( const TCHAR *ptszVolumeDeviceName )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume             *pvol = enumerator.GetNextVolume();

    for(; pvol != NULL; pvol = enumerator.GetNextVolume())
    {
        if( 0 == _tcscmp( pvol->GetVolumeDeviceName(), ptszVolumeDeviceName ))
        {
            break;
        }
        pvol->Release();
    }   // for(; pvol != NULL; pvol = enumerator.GetNextVolume())

    return( pvol );
}




//+----------------------------------------------------------------------------
//
//  CVolumeManager::IsDuplicatevolId
//
//  Check to see if there is a volume, aside from the caller, that
//  has a particular volume ID.  This should never happen, so this
//  method allows a volume to check for it and respond appropriately.
//
//  When checking another volume's volid, we can't take its lock.
//  See the description in CVolume::GetVolumeId.
//
//+----------------------------------------------------------------------------

CVolume *
CVolumeManager::IsDuplicateVolId( CVolume *pvolCheck, const CVolumeId &volid )
{
    CVolumeNode *pVolNode = NULL;
    CVolume *pvol = NULL;
    
    _csVolumeNodeList.Enter();
    __try
    {
    
        pVolNode = _pVolumeNodeListHead;
        while( NULL != pVolNode )
        {
            if( NULL != pVolNode->_pVolume
                &&
                volid == pVolNode->_pVolume->GetVolumeId()    // Doesn't take lock.
                &&
                pvolCheck != pVolNode->_pVolume )
            {
                pvol = pVolNode->_pVolume;
                pvol->AddRef();
                __leave;
            }

            pVolNode = pVolNode->_pNext;
            TrkAssert( pVolNode != _pVolumeNodeListHead );
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in IsDuplicateVolId") ));
    }
    _csVolumeNodeList.Leave();

    return pvol;
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::IsLocal
//
//  Determine if a given volume ID represents a local volume.  Note that
//  if it's not in the linked list of volumes, we'll return false, though
//  the volume may in fact exist on the system (since we don't respond
//  to new volumes after service start).
//
//+----------------------------------------------------------------------------

BOOL
CVolumeManager::IsLocal( const CVolumeId &vol )
{
    CVolume *pvol = FindVolume( vol );

    if( NULL == pvol )
        return FALSE;
    else
    {
        pvol->Release();
        return( TRUE );
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::Seek
//
//  Seek the specified volume's log to the specified sequence number.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::Seek( CVolumeId vol, SequenceNumber seq )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume*            cvolCur = enumerator.GetNextVolume();

    for(; cvolCur != NULL; cvolCur = enumerator.GetNextVolume())
    {
        if( cvolCur->GetVolumeId() == vol )
        {
            cvolCur->Seek( seq );
            cvolCur->Release();
            return;
        }
        cvolCur->Release();
    }   // for( ULONG i = 0; i < 26; i++ )
}


//+----------------------------------------------------------------------------
//
//  CVolumeEnumerator::GetNextVolume
//
//  Get the next CVolume* in the enumeration.
//
//+----------------------------------------------------------------------------

CVolume *
CVolumeEnumerator::GetNextVolume()
{
    CVolume *pVol = NULL;

    if( NULL == _ppVolumeNodeListHead )
        return( NULL );

    TrkAssert( NULL != _pcs );

    _pcs->Enter();
    __try
    {

        if( NULL == *_ppVolumeNodeListHead )
        {
            // There are no volumes in the list
            pVol = NULL;
        }
        else if( NULL == _pVolNodeLast )
        {
            // This is a new enumeration.  Pass back the first volume
            pVol = (*_ppVolumeNodeListHead)->_pVolume;
            _pVolNodeLast = *_ppVolumeNodeListHead;
        }
        else
        {
            // Find the next volume in the list, the one that's
            // just beyond _pVolNodeLast.
            // If we terminate this while loop because pVolNode goes to
            // NULL, it means that there are no more volumes left to
            // enumerate.

            CVolumeNode *pVolNode = *_ppVolumeNodeListHead;
            while( NULL != pVolNode )
            {
                if( pVolNode > _pVolNodeLast )
                {
                    pVol = pVolNode->_pVolume;
                    _pVolNodeLast = pVolNode;
                    break;
                }

                pVolNode = pVolNode->_pNext;
            }
        }

        if( NULL != pVol )
            pVol->AddRef();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkAssert( !TEXT("Unexpected exception in GetNextVolume") );
    }

    _pcs->Leave();
    return( pVol );

}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::DcCallback
//  StubLnkSvrMessageCallback
//
//  When we RPC to trksvr to do a create volume (in the SyncVolumes method),
//  trksvr does an RPC callback on that connection to StubLnkSvrMessageCallback,
//  which in turn calls the DcCallback method.  This was done so that
//  we can verify that the volid actually gets to the volume before taking
//  the hit of writing it into the DS.  (At one point, the request to trksvr
//  was being received, the entry was being put into the DS, but then the
//  response back to trkwks was getting an RPC error, so trkwks would retry
//  the create, etc.
//
//+----------------------------------------------------------------------------

HRESULT CVolumeManager::DcCallback(ULONG cVolumes, TRKSVR_SYNC_VOLUME* rgVolumes)
{
    HRESULT     hr = S_OK;
    BOOL fSuccess = TRUE;

    TrkLog((TRKDBG_VOLUME, TEXT("Dc Callback with %d volumes"), cVolumes ));
    for( ULONG v = 0; v < cVolumes; v++ )
    {
        if( _rgVolumesToUpdate[v]->UnloadSyncVolume( &rgVolumes[v] )
            &&
            rgVolumes[v].hr == S_OK )
        {
            TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                     TEXT("Volume %c successfully synced with server"),
                     'A'+_rgVolumesToUpdate[v]->GetIndex() ));
        }
        else
        {
            fSuccess = FALSE;
            TrkLog(( TRKDBG_ERROR | TRKDBG_MOVE,
                     TEXT("Couldn't sync vol %c with server (%08x, %s)"),
                     'A'+_rgVolumesToUpdate[v]->GetIndex(),
                     rgVolumes[v].hr, GetErrorString(rgVolumes[v].hr) ));
        }
    }   // for( v = 0; v < cVolumes; v++ )


    if( S_OK == hr )
        return fSuccess ? S_OK : TRK_S_VOLUME_NOT_SYNCED;
    else
        return hr;
}



// DC callback function. When calling CAvailableDc::CallAvailableDc, DC will callback to the
// trkwks service to set the volume ids on the volumes.
HRESULT	StubLnkSvrMessageCallback(TRKSVR_MESSAGE_UNION* pMsg)
{
    return g_ptrkwks->_volumes.DcCallback(pMsg->SyncVolumes.cVolumes, pMsg->SyncVolumes.pVolumes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\tbackup.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       tbackup.cxx
//
//  Contents:   testing backup read/write
//
//  History:    1-Aug-97  weiruc      Created.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include <trkwks.hxx>
#include <cfiletim.hxx>
#include <ocidl.h>

// DWORD g_Debug = TRKDBG_ERROR;

#define BUFFERSIZE      1000

EXTERN_C void __cdecl _tmain(int argc, TCHAR **argv)
{ 
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hBackupFile = INVALID_HANDLE_VALUE;
    BYTE        rgbBuffer[BUFFERSIZE];
    DWORD       dwBytesRead = 0;
    DWORD       dwBytesWritten = 0;
    LPVOID      pReadContext = NULL;
    LPVOID      pWriteContext = NULL;
    BOOL        fReadSuccessful = TRUE;

    if(argc != 3)
    {
        _tprintf(TEXT("usage: %s <testfile> <backupfile>\n"), argv[0]);
        goto Exit;
    }

    EnablePrivilege( SE_RESTORE_NAME );

    // open test file
    hFile = CreateFile(argv[1],
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        _tprintf(TEXT("Can't open (%s), %08x\n"), argv[1], GetLastError());
        goto Exit;
    }

    // open backup file
    hBackupFile = CreateFile(argv[2],
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             CREATE_NEW,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);
    if(INVALID_HANDLE_VALUE == hBackupFile)
    {
        _tprintf(TEXT("Can't open (%s), %08x\n"), argv[2], GetLastError());
        goto Exit;
    }

    // All we are doing is to backup read a file and backup write the file to
    // a different file. We are assuming the file is smaller than the
    // BUFFERSIZE.
    while(TRUE)
    {
        if(!BackupRead(hFile,
                       rgbBuffer,
                       BUFFERSIZE,
                       &dwBytesRead,
                       FALSE,
                       FALSE,
                       &pReadContext))
        {
            _tprintf(TEXT("BackupRead failed, %08x\n"), GetLastError());
            break;
        }
        else
        {
            _tprintf(TEXT("    %d bytes read\n"), dwBytesRead);
        }
        if(0 == dwBytesRead)
        {
            break;
        }
        if(!BackupWrite(hBackupFile,
                        rgbBuffer,
                        dwBytesRead,
                        &dwBytesWritten,
                        FALSE,
                        FALSE,
                        &pWriteContext))
        {
            _tprintf(TEXT("BackupWrite failed, %08x\n"), GetLastError());
            break;
        }
        else
        {
            _tprintf(TEXT("    %d bytes wrote\n"), dwBytesWritten);
        }
    }

    // Deallocate data structures used by BackupRead/Write.
    if(!BackupRead(hFile,
                   rgbBuffer,
                   BUFFERSIZE,
                   &dwBytesRead,
                   TRUE,
                   TRUE,
                   &pReadContext))
    {
        _tprintf(TEXT("Last BackupRead failed, %08x\n"), GetLastError());
    }
    if(!BackupWrite(hBackupFile,
                    rgbBuffer,
                    dwBytesRead,
                    &dwBytesWritten,
                    TRUE,
                    TRUE,
                    &pWriteContext))
    {
        _tprintf(TEXT("Last BackupWrite failed, %08x\n"), GetLastError());
    }

Exit:

    if(INVALID_HANDLE_VALUE != hFile)
    {
        if(!CloseHandle(hFile))
        {
            _tprintf(TEXT("Can't close (%s), %08x\n"), argv[1], GetLastError());
        }
    }
    if(INVALID_HANDLE_VALUE != hBackupFile)
    {
        if(!CloseHandle(hBackupFile))
        {
            _tprintf(TEXT("Can't close (%s), %08x\n"), argv[2], GetLastError());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\teststub.cxx ===
//
// This file allows the utests to link.
// This is necessary because the utest sources file links in every obj
// in the project.  So without these definitions we get unnecessary
// linker errors in things like tldap.
//

#include <trklib.hxx>
#include <trkwks.hxx>

CTrkWksSvc *  g_ptrkwks = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\toidsnap.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"

DWORD g_Debug = 0;


inline void
WriteToSnapshot( HANDLE hFileSnapshot, const TCHAR *ptsz )
{
    ULONG cb, cbWritten;

    if( NULL != ptsz )
        cb = _tcslen( ptsz ) * sizeof(TCHAR);
    else
    {
        cb = sizeof(TCHAR);
        ptsz = TEXT("");
    }

    if( !WriteFile( hFileSnapshot, ptsz, cb, &cbWritten, NULL ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed WriteFile (%lu)"), GetLastError() ));
        TrkRaiseLastError();
    }

    if( cb != cbWritten )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Not all of the data was written (%d/%d)"),
                 cbWritten, cb ));
        TrkRaiseWin32Error( ERROR_WRITE_FAULT );
    }
}

void
Usage()
{
    printf( "\n" );
    printf( " Purpose: Take a snapshot of the volume ID and all object IDs for a volume\n" );
    printf( " Usage:   toidsnap [-g|-s] <drive letter>: <snapshot file>\n" );
    printf( " Where:   -g indicates get (create a snapshot)\n" );
    printf( "          -s indicates set (from the snapshot file)\n" );
    printf( " E.g.:    toidsnap -g d: snapshot.txt\n" );
    printf( "          toidsnap -s d: snapshot.txt\n" );
    return;
}

EXTERN_C void __cdecl _tmain( int cArg, TCHAR *rgtszArg[] )
{
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    TCHAR* ptcTmp = NULL;
    LONG iVol;
    BOOL fSuccess = TRUE;
    BOOL fSaving = FALSE;
    HANDLE hFileSnapshot = INVALID_HANDLE_VALUE;
    HANDLE hMapping = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK Iosb;
    TCHAR tszFileData[ 3 * MAX_PATH ];
    ULONG cLine = 0;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "TOidSnap" );


    //  -------------------------
    //  Validate the command-line
    //  -------------------------

    if( 4 != cArg )
    {
        Usage();
        goto Exit;
    }

    _tcslwr( rgtszArg[1] );
    _tcslwr( rgtszArg[2] );

    if( TEXT('-') != rgtszArg[1][0] && TEXT('/') != rgtszArg[1][0]
        ||
        TEXT('g') != rgtszArg[1][1] && TEXT('s') != rgtszArg[1][1]
        ||
        TEXT(':') != rgtszArg[2][1]
        ||
        TEXT('a') > rgtszArg[2][0] || TEXT('z') < rgtszArg[2][0]
      )
    {
        Usage();
        goto Exit;
    }

    fSaving = TEXT('g') == rgtszArg[1][1];

    iVol = rgtszArg[2][0] - TEXT('a');
    if( !IsLocalObjectVolume( iVol ))
    {
        _tprintf( TEXT("%c: isn't an NTFS5 volume\n"), VolChar(iVol) );
        goto Exit;
    }


    __try
    {
        FILE_FS_OBJECTID_INFORMATION fsobOID;

        EnableRestorePrivilege();

        // Open the snapshot file

        hFileSnapshot = CreateFile( rgtszArg[3],
                            fSaving ? GENERIC_WRITE : GENERIC_READ,
                            0, NULL,
                            fSaving ? CREATE_ALWAYS : OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFileSnapshot )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open file: %s (%lu)"),
                     rgtszArg[3], GetLastError() ));
            TrkRaiseLastError();
        }

        //  ----
        //  Save
        //  ----

        if( fSaving )
        {
            // Get the volid

            CVolumeId volid;
            status = QueryVolumeId( iVol, &volid );
            if( STATUS_OBJECT_NAME_NOT_FOUND != status && !NT_SUCCESS(status) )
                TrkRaiseNtStatus( status );

            // Write the volid to the snapshot file.

            WriteToSnapshot( hFileSnapshot, TEXT("VolId, ") );

            CStringize strVolid(volid);
            WriteToSnapshot( hFileSnapshot, static_cast<const TCHAR*>(strVolid) );
            WriteToSnapshot( hFileSnapshot, TEXT("\n") );
            WriteToSnapshot( hFileSnapshot, NULL );
            cLine++;

            CObjId                  objid;
            CDomainRelativeObjId    droidBirth;
            CObjIdEnumerator        oie;

            // Loop through the files with object IDs

            if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
            {
                if(oie.FindFirst(&objid, &droidBirth))
                {
                    do
                    {
                        // Open the file so that we can get its path

                        HANDLE hFile;
                        status = OpenFileById(  iVol, objid, SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                                0, &hFile);
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed OpenFileById for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Get the local path 

                        status = QueryVolRelativePath( hFile, tszFileData );
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed QueryVolRelativePath for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Write the path, objid, and birth ID to the snapshot file.

                        _tcscat( tszFileData, TEXT(" = ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(objid)) );
                        _tcscat( tszFileData, TEXT(", ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(droidBirth)) );
                        _tcscat( tszFileData, TEXT("\n") );


                        // Write a line terminator to the snapshot file.

                        WriteToSnapshot( hFileSnapshot, tszFileData );
                        WriteToSnapshot( hFileSnapshot, NULL );

                        cLine++;

                    } while(oie.FindNext(&objid, &droidBirth));

                    // Write an marker to show end-of-file

                    WriteToSnapshot( hFileSnapshot, TEXT("\n") );
                    WriteToSnapshot( hFileSnapshot, NULL );
                }
            }

            printf( "%d IDs saved\n", cLine );
        
        }   // if fSaving

        //  ---------
        //  Restoring
        //  ---------

        else
        {
            ULONG cCollisions = 0, cSuccess = 0;
            TCHAR *ptsz = NULL;

            // Map the snapshot file into memory.

            hMapping = CreateFileMapping( hFileSnapshot, NULL, PAGE_READONLY, 0, 0, NULL );
            if( NULL == hMapping )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed CreateFileMapping") ));
                TrkRaiseLastError();
            }

            ptsz = reinterpret_cast<TCHAR*>( MapViewOfFile( hMapping, FILE_MAP_READ, 0, 0, 0 ));
            if( NULL == ptsz )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't map view of file") ));
                TrkRaiseLastError();
            }

            // The file should start with the volid

            if( NULL == _tcsstr( ptsz, TEXT("VolId, ") ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't find volid") ));
                TrkRaiseException( E_FAIL );
            }

            // Move ptsz to the start of the stringized volid
            ptsz += _tcslen(TEXT("VolId, "));

            // Unstringize the volid and set it on the volume.

            CVolumeId volid;
            CStringize stringize;
            stringize.Use( ptsz );
            volid = stringize;

            status = SetVolId( iVol, volid );
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set volid") ));
                TrkRaiseNtStatus(status);
            }
            cSuccess++;

            // Move past the eol & null after the volid.

            ptsz = _tcschr( ptsz, TEXT('\n') );
            if( NULL == ptsz || TEXT('\0') != ptsz[1] )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Unexpected end of file") ));
                TrkRaiseException( E_FAIL );
            }
            cLine++;
            ptsz += 2;  // Past '\n' and '\0'

            // Init tszPath with the drive letter.

            TCHAR tszPath[ MAX_PATH + 1 ];
            tszPath[0] = VolChar(iVol);
            tszPath[1] = TEXT(':');

            // Loop through the object IDs in the snapshot file.
            // They are in the form:
            //
            //    <file> = <objid>, <birth ID>
            //
            // E.g.
            //    \test = {...}, {...}{...}

            while( TRUE )
            {
                // Find the separator between the file name and the objid

                TCHAR *ptszSep;
                ptszSep = _tcschr( ptsz, TEXT('=') );
                if( NULL == ptszSep )
                    TrkRaiseException( E_FAIL );

                // cch is the length of the file name

                ULONG cch = ptszSep - ptsz;
                if( 0 == cch )
                    TrkRaiseException( E_FAIL );
                cch--;

                // Put the file name into tszPath

                _tcsncpy( &tszPath[2], ptsz, cch );
                tszPath[2+cch] = TEXT('\0');

                // Move ptsz to the beginning of the stringized objid

                ptsz = ptszSep + 1;
                if( TEXT(' ') != *ptsz )
                    TrkRaiseException( E_FAIL );
                ptsz++;

                // Unstringize the objid

                stringize.Use( ptsz );
                CObjId objid = stringize;

                // Move ptsz to the beginning of the birth ID, and unstringize it.

                ptsz = _tcschr( ptsz, TEXT(',') );
                if( NULL == ptsz || TEXT(' ') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                ptsz += 2;
                stringize.Use( ptsz );
                CDomainRelativeObjId droidBirth;
                droidBirth = stringize;

                // Set the objid and birth ID

                status = SetObjId( tszPath, objid, droidBirth );
                if( STATUS_OBJECT_NAME_COLLISION == status )
                {
                    cCollisions++;
                    status = STATUS_SUCCESS;
                }
                else if( FAILED(status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set objid on %s"), tszPath ));
                    TrkRaiseNtStatus( status );
                }
                else
                    cSuccess++;

                //_tprintf( TEXT("Set %s on %s\n"), static_cast<const TCHAR*>(CStringize(objid)), tszPath );

                // Move to the endo of the line

                ptsz = _tcschr( ptsz, TEXT('\n') );
                if( NULL == ptsz || TEXT('\0') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                // Move to the beginning of the next line
                ptsz += 2;  // '\n' & '\0'

                // If this is an empty line, then we're at the end of the file.
                if( TEXT('\n') == *ptsz )
                    break;

            }   // while( TRUE )

            printf( "%d IDs successfully set, %d ID collisions\n", cSuccess, cCollisions );

        }   // if fSaving ... else
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        printf( "Error exception at line %d: %08x\n", cLine, GetExceptionCode() );
    }


Exit:

    return;

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\tldap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       tldap.cxx
//
//  Contents:   Command line test utility for LDAP link tracking db
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "teststub.cxx"

#define TRKDATA_ALLOCATE
#include <trksvr.hxx>
#undef TRKDATA_ALLOCATE

#if DBG

class CTestSvrSvc
{
public:

    void    Initialize()
    {
        _svc.Initialize(STANDALONE_DEBUGGABLE_PROCESS);
    }

    void    UnInitialize(HRESULT hr)
    {
        _svc.UnInitialize(hr);
    }

    void    DoSwitch(TCHAR ** &tszArgs, int & cArgs, BOOL & fError);

private:

    void    DoAdd(TCHAR * pszKey, TCHAR * ptszNew, TCHAR * ptszBirth);
    void    DoDelete(TCHAR * ptszKey);
    void    DoModify(TCHAR * ptszKey, TCHAR * ptszNew, TCHAR * ptszBirth);
    void    DoQuery(TCHAR * ptszKey);
    void    DoTouch(TCHAR * ptszKey);
    void    DoFill(TCHAR * ptszNum);
    void    DoPurge();
    void    DoCachePurge();
    void    DoVolumeTable();
    void    DoShorten();
    void    DoRunTests();
    void    DoIdt();

    void    TryCreateVolume(const CMachineId & mcid,
                const CVolumeSecret & secret,
                CVolumeId * pVolumeId);

    inline  CIntraDomainTable & idt()
    {
        return(_svc._idt);
    }

    inline  CVolumeTable & voltab()
    {
        return(_svc._voltab);
    }

private:

    CTrkSvrSvc  _svc;

};

void
CTestSvrSvc::TryCreateVolume(const CMachineId & mcid,
            const CVolumeSecret & secret,
            CVolumeId * pVolumeId)
{
    __try
    {
        voltab().CreateVolume(mcid, secret, pVolumeId);
    }
    __except(BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoAdd(TCHAR  * ptszKey, TCHAR * ptszNew, TCHAR * ptszBirth)
{
    __try
    {
        BOOL f = idt().Add(CDomainRelativeObjId(ptszKey), CDomainRelativeObjId(ptszNew), CDomainRelativeObjId(ptszBirth));
        printf("Add returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoDelete(TCHAR * ptszKey)
{
    __try
    {
        BOOL f = idt().Delete(CDomainRelativeObjId(ptszKey));
        printf("Delete returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}

void
CTestSvrSvc::DoModify(TCHAR * ptszKey, TCHAR * ptszNew, TCHAR * ptszBirth)
{
    __try
    {
        BOOL f = idt().Modify(CDomainRelativeObjId(ptszKey), CDomainRelativeObjId(ptszNew), CDomainRelativeObjId(ptszBirth));
        printf("Modify returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}


void
CTestSvrSvc::DoQuery(TCHAR * ptszKey)
{
    __try
    {
        CDomainRelativeObjId ldNew;
        CDomainRelativeObjId ldBirth;

        BOOL f = idt().Query(CDomainRelativeObjId(ptszKey), &ldNew, &ldBirth);
        printf("Query returns %s\n", f ? "TRUE" : "FALSE");
        if (f)
        {
            ldNew.DebugPrint(TEXT("ldNew="));
            ldBirth.DebugPrint(TEXT("ldBirth="));
        }
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}

void
CTestSvrSvc::DoTouch(TCHAR * ptszKey)
{
    __try
    {
        BOOL f = idt().Touch(CDomainRelativeObjId(ptszKey));
        printf("Touch returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}

class CName
{
public:
    CName(int i)
    {
        _tsz[0] = i/(26*26) + TEXT('a');
        _tsz[1] = (i%(26*26))/26 + TEXT('a');
        _tsz[2] = i%26 + TEXT('a');
        _tsz[3] = 0;
    }

    operator TCHAR * ()
    {
        return(_tsz);
    }
private:
    TCHAR _tsz[10];
};

void
CTestSvrSvc::DoFill(TCHAR * ptszNum)
{
    int cEntries;

    _stscanf(ptszNum, TEXT("%d"), &cEntries);

    __try
    {
        for (int i=0; i<cEntries; i++)
        {
            CDomainRelativeObjId ldNew, ldBirth;
            idt().Add(CDomainRelativeObjId(CName(i)),  ldNew, ldBirth);
        }
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoPurge()
{
    int cEntries;

    __try
    {
       idt().PurgeAll();
       voltab().PurgeAll();
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoCachePurge()
{
    const int size = 64000000;
    LPDWORD p, pOrig;

    p = pOrig = (LPDWORD)GlobalAlloc(GMEM_FIXED, size);
    if (p)
    {
        for (int i=0; i<size/sizeof(*p); i++)
        {
            *p++ = 0;
        }
        GlobalFree((HGLOBAL)pOrig);
    }
    else
        printf("couldn't alloc 64M");
}

#define Check(exp) TrkAssert(exp)

void
CTestSvrSvc::DoVolumeTable()
{
    // test out volume table functionality
    HRESULT hr;
    CMachineId mcid1("mcid1");
    CMachineId mcid2("mcid2");
    CMachineId mcid3("mcid3");
    CMachineId mcid4("mcid4");
    CVolumeSecret secret1;
    CVolumeSecret secret2;
    CVolumeSecret secret3;
    CVolumeSecret secret4;
    CVolumeId volume1;
    CVolumeId volume2;
    CVolumeId volume3;
    CVolumeId volume4;
    SequenceNumber seq;
    FILETIME ft;

    DoPurge();

    UuidCreate((GUID*)&volume1);
    UuidCreate((GUID*)&volume2);
    UuidCreate((GUID*)&volume3);
    UuidCreate((GUID*)&volume4);
    UuidCreate((GUID*)&secret1);
    UuidCreate((GUID*)&secret2);
    UuidCreate((GUID*)&secret3);
    UuidCreate((GUID*)&secret4);

    // Check Queries

    CFILETIME cftStart;

    // check non-existent volume
    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_FOUND);

    // exception when setting seq number on non-existent volume
    hr = voltab().SetSequenceNumber(volume1, seq);
    Check(hr != S_OK);

    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_FOUND);

    // exception when setting seq number on non-existent volume
    hr = voltab().SetSequenceNumber(volume1, seq);
    Check(hr != S_OK);

    // create a volume

    TryCreateVolume(mcid1, secret1, & volume1);

    // check we can query it if it is us
    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == S_OK);

    // check we can't query it if it isn't us
    hr = voltab().QueryVolume(mcid2, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_OWNED);

    // Check Claims

    // claim a non-existent volume
    hr = voltab().ClaimVolume(mcid1, volume2, secret1, secret1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_FOUND);

    // claim an existent volume using the wrong secret
    hr = voltab().ClaimVolume(mcid2, volume1, secret2, secret2, &seq, &ft);
    Check(hr == TRK_E_VOLUME_ACCESS_DENIED);

    // claim an existent volume using the right secret
    hr = voltab().ClaimVolume(mcid2, volume1, secret1, secret1, &seq, &ft);
    Check(hr == S_OK);

    // check the query fails from the original machine
    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_OWNED);

    // check the query succeeds from the new machine
    hr = voltab().QueryVolume(mcid2, volume1, &seq, &ft);
    Check(hr == S_OK);

    // Check sequence numbers
    SequenceNumber seq2 = seq;
    seq ++;
    hr = voltab().SetSequenceNumber(volume1, seq);
    Check(hr == S_OK);

    SequenceNumber seq3;
    hr = voltab().QueryVolume(mcid2, volume1, &seq3, &ft);
    Check(hr == S_OK);

    Check(seq3 == seq);
    Check(seq2 + 1 == seq);

}

class CSegString
{
public:
            CSegString(int length);
            ~CSegString();

            
private:
    
};


class CSegment
{
public:
            CSegment()  {  _fInitialized = FALSE; }
            ~CSegment();

            const CDomainRelativeObjId  Current();
            const CDomainRelativeObjId  New();
            const CDomainRelativeObjId  Birth();

private:
    BOOL    _fInitialized;
};

class COrder
{
public:
            COrder(int iLength, int iCurrent) : _iLength(iLength) { }
            ~COrder();

            BOOL    GetSegment(CSegment * pSegment);

private:

            int     _iLength;

};

class COrderEnum
{
public:
            COrderEnum(int length);
            ~COrderEnum();

            BOOL GetOrder(COrder * pOrder);

private:
            int _iCurrent;
            int _iEnd;
            int _iLength;
};

COrderEnum::COrderEnum(int iLength)
{
    _iLength = iLength;
    _iCurrent = 1;
    _iEnd = 1;

    while (iLength)
    {
        _iEnd *= iLength;
        iLength --;
    }
}

BOOL
COrderEnum::GetOrder(COrder * pOrder)
{
    if (_iCurrent > _iEnd)
    {
        return(FALSE);
    }

    

    return(TRUE);
}

void
CTestSvrSvc::DoIdt()
{
    int cChanges=0;

    CDomainRelativeObjId droidCurrent, droidBirth, droidNew;

    memcpy( &droidCurrent, "12345678", 8 );
    droidBirth = droidCurrent;
    memcpy( &droidNew, "87654321", 8 );

    _svc.MoveNotify(droidCurrent, droidBirth, droidNew, &cChanges);

    CDomainRelativeObjId droidNewRead, droidBirthRead;

    idt().Query(droidBirth, &droidNewRead, &droidBirthRead);

    Check( droidNewRead == droidNew );




#if 0
    // Each letter represents a (volume,oid) pair
    //
    // Various string lengths:
    //
    // Length 1:
    //      a->b a                  (1 order A)
    //              
    //      
    // Length 2:
    //      a->b a, b->c a          (2 orders AB, BA)
    //
    //
    // Length 3:
    //      a->b a, b->c a, c->d a  (6 orders ABC, ACB, BAC, BCA, CAB, CBA)
    //
    //
    // Each combination could have a non-matching birth id which should prevent shortening and search
    // Each segment  can be created either through replication (directly to idt) or
    //  through MoveNotify.
    // Each segment can be shortened through MoveNotify or Search
    //

    // three lengths
    for (int l=1; l<=3; l++)
    {
        COrderEnum oe(l);
        COrder     o;

        while (oe.GetOrder(&o))
        {
            CSegString ss(l);   // make segment string of length l

            BOOL fFirst = TRUE;
            CSegment seg, segFirst, segLast;
            int index;

            while (-1 != (index = o.GetIndex()))
            {
                seg = ss[index];

                if (fFirst)
                {
                    segFirst = seg;
                    fFirst = FALSE;
                }

                TRKSVR_MOVE_NOTIFICATION Notification;
                Notification.ldCurrent = seg.Current();
                Notification.ldNew = seg.New();
                Notification.ldBirth = seg.Birth();

                _svc.MoveNotify(Notification);

                segLast = seg;
            }

            CDomainRelativeObjId ldNew, ldBirth;

            idt().Query(segFirst.Birth(), &ldNew, &ldBirth);

            Check(ldNew == segLast.Current());
        }
    }

#endif // #if 0

}

void
CTestSvrSvc::DoRunTests()
{
    DoVolumeTable();
    DoIdt();
}


void
CTestSvrSvc::DoSwitch(TCHAR ** &tszArgs, int & cArgs, BOOL & fError)
{

    if (cArgs == 0)
    {
        return;
    }
    switch (tszArgs[0][1])
    {
    case TEXT('a'):
    case TEXT('A'):
        if (cArgs >= 4)
        {
            DoAdd(tszArgs[1], tszArgs[2], tszArgs[3]);
            cArgs -= 4;
            tszArgs += 4;
            fError = FALSE;
        }
        break;
    case TEXT('d'):
    case TEXT('D'):
        if (cArgs >= 2)
        {
            DoDelete(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;
    case TEXT('m'):
    case TEXT('M'):
        if (cArgs >= 4)
        {
            DoModify(tszArgs[1], tszArgs[2], tszArgs[3]);
            cArgs -= 4;
            tszArgs += 4;
            fError = FALSE;
        }
        break;
    case TEXT('q'):
    case TEXT('Q'):
        if (cArgs >= 2)
        {
            DoQuery(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;
    case TEXT('t'):
    case TEXT('T'):
        if (cArgs >= 2)
        {
            DoTouch(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;

    case TEXT('f'):
    case TEXT('F'):
        if (cArgs >= 2)
        {
            DoFill(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;

    case TEXT('p'):
    case TEXT('P'):
        if (cArgs >= 1)
        {
            DoPurge();
            cArgs -= 1;
            tszArgs += 1;
            fError = FALSE;
        }
        break;
    case TEXT('c'):
    case TEXT('C'):
        DoCachePurge();
        cArgs -= 1;
        tszArgs += 1;
        fError = FALSE;
        break;

    case TEXT('r'):
    case TEXT('R'):
        DoRunTests();
        cArgs -= 1;
        tszArgs += 1;
        fError = FALSE;
        break;

    case TEXT('i'):
    case TEXT('I'):
        printf("Type a command line switch at the prompt (control-c to exit.)\n");
        do
        {

            TCHAR buf[256];
            TCHAR * tszArgs2[16];
            TCHAR ** tszArgsI = tszArgs2;
            int    cArgsI=0;
            BOOL fError2;

            printf("> ");

            _getts(buf);

            TCHAR * p = buf;
            
            while (*p)
            {
                tszArgs2[cArgsI++] = p++;
                while (*p && *p != TEXT(' ')) p++;
                if (*p == ' ')
                {
                    *p = 0;
                    p++;
                }
            }
    
            DoSwitch(tszArgsI, cArgsI, fError2);
        }
        while (TRUE);
        break;
    default:
        break;
    }
}

EXTERN_C int __cdecl _tmain(int cArgs, TCHAR **tszArgs )
{ 
    BOOL fError = FALSE;
    HRESULT hr;
    LARGE_INTEGER liFreq;
    CTestSvrSvc test;

    __try
    {
    
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TLDAP" );
        g_Debug = 0xffffffff & ~TRKDBG_WORKMAN;
        test.Initialize();

        cArgs--;
        tszArgs++;
redo:    
        if (cArgs == 0)
        {
            fError = TRUE;
        }
    
    
        while (!fError && cArgs > 0)
        {
            fError = TRUE;
            if (tszArgs[0][0] == '-' || tszArgs[0][0] == '/')
            {
                test.DoSwitch(tszArgs, cArgs, fError);
            }
        }

        if (fError)
        {
            printf("Usage: \n");
            printf(" Operation   Params\n");
            printf(" ---------   ------\n");
            printf(" Add         -a <key> <cur> <birthid>\n");
            printf(" Delete      -d <key>\n");
            printf(" Modify      -m <key> <cur> <birthid>\n");
            printf(" Query       -q <key>\n");
            printf(" Touch       -t <key>\n");
            printf(" Fill        -f <number of entries> // aaa,aab,aac ...\n");
            printf(" Purge       -p 'purge all server database state'\n");
            printf(" Cache Purge -c\n");
            printf(" Run tests   -r\n");
            printf(" Interactive -i\n");
        }
        hr = S_OK;
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception number %08X caught\n", GetExceptionCode());
        hr = GetExceptionCode();
    }

    test.UnInitialize(hr);

Exit:

    return(0);
}

#else
EXTERN_C int __cdecl _tmain(int cArgs, TCHAR **tszArgs )
{
    printf("Retail build of tldap.exe doesn't run\n");
    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\tforceown.cxx ===
#include "pch.cxx"
#pragma hdrstop
#include "teststub.cxx"

#define TRKDATA_ALLOCATE
#include "trksvr.hxx"
#undef TRKDATA_ALLOCATE

#import "itrkadmn.tlb" no_namespace

#include "itrkadmn.hxx"

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

DWORD g_Debug = TRKDBG_ERROR;

void Usage()
{
    _tprintf( TEXT("\n")
              TEXT("Purpose:  Use this test to check the ownership status - or take ownership - of\n")
              TEXT("          file(s) or volume(s).\n")
              TEXT("Usage:    TForceOwn <options> <file(s) or volume(s)>\n")
              TEXT("Options:  -f<scope>      Take ownership of file(s)\n")
              TEXT("          -f<scope>s     Check file ownership status\n")
              TEXT("          -v<scope>      Take ownership of volume(s)\n")
              TEXT("          -v<scope>s     Check volume ownership status\n")
              TEXT("Where <scope> is:\n")
              TEXT("          f              One file\n")
              TEXT("          v              One volume\n")
              TEXT("          m              Whole machine\n")
              TEXT("E.g.:\n")
              TEXT("          TForceOwn -vs \\\\machine\\share\\path\\file.txt\n")
              TEXT("                // Gets status for the volume containing file.txt\n")
              TEXT("          TForceOwn -ffs \\\\machine\\share\\path\\file.txt\n")
              TEXT("                // Gets status for a single file\n")
              TEXT("          TForceOwn -fm\n")
              TEXT("                // Forces all files on \\\\machine to be owned by that machine\n") );
}


void
DoVolumeStatus( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;
    LONG cVols = 0;
    LONG iVol;
    BSTR bstr = NULL;
    LONG lLowerBound, lUpperBound;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    VARIANT varrglongIndex;
    VARIANT varrgbstrVolId;
    VARIANT varrglongStatus;

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        SAFEARRAYBOUND sabound;

        hr = pForceOwn->VolumeStatus( bstrPath, scope, &varrglongIndex, &varrgbstrVolId, &varrglongStatus );
        if( FAILED(hr) ) TrkRaiseException( hr );

        TrkAssert( (VT_ARRAY|VT_I4) == varrglongIndex.vt );
        TrkAssert( (VT_ARRAY|VT_BSTR) == varrgbstrVolId.vt );
        TrkAssert( (VT_ARRAY|VT_I4) == varrglongStatus.vt );

        TrkAssert( 1 == SafeArrayGetDim( varrglongIndex.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrgbstrVolId.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrglongStatus.parray ));

        hr = SafeArrayGetLBound( varrglongIndex.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrgbstrVolId.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrglongStatus.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetUBound( varrglongIndex.parray, 1, &lUpperBound );
        if( FAILED(hr) ) TrkRaiseException( hr );

        cVols = lUpperBound + 1;

        hr = SafeArrayGetUBound( varrgbstrVolId.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cVols == lUpperBound + 1 );

        hr = SafeArrayGetUBound( varrglongStatus.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cVols == lUpperBound + 1 );

        _tprintf( TEXT("\n")
                  TEXT("Volume ownership status for %s\n"),
                  ptszUncPath );

        for( iVol = 0; iVol < cVols; iVol++ )
        {
            LONG lVolIndex, lStatus;
            BSTR bstr = NULL;

            _tprintf( TEXT("\n") );

            hr = SafeArrayGetElement( varrglongIndex.parray, &iVol, &lVolIndex );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %c\n"), TEXT("Volume:"), TEXT('A')+static_cast<TCHAR>(lVolIndex) );

            hr = SafeArrayGetElement( varrgbstrVolId.parray, &iVol, &bstr );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("ID:"), bstr );
            SysFreeString( bstr ); bstr = NULL;

            hr = SafeArrayGetElement( varrglongStatus.parray, &iVol, &lStatus );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("Status:"), (TCHAR*) CObjectOwnershipString(lStatus) );

        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    VariantClear( &varrglongIndex );
    VariantClear( &varrgbstrVolId );
    VariantClear( &varrglongStatus );

    if( bstr ) SysFreeString( bstr );

    if( FAILED(hr) )
        _tprintf( TEXT("DoVolumeStatus failed:  %08x\n"), hr );
}





void
DoVolumes( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        hr = pForceOwn->Volumes( bstrPath, scope );
        if( FAILED(hr) ) TrkRaiseException( hr );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    if( FAILED(hr) )
        _tprintf( TEXT("DoVolumes failed:  %08x\n"), hr );
}




void
DoFileStatus( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;
    LONG cFiles = 0;
    LONG iFile;
    BSTR bstr = NULL;
    LONG lLowerBound, lUpperBound;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    VARIANT varrgbstrFileName;
    VARIANT varrgbstrFileId;
    VARIANT varrglongStatus;

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        SAFEARRAYBOUND sabound;

        hr = pForceOwn->FileStatus( bstrPath, scope, &varrgbstrFileName, &varrgbstrFileId, &varrglongStatus );
        if( FAILED(hr) ) TrkRaiseException( hr );

        TrkAssert( (VT_ARRAY|VT_BSTR) == varrgbstrFileName.vt );
        TrkAssert( (VT_ARRAY|VT_BSTR) == varrgbstrFileId.vt );
        TrkAssert( (VT_ARRAY|VT_I4) == varrglongStatus.vt );

        TrkAssert( 1 == SafeArrayGetDim( varrgbstrFileName.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrgbstrFileId.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrglongStatus.parray ));

        hr = SafeArrayGetLBound( varrgbstrFileName.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrgbstrFileId.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrglongStatus.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetUBound( varrgbstrFileName.parray, 1, &lUpperBound );
        if( FAILED(hr) ) TrkRaiseException( hr );

        cFiles = lUpperBound + 1;

        hr = SafeArrayGetUBound( varrgbstrFileId.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cFiles == lUpperBound + 1 );

        hr = SafeArrayGetUBound( varrglongStatus.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cFiles == lUpperBound + 1 );

        _tprintf( TEXT("\n")
                  TEXT("File ownership status for %s\n"),
                  ptszUncPath );


        for( iFile = 0; iFile < cFiles; iFile++ )
        {
            BSTR bstr = NULL;
            long lStatus;

            _tprintf( TEXT("\n") );

            hr = SafeArrayGetElement( varrgbstrFileName.parray, &iFile, &bstr );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("File:"), bstr );
            SysFreeString( bstr ); bstr = NULL;

            hr = SafeArrayGetElement( varrgbstrFileId.parray, &iFile, &bstr );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("ID:"), bstr );
            SysFreeString( bstr ); bstr = NULL;

            hr = SafeArrayGetElement( varrglongStatus.parray, &iFile, &lStatus );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("Status:"), (TCHAR*) CObjectOwnershipString(lStatus) );

        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    VariantClear( &varrgbstrFileName );
    VariantClear( &varrgbstrFileId );
    VariantClear( &varrglongStatus );

    if( bstr ) SysFreeString( bstr );

    if( FAILED(hr) )
        _tprintf( TEXT("DoFileStatus failed:  %08x\n"), hr );
}



void
DoFiles( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        hr = pForceOwn->Files( bstrPath, scope );
        if( FAILED(hr) ) TrkRaiseException( hr );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    if( FAILED(hr) )
        _tprintf( TEXT("DoFiles failed:  %08x\n"), hr );
}


struct tagStartOle
{
    tagStartOle() { CoInitialize( NULL ); }
    ~tagStartOle() { CoUninitialize(); }
} StartOle;


EXTERN_C void __cdecl _tmain( ULONG cArgs, TCHAR *rgtszArgs[] )
{
    TrkInfoScope scope;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TForceOwn" );

    if( 3 > cArgs
        ||
        ( rgtszArgs[1][0] != TEXT('-')
          &&
          rgtszArgs[1][0] != TEXT('/') 
        )
      )
    {
        Usage();
        goto Exit;
    }


    _tcsupr( rgtszArgs[1] );

    switch( rgtszArgs[ 1 ][ 1 ] )
    {
        case TEXT('V'):

            switch( rgtszArgs[1][2] )
            {
                case TEXT('V'):
                    scope = TRKINFOSCOPE_VOLUME;
                    break;
                case TEXT('M'):
                    scope = TRKINFOSCOPE_MACHINE;
                    break;
                default:
                    _tprintf( TEXT("Unsupported option:  %s\n"), rgtszArgs[1] );
                    goto Exit;
            }

            if( TEXT('S') == rgtszArgs[1][3] )
                DoVolumeStatus( scope, rgtszArgs[2] );
            else
                DoVolumes( scope, rgtszArgs[2] );
            break;

        case TEXT('F'):

            switch( rgtszArgs[1][2] )
            {
                case TEXT('F'):
                    scope = TRKINFOSCOPE_ONE_FILE;
                    break;
                case TEXT('V'):
                    scope = TRKINFOSCOPE_VOLUME;
                    break;
                case TEXT('M'):
                    scope = TRKINFOSCOPE_MACHINE;
                    break;
                default:
                    _tprintf( TEXT("Unsupported option:  %s\n"), rgtszArgs[1] );
                    goto Exit;
            }

            if( TEXT('S') == rgtszArgs[1][3] )
                DoFileStatus( scope, rgtszArgs[2] );
            else
                DoFiles( scope, rgtszArgs[2] );
            break;

        default:

            _tprintf( TEXT("Unsupported option:  %s\n"), rgtszArgs[1] );
            break;
    }


Exit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\tlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       tlink.cxx
//
//  Contents:   Utility to create/mend links and move files with notify
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE    // This is the main module, trigger trkwks.hxx to do definitions
#include <trkwks.hxx>
#include <cfiletim.hxx>
#include <ocidl.h>

#include <shlobj.h>
#include <shlguid.h>

DWORD g_Debug = TRKDBG_ERROR;

#define CB_LINK_CLIENT_MAX  256

// Implicitely load shell32.dll, rather than waiting for the CoCreate of IShellLink,
// in order to make it easier to debug in windbg.
#pragma comment( lib, "shell32.lib" )


enum EXTRAFLAGS
{
    EXTRAFLAG_SHOW_IDS = 1
};



extern "C"
IID IID_ISLTracker
#ifdef TRKDATA_ALLOCATE
= { /* 7c9e512f-41d7-11d1-8e2e-00c04fb9386d */
    0x7c9e512f,
    0x41d7,
    0x11d1,
    {0x8e, 0x2e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
};
#else
;
#endif

class ISLTracker : public IUnknown
{
public:

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) ()  PURE;
    STDMETHOD_(ULONG,Release) () PURE;

    STDMETHOD(Resolve)(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions) PURE;
    STDMETHOD(GetIDs)(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid) PURE;
};  // interface ISLTracker




void
EnumObjects()
{
    CObjIdEnumerator oie;

    __try
    {
        CObjId aobjid[1000];
        CDomainRelativeObjId adroid[1000];
        int cSources=0;
        
        const int FirstDrive = 'c';
        const int LastDrive = 'z';

        for (int Drive = FirstDrive-'a'; 
                 Drive < LastDrive-'a'+1; 
                 Drive ++)
        {
            // fill up the array with ids from all the drives
            if (oie.Initialize(CVolumeDeviceName(Drive)))
            {
                if (oie.FindFirst(aobjid, adroid))
                {
                    BOOL fGotOne = FALSE;


                    do
                    {
                        do
                        {
                            CDomainRelativeObjId droidBirth;

                            TCHAR tszObjId[256];
                            TCHAR tszBirthLink[256];
                            TCHAR tszPath[MAX_PATH+1];
                            TCHAR * ptszObjId = tszObjId;

                            StringizeGuid(*(GUID*)&aobjid[cSources], ptszObjId);
                            FindLocalPath( Drive, aobjid[cSources], &droidBirth, &tszPath[2]);
                            tszPath[0] = VolChar(Drive);
                            tszPath[1] = TEXT(':');

                            _tprintf(TEXT("%s %s %s\n"),
                                tszObjId,
                                adroid[cSources].Stringize(tszBirthLink,256),
                                tszPath);

                            cSources ++;
                        } while (cSources < sizeof(aobjid)/sizeof(aobjid[0]) &&
                                 (fGotOne = oie.FindNext(&aobjid[ cSources ], &adroid[ cSources ])));
        
                        TrkAssert(cSources > 0);
                        cSources = 0;

                    } while (fGotOne);
                }
            }
        }
    }
    __except(BreakOnDebuggableException())
    {
    }

    oie.UnInitialize();
}

void
AttackDC()
{
    CMachineId mcidDomain(MCID_DOMAIN);
    CRpcClientBinding rcConnect;

    rcConnect.RcInitialize(mcidDomain, s_tszTrkSvrRpcProtocol, s_tszTrkSvrRpcEndPoint);

    TRKSVR_MESSAGE_UNION m;
    CObjId objidCurrent;
    CDomainRelativeObjId droidBirth, droidNew;
    CVolumeId volid;
    

    m.MessageType = MOVE_NOTIFICATION;
    m.Priority = PRI_0;
    m.MoveNotification.cNotifications = 0;
    m.MoveNotification.pvolid = &volid;
    m.MoveNotification.rgobjidCurrent = &objidCurrent;
    m.MoveNotification.rgdroidBirth = &droidBirth;
    m.MoveNotification.rgdroidNew = &droidNew;

    while (1)
    {
        LnkSvrMessage( rcConnect, &m);
    }

    rcConnect.UnInitialize();
}

void
DoCreateLink(IShellLink * pshlink, const TCHAR *ptszLink, const TCHAR *ptszSrc)
{
    HRESULT hr;
    IPersistFile *pPersistFile = NULL;

    __try
    {
        DWORD dwWritten;
        BYTE rgb[ CB_LINK_CLIENT_MAX ];
        ULONG cbPersist = 0;

        memset( rgb, 0, sizeof(rgb) );

        hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI IShellLink for IPersistFile") ));
            TrkRaiseException( hr );
        }

        hr = pshlink->SetPath( ptszSrc );
        _tprintf( TEXT("IShellLink::SetPath returned %08X (%s)\n"),
                  hr, 0==hr ? TEXT("no error") : GetErrorString(hr));
        if( S_OK != hr )
        {
            TrkRaiseException( hr );
        }

        hr = pPersistFile->Save( ptszLink, TRUE );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't persist IShellLink") ));
            TrkRaiseException( hr );
        }
        pPersistFile->SaveCompleted( ptszLink );

        RELEASE_INTERFACE( pPersistFile );

    }
    __except( BreakOnDebuggableException() )
    {
        RELEASE_INTERFACE( pPersistFile );
    }

}

TCHAR *
GetRestrict(DWORD r)
{
    static TCHAR tszError[256];

    tszError[0] = 0;
    if (r == TRK_MEND_DEFAULT)
    {
        _tcscpy(tszError, TEXT("TRK_MEND_DEFAULT "));
    }
    if (r & TRK_MEND_DONT_USE_LOG)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_LOG "));
    }
    if (r & TRK_MEND_DONT_USE_DC)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_DC "));
    }
    if (r & TRK_MEND_SLEEP_DURING_MEND)
    {
        _tcscat(tszError, TEXT("TRK_MEND_SLEEP_DURING_SEARCH "));
    }
    if (r & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_SEARCH_ALL_VOLUMES "));
    }
    if (r & TRK_MEND_DONT_USE_VOLIDS)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_VOLIDS "));
    }
    return(tszError);
}



void
DisplayIDs( ISLTracker *ptracker )
{
    HRESULT hr = S_OK;
    CDomainRelativeObjId droidBirth, droidLast;
    CMachineId mcid;
    TCHAR tsz[ MAX_PATH ];
    TCHAR *ptsz = tsz;

    hr = ptracker->GetIDs( &droidBirth, &droidLast, &mcid );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get IDs") ));
        TrkRaiseException( hr );
    }

    droidBirth.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Birth =\t%s\n"), tsz );

    droidLast.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Last =\t%s\n"), tsz );

    ptsz = tsz;
    mcid.Stringize(ptsz);
    _tprintf( TEXT("Machine =\t%s\n"), tsz );

}


void
DoResolveLink(IShellLink * pshlink, const TCHAR * ptszLink, DWORD r, DWORD dwSLR, DWORD grfExtra )
{
    IPersistFile * pPersistFile = NULL;
    ISLTracker * ptracker = NULL;

    __try
    {
        DWORD dwRead;
        HRESULT  hr;
        WCHAR    wszPath[MAX_PATH+1];
        ULONG    cbPath = sizeof(wszPath);
        WIN32_FIND_DATA fd;

        hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for IPersistFile")));
            TrkRaiseException( hr );
        }

        hr = pPersistFile->Load( ptszLink, STGM_SHARE_EXCLUSIVE | STGM_READWRITE );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't load IShellLink")));
            TrkRaiseException( hr );
        }
        RELEASE_INTERFACE( pPersistFile );

        // Track it (within 30 seconds).
        if( TRK_MEND_DEFAULT == r && 0 == grfExtra )
        {
            hr = pshlink->Resolve( GetDesktopWindow(), 0xfffe0000 | dwSLR | SLR_ANY_MATCH );
        }
        else
        {
            hr = pshlink->QueryInterface( IID_ISLTracker, (void**) &ptracker );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for ISLTracker")));
                TrkRaiseException( hr );
            }

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );

            hr = ptracker->Resolve( GetDesktopWindow(), 0x00100000 /*0xfffe0000*/ | dwSLR | SLR_ANY_MATCH, r );

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );
        }

        pshlink->GetPath( wszPath, cbPath, &fd, 0 );


        _tprintf( TEXT("%ws %08X (%s) %s\n"),
                  wszPath, hr, GetErrorString(hr), GetRestrict(r) );

        RELEASE_INTERFACE( ptracker );

    }
    __except( BreakOnDebuggableException() )
    {
        RELEASE_INTERFACE( pPersistFile );
        RELEASE_INTERFACE( ptracker );

    }

}


void
SignalLockVolume()
{
    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("LOCK_VOLUMES"));
    if (hEvent != NULL)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
    else
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open LOCK_VOLUMES event %d\n"), GetLastError()));
    }

}

void
DoTestWksSvcUp(TCHAR * ptszMachine)
{
    CRpcClientBinding rc;
    CMachineId mcid(ptszMachine);
    BOOL fCalledMachine = FALSE;

    __try
    {
        
        rc.RcInitialize(mcid);

        if (E_NOTIMPL == LnkRestartDcSynchronization(rc))
            fCalledMachine = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    TrkLog((TRKDBG_ERROR,
        TEXT("%successfully called machine %s\n"),
        fCalledMachine ? TEXT("S") : TEXT("Uns"),
        ptszMachine));
}

typedef BOOL (WINAPI *PFNMoveFileWithProgress)( LPCWSTR lpExistingFileName,
                                                LPCWSTR lpNewFileName,
                                                LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
                                                LPVOID lpData OPTIONAL,
                                                DWORD dwFlags
                                                );

#ifndef MOVEFILE_FAIL_IF_NOT_TRACKABLE
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE  0x00000020
#endif


#ifndef UNICODE
#error Unicode required for wszFullPath
#endif

EXTERN_C void __cdecl _tmain(int argc, TCHAR **argv)
{ 
    BOOL fError = FALSE;
    HRESULT hr;
    CMachineId mcid(MCID_LOCAL);
    int ArgC = argc;
    TCHAR ** ArgV = argv;
    DWORD r = TRK_MEND_DEFAULT;
    DWORD grfExtra = 0;
    DWORD dwSLR = 0;    // SLR_ flags
    IShellLink *pshlink = NULL;
    WCHAR wszFullPath[ MAX_PATH + 1 ];
    DWORD dwMoveFlags = MOVEFILE_FAIL_IF_NOT_TRACKABLE |
        MOVEFILE_COPY_ALLOWED |
        MOVEFILE_REPLACE_EXISTING;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TLink" );
    CoInitialize( NULL );

    hr = CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_ALL, IID_IShellLink, (void**)&pshlink );
    if( FAILED(hr) )
    {
        printf( "Couldn't get an IShellLink (%08x)\n", hr );
        goto Exit;
    }

    ArgC--;
    ArgV++;

    if (ArgC == 0)
    {
        fError = TRUE;
    }


    while (!fError && ArgC > 0)
    {
        fError = TRUE;
        if (ArgV[0][0] == TEXT('-') || ArgV[0][0] == TEXT('/'))
        {
            switch (ArgV[0][1])
            {
            case TEXT('a'):
            case TEXT('A'):
                fError = FALSE;
                ArgC --;
                ArgV ++;
                AttackDC();
                break;
            case TEXT('e'):
            case TEXT('E'):
                fError = FALSE;
                ArgC --;
                ArgV ++;
                EnumObjects();
                break;

            case TEXT('v'):
            case TEXT('V'):
                fError = FALSE;
                ArgC --;
                ArgV ++;
                SignalLockVolume();
                break;

            case TEXT('m'):
            case TEXT('M'):
                if (ArgC >= 3)
                {

                    PFNMoveFileWithProgress pfnMoveFileWithProgress = NULL;
                    HMODULE hmodKernel32;

                    for( int i = 2; ArgV[0][i] != TEXT('\0'); i++ )
                    {
                        switch(ArgV[0][i])
                        {
                            case TEXT('f'):
                            case TEXT('F'):
                                dwMoveFlags &= ~ MOVEFILE_FAIL_IF_NOT_TRACKABLE;
                                break;

                            case TEXT('n'):
                            case TEXT('N'):
                                dwMoveFlags &= ~ MOVEFILE_COPY_ALLOWED;
                                break;

                            case TEXT('o'):
                            case TEXT('O'):
                                dwMoveFlags &= ~ MOVEFILE_REPLACE_EXISTING;
                                break;
                            default:
                                _tprintf( TEXT("Bad Move switch: %c\n"), ArgV[0][i] );
                                goto Exit;
                        }   // switch
                    }   // for

                    hmodKernel32 = GetModuleHandle( TEXT("kernel32.dll") );
                    if( NULL == hmodKernel32 )
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("Failed GetModuleHeader for kernel32.dll") ));
                        TrkRaiseLastError( );
                    }
                    pfnMoveFileWithProgress = (PFNMoveFileWithProgress)
                                              GetProcAddress( hmodKernel32, "MoveFileWithProgressW" );
                    if( NULL == pfnMoveFileWithProgress )
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("Couldn't get MoveFileWithProgress export")));
                        TrkRaiseLastError( );
                    }

                    if( !pfnMoveFileWithProgress( ArgV[1], ArgV[2], NULL, NULL, dwMoveFlags ))
                    {
                        _tprintf( TEXT("Failed MoveFileWithProgress (%lu)\n"), GetLastError() );
                    }

                    ArgC -= 3;
                    ArgV += 3;
                    fError = FALSE;
                }
                break;


            case TEXT('c'):
            case TEXT('C'):
                if (ArgC >= 3)
                {
                    if( MAX_PATH < RtlGetFullPathName_U( ArgV[2], sizeof(wszFullPath), wszFullPath, NULL ))
                    {
                        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get full path name") ));
                        TrkRaiseWin32Error( ERROR_BAD_PATHNAME );
                    }


                    DoCreateLink( pshlink, ArgV[1], wszFullPath );

                    ArgC -= 3;
                    ArgV += 3;
                    fError = FALSE;
                }
                break;
            case TEXT('r'):
            case TEXT('R'):
                if (ArgC >= 2)
                {
                    for( int i = 2; ArgV[0][i] != TEXT('\0'); i++ )
                    {
                        switch(ArgV[0][i])
                        {
                            case TEXT('l'):
                            case TEXT('L'):
                                r |= TRK_MEND_DONT_USE_LOG;
                                break;
                            case TEXT('d'):
                            case TEXT('D'):
                                r |= TRK_MEND_DONT_USE_DC;
                                break;
                            case TEXT('i'):
                            case TEXT('I'):
                                r |= TRK_MEND_DONT_USE_VOLIDS;
                                break;
                            case TEXT('m'):
                            case TEXT('M'):
                                r |= TRK_MEND_DONT_SEARCH_ALL_VOLUMES;
                                break;
                            case TEXT('s'):
                            case TEXT('S'):
                                dwSLR |= SLR_NOSEARCH;
                                break;
                            case TEXT('t'):
                            case TEXT('T'):
                                dwSLR |= SLR_NOTRACK;
                                break;
                            case TEXT('u'):
                            case TEXT('U'):
                                dwSLR |= SLR_NO_UI;
                                break;
                            case TEXT('x'):
                            case TEXT('X'):
                                grfExtra |= EXTRAFLAG_SHOW_IDS;
                                break;
                            case TEXT('z'):
                            case TEXT('Z'):
                                r |= TRK_MEND_SLEEP_DURING_MEND;
                                break;

                            default:
                                _tprintf( TEXT("Bad Resolve switch: %c\n"), ArgV[0][i] );
                                goto Exit;
                        }   // switch
                    }   // for

                    DoResolveLink( pshlink, ArgV[1], r, dwSLR, grfExtra );
                    ArgC -= 2;
                    ArgV += 2;
                    fError = FALSE;
                }
                break;
            case TEXT('t'):
            case TEXT('T'):
                if (ArgC >= 2)
                {
                    DoTestWksSvcUp( ArgV[1] );
                    ArgC -= 2;
                    ArgV += 2;
                    fError = FALSE;
                }
                break;

            default:
                break;
            }
        }
    }

Exit:

    if (fError)
    {
        printf("Usage: \n");
        printf(" Operation   Params\n");
        printf(" ---------   ------\n");
        printf(" AttackDC    -a\n");
        printf(" MoveFileWP  -m<opts> <src> <dst>\n");
        printf("   where <opts> may use:  -f = NO fail if not trackable flag\n");
        printf("                          -n = NO copy-allowed flag\n");
        printf("                          -o = NO overwrite existing flag\n");
        printf(" CreateLink  -c <link> <src>\n");
        printf(" EnumObjects -e\n");
        printf(" SignalLockVolume -v\n");
        printf(" ResolveLink -r<opts> <link>\n");
        printf("   where <opts> may use:  -l = don't use log\n");
        printf("                          -d = don't use dc\n");
        printf("                          -i = don't use volids\n");
        printf("                          -m = don't scan all volumes on a machine\n");
        printf("                          -s = no search (SLR_NOSEARCH)\n");
        printf("                          -t = no track (SLR_NOTRACK)\n");
        printf("                          -x = show before/after droids\n");
        printf("                          -u = no UI (SLR_NOUI)\n");
        printf("                          -z = sleep in CTrkWksSvc::Mend\n");
        printf("E.g.:\n");
        printf(" tlink -c l1 t1\n");
        printf(" tlink -mf t1 t1a\n");
        printf(" tlink -r l1\n");
        printf(" tlink -rd l1\n");

    }


    RELEASE_INTERFACE( pshlink );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\trestore.cxx ===
#include "pch.cxx"
#pragma hdrstop
#include "teststub.cxx"

#define TRKDATA_ALLOCATE
#include "trksvr.hxx"

#include "itrkadmn.h"

DWORD g_Debug = 0xffffffff & ~TRKDBG_WORKMAN;

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

EXTERN_C void __cdecl _tmain( ULONG cArgs, TCHAR *rgtszArgs[] )
{
    TCHAR tsz[ MAX_PATH + 1 ];

    IBindCtx *pBC = NULL;
    IMoniker* pMnk = NULL;
    ITrkRestoreNotify *pTrkRestore = NULL; 
    ULONG cchEaten = 0;
    HRESULT hr = E_FAIL;


    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TRestore" );
    CoInitialize(NULL);

    if( 1 >= cArgs )
    {
        printf( "\n"
                "This test takes a path and calls ITrkRestoreNotify on that machine\n" );
        printf( "Usage:  TRestore <path>\n" );
        printf( "E.g.:   TRestore \\\\machine\\share\\dir\\path.ext\n" );
        goto Exit;
    }

    __try
    {
        _tcscpy( tsz, TEXT("@LinkTrack@") );
        _tcscat( tsz, rgtszArgs[1] );

        // Get the moniker
        CreateBindCtx( 0, &pBC ); 
        hr = MkParseDisplayName( pBC, tsz, &cchEaten, &pMnk );
        if( FAILED(hr) ) TrkRaiseException( hr );

        // Get the ITrkRestoreNotify object
        hr = pMnk->BindToObject( pBC, NULL, IID_ITrkRestoreNotify, reinterpret_cast<void**>(&pTrkRestore) );
        if( FAILED(hr) ) TrkRaiseException( hr );

        // Do the notification
        hr = pTrkRestore->OnRestore();
        if( FAILED(hr) ) TrkRaiseException( hr );
    }
    __except( BreakOnDebuggableException() )
    {
        TrkAssert( STATUS_ACCESS_VIOLATION != GetExceptionCode() );
        TrkLog(( TRKDBG_ERROR, TEXT("Exception %d caught in TRestore\n"), GetExceptionCode() ));
    }

Exit:

    if( SUCCEEDED(hr) ) printf("Passed\n");

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\tshlink.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include <windows.h>
#include <shlobj.h>
#include <shlguid.h>

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"

DWORD g_Debug = 0;


void Usage()
{
    wprintf( L"\n"
             L"Purpose:  Create/resolve shell links\n"
             L"Usage:    tshlink <-c <link client> <link source>> | <-r <link client>>\n"
             L"E.g.:     tshlink -c myfile.txt.lnk myfile.txt\n"
             L"          tshlink -r myfile.txt.lnk\n" );
    exit(0);
}


class CMyApp
{
public:

    CMyApp()
    {
        m_hwnd = NULL;
        *m_szAppName = '\0';
        m_nCmdShow = 0;
    }

    ~CMyApp() {}

public:

    __declspec(dllexport)
    static long FAR PASCAL
    WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam);


    BOOL Init( HANDLE hInstance, HANDLE hPrevInstance,
               LPSTR lpszCmdLine, int nCmdShow,
               int cArg, TCHAR *rgtszArg[] );

    WORD Run( void );

private:

    static HWND            m_hwnd;
    static CHAR            m_szAppName[80];
    static HINSTANCE       m_hInstance;
    static int             m_nCmdShow;
    static int             m_cArg;
    static TCHAR **        m_rgtszArg;

};


HWND            CMyApp::m_hwnd;
CHAR            CMyApp::m_szAppName[80];
HINSTANCE       CMyApp::m_hInstance;
int             CMyApp::m_nCmdShow;
int             CMyApp::m_cArg;
TCHAR **        CMyApp::m_rgtszArg;



CMyApp cMyApp;

EXTERN_C void __cdecl _tmain( int cArg, TCHAR *rgtszArg[] )
{

    if( cMyApp.Init(NULL, NULL, //hInstance, hPrevInstance,
                    NULL, SW_SHOWNORMAL, //lpszCmdLine, nCmdShow) )
                    cArg, rgtszArg ))

    {
        cMyApp.Run();
    }

}

void ShellLink( HWND hwnd, int cArg, TCHAR *rgtszArg[] );

long FAR PASCAL
CMyApp::WndProc (HWND hwnd, UINT message,
                 UINT wParam, LONG lParam)
{
    switch (message)
    {
        case WM_CREATE:

            ShellLink( hwnd, m_cArg, m_rgtszArg );
            PostQuitMessage(0);
            break;

        case WM_CLOSE :

            DestroyWindow( hwnd );
            break;

        case WM_DESTROY :

            PostQuitMessage (0) ;
            return 0 ;
    }

    return DefWindowProc (hwnd, message, wParam, lParam) ;
}



BOOL
CMyApp::Init( HANDLE hInstance, HANDLE hPrevInstance,
              LPSTR lpszCmdLine, int nCmdShow,
              int cArg, TCHAR *rgtszArg[] )
{
    WNDCLASSA wndclass;

    sprintf( m_szAppName, "ShellLink" );
    m_hInstance = (HINSTANCE) hInstance;
    m_nCmdShow = nCmdShow;
    m_cArg = cArg;
    m_rgtszArg = rgtszArg;

    if( !hPrevInstance )
    {
        wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc    = CMyApp::WndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = m_hInstance;
        wndclass.hIcon          = LoadIconA( m_hInstance, m_szAppName );
        wndclass.hCursor        = LoadCursorA( NULL, MAKEINTRESOURCEA(32512) ); // IDC_ARROW
        wndclass.hbrBackground  = (HBRUSH) GetStockObject( WHITE_BRUSH );
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = m_szAppName;

        RegisterClassA( &wndclass );
    }

    return( TRUE ); // Successful
}


#ifdef CreateWindowA
#undef CreateWindow
#endif

WORD
CMyApp::Run( void )
{
    MSG msg;
    HRESULT hr;
    CHAR szErrorMessage[80];

    msg.wParam = 0;

    m_hwnd = CreateWindowA( m_szAppName,
                           "ShellLink",
                           WS_OVERLAPPEDWINDOW,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           CW_USEDEFAULT, CW_USEDEFAULT,
                           NULL, NULL, m_hInstance, NULL );
    if( NULL == m_hwnd )
    {
        sprintf( szErrorMessage, "Failed CreateWindowA (%lu)", GetLastError() );
        goto Exit;
    }

    ShowWindow( m_hwnd, SW_MINIMIZE );
    UpdateWindow( m_hwnd );


    while( GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

Exit:

    return( msg.wParam );
}



void ShellLink( HWND hwnd, int cArg, TCHAR *rgtszArg[] )
{
    HRESULT hr;
    IPersistFile *ppf = NULL;
    IShellLink *psl = NULL;
    TCHAR tszPath[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    WIN32_FIND_DATA fd;
    DWORD dwFlags;

    try
    {

        if( 2 > cArg ) Usage();
        if( L'-' != rgtszArg[1][0] ) Usage();

        hr = CoInitialize( NULL );
        if( FAILED(hr) ) throw L"Failed CoInit";

        hr = CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void**) &psl );
        if( FAILED(hr) ) throw L"Failed CoCreateInstance";

        hr = psl->QueryInterface( IID_IPersistFile, (void**) &ppf );
        if( FAILED(hr) ) throw L"Failed QI for IPersistFile";

        switch( rgtszArg[1][1] )
        {
        case L'c':
        case L'C':

            if( 4 > cArg ) Usage();

            if( L':' == rgtszArg[3][1]
                ||
                !wcsncmp( L"\\\\", rgtszArg[3], 2 ))
            {
                if( L':' == rgtszArg[3][1] && L'\\' != rgtszArg[3][2] )
                    Usage();

                wcscpy( tszPath, rgtszArg[3] );

                wcscpy( tszDir, tszPath );
                TCHAR *ptsz = wcsrchr( tszDir, L'\\' );
                *ptsz = L'\0';

            }
            else
            {
                if( !GetCurrentDirectory( sizeof(tszDir), tszDir ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    throw L"Failed GetCurrentDirectory";
                }

                wcscpy( tszPath, tszDir );
                wcscat( tszPath, L"\\" );
                wcscat( tszPath, rgtszArg[3] );
            }
            
            hr = psl->SetPath( tszPath );
            if( FAILED(hr) ) throw L"Failed IShellLink::SetPath";

            hr = psl->SetWorkingDirectory( tszDir );
            if( FAILED(hr) ) throw L"Failed IShellLink::SetWorkingDirectory";

            hr = ppf->Save( rgtszArg[2], TRUE );
            if( FAILED(hr) ) throw L"Failed IPersistFile::Save";

            wprintf( L"Success\n" );
            break;

        case L'r':
        case L'R':

            if( 3 > cArg ) Usage();

            hr = ppf->Load( rgtszArg[2], STGM_READ );
            if( FAILED(hr) ) throw L"Failed IPersistFile::Load";

            dwFlags = (180*1000 << 16) | SLR_ANY_MATCH;
            hr = psl->Resolve( hwnd, dwFlags );
            if( FAILED(hr) ) throw L"Failed Resolve";

            hr = psl->GetPath( tszPath, sizeof(tszPath), &fd, 0 );
            if( FAILED(hr) ) throw L"Failed IShellLink::GetPath";

            wprintf( L"Path = \"%s\"\n", tszPath );
            break;

        default:

            Usage();
            break;

        }   // switch

    }
    catch( TCHAR *tszError )
    {
        wprintf( L"Error:  %s (%08x)\n", tszError, hr );
    }

    if( ppf ) ppf->Release();
    if( psl ) psl->Release();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\ttimer.cxx ===
#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"


const TCHAR *g_tszDefaultName = TEXT("TimerTestDefault");
const TCHAR *g_tszContinueName = TEXT("TimerTestContinue");

DWORD g_Debug = TRKDBG_ERROR | TRKDBG_TIMER;
ULONG g_ulDefaultPeriod = 4;   // Seconds
ULONG g_ulMinRetry = g_ulDefaultPeriod * 3 / 2;
ULONG g_ulMaxRetry = g_ulMinRetry * 4;
ULONG g_ulTimerContext = 0;

CFILETIME g_cftDeltaMargin = 10*1000*1000; // 1 second

#include "ttimer.hxx"


void
CTimerTest::Initialize( PTimerCallback *pTimerCallback,
                        const TCHAR *ptszName,
                        ULONG ulTimerContext,
                        ULONG ulPeriodInSeconds,
                        CNewTimer::TimerRetryType retrytype,
                        ULONG ulLowerRetryTime,
                        ULONG ulUpperRetryTime,
                        ULONG ulMaxLifetime )
{
    _ptszName = ptszName;

    _fInitialized = TRUE;

    _timer.Initialize(pTimerCallback, ptszName,
                      ulTimerContext, ulPeriodInSeconds, retrytype,
                      ulLowerRetryTime, ulUpperRetryTime, ulMaxLifetime );

    _hEvent = CreateEvent( NULL, FALSE, FALSE, TEXT("TTimer Test") );
    if( INVALID_HANDLE_VALUE == _hEvent )
        TrkRaiseLastError( );

}


void
CTimerTest::SetTimerRegistryValue( const TCHAR *ptszName,
                                   const CFILETIME &cftSet, const CFILETIME cftDue,
                                   ULONG ulRetry )
{
    HKEY hkey;
    LONG lRet;

    if( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                                       0, KEY_ALL_ACCESS, &hkey ))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open persistent registry key") ));
        TrkRaiseLastError( );
    }

    CNewTimer::PersistentState TimerPersistence;

    TimerPersistence.cftDue = cftDue;
    TimerPersistence.cftSet = cftSet;
    TimerPersistence.ulCurrentRetryTime = ulRetry;

    RegDeleteValue( hkey, ptszName );
    lRet = RegSetValueEx(  hkey,
                           ptszName,
                           0,
                           REG_BINARY,
                           (CONST BYTE *)&TimerPersistence,
                           sizeof(TimerPersistence) );

    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't write to registry") ));
        TrkRaiseWin32Error( lRet );
    }

    RegCloseKey( hkey );
}



void
CTimerTest::VerifyRegistryDataCorrect()
{
    LONG lRet = ERROR_SUCCESS;
    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey,
                            _ptszName,
                            NULL,
                            &dwType,
                            (BYTE *)&persist,
                            &cbData );
    RegCloseKey( hkey );

    cftDelta = _cftExpected - persist.cftDue;

    if( lRet != ERROR_SUCCESS
        ||
        dwType != REG_BINARY
        ||
        cbData != sizeof(persist)
        ||
        persist.cftDue > _cftExpected
        ||
        cftDelta > g_cftDeltaMargin )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Registry data isn't correct (%d, %d, %d,\n  %s,\n  %s"),
            lRet, dwType, cbData, CDebugString(persist.cftDue)._tsz, CDebugString(_cftExpected)._tsz ));
        TrkRaiseWin32Error( E_FAIL );
    }
}


void
CTimerTest::VerifyRegistryDataRemoved()
{
    LONG lRet = ERROR_SUCCESS;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey, g_tszDefaultName, NULL, &dwType, (BYTE*)&persist, &cbData );
    RegCloseKey( hkey );

    if( ERROR_FILE_NOT_FOUND != lRet )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Registry data wasn't removed") ));
        TrkRaiseWin32Error( E_FAIL );
        return;
    }

    return;
}




PTimerCallback::TimerContinuation
CTimerTest0::Timer( ULONG ulTimerContext)
{
    CFILETIME cftDelta(0);

    if( ulTimerContext != 0 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs( static_cast<int>(CFILETIME() - _cftExpected) );
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 0")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Release the main test controller

    MarkTestCompleted();

    return( CONTINUE_TIMER );
}


PTimerCallback::TimerContinuation
CTimerTest1::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;
    LONG lRet = ERROR_SUCCESS;
    ULONG ulRetryPeriod;
    static CFILETIME cftBeforeRetries(0);

    if( ulTimerContext != 1 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // We shouldn't be called in the final sub-phase.

    if( FINAL == _SubPhase )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Called after the timer was stopped\n")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that this time was stored in the Registry

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key") ));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey,
                            _ptszName,
                            NULL,
                            &dwType,
                            (BYTE *)&persist,
                            &cbData );
    RegCloseKey( hkey );

    if( lRet != ERROR_SUCCESS
        ||
        dwType != REG_BINARY
        ||
        cbData != sizeof(persist)
        ||
        cftNow - persist.cftDue > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Value in registry wasn't correct") ));
        TrkRaiseWin32Error( E_FAIL );
    }
    
    //  -----------------------------
    //  Move on to the next sub-phase
    //  -----------------------------

    ulRetryPeriod = g_ulMinRetry;

    // Switch on the sub-phase which just completed.

    switch( _SubPhase )
    {

    case INITIAL:

        _tprintf( TEXT("   Letting recur\n") );

        continuation = CONTINUE_TIMER;
        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod );

        break;

    case THIRD_RETRY:
    case SECOND_RETRY:

        ulRetryPeriod *= 2;

    case FIRST_RETRY:

        ulRetryPeriod *= 2;

    case FIRST_RECURRENCE:

        _tprintf( TEXT("   Retrying timer (%ds)\n"), ulRetryPeriod );
        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( ulRetryPeriod );

        continuation = RETRY_TIMER;

        break;

    case FOURTH_RETRY:

        _tprintf( TEXT("   Letting timer recur\n") );
        continuation = CONTINUE_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod  );

        break;

    case SECOND_RECURRENCE:

        VerifyRegistryDataCorrect();

        _tprintf( TEXT("   Retrying one more time (%ds)\n"), g_ulMinRetry );

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulMinRetry );

        continuation = RETRY_TIMER;
        break;

    case LAST_RETRY:

        _tprintf( TEXT("   Stopping timer\n") );
        continuation = BREAK_TIMER;
        MarkTestCompleted();

        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Invalid sub-phase in phase 1 (%d)"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch

    _SubPhase++;

    return( continuation );
}


PTimerCallback::TimerContinuation
CTimerTest2::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;
    LONG lRet = ERROR_SUCCESS;
    ULONG ulRetryPeriod;
    static CFILETIME cftBeforeRetries(0);

    if( ulTimerContext != 2 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // We shouldn't be called in the final sub-phase.

    if( FINAL == _SubPhase )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Called after the timer was stopped\n")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }

    //  -----------------------------
    //  Move on to the next sub-phase
    //  -----------------------------

    switch( _SubPhase )
    {
    case INITIAL:

        // Verify that the registry was set correctly
        VerifyRegistryDataCorrect();

        // Restart the timer to a new time

        _tprintf( TEXT("   Restarting timer (%ds), still recurring and non-retrying\n"),
                  g_ulDefaultPeriod * 2 );
        _timer.ReInitialize( g_ulDefaultPeriod * 2 );
        continuation = CONTINUE_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod * 2  );

        break;

    case RESET:

        // Verify that the registry was set correctly
        VerifyRegistryDataCorrect();

        // Release the main test controller
        MarkTestCompleted();

        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Invalid sub-phase in phase 2 (%d)"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( (SUB_PHASE2_ENUM) g_SubPhase )

    _SubPhase++;


    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest3::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 3 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 3")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        VerifyRegistryDataCorrect();

        // We're done

        continuation = BREAK_TIMER;

        // Release the main test controller
        MarkTestCompleted();

        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Invalid sub-phase in phase 3 (%d)"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest4::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 4 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }



    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod/2 );
        VerifyRegistryDataRemoved();

        continuation = RETRY_TIMER;
        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod / 2 );

        break;

    case SECOND:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod );
        continuation = RETRY_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod );

        break;

    case THIRD:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod*2 );
        continuation = RETRY_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod * 2 );

        break;

    case FOURTH:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod/4 );
        continuation = RETRY_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod / 4 );

        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();
        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase in phase 4"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest5::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 5 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }



    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        continuation = BREAK_TIMER;
        VerifyRegistryDataRemoved();    // Since this is a non-persistent timer
        MarkTestCompleted();
        break;


    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase in phase 5"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest6::Timer( ULONG ulTimerContext )
{
    CFILETIME cftDelta(0), cftNow;
    PTimerCallback::TimerContinuation continuation = BREAK_TIMER;

    if( ulTimerContext != 6 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Validate the fire time

    if( _SubPhase == INITIAL )
    {
        cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
        if( cftDelta > g_cftDeltaMargin )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Timer expired too soon/late in phase 4") ));
            TrkRaiseWin32Error( E_FAIL );
        }
    }
    else
    {
        if( cftNow < _cftLower - g_cftDeltaMargin
            ||
            cftNow > _cftUpper + g_cftDeltaMargin )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Timer expired too soon/late in phase 6") ));
            TrkRaiseWin32Error( E_FAIL );
        }
    }

    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        _tprintf( TEXT("   Letting recur\n") );
        continuation = CONTINUE_TIMER;
        
        // Set the due time
        _cftLastSet = _cftLower = cftNow;
        _cftLower.IncrementSeconds( g_ulDefaultPeriod );
        _cftUpper = _cftLower;

        break;

    case FIRST_RECURRENCE:

        _tprintf( TEXT("   Retrying ") );
        continuation = RETRY_TIMER;

        _cftLastSet = _cftLower = _cftUpper = cftNow;
        _cftLower.IncrementSeconds( g_ulMinRetry );
        _cftUpper.IncrementSeconds( g_ulMaxRetry );

        break;

    case FIRST_RETRY:
    case SECOND_RETRY:
    case THIRD_RETRY:

        // Show how long the retry was
        _tprintf( TEXT("(%2ds)\n"), static_cast<LONG>(cftNow-_cftLastSet)/10000000 );

        _tprintf( TEXT("   Retrying ") );
        continuation = RETRY_TIMER;

        _cftLastSet = _cftLower = _cftUpper = cftNow;
        _cftLower.IncrementSeconds( g_ulMinRetry );
        _cftUpper.IncrementSeconds( g_ulMaxRetry );

        break;

    case FOURTH_RETRY:

        // Show how long the retry was
        _tprintf( TEXT("(%2ds)\n"), static_cast<LONG>(cftNow-_cftLastSet)/10000000 );

        _tprintf( TEXT("   Recurring one last time (%ds)\n"), g_ulDefaultPeriod );
        continuation = CONTINUE_TIMER;

        _cftLastSet = _cftLower = cftNow;
        _cftLower.IncrementSeconds( g_ulDefaultPeriod );
        _cftUpper = _cftLower;

        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();

        break;
        

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase %d in test 6"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( (SUB_PHASE4_ENUM) g_SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest7::Timer( ULONG ulTimerContext )
{
    CFILETIME cftDelta(0), cftNow;
    PTimerCallback::TimerContinuation continuation = BREAK_TIMER;

    if( ulTimerContext != 7 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        _tprintf( TEXT("   Starting again from the callback, while returning retry_timer\n") );

        _tprintf( TEXT("      Ensure the timer doesn't fire while we're in the callback\n") );
        Set();
        Sleep( _ulPeriod * 2 );

        _timer.Cancel();
        Set();

        continuation = RETRY_TIMER;
        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();

        break;
        

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase %d in test 7"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( g_SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest8::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 8 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 8 (%s - %s)"),
                CDebugString(cftNow)._tsz, CDebugString(_cftExpected)._tsz ));
        TrkRaiseWin32Error( E_FAIL );
    }



    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        continuation = RETRY_TIMER;
        
        _cftExpected = CFILETIME();
        _cftExpected.IncrementSeconds( _ulPeriod*4 );   // The second retry
        
        break;

    case FIRST_RETRY:

        continuation = RETRY_TIMER;
        
        _cftExpected = CFILETIME();
        _cftExpected.IncrementSeconds( _ulPeriod ); // Up to max lifetime
        
        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();
        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase in phase 8"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}






BOOL
IsRegistryEntryExtant()
{
    LONG lRet = ERROR_SUCCESS;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey, g_tszDefaultName, NULL, &dwType, (BYTE*)&persist, &cbData );
    RegCloseKey( hkey );

    if( ERROR_FILE_NOT_FOUND == lRet )
        return FALSE;
    else
        return TRUE;
}


BOOL
IsRegistryEntryCorrect( const CFILETIME &cftExpected )
{
    LONG lRet = ERROR_SUCCESS;
    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey,
                            g_tszDefaultName,
                            NULL,
                            &dwType,
                            (BYTE *)&persist,
                            &cbData );
    RegCloseKey( hkey );

    cftDelta = cftExpected - persist.cftDue;

    if( lRet != ERROR_SUCCESS
        ||
        dwType != REG_BINARY
        ||
        cbData != sizeof(persist)
        ||
        persist.cftDue > cftExpected
        ||
        cftDelta > g_cftDeltaMargin )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}



EXTERN_C void __cdecl _tmain( int argc, TCHAR **argv )
{
    HRESULT hr = S_OK;
    CNewTimer::PersistentState TimerPersistence;
    
    __try
    {

        LONG lRet = ERROR_SUCCESS;
        ULONG ulMaxLifetime;
        CFILETIME cftTimer0(0);

        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TTimer" );
        RegDeleteValue( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack );

        CTimerTest0 cTimer0;
        CTimerTest1 cTimer1;
        CTimerTest2 cTimer2;
        CTimerTest3 cTimer3;
        CTimerTest4 cTimer4;
        CTimerTest5 cTimer5;
        CTimerTest6 cTimer6;
        CTimerTest7 cTimer7;
        CTimerTest8 cTimer8;

        //goto phase8;

        //  -------
        //  Phase 0
        //  -------

        cTimer0.Initialize( );
        cTimer0.Set();
        cTimer0.WaitForTestToComplete();
        cTimer0.EnsureTimerIsStopped(  );

        //  -------
        //  Phase 1
        //  -------
phase1:
        cTimer1.Initialize( );
        cTimer1.Set();
        cTimer1.WaitForTestToComplete();
        cTimer1.EnsureTimerIsStopped(  );


        //  -------
        //  Phase 2
        //  -------

        cTimer2.Initialize( );
        cTimer2.Set();
        cTimer2.WaitForTestToComplete();
        cTimer2.EnsureTimerIsStopped(  );

        //  -------
        //  Phase 3
        //  -------
phase3:
        cTimer3.Initialize();
        cTimer3.Set();
        cTimer3.WaitForTestToComplete();
        cTimer3.EnsureTimerIsStopped();

        // Pause to ensure that the timer clears itself
        Sleep( 1000 );

        //  -------
        //  Phase 4
        //  -------

        cTimer4.Initialize();
        cTimer4.Set();
        cTimer4.WaitForTestToComplete();
        cTimer3.EnsureTimerIsStopped();

        //  -------
        //  Phase 5
        //  -------

phase5:
        cTimer5.Initialize();
        cTimer5.Set();
        cTimer5.WaitForTestToComplete();
        cTimer5.EnsureTimerIsStopped();

        //  -------
        //  Phase 6
        //  -------
phase6:
        cTimer6.Initialize( );
        cTimer6.Set();
        cTimer6.WaitForTestToComplete();
        cTimer6.EnsureTimerIsStopped(  );

phase7:

        cTimer7.Initialize();
        cTimer7.Set();
        cTimer7.WaitForTestToComplete();
        cTimer7.EnsureTimerIsStopped();

phase8:

        cTimer8.Initialize();
        cTimer8.Set();
        cTimer8.WaitForTestToComplete();
        cTimer8.EnsureTimerIsStopped();

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    if( FAILED(hr) )
        _tprintf( TEXT("\nFailed:  hr = %#08x\n"), hr );
    else
        _tprintf( TEXT("\nPassed\n") );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\ttunnel.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       ttunnel.cxx
//
//  Contents:   Utility for multi-thread tunnel tests
//
//  Codework:
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE    // This is the main module, trigger trkwks.hxx to do definitions

#include <trkwks.hxx>

typedef struct
{
    ULONG Vol;
    int file1;
    int file2;
} PARAMS;

class THREAD_FILE_NAME
{
public:
    THREAD_FILE_NAME(LPVOID pv)
    {
        PARAMS *params = (PARAMS*)pv;

        wsprintf(Name1, TEXT("%d"), params->file1);
        wsprintf(Name2, TEXT("%d"), params->file2);

        Vol = params->Vol;
    }

    TCHAR Name1[MAX_PATH];
    TCHAR Name2[MAX_PATH];

    ULONG Vol;
}; 

void
PrintThreadId()
{
    printf("[%d]", GetCurrentThreadId());
}

// dis app
// --- ---
// ren ren
// ren cre
// del cre
// del ren
//

void
CreateWithId( TCHAR * Name, CDomainRelativeObjId * pdroid )
{
    CDomainRelativeObjId droidBirth;

    HANDLE h = CreateFile(
        Name,
        GENERIC_READ|GENERIC_WRITE,
        0,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL );

    if (h!=INVALID_HANDLE_VALUE)
    {
        GetDroids(h, pdroid, &droidBirth, RGO_READ_OBJECTID);
        GetDroids(h, pdroid, &droidBirth, RGO_GET_OBJECTID);

        DelObjId( h );
        GetDroids(h, pdroid, &droidBirth, RGO_READ_OBJECTID);

        GetDroids(h, pdroid, &droidBirth, RGO_GET_OBJECTID);
        CloseHandle(h);
    }
}

void
OpenById(ULONG Vol, const CDomainRelativeObjId & droidCurrent)
{
    NTSTATUS Status;
    HANDLE h;

    Status = OpenFileById( Vol,
                droidCurrent.GetObjId(),
                SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                0,
                0,
                &h );
    if ( NT_SUCCESS(Status) )
    {
        CloseHandle(h);
    }
}

DWORD
WINAPI
RenRen( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("RenRen( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );
            OpenById( Names.Vol, droidCurrent );

        MoveFile( Names.Name1, Names.Name2 );

            OpenById( Names.Vol, droidCurrent );
    
        MoveFile( Names.Name2, Names.Name1 );

            OpenById( Names.Vol, droidCurrent );

        DeleteFile( Names.Name1 );
            OpenById( Names.Vol, droidCurrent );
    }
    return(0);
}

DWORD
WINAPI
RenCre( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("RenCre( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );
            OpenById( Names.Vol, droidCurrent );
    
        MoveFile( Names.Name1, Names.Name2 );

            OpenById( Names.Vol, droidCurrent );
    
        CreateWithId( Names.Name1, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );

        DeleteFile( Names.Name1 );
        DeleteFile( Names.Name2 );

            OpenById( Names.Vol, droidCurrent );

    }    
    return(0);
}

DWORD
WINAPI
DelCre( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("DelCre( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );
    
        DeleteFile( Names.Name1 );

            OpenById( Names.Vol, droidCurrent );
    
        CreateWithId( Names.Name1, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );

        DeleteFile( Names.Name1 );

            OpenById( Names.Vol, droidCurrent );

    }    
    return(0);
}

DWORD
WINAPI
DelRen( LPVOID pvParam )
{
    THREAD_FILE_NAME Names(pvParam);
    CDomainRelativeObjId droidCurrent;

    printf("DelRen( %s %s )\n", Names.Name1, Names.Name2);

    while (1)
    {
        PrintThreadId();
        CreateWithId( Names.Name1, &droidCurrent );
            OpenById( Names.Vol, droidCurrent );
    
        DeleteFile( Names.Name1 );

            OpenById( Names.Vol, droidCurrent );
    
        CreateWithId( Names.Name2, &droidCurrent );

            OpenById( Names.Vol, droidCurrent );

        MoveFile( Names.Name2, Names.Name1 );

            OpenById( Names.Vol, droidCurrent );

    }    
    return(0);
}

LPTHREAD_START_ROUTINE pfn[8] = {
    RenRen,
    RenCre,
    DelRen,
    DelCre
};

#ifdef _UNICODE
EXTERN_C void __cdecl wmain( int argc, wchar_t **argv )
#else
void __cdecl main( int argc, char **argv )
#endif
{
    HRESULT hr = S_OK;
    NTSTATUS status = 0;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TTunnel" );


    // Convert the option to upper case (options are case-insensitive).

    __try
    {
        PARAMS params[24];

        TCHAR tszDir[MAX_PATH];

        GetCurrentDirectory( sizeof(tszDir)/sizeof(tszDir[0]), tszDir );
        CharUpper(tszDir);

        for (int i=0;i<24;i++)
        {
            DWORD dw;
            
            params[i].Vol = tszDir[0]-TEXT('A');

            if (i<8)
            {
                // 8 threads on two files
                params[i].file1 = 0;
                params[i].file2 = 1;
            }
            else
            if (i<16)
            {
                // 8 threads on 4 pairs of files
                params[i].file1 = i/2;  // 4 .. 7
                params[i].file2 = i/2+1; // 5 .. 8
            }
            else
            {
                // 8 threads on 8 pairs of files
                params[i].file1 = i+8;
                params[i].file2 = i+16;
            }

            if (i&1)
            {
                int s = params[i].file1;
                params[i].file1 = params[i].file2;
                params[i].file2 = s;
            }

            HANDLE h = CreateThread(0,NULL,pfn[i%4],&params[i],0,&dw);
            if (h)
            {
                CloseHandle(h);
            }
        }
        Sleep(INFINITE);
    }

    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
        printf( "HR = %08X\n", hr );

    return;

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\svcdlls\trksvcs\utest\ttrkcom.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       ttrkcom.cxx
//
//  Contents:   testing IPersistStreamInit interface
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    21-Apl-97  weiruc      Created.
//
//  Notes:      Use IStream on global memory instead of a file. Not sure if
//              it's worth the trouble to test with disk file.
//
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include <trkwks.hxx>
#include <cfiletim.hxx>
#include <trkcom.h>
#include <trkcom.hxx>
#include <ocidl.h>

DWORD g_Debug = TRKDBG_ERROR;

void ExtractPersistentState(CTrackFile* pTrackFile, LinkTrackPersistentState* target)
{
    memcpy(target, &(pTrackFile->_PersistentState), sizeof(pTrackFile->_PersistentState));
}

BOOL CmpPersistentState(CTrackFile* pTrackFile, LinkTrackPersistentState* target)
{
    if(memcmp(&(pTrackFile->_PersistentState), target, sizeof(pTrackFile->_PersistentState)) != 0)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

void FakeCreateFromPath(CTrackFile* pTrackFile)
{
    char*       pbScanner;

    // I can't get time() function to work. xxx
    // srand((unsigned)time(NULL));
 
        
    pTrackFile->_fLoaded = FALSE;
    pTrackFile->InitNew();

    pbScanner = (char*)&pTrackFile->_PersistentState.droidCurrent;
        TrkAssert(FIELD_OFFSET(LinkTrackPersistentState, droidCurrent) == sizeof(DWORD)+sizeof(CLSID));
    for(; pbScanner < (char*)&pTrackFile->_PersistentState + sizeof(pTrackFile->_PersistentState); pbScanner++)
    {
        *pbScanner = (char)rand();
    }

    pTrackFile->_fDirty = TRUE;
}

EXTERN_C int __cdecl _tmain(int argc, TCHAR **argv)
{ 
    HRESULT                     hr;
    ITrackFile*                 pTrackFile1 = NULL;
    ITrackFile*                 pTrackFile2 = NULL;
    IPersistStreamInit*         pPersistStreamInit = NULL;
    IPersistMemory*             pPersistMemory = NULL;
    IStream*                    pStream = NULL;
    HGLOBAL                     hmemStream = NULL, hmemMemory = NULL;
    CLSID                       clsid;
    ULARGE_INTEGER              cbSize_PersistStream;
    ULONG                       cbSize_PersistMemory;
    LinkTrackPersistentState    target;
    HANDLE                      hfileTest = INVALID_HANDLE_VALUE;
    LPVOID                      pszErrorMsg;
    BOOL                        fInitNew = TRUE,              // flags of whether
                                fIsDirty = TRUE,              // tests succeeded or
                                fSaveStream = TRUE,           // failed
                                fLoadStream = TRUE,
                                fSaveMemory = TRUE,
                                fLoadMemory = TRUE;
    ULARGE_INTEGER              ulSize1;                          //
    ULONG                       ulSize2;                          // filled by GetSizeMax
    ULONG                       cbWritten;
    LARGE_INTEGER               zeroOffset;                     // to reset IStream seek pointer
    DWORD                       cbPath;
    OLECHAR                     oszPath[ MAX_PATH + 1 ];
    BYTE                        rgb[256];

    __try
    {
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TTRKCOM" );
        CoInitialize( NULL );

        hmemStream = GlobalAlloc(GMEM_FIXED, sizeof(target));
        if(NULL == hmemStream)
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &pszErrorMsg,
                          0,
                          NULL);

            _tprintf(TEXT("Fatal error: %s\n"), pszErrorMsg);
            LocalFree(pszErrorMsg);
            goto ExitWithError;
        }
        hmemMemory = GlobalAlloc(GMEM_FIXED, sizeof(target));
        if(NULL == hmemMemory)
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &pszErrorMsg,
                          0,
                          NULL);

            _tprintf(TEXT("Fatal error: %s\n"), pszErrorMsg);
            LocalFree(pszErrorMsg);
            goto ExitWithError;
        }

        if(argc > 1)
        {
            _tprintf(TEXT("Usage: %s"), argv[0]);
            goto ExitWithError;
        }

        _tprintf(TEXT("********** Testing IPersistStreamInit and IPersistMemory **********\n"));

        // Create a temporary file for testing.
        hfileTest = CreateFile(TEXT("c:\\_testfile_"),
                               GENERIC_WRITE, 0, NULL, CREATE_NEW,
                               FILE_ATTRIBUTE_TEMPORARY,
                               NULL);
        if(hfileTest == INVALID_HANDLE_VALUE)
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &pszErrorMsg,
                          0,
                          NULL);


            _tprintf(TEXT("Fatal error: %s\n"), pszErrorMsg);
            LocalFree(pszErrorMsg);
            goto ExitWithError;
        }

        if(CloseHandle(hfileTest) == 0)
        {
            _tprintf(TEXT("Fatal error: Can't close test file \"c:\\_testfile_\"\n"));
            goto ExitWithError;
        }
        hfileTest = INVALID_HANDLE_VALUE;
        
        zeroOffset.QuadPart = 0;

        hr = CoCreateInstance(CLSID_TrackFile, NULL, CLSCTX_ALL, IID_ITrackFile, (void**)&pTrackFile1);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't get an ITrackFile (%08x)\n"), hr);
            goto ExitWithError;
        }

        hr = pTrackFile1->QueryInterface(IID_IPersistStreamInit, (void**)&pPersistStreamInit);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistStreamInit. hr = %08x"), hr);
        }
        hr = pTrackFile1->QueryInterface(IID_IPersistMemory, (void**)&pPersistMemory);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistMemory. hr = %08x"), hr);
        }

        hr = pPersistStreamInit->InitNew();            //  Should be able to call InitNew
        if(!SUCCEEDED(hr))                                 //  on a newly created object
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
            fInitNew = FALSE;
        }



        //  --------------------
        //  Parameter Validation
        //  --------------------

        hr = pTrackFile1->QueryInterface( IID_IPersistStreamInit, NULL );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::QueryInterface(...,NULL) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->CreateFromPath( NULL );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::CreateFromPath(NULL) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->QueryInterface( IID_IPersistStreamInit, NULL );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::QueryInterface(...,NULL) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->Resolve( NULL, oszPath, 1 );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::Resolve(NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pTrackFile1->Resolve( &cbPath, NULL, 1 );
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("ITrackFile::Resolve(...,NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->GetClassID( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::GetClassID(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->Load( NULL, 1);
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::Load(NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->Save( NULL, TRUE, 1);
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::Save(NULL,...) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->Save( &rgb, TRUE, 1);
        if( E_INVALIDARG != hr )
            _tprintf(TEXT("IPersistMemory::Save(...,1) FAILED, hr = %08x\n"), hr );

        hr = pPersistMemory->GetSizeMax( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistMemory::GetSizeMax(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistStreamInit->GetSizeMax( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistStreamInit::GetSizeMax(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistStreamInit->Load( NULL );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistStreamInit::Load(NULL) FAILED, hr = %08x\n"), hr );

        hr = pPersistStreamInit->Save( NULL, TRUE );
        if( E_POINTER != hr )
            _tprintf(TEXT("IPersistStreamInit::Save(NULL,...) FAILED, hr = %08x\n"), hr );









        if(fInitNew == TRUE)
        {
            hr = pPersistMemory->InitNew();            // InitNew can only be called once
            if(SUCCEEDED(hr))
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
                fInitNew = FALSE;
            }
            else if(E_UNEXPECTED != hr)
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
                fInitNew = FALSE;
            }
        }

        hr = pPersistStreamInit->IsDirty();            // IsDirty should return FALSE
        if(S_FALSE != hr)
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr);
            fIsDirty = FALSE;
        }

        pPersistStreamInit->GetSizeMax(&ulSize1);        // Test GetSizeMax
        pPersistMemory->GetSizeMax(&ulSize2);
        if(ulSize1.QuadPart != sizeof(target))
        {
            _tprintf(TEXT("IPersistStreamInit::GetSizeMax FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit::GetSizeMax PASSED\n"));
        }
        if(ulSize2 != sizeof(target))
        {
            _tprintf(TEXT("IPersistMemory::GetSizeMax FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistMemory::GetSizeMax PASSED\n"));
        }

        pPersistStreamInit->GetClassID(&clsid);          // Test GetClassID
        if(IID_ITrackFile != clsid)
        {
            _tprintf(TEXT("IPersistStreamInit::GetClassID FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit::GetClassID PASSED\n"));
        }
        pPersistMemory->GetClassID(&clsid);
        if(IID_ITrackFile != clsid)
        {
            _tprintf(TEXT("IPersistMemory::GetClassID FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistMemory::GetClassID PASSED\n"));
        }

        // This call breaks on my test machine. Since I don't really need it to test my
        // program, I'm going to fake the result from this call.
        // hr = pTrackFile1->CreateFromPath(TEXT("c:\\_testfile_"));
        // if(!SUCCEEDED(hr))
        // {
                // _tprintf(TEXT("Fatal error: Couldn't call CTrackFile::CreateFromPath(\"c:\\_testfile_\") (%08x)\n"), hr);
                // goto ExitWithError;
        // }

        FakeCreateFromPath((CTrackFile*)pTrackFile1);

        if(fIsDirty == TRUE)
        {
            hr = pPersistStreamInit->IsDirty();            // After CreateFromPath IsDirty
            if(S_OK != hr)                                  // should return dirty.
            {
                _tprintf(TEXT("IPersistStreamInit::IsDirty FAILED. hr = %08x\n"), hr);
                _tprintf(TEXT("IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr );
                fIsDirty = FALSE;
            }
        }

        if(fInitNew == TRUE)
        {
            hr = pPersistStreamInit->InitNew();         // Shouldn't be able to call InitNew
            if(S_OK == hr || E_UNEXPECTED != hr)        // after TrackFile is initialized.
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
            }
            else
            {
                _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew PASSED\n"));
            }
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::InitNew FAILED. hr = %08x\n"), hr);
        }

        hr = CreateStreamOnHGlobal(hmemStream, FALSE, &pStream);   // pPersistStreamInit::Save test
        if( !SUCCEEDED(hr) )
        {
            _tprintf(TEXT("Fatal error: Couldn't get an IStream (%08x)\n"), hr);
            goto ExitWithError;
        }
        hr = pPersistStreamInit->Save(pStream, FALSE);  // fClearDirty is set to FALSE
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistStreamInit::Save FAILED (%08x)\n"), hr);
            fSaveStream = FALSE;
        }
        else
        {
            if(fIsDirty == TRUE)
            {
                hr = pPersistStreamInit->IsDirty();  // After Save, IsDirty should still return
                if(S_OK != hr)                       // dirty when fClearDirty is set to be FALSE.
                {
                    _tprintf(TEXT("Either IPersistStreamInit/IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr);
                    _tprintf(TEXT("or     IPersistStreamInit::Save with fClearDirty = FALSE FAILED\n"));
                    fIsDirty = FALSE;
                }
            }
        }
        pStream->Seek(zeroOffset, STREAM_SEEK_SET, NULL);
        hr = pPersistStreamInit->Save(pStream, TRUE);   // set fClearDirty to be TRUE
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistStreamInit::Save FAILED (%08x)\n"), hr);
            fSaveStream = FALSE;
        }
        else
        {
            if(fIsDirty == TRUE)
            {
                hr = pPersistStreamInit->IsDirty();     // After Save, IsDirty should return
                if(S_FALSE != hr)                       // clean when fClearDirty is TRUE.
                {
                    _tprintf(TEXT("Either IPersistStreamInit/IPersistMemory::IsDirty FAILED. hr = %08x\n"), hr);
                    _tprintf(TEXT("or     IPersistStreamInit::Save with fClearDirty = TRUE FAILED\n"));
                    fIsDirty = FALSE;
                }
            }
        }

        if(fIsDirty == TRUE)
        {
            _tprintf(TEXT("IPersistStreamInit/IPersistMemory::IsDirty PASSED\n"));
        }

        hr = pPersistMemory->Save(hmemMemory, FALSE, GlobalSize(hmemMemory));   // test IPersistMemory::Save
        if(!SUCCEEDED(hr))                                                                      // fClearDirty is set to be FALSE
        {
            _tprintf(TEXT("IPersistMemory::Save FAILED (%08x)\n"), hr);
            fSaveMemory = FALSE;
        }
        hr = pPersistMemory->Save(hmemMemory, TRUE, GlobalSize(hmemMemory));    // fClearDirty = TRUE
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistMemory::Save FAILED (%08x)\n"), hr);
            fSaveMemory = FALSE;
        }

        if(TRUE == fSaveStream && TRUE == fSaveMemory)  // Compare the memory content after
        {                                                   // Save operation
            ExtractPersistentState((CTrackFile*)pTrackFile1, &target);
            if(memcmp(hmemStream, &target, sizeof(target)) == 0)
            {
                _tprintf(TEXT("IPersistStreamInit::Save PASSED (if no error message before about fClearDirty)\n"));
            }
            else
            {
                _tprintf(TEXT("IPersistStreamInit::Save FAILED\n"));
            }
            if(memcmp(hmemMemory, &target, sizeof(target)) == 0)
            {
                _tprintf(TEXT("IPersistMemory::Save PASSED (if no error message before about fClearDirty)\n"));
            }
            else
            {
                _tprintf(TEXT("IPersistMemory::Save FAILED\n"));
            }
        }
        RELEASE_INTERFACE(pTrackFile1);
        RELEASE_INTERFACE(pPersistMemory);
        RELEASE_INTERFACE(pPersistStreamInit);
        RELEASE_INTERFACE(pStream);

        // Test Load functions
        hr = CoCreateInstance(IID_ITrackFile, NULL, CLSCTX_ALL, IID_ITrackFile, (void**)&pTrackFile1);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't get an ITrackFile (%08x)\n"), hr);
            goto ExitWithError;
        }   
        hr = pTrackFile1->QueryInterface(IID_IPersistStreamInit, (void**)&pPersistStreamInit);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistStreamInit"));
            goto ExitWithError;
        }

        hr = CoCreateInstance(IID_ITrackFile, NULL, CLSCTX_ALL, IID_ITrackFile, (void**)&pTrackFile2);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't get an ITrackFile (%08x)\n"), hr);
            goto ExitWithError;
        }
        hr = pTrackFile2->QueryInterface(IID_IPersistMemory, (void**)&pPersistMemory);
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("Couldn't QI ITrackFile for IPersistMemory"));
            goto ExitWithError;
        }

        memcpy(hmemMemory, &target, sizeof(target));     // Set up sources to load from
        CreateStreamOnHGlobal(hmemStream, TRUE, &pStream);
        hr = pStream->Write((byte*)&target, sizeof(target), &cbWritten);
        if(!SUCCEEDED(hr) || sizeof(target) != cbWritten)
        {
            _tprintf(TEXT("Fatal error: Can't create stream object\n"));
            goto ExitWithError;
        }
        pStream->Seek(zeroOffset, STREAM_SEEK_SET, NULL);

        hr = pPersistStreamInit->Load(pStream);         // Test IPersistStreamInit::Load
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistStreamInit::Load FAILED. hr = %08x\n"), hr);
        }
        else if(CmpPersistentState((CTrackFile*)pTrackFile1, (LinkTrackPersistentState*)hmemStream) != TRUE)
        {
            _tprintf(TEXT("IPersistStreamInit::Load FAILED"));
        }
        else
        {
            _tprintf(TEXT("IPersistStreamInit::Load PASSED\n"));
        }

        hr = pPersistMemory->Load(hmemMemory, GlobalSize(hmemMemory));  // Test IPersistMemory::Load
        if(!SUCCEEDED(hr))
        {
            _tprintf(TEXT("IPersistMemory::Load FAILED. hr = %08x\n"), hr);
        }
        else if(CmpPersistentState((CTrackFile*)pTrackFile2, (LinkTrackPersistentState*)hmemMemory) != TRUE)
        {
            _tprintf(TEXT("IPersistMemory::Load FAILED\n"));
        }
        else
        {
            _tprintf(TEXT("IPersistMemory::Load PASSED\n"));
        }
    }
    __except(BreakOnDebuggableException())
    {
        _tprintf(TEXT("Exception happened. Exception code = %08x\n"), GetExceptionCode());
    }

ExitWithError:

    RELEASE_INTERFACE(pTrackFile1);
    RELEASE_INTERFACE(pTrackFile2);
    RELEASE_INTERFACE(pPersistStreamInit);
    RELEASE_INTERFACE(pPersistMemory);
    RELEASE_INTERFACE(pStream);
    
    GlobalFree(hmemStream);
    GlobalFree(hmemMemory);

    if(DeleteFile(TEXT("c:\\_testfile_")) == 0)
    {
        _tprintf(TEXT("WARNING: Couldn't delete test file \"c:\\_testfile_\""));
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\cmacs.h ===
/****************************** Module Header ******************************\
* Module Name: CMACS.H
*
* This module contains common macros used by C routines.
*
* Created: 9-Feb-1989
*
* Copyright (c) 1985 - 1989  Microsoft Corporation
*
* History:
*   Created by Raor
*
\***************************************************************************/

#define _WINDOWS
#define  DLL_USE

#define INTERNAL        PASCAL NEAR
#define FARINTERNAL     PASCAL FAR

#ifdef FIREWALLS
extern short ole_flags;

#define DEBUG_PUTS          0x01
#define DEBUG_DEBUG_OUT     0x02
#define DEBUG_MESSAGEBOX    0x04

extern char    szDebugBuffer[];

#define DEBUG_OUT(parm1,parm2){\
    if(ole_flags & DEBUG_DEBUG_OUT){\
            wsprintf(szDebugBuffer,parm1,parm2);\
        OutputDebugString(szDebugBuffer);\
            OutputDebugString ("^^^  ");\
        }\
    }

#define ASSERT(x,y) {\
    if (!(x)) { \
        wsprintf (szDebugBuffer, "Assert Failure file %s, line %d\r\n     ", \
            (LPSTR) __FILE__, __LINE__);\
        OutputDebugString (szDebugBuffer);\
        OutputDebugString ((LPSTR) (y));\
        OutputDebugString ("@@@  ");\
    } \
}

#define Puts(msg) {\
                    if(ole_flags & DEBUG_PUTS){\
                        OutputDebugString ((LPSTR)(msg));\
                        OutputDebugString ("**  ");\
                    }\
                  }

#else

#define DEBUG_OUT(err, val) ;
#define ASSERT(cond, msg)
#define Puts(msg)        

#endif /* FIREWALLS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\checkptr.c ===
/* CheckPtr.c
   Pointer validation routine
   Written by t-jasonf.
*/

#include "windows.h"
#include "dll.h"


/* CheckPointer()
   Parameters : 
      LPVOID lp         - pointer to check
      int    nREADWRITE - READ_ACCESS or WRITE_ACCESS
   Returns:
      0 if process does not have that kind of access to memory at lp.
      1 if process does have access.
*/
int CheckPointer (void *lp, int nReadWrite)
{
   char ch;
   int iRet;

   try
   {
      switch (nReadWrite)
      {
         case READ_ACCESS:
            ch = *((volatile char *)lp);
            break;
         case WRITE_ACCESS:
            ch = *((volatile char *)lp);
            *((volatile char *)lp) = ch;
            break;
      }
      iRet = 1;
   }
   except ( /*
            GetExceptionCode == STATUS_ACCESS_VIOLATION 
            ? EXCEPTION_EXECUTE_HANDLER
            : EXCEPTION_CONTINUE_SEARCH
            */
            EXCEPTION_EXECUTE_HANDLER
          )
   {
      iRet = 0;
   }

   return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\bm.c ===
/****************************** Module Header ******************************\
* Module Name: BM.C
*
* Handles all API routines for the bitmap sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor,Srinik  (../../1990,91)    Designed, coded
*   Curts create NT version
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

extern int   maxPixelsX, maxPixelsY;
void INTERNAL GetHimetricUnits(HBITMAP, LPPOINT);

#ifdef WIN16
#pragma alloc_text(_TEXT, BmSaveToStream, BmStreamWrite, BmLoadFromStream, BmStreamRead, GetBytes, PutBytes, PutStrWithLen, BmQueryBounds, BmChangeData, BmCopy, BmDuplicate, BmUpdateStruct, GetHimetricUnits)
#endif

OLEOBJECTVTBL    vtblBM  = {

        ErrQueryProtocol,  // check whether the speced protocol is supported

        BmRelease,         // Release
        ErrShow,           // Show
        ErrPlay,           // play
        BmGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//

        ErrSetBounds,      // set viewport bounds
        BmEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //
        BmRelease,         // delete
        ErrSetHostNames,   //

        BmSaveToStream,    // write to file
        BmClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Link

        BmEqual,           // compares the given objects for data equality

        BmCopy,            // copy to clip

        BmDraw,            // draw the object

        ErrActivate,       // open
        ErrExecute,        // excute
        ErrClose,          // Stop
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type

        ErrGetUpdateOptions,// update options
        ErrSetUpdateOptions,// update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name

        ObjQueryType,      // Object type
        BmQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current

        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        BmChangeData        // change data of the existing object
};



OLESTATUS  FARINTERNAL BmRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    HOBJECT     hobj;

    if (lpobj->hBitmap) {
        DeleteObject (lpobj->hBitmap);
        lpobj->hBitmap = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);

    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL BmSaveToStream (
    LPOLEOBJECT    lpoleobj,
    LPOLESTREAM    lpstream
){
    DWORD       dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_BM lpobj     = (LPOBJECT_BM)lpoleobj;
    DWORD       dwSize    = lpobj->sizeBytes - sizeof(BITMAP) + sizeof(WIN16BITMAP);

    if (!lpobj->hBitmap || !lpobj->sizeBytes)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"BITMAP"))
        return OLE_ERROR_STREAM;

    if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
            if (!PutBytes (lpstream, (LPSTR) &dwSize, sizeof(DWORD)))
            return BmStreamWrite (lpstream, lpobj);
    }
    return OLE_ERROR_STREAM;
}


OLESTATUS FARINTERNAL  BmClone (
    LPOLEOBJECT         lpoleobj,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){
    LPOBJECT_BM         lpobjsrc = (LPOBJECT_BM)lpoleobj;
    LPOBJECT_BM  FAR *  lplpobj  = (LPOBJECT_BM  FAR *)lplpoleobj;

    if (!CheckClientDoc ((LPCLIENTDOC)lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(*lplpobj = BmCreateObject (lpobjsrc->hBitmap, lpclient, FALSE,
                            lhclientdoc, lpobjname,
                            lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}


OLESTATUS FARINTERNAL  BmEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_BM lpobj1 = (LPOBJECT_BM)lpoleobj1;
    LPOBJECT_BM lpobj2 = (LPOBJECT_BM)lpoleobj2;
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    LPSTR       lpBits1 = NULL, lpBits2 = NULL;
    OLESTATUS   retVal;
    DWORD       dwBytes1, dwBytes2;


    if (lpobj1->sizeBytes != lpobj2->sizeBytes)
        return OLE_ERROR_NOT_EQUAL;

    retVal = OLE_ERROR_MEMORY;

    if (!(hBits1 = GlobalAlloc (GMEM_MOVEABLE, lpobj1->sizeBytes)))
        goto errEqual;

    if (!(lpBits1 = GlobalLock (hBits1)))
        goto errEqual;

    if (!(hBits2 = GlobalAlloc (GMEM_MOVEABLE, lpobj2->sizeBytes)))
        goto errEqual;

    if (!(lpBits2 = GlobalLock (hBits2)))
        goto errEqual;

    dwBytes1 = GetBitmapBits (lpobj1->hBitmap, lpobj1->sizeBytes, lpBits1);
    dwBytes2 = GetBitmapBits (lpobj2->hBitmap, lpobj2->sizeBytes, lpBits2);

    if (dwBytes1 != dwBytes2) {
        retVal = OLE_ERROR_NOT_EQUAL;
        goto errEqual;
    }

    // !!! UtilMemCmp has to be redone for >64k bitmaps
    if (UtilMemCmp (lpBits1, lpBits2, dwBytes1))
        retVal = OLE_ERROR_NOT_EQUAL;
    else
        retVal = OLE_OK;

errEqual:
    if (lpBits1)
        GlobalUnlock (hBits1);

    if (lpBits2)
        GlobalUnlock (hBits2);

    if (hBits1)
        GlobalFree (hBits1);

    if (hBits2)
        GlobalFree (hBits2);

    return retVal;
}



OLESTATUS FARINTERNAL BmCopy (
    LPOLEOBJECT lpoleobj
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    HBITMAP hBitmap;
    DWORD   size;

    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    if(!(hBitmap = BmDuplicate (lpobj->hBitmap, &size, NULL)))
        return OLE_ERROR_MEMORY;

    SetClipboardData(CF_BITMAP, hBitmap);
    return OLE_OK;
}


OLESTATUS FARINTERNAL BmQueryBounds (
    LPOLEOBJECT lpoleobj,
    LPRECT      lpRc
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;

    Puts("BmQueryBounds");

    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL BmEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;

    if (!cfFormat)
        return CF_BITMAP;

    return 0;
}



OLESTATUS FARINTERNAL BmGetData (
   LPOLEOBJECT     lpoleobj,
   OLECLIPFORMAT   cfFormat,
   LPHANDLE        lphandle
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;

    if (cfFormat != CF_BITMAP)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hBitmap))
        return OLE_ERROR_BLANK;
    return OLE_OK;

}




OLESTATUS FARINTERNAL BmLoadFromStream (
   LPOLESTREAM         lpstream,
   LPOLECLIENT         lpclient,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpoleobject,
   LONG                objType
){
    LPOBJECT_BM lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = BmCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
            if (!GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
            if (BmStreamRead (lpstream, lpobj)) {
                *lplpoleobject = (LPOLEOBJECT)lpobj;
                return OLE_OK;
            }
    }

    OleDelete ((LPOLEOBJECT)lpobj);
    return OLE_ERROR_STREAM;;
}



OLESTATUS INTERNAL BmStreamWrite (
   LPOLESTREAM     lpstream,
   LPOBJECT_BM     lpobj
){
    HANDLE      hBits;
    LPSTR       lpBits;
    int         retVal   = OLE_ERROR_STREAM;
    BITMAP      bm;
    DWORD       dwSize;

    dwSize = lpobj->sizeBytes - sizeof(BITMAP);

    if (hBits = GlobalAlloc (GMEM_MOVEABLE, dwSize)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (GetBitmapBits (lpobj->hBitmap, dwSize, lpBits)) {
                WIN16BITMAP w16bm;

                GetObject (lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm);
                ConvertBM32to16(&bm, &w16bm);

                if (!PutBytes (lpstream, (LPSTR) &w16bm, sizeof(WIN16BITMAP)))
                    if (!PutBytes (lpstream, (LPSTR) lpBits, dwSize))
                        retVal = OLE_OK;
            }
            GlobalUnlock(hBits);
        } else
            retVal = OLE_ERROR_MEMORY;
        GlobalFree(hBits);
    } else
        retVal = OLE_ERROR_MEMORY;

    return retVal;
}



BOOL INTERNAL BmStreamRead (
   LPOLESTREAM     lpstream,
   LPOBJECT_BM     lpobj
){
    HANDLE      hBits;
    LPSTR       lpBits;
    BOOL        retVal   = FALSE;
    BITMAP      bm;
    WIN16BITMAP w16bm;
    POINT       point;

    if (GetBytes (lpstream, (LPSTR)&w16bm, sizeof(WIN16BITMAP)))
        return FALSE;

    ConvertBM16to32(&w16bm,&bm);

    lpobj->sizeBytes -= sizeof(WIN16BITMAP) ;

    if (hBits = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (!GetBytes(lpstream, lpBits, lpobj->sizeBytes)) {
                if (lpobj->hBitmap = CreateBitmap (bm.bmWidth,
                                            bm.bmHeight,
                                            bm.bmPlanes,
                                            bm.bmBitsPixel,
                                            lpBits)) {
                    retVal = TRUE;
                    lpobj->xSize = point.x = bm.bmWidth;
                    lpobj->ySize = point.y = bm.bmHeight;

                    // size of (bitmap header + bits)
                    lpobj->sizeBytes += sizeof(BITMAP);

#ifdef OLD
                    // !!! We shouldn't do the conversion. The info should be
                    // part of the stream.
                    if (!lpobj->head.cx) {
                        ConvertToHimetric (&point);
                        lpobj->head.cx = (LONG) point.x;
                        lpobj->head.cy = (LONG) point.y;
                    }
#endif
                 }
             }
             GlobalUnlock(hBits);
        }
        GlobalFree(hBits);
    }
    return  retVal;
}


OLESTATUS FARINTERNAL BmPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HBITMAP     hBitmap;

    *lplpoleobject = NULL;

    if ((hBitmap = (HBITMAP) GetClipboardData(CF_BITMAP)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) BmCreateObject (hBitmap,
                                                lpclient, FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;

}


LPOBJECT_BM INTERNAL BmCreateObject (
    HBITMAP     hBitmap,
    LPOLECLIENT lpclient,
    BOOL        fDelete,
    LHCLIENTDOC lhclientdoc,
    LPCSTR      lpobjname,
    LONG        objType
){
    LPOBJECT_BM     lpobj;

    if (lpobj = BmCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (BmChangeData ((LPOLEOBJECT)lpobj, (HANDLE)hBitmap, lpclient, fDelete) != OLE_OK) {
            BmRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewBitmap will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL BmChangeData (
    LPOLEOBJECT lpoleobj,
    HANDLE      hNewBitmap,
    LPOLECLIENT lpclient,
    BOOL        fDelete
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    BITMAP      bm;
    DWORD       dwSize;
    HBITMAP     hOldBitmap;

    hOldBitmap = lpobj->hBitmap;

    if (!fDelete) {
        if (!(hNewBitmap = BmDuplicate (hNewBitmap, &dwSize, &bm)))
            return OLE_ERROR_MEMORY;
    }
    else {
        if (!GetObject (hNewBitmap, sizeof(BITMAP), (LPSTR) &bm)) {
            DeleteObject (hNewBitmap);
            return OLE_ERROR_MEMORY;
        }
//*add get bitmap bits
        dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
                 ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);
    }

    BmUpdateStruct (lpobj, lpclient, hNewBitmap, &bm, dwSize);
    if (hOldBitmap)
        DeleteObject (hOldBitmap);

    return OLE_OK;
}


void INTERNAL BmUpdateStruct (
   LPOBJECT_BM lpobj,
   LPOLECLIENT lpclient,
   HBITMAP     hBitmap,
   LPBITMAP    lpBm,
   DWORD       dwBytes
){
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->xSize = point.x = lpBm->bmWidth;
    lpobj->ySize = point.y = lpBm->bmHeight;
    GetHimetricUnits (hBitmap, &point);
    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->sizeBytes = dwBytes + sizeof(BITMAP);
    lpobj->hBitmap = hBitmap;
}

LPOBJECT_BM FARINTERNAL BmCreateBlank (
   LHCLIENTDOC lhclientdoc,
   LPSTR       lpobjname,
   LONG        objType
){
    HOBJECT hobj;
    LPOBJECT_BM lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_BM)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_BM) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblBM;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                    (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}



HBITMAP FARINTERNAL BmDuplicate (
    HBITMAP     hold,
    DWORD FAR * lpdwSize,
    LPBITMAP    lpBm
){
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;
    INT         iX,iY;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL)) {
        if (hnew) retVal = SetBitmapBits (hnew, dwSize, lpMem);
    }

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }
    *lpdwSize = dwSize;
    if (lpBm)
        *lpBm = bm;

    if (MGetBitmapDimension (hold,&iX,&iY))
        if (hnew) MSetBitmapDimension (hnew, iX, iY);

    return hnew;
}


void INTERNAL GetHimetricUnits(HBITMAP hBitmap, LPPOINT lpPoint)
{
    HDC     hdc;
    INT     iX,iY;

    MGetBitmapDimension (hBitmap,&iX,&iY);

    if (iX || iY) {
        lpPoint->x = 10 * iX;
        lpPoint->y = - (10 * iY);
        return;
    }

    // clip if it exceeds maxPixels. Note that we have a limitation of
    // 0x8FFF HIMETRIC units in OLE1.0

    if (lpPoint->x > maxPixelsX)
        lpPoint->x = maxPixelsX;

    if (lpPoint->y > maxPixelsY)
        lpPoint->y = maxPixelsY;

    if (hdc = GetDC (NULL)) {
        lpPoint->x = MulDiv (lpPoint->x, 2540,
                         GetDeviceCaps (hdc, LOGPIXELSX));
        lpPoint->y = - MulDiv (lpPoint->y, 2540,
                         GetDeviceCaps (hdc, LOGPIXELSY));
        ReleaseDC (NULL, hdc);
    }
    else {
        lpPoint->x = 0;
        lpPoint->y = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\dde.c ===
/****************************** Module Header ******************************\
* Module Name: DDE.C (Extensible Compound Documents -DDE)
*
* Copyright (c) 1985 - 1991 Microsoft Corporation
*
* PURPOSE: Handles all API routines for the dde sub-dll of the ole dll.
*
* History:
*   Raor,Srinik  (../../90,91)  Designed and coded
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"

/* #define GRAPHBUG */


// ### may not need seperate wndproc for system topic!
HANDLE  GetDDEDataHandle (DDEDATA FAR *, UINT, HANDLE);

extern  ATOM        aSystem;
extern  ATOM        aOle;
extern  HANDLE      hInstDLL;


// DocWndProc: Window procedure used to document DDE conversations

LRESULT FAR PASCAL DocWndProc(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
){
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;



    Puts("DocWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLongPtr (hwnd, 0))
    {
        pedit = lpobj->pDocEdit;
    }
    else
    {
        // Can't cope so just pass this message on
        DEBUG_OUT ("SYS: doc conv block missing",0);
        return DefWindowProc (hwnd, message, wParam, lParam);
    }

    switch (message){

        case WM_DDE_ACK:
#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_ACK ", 0);
            if (pedit->bTerminating){
                // ### this error recovery may not be correct.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch(pedit->awaitAck){

                case AA_INITIATE:
                    HandleAckInitMsg (pedit, (HWND)wParam);
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));
                    break;

                case AA_REQUEST:
                    Puts("Request");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_UNADVISE:
                    Puts("Unadvise");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_EXECUTE:
                    Puts("Execute");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_ADVISE:
                    Puts("Advise");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                case AA_POKE:

                    // freeing pokedata is done in handleack
                    Puts("Poke");
                    HandleAck (lpobj, pedit, wParam, lParam);
                    break;

                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;

            } // end of switch
            break;

        case WM_TIMER:
#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            HandleTimerMsg (lpobj, pedit);
            break;

        case WM_DDE_DATA:
#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_DATA",0);
            HandleDataMsg (lpobj, GET_WM_DDE_DATA_HDATA(wParam,lParam),
                                  GET_WM_DDE_DATA_ITEM(wParam,lParam));
            DDEFREE(message, lParam);
            break;

        case WM_DDE_TERMINATE:

#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_TERMINATE",0);
            HandleTermMsg (lpobj, pedit, (HWND)wParam, TRUE);
            break;

        case WM_DESTROY:

#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("Client window being destroyed", 0)
            pedit->hClient = NULL;
            break;

        default:
            return DefWindowProc (hwnd, message, wParam, lParam);

    }
    return 0L;
}



// SrvrWndProc: Window Procedure for System Topic DDE conversations
// wndproc for system topic

LRESULT FAR PASCAL SrvrWndProc(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
){
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;

    Puts("SysWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLongPtr (hwnd, 0))
    {
        pedit = lpobj->pSysEdit;
    }
    else
    {
        // Can't cope so just pass this message on
        DEBUG_OUT ("SYS: conv edit block missing",0);
        return DefWindowProc (hwnd, message, wParam, lParam);
    }


    switch (message){

       case WM_DDE_ACK:

#ifdef  FIREWALLS
            ASSERT (pedit, "sys conv edit block missing");
#endif

            DEBUG_OUT ("SYS: WM_DDE_ACK",0);

            if(pedit->bTerminating){
                //### Error recovery may not be OK.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch (pedit->awaitAck) {


                case AA_INITIATE:

#ifdef      HISTORY
                    if (GETWINDOWUINT((HWND)wParam, GWW_HINSTANCE) == pedit->hInst ||
                            IsSrvrDLLwnd ((HWND)wParam, pedit->hInst)) {
                        // For exact instance match or for
                        // DLL instance match, keep the new one
#ifdef  FIREWALLS
        ASSERT (!pedit->hServer, "Two instances are matching");
#endif

                        pedit->hServer = (HWND)wParam;
                    } else {

                        ++pedit->extraTerm;
                        // This post directly is alright since we are
                        // terminating extra initiates.

                        PostMessage ((HWND)wParam,
                                WM_DDE_TERMINATE, hwnd, 0);
                    }
#else

                    HandleAckInitMsg (pedit, (HWND)wParam);
#endif
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));

                    break;

                case AA_EXECUTE:
                    HandleAck(lpobj, pedit, wParam, lParam);
                    break;


                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;


            }

            break;

       case WM_TIMER:
#ifdef  FIREWALLS
            ASSERT (pedit, "sys conv edit block missing");
#endif

            HandleTimerMsg (lpobj, pedit);
            break;

       case WM_DDE_TERMINATE:

#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif
            HandleTermMsg (lpobj, pedit, (HWND)wParam, FALSE);
            break;

       case WM_DESTROY:
#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif
            DEBUG_OUT ("destroy window for the sys connection", 0);
            pedit->hClient = NULL;
            break;


       default:
            return DefWindowProc (hwnd, message, wParam, lParam);

       }
       return 0L;
}

void    INTERNAL    HandleTimerMsg (
    LPOBJECT_LE lpobj,
    PEDIT_DDE   pedit
){


    // Since there is only one timer for each client, just
    // repost the message and delete the timer.

    KillTimer (pedit->hClient, 1);
    pedit->wTimer = 0;

    if (PostMessageToServer(pedit, pedit->msg, pedit->lParam))
        return ; // return something.

    // Postmessage failed. We need to getback to the main stream of
    // commands for the object.
    HandleAck (lpobj, pedit, (WPARAM)NULL, pedit->lParam);
    return ;
}


void INTERNAL   HandleTermMsg (lpobj, pedit, hwndPost, bDoc)
    LPOBJECT_LE     lpobj;
    PEDIT_DDE       pedit;
    HWND            hwndPost;
    BOOL            bDoc;
{
    UINT    asyncCmd;
    BOOL    bBusy;

    if (pedit->hServer != hwndPost){
        DEBUG_OUT ("Got terminate for extra conversation",0)
        if (--pedit->extraTerm == 0 && pedit->bTerminating)
            ScheduleAsyncCmd (lpobj);
        return;

    }

    if (!pedit->bTerminating){

        // If we are waiting for any ack, then goto next step with error

        // delete any data if we were in busy mode.
        bBusy = DeleteBusyData (lpobj, pedit);

        asyncCmd = lpobj->asyncCmd;
        PostMessageToServer(pedit, WM_DDE_TERMINATE, 0);
        pedit->hServer = NULL;
        if (pedit->awaitAck || bBusy) {
            // Set error and goto next step.
            lpobj->subErr = OLE_ERROR_COMM;
            pedit->awaitAck = 0;
            ScheduleAsyncCmd (lpobj);
        }

        // If the command is delete, do not delete
        // the edit blocks. It will be deleted
        // in the OleLnkDelete routine and for delete it is
        // possible that by the time we come here, the object
        // may not exist at all.

        if (asyncCmd != OLE_DELETE){
            // QueryOpen() is done because excel is sending WM_DDE_TERMINATE
            // for system without sending for doc in case of failure.

            if (bDoc || QueryOpen (lpobj)) {
                // if the termination is for document and no async command
                // terminate the server conversation also.
                if ((asyncCmd == OLE_NONE) || (asyncCmd == OLE_REQUESTDATA)
                       || (asyncCmd == OLE_OTHER) || (asyncCmd == OLE_SETDATA)
                       || (asyncCmd == OLE_RUN) || (asyncCmd == OLE_SHOW)
                       || (asyncCmd == OLE_SETUPDATEOPTIONS)) {
                    if (lpobj->pDocEdit && lpobj->pDocEdit->awaitAck)
                        // we are waiting for an ack on Doc channel. So start
                        // the unlaunch process after we get the ack.
                        lpobj->bUnlaunchLater = TRUE;
                    else
                        CallEmbLnkDelete (lpobj);
                } else {
                    if (bDoc)
                        DeleteDocEdit (lpobj);

                }
            }else
                DeleteSrvrEdit (lpobj);

        }
    } else {
        pedit->hServer = NULL;
        if (pedit->extraTerm == 0)
            ScheduleAsyncCmd (lpobj);
    }
}

#ifdef FIREWALLS
BOOL INTERNAL CheckAtomValid (ATOM aItem)
{
    char    buffer[MAX_ATOM];
    int     len, val;


    Puts("CheckAtomValid");

    if (aItem == NULL)
             return TRUE;

    val = GlobalGetAtomName (aItem, buffer, MAX_ATOM);
    len = lstrlen (buffer);
    return ((val != 0) && (val == len));
}
#endif




//  HandleAckInitMsg: Handles WM_DDE_ACKs received while in initiate state.  If
//  this is the first reply, save its window handle.  If multiple replies
//  are received, take the one with the prefered instance, if there is
//  one.  Keep a count of WM_DDE_TERMINATEs we send so that we don't shut
//  the window until we get all of the responses for  WM_DDE_TERMINATEs.

void INTERNAL HandleAckInitMsg (
    PEDIT_DDE      pedit,
    HWND           hserver
){

    Puts("HandleAckInitMsg");

    if (pedit->hServer){
        // just take the very first one. Direct post is OK
        PostMessage (hserver, WM_DDE_TERMINATE, (WPARAM)pedit->hClient, 0);
        ++pedit->extraTerm;
    } else
        pedit->hServer = hserver;

}


// HandleAck: returns 0 if <ack> is not positive, else non-0.  Should probably be
//  a macro.

BOOL INTERNAL HandleAck (
    LPOBJECT_LE     lpobj,
    PEDIT_DDE       pedit,
    WPARAM          wParam,
    LPARAM          lParam
){
    WORD    wStatus = GET_WM_DDE_ACK_STATUS(wParam,lParam);
    HANDLE  hData  = NULL;
    BOOL    retval = TRUE;

    UNREFERENCED_PARAMETER(wParam);

    // check for busy bit
    if ((wStatus & 0x4000) && ContextCallBack ((LPOLEOBJECT)lpobj, OLE_QUERY_RETRY)){
        // we got busy from the server. create a timer and wait for time out.

        // We do not need makeprocinstance since, DLLs are single insance, all
        // we need to do is export for this function.

        if ((pedit->wTimer = SetTimer (pedit->hClient, 1, 3000, NULL)))
            return TRUE;
    }

    // even if the client got terminate we have to go thru this path.

    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }

    if (pedit->awaitAck == AA_POKE)
        // We have to free the data first. Handleack can trigger
        // another Poke (like pokehostnames)
        FreePokeData (lpobj, pedit);

    if (pedit->awaitAck == AA_EXECUTE) {
        hData = GET_WM_DDE_EXECACK_HDATA(wParam,lParam);
        if (hData) GlobalFree (hData);
    } else {
        ATOM aItem = GET_WM_DDE_ACK_ITEM(wParam,lParam);

        ASSERT (CheckAtomValid(aItem),"Invalid atom in ACK")

        if (aItem)
            GlobalDeleteAtom (aItem);
    }

    if (!(wStatus & 0x8000)) {
        // error case. set the error
        DEBUG_OUT ("DDE ACK with failure", 0)

        if (lpobj->errHint){
            lpobj->subErr = lpobj->errHint;
            lpobj->errHint = OLE_OK;
        } else
            lpobj->subErr = OLE_ERROR_COMM;

        retval = FALSE;

        if (pedit->awaitAck == AA_ADVISE) {

#ifdef  ASSERT
        ASSERT (pedit->hopt, "failed advise, options block missing");
#endif
           GlobalFree (pedit->hopt);
        }
    }

    pedit->hopt = NULL;
    pedit->awaitAck = 0;
    ScheduleAsyncCmd (lpobj);
    return retval;
}

// HandleDataMsg: Called for WM_DDE_DATA message.  If data is from an
//  ADVISE-ON-CLOSE and this is there are no more outstanding
//  ADVISE-ON-CLOSE requests, close the document and end the
//  conversation.

void INTERNAL HandleDataMsg (
    LPOBJECT_LE     lpobj,
    HANDLE          hdata,
    ATOM            aItem
){
    DDEDATA         far *lpdata = NULL;
    BOOL            fAck;
    BOOL            fRelease;
    int             options;
    PEDIT_DDE       pedit;

    Puts("HandleDataMsg");

    if (ScanItemOptions (aItem, (int far *)&options) != OLE_OK) {
        DEBUG_OUT (FALSE, "Improper item options");
        return;
    }

    pedit = lpobj->pDocEdit;

    if (hdata) {
        if (!(lpdata = (DDEDATA FAR *) GlobalLock(hdata)))
            return;

        fAck = lpdata->fAckReq;
        fRelease = lpdata->fRelease;

        if (pedit->bTerminating) {
            DEBUG_OUT ("Got DDE_DATA in terminate sequence",0)
            fRelease = TRUE;
        }
        else {
            if ((OLECLIPFORMAT)lpdata->cfFormat == cfBinary && aItem == aStdDocName) {
                ChangeDocName (lpobj, (LPSTR)lpdata->Value);
            }
            else
                SetData (lpobj, hdata, options);

            #ifdef  FIREWALLS
                ASSERT (IsWindowValid(pedit->hServer),
                    "Server window missing in HandleDataMsg")
                ASSERT (CheckAtomValid(aItem),"HandleDataMsg invalid atom")
            #endif

            // important that we post the acknowledge first. Otherwist the
            // messages are not in sync.

            if (fAck)
            {
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,POSITIVE_ACK,aItem);
                PostMessageToServer (pedit, WM_DDE_ACK, lparamNew);
            }
            else if (aItem)
                GlobalDeleteAtom (aItem);

            if ((lpdata->fResponse) && (pedit->awaitAck == AA_REQUEST)) {
                // we sent the request. So, schedule next step.
                pedit->awaitAck = 0;
                ScheduleAsyncCmd (lpobj);
            }
        }

        GlobalUnlock (hdata);
        if (fRelease)
            GlobalFree (hdata);
    }
    else {
        if (CanCallback (lpobj, options)) {
            if (options != OLE_CLOSED)
                ContextCallBack ((LPOLEOBJECT)lpobj, options);
            else
                lpobj->bSvrClosing = FALSE;

        }
    }

    if (options == OLE_CLOSED && (lpobj->pDocEdit->nAdviseClose <= 2)
            && (lpobj->asyncCmd == OLE_NONE)) {
        InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH, EMBLNKDELETE);
        EmbLnkDelete (lpobj);
    }
}


HANDLE  GetDDEDataHandle (
   DDEDATA far     *lpdata,
   UINT            cfFormat,
   HANDLE          hdata
){

    if (cfFormat == CF_METAFILEPICT) {
#ifdef _WIN64
        return (*(void* _unaligned*)lpdata->Value);
#else
        return LongToHandle(*(LONG*)lpdata->Value);
#endif
    }

    if (cfFormat == CF_BITMAP || cfFormat == CF_ENHMETAFILE)
         return LongToHandle(*(LONG*)lpdata->Value);

    if (cfFormat == CF_DIB)
        return GlobalReAlloc (LongToHandle(*(LONG*)lpdata->Value), 0L,
                    GMEM_MODIFY|GMEM_SHARE);

    return CopyData (((LPSTR)lpdata)+4, (DWORD)(GlobalSize (hdata) - 4));
}

// SetData: Given the DDEDATA structure from a WM_DDE_DATA message, set up the
//  appropriate data in lpobj.  If the native is in native format, add
//  that field, otherwise, if it is in picture format, ask the picture
//  to add it itself.

void INTERNAL SetData (
    LPOBJECT_LE     lpobj,
    HANDLE          hdata,
    int             options
){
    DDEDATA far     *lpdata   = NULL;
    OLESTATUS       retVal = OLE_ERROR_MEMORY;
    HANDLE          hdataDDE;

    Puts("SetData");

    if (!(lpdata = (DDEDATA far *) (GlobalLock (hdata))))
        goto errrtn;


    if (!(hdataDDE =  GetDDEDataHandle (lpdata, lpdata->cfFormat, hdata)))
        goto errrtn;

    if ((OLECLIPFORMAT)lpdata->cfFormat == cfNative) {
        retVal = (*lpobj->head.lpvtbl->ChangeData) ( (LPOLEOBJECT)lpobj,
                        hdataDDE,
                        lpobj->head.lpclient,
                        TRUE);  // use this data, don't copy

    }
    else if ((BOOL)lpdata->cfFormat && (lpdata->cfFormat == (int)GetPictType (lpobj))) {

            retVal = (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                        hdataDDE,
                        lpobj->head.lpclient,
                        lpdata->fRelease);

    } else {
        // case of extra data in the object.
        DeleteExtraData (lpobj);
        lpobj->cfExtra = lpdata->cfFormat;
        lpobj->hextraData = hdataDDE;
        goto end;
    }

    if (retVal == OLE_OK) {
        SetExtents (lpobj);
        if (CanCallback (lpobj, options)) {
            if (options == OLE_CLOSED) {
                ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CHANGED);
                ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CLOSED);
                lpobj->bSvrClosing = FALSE;
            }
            else
                ContextCallBack ((LPOLEOBJECT)lpobj, options);
        }
    }

end:
errrtn:
    if (lpdata)
        GlobalUnlock (hdata);

    return;
}


// SysStartConvDDE: Starts a system conversation.  Returns a handle to that
//  conversation, or NULL.

BOOL INTERNAL InitSrvrConv (
    LPOBJECT_LE     lpobj,
    HANDLE          hInst
){
    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;

    Puts("InitSrvrConv");

    if (!lpobj->hSysEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL))
            goto errRtn;

    } else {
#ifdef  FIREWALLS
    ASSERT (!lpobj->pSysEdit->hClient, "Sys conv lptr is present");
#endif
        hedit  =  lpobj->hSysEdit;
        pedit =   lpobj->pSysEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if((pedit->hClient = CreateWindow ("OleSrvrWndClass", "",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL)
        goto errRtn;


    lpobj->hSysEdit     = hedit;
    lpobj->pSysEdit     = pedit;
    pedit->hInst        = hInst;
    pedit->awaitAck     = AA_INITIATE;

    SetWindowLongPtr (pedit->hClient, 0, (LONG_PTR)lpobj);
    SendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM)pedit->hClient,
             MAKELPARAM (lpobj->app, aOle));

    ASSERT (CheckAtomValid(aOle),"systopic invalid atom")

    pedit->awaitAck    = 0;
    if (pedit->hServer == NULL) {
        pedit->awaitAck    = AA_INITIATE;
        // Now try the System topic
        SendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM)pedit->hClient,
                 MAKELPARAM (lpobj->app, aSystem));

        ASSERT (CheckAtomValid(aSystem),"systopic invalid atom")

        pedit->awaitAck    = 0;
        if (pedit->hServer == NULL) {
            DEBUG_OUT ("Srver connection failed", 0);
            goto errRtn;
        }
    }

    // Put the long ptr handle in the object.
    return TRUE;

errRtn:

    if (pedit) {
        if (pedit->hClient)
            DestroyWindow (pedit->hClient);
        LocalUnlock (hedit);
    }

    if (hedit)
        LocalFree (hedit);

    lpobj->hSysEdit     = NULL;
    lpobj->pSysEdit    = NULL;

    return FALSE;
}


// TermSrvrConv: Ends conversation indicated by hedit.
void INTERNAL TermSrvrConv (LPOBJECT_LE lpobj)
{
    PEDIT_DDE pedit;

    Puts("TermSrvrConv");


    if (!(pedit = lpobj->pSysEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)){
        lpobj->bAsync        = TRUE;
        pedit->bTerminating = TRUE;
    } else {
        pedit->bTerminating = FALSE;
        lpobj->subErr = OLE_ERROR_TERMINATE;
    }
    return;
}


void INTERNAL  DeleteAbortData (
   LPOBJECT_LE    lpobj,
   PEDIT_DDE     pedit
){
    UNREFERENCED_PARAMETER(lpobj);

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }
    return;


}

BOOL INTERNAL   DeleteBusyData (
    LPOBJECT_LE    lpobj,
    PEDIT_DDE     pedit
){
    UNREFERENCED_PARAMETER(lpobj);

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;

        if (pedit->hData) {
            GlobalFree (pedit->hData);
            pedit->hData = NULL;
        }

        if (pedit->hopt) {
            GlobalFree (pedit->hopt);
            pedit->hopt = NULL;
        }

        if (pedit->awaitAck && (HIWORD(pedit->lParam))) {
            if (pedit->awaitAck == AA_EXECUTE) {
		HANDLE hData = GET_WM_DDE_EXECACK_HDATA(pedit->wParam, pedit->lParam);
	        if (hData) GlobalFree (hData);
	    } else {
                ASSERT (CheckAtomValid(HIWORD(pedit->lParam)),
                    "Invalid atom in ACK")
                if (HIWORD(pedit->lParam))
                    GlobalDeleteAtom (HIWORD(pedit->lParam));
            }

            // we want to wipe out the HIWORD of lParam
            pedit->lParam &= 0x0000FFFF;
        }

        return TRUE;
    }

    return FALSE;
}

void INTERNAL   DeleteSrvrEdit (
   LPOBJECT_LE    lpobj
){

    PEDIT_DDE pedit;

    Puts("deleteSrvrEdit");

    if (!(pedit = lpobj->pSysEdit))
        return;


    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pSysEdit)
        LocalUnlock (lpobj->hSysEdit);

    if (lpobj->hSysEdit)
        LocalFree (lpobj->hSysEdit);

    lpobj->hSysEdit  = NULL;
    lpobj->pSysEdit = NULL;

    return;
}


void INTERNAL   SendStdExit (
   LPOBJECT_LE    lpobj
){


    Puts("SendSrvrExit");

    if (!lpobj->pSysEdit)
        return;

    SrvrExecute (lpobj, MapStrToH ("[StdExit]"));

}

void INTERNAL   SendStdClose (
    LPOBJECT_LE    lpobj
){


    Puts("SendDocClose");

    if (!lpobj->pDocEdit)
        return;

    DocExecute (lpobj, MapStrToH ("[StdCloseDocument]"));

}


// SrvrExecute: Sends execute command to system conversation.
BOOL INTERNAL SrvrExecute (
    LPOBJECT_LE lpobj,
    HANDLE      hdata
){
    PEDIT_DDE   pedit = NULL;
    int         retval = FALSE;

    Puts("SrvrExecute");

#ifdef  FIREWALLS

    ASSERT (lpobj->hSysEdit, "Sys conv handle missing");
    ASSERT (lpobj->pSysEdit, "sys conv lptr is missing");

#endif
    pedit = lpobj->pSysEdit;

    if (hdata == NULL || pedit == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        return FALSE;
    }

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "In terminate state")
    ASSERT (pedit->awaitAck == 0, "trying to Post msg while waiting for ack")
#endif

    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }


    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, (LPARAM)hdata)) {
        // data is being freed in the acknowledge
        lpobj->bAsync    = TRUE;
        pedit->awaitAck = AA_EXECUTE;
        return TRUE;
    } else {
        lpobj->subErr = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}

// StartConvDDE: Starts the document conversation for an object based on
// .app and .topic atoms.
BOOL FARINTERNAL InitDocConv (
    LPOBJECT_LE lpobj,
    BOOL        fNetDlg
){

    // ### This routine looks very similar to IitSrvrConv
    // combine with the it

    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;
    char        buf[MAX_NET_NAME];
    int         nDrive = 2;     // drive C
    char        cOldDrive;

    Puts("InitDocConv");

    if (QueryOpen (lpobj)){
        DEBUG_OUT ("Attempt to start already existing conversation",0);
        return FALSE;
    }

    cOldDrive = lpobj->cDrive;
    if (CheckNetDrive (lpobj, fNetDlg) != OLE_OK)
        return FALSE;

    if (!lpobj->pDocEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL)){
            lpobj->subErr = OLE_ERROR_MEMORY;
            goto errRtn;
        }
    } else {
#ifdef  FIREWALLS
    ASSERT (!lpobj->pDocEdit->hClient, "Doc conv lptr is present");
#endif
        hedit  =  lpobj->hDocEdit;
        pedit =  lpobj->pDocEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if ((pedit->hClient = CreateWindow ("OleDocWndClass", "Window Name",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        goto errRtn;
    }
    lpobj->hDocEdit     = hedit;
    lpobj->pDocEdit     = pedit;
    SetWindowLongPtr (pedit->hClient, 0, (LONG_PTR)lpobj);

    // buf will filled by netname in the first call to SetNextNetDrive()
    buf[0] = '\0';
    do {
        pedit->awaitAck = AA_INITIATE;

        // !!! Where are the atom counts bumped?

        SendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM)pedit->hClient,
                MAKELPARAM (lpobj->app, lpobj->topic));

        pedit->awaitAck = 0;

        if (pedit->hServer) {
            if ((cOldDrive != lpobj->cDrive)
                    && (lpobj->asyncCmd != OLE_CREATEFROMFILE))
                ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RENAMED);
            return TRUE;
        }

    } while ((lpobj->head.ctype == CT_LINK) && (lpobj->aNetName)
                && SetNextNetDrive (lpobj, &nDrive, buf)) ;

errRtn:
    if (cOldDrive != lpobj->cDrive) {
        // put back the old drive
        lpobj->cDrive = cOldDrive;
        ChangeTopic (lpobj);
    }

    if (pedit && pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (pedit)
        LocalUnlock (hedit);

    if (hedit)
        LocalFree (hedit);

    lpobj->hDocEdit     = NULL;
    lpobj->pDocEdit     = NULL;
    return FALSE;
}


// Execute: Sends an execute string WM_DDE_EXECUTE to the document conversation.
BOOL INTERNAL DocExecute(
    LPOBJECT_LE lpobj,
    HANDLE      hdata
){
    PEDIT_DDE   pedit;

    Puts("DocExecute");
    pedit = lpobj->pDocEdit;

    if (hdata == NULL || pedit == NULL)
        return FALSE;


#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "Execute: terminating")
    ASSERT (pedit->hClient, "Client null")
    ASSERT (IsWindowValid(pedit->hClient),"Invalid client")
    ASSERT (pedit->awaitAck == 0, "trying to Post msg while waiting for ack")
#endif

    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }

    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, (LPARAM)hdata)) {
        // data is being freed in the execute command
        pedit->awaitAck    = AA_EXECUTE;
        lpobj->bAsync       = TRUE;
        return TRUE;
    } else {
        lpobj->subErr    = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}


// EndConvDDE: terminates the doc level conversation.
void INTERNAL TermDocConv (
    LPOBJECT_LE    lpobj
){
    PEDIT_DDE pedit;

    Puts ("TermDocConv");

    DEBUG_OUT ("About to terminate convs from destroy",0)

    if (!(pedit = lpobj->pDocEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)) {
        pedit->bTerminating = TRUE;
        lpobj->bAsync        = TRUE;
    } else
        lpobj->subErr = OLE_ERROR_TERMINATE;

    return;

}

// Deletes the document conversdation memory.
void INTERNAL DeleteDocEdit (lpobj)
LPOBJECT_LE    lpobj;
{

    PEDIT_DDE pedit;

    Puts ("DeleteDocEdit");

    if (!(pedit = lpobj->pDocEdit))
        return;

    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    // Delete if any data blocks.
    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pDocEdit)
        LocalUnlock (lpobj->hDocEdit);

    if (lpobj->hDocEdit)
        LocalFree (lpobj->hDocEdit);

    lpobj->hDocEdit  = NULL;
    lpobj->pDocEdit = NULL;

    return;
}


// LeLauchApp: Launches app based on the ClassName in lpobj.
// History:
// curts changed LoadModule calls to WinExec
//

HANDLE INTERNAL  LeLaunchApp (LPOBJECT_LE lpobj)
{
//    struct CMDSHOW
//    {
//        WORD first;
//        WORD second;
//    } cmdShow = {2, SW_SHOWNORMAL};
//
//    struct
//    {
//        WORD wEnvSeg;
//        LPSTR lpcmdline;
//        struct CMDSHOW FAR *lpCmdShow;
//        DWORD dwReserved;
//    } paramBlock;

    WORD    cmdShow = SW_SHOWNORMAL;
    char    cmdline[MAX_STR];
    char    exeName[MAX_STR];
    char    lpstr[2*MAX_STR];
    HANDLE  hInst;

    #define EMB_STR     " -Embedding "

    Puts("LeLaunchApp");

    GlobalGetAtomName (lpobj->aServer, exeName, MAX_STR);

    cmdline[0] = ' ';
    if (lpobj->bOldLink) {
        cmdShow = SW_SHOWMINIMIZED;
        GlobalGetAtomName (lpobj->topic, cmdline + 1, MAX_STR);
    } else {
        lstrcpy ((LPSTR)cmdline+1, (LPSTR) EMB_STR);

        // For all link servers we want to give the filename on the command
        // line. But Excel is not registering the document before returning
        // from WinMain, if it has auto load macros. So, we want send StdOpen
        // for the old servers, instead of giving the file name on the command
        // line.

        if (lpobj->bOleServer && (lpobj->fCmd & LN_MASK) == LN_LNKACT)
            GlobalGetAtomName (lpobj->topic, cmdline+sizeof(EMB_STR),
                    MAX_STR-sizeof(EMB_STR));
        if (lpobj->fCmd & ACT_MINIMIZE)
            cmdShow = SW_SHOWMINIMIZED;
        else if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB))
                    // we want to launch with show in create invisible case
                    // even though ACT_SHOW flag will be false
                    && ((lpobj->fCmd & LN_MASK) != LN_NEW))
            cmdShow = SW_HIDE;
    }

//    paramBlock.wEnvSeg      = NULL;
//    paramBlock.lpcmdline    = (LPSTR)cmdline;
//    paramBlock.lpCmdShow    = &cmdShow;
//    paramBlock.dwReserved   = NULL;

    lstrcpy(lpstr,exeName);
    lstrcat(lpstr,cmdline);

    if ((hInst =  (HANDLE)ULongToPtr(WinExec(lpstr, cmdShow))) < (HANDLE)32)
        hInst = NULL;

    if (!hInst) {
        LPSTR   lptmp;
        char    ch;

        // strip off the path and try again
        lptmp = (LPSTR)exeName;
        lptmp += lstrlen ((LPSTR) exeName);
        ch = *lptmp;
        while (ch != '\\' && ch != ':') {
            if (lptmp == (LPSTR) exeName) {
                // exe did not have path in it's name. we already tried
                // loading and it failed, no point trying again.
                return NULL;
            }
            else
                ch = *--lptmp;
        }

        lstrcpy(lpstr,++lptmp);
        lstrcat(lpstr,cmdline);

        if ((hInst =  (HANDLE)ULongToPtr(WinExec(lpstr,cmdShow))) < (HANDLE)32)
            hInst = NULL;
    }

    return hInst;
}



//ScanItemOptions: Scan for the item options like Close/Save etc.

int INTERNAL ScanItemOptions (
   ATOM    aItem,
   int far *lpoptions
){

    ATOM    aModifier;

    LPSTR   lpbuf;
    char    buf[MAX_STR];

    *lpoptions = OLE_CHANGED;

    if (!aItem) {
        // NULL item with no modifier means OLE_CHANGED for NULL item
        return OLE_OK;
    }

    GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR);
    lpbuf = (LPSTR)buf;

    while ( *lpbuf && *lpbuf != '/')
           lpbuf++;

    // no modifier same as /change

    if (*lpbuf == '\0')
        return OLE_OK;

    *lpbuf++ = '\0';        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknown modifier
    return OLE_ERROR_SYNTAX;

}

void   INTERNAL   ChangeDocName (
    LPOBJECT_LE lpobj,
    LPSTR       lpdata

){
    ATOM      aOldTopic;
    OLESTATUS retVal;

    aOldTopic = lpobj->topic;
    lpobj->topic = GlobalAddAtom (lpdata);
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        return;
        // !!! what should we do in case of error? Currently, we will not
        // change the topic if SetNetName fails.
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);

    // Delete the link data block
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RENAMED);



}


BOOL INTERNAL CanCallback (
    LPOBJECT_LE lpobj,
    int         options
){
    LPINT    lpCount;

    if (options == OLE_CLOSED) {
        lpobj->bSvrClosing = TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseClose);
    }
    else if (options == OLE_SAVED) {
        if (lpobj->head.ctype == CT_LINK)
            return TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseSave);
    }
    else {
        // it must be due to request
        if ((lpobj->pDocEdit->awaitAck == AA_REQUEST)
                && lpobj->pDocEdit->bCallLater)
            return FALSE;

        return TRUE;
    }

    switch (*lpCount) {
        case 1:
            break;

        case 2:
            ++(*lpCount);
            return FALSE;

        case 3:
            --(*lpCount);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


void  FARINTERNAL CallEmbLnkDelete (
    LPOBJECT_LE lpobj
){
    InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH,EMBLNKDELETE);
    EmbLnkDelete (lpobj);

    if (lpobj->head.ctype == CT_EMBEDDED) {
        lpobj->bSvrClosing = TRUE;
        ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CLOSED);
        if (FarCheckObject ((LPOLEOBJECT)lpobj))
            lpobj->bSvrClosing = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\defcreat.c ===
/****************************** Module Header ******************************\
* Module Name: defcreat.c
*
* Purpose: Handles the various object creation routines, which are exported
*          to the DLL writers.
*
* Created: November 1990
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*   Srinik (11/12/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;


RENDER_ENTRY stdRender[NUM_RENDER] = {
    { "METAFILEPICT",   0, MfLoadFromStream}, 
    { "DIB",            0, DibLoadFromStream},
    { "BITMAP",         0, BmLoadFromStream},
    { "ENHMETAFILE",    0, EmfLoadFromStream} 
};


OLESTATUS  FARINTERNAL  DefLoadFromStream (
    LPOLESTREAM         lpstream,
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    int         i;

    UNREFERENCED_PARAMETER(lpprotocol);

    *lplpobj = NULL;        

    if ((objType == CT_PICTURE) || (objType == CT_STATIC)) {
        for (i = 0; i < NUM_RENDER; i++) {
            if (stdRender[i].aClass == aClass) {
                retVal = (*stdRender[i].Load) (lpstream, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, objType);
                if (aClass)
                    GlobalDeleteAtom (aClass);
                return retVal;
            }
        }
        
        return GenLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
    else {
        return LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
}


OLESTATUS FAR PASCAL DefCreateFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    LONG                objType
){
    UNREFERENCED_PARAMETER(lpprotocol);

    if (objType == CT_EMBEDDED)
        return EmbPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat);
    
    if (objType == CT_LINK)
        return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat, cfOwnerLink);

    return OLE_ERROR_CLIPBOARD;                          
}




OLESTATUS FAR PASCAL DefCreateLinkFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                optRender, cfFormat, cfObjectLink);
}


OLESTATUS FAR PASCAL DefCreateFromTemplate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LeCreateFromTemplate (lpclient,
                    lptemplate,
                    lhclientdoc,
                    lpobjname,
                    lplpoleobject,
                    optRender,
                    cfFormat);
}


OLESTATUS FAR PASCAL DefCreate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LeCreate (lpclient,
                lpclass,
                lhclientdoc,
                lpobjname,
                lplpoleobject,
                optRender,
                cfFormat);
}



OLESTATUS FAR PASCAL DefCreateFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        NULL,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_EMBEDDED);
}


OLESTATUS FAR PASCAL DefCreateLinkFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LPSTR               lpitem,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        lpitem,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_LINK);
}


OLESTATUS FAR PASCAL DefCreateInvisible (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                fActivate
){
    UNREFERENCED_PARAMETER(lpprotocol);

    return LeCreateInvisible (lpclient,
                        lpclass,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        fActivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\doc.c ===
/****************************** Module Header ******************************\
* Module Name: doc.c
*
* PURPOSE: Contains client document maipulation routines.
*
* Created: Jan 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  01/11/1191  Orginal
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

#ifdef FIREWALLS
extern BOOL     bShowed;
extern void FARINTERNAL ShowVersion (void);
#endif

LPCLIENTDOC lpHeadDoc = NULL;
LPCLIENTDOC lpTailDoc  = NULL;

extern ATOM aClipDoc;
extern int  iUnloadableDll;

#ifdef WIN16
#pragma alloc_text(_TEXT, CheckClientDoc, CheckPointer)
#endif

OLESTATUS FAR PASCAL OleRegisterClientDoc(
    LPCSTR               lpClassName,
    LPCSTR               lpDocName,
    LONG                future,
    LHCLIENTDOC FAR *   lplhclientdoc
){
    HANDLE      hdoc = NULL;
    LPCLIENTDOC lpdoc;
    OLESTATUS   retVal;
    ATOM        aClass, aDoc;

    UNREFERENCED_PARAMETER(future);

#ifdef FIREWALLS
    if (!bShowed && (ole_flags & DEBUG_MESSAGEBOX))
        ShowVersion ();
#endif

    Puts ("OleRegisterClientDoc");

    PROBE_MODE(bProtMode);
    FARPROBE_WRITE(lplhclientdoc);
    *lplhclientdoc = 0;
    FARPROBE_READ(lpClassName);
    FARPROBE_READ(lpDocName);
    if (!lpDocName[0])
        return OLE_ERROR_NAME;

    aDoc = GlobalAddAtom (lpDocName);
    aClass = GlobalAddAtom (lpClassName);

    if (!(hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE,
                        sizeof(CLIENTDOC)))
            || !(lpdoc = (LPCLIENTDOC) GlobalLock (hdoc))) {
        retVal =  OLE_ERROR_MEMORY;
        goto err;
    }

    lpdoc->docId[0] = 'C';
    lpdoc->docId[1] = 'D';
    lpdoc->aClass   = aClass;
    lpdoc->aDoc     = aDoc;
    lpdoc->hdoc     = hdoc;
    lpdoc->dwFileVer= (DWORD)MAKELONG(wReleaseVer,OS_WIN16);

    // Documents are doubly linked

    if (!lpHeadDoc) {
#ifdef FIREWALLS
        ASSERT(!lpTailDoc, "lpTailDoc is not NULL");
#endif
        lpHeadDoc = lpTailDoc = lpdoc;
    }
    else {
        lpTailDoc->lpNextDoc = lpdoc;
        lpdoc->lpPrevDoc = lpTailDoc;
        lpTailDoc = lpdoc;
    }

    *lplhclientdoc = (LHCLIENTDOC) lpdoc;

    // inform the link manager;
    return OLE_OK;

err:
    if (aClass)
        GlobalDeleteAtom (aClass);

    if (aDoc)
        GlobalDeleteAtom (aDoc);

    if (hdoc)
        GlobalFree (hdoc);

    return retVal;
}


OLESTATUS FAR PASCAL OleRevokeClientDoc (
   LHCLIENTDOC lhclientdoc
){
    LPCLIENTDOC lpdoc;

    Puts ("OleRevokeClientDoc");

    // if there is any handler dll that can be freed up, free it now.
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll)
        UnloadDll ();

    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (lpdoc->lpHeadObj) {
        ASSERT (0, "OleRevokeClientDoc() called without freeing all objects");
        return OLE_ERROR_NOT_EMPTY;
    }

    if (lpdoc->aClass)
        GlobalDeleteAtom (lpdoc->aClass);

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);

    // if only one doc is in the list then it's prev and next docs are NULL

    if (lpdoc == lpHeadDoc)
        lpHeadDoc = lpdoc->lpNextDoc;

    if (lpdoc == lpTailDoc)
        lpTailDoc = lpdoc->lpPrevDoc;

    if (lpdoc->lpPrevDoc)
        lpdoc->lpPrevDoc->lpNextDoc = lpdoc->lpNextDoc;

    if (lpdoc->lpNextDoc)
        lpdoc->lpNextDoc->lpPrevDoc = lpdoc->lpPrevDoc;

    GlobalUnlock (lpdoc->hdoc);
    GlobalFree (lpdoc->hdoc);

    // inform link manager
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRenameClientDoc (
    LHCLIENTDOC lhclientdoc,
    LPCSTR       lpNewDocName
){
    LPCLIENTDOC lpdoc;
    ATOM        aNewDoc;
    LPOLEOBJECT lpobj = NULL;

    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    FARPROBE_READ(lpNewDocName);

    aNewDoc = GlobalAddAtom (lpNewDocName);
    if (aNewDoc == lpdoc->aDoc) {
        if (aNewDoc)
            GlobalDeleteAtom (aNewDoc);
        return OLE_OK;
    }

    // Document name has changed. So, change the topic of all embedded objects
    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = aNewDoc;

    while (lpobj = DocGetNextObject (lpdoc, lpobj)) {
        if (lpobj->ctype == CT_EMBEDDED)
            if (OleQueryReleaseStatus (lpobj) != OLE_BUSY)
                SetEmbeddedTopic ((LPOBJECT_LE) lpobj);
    }

    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRevertClientDoc (
    LHCLIENTDOC lhclientdoc
){
    // if there is any handler dll that can be freed up, free it now.
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll)
        UnloadDll ();

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}


OLESTATUS FAR PASCAL OleSavedClientDoc (
    LHCLIENTDOC lhclientdoc
){
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}

OLESTATUS FAR PASCAL OleEnumObjects (
    LHCLIENTDOC         lhclientdoc,
    LPOLEOBJECT FAR *   lplpobj
){
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    FARPROBE_WRITE(lplpobj);

    if (*lplpobj) {
        // we are making lhclientdoc field of the object NULL at deletion
        // time. The check (*lpobj->lhclientdoc != lhclientdoc) will take care
        // of the case where same chunk of memory is allocated again for the
        // same pointer and old contents are not erased yet.
        if (!FarCheckObject (*lplpobj)
                || ((*lplpobj)->lhclientdoc != lhclientdoc))
            return OLE_ERROR_OBJECT;
    }

    *lplpobj = DocGetNextObject ((LPCLIENTDOC) lhclientdoc, *lplpobj);
    return OLE_OK;
}



LPOLEOBJECT INTERNAL DocGetNextObject (
    LPCLIENTDOC lpdoc,
    LPOLEOBJECT lpobj
){
    if (!lpobj)
        return lpdoc->lpHeadObj;

    return lpobj->lpNextObj;
}


BOOL FARINTERNAL CheckClientDoc (
    LPCLIENTDOC lpdoc
){
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
        return FALSE;

    if ((lpdoc->docId[0] == 'C') && (lpdoc->docId[1] == 'D'))
        return TRUE;
    return FALSE;
}


void FARINTERNAL DocAddObject (
    LPCLIENTDOC lpdoc,
    LPOLEOBJECT lpobj,
    LPCSTR      lpobjname
){
    if (lpobjname)
        lpobj->aObjName = GlobalAddAtom (lpobjname);
    else
        lpobj->aObjName = (ATOM)0;

    // Objects of a doc are doubly linked

    if (!lpdoc->lpHeadObj)
        lpdoc->lpHeadObj = lpdoc->lpTailObj = lpobj;
    else {
        lpdoc->lpTailObj->lpNextObj = lpobj;
        lpobj->lpPrevObj = lpdoc->lpTailObj;
        lpdoc->lpTailObj = lpobj;
    }
    lpobj->lhclientdoc = (LHCLIENTDOC)lpdoc;
}


void FARINTERNAL DocDeleteObject (
    LPOLEOBJECT lpobj
){
    LPCLIENTDOC lpdoc;

    if (!(lpdoc = (LPCLIENTDOC) lpobj->lhclientdoc))
        return;

    if (lpobj->aObjName) {
        GlobalDeleteAtom (lpobj->aObjName);
        lpobj->aObjName = (ATOM)0;
    }

    // Remove this obj from object chain of the relevant client doc.
    // The objects of a doc are doubly linked.

    if (lpdoc->lpHeadObj == lpobj)
        lpdoc->lpHeadObj = lpobj->lpNextObj;

    if (lpdoc->lpTailObj == lpobj)
        lpdoc->lpTailObj = lpobj->lpPrevObj;

    if (lpobj->lpPrevObj)
        lpobj->lpPrevObj->lpNextObj = lpobj->lpNextObj;

    if (lpobj->lpNextObj)
        lpobj->lpNextObj->lpPrevObj = lpobj->lpPrevObj;

    lpobj->lhclientdoc = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\dll.h ===
/****************************** Module Header ******************************\
* Module Name: dll.h
*
* PURPOSE: Private definitions file for ole.c
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*  curts created portable version for win16/32
*
\***************************************************************************/

#define  OLE_INTERNAL

#include    "port1632.h"
#include    "cmacs.h"
#include    "ole.h"

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// WIN16                                                                  //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#ifdef WIN16


#define PROBE_MODE(bProtMode) {\
        if (!bProtMode) \
            return OLE_ERROR_PROTECT_ONLY; \
}

extern  WORD FARINTERNAL FarCheckPointer (LPVOID, int);

extern  WORD            wWinVer;
extern  BOOL            bProtMode;
extern  BOOL            bWLO;

#define MAKE_DDE_LPARAM(x,y,z) MAKELONG(y,z)
#define UNREFERENCED_PARAMETER(p) (p)
#define WIN16METAFILEPICT     METAFILEPICT
#define LPWIN16METAFILEPICT   LPMETAFILEPICT
#define WIN16BITMAP           BITMAP
#define LPWIN16BITMAP         LPBITMAP

// Routines in OLE.ASM                                                     //

WORD    GetGDIds (DWORD);
WORD    IsMetaDC (HDC, WORD);
WORD    CheckPointer (LPVOID, int);

#endif

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// WIN32                                                                  //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#ifdef WIN32

typedef struct tagWIN16METAFILEPICT
{
    short   mm;
    short   xExt;
    short   yExt;
    WORD    hMF;
} WIN16METAFILEPICT ,FAR* LPWIN16METAFILEPICT;

#ifndef RC_INVOKED
#pragma pack(1)
typedef struct tagWIN16BITMAP
{
    short   bmType;
    short   bmWidth;
    short   bmHeight;
    short   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} WIN16BITMAP, FAR* LPWIN16BITMAP;
#pragma pack()      /* Resume normal packing */
#endif  /* !RC_INVOKED */

#define PROBE_MODE(bProtMode)

#define GET_WM_DDE_EXECUTE_LPARAM(hdataExec)    ((UINT)hdataExec)
#define MAKE_DDE_LPARAM(x,y,z) PackDDElParam((UINT)x,(UINT_PTR)y,(UINT_PTR)z)

#define FarCheckPointer CheckPointer
INT  CheckPointer (LPVOID, int);
#define FarInitAsyncCmd InitAsyncCmd

#endif

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines, Object methods table and Structures.                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


//#ifndef HUGE
//#define HUGE    huge
//#endif

/* file format types */

#define OS_WIN16    0x0000
#define OS_MAC      0x0001
#define OS_WIN32    0x0002


// Characteristics Type Field
#define CT_NULL     0L
#define CT_LINK     1L
#define CT_EMBEDDED 2L
#define CT_STATIC   3L
#define CT_OLDLINK  4L
#define CT_PICTURE  5L

#define OLE_NO          0   // for boolean query functions
#define OLE_YES         1   // for boolean query functions

#define MAX_STR         256
#define MAX_NET_NAME    MAX_STR
#define INVALID_INDEX   -1
#define MAX_ATOM        256

#define NUM_RENDER      4

#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_STATIC     ((LPSTR)"Static")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")

#define READ_ACCESS     0
#define WRITE_ACCESS    1

#define POPUP_NETDLG    1

#define PROBE_OLDLINK(lpobj){\
        if (lpobj->bOldLink)\
            return OLE_ERROR_OBJECT;\
}


#define PROBE_READ(lp){\
        if (!CheckPointer((LPVOID)(lp), READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer((LPVOID)(lp), WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}


#define FARPROBE_READ(lp){\
        if (!FarCheckPointer((LPVOID)(lp), READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define FARPROBE_WRITE(lp){\
        if (!FarCheckPointer((LPVOID)(lp), WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}


extern  OLECLIPFORMAT   cfBinary;
extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfLink;
extern  OLECLIPFORMAT   cfNative;

extern  ATOM            aStdHostNames;
extern  ATOM            aStdTargetDevice ;
extern  ATOM            aStdDocDimensions;
extern  ATOM            aStdDocName;
extern  ATOM            aStdColorScheme;
extern  ATOM            aNullArg;
extern  ATOM            aSave;
extern  ATOM            aChange;
extern  ATOM            aClose;
extern  ATOM            aPackage;

extern  HANDLE          hInstDLL;
extern  WORD            wReleaseVer;
extern  DWORD           dwVerFromFile;

// Used by QuerySize() API;
extern  DWORD           dwObjSize;

extern  OLESTREAM       dllStream;



typedef struct _OLEOBJECT { /*object */
    LPOLEOBJECTVTBL lpvtbl;
    char            objId[2];
    HOBJECT         hobj;
    LPOLECLIENT     lpclient;
    LONG            ctype;
    LONG            cx;
    LONG            cy;
    LONG            mm;
    int             iTable;        // Index into the dll table
    ATOM            aObjName;      //** Client
    LHCLIENTDOC     lhclientdoc;   //      Document
    LPOLEOBJECT     lpPrevObj;     //      related
    LPOLEOBJECT     lpNextObj;     //** fileds
    LPOLEOBJECT     lpParent;      // NULL for LE or Static objects.
} OBJECT;



typedef struct _CF_NAME_ATOM {
    char *  cfName;
    ATOM    cfAtom;
} CF_NAME_ATOM;

extern  CF_NAME_ATOM    cfNameAtom[];


/////////////////////////////////////////////////////////////////////////////
// METAFFILE object structures
/////////////////////////////////////////////////////////////////////////////

typedef struct _METADC {
    int     xMwo;
    int     yMwo;
    int     xMwe;
    int     yMwe;
    int     xre;
    int     yre;
    struct _METADC * pNext;
} METADC, *PMETADC;

typedef struct _METAINFO {
    METADC  headDc;
    int         xwo;
    int         ywo;
    int         xwe;
    int         ywe;
    int         xro;
    int         yro;
} METAINFO, *PMETAINFO;

typedef struct OBJECT_MF { /* object_mf */
    OBJECT          head;
    DWORD           sizeBytes;
    METAFILEPICT    mfp;
    HANDLE          hmfp;
    BOOL            fMetaDC;
    OLESTATUS       error;
    int             nRecord;
    PMETAINFO       pMetaInfo;
    PMETADC         pCurMdc;
} OBJECT_MF;

typedef OBJECT_MF  FAR * LPOBJECT_MF;


#ifdef WIN32
/////////////////////////////////////////////////////////////////////////////
// ENHMETAFILE structures
/////////////////////////////////////////////////////////////////////////////


typedef struct OBJECT_EMF {
    OBJECT          head;
    DWORD           sizeBytes;
    HENHMETAFILE    hemf;
    BOOL            fMetaDC;
    OLESTATUS       error;
    int             nRecord;
} OBJECT_EMF;

typedef OBJECT_EMF  FAR * LPOBJECT_EMF;

#endif

/////////////////////////////////////////////////////////////////////////////
// BITMAP object structure
/////////////////////////////////////////////////////////////////////////////

typedef struct
{
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;  // width in pixels
    int     ySize;  // height in pixels
    HBITMAP hBitmap;
} OBJECT_BM;

typedef OBJECT_BM FAR * LPOBJECT_BM;


// DIB object structures

typedef struct _OBJECT_DIB {
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;
    int     ySize;
    HANDLE  hDIB;
} OBJECT_DIB;

typedef OBJECT_DIB FAR * LPOBJECT_DIB;

//* GENERIC object structure

typedef struct
{
    OBJECT          head;
    OLECLIPFORMAT   cfFormat;
    ATOM            aClass;
    DWORD           sizeBytes;
    HANDLE          hData;
} OBJECT_GEN;

typedef OBJECT_GEN FAR * LPOBJECT_GEN;



typedef struct  _RENDER_ENTRY { /* dll_entry */
    LPSTR       lpClass;
    ATOM        aClass;
    OLESTATUS   (FARINTERNAL *Load) (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
} RENDER_ENTRY;


typedef struct _DLL_ENTRY {
    ATOM        aDll;     /* global atom for dll name with full path */
    HANDLE      hDll;     /* handle to the dll module */
    int         cObj;     /* count of objects, unload dll when this is 0 */
    OLESTATUS   (FAR PASCAL *Load) (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Clip) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

    OLESTATUS   (FAR PASCAL *Link) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromTemplate) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Create) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateLinkFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
    OLESTATUS   (FAR PASCAL *CreateInvisible) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

} DLL_ENTRY;


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in OLE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

BOOL      INTERNAL      CheckObject(LPOLEOBJECT);
BOOL      FARINTERNAL   FarCheckObject(LPOLEOBJECT);
OLESTATUS INTERNAL      LeQueryCreateFromClip (LPSTR, OLEOPT_RENDER, OLECLIPFORMAT, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DEFCREAT.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   DefLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   DefCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in PBHANDLR.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   PbLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   PbCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines common for le.c, ledde.c, dde.c, doc.c                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


// Constants for chekcing whether the instance is SrvrDLL instance.

#define   WW_LPTR           0       // ptr tosrvr/doc/item
#define   WW_LE             4       // signature
#define   WW_HANDLE         6       // instance handle

#define   WC_LE             0x4c45  // LE chars


// command flags
#define     ACT_SHOW        0x0001      // show the window
#define     ACT_ACTIVATE    0x0002      // activate
#define     ACT_DOVERB      0x0004      // Run the item
#define     ACT_ADVISE      0x0008      // advise for data
#define     ACT_REQUEST     0x0010      // request for data
#define     ACT_CLOSE       0x0020      // request for advise only on close
#define     ACT_UNLAUNCH    0x0040      // unload the server after all the
#define     ACT_TERMSRVR    0x0080      // terminate server
#define     ACT_TERMDOC     0x0100      // terminate document

#define     ACT_NATIVE      0x0200      // only for LNKed objects, if we
                                        // need native data.

#define     ACT_MINIMIZE    0x0400      // launch the app minimized

#define     ACT_NOLAUNCH    0x0800      // don't launch the server


#define     LN_TEMPLATE     0x0000       // create from template
#define     LN_NEW          0x1000       // create new
#define     LN_EMBACT       0x2000       // activate emb
#define     LN_LNKACT       0x3000       // activate link
#define     LN_MASK         0xf000       // launch mask
#define     LN_SHIFT        12            // shift count for LN_MASK

typedef struct _EDIT_DDE { /* edit_dde */
    HANDLE      hInst;
    int         extraTerm;
    HWND        hClient;
    HWND        hServer;
    BOOL        bTerminating;
    BOOL        bAbort;
    BOOL        bCallLater;     // used in request cases. if this is FALSE
                                // then OLE_CHANGED is sent to client
    int         awaitAck;
    HANDLE      hopt;           // Memory block I may have to free
    int         nAdviseClose;   // count of outstanding advises on closes
    int         nAdviseSave;    // count of outstanding advises on save
    HANDLE      hData;          // Poked data/ temp for holding the
                                // handle in DDE messages

                                // busy parameters
    LPARAM      lParam;         // lparam value in case we need to
                                // repost the message
    UINT        msg;            // busy repost message

    UINT_PTR    wTimer;         // timer id.
} EDIT_DDE;

typedef EDIT_DDE NEAR   *PEDIT_DDE;
typedef EDIT_DDE FAR    *LPEDIT_DDE;

typedef struct _OBJECT_LE { /* object_le */
    OBJECT          head;
    ATOM            app;
    ATOM            topic;
    ATOM            item;
    ATOM            aServer;
    BOOL            bOldLink;           // whether a linked object for old link
    BOOL            bOleServer;         // server which supports the verbs
    UINT            verb;               // verb nuymber;
    UINT            fCmd;               // Command flags;
    OLEOPT_UPDATE   optUpdate;
    OLEOPT_UPDATE   optNew;             // new update options
    LPSTR           lptemplate;         // ptr to the template string, if
                                        // create from template

    ATOM            aNetName;           // network name on which the doc is
    char            cDrive;             // local drive for that network
    DWORD           dwNetInfo;          // LOW WORD = Net type
                                        // HIGH WORD = Driver version

    LPOLEOBJECT     lpobjPict;

    LONG            lAppData;           // apps data
    LONG            lHandlerData;       // handler data

    HANDLE          hnative;
    HANDLE          hLink;
    HANDLE          hhostNames;         // host name block
    HANDLE          htargetDevice;      // target device info
    HANDLE          hdocDimensions;     // document dimensions
    HANDLE          hextraData;         // reqestdata handle
    UINT            cfExtra;            // extra format data
    HANDLE          hlogpal;          // logiccal palette


    UINT            oldasyncCmd;        // previous asynchronous command
    UINT            asyncCmd;           // asynchronous command
    BOOL            endAsync;           // true if we need to send END_RELEASE.
    BOOL            bAsync;             // true if async command on.
    UINT            mainRtn;            // main async routine
    UINT            subRtn;             // step within the main async routine
    UINT            mainErr;            // failure error
    UINT            subErr;             // step error
    UINT            errHint;            // ;error hint

    BOOL            bSvrClosing;        // TRUE - server in the process of
                                        // closing down
    BOOL            bUnlaunchLater;     // Call EmbLnkDelete from EndAsyncCmd
                                        // if this flag is TRUE

    HANDLE          hSysEdit;           // handle to system edit.
    PEDIT_DDE       pSysEdit;           // near ptr to system edit.
    HANDLE          hDocEdit;           // handle to doc level channel
    PEDIT_DDE       pDocEdit;           // near ptr to the doc level channel
    BOOL            bNewPict;

} OBJECT_LE;
typedef OBJECT_LE  FAR * LPOBJECT_LE;


typedef struct _CLIENTDOC { /* object_le */
    char                    docId[2];
    LPOLEOBJECT             lpHeadObj;
    LPOLEOBJECT             lpTailObj;
    ATOM                    aClass;
    ATOM                    aDoc;
    HANDLE                  hdoc;
    DWORD                   dwFileVer;
    struct _CLIENTDOC FAR * lpPrevDoc;
    struct _CLIENTDOC FAR * lpNextDoc;
} CLIENTDOC;
typedef CLIENTDOC  FAR * LPCLIENTDOC;


typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;

//
// BOUNDSRECT must be defined as the same size in both
// 16 and 32 bit versions.
//
typedef struct _BOUNDSRECT {
    USHORT    defaultWidth;
    USHORT    defaultHeight;
    USHORT    maxWidth;
    USHORT    maxHeight;
} BOUNDSRECT;

typedef BOUNDSRECT FAR *LPBOUNDSRECT;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Function pointer types                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
typedef OLESTATUS       (FAR PASCAL *_LOAD)                  (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CLIP)                  (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);
typedef OLESTATUS       (FAR PASCAL *_LINK)                  (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATEFROMTEMPLATE)    (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATE)                (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATEFROMFILE)        (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATELINKFROMFILE)    (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
typedef OLESTATUS       (FAR PASCAL *_CREATEINVISIBLE)       (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


// AwaitAck values
#define AA_REQUEST  1
#define AA_ADVISE   2
#define AA_POKE     3
#define AA_EXECUTE  4
#define AA_UNADVISE 5
#define AA_INITIATE 6

// Bits for Positive WM_DDE_ACK
#define POSITIVE_ACK 0x8000



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LE.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPVOID      FARINTERNAL LeQueryProtocol (LPOLEOBJECT, OLE_LPCSTR);
OLESTATUS   FARINTERNAL LeRelease (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS   FARINTERNAL LeCopyFromLink (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS   FARINTERNAL LeEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeCopy (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS   FARINTERNAL LeDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLECLIPFORMAT   FARINTERNAL LeEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeGetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);
OLESTATUS   FARINTERNAL LeRequestData (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeQueryOutOfDate (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeObjectConvert (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS   FARINTERNAL LeChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
LPOBJECT_LE FARINTERNAL LeCreateBlank(LHCLIENTDOC, LPSTR, LONG);
void        FARINTERNAL SetExtents (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   FARINTERNAL LeLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS   INTERNAL    LeStreamRead (LPOLESTREAM, LPOBJECT_LE);
OLESTATUS   INTERNAL    LeStreamWrite (LPOLESTREAM, LPOBJECT_LE);
int         FARINTERNAL ContextCallBack (LPOLEOBJECT, OLE_NOTIFICATION);
void        INTERNAL    DeleteObjectAtoms (LPOBJECT_LE);
void        FARINTERNAL DeleteExtraData (LPOBJECT_LE);

OLESTATUS   FARINTERNAL LeGetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS   FARINTERNAL LnkPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL EmbPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
BOOL        INTERNAL    SetLink (LPOBJECT_LE, HANDLE, LPSTR FAR *);
HANDLE      INTERNAL    GetLink (LPOBJECT_LE);
void        FARINTERNAL SetEmbeddedTopic (LPOBJECT_LE);

OLESTATUS   FAR PASCAL  LeQueryReleaseStatus (LPOLEOBJECT);
OLESTATUS   FAR PASCAL  LeQueryReleaseError (LPOLEOBJECT);
OLE_RELEASE_METHOD FAR PASCAL LeQueryReleaseMethod (LPOLEOBJECT);

OLESTATUS   FARINTERNAL LeQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS   FARINTERNAL LeObjectLong (LPOLEOBJECT, UINT, LPLONG);


void SetNetDrive (LPOBJECT_LE);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LEDDE.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeDoVerb  (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS   FARINTERNAL LeShow (LPOLEOBJECT, BOOL);
OLESTATUS   FARINTERNAL LeQueryOpen (LPOLEOBJECT);
BOOL        INTERNAL    QueryOpen (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeActivate (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
OLESTATUS   FARINTERNAL LeUpdate (LPOLEOBJECT);
OLESTATUS   FARINTERNAL EmbOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL EmbUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL EmbOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL LnkUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeClose (LPOLEOBJECT);
OLESTATUS   FARINTERNAL LeReconnect (LPOLEOBJECT);
OLESTATUS   INTERNAL    PokeNativeData (LPOBJECT_LE);
BOOL        INTERNAL    PostMessageToServer (PEDIT_DDE, UINT, LPARAM);

OLESTATUS   FARINTERNAL LeCreateFromTemplate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreateInvisible (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

OLESTATUS   FARINTERNAL CreateFromClassOrTemplate (LPOLECLIENT, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, UINT, LPSTR, LHCLIENTDOC, LPSTR);

OLESTATUS   FARINTERNAL CreateEmbLnkFromFile (LPOLECLIENT, LPCSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS   FARINTERNAL LeSetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE);

void        INTERNAL    AdvisePict (LPOBJECT_LE, ATOM);
void        INTERNAL    UnAdvisePict (LPOBJECT_LE);
int         INTERNAL    GetPictType (LPOBJECT_LE);
void        INTERNAL    AdviseOn (LPOBJECT_LE, int, ATOM);
void        INTERNAL    UnAdviseOn (LPOBJECT_LE, int);
void        INTERNAL    RequestOn (LPOBJECT_LE, int);
void        INTERNAL    RequestPict (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetHostNames (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
OLESTATUS   INTERNAL    PokeHostNames (LPOBJECT_LE);
OLESTATUS   INTERNAL    SetHostNamesHandle (LPOBJECT_LE, LPSTR, LPSTR);
void        INTERNAL    FreePokeData (LPOBJECT_LE, PEDIT_DDE);
OLESTATUS   INTERNAL    SendPokeData (LPOBJECT_LE, ATOM, HANDLE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS   INTERNAL    PokeTargetDeviceInfo (LPOBJECT_LE);
OLESTATUS   INTERNAL    PokeDocDimensions (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);

OLESTATUS   FARINTERNAL LeSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
BOOL        INTERNAL SendSrvrMainCmd (LPOBJECT_LE, LPSTR);
ATOM        INTERNAL    ExtendAtom (LPOBJECT_LE, ATOM);
BOOL        INTERNAL    CreatePictObject (LHCLIENTDOC, LPSTR, LPOBJECT_LE, OLEOPT_RENDER, OLECLIPFORMAT, LPCSTR);
BOOL        INTERNAL    IsSrvrDLLwnd (HWND, HANDLE);
OLESTATUS   INTERNAL    ChangeDocAndItem (LPOBJECT_LE, HANDLE);
BOOL                    QueryUnlaunch (LPOBJECT_LE);
BOOL                    QueryClose (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS   INTERNAL    PokeColorScheme (LPOBJECT_LE);
OLESTATUS   FARINTERNAL ProbeAsync (LPOBJECT_LE);
BOOL        INTERNAL    IsServerValid (LPOBJECT_LE);
BOOL        INTERNAL    IsWindowValid (HWND);
OLESTATUS   FARINTERNAL LeExecute (LPOLEOBJECT, HANDLE, UINT);
void        INTERNAL    FreeGDIdata (HANDLE, OLECLIPFORMAT);
BOOL        INTERNAL    CanPutHandleInPokeBlock (LPOBJECT_LE, OLECLIPFORMAT);
BOOL        INTERNAL    ChangeEMFtoMF( LPOBJECT_LE );
BOOL        INTERNAL    ChangeEMFtoMFneeded(LPOBJECT_LE, ATOM );


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DDE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LRESULT     FARINTERNAL DocWndProc(HWND, UINT, WPARAM, LPARAM );
LRESULT     FARINTERNAL SrvrWndProc(HWND, UINT, WPARAM, LPARAM );
BOOL        INTERNAL    CheckAtomValid (ATOM);
void        INTERNAL    HandleAckInitMsg (PEDIT_DDE, HWND);
BOOL        INTERNAL    HandleAck (LPOBJECT_LE, PEDIT_DDE, WPARAM, LPARAM);
void        INTERNAL    HandleDataMsg (LPOBJECT_LE, HANDLE, ATOM);
void        INTERNAL    HandleTermMsg (LPOBJECT_LE, PEDIT_DDE, HWND, BOOL);
void        INTERNAL    HandleTimerMsg (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    SetData (LPOBJECT_LE, HANDLE, int);
BOOL        INTERNAL    DeleteBusyData (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    DeleteAbortData (LPOBJECT_LE, PEDIT_DDE);

BOOL        INTERNAL    WaitDDE (HWND, BOOL);
BOOL        INTERNAL    WaitDDEAck (PEDIT_DDE);

BOOL        INTERNAL    InitSrvrConv (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermSrvrConv (LPOBJECT_LE);
void        INTERNAL    DeleteSrvrEdit (LPOBJECT_LE);
BOOL        INTERNAL    SrvrExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    SendStdExit (LPOBJECT_LE);
void        INTERNAL    SendStdClose (LPOBJECT_LE);
void        INTERNAL    SendStdExit  (LPOBJECT_LE);

BOOL        FARINTERNAL InitDocConv (LPOBJECT_LE, BOOL);
BOOL        INTERNAL    DocExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermDocConv (LPOBJECT_LE);
void        INTERNAL    DeleteDocEdit (LPOBJECT_LE);

HANDLE      INTERNAL    LeLaunchApp (LPOBJECT_LE);
HANDLE      INTERNAL    LoadApp (LPSTR, UINT);

int         INTERNAL    ScanItemOptions (ATOM, int FAR *);
void        INTERNAL    ChangeDocName (LPOBJECT_LE, LPSTR);
BOOL        INTERNAL    CanCallback (LPOBJECT_LE, int);

void        FARINTERNAL CallEmbLnkDelete (LPOBJECT_LE);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Picture Object routines used by routines in other modules               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPOBJECT_BM  FARINTERNAL BmCreateBlank (LHCLIENTDOC, LPSTR, LONG);
OLESTATUS    FARINTERNAL BmLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL BmPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_DIB FARINTERNAL DibCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_DIB FARINTERNAL DibCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPCSTR, LONG);
OLESTATUS    FARINTERNAL DibLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL DibPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_MF  FARINTERNAL MfCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_MF  FARINTERNAL MfCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPCSTR, LONG);
OLESTATUS    FARINTERNAL MfLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL MfPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);

LPOBJECT_EMF  FARINTERNAL EmfCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_EMF  FARINTERNAL EmfCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPCSTR, LONG);
OLESTATUS    FARINTERNAL EmfLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL EmfPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);

LPOBJECT_GEN FARINTERNAL GenCreateBlank (LHCLIENTDOC, LPSTR, LONG, ATOM);
OLESTATUS    FARINTERNAL GenLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS    FARINTERNAL GenPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LPSTR, OLECLIPFORMAT, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MAIN.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

void    FARINTERNAL UnloadDll (void);
int     FARINTERNAL LoadDll (LPCSTR);
void    FARINTERNAL DecreaseHandlerObjCount (int);

void    FARINTERNAL RemoveLinkStringFromTopic (LPOBJECT_LE);

OLESTATUS FARINTERNAL CreatePictFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LPSTR, LONG);

OLESTATUS FARINTERNAL CreatePackageFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in UTILS.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        PutStrWithLen (LPOLESTREAM, LPSTR);
BOOL        GetStrWithLen (LPOLESTREAM, LPSTR);
ATOM        GetAtomFromStream (LPOLESTREAM);
BOOL        PutAtomIntoStream (LPOLESTREAM, ATOM);
BOOL        GetBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        PutBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        QueryApp (LPCSTR, LPCSTR, LPSTR);
HANDLE      MapStrToH (LPSTR);
void        UtilMemClr (PSTR, UINT);
BOOL        QueryHandler (UINT);

OLESTATUS INTERNAL      FileExists (LPOBJECT_LE);
ATOM      FARINTERNAL   GetAppAtom (LPCSTR);
HANDLE    FARINTERNAL   DuplicateGlobal (HANDLE, UINT);
HANDLE    FARINTERNAL   CopyData (LPSTR, DWORD);
ATOM      FARINTERNAL   DuplicateAtom (ATOM);
BOOL      FARINTERNAL   UtilQueryProtocol (LPOBJECT_LE, OLE_LPCSTR);
BOOL      FARINTERNAL   CmpGlobals (HANDLE, HANDLE);
void      FARINTERNAL   ConvertToHimetric(LPPOINT);
BOOL      FARINTERNAL   QueryVerb (LPOBJECT_LE, UINT, LPSTR, LONG);
BOOL      FARINTERNAL   MapExtToClass (LPSTR, LPSTR, int);
int       FARINTERNAL   GlobalGetAtomLen (ATOM);
void      FARINTERNAL   UtilMemCpy (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   UtilMemCmp (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   IsObjectBlank (LPOBJECT_LE);

OLESTATUS FARINTERNAL   ObjQueryName (LPOLEOBJECT, LPSTR, UINT FAR *);
OLESTATUS FARINTERNAL   ObjRename (LPOLEOBJECT, OLE_LPCSTR);
void      INTERNAL      SetExeAtom (LPOBJECT_LE);
BOOL      INTERNAL      OleIsDcMeta (HDC hdc);
void      INTERNAL      ConvertMF32to16(LPMETAFILEPICT, LPWIN16METAFILEPICT);
void      INTERNAL      ConvertMF16to32(LPWIN16METAFILEPICT, LPMETAFILEPICT);
void      INTERNAL      ConvertBM32to16(LPBITMAP, LPWIN16BITMAP);
void      INTERNAL      ConvertBM16to32(LPWIN16BITMAP, LPBITMAP);
DWORD     INTERNAL      GetFileVersion(LPOLEOBJECT);


// !!!make a routine and let the macro call the routine
// definitions related to the asynchronous operations.
#define WAIT_FOR_ASYNC_MSG(lpobj) {  \
    lpobj->subRtn++;                 \
    if (lpobj->bAsync){              \
        lpobj->endAsync = TRUE;      \
        return OLE_WAIT_FOR_RELEASE; \
    }                                \
}

#define STEP_NOP(lpobj)     lpobj->subRtn++;

// !!! Assumes all the creates are in order
#define PROBE_CREATE_ASYNC(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEINVISIBLE) {\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;\
    }

#define PROBE_OBJECT_BLANK(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEFROMFILE) { \
        if ((ProbeAsync(lpobj) == OLE_BUSY) && IsObjectBlank(lpobj)) \
            return OLE_ERROR_BLANK;\
    }

#define PROBE_ASYNC(lpobj)\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;

#define IS_SVRCLOSING(lpobj)\
        ((lpobj->bUnlaunchLater || lpobj->bSvrClosing) ? TRUE : FALSE)

#define PROBE_SVRCLOSING(lpobj)\
        if (IS_SVRCLOSING(lpobj)) \
            return OLE_ERROR_NOT_OPEN; \


#define CLEAR_STEP_ERROR(lpobj) lpobj->subErr = OLE_OK;


#define   SKIP_TO(a, b)    if (a) goto b;
#define   RESETERR(lpobj)  lpobj->mainErr = OLE_OK
#define   SETSTEP(lpobj, no)  lpobj->subRtn = no
#define   SETERRHINT(lpobj, no) lpobj->errHint = no
#define   CLEARASYNCCMD(lpobj)  lpobj->asyncCmd = OLE_NONE



// routines.
BOOL        ProcessErr          (LPOBJECT_LE);
void        InitAsyncCmd        (LPOBJECT_LE, UINT, UINT);
void        NextAsyncCmd        (LPOBJECT_LE, UINT);
void        ScheduleAsyncCmd    (LPOBJECT_LE);
OLESTATUS   EndAsyncCmd         (LPOBJECT_LE);
OLESTATUS   DocShow             (LPOBJECT_LE);
OLESTATUS   DocRun              (LPOBJECT_LE);
void        SendStdShow         (LPOBJECT_LE);
OLESTATUS   EmbLnkClose         (LPOBJECT_LE);
OLESTATUS   LnkSetUpdateOptions (LPOBJECT_LE);
OLESTATUS   EmbSrvrUnlaunch     (LPOBJECT_LE);
OLESTATUS   LnkChangeLnk        (LPOBJECT_LE);
OLESTATUS   RequestData         (LPOBJECT_LE, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL EmbLnkDelete(LPOBJECT_LE);

void FARINTERNAL FarInitAsyncCmd(LPOBJECT_LE, UINT, UINT);

// async command routines.
#define  EMBLNKDELETE           1
#define  LNKOPENUPDATE          2
#define  DOCSHOW                3
#define  EMBOPENUPDATE          4
#define  EMBLNKCLOSE            5
#define  LNKSETUPDATEOPTIONS    6
#define  LNKCHANGELNK           7
#define  REQUESTDATA            8
#define  DOCRUN                 9

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DOC.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        FARINTERNAL     CheckClientDoc (LPCLIENTDOC);
void        FARINTERNAL     DocAddObject (LPCLIENTDOC, LPOLEOBJECT, LPCSTR);
void        FARINTERNAL     DocDeleteObject (LPOLEOBJECT);
LPOLEOBJECT INTERNAL        DocGetNextObject (LPCLIENTDOC, LPOLEOBJECT);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in NET.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define     IDD_DRIVE       500
#define     IDD_PASSWORD    501
#define     IDD_PATH        502

#define     IDS_NETERR          600
#define     IDS_NETCONERRMSG    601
#define     IDS_FILENOTFOUNDMSG 602
#define     IDS_BADPATHMSG      603

OLESTATUS   FARINTERNAL SetNetName (LPOBJECT_LE);
BOOL        FARINTERNAL SetNextNetDrive (LPOBJECT_LE, int FAR *, LPSTR);
OLESTATUS   FARINTERNAL CheckNetDrive (LPOBJECT_LE, BOOL);
OLESTATUS   INTERNAL    FixNet (LPOBJECT_LE, LPSTR, BOOL);
OLESTATUS   INTERNAL    ConnectNet (LPOBJECT_LE, LPSTR);
BOOL        FARINTERNAL ChangeTopic (LPOBJECT_LE);
VOID        INTERNAL    FillDrives (HWND);
INT_PTR     FAR PASCAL  ConnectDlgProc(HWND, UINT, WPARAM, LPARAM);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL   ObjQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL   ObjQuerySize (LPOLEOBJECT, DWORD FAR *);
DWORD     PASCAL FAR    DllPut (LPOLESTREAM, OLE_CONST void FAR*, DWORD);
HANDLE    FARINTERNAL   DuplicateGDIdata (HANDLE, OLECLIPFORMAT);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

HBITMAP   FARINTERNAL   BmDuplicate (HBITMAP, DWORD FAR *, LPBITMAP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\dib.c ===
/****************************** Module Header ******************************\
* Module Name: DIB.C
*
* Handles all API routines for the device independent bitmap sub-dll of
* the ole dll.
*
* Created: Oct-1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik, Raor  (../../1990,91)   Designed, coded
*   curts created portable version for win16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

void FARINTERNAL DibGetExtents (LPSTR, LPPOINT);

#ifdef WIN16
#pragma alloc_text(_TEXT, DibSaveToStream, DibLoadFromStream, DibStreamRead, GetBytes, PutBytes, PutStrWithLen, DibGetExtents)
#endif

OLEOBJECTVTBL    vtblDIB  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        DibRelease,         // Release
        ErrShow,            // Show
        ErrPlay,            // show
        DibGetData,         // Get the object data
        ErrSetData,         // Set the object data
        ErrSetTargetDevice, //

        ErrSetBounds,       // set viewport bounds
        DibEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        DibRelease,         // delete
        ErrSetHostNames,    //

        DibSaveToStream,    // write to file
        DibClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Lnk

        DibEqual,           // compares the given objects for data equality

        DibCopy,            // copy to clip

        DibDraw,            // draw the object

        ErrActivate,        // open
        ErrExecute,         // excute
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name

        ObjQueryType,      // Object type
        DibQueryBounds,    // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current

        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        DibChangeData        // change data of the existing object
};



OLESTATUS  FARINTERNAL DibRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;
    HOBJECT hobj;

    if (lpobj->hDIB){
        GlobalFree (lpobj->hDIB);
        lpobj->hDIB = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);

    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL DibSaveToStream (
    LPOLEOBJECT  lpoleobj,
    LPOLESTREAM  lpstream
){
    DWORD        dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_DIB lpobj     = (LPOBJECT_DIB)lpoleobj;
    LPSTR        lpDIBbuf;

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen (lpstream, (LPSTR)"DIB"))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    lpobj->sizeBytes = (DWORD)GlobalSize (lpobj->hDIB);
    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (!(lpDIBbuf = GlobalLock (lpobj->hDIB)))
        return OLE_ERROR_MEMORY;

    if (PutBytes (lpstream, lpDIBbuf, lpobj->sizeBytes))
        return OLE_ERROR_STREAM;

    GlobalUnlock (lpobj->hDIB);
    return OLE_OK;
}



OLESTATUS FARINTERNAL  DibClone (
    LPOLEOBJECT         lpoleobjsrc,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){
    LPOBJECT_DIB lpobjsrc = (LPOBJECT_DIB)lpoleobjsrc;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(*lplpoleobj = (LPOLEOBJECT)DibCreateObject (lpobjsrc->hDIB, lpclient,
                            FALSE, lhclientdoc, (LPSTR)lpobjname,
                            lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}



OLESTATUS FARINTERNAL  DibEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_DIB lpobj1 = (LPOBJECT_DIB)lpoleobj1;
    LPOBJECT_DIB lpobj2 = (LPOBJECT_DIB)lpoleobj2;

    if (CmpGlobals (lpobj1->hDIB, lpobj1->hDIB))
        return OLE_OK;

    return OLE_ERROR_NOT_EQUAL;
}


OLESTATUS FARINTERNAL DibCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;
    HANDLE       hDIB;

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    if (!(hDIB = DuplicateGlobal (lpobj->hDIB, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    SetClipboardData (CF_DIB, hDIB);
    return OLE_OK;
}


OLESTATUS FARINTERNAL DibQueryBounds (
    LPOLEOBJECT  lpoleobj,
    LPRECT       lpRc
){
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;

    Puts("DibQueryBounds");

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    lpRc->left     = 0;
    lpRc->top      = 0;
    lpRc->right    = (int) lpobj->head.cx;
    lpRc->bottom   = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL DibEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_DIB lpobj = (LPOBJECT_DIB)lpoleobj;

    if (!cfFormat)
        return CF_DIB;

    return 0;
}


OLESTATUS FARINTERNAL DibGetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    LPHANDLE      lphandle
){
    LPOBJECT_DIB  lpobj = (LPOBJECT_DIB)lpoleobj;

    if (cfFormat != CF_DIB)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hDIB))
        return OLE_ERROR_BLANK;

    return OLE_OK;
}



LPOBJECT_DIB FARINTERNAL DibCreateObject (
    HANDLE      hDIB,
    LPOLECLIENT lpclient,
    BOOL        fDelete,
    LHCLIENTDOC lhclientdoc,
    LPCSTR      lpobjname,
    LONG        objType
){
    LPOBJECT_DIB    lpobj;

    if (lpobj = DibCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (DibChangeData ((LPOLEOBJECT)lpobj, hDIB, lpclient, fDelete) != OLE_OK) {
            DibRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}



// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewDIB will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL DibChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hNewDIB,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_DIB        lpobj = (LPOBJECT_DIB)lpoleobj;
    BITMAPINFOHEADER    bi;
    DWORD               dwSize;
    LPBITMAPINFOHEADER  lpBi;

    if (!hNewDIB)
        return OLE_ERROR_BLANK;

    lpBi = (LPBITMAPINFOHEADER) &bi;
    if (!fDelete) {
        if (!(hNewDIB = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself

        HANDLE htmp;

        if (!(htmp = GlobalReAlloc (hNewDIB, 0L, GMEM_MODIFY|GMEM_SHARE))) {
            htmp = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE);
            GlobalFree (hNewDIB);
            if (!htmp)
                return OLE_ERROR_MEMORY;
        }

        hNewDIB = htmp;
    }

    if (!(lpBi = (LPBITMAPINFOHEADER) GlobalLock (hNewDIB))) {
        GlobalFree (hNewDIB);
        return OLE_ERROR_MEMORY;
    }

    dwSize = (DWORD)GlobalSize (hNewDIB);
    if (lpobj->hDIB)
        GlobalFree (lpobj->hDIB);
    DibUpdateStruct (lpobj, lpclient, hNewDIB, lpBi, dwSize);
    return OLE_OK;
}


void INTERNAL DibUpdateStruct (
    LPOBJECT_DIB        lpobj,
    LPOLECLIENT         lpclient,
    HANDLE              hDIB,
    LPBITMAPINFOHEADER  lpBi,
    DWORD               dwBytes
){
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->sizeBytes = dwBytes;

#ifdef OLD
    lpobj->xSize = point.x = (int) lpBi->biWidth;
    lpobj->ySize = point.y = (int) lpBi->biHeight;
    ConvertToHimetric (&point);
#else
    DibGetExtents ((LPSTR) lpBi, &point);
#endif

    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->hDIB = hDIB;
}



OLESTATUS FARINTERNAL DibLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    LPOBJECT_DIB lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = DibCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto errLoad;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        goto errLoad;

    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto errLoad;

     if (DibStreamRead (lpstream, lpobj)) {
         *lplpoleobject = (LPOLEOBJECT) lpobj;
         return OLE_OK;
    }

errLoad:
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



LPOBJECT_DIB FARINTERNAL DibCreateBlank (
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType
){
    HOBJECT hobj;
    LPOBJECT_DIB lpobj;

    if((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_DIB)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_DIB) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    // The structure is ZERO initialized at allocation time. So only the
    // fields that need to be filled with values other than ZEROS are
    // initialized below

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblDIB;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}




BOOL INTERNAL DibStreamRead (
    LPOLESTREAM     lpstream,
    LPOBJECT_DIB    lpobj
){
    HANDLE              hDIBbuf;
    LPSTR               lpDIBbuf;
    BOOL                retVal = FALSE;
    BITMAPINFOHEADER    bi;

    if (GetBytes (lpstream, (LPSTR) &bi, sizeof(bi)))
        return FALSE;

    if (hDIBbuf = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpDIBbuf = (LPSTR)GlobalLock (hDIBbuf)){
            *((LPBITMAPINFOHEADER) lpDIBbuf) = bi;
            if (!GetBytes (lpstream, lpDIBbuf+sizeof(bi),
                     (lpobj->sizeBytes - sizeof(bi)))) {

                lpobj->hDIB = hDIBbuf;
#ifdef OLD
                //!!! this info should be part of the stream
                if (!lpobj->head.cx) {
                    DibGetExtents ((LPSTR) lpDIBbuf, &point);
                    lpobj->head.cx = (LONG) point.x;
                    lpobj->head.cy = (LONG) point.y;
                }
#endif
                retVal = TRUE;
            }
            GlobalUnlock(hDIBbuf);
        }
        //* Hang on to the memory allocated for the DIB
    }
    return  retVal;
}


OLESTATUS FARINTERNAL DibPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HANDLE     hDIB;

    if ((hDIB = GetClipboardData (CF_DIB)) == NULL)
        return  OLE_ERROR_MEMORY;

    *lplpoleobject = (LPOLEOBJECT) DibCreateObject (hDIB, lpclient, FALSE,
                                        lhclientdoc, lpobjname, objType);

    return OLE_OK;

}


void FARINTERNAL DibGetExtents (
    LPSTR   lpData,
    LPPOINT lpPoint
){
    #define HIMET_PER_METER     100000L  // number of HIMETRIC units / meter

    LPBITMAPINFOHEADER  lpbmi;

    lpbmi = (LPBITMAPINFOHEADER)lpData;

    if (!(lpbmi->biXPelsPerMeter && lpbmi->biYPelsPerMeter)) {
        HDC hdc;

        if (hdc = GetDC (NULL)){
            lpbmi->biXPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSX),
                                    10000, 254);
            lpbmi->biYPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSY),
                                    10000, 254);
        ReleaseDC (NULL, hdc);
        } else {
            //1000x1000 pixel coordinate system to avoid mod by 0
            lpbmi->biXPelsPerMeter = 1000;
            lpbmi->biYPelsPerMeter = 1000;
        }
    }

    lpPoint->x = (int) (lpbmi->biWidth * HIMET_PER_METER
                            / lpbmi->biXPelsPerMeter);
    lpPoint->y = -(int) (lpbmi->biHeight * HIMET_PER_METER
                            / lpbmi->biYPelsPerMeter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\error.c ===
/****************************** Module Header ******************************\
* Module Name: ERROR.C
*
* PURPOSE:  Contains routines which are commonly used, as method functions, by
*           bm.c, mf.c and dib.c. These routines do nothing more than 
*           returning an error code.
*
* Created: November 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (11/20/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

OLESTATUS FARINTERNAL ErrQueryRelease (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    
    return OLE_ERROR_STATIC;
}

OLE_RELEASE_METHOD FARINTERNAL ErrQueryReleaseMethod (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrPlay (
    LPOLEOBJECT lpobj,
    UINT        verb,
    BOOL        fAct,
    BOOL        fShow
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(verb);
    UNREFERENCED_PARAMETER(fAct);
    UNREFERENCED_PARAMETER(fShow);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrShow (
    LPOLEOBJECT lpobj,
    BOOL        fAct
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(fAct);

    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrAbort (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL  ErrCopyFromLink(
    LPOLEOBJECT         lpobj,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpclient);
    UNREFERENCED_PARAMETER(lhclientdoc);
    UNREFERENCED_PARAMETER(lpobjname);
    UNREFERENCED_PARAMETER(lplpobj);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetHostNames (
    LPOLEOBJECT lpobj,
    OLE_LPCSTR  lpclientName,
    OLE_LPCSTR  lpdocName
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpclientName);
    UNREFERENCED_PARAMETER(lpdocName);

    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetTargetDevice (
    LPOLEOBJECT lpobj,
    HANDLE      hDevInfo
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(hDevInfo);

    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetColorScheme (
    LPOLEOBJECT               lpobj,
    OLE_CONST LOGPALETTE FAR* lplogpal
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lplogpal);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetBounds(
    LPOLEOBJECT         lpobj,
    OLE_CONST RECT FAR* lprc
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lprc);

    return OLE_ERROR_MEMORY;
}


OLESTATUS FARINTERNAL  ErrQueryOpen (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrActivate (
    LPOLEOBJECT         lpobj,
    UINT                verb,
    BOOL                fShow,
    BOOL                fAct,
    HWND                hWnd,
    OLE_CONST RECT FAR* lprc
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(verb);
    UNREFERENCED_PARAMETER(fShow);
    UNREFERENCED_PARAMETER(fAct);
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrEdit (
    LPOLEOBJECT lpobj,
    BOOL        fShow,
    HWND        hWnd,
    LPRECT      lprc
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(fShow);
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrClose (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrUpdate (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrReconnect (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);

    return OLE_ERROR_STATIC;      // static object

}


OLESTATUS FARINTERNAL ErrSetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE          hData
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(cfFormat);
    UNREFERENCED_PARAMETER(hData);

    return OLE_ERROR_MEMORY;
}


OLESTATUS   FARINTERNAL  ErrReadFromStream (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    LPOLESTREAM     lpstream
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(cfFormat);
    UNREFERENCED_PARAMETER(lpstream);

    return OLE_ERROR_STREAM;
}



OLESTATUS FARINTERNAL ErrQueryOutOfDate (
    LPOLEOBJECT lpobj
){
    UNREFERENCED_PARAMETER(lpobj);
 
   return OLE_OK;
}


OLESTATUS FARINTERNAL ErrObjectConvert (
    LPOLEOBJECT         lpobj,
    OLE_LPCSTR          lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpprotocol);
    UNREFERENCED_PARAMETER(lpclient);
    UNREFERENCED_PARAMETER(lhclientdoc);
    UNREFERENCED_PARAMETER(lpobjname);
    UNREFERENCED_PARAMETER(lplpobj);

    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrGetUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE  FAR  *lpoptions
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpoptions);

    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrSetUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE       options
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(options);

    return OLE_ERROR_STATIC;

}

LPVOID  FARINTERNAL ErrQueryProtocol (
    LPOLEOBJECT lpobj,
    LPCSTR      lpprotocol
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lpprotocol);
 
   return NULL;
}

OLESTATUS FARINTERNAL ErrRequestData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(cfFormat);

    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrExecute (
    LPOLEOBJECT     lpobj,
    HANDLE          hData,
    UINT            wReserved
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(hData);
    UNREFERENCED_PARAMETER(wReserved);

    return OLE_ERROR_STATIC;
}



OLESTATUS FARINTERNAL ErrObjectLong (
    LPOLEOBJECT     lpobj,
    UINT            wFlags,
    LPLONG          lplong
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(wFlags);
    UNREFERENCED_PARAMETER(lplong);

    return OLE_ERROR_STATIC;
}


HANDLE FARINTERNAL DuplicateGDIdata (
    HANDLE          hSrcData,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpSrcMfp;
        LPMETAFILEPICT  lpDstMfp = NULL;        
        HANDLE          hMF = NULL;
        HANDLE          hDstMfp = NULL;
        
        if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
            return NULL;
        
        GlobalUnlock (hSrcData);
        
        if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
            return NULL;
        
        if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
            goto errMfp;    

        if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
            goto errMfp;
        
        GlobalUnlock (hDstMfp);
        
        *lpDstMfp = *lpSrcMfp;
        lpDstMfp->hMF = hMF;
        return hDstMfp;
errMfp:
        if (hMF)
            DeleteMetaFile (hMF);
        
        if (hDstMfp)
            GlobalFree (hDstMfp);
        
        return NULL;
    }
    
    if (cfFormat == CF_BITMAP) {
        DWORD dwSize;
        
        return BmDuplicate (hSrcData, &dwSize, NULL);
    }
    
    if (cfFormat == CF_DIB) 
        return DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
    
    if (cfFormat == CF_ENHMETAFILE) 
        return CopyEnhMetaFile(hSrcData, NULL);

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: DRAW.C
*
* PURPOSE: Contains all the drawing related routines
*
* Created: March 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*       (03/21/91) Srinik  Original
*       (03/22/91) Srinik  Added support for drawing metafile in a metafile
*       curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

#define RECORD_COUNT    16

int       INTERNAL    PaletteSize (int);
HANDLE    INTERNAL    DibMakeLogPalette(LPSTR, UINT, LPLOGPALETTE FAR *);
OLESTATUS FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);
OLESTATUS INTERNAL    wDrawBitmap (LPOBJECT_BM, HDC, HDC, LPRECT);
OLESTATUS INTERNAL    wDrawBitmapUsingDib (LPOBJECT_BM, HDC, HDC, HDC, LPRECT, LPRECT);

void SetPictOrg (LPOBJECT_MF, HDC, int, int, BOOL);
void SetPictExt (LPOBJECT_MF, HDC, int, int);
void ScalePictExt (LPOBJECT_MF, HDC, int, int, int, int);
void ScaleRectExt (LPOBJECT_MF, HDC, int, int, int, int);

void CleanStack(LPOBJECT_MF, HANDLE);
BOOL PopDc (LPOBJECT_MF);
BOOL PushDc (LPOBJECT_MF);

#ifdef META_DEBUG
void PutMetaFuncName (UINT);
#endif

OLESTATUS  FARINTERNAL BmDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_BM lpobj = (LPOBJECT_BM)lpoleobj;
    int         iScreenDevCaps;
    HDC         hMemDC, hScreenDC;
    OLESTATUS   ret = OLE_OK;

    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    if (!(hScreenDC = GetDC (NULL))){
        return OLE_ERROR_MEMORY;
    }

    iScreenDevCaps = GetDeviceCaps (hScreenDC, TECHNOLOGY);
    if (!OleIsDcMeta (hdc)
            && (iScreenDevCaps != GetDeviceCaps (hdc, TECHNOLOGY))) {
        ret = wDrawBitmapUsingDib (lpobj, hdc, hScreenDC,
                        hdcTarget, (LPRECT)lprc, (LPRECT)lpWrc);
    }
    else {
        hMemDC = CreateCompatibleDC (hdc);
        if (hMemDC) {
            ret = wDrawBitmap (lpobj, hdc, hMemDC, (LPRECT)lprc);
            DeleteDC (hMemDC);
        } else {
            ret = OLE_ERROR_MEMORY;
        }

    }

    ReleaseDC (NULL, hScreenDC);
    return ret;

}

OLESTATUS INTERNAL wDrawBitmap (
    LPOBJECT_BM lpobj,
    HDC         hdc,
    HDC         hMemDC,
    LPRECT      lprc
){
    HBITMAP     hOldBitmap;
    OLESTATUS   ret = OLE_OK;

    if (!hMemDC)
        return OLE_ERROR_MEMORY;

    if (!(hOldBitmap = SelectObject(hMemDC, lpobj->hBitmap)))
        return OLE_ERROR_DRAW;

    if (!StretchBlt(hdc,
            lprc->left, lprc->top,
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            hMemDC, 0, 0, lpobj->xSize, lpobj->ySize, SRCCOPY)) {
        ret = OLE_ERROR_DRAW;
    }

    SelectObject (hMemDC, hOldBitmap);
    return ret;
}


OLESTATUS INTERNAL wDrawBitmapUsingDib (
    LPOBJECT_BM     lpobj,
    HDC             hdc,
    HDC             hScreenDC,
    HDC             hTargetDC,
    LPRECT          lprc,
    LPRECT          lpWrc
){
    BITMAP              bm;
    LPBITMAPINFOHEADER  lpBmi;
    HANDLE              hBmi, hDib = NULL;
    UINT                wBmiSize;
    OLESTATUS           retVal = OLE_ERROR_MEMORY;

    if (!GetObject(lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm))
        return OLE_ERROR_HANDLE;

    wBmiSize = sizeof(BITMAPINFOHEADER)
                    + PaletteSize(bm.bmPlanes * bm.bmBitsPixel);

    if (!(hBmi = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, wBmiSize)))
        return OLE_ERROR_MEMORY;

    if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hBmi))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }

    GlobalUnlock (hBmi);

    lpBmi->biSize          = (LONG) sizeof(BITMAPINFOHEADER);
    lpBmi->biWidth         = (LONG) bm.bmWidth;
    lpBmi->biHeight        = (LONG) bm.bmHeight;
    lpBmi->biPlanes        = 1;
    lpBmi->biBitCount      = bm.bmPlanes * bm.bmBitsPixel;
    lpBmi->biCompression   = BI_RGB;
    lpBmi->biSizeImage     = 0L;
    lpBmi->biXPelsPerMeter = 0L;
    lpBmi->biYPelsPerMeter = 0L;
    lpBmi->biClrUsed       = 0L;
    lpBmi->biClrImportant  = 0L;

    // Call GetDIBits with a NULL lpBits parm, so that it will calculate
    // the biSizeImage field for us
    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, bm.bmHeight, NULL,
            (LPBITMAPINFO)lpBmi, DIB_RGB_COLORS))
        return OLE_ERROR_HANDLE;

    // Realloc the buffer to provide space for the bits
    if (!(hDib = GlobalReAlloc (hBmi, (wBmiSize + lpBmi->biSizeImage),
                        GMEM_MOVEABLE))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }

    // If reallocation gave a new handle then lock that handle and get the
    // long pointer to it.
    if (hDib != hBmi) {
        if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hDib)))
            goto errRtn;
        GlobalUnlock (hDib);
    }

    // Call GetDIBits with a NON-NULL lpBits parm, and get the actual bits

    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, (WORD) lpBmi->biHeight,
             ((LPSTR)lpBmi)+wBmiSize,
             (LPBITMAPINFO) lpBmi,
             DIB_RGB_COLORS)) {
        retVal = OLE_ERROR_HANDLE;
        goto errRtn;
    }

    retVal = wDibDraw (hDib, hdc, lprc, lpWrc, hTargetDC, FALSE);

errRtn:
    if (hDib)
        GlobalFree (hDib);
    return retVal;
}

OLESTATUS  FARINTERNAL DibDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_DIB    lpobj = (LPOBJECT_DIB)lpoleobj;

    return wDibDraw (lpobj->hDIB, hdc, (LPRECT)lprc, (LPRECT)lpWrc, hdcTarget, FALSE);
}



OLESTATUS  FARINTERNAL wDibDraw (
    HANDLE  hData,
    HDC     hdc,
    LPRECT  lprc,
    LPRECT  lpWrc,
    HDC     hdcTarget,
    BOOL    bPbrushData
){
    // !!! current implementation is not using hdcTarget
    OLESTATUS       ret = OLE_ERROR_DRAW;
    LPSTR           lpData;
    HANDLE          hPalette = NULL;
    HPALETTE        hLogPalette = NULL, hOldPalette = NULL;
    LPLOGPALETTE    lpLogPalette;
    UINT            wPalSize;
    int             iOffBits;
	 HANDLE          hbminfo = NULL;
	 LPBITMAPINFO    lpbminfo;

    UNREFERENCED_PARAMETER(lpWrc);
    UNREFERENCED_PARAMETER(hdcTarget);

    if (!hData)
        return OLE_ERROR_BLANK;

    if (!(lpData = GlobalLock (hData)))
        return OLE_ERROR_MEMORY;

    if (bPbrushData)
	 {
	     BITMAPINFO UNALIGNED * lpbminfoTmp;
		  DWORD dwSize;
	
	  	  lpData     += sizeof(BITMAPFILEHEADER);
		  lpbminfoTmp = (BITMAPINFO UNALIGNED *)lpData;
	
		  dwSize =  sizeof(BITMAPINFOHEADER) + PaletteSize (lpbminfoTmp->bmiHeader.biBitCount);
								
		  if (!(hbminfo = GlobalAlloc(GHND, dwSize)) )
			  return OLE_ERROR_MEMORY;

        if (!(lpbminfo = (LPBITMAPINFO)GlobalLock(hbminfo)) )
		  {
            ret = OLE_ERROR_MEMORY;
			   goto end;
		  }
		
		  memcpy( (LPSTR)lpbminfo, lpData, dwSize );
		
	 }
	 else
		  lpbminfo = (LPBITMAPINFO)lpData;

    wPalSize = PaletteSize (lpbminfo->bmiHeader.biBitCount);
    iOffBits  = sizeof(BITMAPINFOHEADER) + wPalSize;

    // if color palette exits do the following
    if (wPalSize) {
        if (!(hLogPalette = DibMakeLogPalette(lpData+sizeof(BITMAPINFOHEADER),
                                    wPalSize, &lpLogPalette))) {
            ret = OLE_ERROR_MEMORY;
            goto end;
        }

        if (!(hPalette = CreatePalette (lpLogPalette)))
            goto end;

        // select as a background palette
        if (!(hOldPalette = SelectPalette (hdc, hPalette, TRUE)))
            goto end;

        RealizePalette(hdc);
    }

    if (!StretchDIBits(hdc,
            lprc->left, lprc->top,
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            0, 0,
            (UINT) lpbminfo->bmiHeader.biWidth,
            (UINT) lpbminfo->bmiHeader.biHeight,
            lpData + iOffBits,
            lpbminfo,
            DIB_RGB_COLORS,
            SRCCOPY)) {
        ret = OLE_ERROR_DRAW;
    }
    else
        ret = OLE_OK;

end:
    // if color palette exists do the following
    if (wPalSize) {
        hOldPalette = (OleIsDcMeta (hdc) ? GetStockObject(DEFAULT_PALETTE)
                                         : hOldPalette);
        if (hOldPalette) {
            // select as a background palette
            SelectPalette (hdc, hOldPalette, TRUE);
            RealizePalette (hdc);
        }

        if (hPalette)
            DeleteObject (hPalette);

        if (hLogPalette)
            GlobalFree (hLogPalette);
    }

    GlobalUnlock (hData);
	
	 if (hbminfo)
	 {
		 GlobalUnlock(hbminfo);
		 GlobalFree(hbminfo);
	 }
		
    return ret;
}





HANDLE INTERNAL DibMakeLogPalette (
    LPSTR               lpColorData,
    UINT                wDataSize,
    LPLOGPALETTE FAR *  lplpLogPalette
){
    HANDLE          hLogPalette=NULL;
    LPLOGPALETTE    lpLogPalette;
    DWORD           dwLogPalSize = wDataSize +  2 * sizeof(UINT);
    LPPALETTEENTRY  lpPE;
    RGBQUAD FAR *   lpQuad;

    if (!(hLogPalette = GlobalAlloc(GMEM_MOVEABLE,dwLogPalSize)))
        return NULL;

    if (!(lpLogPalette = (LPLOGPALETTE) GlobalLock (hLogPalette))) {
        GlobalFree (hLogPalette);
        return NULL;
    }

    GlobalUnlock (hLogPalette);
    *lplpLogPalette = lpLogPalette;

    lpLogPalette->palVersion = 0x300;
    lpLogPalette->palNumEntries = (WORD)(wDataSize / sizeof(PALETTEENTRY));

    /* now convert RGBQUAD to PALETTEENTRY as we copy color info */
    for (lpQuad = (RGBQUAD far *)lpColorData,
            lpPE   = (LPPALETTEENTRY)lpLogPalette->palPalEntry,
            wDataSize /= sizeof(RGBQUAD);
            wDataSize--;
            ++lpQuad,++lpPE) {
        lpPE->peFlags=0;
        lpPE->peRed = lpQuad->rgbRed;
        lpPE->peBlue = lpQuad->rgbBlue;
        lpPE->peGreen = lpQuad->rgbGreen;
    }

    return hLogPalette;
}


int INTERNAL PaletteSize (int iBitCount)
{
    switch (iBitCount) {
        case 1:
            return (2*sizeof(RGBQUAD));

        case 4:
            return (16*sizeof(RGBQUAD));

        case 8:
            return (256*sizeof(RGBQUAD));

        default:
            return 0;   /* A 24 bitcount DIB has no color table */
    }
}


OLESTATUS  FARINTERNAL GenDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_GEN    lpobj = (LPOBJECT_GEN) lpoleobj;

    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(lprc);
    UNREFERENCED_PARAMETER(lpWrc);
    UNREFERENCED_PARAMETER(hdcTarget);

    return OLE_ERROR_GENERIC;
}

////////////////////////////////////////////////////////////////////////////
//  METAFILE draw routines
////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL MfDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_MF lpobj = (LPOBJECT_MF) lpoleobj;
    HANDLE  hInfo;
    int     iOldDc;
    RECT    rect;
    LPRECT  lpRrc = (LPRECT) &rect;

    UNREFERENCED_PARAMETER(hdcTarget);

    rect.left   = lprc->left;
    rect.right  = lprc->right;
    rect.top    = lprc->top;
    rect.bottom = lprc->bottom;

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    lpobj->nRecord = RECORD_COUNT;
    lpobj->fMetaDC = OleIsDcMeta (hdc);

    if (!(iOldDc = SaveDC (hdc)))
        return OLE_ERROR_MEMORY;

    IntersectClipRect (hdc, lpRrc->left, lpRrc->top,
        lpRrc->right, lpRrc->bottom);

    if (!lpobj->fMetaDC) {
        LPtoDP (hdc, (LPPOINT) lpRrc, 2);
        SetMapMode (hdc, MM_ANISOTROPIC);
        MSetViewportOrg (hdc, lpRrc->left, lpRrc->top);
        MSetViewportExt (hdc, lpRrc->right - lpRrc->left,
            lpRrc->bottom - lpRrc->top);
    }
    else {

        iOldDc = -1;

        if (!lpWrc) {
#ifdef FIREWALLS
            ASSERT(0, "Pointer to rect is null")
#endif
            return OLE_ERROR_DRAW;
        }

        if (!(hInfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT,
                            sizeof(METAINFO))))
            return OLE_ERROR_MEMORY;

        if (!(lpobj->pMetaInfo = (PMETAINFO) LocalLock (hInfo))) {
            LocalFree (hInfo);
            return OLE_ERROR_MEMORY;
        }

        LocalUnlock (hInfo);

        lpobj->pCurMdc          = (PMETADC) (lpobj->pMetaInfo);

        lpobj->pMetaInfo->xwo   = lpWrc->left;
        lpobj->pMetaInfo->ywo   = lpWrc->top;
        lpobj->pMetaInfo->xwe   = lpWrc->right;
        lpobj->pMetaInfo->ywe   = lpWrc->bottom;

        lpobj->pMetaInfo->xro   = lpRrc->left - lpWrc->left;
        lpobj->pMetaInfo->yro   = lpRrc->top - lpWrc->top;

        lpobj->pCurMdc->xre     = lpRrc->right - lpRrc->left;
        lpobj->pCurMdc->yre     = lpRrc->bottom - lpRrc->top;

    }

    lpobj->error = OLE_OK;
    MfInterruptiblePaint(lpobj, hdc);

    if (lpobj->fMetaDC)
        CleanStack (lpobj, hInfo);

    RestoreDC (hdc, iOldDc);
    return lpobj->error;
}


void INTERNAL MfInterruptiblePaint (
    LPOBJECT_MF lpobj,
    HDC         hdc
){

    EnumMetaFile (hdc,lpobj->mfp.hMF, (MFENUMPROC)MfCallbackFunc, (LPARAM)lpobj);
	
}



BOOL APIENTRY MfCallbackFunc (
    HDC             hdc,
    LPHANDLETABLE   lpHTable,
    LPMETARECORD    lpMFR,
    int             nObj,
    LPVOID          lpobj
){
    LPOBJECT_MF lpobjMf;

    lpobjMf = (LPOBJECT_MF) lpobj;
    if (!--lpobjMf->nRecord) {
        lpobjMf->nRecord = RECORD_COUNT;
        if (!ContextCallBack ((lpobjMf->head.lpParent
                                    ? lpobjMf->head.lpParent
                                    : (LPOLEOBJECT) lpobjMf),
                        OLE_QUERY_PAINT)) {
            lpobjMf->error = OLE_ERROR_ABORT;
            return FALSE;
        }
    }

    if (lpobjMf->fMetaDC) {

#ifdef META_DEBUG
        PutMetaFuncName (lpMFR->rdFunction);
#endif

        switch (lpMFR->rdFunction) {
            case META_SETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1],
                    lpMFR->rdParm[0], FALSE);
                return TRUE;

            case META_OFFSETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1],
                    lpMFR->rdParm[0], TRUE);
                return TRUE;

            case META_SETWINDOWEXT:
                SetPictExt (lpobjMf, hdc, lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;

            case META_SCALEWINDOWEXT:
                ScalePictExt (lpobjMf, hdc,
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;

            case META_SAVEDC:
                if (!PushDc (lpobjMf))
                    return FALSE;
                break;

            case META_RESTOREDC:
                PopDc (lpobjMf);
                break;

            case META_SCALEVIEWPORTEXT:
                ScaleRectExt (lpobjMf, hdc,
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;

            case META_OFFSETVIEWPORTORG:
#ifdef FIREWALLS
                ASSERT(0, "OffsetViewportOrg() in metafile");
#endif
                return TRUE;

            case META_SETVIEWPORTORG:
#ifdef FIREWALLS
                ASSERT(0, "SetViewportOrg() in metafile");
#endif
                return TRUE;

            case META_SETVIEWPORTEXT:
#ifdef FIREWALLS
                ASSERT(0, "SetViewportExt() in metafile");
#endif
                return TRUE;

            case META_SETMAPMODE:
#ifdef FIREWALLS
                ASSERT(lpMFR->rdParm[0] == MM_ANISOTROPIC,
                    "SetmapMode() in metafile with invalid mapping mode");
#endif
                return TRUE;

            default:
                break;
        }
    }
    else {
        switch (lpMFR->rdFunction) {
            int extX,extY;

            case META_SCALEWINDOWEXT:
                if (MGetWindowExt (hdc,&extX,&extY))
                {
                     MSetWindowExt (
                        hdc,
                        MulDiv(extX, lpMFR->rdParm[3], lpMFR->rdParm[2]),
                        MulDiv(extY, lpMFR->rdParm[1], lpMFR->rdParm[0])
                     );
                     return TRUE;
                }
                return FALSE;

            case META_SCALEVIEWPORTEXT:
                if (MGetViewportExt (hdc,&extX,&extY))
                {
                     MSetViewportExt (
                        hdc,
                        MulDiv(extX, lpMFR->rdParm[3], lpMFR->rdParm[2]),
                        MulDiv(extY, lpMFR->rdParm[1], lpMFR->rdParm[0])
                     );
                     return TRUE;
                }
                return FALSE;

            default:
                break;
        }
    }

    PlayMetaFileRecord (hdc, lpHTable, lpMFR, nObj);
    return TRUE;
}


void SetPictOrg (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xOrg,
    int         yOrg,
    BOOL        fOffset
){
    if (fOffset) {
        // it's OffsetWindowOrg() call
        lpobj->pCurMdc->xMwo += xOrg;
        lpobj->pCurMdc->yMwo += yOrg;
    }
    else {
        // it's SetWindowOrg()
        lpobj->pCurMdc->xMwo = xOrg;
        lpobj->pCurMdc->yMwo = yOrg;
    }

    if (lpobj->pCurMdc->xMwe && lpobj->pCurMdc->yMwe) {
        MSetWindowOrg (hdc,
            (lpobj->pCurMdc->xMwo - MulDiv (lpobj->pMetaInfo->xro,
                                        lpobj->pCurMdc->xMwe,
                                        lpobj->pCurMdc->xre)),
            (lpobj->pCurMdc->yMwo - MulDiv (lpobj->pMetaInfo->yro,
                                        lpobj->pCurMdc->yMwe,
                                        lpobj->pCurMdc->yre)));
    }
}


void SetPictExt (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xExt,
    int         yExt
){
    lpobj->pCurMdc->xMwe = xExt;
    lpobj->pCurMdc->yMwe = yExt;

    MSetWindowExt (hdc,
        MulDiv (lpobj->pMetaInfo->xwe, xExt, lpobj->pCurMdc->xre),
        MulDiv (lpobj->pMetaInfo->ywe, yExt, lpobj->pCurMdc->yre));

    MSetWindowOrg (hdc,
        (lpobj->pCurMdc->xMwo
            - MulDiv (lpobj->pMetaInfo->xro, xExt, lpobj->pCurMdc->xre)),
        (lpobj->pCurMdc->yMwo
            - MulDiv (lpobj->pMetaInfo->yro, yExt, lpobj->pCurMdc->yre)));
}


void ScalePictExt (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xNum,
    int         xDenom,
    int         yNum,
    int         yDenom
){
    SetPictExt (lpobj, hdc, MulDiv (lpobj->pCurMdc->xMwe, xNum, xDenom),
        MulDiv (lpobj->pCurMdc->yMwe, yNum, yDenom));
}


void ScaleRectExt (
    LPOBJECT_MF lpobj,
    HDC         hdc,
    int         xNum,
    int         xDenom,
    int         yNum,
    int         yDenom
){
    lpobj->pCurMdc->xre = MulDiv (lpobj->pCurMdc->xre, xNum, xDenom);
    lpobj->pCurMdc->yre = MulDiv (lpobj->pCurMdc->yre, yNum, yDenom);

    SetPictExt (lpobj, hdc, lpobj->pCurMdc->xMwe, lpobj->pCurMdc->yMwe);
}



BOOL PushDc (LPOBJECT_MF lpobj)
{
    HANDLE  hNode = NULL;
    PMETADC pNode = NULL;

    if ((hNode = LocalAlloc (LMEM_MOVEABLE, sizeof (METADC)))
            && (pNode = (PMETADC) LocalLock (hNode))) {
        *pNode =  *lpobj->pCurMdc;
        lpobj->pCurMdc->pNext = pNode;
        pNode->pNext = NULL;
        lpobj->pCurMdc = pNode;
        LocalUnlock (hNode);
        return TRUE;
    }

    if (pNode)
        LocalFree (hNode);

    lpobj->error = OLE_ERROR_MEMORY;
    return FALSE;
}


BOOL PopDc (LPOBJECT_MF lpobj)
{
    PMETADC pPrev = (PMETADC) (lpobj->pMetaInfo);
    PMETADC pCur  = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;

    if (!pCur)
        // more Pops than Pushes
        return FALSE;

    while (pCur->pNext) {
        pPrev = pCur;
        pCur  = pCur->pNext;
    }

    if (hCur = LocalHandle ((MAPTYPE(WORD,LPSTR)) pCur))
        LocalFree (hCur);
    pPrev->pNext    = NULL;
    lpobj->pCurMdc  = pPrev;
    return TRUE;
}


void CleanStack(
    LPOBJECT_MF lpobj,
    HANDLE      hMetaInfo
){
    PMETADC pCur = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;

    while (pCur) {
        hCur = LocalHandle ((MAPTYPE(WORD,LPSTR)) pCur);
        ((PMETADC) (lpobj->pMetaInfo))->pNext = pCur = pCur->pNext;
        if (hCur)
            LocalFree (hCur);
    }

    LocalFree (hMetaInfo);
    lpobj->fMetaDC      = FALSE;
    lpobj->pCurMdc      = NULL;
    lpobj->pMetaInfo    = NULL;
}

#ifdef META_DEBUG
void PutMetaFuncName (WORD value)
{
    switch (value) {
        case META_SETBKCOLOR:
             OutputDebugString ("SetBkColor ");
             break;

        case META_SETBKMODE:
             OutputDebugString ("SetBkMode ");
             break;

        case META_SETMAPMODE:
             OutputDebugString ("SetMapMode ");
             break;

        case META_SETROP2:
             OutputDebugString ("SetRop2 ");
             break;

        case META_SETRELABS:
             OutputDebugString ("SetRelabs ");
             break;

        case META_SETPOLYFILLMODE:
             OutputDebugString ("SetPolyfillMode ");
             break;

        case META_SETSTRETCHBLTMODE:
             OutputDebugString ("SetStretchBltMode ");
             break;

        case META_SETTEXTCHAREXTRA:
             OutputDebugString ("SetTextCharExtra ");
             break;

        case META_SETTEXTCOLOR:
             OutputDebugString ("SetTextColor ");
             break;

        case META_SETTEXTJUSTIFICATION:
             OutputDebugString ("SetTextJustification ");
             break;

        case META_SETWINDOWORG:
             OutputDebugString ("SetWindowOrg ");
             break;

        case META_SETWINDOWEXT:
             OutputDebugString ("SetWindowExt ");
             break;

        case META_SETVIEWPORTORG:
             OutputDebugString ("SetViewportOrg ");
             break;

        case META_SETVIEWPORTEXT:
             OutputDebugString ("SetViewportExt ");
             break;

        case META_OFFSETWINDOWORG:
             OutputDebugString ("OffsetWindowOrg ");
             break;

        case META_SCALEWINDOWEXT:
             OutputDebugString ("ScaleWindowExt ");
             break;

        case META_OFFSETVIEWPORTORG:
             OutputDebugString ("OffsetViewportOrg ");
             break;

        case META_SCALEVIEWPORTEXT:
             OutputDebugString ("ScaleViewportExt ");
             break;

        case META_LINETO:
             OutputDebugString ("LineTo ");
             break;

        case META_MOVETO:
             OutputDebugString ("MoveTo ");
             break;

        case META_EXCLUDECLIPRECT:
             OutputDebugString ("ExcludeCliprect ");
             break;

        case META_INTERSECTCLIPRECT:
             OutputDebugString ("IntersectCliprect ");
             break;

        case META_ARC:
             OutputDebugString ("Arc ");
             break;

        case META_ELLIPSE:
             OutputDebugString ("Ellipse ");
             break;

        case META_FLOODFILL:
             OutputDebugString ("FloodFill ");
             break;

        case META_PIE:
             OutputDebugString ("Pie ");
             break;

        case META_RECTANGLE:
             OutputDebugString ("Rectangle ");
             break;

        case META_ROUNDRECT:
             OutputDebugString ("RoundRect ");
             break;

        case META_PATBLT:
             OutputDebugString ("PatBlt ");
             break;

        case META_SAVEDC:
             OutputDebugString ("SaveDC ");
             break;

        case META_SETPIXEL:
             OutputDebugString ("SetPixel ");
             break;

        case META_OFFSETCLIPRGN:
             OutputDebugString ("OffsetClipRegion ");
             break;

        case META_TEXTOUT:
             OutputDebugString ("TextOut ");
             break;

        case META_BITBLT:
             OutputDebugString ("BitBlt ");
             break;

        case META_STRETCHBLT:
             OutputDebugString ("StrechBlt ");
             break;

        case META_POLYGON:
             OutputDebugString ("Polygon ");
             break;

        case META_POLYLINE:
             OutputDebugString ("PolyLine ");
             break;

        case META_ESCAPE:
             OutputDebugString ("Escape ");
             break;

        case META_RESTOREDC:
             OutputDebugString ("RestoreDC ");
             break;

        case META_FILLREGION:
             OutputDebugString ("FillRegion ");
             break;

        case META_FRAMEREGION:
             OutputDebugString ("FrameRegion ");
             break;

        case META_INVERTREGION:
             OutputDebugString ("InvertRegion ");
             break;

        case META_PAINTREGION:
             OutputDebugString ("PaintRegion ");
             break;

        case META_SELECTCLIPREGION:
             OutputDebugString ("SelectClipRegion ");
             break;

        case META_SELECTOBJECT:
             OutputDebugString ("SelectObject ");
             break;

        case META_SETTEXTALIGN:
             OutputDebugString ("SetTextAlign ");
             break;

        case META_DRAWTEXT:
             OutputDebugString ("DrawText");
             break;

        case META_CHORD:
             OutputDebugString ("Chord ");
             break;

        case META_SETMAPPERFLAGS:
             OutputDebugString ("SetMapperFlags ");
             break;

        case META_EXTTEXTOUT:
             OutputDebugString ("ExtTextOut ");
             break;

        case META_SETDIBTODEV:
             OutputDebugString ("SetDIBitsToDevice ");
             break;

        case META_SELECTPALETTE:
             OutputDebugString ("SelectPalette ");
             break;

        case META_REALIZEPALETTE:
             OutputDebugString ("RealizePalette ");
             break;

        case META_ANIMATEPALETTE:
             OutputDebugString ("AnimatePalette ");
             break;

        case META_SETPALENTRIES:
             OutputDebugString ("SetPaletteEntries ");
             break;

        case META_POLYPOLYGON:
             OutputDebugString ("PolyPolygon ");
             break;

        case META_RESIZEPALETTE:
             OutputDebugString ("ResizePalette ");
             break;

        case META_DIBBITBLT:
             OutputDebugString ("DibBitBlt ");
             break;

        case META_DIBSTRETCHBLT:
             OutputDebugString ("DibStrechBlt ");
             break;

        case META_DIBCREATEPATTERNBRUSH:
             OutputDebugString ("DibCreatePatternBrush ");
             break;

        case META_STRETCHDIB:
             OutputDebugString ("StretchDIBits ");
             break;

        case META_DELETEOBJECT:
             OutputDebugString ("DeleteObject ");
             break;

        case META_CREATEPALETTE:
             OutputDebugString ("CreatePalette ");
             break;

        case META_CREATEBRUSH:
             OutputDebugString ("CreateBrush ");
             break;

        case META_CREATEPATTERNBRUSH:
             OutputDebugString ("CreatePatternBrush ");
             break;

        case META_CREATEPENINDIRECT:
             OutputDebugString ("CreatePenIndirect ");
             break;

        case META_CREATEFONTINDIRECT:
             OutputDebugString ("CreateFontIndirect ");
             break;

        case META_CREATEBRUSHINDIRECT:
             OutputDebugString ("CreateBrushIndirect ");
             break;

        case META_CREATEBITMAPINDIRECT:
             OutputDebugString ("CreateBitmapIndirect ");
             break;

        case META_CREATEBITMAP:
             OutputDebugString ("CreateBitmap ");
             break;

        case META_CREATEREGION:
             OutputDebugString ("CreateRegion ");
             break;

        default:
             OutputDebugString ("Invalid+Function+encountered ");
             break;

    }
}
#endif

////////////////////////////////////////////////////////////////////////////
//  ENHMETAFILE draw routines
////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmfDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF) lpoleobj;

     UNREFERENCED_PARAMETER(hdcTarget);
     UNREFERENCED_PARAMETER(lpWrc);

     if (!lpobj->hemf)
         return OLE_ERROR_BLANK;

     lpobj->nRecord = RECORD_COUNT;
     lpobj->fMetaDC = OleIsDcMeta (hdc);

     if (!SaveDC(hdc))
         return OLE_ERROR_MEMORY;

     IntersectClipRect (hdc, lprc->left, lprc->top,
         lprc->right, lprc->bottom);

     lpobj->error = OLE_OK;
     EmfInterruptiblePaint(lpobj, hdc, (LPRECT)lprc);

     RestoreDC(hdc, -1);

     return lpobj->error;
}

void INTERNAL EmfInterruptiblePaint (
    LPOBJECT_EMF lpobj,
    HDC         hdc ,
    LPRECT      lprc
){

    EnumEnhMetaFile (hdc,(HENHMETAFILE)lpobj->hemf, (ENHMFENUMPROC)EmfCallbackFunc, (LPVOID)lpobj, lprc);

}

int FARINTERNAL EmfCallbackFunc (
    HDC             hdc,
    LPHANDLETABLE   lpHTable,
    LPENHMETARECORD lpEMFR,
    int             nObj,
    LPVOID          lpobj
){
    LPOBJECT_EMF lpobjEmf = (LPOBJECT_EMF) lpobj;

    if (!--lpobjEmf->nRecord) {
        lpobjEmf->nRecord = RECORD_COUNT;
        if (!ContextCallBack ((lpobjEmf->head.lpParent
                                    ? lpobjEmf->head.lpParent
                                    : (LPOLEOBJECT) lpobjEmf),
                        OLE_QUERY_PAINT)) {
            lpobjEmf->error = OLE_ERROR_ABORT;
            return FALSE;
        }
    }

    PlayEnhMetaFileRecord (hdc, lpHTable, lpEMFR, nObj);
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\emf.c ===
/****************************** Module Header ******************************\
* Module Name:EMF.C (Extensible Compound Documents - EnhancedMetafile)
*
* PURPOSE:Handles all API routines for the metafile sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   cloned mf.c and banged into form curts March 92
*
* Comments:
*   fun, fun, until hockl takes the enhanced metafile api away
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

#define RECORD_COUNT    16

OLEOBJECTVTBL    vtblEMF = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        EmfRelease,         // Release
        ErrShow,            // show
        ErrPlay,            // play
        EmfGetData,         // Get the object data
        ErrSetData,         // Set the object data
        ErrSetTargetDevice, //
        ErrSetBounds,       // set viewport bounds
        EmfEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        EmfRelease,         // delete
        ErrSetHostNames,    //

        EmfSaveToStream,    // write to file
        EmfClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Lnk

        EmfEqual,           // compares the given objects for data equality

        EmfCopy,            // copy to clip

        EmfDraw,            // draw the object

        ErrActivate,        // open
        ErrExecute,         // excute
        ErrClose,           // stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,          // Change Object name
        ObjQueryName,       // Get current object name
        ObjQueryType,       // Object type
        EmfQueryBounds,     // QueryBounds
        ObjQuerySize,       // Find the size of the object
        ErrQueryOpen,       // Query open
        ErrQueryOutOfDate,  // query whether object is current

        ErrQueryRelease,    // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,     // requestdata
        ErrObjectLong,      // objectLong
        EmfChangeData       // change data of the existing object
};


OLESTATUS FARINTERNAL  EmfRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;
    HOBJECT hobj;

    if (lpobj->hemf) {
        DeleteEnhMetaFile ((HENHMETAFILE)lpobj->hemf);
        lpobj->hemf = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT)lpobj);

    if (hobj = lpobj->head.hobj) {
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}


OLESTATUS FARINTERNAL  SaveEmfAsMfToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD             dwFileVer = (DWORD)MAKELONG(wReleaseVer,OS_WIN32);
    LPOBJECT_EMF      lpobj     = (LPOBJECT_EMF)lpoleobj;
    OLESTATUS         retval    = OLE_ERROR_MEMORY;
    HDC               hdc       = NULL ;
    LPBYTE            lpBytes   = NULL ;
    HANDLE            hBytes    = NULL ;
    WIN16METAFILEPICT w16mfp;
    UINT              lSizeBytes;

    w16mfp.mm   = MM_ANISOTROPIC;
    w16mfp.xExt = (short)lpobj->head.cx;

    if ((short)lpobj->head.cy <0 ) {
       w16mfp.yExt = -(short)lpobj->head.cy;
    } else {
       w16mfp.yExt = (short)lpobj->head.cy;
    }

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"METAFILEPICT"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    hdc = GetDC(NULL);
    if (!(lSizeBytes = GetWinMetaFileBits((HENHMETAFILE)lpobj->hemf, 0, NULL, MM_ANISOTROPIC, hdc)) ) {
        if (hdc) ReleaseDC(NULL, hdc);
        return OLE_ERROR_METAFILE;
    }

    if (!(hBytes = GlobalAlloc(GHND, lSizeBytes)) )
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock(hBytes)) )
        goto error;

    if (GetWinMetaFileBits((HENHMETAFILE)lpobj->hemf, lSizeBytes, lpBytes, MM_ANISOTROPIC, hdc) != lSizeBytes) {
        retval = OLE_ERROR_METAFILE;
        goto error;
    }

    lSizeBytes += sizeof(WIN16METAFILEPICT);

    if (PutBytes (lpstream, (LPSTR) &lSizeBytes, sizeof(UINT)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR)&w16mfp, sizeof(WIN16METAFILEPICT)))
        goto error;

    if (!PutBytes (lpstream, (LPSTR)lpBytes, lSizeBytes - sizeof(WIN16METAFILEPICT)))
        retval = OLE_OK;

error:
    if (lpBytes)
        GlobalUnlock(hBytes);
    if (hBytes)
        GlobalFree(hBytes);

    if (hdc)
      ReleaseDC(NULL, hdc);

    return retval;

}

OLESTATUS FARINTERNAL  EmfSaveToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD        dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_EMF lpobj     = (LPOBJECT_EMF)lpoleobj;
    OLESTATUS    retval    = OLE_ERROR_MEMORY;
    LPBYTE       lpBytes   = NULL ;
    HANDLE       hBytes    = NULL ;


    if (!lpobj->hemf)
        return OLE_ERROR_BLANK;

    if (HIWORD(dwFileVer) == OS_WIN16)
      if (!SaveEmfAsMfToStream(lpoleobj,lpstream))
         return OLE_OK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"ENHMETAFILE"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (!(hBytes = GlobalAlloc(GHND, lpobj->sizeBytes)) )
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock(hBytes)) )
        goto error;

    retval = OLE_ERROR_METAFILE;

    if (GetEnhMetaFileBits((HENHMETAFILE)lpobj->hemf, lpobj->sizeBytes, lpBytes) != lpobj->sizeBytes )
        goto error;

    if (!PutBytes (lpstream, (LPSTR)lpBytes, lpobj->sizeBytes))
        retval = OLE_OK;

error:
    if (lpBytes)
        GlobalUnlock(hBytes);
    if (hBytes)
        GlobalFree(hBytes);

    return retval;

}

OLESTATUS FARINTERNAL  EmfClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_EMF lpobjsrc = (LPOBJECT_EMF)lpoleobjsrc;
    LPOBJECT_EMF lpobjEmf;
    HENHMETAFILE hemf;

    *lplpoleobj = (LPOLEOBJECT)NULL;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;


    if (!((HENHMETAFILE)hemf = CopyEnhMetaFile ((HENHMETAFILE)lpobjsrc->hemf, NULL)))
        return OLE_ERROR_MEMORY;

    if (lpobjEmf = EmfCreateBlank (lhclientdoc, (LPSTR)lpobjname,
                        lpobjsrc->head.ctype)) {
        lpobjEmf->sizeBytes      = lpobjsrc->sizeBytes;
        lpobjEmf->head.lpclient  = lpclient;
		  lpobjEmf->hemf           = hemf;
        EmfSetExtents (lpobjEmf);

        *lplpoleobj = (LPOLEOBJECT)lpobjEmf;
        return OLE_OK;
    }

    return OLE_ERROR_MEMORY;
}



OLESTATUS FARINTERNAL  EmfEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_EMF lpobj1   = (LPOBJECT_EMF)lpoleobj1;
    HANDLE       hBytes1  = NULL;
    LPBYTE       lpBytes1 = NULL;
    LPOBJECT_EMF lpobj2   = (LPOBJECT_EMF)lpoleobj2;
    HANDLE       hBytes2  = NULL;
    LPBYTE       lpBytes2 = NULL;
    OLESTATUS    retval   = OLE_ERROR_MEMORY;


    if (lpobj1->sizeBytes != lpobj2->sizeBytes)
        return OLE_ERROR_NOT_EQUAL;

    if (!(hBytes1 = GlobalAlloc(GHND, lpobj1->sizeBytes)) )
        goto errMemory;

    if (!(lpBytes1 = (LPBYTE)GlobalLock(hBytes1)) )
        goto errMemory;

    if (!(hBytes2 = GlobalAlloc(GHND, lpobj2->sizeBytes)) )
        goto errMemory;

    if (!(lpBytes2 = (LPBYTE)GlobalLock(hBytes2)) )
        goto errMemory;

    if (GetEnhMetaFileBits((HENHMETAFILE)lpobj1->hemf, lpobj1->sizeBytes, lpBytes1) != lpobj1->sizeBytes)
        goto errMemory;

    if (GetEnhMetaFileBits((HENHMETAFILE)lpobj2->hemf, lpobj2->sizeBytes, lpBytes2) != lpobj2->sizeBytes)
        goto errMemory;

    if (CmpGlobals (hBytes1, hBytes2))
        retval = OLE_OK;
    else
        retval = OLE_ERROR_NOT_EQUAL;

errMemory:
   if (lpBytes1)
      GlobalUnlock(lpBytes1);
   if (hBytes1)
      GlobalFree(hBytes1);

   if (lpBytes2)
      GlobalUnlock(lpBytes2);
   if (hBytes2)
      GlobalFree(hBytes2);

   return retval;
}


OLESTATUS FARINTERNAL  EmfCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;
    HENHMETAFILE hemf;

    if (!((HENHMETAFILE)hemf = CopyEnhMetaFile ((HENHMETAFILE)lpobj->hemf, NULL)))
        return OLE_ERROR_MEMORY;

    SetClipboardData(CF_ENHMETAFILE, hemf);

    return OLE_OK;
}



OLESTATUS FARINTERNAL EmfQueryBounds (
    LPOLEOBJECT lpoleobj,
    LPRECT      lpRc
){
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;

    Puts("EmfQueryBounds");

    if (!lpobj->hemf)
        return OLE_ERROR_BLANK;

    // Bounds are given in MM_HIMETRIC mode.

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;

}

OLECLIPFORMAT FARINTERNAL  EmfEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    UNREFERENCED_PARAMETER(lpoleobj);

    if (!cfFormat)
        return CF_ENHMETAFILE;

    return 0;
}


OLESTATUS FARINTERNAL EmfGetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    LPHANDLE      lphandle
){
    LPOBJECT_EMF lpobj = (LPOBJECT_EMF)lpoleobj;

    if (cfFormat != CF_ENHMETAFILE)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hemf))
        return OLE_ERROR_BLANK;

    return OLE_OK;
}


LPOBJECT_EMF FARINTERNAL  EmfCreateObject (
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete,
    LHCLIENTDOC     lhclientdoc,
    LPCSTR          lpobjname,
    LONG            objType
){
    LPOBJECT_EMF     lpobj;

    if (lpobj = EmfCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (EmfChangeData ((LPOLEOBJECT)lpobj, hMeta, lpclient, fDelete) != OLE_OK) {
            EmfRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}

// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.

OLESTATUS FARINTERNAL EmfChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_EMF    lpobj   = (LPOBJECT_EMF)lpoleobj;
    DWORD           dwSizeBytes;
	
	 Puts("EmfChangeData");

    if (hMeta) {
       dwSizeBytes = lpobj->sizeBytes;
       if (lpobj->sizeBytes = GetEnhMetaFileBits(hMeta, 0, NULL)) {
         if (lpobj->hemf)
            DeleteEnhMetaFile ((HENHMETAFILE)lpobj->hemf);
         if (fDelete)
            lpobj->hemf = hMeta;
         else
            (HENHMETAFILE)lpobj->hemf = CopyEnhMetaFile(hMeta,NULL);
         lpobj->head.lpclient = lpclient;
         EmfSetExtents (lpobj);
         return OLE_OK;
       }
       else
         lpobj->sizeBytes = dwSizeBytes;
    }

    return OLE_ERROR_METAFILE;

}


LPOBJECT_EMF FARINTERNAL EmfCreateBlank(
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType
){
    HOBJECT     hobj;
    LPOBJECT_EMF lpobj;

    if(!(hobj = GlobalAlloc (GHND, sizeof(OBJECT_EMF))))
        return NULL;

    if (!(lpobj = (LPOBJECT_EMF) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    lpobj->head.ctype    = objType;
    lpobj->head.lpvtbl   = (LPOLEOBJECTVTBL)&vtblEMF;
    lpobj->head.iTable   = INVALID_INDEX;
    lpobj->head.hobj     = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                    (LPOLEOBJECT) lpobj, lpobjname);

    // Unlock will be done at object deletion time.
    return lpobj;
}


OLESTATUS  FARINTERNAL  EmfLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType
){
    LPOBJECT_EMF lpobj   = NULL;
    OLESTATUS    retval  = OLE_ERROR_STREAM;
    HANDLE       hBytes  = NULL;
    LPBYTE       lpBytes = NULL;

    // Class name would've been read by this time.

    *lplpobj = NULL;

    if (!(lpobj = EmfCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto error;

    if (!lpobj->sizeBytes) {
        retval = OLE_ERROR_BLANK;
        goto error;
    }

    retval = OLE_ERROR_MEMORY;
    if (!(hBytes = GlobalAlloc (GHND, lpobj->sizeBytes)))
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock (hBytes)))
        goto error;

    if (GetBytes (lpstream, (LPSTR)lpBytes, lpobj->sizeBytes))
        goto error;

    if (!((HENHMETAFILE)lpobj->hemf = SetEnhMetaFileBits (lpobj->sizeBytes,lpBytes)) )
        goto error;

    EmfSetExtents (lpobj);

    *lplpobj = (LPOLEOBJECT) lpobj;
    GlobalUnlock(hBytes);
    GlobalFree (hBytes);
    return OLE_OK;

error:
    if (lpBytes)
      GlobalUnlock(hBytes);
    if (hBytes)
      GlobalFree (hBytes);

    OleDelete ((LPOLEOBJECT)lpobj);
    return retval;
}

OLESTATUS FARINTERNAL  EmfPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HANDLE      hMeta;

    *lplpoleobject = NULL;

    if((hMeta = GetClipboardData (CF_ENHMETAFILE)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) EmfCreateObject (hMeta, lpclient,
                                                FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;
}

void FARINTERNAL EmfSetExtents (LPOBJECT_EMF lpobj)
{
    ENHMETAHEADER enhmetaheader;

    GetEnhMetaFileHeader((HENHMETAFILE)lpobj->hemf, sizeof(enhmetaheader), &enhmetaheader);

    lpobj->head.cx = enhmetaheader.rclFrame.right - enhmetaheader.rclFrame.left;
    lpobj->head.cy = enhmetaheader.rclFrame.top - enhmetaheader.rclFrame.bottom;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\le.c ===
/****************************** Module Header ******************************\
* Module Name: le.c
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*   curts created portable version for win16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

#define EMB_ID_INDEX    3          // index of ones digit in #000
char    embStr[]        = "#000";

extern  HANDLE          hInfo;
extern  OLECLIPFORMAT   cfNetworkName;

HANDLE  GetNetNameHandle (LPOBJECT_LE);
BOOL    AreTopicsEqual (LPOBJECT_LE, LPOBJECT_LE);

ATOM FARINTERNAL wAtomCat (ATOM, ATOM);

#ifdef WIN16
#pragma alloc_text(_RARETEXT, LeObjectLong, LeQueryProtocol, LeEqual, AreTopicsEqual, LeObjectConvert, wAtomCat)
#pragma alloc_text(_DDETEXT, LeRequestData, RequestData, LeChangeData, ContextCallBack, DeleteExtraData, NextAsyncCmd, InitAsyncCmd, FarInitAsyncCmd, EndAsyncCmd, ProcessErr, ScheduleAsyncCmd, LeQueryReleaseStatus, EmbLnkDelete, LeRelease, DeleteObjectAto
ms, QueryClose, SendStdClose, TermDocConv, DeleteDocEdit, QueryUnlaunch, SendStdExit, QueryOpen, GetPictType, RequestOn, DocShow, EmbLnkClose, LnkSetUpdateOptions, LnkChangeLnk, TermSrvrConv, DeleteSrvrEdit, LeCopyFromLink)
#endif

OLEOBJECTVTBL    vtblLE  = {

        LeQueryProtocol,   // check whether the speced protocol is supported

        LeRelease,         // release
        LeShow,            // Show
        LeDoVerb,          // run
        LeGetData,
        LeSetData,
        LeSetTargetDevice, //

        LeSetBounds,       // set viewport bounds
        LeEnumFormat,      // returns format
        LeSetColorScheme,  // set color scheme
        LeRelease,         // delete
        LeSetHostNames,    //
        LeSaveToStream,    // write to file
        LeClone,           // clone object
        LeCopyFromLink,    // Create embedded from Link

        LeEqual,           // test whether the object data is similar

        LeCopy,            // copy to clip

        LeDraw,            // draw the object

        LeActivate,        // activate
        LeExecute,         // excute the given commands
        LeClose,           // stop
        LeUpdate,          // Update
        LeReconnect,       // Reconnect

        LeObjectConvert,        // convert object to specified type

        LeGetUpdateOptions,     // Get Link Update options
        LeSetUpdateOptions,     // Set Link Update options

        ObjRename,              // Change Object name
        ObjQueryName,           // Get current object name

        LeQueryType,            // object Type
        LeQueryBounds,          // QueryBounds
        ObjQuerySize,           // Find the size of the object
        LeQueryOpen,            // Query open
        LeQueryOutOfDate,       // query whether object is current

        LeQueryReleaseStatus,   // returns release status
        LeQueryReleaseError,    // assynchronusrelease error
        LeQueryReleaseMethod,   // the method/proc which is in assynchronus
                                // operation.
        LeRequestData,          // requestdata
        LeObjectLong,           // objectLong
        LeChangeData            // change native data of existing object
};



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeObjectLong (lpoleobj, wFlags, lpData)
//
//
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//
//  Arguments:
//
//      lpoleobj    -   ole object pointer
//      wFlags      -   get, set flags
//      lpData      -   long pointer to data
//
//  Returns:
//
//      OLE_OK
//      OLE_ERROR_OBJECT
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeObjectLong (
    LPOLEOBJECT lpoleobj,
    UINT        wFlags,
    LPLONG      lpData
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    LONG    lData;

    Puts("LeObjectLong");

    if (!FarCheckObject((LPOLEOBJECT) lpobj))
        return OLE_ERROR_OBJECT;

    if ((lpobj->head.ctype != CT_EMBEDDED) && (lpobj->head.ctype != CT_LINK))
        return OLE_ERROR_OBJECT;

    if (wFlags & OF_HANDLER) {
        lData = lpobj->lHandlerData;
        if (wFlags & OF_SET)
            lpobj->lHandlerData = *lpData;

        if (wFlags & OF_GET)
            *lpData = lData;
    }
    else {
        lData = lpobj->lAppData;
        if (wFlags & OF_SET)
            lpobj->lAppData = *lpData;

        if (wFlags & OF_GET)
            *lpData = lData;
    }

    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseStatus (lpoleobj)
//
//
//  Returns whether a given object is still processing a previous
//  asynchronous command.  returns OLE_BUSY if the object is still
//  processing the previous command
//
//  Arguments:
//
//      lpoleobj    -   ole object pointer
//
//  Returns:
//
//      OLE_BUSY    -   object is busy
//      OLE_OK      -   not busy
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS   FAR PASCAL LeQueryReleaseStatus (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // probe async will clean up the channels
    // if the server died.


    PROBE_ASYNC (lpobj);
    return OLE_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS   FAR PASCAL LeQueryReleaseError (lpoleobj)
//
//  returns the errors of an asynchronous command.
//
//  Arguments:
//
//      lpoleobj        -   ole object pointer
//
//  Returns:
//
//      OLE_ERROR_..    -   if there is any error
//      OLE_OK          -   no error
//
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE.
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS   FAR PASCAL LeQueryReleaseError (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    return lpobj->mainErr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (lpoleobj)
//
//  returns the method/command of the asynchronous command which
//  resulted in the OLE_RELEASE call back.
//
//  Arguments:
//
//      lpoleobj   -   ole object pointer
//
//  Returns:
//      OLE_RELEASE_METHOD
//
//  Note: This api is typically valid only during the callback of
//        OLE_RELEASE. Using this api, clients can decide which previous
//        asynchronous command resulted in OLE_RELEASE.
//
//////////////////////////////////////////////////////////////////////////////
OLE_RELEASE_METHOD   FAR PASCAL LeQueryReleaseMethod (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    return lpobj->oldasyncCmd;
}



//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID  FARINTERNAL LeQueryProtocol (lpoleobj, lpprotocol)
//
//  Given an oject, returns the new object handle for the new protocol.
//  Does the conversion of objects from one protocol to another one.
//
//  Arguments:
//
//      lpoleobj    -   ole object pointer
//      lpprotocol  -   ptr to new protocol string
//
//  Returns:
//      lpobj       -   New object handle
//      null        -   if the protocol is not supported.
//
//
//////////////////////////////////////////////////////////////////////////////

LPVOID FARINTERNAL  LeQueryProtocol (
    LPOLEOBJECT lpoleobj,
    OLE_LPCSTR  lpprotocol
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->bOldLink)
        return NULL;

    if (!lstrcmp (lpprotocol, PROTOCOL_EDIT))
        return lpobj;

    if  (!lstrcmp (lpprotocol, PROTOCOL_EXECUTE)) {
        if (UtilQueryProtocol (lpobj, lpprotocol))
            return lpobj;

        return NULL;
    }

    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS EmbLnkDelete (lpoleobj)
//
//  Routine for the object termination/deletion. Schedules differnt
//  asynchronous commands depending on different conditions.
//  Arguments:
//
//  Sends "StdClose" only if it is Ok to close the document. Sends
//  "StdExit" only if the server has to be unlaunched.  Deletes the object
//  only if the original command is OLE_DELETE.  No need to call back the
//  client if the deletion is internal.
//
//  While delete, this routine is entered several times. EAIT_FOR_ASYNC_MSG
//  results in going back to from where it is called and the next DDE message
//  brings back the control to this routine.
//
//  Arguments:
//
//      lpobj   -    object pointer
//
//  Returns:
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmbLnkDelete (LPOBJECT_LE lpobj)
{
    HOBJECT     hobj;

    switch (lpobj->subRtn) {

        case    0:

            SKIP_TO (!QueryClose (lpobj), step1);
            // Send "StdCloseDocument"
            SendStdClose (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            step1:
            SETSTEP (lpobj, 1);

            // End the doc conversation
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case    2:


            // delete the doc edit block. It is Ok even if the object
            // is not actually getting deleted.
            DeleteDocEdit (lpobj);

            // if need to unluanch the app, send stdexit.
            SKIP_TO (!QueryUnlaunch (lpobj), step3);
            SendStdExit (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    3:

            step3:
            SETSTEP (lpobj, 3);

            // Do not set any errors.
            // Terminate the server conversation.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    4:

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            if (lpobj->asyncCmd != OLE_DELETE) {

                // if this delete is called because of unlauncinh of
                // object because of some error, no need to
                // call end asynchronous. It  should have been already
                // called from somewhere else.

                if (lpobj->asyncCmd == OLE_SERVERUNLAUNCH){
                    // send the async cmd;
                    CLEARASYNCCMD (lpobj);
                } else
                    EndAsyncCmd (lpobj);
                return OLE_OK;
            }



            // for real delete delete the atoms and space.
            DeleteObjectAtoms (lpobj);

            if (lpobj->lpobjPict)
                (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);

            if (lpobj->hnative)
                GlobalFree (lpobj->hnative);

            if (lpobj->hLink)
                GlobalFree (lpobj->hLink);

            if (lpobj->hhostNames)
                GlobalFree (lpobj->hhostNames);

            if (lpobj->htargetDevice)
                GlobalFree (lpobj->htargetDevice);

            if (lpobj->hdocDimensions)
                GlobalFree (lpobj->hdocDimensions);

            DeleteExtraData (lpobj);

            DocDeleteObject ((LPOLEOBJECT) lpobj);
            // send the async cmd;
            EndAsyncCmd (lpobj);

            if (lpobj->head.iTable != INVALID_INDEX)
                DecreaseHandlerObjCount (lpobj->head.iTable);

            hobj = lpobj->head.hobj;
            ASSERT (hobj, "Object handle NULL in delete")

            GlobalUnlock (hobj);
            GlobalFree (hobj);

            return OLE_OK;
    }

    return OLE_ERROR_GENERIC;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeRelease (lpoleobj)
//
//  Deletes the given object. This is can be asynchronous operation.
//
//  Arguments:
//
//      lpoleobj   -   ole object pointer
//
//  Returns:
//
//      OLE_WAIT_FOR_RELASE: If any DDE_TRANSACTIONS have been queued
//      OLE_OK             : If deletion successfully
//      OLE_ERROR_...      : If any error
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE    lpobj = (LPOBJECT_LE) lpoleobj;


    // For delete allow if the object has been aborted.

    PROBE_ASYNC (lpobj);

    // reset the flags so that we do not delete the object based on the old
    // flags
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_DELETE, EMBLNKDELETE);
    return  EmbLnkDelete (lpobj);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeClone (lpoleobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Clones a given object.
//
//  Arguments:
//
//      lpoleobjsrc:    ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//
//  Note: If the object being cloned is connected to the server, then
//        the cloned object is not connected to the server. For linked
//        objects, OleConnect has to be called.
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_LE lpobjsrc = (LPOBJECT_LE) lpoleobjsrc;
    LPOBJECT_LE lpobj    = (LPOBJECT_LE) NULL;
    int         retval   = OLE_ERROR_MEMORY;

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobjsrc);

    PROBE_CREATE_ASYNC(lpobjsrc);

    if (!(lpobj = LeCreateBlank(lhclientdoc, (LPSTR)lpobjname,
                        lpobjsrc->head.ctype)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;
    lpobj->head.iTable  = lpobjsrc->head.iTable; //!!! dll loading
    lpobj->head.lpvtbl  = lpobjsrc->head.lpvtbl;

    // set the atoms.
    lpobj->app          = DuplicateAtom (lpobjsrc->app);
    lpobj->topic        = DuplicateAtom (lpobjsrc->topic);
    lpobj->item         = DuplicateAtom (lpobjsrc->item);
    lpobj->aServer      = DuplicateAtom (lpobjsrc->aServer);

    lpobj->bOleServer   = lpobjsrc->bOleServer;
    lpobj->verb         = lpobjsrc->verb;
    lpobj->fCmd         = lpobjsrc->fCmd;

    lpobj->aNetName     = DuplicateAtom (lpobjsrc->aNetName);
    lpobj->cDrive       = lpobjsrc->cDrive;
    lpobj->dwNetInfo    = lpobjsrc->dwNetInfo;

    if (lpobjsrc->htargetDevice)
        lpobj->htargetDevice = DuplicateGlobal (lpobjsrc->htargetDevice,
                                    GMEM_MOVEABLE);

    if (lpobjsrc->head.ctype == CT_EMBEDDED) {
        if (lpobjsrc->hnative) {
            if (!(lpobj->hnative = DuplicateGlobal (lpobjsrc->hnative,
                                        GMEM_MOVEABLE)))
                goto errRtn;
        }

        if (lpobjsrc->hdocDimensions)
            lpobj->hdocDimensions = DuplicateGlobal (lpobjsrc->hdocDimensions,
                                            GMEM_MOVEABLE);
        if (lpobjsrc->hlogpal)
            lpobj->hlogpal = DuplicateGlobal (lpobjsrc->hlogpal,
                                            GMEM_MOVEABLE);
        SetEmbeddedTopic (lpobj);
    }
    else {
        lpobj->bOldLink     = lpobjsrc->bOldLink;
        lpobj->optUpdate    = lpobjsrc->optUpdate;
    }

    retval = OLE_OK;
    // if picture is needed clone the picture object.
    if ((!lpobjsrc->lpobjPict) ||
         ((retval = (*lpobjsrc->lpobjPict->lpvtbl->Clone)(lpobjsrc->lpobjPict,
                                    lpclient, lhclientdoc, lpobjname,
                                    (LPOLEOBJECT FAR *)&lpobj->lpobjPict))
                    == OLE_OK)) {
        SetExtents (lpobj);
        *lplpoleobj = (LPOLEOBJECT)lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    }

    return retval;

errRtn:

    // This oledelete should not result in any async communication.
    if (lpobj)
        OleDelete ((LPOLEOBJECT)lpobj);

    return retval;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopyFromLink (lpoleobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Creates an embedded object from a lonked object. If the linked object
//  is not activated, then launches the server, gets the native data and
//  unlaunches the server. All these operations are done silently.
//
//  Arguments:
//
//      lpoleobjsrc:    ptr to the src object.
//      lpclient:       client callback handle
//      lhclientdoc:    doc handle
//      lpobjname:      object name
//      lplpobj:        holder for returning object.
//
//  Returns:
//      OLE_OK             : successful
//      OLE_ERROR_...      : error
//      OLE_WAITF_FOR_RELEASE : if DDE transcation is queued
//
//  Note: Could result in asynchronous operation if there is any
//        DDE operaion involved in getting any data from the server.
//
//        Also, If there is any error in getting the native data, the
//        client is expected delete the object after the OLE_RELEASE
//        call back
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopyFromLink (
    LPOLEOBJECT         lpoleobjsrc,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    OLE_LPCSTR          lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){

    LPOBJECT_LE    lpobjsrc = (LPOBJECT_LE)lpoleobjsrc;
    LPOBJECT_LE    lpobj;
    int            retval;


    *lplpoleobj = (LPOLEOBJECT)NULL;
    PROBE_OLDLINK (lpobjsrc);
    if (lpobjsrc->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;

    PROBE_ASYNC (lpobjsrc);
    PROBE_SVRCLOSING(lpobjsrc);

    if ((retval = LeClone ((LPOLEOBJECT)lpobjsrc, lpclient, lhclientdoc, lpobjname,
                    (LPOLEOBJECT FAR *)&lpobj)) != OLE_OK)
        return retval;


    // we successfully cloned the object. if picture object has native data
    // then grab it and put it in LE object. otherwise activate and get native
    // data also.

    if (lpobj->lpobjPict
            && (*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, 0) == cfNative){
        // Now we know that the picture object is of native format, and it
        // means that it is a generic object. So grab the handle to native
        // data and put it in LE object.

        lpobj->hnative = ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData;
        ((LPOBJECT_GEN) (lpobj->lpobjPict))->hData = (HANDLE)NULL;
        (*lpobj->lpobjPict->lpvtbl->Delete) (lpobj->lpobjPict);
        lpobj->lpobjPict = (LPOLEOBJECT)NULL;
        SetEmbeddedTopic (lpobj);
        *lplpoleobj = (LPOLEOBJECT)lpobj;
        return OLE_OK;
    } else {

        // if necessary launch, get native data and unlaunch the app.
        lpobj->fCmd = LN_LNKACT | ACT_REQUEST | ACT_NATIVE | (QueryOpen(lpobjsrc) ? ACT_TERMDOC : ACT_UNLAUNCH);
        InitAsyncCmd (lpobj, OLE_COPYFROMLNK, LNKOPENUPDATE);
        if ((retval = LnkOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            LeRelease ((LPOLEOBJECT)lpobj);
        else
            *lplpoleobj = (LPOLEOBJECT)lpobj;

        return retval;

        // we will be changing the topic in end conversation.
    }
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeEqual (lpoleobj1, lpoleobj2)
//
//  Checks whethere two objects are equal. Checks for equality
//  of links, native data and picture data.
//
//  Arguments:
//
//      lpoleobj1:      first object
//      lpoleobj2:      second object
//
//  Returns:
//      OLE_OK              : equal
//      OLE_ERROR_NOT_EQUAL : if not equal
//      OLE_ERROR_.....     : any errors
//
//  Note: If any of the objects are connectd to the servers, leequal operaion
//        may not make much sense because the data might be changing from the
//        the server
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_LE lpobj1 = (LPOBJECT_LE)lpoleobj1;
    LPOBJECT_LE lpobj2 = (LPOBJECT_LE)lpoleobj2;

    if (lpobj1->app != lpobj2->app)
        return OLE_ERROR_NOT_EQUAL;

    // type of the objects is same. Otherwise this routine won't be called
    if (lpobj1->head.ctype == CT_LINK) {
        if (AreTopicsEqual (lpobj1, lpobj2) && (lpobj1->item == lpobj2->item))
            return OLE_OK;

        return OLE_ERROR_NOT_EQUAL;
    }
    else {
        ASSERT (lpobj1->head.ctype == CT_EMBEDDED, "Invalid ctype in LeEqual")

        if (lpobj1->item != lpobj2->item)
            return OLE_ERROR_NOT_EQUAL;

        if (CmpGlobals (lpobj1->hnative, lpobj2->hnative))
            return OLE_OK;
        else
            return OLE_ERROR_NOT_EQUAL;
    }

    //### we may have to compare the picture data also
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeCopy (lpoleobj)
//
//  Copies the object to the clipboard. Even for linked objects
//  we do not render the objectlink. It is up to the client app
//  to render object link
//
//  Arguments:
//
//      lpoleobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    HANDLE      hlink    = (HANDLE)NULL;
    HANDLE      hnative  = (HANDLE)NULL;

    PROBE_OLDLINK (lpobj);
    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);

    if (lpobj->head.ctype == CT_EMBEDDED){
        if (!(hnative = DuplicateGlobal (lpobj->hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
        SetClipboardData (cfNative, hnative);
    }

    hlink = GetLink (lpobj);
    if (!(hlink = DuplicateGlobal (hlink, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;
    SetClipboardData (cfOwnerLink, hlink);

    // copy network name if it exists
    if (lpobj->head.ctype == CT_LINK  && lpobj->aNetName) {
        HANDLE hNetName;

        if (hNetName = GetNetNameHandle (lpobj))
            SetClipboardData (cfNetworkName, hNetName);
    }

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->CopyToClipboard)(lpobj->lpobjPict);

    return OLE_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeQueryBounds (lpoleobj, lpRc)
//
//  Returns the bounding rectangle of the object. Returns topleft
//  as zero always and the units are himetric units.
//
//  Arguments:
//
//      lpoleobj:      object handle
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_.....     : any errors
//
//  Note: Library does not open the clipboard. Client is supposed to
//        open the librray before this call is made
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL LeQueryBounds (
    LPOLEOBJECT    lpoleobj,
    LPRECT         lpRc
){
    LPOBJECT_LE    lpobj = (LPOBJECT_LE)lpoleobj;
    Puts("LeQueryBounds");

    // MM_HIMETRIC units

    lpRc->left     =  0;
    lpRc->top      =  0;
    lpRc->right    =  (int) lpobj->head.cx;
    lpRc->bottom   =  (int) lpobj->head.cy;

    if (lpRc->right || lpRc->bottom)
        return OLE_OK;

    if (!lpobj->lpobjPict)
        return OLE_ERROR_BLANK;

    return (*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict, lpRc);
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeDraw (lpoleobj, hdc, lprc, lpWrc, hdcTarget)
//
//  Draws the object. Calls the picture object for drawing the object
//
//
//  Arguments:
//
//       lpoleobj:    source object
//       hdc:         handle to dest dc. Could be metafile dc
//       lprc:        rectangle into which the object should be drawn
//                    should be in himetric units and topleft
//                    could be nonzero.
//       hdctarget:   Target dc for which the object should be drawn
//                    (Ex: Draw metafile on the dest dc using the attributes
//                         of traget dc).
//
//  Returns:
//      OLE_OK              : successful
//      OLE_ERROR_BLANK     : no picture
//
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeDraw (
    LPOLEOBJECT         lpoleobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->Draw) (lpobj->lpobjPict,
                                        hdc, lprc, lpWrc, hdcTarget);
    return OLE_ERROR_BLANK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  OLECLIPFORMAT FARINTERNAL LeEnumFormat (lpoleobj, cfFormat)
//
//  Enumerates the object formats.
//
//
//  Arguments:
//
//       lpoleobj      :  source object
//       cfFormat   :  ref fprmat
//
//  Returns:
//      NULL        :  no more formats or if we do not understand the
//                     given format.
//
//  Note: Even if the object is connected, we do not enumerate all the formats
//        the server can render. Server protocol can render the format list
//        only on system channel. Object can be connected only on the doc
//        channel
//
//////////////////////////////////////////////////////////////////////////////

OLECLIPFORMAT FARINTERNAL LeEnumFormat (
   LPOLEOBJECT    lpoleobj,
   OLECLIPFORMAT  cfFormat
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    Puts("LeEnumFormat");

    ASSERT((lpobj->head.ctype == CT_LINK)||(lpobj->head.ctype == CT_EMBEDDED),
        "Invalid Object Type");

    // switch is not used because case won't take variable argument
    if (cfFormat == (OLECLIPFORMAT)NULL) {
        if (lpobj->head.ctype == CT_EMBEDDED)
            return cfNative;
        else
            return (lpobj->bOldLink ? cfLink : cfObjectLink);
    }

    if (cfFormat == cfNative) {
        if (lpobj->head.ctype == CT_EMBEDDED)
            return cfOwnerLink;
        else
            return 0;
    }

    if (cfFormat == cfObjectLink) {
        if (lpobj->aNetName)
            return cfNetworkName;
        else
            cfFormat = (OLECLIPFORMAT)NULL;
    }
    else if  (cfFormat == cfOwnerLink || cfFormat == cfLink
                        || cfFormat == cfNetworkName)
        cfFormat = (OLECLIPFORMAT)NULL;

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, cfFormat);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeRequestData (lpoleobj, cfFormat)
//
//  Requests data from the server for a given format, if the server
//  is connected. If the server is not connected returns error.
//
//
//  Arguments:
//
//       lpoleobj:    source object
//       cfFormat:    ref fprmat
//
//  Returns:
//       OLE_WAIT_FOR_RELEASE : If the data request data is sent to
//                              the server.
//       OLE_ERROR_NOT_OPEN   : Server is not open for data
//
//  Note: If the server is ready, sends request to the server. When the
//        the data comes back from the server OLE_DATA_READY is sent in
//        the callback and the client can use Getdata to get the data.
//
//
//////////////////////////////////////////////////////////////////////////////



OLESTATUS FARINTERNAL LeRequestData (
   LPOLEOBJECT     lpoleobj,
   OLECLIPFORMAT   cfFormat
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // Assumes all the creates are in order
    PROBE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!QueryOpen (lpobj))
        return  OLE_ERROR_NOT_OPEN;

    if (cfFormat == cfOwnerLink || cfFormat == cfObjectLink)
        return OLE_ERROR_FORMAT;

    if (!(cfFormat == cfNative && lpobj->head.ctype == CT_EMBEDDED)
            && (cfFormat != (OLECLIPFORMAT) GetPictType (lpobj))) {
        DeleteExtraData (lpobj);
        lpobj->cfExtra = cfFormat;
    }

    InitAsyncCmd (lpobj, OLE_REQUESTDATA, REQUESTDATA);
    lpobj->pDocEdit->bCallLater = FALSE;
    return RequestData(lpobj, cfFormat);
}


OLESTATUS  RequestData (
   LPOBJECT_LE     lpobj,
   OLECLIPFORMAT   cfFormat
){
    switch (lpobj->subRtn) {

        case 0:
            RequestOn (lpobj, cfFormat);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            ASSERT (TRUE, "unexpected step in Requestdata");
            return OLE_ERROR_GENERIC;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//
//  OLESTATUS FARINTERNAL LeGetData (lpoleobj, cfFormat, lphandle)
//
//  Returns the data handle for a given format
//
//  Arguments:
//
//       lpoleobj:    source object
//       cfFormat:    ref fprmat
//       lphandle:    handle return
//
//  Returns:
//      NULL                : no more formats or if we do not understand the
//                            given format.
//
//  Note: Even if the object is connected, we do not get the data from the
//        server. Getdata can not be used for getting data in any other
//        format other than the formats available with the object on
//        the client side.
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeGetData (
    LPOLEOBJECT     lpoleobj,
    OLECLIPFORMAT   cfFormat,
    LPHANDLE        lphandle
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // Assumes all the creates are in order
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);

    *lphandle = (HANDLE)NULL;

    // The assumption made here is that the native data can be in either
    // LE object or picture object.
    if ((cfFormat == cfNative) && (lpobj->hnative)) {
        ASSERT ((lpobj->head.ctype == CT_EMBEDDED) || (!lpobj->lpobjPict) ||
            ((*lpobj->lpobjPict->lpvtbl->EnumFormats) (lpobj->lpobjPict, NULL)
                        != cfNative), "Native data at wrong Place");
        *lphandle = lpobj->hnative;
        return OLE_OK;
    }

    if (cfFormat == cfOwnerLink && lpobj->head.ctype == CT_EMBEDDED) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if ((cfFormat == cfObjectLink || cfFormat == cfLink) &&
            lpobj->head.ctype == CT_LINK) {
        if (*lphandle = GetLink (lpobj))
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if (cfFormat == cfNetworkName) {
        if (lpobj->aNetName && (*lphandle = GetNetNameHandle (lpobj)))
            return OLE_WARN_DELETE_DATA;

        return OLE_ERROR_BLANK;
    }

    if (cfFormat == (OLECLIPFORMAT)lpobj->cfExtra) {
        if (*lphandle = lpobj->hextraData)
            return OLE_OK;

        return OLE_ERROR_BLANK;
    }

    if (!lpobj->lpobjPict && cfFormat)
        return OLE_ERROR_FORMAT;

    return (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict, cfFormat, lphandle);
}




OLESTATUS FARINTERNAL LeQueryOutOfDate (LPOLEOBJECT lpoleobj)
{
    UNREFERENCED_PARAMETER(lpoleobj);

    return OLE_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL LeObjectConvert (lpoleobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
//
//  Converts a given  linked/embedded object to static object.
//
//  Arguments:
//          lpoleobj   : source object
//          lpprotocol : protocol
//          lpclient   : client callback for the new object
//          lhclientdoc: client doc
//          lpobjname  : object name
//          lplpoleobj : object return
//
//
//  Returns:
//      OLE_OK          :  successful
//      OLE_ERROR_....  :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeObjectConvert (
    LPOLEOBJECT         lpoleobj,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobj
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS   retVal;

    PROBE_ASYNC (lpobj);

    *lplpoleobj = (LPOLEOBJECT)NULL;

    if (lstrcmp (lpprotocol, PROTOCOL_STATIC))
        return OLE_ERROR_PROTOCOL;

    if (!lpobj->lpobjPict ||
            ((*lpobj->lpobjPict->lpvtbl->QueryType) (lpobj->lpobjPict, NULL)
                    == OLE_ERROR_GENERIC)) {
        // Either no picture object or non-standard picture object.
        // Create a metafile Object.

        HDC             hMetaDC;
        RECT            rc;
        HANDLE          hMF = (HANDLE)NULL, hmfp = (HANDLE)NULL;
        LPMETAFILEPICT  lpmfp;

        OleQueryBounds ((LPOLEOBJECT) lpobj, &rc);
        if (!(hMetaDC = CreateMetaFile (NULL)))
            goto Cleanup;

        MSetWindowOrg (hMetaDC, rc.left, rc.top);
        MSetWindowExt (hMetaDC, rc.right - rc.left, rc.bottom - rc.top);
        retVal = OleDraw ((LPOLEOBJECT) lpobj, hMetaDC, &rc, &rc, NULL);
        hMF = CloseMetaFile (hMetaDC);
        if ((retVal != OLE_OK) ||  !hMF)
            goto Cleanup;

        if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof (METAFILEPICT))))
            goto Cleanup;

        if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp)))
            goto Cleanup;

        lpmfp->hMF  = hMF;
        lpmfp->mm   = MM_ANISOTROPIC;
        lpmfp->xExt = rc.right - rc.left;
        lpmfp->yExt = rc.top - rc.bottom;
        GlobalUnlock (hmfp);

        if (*lplpoleobj = (LPOLEOBJECT) MfCreateObject (hmfp, lpclient, TRUE,
                                        lhclientdoc, lpobjname, CT_STATIC))
            return OLE_OK;

Cleanup:
        if (hMF)
            DeleteMetaFile (hMF);

        if (hmfp)
            GlobalFree (hmfp);

        return OLE_ERROR_MEMORY;
    }


    // Picture object is one of the standard objects
    if ((retVal = (*lpobj->lpobjPict->lpvtbl->Clone) (lpobj->lpobjPict,
                                lpclient, lhclientdoc,
                                lpobjname, lplpoleobj)) == OLE_OK) {
        (*lplpoleobj)->ctype = CT_STATIC;
        DocAddObject ((LPCLIENTDOC) lhclientdoc, *lplpoleobj, lpobjname);
    }

    return retVal;
}



// internal method used for changing picture/native data
OLESTATUS FARINTERNAL LeChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hnative,
    LPOLECLIENT     lpoleclient,
    BOOL            fDelete
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    UNREFERENCED_PARAMETER(lpoleclient);

    if (!fDelete) {
        if (!(hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }

    // In case of a CopyFromLink, eventhough the object type is CT_LINK, the
    // native data should go to LE object rather than the picture object, as
    // we are going to change the object type to embedded after the required
    // data is recieved.

    if ((lpobj->head.ctype == CT_LINK)
            && (lpobj->asyncCmd != OLE_COPYFROMLNK)
            && (lpobj->asyncCmd != OLE_CREATEFROMFILE)) {
        if (lpobj->lpobjPict)
            return  (*lpobj->lpobjPict->lpvtbl->SetData)
                            (lpobj->lpobjPict, cfNative, hnative);
    }
    else { // It must be embedded.
        if (lpobj->hnative)
            GlobalFree (lpobj->hnative);
        lpobj->hnative = hnative;
        return OLE_OK;
    }

    GlobalFree(hnative);
    return OLE_ERROR_BLANK;
}



////////////////////////////////////////////////////////////////////////////////
//
//  LPOBJECT_LE FARINTERNAL LeCreateBlank (lhclientdoc, lpobjname, ctype)
//
//  Create a blank object. Global block is used for the object and it is
//  locked once sucessful. Unlocking is done only while deletion. Object
//  is added to the corresponding doc.
//
//  'LE' signature is used for object validation.
//
//  Arguments:
//      lhclientdoc     :  client doc handle
//      lpobjname       :  object name
//      ctype           :  type of object to be created
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

LPOBJECT_LE FARINTERNAL LeCreateBlank (
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        ctype
){
    HOBJECT        hobj;
    LPOBJECT_LE    lpobj;

    if (!(ctype == CT_LINK || ctype == CT_EMBEDDED || ctype == CT_OLDLINK))
        return NULL;

    if (!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,
                        sizeof (OBJECT_LE))))
        return NULL;

    if (!(lpobj = (LPOBJECT_LE) GlobalLock (hobj))) {
        GlobalFree (hobj);
        return NULL;
    }

    if (ctype == CT_OLDLINK) {
        ctype = CT_LINK;
        lpobj->bOldLink = TRUE;
    }

    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';
    lpobj->head.ctype    = ctype;
    lpobj->head.iTable   = INVALID_INDEX;

    lpobj->head.lpvtbl  = (LPOLEOBJECTVTBL)&vtblLE;

    if (ctype == CT_LINK){
        lpobj->optUpdate = oleupdate_always;

    }else {
        lpobj->optUpdate = oleupdate_onclose;
    }
    lpobj->head.hobj = hobj;
    DocAddObject ((LPCLIENTDOC) lhclientdoc, (LPOLEOBJECT) lpobj, lpobjname);
    return lpobj;
}


void FARINTERNAL SetExtents (LPOBJECT_LE lpobj)
{
    RECT    rc = {0, 0, 0, 0};

    if (lpobj->lpobjPict) {
        if ((*lpobj->lpobjPict->lpvtbl->QueryBounds) (lpobj->lpobjPict,
                                        (LPRECT)&rc) == OLE_OK) {
            // Bounds are in MM_HIMETRIC units
            lpobj->head.cx = (LONG) (rc.right - rc.left);
            lpobj->head.cy = (LONG) (rc.bottom - rc.top);
        }
        return;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FARINTERNAL  LeSaveToStream (lpoleobj, lpstream)
//
//  Save the object to the stream. Uses the stream functions provided
//  in the lpclient.
//
//  Format: (!!! Document the fomrat here).
//
//
//
//  Arguments:
//      lpoleobj - pointer to ole object
//      lpstream - pointer to stream
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL  LeSaveToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD       dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_LE lpobj     = (LPOBJECT_LE)lpoleobj;
//    PROBE_OBJECT_BLANK(lpobj);

    PROBE_CREATE_ASYNC(lpobj);

    if (lpobj->head.ctype == CT_LINK && lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (lpobj->bOldLink)
        lpobj->head.ctype = CT_OLDLINK;

    return LeStreamWrite (lpstream, lpobj);
}



////////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS  FARINTERNAL  LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, ctype, aClass, cfFormat)
//
//  Create an object, loading the object from the stream.
//
//  Arguments:
//      lpstream            : stream table
//      lpclient            : client callback table
//      lhclientdoc         : Doc handle foe which the object should be created
//      lpobjname           : Object name
//      lplpoleobject       : object return
//      ctype               : Type of object
//      aClass              : class atom
//      cfFormat            : render format
//
//  Returns:
//      LPOBJECT        :  successful
//      NULL            :  any errors
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS  FARINTERNAL  LeLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                ctype,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)NULL;
    OLESTATUS   retval = OLE_ERROR_STREAM;
    LONG        type;   // this not same as ctype
    char        chVerb [80];

    *lplpoleobject = (LPOLEOBJECT)NULL;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, ctype)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    lpobj->app = aClass;
    // if the entry is present, then it is
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 80);

    if (LeStreamRead (lpstream, lpobj) == OLE_OK) {

        // Get exe name from aClass and set it as aServer
        SetExeAtom (lpobj);
        if (!GetBytes (lpstream, (LPSTR) &dwVerFromFile, sizeof(LONG))) {
            if (!GetBytes (lpstream, (LPSTR) &type, sizeof(LONG))) {
                if (type == CT_NULL)
                    retval = OLE_OK;
                else if (aClass = GetAtomFromStream (lpstream)) {
                    retval = DefLoadFromStream (lpstream, NULL, lpclient,
                                        lhclientdoc, lpobjname,
                                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict,
                                        CT_PICTURE, aClass, cfFormat);
                }
            }
        }

        if (retval == OLE_OK) {
            SetExtents (lpobj);
            *lplpoleobject = (LPOLEOBJECT) lpobj;
            if (lpobj->lpobjPict)
                lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;

            if ((lpobj->head.ctype != CT_LINK)
                    || (!InitDocConv (lpobj, !POPUP_NETDLG))
                    || (lpobj->optUpdate >= oleupdate_oncall))
                return OLE_OK;

            lpobj->fCmd = ACT_ADVISE;

            // If it's auto update, then get the latest data.
            if (lpobj->optUpdate == oleupdate_always)
                lpobj->fCmd |= ACT_REQUEST;

            FarInitAsyncCmd (lpobj, OLE_LOADFROMSTREAM, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);
        }
    }

    // This delete will not run into async command. We did not even
    // even connect.
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



//

OLESTATUS INTERNAL LeStreamRead (
    LPOLESTREAM lpstream,
    LPOBJECT_LE lpobj
){
    DWORD          dwBytes;
    LPSTR          lpstr;
    OLESTATUS      retval = OLE_OK;

    if (!(lpobj->topic = GetAtomFromStream(lpstream))
            && (lpobj->head.ctype != CT_EMBEDDED))
        return OLE_ERROR_STREAM;

    // !!! This atom could be NULL. How do we distinguish the
    // error case

    lpobj->item = GetAtomFromStream(lpstream);

    if (lpobj->head.ctype == CT_EMBEDDED)  {
        if (GetBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (!(lpobj->hnative = GlobalAlloc (GMEM_MOVEABLE, dwBytes)))
            return OLE_ERROR_MEMORY;
        else if (!(lpstr = GlobalLock (lpobj->hnative))) {
            GlobalFree (lpobj->hnative);
            return OLE_ERROR_MEMORY;
        }
        else {
            if (GetBytes(lpstream, lpstr, dwBytes))
                retval = OLE_ERROR_STREAM;
            GlobalUnlock (lpobj->hnative);
        }

        if (retval == OLE_OK)
            SetEmbeddedTopic (lpobj);
    }
    else {
        if (lpobj->aNetName = GetAtomFromStream (lpstream)) {
            if (HIWORD(dwVerFromFile) == OS_MAC) {
                // if it is a mac file this field will have "ZONE:MACHINE:"
                // string. Lets prepend this to the topic, so that server
                // app or user can fix the string

                ATOM    aTemp;

                aTemp = wAtomCat (lpobj->aNetName, lpobj->topic);
                GlobalDeleteAtom (lpobj->aNetName);
                lpobj->aNetName = (ATOM)0;
                GlobalDeleteAtom (lpobj->topic);
                lpobj->topic = aTemp;
            }
            else
                SetNetDrive (lpobj);
        }

        if (HIWORD(dwVerFromFile) != OS_MAC) {
            if (GetBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
                return OLE_ERROR_STREAM;
        }

        if (GetBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    return retval;

}



OLESTATUS INTERNAL LeStreamWrite (
    LPOLESTREAM lpstream,
    LPOBJECT_LE lpobj
){
    DWORD   dwFileVer = GetFileVersion((LPOLEOBJECT)lpobj);
    LPSTR   lpstr;
    DWORD   dwBytes   = 0L;
    LONG    nullType  = CT_NULL;
    int     error;

    if (PutAtomIntoStream(lpstream, lpobj->app))
        return OLE_ERROR_STREAM;

    if (lpobj->head.ctype == CT_EMBEDDED) {
        // we set the topic at load time, no point in saving it
        if (PutBytes (lpstream, (LPSTR) &dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->topic))
            return OLE_ERROR_STREAM;
    }

#ifdef OLD
    if (PutAtomIntoStream(lpstream, lpobj->topic))
        return OLE_ERROR_STREAM;
#endif

    if (PutAtomIntoStream(lpstream, lpobj->item))
        return OLE_ERROR_STREAM;

    // !!! deal with objects > 64k

    if (lpobj->head.ctype == CT_EMBEDDED) {

        if (!lpobj->hnative)
            return OLE_ERROR_BLANK;

        // assumption low bytes are first
        dwBytes = (DWORD)GlobalSize (lpobj->hnative);

        if (PutBytes (lpstream, (LPSTR)&dwBytes, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (!(lpstr = GlobalLock (lpobj->hnative)))
            return OLE_ERROR_MEMORY;

        error = PutBytes (lpstream, lpstr, dwBytes);
        GlobalUnlock (lpobj->hnative);

        if (error)
            return OLE_ERROR_STREAM;
    }
    else {
        if (PutAtomIntoStream(lpstream, lpobj->aNetName))
            return OLE_ERROR_STREAM;

        if (PutBytes (lpstream, (LPSTR) &lpobj->dwNetInfo, sizeof(LONG)))
            return OLE_ERROR_STREAM;

        if (PutBytes (lpstream, (LPSTR) &lpobj->optUpdate, sizeof(LONG)))
            return OLE_ERROR_STREAM;
    }

    if (lpobj->lpobjPict)
        return (*lpobj->lpobjPict->lpvtbl->SaveToStream) (lpobj->lpobjPict,
                                                    lpstream);

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &nullType, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    return OLE_OK;
}


/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL LeQueryType (lpobj, lptype)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL LeQueryType (
    LPOLEOBJECT lpoleobj,
    LPLONG      lptype
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    Puts("LeQueryType");

    if ((lpobj->head.ctype == CT_EMBEDDED)
            || (lpobj->asyncCmd == OLE_COPYFROMLNK)
            || (lpobj->asyncCmd == OLE_CREATEFROMFILE))
        *lptype = CT_EMBEDDED;
    else if ((lpobj->head.ctype == CT_LINK)
                || (lpobj->head.ctype == CT_OLDLINK))
        *lptype = CT_LINK;
    else
        return OLE_ERROR_OBJECT;

    return OLE_OK;
}



// ContextCallBack: internal function. Calls callback function of <hobj>
// with flags.

int FARINTERNAL ContextCallBack (
    LPOLEOBJECT         lpobj,
    OLE_NOTIFICATION    flags
){
    LPOLECLIENT     lpclient;

    Puts("ContextCallBack");

    if (!FarCheckObject(lpobj))
        return FALSE;

    if (!(lpclient = lpobj->lpclient))
        return FALSE;

    ASSERT (lpclient->lpvtbl->CallBack, "Client Callback ptr is NULL");

    return ((*lpclient->lpvtbl->CallBack) (lpclient, flags, lpobj));
}


void FARINTERNAL DeleteExtraData (LPOBJECT_LE lpobj)
{
    if (lpobj->hextraData == (HANDLE)NULL)
        return;

    switch (lpobj->cfExtra) {
        case CF_BITMAP:
            DeleteObject (lpobj->hextraData);
            break;

        case CF_METAFILEPICT:
        {
            LPMETAFILEPICT  lpmfp;

            if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (lpobj->hextraData)))
                break;

            DeleteMetaFile (lpmfp->hMF);
            GlobalUnlock (lpobj->hextraData);
            GlobalFree (lpobj->hextraData);
            break;
        }

        default:
            GlobalFree (lpobj->hextraData);
    }

    lpobj->hextraData = (HANDLE)NULL;
}


void   INTERNAL DeleteObjectAtoms(LPOBJECT_LE lpobj)
{
    if (lpobj->app) {
        GlobalDeleteAtom (lpobj->app);
        lpobj->app = (ATOM)0;
    }

    if (lpobj->topic) {
        GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = (ATOM)0;
    }

    if (lpobj->item) {
        GlobalDeleteAtom (lpobj->item);
        lpobj->item  = (ATOM)0;
    }

    if (lpobj->aServer) {
        GlobalDeleteAtom (lpobj->aServer);
        lpobj->aServer = (ATOM)0;
    }

    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = (ATOM)0;
    }
}


// LeGetUpdateOptions: Gets the update options.

OLESTATUS   FARINTERNAL LeGetUpdateOptions (
    LPOLEOBJECT       lpoleobj,
    OLEOPT_UPDATE FAR *lpOptions
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_OBJECT;

    *lpOptions = lpobj->optUpdate;
    return OLE_OK;
}




OLESTATUS FARINTERNAL  LnkPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    OLECLIPFORMAT       sfFormat
){
    LPOBJECT_LE lpobj  = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD
    if (!bWLO) {
        // we are not running under WLO
        if (!(hInfo = GetClipboardData (sfFormat))) {
            if (hInfo = GetClipboardData (cfLink))
                lpobj->bOldLink = TRUE;
        }
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!IsClipboardFormatAvailable (sfFormat))
        lpobj->bOldLink = TRUE;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    if ((retval = SetNetName(lpobj)) != OLE_OK) {
        // see whether network name is on the clipboard and try to use it
        HANDLE  hNetName;
        LPSTR   lpNetName;

        if (!IsClipboardFormatAvailable (cfNetworkName))
            goto errRtn;

        if (!(hNetName = GetClipboardData (cfNetworkName)))
            goto errRtn;

        if (!(lpNetName = GlobalLock (hNetName)))
            goto errRtn;

        GlobalUnlock (hNetName);
        if (!(lpobj->aNetName = GlobalAddAtom (lpNetName)))
            goto errRtn;

        SetNetDrive (lpobj);
    }

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname,
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);

    if (retval == OLE_OK) {
        SetExtents (lpobj);
                // why do we have to update the link, do we show it?

        // Reconnect if we could and advise for updates
        *lplpoleobject = (LPOLEOBJECT)lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;

        if (!InitDocConv (lpobj, !POPUP_NETDLG))
             return OLE_OK;             // document is not loaded , it is OK.

        lpobj->fCmd = ACT_ADVISE | ACT_REQUEST;
        FarInitAsyncCmd (lpobj, OLE_LNKPASTE, LNKOPENUPDATE);
        return LnkOpenUpdate (lpobj);

    }
    else {
errRtn:
        if (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

    return retval;
}



// !!! EmbPaste and LnkPaste Can be combined
OLESTATUS FARINTERNAL  EmbPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    LPOBJECT_LE lpobj = NULL;
    HANDLE      hnative;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    LPSTR       lpClass = NULL;

    if (!IsClipboardFormatAvailable (cfOwnerLink))
        return OLE_ERROR_CLIPBOARD;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED)))
        goto errRtn;

    lpobj->head.lpclient = lpclient;

#ifdef OLD
    if (!bWLO) {
        // we are not running under WLO
        hInfo = GetClipboardData (cfOwnerLink);
    }
#endif

    if (!hInfo)
        goto errRtn;

    if (!SetLink (lpobj, hInfo, &lpClass))
        goto errRtn;

    SetEmbeddedTopic (lpobj);

    hnative = GetClipboardData (cfNative);
    if (!(lpobj->hnative = DuplicateGlobal (hnative, GMEM_MOVEABLE)))
        goto errRtn;

    retval = CreatePictFromClip (lpclient, lhclientdoc, lpobjname,
                        (LPOLEOBJECT FAR *)&lpobj->lpobjPict, optRender,
                         cfFormat, lpClass, CT_PICTURE);

    if (retval == OLE_OK) {
        SetExtents (lpobj);
        *lplpoleobject = (LPOLEOBJECT) lpobj;
        if (lpobj->lpobjPict)
            lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    }
    else {
errRtn:
        // Note:  This oledelete should not result in any async commands.
        if  (lpobj)
            OleDelete ((LPOLEOBJECT)lpobj);
    }

#ifdef EXCEL_BUG
    // Some server apps (ex: Excel) copy picture (to clipboard) which is
    // formatted for printer DC. So, we want to update the picture if the
    // server app is running, and the it's a old server

    if ((retval == OLE_OK) && (!lpobj->bOleServer)) {
        lpobj->fCmd =  LN_EMBACT | ACT_NOLAUNCH | ACT_REQUEST | ACT_UNLAUNCH;
        FarInitAsyncCmd (lpobj, OLE_EMBPASTE, EMBOPENUPDATE);
        if ((retval = EmbOpenUpdate (lpobj)) > OLE_WAIT_FOR_RELEASE)
            return OLE_OK;
    }
#endif

    return retval;
}



BOOL INTERNAL SetLink (
    LPOBJECT_LE     lpobj,
    HANDLE          hinfo,
    LPSTR FAR *     lpLpClass
){
    LPSTR   lpinfo;
    char    chVerb[80];
    // If there exits a conversation, then terminate it.

    if (!(lpinfo = GlobalLock (hinfo)))
        return FALSE;

    *lpLpClass = lpinfo;

#if FIREWALLS
     if (lpobj->pDocEdit)
        ASSERT (!lpobj->pDocEdit->hClient, "unexpected client conv exists");
#endif

    lpobj->app = GlobalAddAtom (lpinfo);
    SetExeAtom (lpobj);
    lpobj->bOleServer = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 80);

//  lpobj->aServer = GetAppAtom (lpinfo);

    lpinfo += lstrlen (lpinfo) + 1;
    lpobj->topic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        lpobj->item = GlobalAddAtom (lpinfo);
    else
        lpobj->item = (ATOM)0;

    if (lpobj->hLink) {             // As the atoms have already changed,
        GlobalFree (lpobj->hLink);  // lpobj->hLink becomes irrelevant.
        lpobj->hLink = NULL;
    }

    if (lpinfo)
        GlobalUnlock(hinfo);

    if (!lpobj->app)
        return FALSE;

    if (!lpobj->topic && (lpobj->head.ctype == CT_LINK))
        return FALSE;

    lpobj->hLink = DuplicateGlobal (hinfo, GMEM_MOVEABLE);
    return TRUE;
}



HANDLE INTERNAL GetLink (LPOBJECT_LE lpobj)
{
    HANDLE  hLink = NULL;
    LPSTR   lpLink;
    int     len;
    WORD    size;

    if (lpobj->hLink)
        return lpobj->hLink;

    size = 4;    // three nulls and one null at the end
    size += (WORD)GlobalGetAtomLen (lpobj->app);
    size += (WORD)GlobalGetAtomLen (lpobj->topic);
    size += (WORD)GlobalGetAtomLen (lpobj->item);

    if (!(hLink = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;

    if (!(lpLink = GlobalLock (hLink))) {
        GlobalFree (hLink);
        return NULL;
    }

    len = (int) GlobalGetAtomName (lpobj->app, lpLink, size);
    lpLink += ++len;

    len = (int) GlobalGetAtomName (lpobj->topic, lpLink, (size -= (WORD)len));
    lpLink += ++len;

    if (!lpobj->item)
        *lpLink = '\0';
    else {
        len = (int) GlobalGetAtomName (lpobj->item, lpLink, size - len);
        lpLink += len;
    }

    *++lpLink = '\0';     // put another null the end
    GlobalUnlock (hLink);
    return (lpobj->hLink = hLink);

}


void FARINTERNAL SetEmbeddedTopic (LPOBJECT_LE lpobj)
{
    LPCLIENTDOC lpdoc;
    char        buf[MAX_STR];
    char        buf1[MAX_STR];
    LPSTR       lpstr, lptmp;
    int         len;

    if (lpobj->topic)
        GlobalDeleteAtom (lpobj->topic);

    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = (ATOM)0;
    }

    lpobj->cDrive       = '\0';
    lpobj->dwNetInfo    = 0;
    lpobj->head.ctype   = CT_EMBEDDED;

    lpdoc = (LPCLIENTDOC) lpobj->head.lhclientdoc;
    lpstr = (LPSTR) buf;
    lptmp = (LPSTR) buf1;
    ASSERT(lpdoc->aDoc, "lpdoc->aDoc is null");
    GlobalGetAtomName (lpdoc->aDoc, lpstr, sizeof(buf));

    // strip the path
    lpstr += (len = lstrlen(lpstr));
    while (--lpstr != (LPSTR) buf) {
        if ((*lpstr == '\\') || (*lpstr == ':')) {
            lpstr++;
            break;
        }
    }

    GlobalGetAtomName (lpdoc->aClass, lptmp, sizeof(buf1));
    lstrcat (lptmp, "%");
    lstrcat (lptmp, lpstr);
    lstrcat (lptmp, "%");
    lpstr = lptmp;
    lptmp += lstrlen (lptmp);

    if (lpobj->head.aObjName) {
        GlobalGetAtomName (lpobj->head.aObjName, lptmp, sizeof(buf)-(len+1));
    }

    if ((embStr[EMB_ID_INDEX] += 1) > '9') {
        embStr[EMB_ID_INDEX] = '0';
        if ((embStr[EMB_ID_INDEX - 1] += 1) > '9') {
            embStr[EMB_ID_INDEX - 1] = '0';
            if ((embStr[EMB_ID_INDEX - 2] += 1) > '9')
                embStr[EMB_ID_INDEX - 2] = '0';
        }
    }

    lstrcat (lptmp, embStr);

    lpobj->topic = GlobalAddAtom (lpstr);

    // Topic, item have changed, lpobj->hLink is out of date.
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
}


/////////////////////////////////////////////////////////////////////
//                                                                 //
// Routines related to the asynchronous processing.                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////

void NextAsyncCmd (
    LPOBJECT_LE lpobj,
    UINT        mainRtn
){
    lpobj->mainRtn  = mainRtn;
    lpobj->subRtn   = 0;

}

void  InitAsyncCmd (
    LPOBJECT_LE lpobj,
    UINT        cmd,
    UINT        mainRtn
){

    lpobj->asyncCmd = cmd;
    lpobj->mainErr  = OLE_OK;
    lpobj->mainRtn  = mainRtn;
    lpobj->subRtn   = 0;
    lpobj->subErr   = 0;
    lpobj->bAsync   = 0;
    lpobj->endAsync = 0;
    lpobj->errHint  = 0;

}

#ifdef WIN16
void  FARINTERNAL FarInitAsyncCmd (
   LPOBJECT_LE lpobj,
   UINT        cmd,
   UINT        mainRtn
){
    return (InitAsyncCmd(lpobj, cmd, mainRtn));
}
#endif


OLESTATUS EndAsyncCmd (LPOBJECT_LE lpobj)
{
    OLESTATUS   olderr;


    if (!lpobj->endAsync) {
        lpobj->asyncCmd = OLE_NONE;
        return OLE_OK;
    }


    // this is an asynchronous operation. Send callback with or without
    // error.

    switch (lpobj->asyncCmd) {

        case    OLE_DELETE:
            break;

        case    OLE_COPYFROMLNK:
        case    OLE_CREATEFROMFILE:
            // change the topic name to embedded.
            SetEmbeddedTopic (lpobj);
            break;

        case    OLE_LOADFROMSTREAM:
        case    OLE_LNKPASTE:
        case    OLE_RUN:
        case    OLE_SHOW:
        case    OLE_ACTIVATE:
        case    OLE_UPDATE:
        case    OLE_CLOSE:
        case    OLE_RECONNECT:
        case    OLE_CREATELINKFROMFILE:
        case    OLE_CREATEINVISIBLE:
        case    OLE_CREATE:
        case    OLE_CREATEFROMTEMPLATE:
        case    OLE_SETUPDATEOPTIONS:
        case    OLE_SERVERUNLAUNCH:
        case    OLE_SETDATA:
        case    OLE_REQUESTDATA:
        case    OLE_OTHER:
            break;

        case    OLE_EMBPASTE:
            lpobj->mainErr = OLE_OK;
            break;

        default:
            DEBUG_OUT ("unexpected maincmd", 0);
            break;

    }

    lpobj->bAsync   = FALSE;
    lpobj->endAsync = FALSE;
    lpobj->oldasyncCmd = lpobj->asyncCmd;
    olderr          = lpobj->mainErr;
    lpobj->asyncCmd = OLE_NONE;  // no async command in progress.

    if (lpobj->head.lpclient)
        ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RELEASE);

    lpobj->mainErr  = OLE_OK;
    return olderr;
}


BOOL   ProcessErr   (LPOBJECT_LE  lpobj)
{

    if (lpobj->subErr == OLE_OK)
        return FALSE;

    if (lpobj->mainErr == OLE_OK)
        lpobj->mainErr = lpobj->subErr;

    lpobj->subErr = OLE_OK;
    return TRUE;
}


void ScheduleAsyncCmd (LPOBJECT_LE  lpobj)
{

    // replacs this with direct proc jump later on.
#ifdef  FIREWALLS
    ASSERT (lpobj->bAsync, "Not an asynchronous command");
#endif
    lpobj->bAsync = FALSE;

    // if the object is active and we do pokes we go thru this path
    // !!! We may have to go thru the endasynccmd.

    if ((lpobj->asyncCmd == OLE_OTHER)
            || ((lpobj->asyncCmd == OLE_SETDATA) && !lpobj->mainRtn)) {
        lpobj->endAsync = TRUE;
        lpobj->mainErr = lpobj->subErr;
        EndAsyncCmd (lpobj);
        if (lpobj->bUnlaunchLater) {
            lpobj->bUnlaunchLater = FALSE;
            CallEmbLnkDelete(lpobj);
        }

        return;
    }

    switch (lpobj->mainRtn) {

        case EMBLNKDELETE:
            EmbLnkDelete (lpobj);
            break;

        case LNKOPENUPDATE:
            LnkOpenUpdate (lpobj);
            break;

        case DOCSHOW:
            DocShow (lpobj);
            break;


        case EMBOPENUPDATE:
            EmbOpenUpdate (lpobj);
            break;


        case EMBLNKCLOSE:
            EmbLnkClose (lpobj);
            break;

        case LNKSETUPDATEOPTIONS:
            LnkSetUpdateOptions (lpobj);
            break;

        case LNKCHANGELNK:
            LnkChangeLnk (lpobj);
            break;

        case REQUESTDATA:
            RequestData (lpobj, 0);
            break;

        default:
            DEBUG_OUT ("Unexpected asyn command", 0);
            break;
    }

    return;
}

void SetNetDrive (LPOBJECT_LE lpobj)
{
    char    buf[MAX_STR];

    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))
            && (buf[1] == ':')) {
        AnsiUpperBuff ((LPSTR) buf, 1);
        lpobj->cDrive = buf[0];
    }
}

HANDLE GetNetNameHandle (LPOBJECT_LE lpobj)
{
    HANDLE  hNetName;
    LPSTR   lpNetName;
    int     size;

    if (!(size = GlobalGetAtomLen (lpobj->aNetName)))
        return NULL;

    size++;
    if (!(hNetName = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size)))
        return NULL;

    if (lpNetName = GlobalLock (hNetName)) {
        GlobalUnlock (hNetName);
        if (GlobalGetAtomName(lpobj->aNetName, lpNetName, size))
            return hNetName;
    }

    // error case
    GlobalFree (hNetName);
    return NULL;
}

BOOL AreTopicsEqual (
    LPOBJECT_LE lpobj1,
    LPOBJECT_LE lpobj2
){
    char    buf1[MAX_STR];
    char    buf2[MAX_STR];

    if (lpobj1->aNetName != lpobj2->aNetName)
        return FALSE;

    if (!lpobj1->aNetName) {
        if (lpobj1->topic == lpobj2->topic)
            return TRUE;

        return FALSE;
    }

    if (!GlobalGetAtomName (lpobj1->topic, buf1, MAX_STR))
        return FALSE;

    if (!GlobalGetAtomName (lpobj2->topic, buf2, MAX_STR))
        return FALSE;

    if (!lstrcmpi (&buf1[1], &buf2[1]))
        return TRUE;

    return FALSE;
}

ATOM FARINTERNAL wAtomCat (
   ATOM        a1,
   ATOM        a2
){
    char    buf[MAX_STR+MAX_STR];
    LPSTR   lpBuf = (LPSTR)buf;

    if (!GlobalGetAtomName (a1, lpBuf, MAX_STR+MAX_STR))
        return (ATOM)0;

    lpBuf += lstrlen(lpBuf);

    if (!GlobalGetAtomName(a2, lpBuf, MAX_STR))
        return (ATOM)0;

    return GlobalAddAtom ((LPSTR) buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\generic.c ===
/****************************** Module Header ******************************\
* Module Name: GENERIC.C
*
* Handles all API routines for the generic sub-dll of the ole dll.
* Since the data format is unknown, all the routines are written with the
* assumption that all the relevant data is placed in a single global data
* segment. Note that this assumption is not valid for metafiles, bitmaps, and
* and there can always be some other formats with such idiosyncracies. To
* accommodate those cases the rendering dll writer should replace the relevant
* routines after the creation of the generic object. If for a given class this
* assumption (about data format) is valid then the dll writer need to replace
* only the Draw and QueryBounds functions.
*
* Created: November-1990
*
* Copyright (c) 1990, 1991 Microsoft Corporation
*
* History:
*
*  Srinik, Raor  (11/05/90) Designed, coded
*  Curts created NT version
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

char aMacText[4] = {'T', 'E', 'X', 'T'};
char aMacRtf[4]  = "RTF";

extern OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

#ifdef WIN16
#pragma alloc_text(_TEXT, GenSaveToStream, GenLoadFromStream, GetBytes, PutBytes, PutStrWithLen, PutAtomIntoStream, GenQueryBounds)
#endif

OLEOBJECTVTBL    vtblGEN  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        GenRelease,         // Release
        ErrShow,            // Show
        ErrPlay,            // plat
        GenGetData,         // Get the object data
        GenSetData,         // Set the object data
        ErrSetTargetDevice, //

        ErrSetBounds,       // set viewport bounds
        GenEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        GenRelease,         // delete
        ErrSetHostNames,    //

        GenSaveToStream,    // write to file
        GenClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Link

        GenEqual,           // compares the given objects for data equality

        GenCopy,            // copy to clip

        GenDraw,            // draw the object

        ErrActivate,        // open
        ErrExecute,         // excute
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,          // Change Object name
        ObjQueryName,       // Get current object name

        GenQueryType,       // Object type
        GenQueryBounds,     // QueryBounds
        ObjQuerySize,       // Find the size of the object
        ErrQueryOpen,       // Query open
        ErrQueryOutOfDate,  // query whether object is current

        ErrQueryRelease,     // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        GenChangeData      // change data of the existing object
};


OLESTATUS  FARINTERNAL GenRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_GEN lpobj = (LPOBJECT_GEN)lpoleobj;
    HOBJECT      hobj;

    if (lpobj->hData) {
        GlobalFree (lpobj->hData);
        lpobj->hData = NULL;
    }

    if (lpobj->aClass)
        GlobalDeleteAtom (lpobj->aClass);

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);

    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL GenSaveToStream (
    LPOLEOBJECT     lpoleobj,
    LPOLESTREAM     lpstream
){
    DWORD        dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_GEN lpobj     = (LPOBJECT_GEN)lpoleobj;
    LPSTR        lpData;
    OLESTATUS    retVal    = OLE_OK;
    DWORD        dwClipFormat = 0;
    char         formatName[MAX_STR];

    if (!lpobj->hData)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutAtomIntoStream (lpstream, lpobj->aClass))
        return OLE_ERROR_STREAM;

    if (lpobj->cfFormat < 0xC000)
        // then it is a predefined format
        dwClipFormat = lpobj->cfFormat;

    if (PutBytes (lpstream, (LPSTR) &dwClipFormat, sizeof(DWORD)))
        return OLE_ERROR_STREAM;

    if (!dwClipFormat) {
        if (!GetClipboardFormatName (lpobj->cfFormat, (LPSTR) formatName,
                        sizeof(formatName)))
            return OLE_ERROR_FORMAT;

        if (PutStrWithLen (lpstream, formatName))
            return OLE_ERROR_STREAM;
    }

    if (!lpobj->sizeBytes)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
        return OLE_ERROR_STREAM;

    if (!(lpData = GlobalLock (lpobj->hData)))
        return OLE_ERROR_MEMORY;

    if (PutBytes (lpstream, lpData, lpobj->sizeBytes))
        retVal = OLE_ERROR_STREAM;

    GlobalUnlock (lpobj->hData);
    return retVal;
}


OLESTATUS FARINTERNAL  GenClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_GEN lpobjsrc = (LPOBJECT_GEN)lpoleobjsrc;

    if (!lpobjsrc->hData)
        return OLE_ERROR_BLANK;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(*lplpoleobj = (LPOLEOBJECT)GenCreateObject (lpobjsrc->hData, lpclient,
                            FALSE, lhclientdoc,
                            (LPSTR)lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else {
        ((LPOBJECT_GEN)(*lplpoleobj))->cfFormat = lpobjsrc->cfFormat;
        ((LPOBJECT_GEN)(*lplpoleobj))->aClass = DuplicateAtom (lpobjsrc->aClass);
        return OLE_OK;
    }
}



OLESTATUS FARINTERNAL  GenEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_GEN lpobj1 = (LPOBJECT_GEN)lpoleobj1;
    LPOBJECT_GEN lpobj2 = (LPOBJECT_GEN)lpoleobj2;

    if (CmpGlobals (lpobj1->hData, lpobj2->hData))
        return OLE_OK;

    return  OLE_ERROR_NOT_EQUAL;
}



OLESTATUS FARINTERNAL GenCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_GEN lpobj = (LPOBJECT_GEN)lpoleobj;
    HANDLE  hData;

    if (!lpobj->hData)
        return OLE_ERROR_BLANK;

    if (!(hData = DuplicateGlobal (lpobj->hData, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    SetClipboardData (lpobj->cfFormat, hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    LPOBJECT_GEN    lpobj = NULL;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    HANDLE          hData;
    LPSTR           lpData;
    DWORD           dwClipFormat;
    char            formatName[MAX_STR];
    LONG            length;

    if (!(*lplpobj = (LPOLEOBJECT) (lpobj = GenCreateBlank(lhclientdoc,
                                                    lpobjname, objType,
                                                    aClass)))) {
        if (aClass)
            GlobalDeleteAtom(aClass);
        return OLE_ERROR_MEMORY;
    }

    if (GetBytes (lpstream, (LPSTR) &dwClipFormat, sizeof (DWORD)))
        goto errLoad;

    // If object is from MAC then we will keep the data intact if the data
    // format is either TEXT or RTF
    if (HIWORD(dwVerFromFile) == OS_MAC) {
        if (dwClipFormat ==  *((DWORD *) aMacText))
            lpobj->cfFormat = CF_TEXT;
        else if (dwClipFormat == *((DWORD *) aMacRtf))
            lpobj->cfFormat = (OLECLIPFORMAT)RegisterClipboardFormat ((LPSTR) "Rich Text Format");
        else
            lpobj->cfFormat = 0;
    }
    else {
        // object is created on windows
        if (!dwClipFormat) {
            // this is new file format. format name string follows
            if (GetBytes (lpstream, (LPSTR) &length, sizeof (LONG))
                    || GetBytes (lpstream, (LPSTR)formatName, length)
                    || (!(lpobj->cfFormat = (OLECLIPFORMAT)RegisterClipboardFormat ((LPSTR) formatName))))
                goto errLoad;
        }
        else if ((lpobj->cfFormat = (WORD) dwClipFormat) >= 0xc000) {
            // if format is not predefined and file format is old, then use
            // what value is passed to you through "cfFormat" argument
            lpobj->cfFormat = cfFormat;
        }
    }

    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof (DWORD)))
        goto errLoad;

    lpobj->head.lpclient = lpclient;

    retVal = OLE_ERROR_MEMORY;
    if (!(hData = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)))
        goto errLoad;

    if (!(lpData = GlobalLock (hData)))
        goto errMem;

    if (GetBytes (lpstream, lpData, lpobj->sizeBytes)) {
        retVal = OLE_ERROR_STREAM;
        GlobalUnlock (hData);
        goto errMem;
    }

    lpobj->hData = hData;
    GlobalUnlock (hData);

    // if the object is from MAC then we want delete this and create blank
    // metafile object, which draws a rectangle
    if ((HIWORD(dwVerFromFile) == OS_MAC) && !lpobj->cfFormat) {
        LPOBJECT_MF lpobjMf;

        OleDelete ((LPOLEOBJECT)lpobj);  // delete generic object

        // Now create a dummy metafile object which draws a rectangle of size
        // 1" x 1". Note that 1" = 2540 HIMETRIC units
        lpobjMf = MfCreateBlank (lhclientdoc, lpobjname, objType);
        lpobjMf->head.cx = lpobjMf->mfp.xExt = 2540;
        lpobjMf->head.cy = - (lpobjMf->mfp.yExt = 2540);
        if ((retVal = wCreateDummyMetaFile (lpobjMf, lpobjMf->mfp.xExt,
                                    lpobjMf->mfp.yExt)) != OLE_OK) {
            OleDelete ((LPOLEOBJECT) lpobjMf);
            return retVal;
        }
    }

    return OLE_OK;

errMem:
    GlobalFree (hData);

errLoad:
    OleDelete ((LPOLEOBJECT)lpobj);
    *lplpobj = NULL;
    return OLE_ERROR_STREAM;

}




LPOBJECT_GEN INTERNAL GenCreateObject (
    HANDLE      hData,
    LPOLECLIENT lpclient,
    BOOL        fDelete,
    LHCLIENTDOC lhclientdoc,
    LPCSTR      lpobjname,
    LONG        objType
){
    LPOBJECT_GEN     lpobj;

    if (!hData)
        return NULL;

    if (lpobj = GenCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType, (ATOM)0)) {
        if (GenChangeData ((LPOLEOBJECT)lpobj, hData, lpclient, fDelete) != OLE_OK) {
            GenRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewData will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL GenChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hSrcData,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_GEN lpobj = (LPOBJECT_GEN)lpoleobj;
    HANDLE      hDestData;

    if (!fDelete) {
        if (!(hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself
        if (!(hDestData = GlobalReAlloc(hSrcData,0L,GMEM_MODIFY|GMEM_SHARE))){
            hDestData = DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
            GlobalFree (hSrcData);
            if (!hDestData)
                return OLE_ERROR_MEMORY;
        }
    }

    lpobj->head.lpclient = lpclient;
    if (lpobj->hData)
        GlobalFree (lpobj->hData);
    lpobj->hData = hDestData;
    lpobj->sizeBytes = (DWORD)GlobalSize (hDestData);

    return OLE_OK;
}



LPOBJECT_GEN FARINTERNAL GenCreateBlank(
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType,
    ATOM        aClass
){
    HOBJECT         hobj;
    LPOBJECT_GEN    lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_GEN)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_GEN) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblGEN;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    lpobj->aClass           = aClass;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
            (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}


OLESTATUS FARINTERNAL GenPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LPSTR               lpClass,
    OLECLIPFORMAT       cfFormat,
    LONG                objType
){
    HANDLE  hData = NULL;

    *lplpobj = NULL;
    if (!cfFormat)
        return OLE_ERROR_FORMAT;

    if (!(hData = GetClipboardData(cfFormat)))
        return OLE_ERROR_MEMORY;

    if (!(*lplpobj = (LPOLEOBJECT) GenCreateObject (hData, lpclient,
                                        FALSE, lhclientdoc,
                                        lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    ((LPOBJECT_GEN)(*lplpobj))->cfFormat = cfFormat;
    ((LPOBJECT_GEN)(*lplpobj))->aClass = GlobalAddAtom (lpClass);
    return OLE_OK;

}



OLESTATUS FARINTERNAL GenQueryType (
    LPOLEOBJECT lpobj,
    LPLONG      lptype
){
    UNREFERENCED_PARAMETER(lpobj);
    UNREFERENCED_PARAMETER(lptype);

    return OLE_ERROR_GENERIC;;
}



OLESTATUS FARINTERNAL GenSetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    HANDLE        hData
){
    LPOBJECT_GEN  lpobj = (LPOBJECT_GEN)lpoleobj;

    if (lpobj->cfFormat != cfFormat)
        return OLE_ERROR_FORMAT;

    if (!hData)
        return OLE_ERROR_BLANK;

    GlobalFree (lpobj->hData);
    lpobj->hData = hData;
    lpobj->sizeBytes = (DWORD)GlobalSize (hData);
    return OLE_OK;
}


OLESTATUS FARINTERNAL GenGetData (
    LPOLEOBJECT     lpoleobj,
    OLECLIPFORMAT   cfFormat,
    LPHANDLE        lphandle
){
    LPOBJECT_GEN    lpobj = (LPOBJECT_GEN)lpoleobj;

    if (cfFormat != lpobj->cfFormat)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = lpobj->hData))
        return OLE_ERROR_BLANK;

    return OLE_OK;

}


OLECLIPFORMAT FARINTERNAL GenEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_GEN  lpobj = (LPOBJECT_GEN)lpoleobj;

    if (!cfFormat)
        return lpobj->cfFormat;

    return 0;
}


OLESTATUS FARINTERNAL GenQueryBounds (
    LPOLEOBJECT     lpoleobj,
    LPRECT          lpRc
){
    LPOBJECT_GEN    lpobj = (LPOBJECT_GEN)lpoleobj;

    lpRc->right     = 0;
    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->bottom    = 0;
    return OLE_ERROR_GENERIC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\main.c ===
/****************************** Module Header ******************************\
* Module Name: MAIN.C
*
* PURPOSE: WinMain, WEP and some other misc routines
*
* Created: 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik   (04/01/91)  Pulled some routines, into this, from ole.c.
*   curts    Create portable version for win16/32.
*
\***************************************************************************/

#include <windows.h>

#include "dll.h"

#ifndef WF_WLO
#define WF_WLO  0x8000
#endif

// ordinal number new win31 API IsTask
#define ORD_IsTask  320

#define NUM_DLL     30  /* space for this many DLL_ENTRYs is created on */
			/* each alloc/realloc */

OLECLIPFORMAT   cfOwnerLink     = 0;     // global variables for clip frmats
OLECLIPFORMAT   cfObjectLink    = 0;
OLECLIPFORMAT   cfLink          = 0;
OLECLIPFORMAT   cfNative        = 0;
OLECLIPFORMAT   cfBinary        = 0;
OLECLIPFORMAT   cfFileName      = 0;
OLECLIPFORMAT   cfNetworkName   = 0;

ATOM            aStdHostNames;
ATOM            aStdTargetDevice ;
ATOM            aStdDocDimensions;
ATOM            aStdDocName;
ATOM            aStdColorScheme;
ATOM            aNullArg = 0;
ATOM            aSave;
ATOM            aChange;
ATOM            aClose;
ATOM            aSystem;
ATOM            aOle;
ATOM            aClipDoc;
ATOM            aPackage;

// Used in work around for MSDraw bug
ATOM            aMSDraw;

extern LPCLIENTDOC  lpHeadDoc;
extern LPCLIENTDOC  lpTailDoc;

extern RENDER_ENTRY stdRender[];

HANDLE          hInstDLL;

/* HANDLE   hDllTable;          !!! Add this when bug in WEP is fixed */
DLL_ENTRY   lpDllTable[NUM_DLL]; //!!! change this when WEP bug is fixed
DWORD       dllTableSize;
int         iLast = 0;
int         iMax = NUM_DLL -1;
int         iUnloadableDll =  0; // index to handler than can be freed up

char        packageClass[] = "Package";

// For QuerySize() API & methods.
extern  OLESTREAMVTBL  dllStreamVtbl;
extern  CLIENTDOC      lockDoc;

#ifdef FIREWALLS
BOOL        bShowed = FALSE;
char        szDebugBuffer[80];
short       ole_flags;

void FARINTERNAL    ShowVersion (void);
void FARINTERNAL    SetOleFlags(void);
#endif

// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD reserved

DWORD  dwOleVer = 0x0901L;  // change this when we want to update dll version
			    // number

WORD   wReleaseVer = 0x0001;  // This is used while object is being saved to
			      // file. There is no need to change this value
			      // whenever we change ole dll version number

static BOOL  bLibInit = FALSE;



HANDLE  hModule;

#define MAX_HIMETRIC    0x7FFF

int     maxPixelsX = MAX_HIMETRIC;
int     maxPixelsY = MAX_HIMETRIC;
void    SetMaxPixel (void);

VOID FAR PASCAL WEP (int);

#ifdef WIN16                        // begin WIN16
BOOL    bProtMode;
BOOL    bWLO = FALSE;
WORD    wWinVer;
#pragma alloc_text(WEP_TEXT, WEP)

FARPROC lpfnIsTask = NULL;          // the API IsTask() became available from
				    // win31 onwards, hence we are trying to
				    // get it's address through GetProcAddress
#endif                              // end WIN16


//////////////////////////////////////////////////////////////////////////////
//
//  int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
//
//  The main library entry point. This routine is called when the library
//  is loaded.
//
//  Arguments:
//
//      hInst       -   dll's instance handle
//      wDataSeg    -   DS register value
//      cbHeapSize  -   heap size defined def file
//      lpszCmdLine -   command line info
//
//  Returns:
//
//      0   -   failure
//      1   -   success
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

#ifdef WIN16
int APIENTRY LibMain(
   HANDLE  hInst,
   WORD    wDataSeg,
   WORD    cbHeapSize,
   LPSTR   lpszCmdLine
#endif

#ifdef WIN32
BOOL LibMain(
   HANDLE hInst,
   ULONG Reason,
   PCONTEXT Context
#endif  // WIN32

){
    WNDCLASS  wc;
    int     i;
#ifdef WIN32
    char szDocClass[] = "OleDocWndClass" ;
    char szSrvrClass[] = "OleSrvrWndClass" ;
#endif

    Puts("LibMain");

#ifdef  FIREWALLS
    SetOleFlags();
#endif

#ifdef WIN32                        // begin WIN32
    UNREFERENCED_PARAMETER(Context);
    if (Reason == DLL_PROCESS_DETACH)
    {
	WEP(0);
   UnregisterClass (szDocClass, hInst) ;
   UnregisterClass (szSrvrClass, hInst) ;
	return TRUE;
    }
    else if (Reason != DLL_PROCESS_ATTACH)
	return TRUE;
#endif                              // end WIN32

    bLibInit  = TRUE;
    hInstDLL  = hInst;
    hModule = GetModuleHandle ("OLECLI");

#ifdef WIN16                        // begin WIN16
    bProtMode = (BOOL) (GetWinFlags() & WF_PMODE);
    bWLO      = (BOOL) (GetWinFlags() & WF_WLO);
    wWinVer   = (WORD) GetVersion();
#endif                              // end WIN16

    // REGISTER LINK FORMAT

    cfObjectLink    = (OLECLIPFORMAT)RegisterClipboardFormat("ObjectLink");
    cfLink          = (OLECLIPFORMAT)RegisterClipboardFormat("Link");
    cfOwnerLink     = (OLECLIPFORMAT)RegisterClipboardFormat("OwnerLink");
    cfNative        = (OLECLIPFORMAT)RegisterClipboardFormat("Native");
    cfBinary        = (OLECLIPFORMAT)RegisterClipboardFormat("Binary");
    cfFileName      = (OLECLIPFORMAT)RegisterClipboardFormat("FileName");
    cfNetworkName   = (OLECLIPFORMAT)RegisterClipboardFormat("NetworkName");

    if (!(cfObjectLink && cfOwnerLink && cfNative && cfLink))
	return 0;

    // SET UP OLEWNDCLASS
    wc.style        = 0;
    wc.lpfnWndProc  = DocWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG_PTR);     //we are storing longs
    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName= szDocClass;
    if (!RegisterClass(&wc))
	     return 0;

    wc.lpfnWndProc = (WNDPROC)SrvrWndProc;
    wc.lpszClassName = szSrvrClass ;

    if (!RegisterClass(&wc))
	return 0;
/*
    // !!! Add this when bug in WEP is fixed.
    // Allocate memory for DLL table
    dllTableSize = NUM_DLL * sizeof(DLL_ENTRY);
    if (!(hDllTable = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
			    dllTableSize)))
	return 0;

    if (!(lpDllTable = (DLL_ENTRY FAR *) GlobalLock (hDllTable)))
	return 0;
*/

    // !!! remove the following when WEP bug is fixed
    for (i = 0; i < NUM_DLL; i++)
	lpDllTable[i].aDll = (ATOM)0;

    // !!! BEGIN hack for Pbrush.

    lpDllTable[0].hDll                  = NULL;
    lpDllTable[0].aDll                  = GlobalAddAtom ((LPSTR) "ole");
    lpDllTable[0].Load                  = PbLoadFromStream;
    lpDllTable[0].Clip                  = PbCreateFromClip;
    lpDllTable[0].Link                  = PbCreateLinkFromClip;
    lpDllTable[0].Create                = PbCreate;
    lpDllTable[0].CreateFromTemplate    = PbCreateFromTemplate;
    lpDllTable[0].CreateFromFile        = PbCreateFromFile;
    lpDllTable[0].CreateLinkFromFile    = PbCreateLinkFromFile;
    lpDllTable[0].CreateInvisible       = PbCreateInvisible;


    // !!! END hack for pbrush

    // For ObjectSize API
    dllStream.lpstbl      = (LPOLESTREAMVTBL) &dllStreamVtbl;
    dllStream.lpstbl->Put = DllPut;

    // add the atoms required.
    aStdDocName       = GlobalAddAtom ((LPSTR)"StdDocumentName");
    aSave             = GlobalAddAtom ((LPSTR)"Save");
    aChange           = GlobalAddAtom ((LPSTR)"Change");
    aClose            = GlobalAddAtom ((LPSTR)"Close");
    aSystem           = GlobalAddAtom ((LPSTR)"System");
    aOle              = GlobalAddAtom ((LPSTR)"OLEsystem");
    aPackage          = GlobalAddAtom ((LPSTR) packageClass);

    // Used in work around for MSDraw bug
    aMSDraw           = GlobalAddAtom ((LPSTR) "MSDraw");

    // clipboard document name atom
    aClipDoc          = GlobalAddAtom ((LPSTR)"Clipboard");

    stdRender[0].aClass = GlobalAddAtom ("METAFILEPICT");
    stdRender[1].aClass = GlobalAddAtom ("DIB");
    stdRender[2].aClass = GlobalAddAtom ("BITMAP");
    stdRender[3].aClass = GlobalAddAtom ("ENHMETAFILE");

    SetMaxPixel();

#ifdef WIN16                        // begin WIN16
    if (wWinVer != 0x0003) {
	HANDLE  hModule;

	if (hModule = GetModuleHandle ("KERNEL"))
	    lpfnIsTask = GetProcAddress (hModule,
				(LPSTR) MAKELONG (ORD_IsTask, 0));
    }

    if (cbHeapSize != 0)
	UnlockData(0);
#endif                              // end WIN16

    return 1;
}



//////////////////////////////////////////////////////////////////////////////
//
//  VOID FAR PASCAL WEP (nParameter)
//
//  Called just before the library is being unloaded. Delete all the atoms
//  added by this dll and also frees up all unloaded handler dlls.
//
//  Arguments:
//
//      nParameter  -   Termination code
//
//  Returns:
//
//      none
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


VOID FAR PASCAL WEP (int nParameter)
{
    int i;


    Puts("LibExit");

#ifdef WIN32                        // begin WIN32
	UNREFERENCED_PARAMETER(nParameter);
	DEBUG_OUT ("---L&E DLL EXIT---\n",0)
#endif                              // end WIN32
    // case when the DLLs are missing

    if (!bLibInit)
	return;

#ifdef WIN16                        // begin WIN16
    if (nParameter == WEP_SYSTEM_EXIT)
	DEBUG_OUT ("---L&E DLL EXIT on system exit---",0)
    else if (nParameter == WEP_FREE_DLL)
	DEBUG_OUT ("---L&E DLL EXIT---\n",0)
    else
	return;
#endif                              // end WIN16


    // Delete atoms added by us

    for (i = 0; i < NUM_RENDER; i++) {
	if (stdRender[i].aClass)
	    GlobalDeleteAtom (stdRender[i].aClass);
    }

    if (aStdDocName)
	GlobalDeleteAtom (aStdDocName);
    if (aSave)
	GlobalDeleteAtom (aSave);
    if (aChange)
	GlobalDeleteAtom (aChange);
    if (aClose)
	GlobalDeleteAtom (aClose);
    if (aSystem)
	GlobalDeleteAtom (aSystem);
    if (aOle)
	GlobalDeleteAtom (aOle);
    if (aPackage)
	GlobalDeleteAtom (aPackage);
    if (aClipDoc)
	GlobalDeleteAtom (aClipDoc);
    if (aMSDraw)
	GlobalDeleteAtom (aMSDraw);

    // Free handler dlls if there are any still loaded. Entry 0 is used for
    // Pbrush handler which is part of this dll.


    for (i = 0; i <= iLast; i++) {
	if (lpDllTable[i].aDll)
	    GlobalDeleteAtom (lpDllTable[i].aDll);

	if (lpDllTable[i].hDll)
	    FreeLibrary (lpDllTable[i].hDll);
    }


#ifdef FIREWALLS
    ASSERT(!lpHeadDoc, "Some client doc structures are not deleted");
    ASSERT(!lockDoc.lpHeadObj, "Some servers are left in a locked state");
#endif

/* !!! Add this when bug in WEP is fixed

    if (lpDllTable)
	GlobalUnlock (hDllTable);

    if (hDllTable)
	GlobalFree (hDllTable);
*/
}


//////////////////////////////////////////////////////////////////////////////
//
//  void FARINTERNAL SetOleFlags()
//
//  Sets the debug level flags for controlling the level of debug information
//  on the comm terminal. This will be included only in the debug version.
//
//  Arguments:
//
//      none
//
//  Returns:
//
//      none
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

#ifdef  FIREWALLS

void FARINTERNAL SetOleFlags()
{

    char    buffer[80];

    if(GetProfileString ("OLE",
	"Puts","", (LPSTR)buffer, 80))
	ole_flags = DEBUG_PUTS;
    else
	ole_flags = 0;


    if(GetProfileString ("OLE",
	"DEBUG_OUT","", (LPSTR)buffer, 80))
	ole_flags |= DEBUG_DEBUG_OUT;


    if(GetProfileString ("OLE",
	"MESSAGEBOX","", (LPSTR)buffer, 80))
	ole_flags |= DEBUG_MESSAGEBOX;

}



//////////////////////////////////////////////////////////////////////////////
//
//  void FARINTERNAL ShowVersion (void)
//
//  Displays version, date, time and copyright info in client app's window.
//  Called by all the object create functions after checking the flag bShowed.
//  This will be included only in the debug version.
//
//  Arguments:
//
//      none
//
//  Returns:
//
//      none
//
//  Effects:
//
//      sets bShowed
//
//////////////////////////////////////////////////////////////////////////////

void FARINTERNAL ShowVersion ()
{

    if (!bShowed && (ole_flags & DEBUG_MESSAGEBOX)) {
	MessageBox (NULL, "\
		       VER: 1.09.000\n\
		    TIME: 00:00:00\n\
		   DATE: 02/01/1992\n\
	 Copyright (c) 1990, 1991 Microsoft Corp.\n\
		  All Rights Reserved.",
      "Ole Client Library",
      MB_OK | MB_TASKMODAL);
	bShowed = TRUE;
    }
}

#endif




int FARINTERNAL LoadDll (LPCSTR   lpClass)
{
    char        str[MAX_STR];
    char        str1[MAX_STR];
    ATOM        aDll = (ATOM)0;
    int         index;
    int         iEmpty;
    BOOL        found = FALSE;
    HANDLE      hDll;
#ifdef WIN16
    int         refcnt;
#endif
    LONG        cb = MAX_STR;

    if (!lstrcmpi (lpClass, "Pbrush"))
	return 0;

    lstrcpy (str, lpClass);
    lstrcat (str, "\\protocol\\StdFileEditing\\handler32");
    if (RegQueryValue (HKEY_CLASSES_ROOT, str, str1, &cb))
	return INVALID_INDEX;

    if (aDll = GlobalFindAtom (str1)) {
	for (index = 1; index <= iLast; index++) {
	    if (lpDllTable[index].aDll == aDll) { // Dll already loaded
		lpDllTable[index].cObj ++;

		if (index == iUnloadableDll)  {
		    // since the object count is not zero anymore, this
		    // handler can not be freed up.
		    iUnloadableDll = 0;
		}

		return index;
	    }
	}
    }

    aDll = GlobalAddAtom (str1);

    // Look for an empty entry
    for (iEmpty = 1; iEmpty <= iLast; iEmpty++) {
	if (!lpDllTable[iEmpty].aDll) {
	    found = TRUE;
	    break;
	}
    }

    if (iEmpty > iMax)
	goto errLoad;
/*
    if (!found) {// no empty entry exists create a new one if necessary.
	if (iEmpty > iMax) {
	    dllTableSize += (blockSize = NUM_DLL * sizeof(DLL_ENTRY));
	    hTable = GlobalReAlloc (hDllTable, dllTableSize,
				GMEM_MOVEABLE | GMEM_ZEROINIT);
	    if (hTable == hDllTable)
		iMax += NUM_DLL;
	    else {
		dllTableSize -= blockSize;
		iEmpty = INVALID_INDEX;
	    }
	}
    }
*/
#ifdef WIN16
    // !!! reference count of OLECLI is increasing by 2 when the handlers are
    // are loaded, looks like windows bug. Following is a temporary fix.

    refcnt = GetModuleUsage (hModule);
    hDll = LoadLibrary ((LPSTR) str1);
    refcnt = (GetModuleUsage (hModule) - refcnt);

    while (refcnt > 1) {
	FreeModule (hModule);
	refcnt--;
    }
#endif

#ifdef WIN32
    hDll = LoadLibrary ((LPSTR) str1);
#endif

    if (MAPVALUE(hDll < 32, !hDll))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Load = (_LOAD)GetProcAddress(hDll,
					  "DllLoadFromStream")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Clip = (_CLIP)GetProcAddress (hDll,
					    "DllCreateFromClip")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Link = (_LINK)GetProcAddress (hDll,
					    "DllCreateLinkFromClip")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromTemplate = (_CREATEFROMTEMPLATE)
					     GetProcAddress (hDll,
					    "DllCreateFromTemplate")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].Create = (_CREATE)GetProcAddress (hDll,
					  "DllCreate")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromFile = (_CREATEFROMFILE)GetProcAddress (hDll,
						    "DllCreateFromFile")))
	goto errLoad;

    if (!(lpDllTable[iEmpty].CreateLinkFromFile = (_CREATELINKFROMFILE)GetProcAddress (hDll,
					    "DllCreateLinkFromFile")))
	goto errLoad;

    lpDllTable[iEmpty].CreateInvisible = (_CREATEINVISIBLE)GetProcAddress (hDll,
					    "DllCreateInvisible");

    lpDllTable[iEmpty].aDll = aDll;
    lpDllTable[iEmpty].cObj = 1;
    lpDllTable[iEmpty].hDll = hDll;
    if (iEmpty > iLast)
	iLast++;
    return iEmpty;

errLoad:
    if (aDll)
	GlobalDeleteAtom (aDll);
    if (MAPVALUE(hDll >= 32, !hDll))
	FreeLibrary (hDll);
    return INVALID_INDEX;
}


// unload the the handler that can be free up (whose object count is NULL)

void FARINTERNAL UnloadDll ()
{
    if (!iUnloadableDll)
	return;

    if (iUnloadableDll == iLast)
	iLast--;

    if (lpDllTable[iUnloadableDll].aDll)
	GlobalDeleteAtom (lpDllTable[iUnloadableDll].aDll);
    lpDllTable[iUnloadableDll].aDll = (ATOM)0;
    FreeLibrary (lpDllTable[iUnloadableDll].hDll);
    lpDllTable[iUnloadableDll].hDll = NULL;

    iUnloadableDll = 0;
}


//
// Reduce the object count of the handler, refered to by the index, by one.
// If the object count becomes NULL, free up the handler that is ready to be
// freed (refered to by index iUnloadableDll), and then make this handler the
// freeable one.
//
// As you can see we are trying to implement a simple mechanism of caching.
//

void FARINTERNAL DecreaseHandlerObjCount (int iTable)
{
    if (!iTable)
	return;

    if (iTable != INVALID_INDEX) {
	ASSERT (lpDllTable[iTable].cObj, "Handler Obj count is already NULL");
	if (!--lpDllTable[iTable].cObj) {
	    UnloadDll ();
	    iUnloadableDll = iTable;
	}
    }
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FARINTERNAL CreatePictFromClip (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, lpClass, ctype)
*
*  CreatePictFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create a static picture object if
*  it understands any rendering formats on the clipboard. Currently, it
*  understands only bitmaps and metafiles.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL CreatePictFromClip (
   LPOLECLIENT         lpclient,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpobj,
   OLEOPT_RENDER       optRender,
   OLECLIPFORMAT       cfFormat,
   LPSTR               lpClass,
   LONG                objType
){
    OLESTATUS   retVal = OLE_ERROR_OPTION;

    *lplpobj = NULL;

    if (optRender == olerender_none)
	return OLE_OK;
    else if (optRender == olerender_format) {
	switch (cfFormat) {
	    case 0:
		return OLE_ERROR_FORMAT;

	    case CF_ENHMETAFILE:
		return EmfPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    case CF_METAFILEPICT:
		return MfPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    case CF_DIB:
		return DibPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    case CF_BITMAP:
		return BmPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);

	    default:
		return GenPaste (lpclient, lhclientdoc, lpobjname, lplpobj,
			    lpClass, cfFormat, objType);
	}
    }
    else if (optRender == olerender_draw) {
	cfFormat = (OLECLIPFORMAT)EnumClipboardFormats (0);
	while ((cfFormat) && (retVal > OLE_WAIT_FOR_RELEASE)) {
	    switch (cfFormat) {

		case CF_ENHMETAFILE:
		    retVal = EmfPaste (lpclient, lhclientdoc, lpobjname,
			    lplpobj, objType);
		    break;

		case CF_METAFILEPICT:
		    retVal = MfPaste (lpclient, lhclientdoc,
				lpobjname, lplpobj, objType);
		    break;

		case CF_DIB:
		    retVal = DibPaste (lpclient, lhclientdoc,
				lpobjname, lplpobj, objType);
		    break;

		case CF_BITMAP:
		    retVal = BmPaste (lpclient, lhclientdoc,
				lpobjname, lplpobj, objType);
		    break;
	    }

	    cfFormat = (OLECLIPFORMAT)EnumClipboardFormats (cfFormat);
	}
    }

    return retVal;
}



OLESTATUS FARINTERNAL CreatePackageFromClip (
   LPOLECLIENT         lpclient,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpobj,
   OLEOPT_RENDER       optRender,
   OLECLIPFORMAT       cfFormat,
   LONG                objType
){
    char    file[MAX_STR+6];
    HANDLE  hData;
    LPSTR   lpFileName;

    if (!(hData = GetClipboardData (cfFileName))
	    || !(lpFileName = GlobalLock (hData)))
	return OLE_ERROR_CLIPBOARD;


    if (objType == OT_LINK) {
	lstrcpy (file, lpFileName);
	lstrcat (file, "/Link");
	lpFileName = (LPSTR) file;
    }

    GlobalUnlock (hData);

    return  CreateEmbLnkFromFile (lpclient, packageClass, lpFileName,
			NULL, lhclientdoc, lpobjname, lplpobj,
			optRender, cfFormat, OT_EMBEDDED);
}



void FARINTERNAL RemoveLinkStringFromTopic (
   LPOBJECT_LE lpobj
){
    char    buf[MAX_STR+6];
    int     i = 0;

    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))) {
	// scan the topic for "/Link"
	while (buf[i] != '/') {
	    if (!buf[i])
		return;
	    i++;
	}

	buf[i] = '\0';
	if (lpobj->topic)
	    GlobalDeleteAtom (lpobj->topic);
	lpobj->topic = GlobalAddAtom (buf);
    }
}


void SetMaxPixel ()
{
    HDC hdc;
    // find out the pixel equivalent of MAX_HIMETRIC in X and Y directions

    if (hdc = GetDC (NULL)) {
	maxPixelsX = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSX),
			2540);
	maxPixelsY = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSY),
			2540);
	ReleaseDC (NULL, hdc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\net.c ===
/****************************** Module Header ******************************\
* Module Name: net.c
*
* PURPOSE: Contains routines  network support
*
* Created: Feb 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  02\12\1190  Orginal
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>

#ifdef WIN16
#include <winnet.h>
#endif

#ifdef WIN32
#include <winnetwk.h>
#endif

#include "dll.h"

#define MAX_DRIVE   26

char    szNULL[]   = "";
char    szNetName[]= "NetName";


BOOL FAR PASCAL GetTaskVisibleWindow (HWND, LPARAM);
void INTERNAL RemoveNetName (LPOBJECT_LE);

// Gets the drive letter from topic (if one exists) and then gets the remote
// name for that drive and then saves it in the object.

OLESTATUS FARINTERNAL SetNetName (
   LPOBJECT_LE lpobj
){
    char        buf[MAX_STR];
    WORD2DWORD  cbBuf = sizeof(buf);
    WORD2DWORD  driveType;
    char        szDrive[3];

    if (lpobj->head.ctype == CT_EMBEDDED)
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->topic, buf, cbBuf))
        return OLE_ERROR_BLANK;

    if (buf[1] != ':') {
        RemoveNetName (lpobj);
        return OLE_OK;
    }

    szDrive[2] = '\0';
    szDrive[1] = ':';
    szDrive[0] = buf[0];
    AnsiUpperBuff ((LPSTR) szDrive, 1);

    if (!(driveType = GetDriveType (MAPVALUE(szDrive[0] - 'A',szDrive)) )) {
        // drive is non existent
        return OLE_ERROR_DRIVE;
    }

    if  (driveType == DRIVE_REMOTE) {
         if (WNetGetConnection (szDrive, buf, (MAPTYPE(LPWORD,LPDWORD)) &cbBuf)
                    != WN_SUCCESS)
             return OLE_ERROR_DRIVE;

         lpobj->cDrive = szDrive[0];
         if (lpobj->aNetName)
             GlobalDeleteAtom (lpobj->aNetName);
         lpobj->aNetName = GlobalAddAtom(buf);
#ifdef WIN16
         lpobj->dwNetInfo = MAKELONG((WNetGetCaps (WNNC_NET_TYPE)),
                                     (WNetGetCaps (WNNC_DRIVER_VERSION)));
#endif

    }
    else {
        RemoveNetName (lpobj);
    }

    return OLE_OK;
}


// If netname exists for the given object, then it makes sure that drive
// in topic corresponds to the netname. If it's not the drive letter will
// be fixed by calling FixNet()

OLESTATUS FARINTERNAL CheckNetDrive (
    LPOBJECT_LE lpobj,
    BOOL        fNetDlg
){
    char    buf[MAX_NET_NAME];
    char    netName[MAX_NET_NAME];
    WORD2DWORD    cbBuf = sizeof(buf);
    char    szDrive[3];

    if (lpobj->head.ctype == CT_EMBEDDED)
        return OLE_OK;

    if (!lpobj->aNetName)
        return OLE_OK;

    if (!GlobalGetAtomName (lpobj->aNetName, netName, sizeof(netName)))
        return OLE_ERROR_MEMORY;

    szDrive[2] = '\0';
    szDrive[1] = ':';
    if (!(szDrive[0] = lpobj->cDrive)) {
        if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf)))
            szDrive[0] = lpobj->cDrive = buf[0];
    }

    if ((WNetGetConnection (szDrive, buf, (MAPTYPE(LPWORD,LPDWORD)) &cbBuf)
            == WN_SUCCESS)  && (!lstrcmp(netName, buf)))
        return OLE_OK;

    return FixNet (lpobj, netName, fNetDlg);
}


// Find if there is a drive connected to the given server. If so, get the
// drive letter and set it in topic. If not try to make connection, and if
// that attempt is successful the set the drive letter in topic.

OLESTATUS INTERNAL FixNet (
    LPOBJECT_LE lpobj,
    LPSTR       lpNetName,
    BOOL        fNetDlg
){
    int         nDrive = 2;     // drive 'C'
    OLESTATUS   retVal;

    if (SetNextNetDrive(lpobj, &nDrive, lpNetName))
        return OLE_OK;

    if (fNetDlg != POPUP_NETDLG)
        return OLE_ERROR_NETWORK;

    if ((retVal = ConnectNet (lpobj, lpNetName)) == OLE_OK) {
        if (!ChangeTopic (lpobj))
            return OLE_ERROR_BLANK;
    }

    return retVal;
}



BOOL FARINTERNAL SetNextNetDrive (
    LPOBJECT_LE lpobj,
    int FAR *   lpnDrive,
    LPSTR       lpNetName
){
    char    buf[MAX_STR];
    WORD2DWORD    cbBuf = sizeof(buf);
    char    szDrive[3];

    if (!lpNetName[0]) {
        if (!GlobalGetAtomName(lpobj->aNetName, lpNetName, MAX_STR))
            return FALSE;
    }

    szDrive[2] = '\0';
    szDrive[1] = ':';
    while (*lpnDrive < MAX_DRIVE) {
        szDrive[0] = (char) ('A' + (++*lpnDrive));
        if (GetDriveType (szDrive) == DRIVE_REMOTE) {
#ifdef WIN16
        if (GetDriveType (++*lpnDrive) == DRIVE_REMOTE) {
#endif
            cbBuf = sizeof(buf);
            if ((WNetGetConnection (szDrive, buf, (MAPTYPE(LPWORD,LPDWORD)) &cbBuf)
                        == WN_SUCCESS) && (!lstrcmp(lpNetName, buf))) {
                lpobj->cDrive = szDrive[0];
                return ChangeTopic (lpobj);
            }
        }
    }

    return FALSE;
}


BOOL FARINTERNAL ChangeTopic (
    LPOBJECT_LE lpobj
){
    char buf[MAX_STR];

    if (!GlobalGetAtomName(lpobj->topic, buf, sizeof(buf)))
        return FALSE;
    if (lpobj->topic)
        GlobalDeleteAtom(lpobj->topic);
    buf[0] = lpobj->cDrive;
    lpobj->topic = GlobalAddAtom (buf);
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    return TRUE;
}



OLESTATUS INTERNAL ConnectNet (
    LPOBJECT_LE lpobj,
    LPSTR       lpNetName
){
    HWND        hCurTask;
    HWND        hwndParent = NULL;


    hCurTask = (HWND)ULongToPtr(MGetCurrentTask());
    ASSERT (hCurTask, "Current task handle in NULL");

    // Get the container task's main window, and use that as parent for
    // the dlg box.
    EnumTaskWindows (hCurTask, (WNDENUMPROC)GetTaskVisibleWindow,
        (DWORD_PTR) ((WORD FAR *) &hwndParent));

    if (lpobj->cDrive = (char) DialogBoxParam (hInstDLL, "CONNECTDLG",
                                    hwndParent, ConnectDlgProc,
                                    (LONG_PTR) lpNetName))
        return OLE_OK;
    else
        return OLE_ERROR_NETWORK;


}



INT_PTR FAR PASCAL ConnectDlgProc(
    HWND    hDlg,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
){
    char            szPassword[32];
    char            szTitle[64];
 
    switch (wMsg) {
        case WM_INITDIALOG:
            SetProp (hDlg, szNetName, (HANDLE)lParam);
            FillDrives (hDlg);
            SetDlgItemText (hDlg, IDD_PATH, (LPSTR) lParam);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam,lParam)) {

                case IDOK:
                {
                    int    cch = 128;
                    char    szMessage[128];
                    char    szDrive[3];
                    LPSTR   lpNetName;

                    GetDlgItemText(hDlg, IDD_DRIVE, szDrive, sizeof(szDrive));
                    GetDlgItemText(hDlg, IDD_PASSWORD, szPassword,
                                sizeof(szPassword));
                    lpNetName = (LPSTR) GetProp (hDlg, szNetName);
                    wParam = WNetAddConnection (lpNetName,
                                (LPSTR) szPassword, szDrive);

                    if (wParam == WN_SUCCESS)  {
                        RemoveProp (hDlg, szNetName);
			EndDialog (hDlg, szDrive[0]);
                        return TRUE;
                    }

                    LoadString (hInstDLL, IDS_NETERR, szTitle,
                        sizeof(szTitle));
#ifdef WIN16
                    if (WNetGetErrorText ((UINT)wParam, szMessage, &cch)
                                    != WN_SUCCESS)
#endif
                        LoadString (hInstDLL, IDS_NETCONERRMSG,
                            szMessage, sizeof(szMessage));

                    if (MessageBox (hDlg, szMessage, szTitle,
                            MB_RETRYCANCEL)  == IDCANCEL)
                        goto error;

                    if (wParam == WN_ALREADY_CONNECTED)
                        FillDrives (hDlg);
                    SetDlgItemText (hDlg, IDD_PASSWORD, szNULL);
                    break;
                }

                case IDCANCEL:
error:
                    RemoveProp (hDlg, szNetName);
                    EndDialog(hDlg, 0);
                    return TRUE;

                case IDD_DRIVE:
                    break;

                case IDD_PATH:
                    if (GET_WM_COMMAND_CMD(wParam,lParam) == EN_KILLFOCUS) {
                        LPSTR   lpNetName;

                        lpNetName = (LPSTR) GetProp (hDlg, szNetName);

                        SendDlgItemMessage (hDlg, IDD_PATH, WM_SETTEXT, 0,
                                    (DWORD_PTR) lpNetName);
                    }
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }

    return FALSE;
}


VOID INTERNAL FillDrives (
    HWND    hDlg
){
    HWND    hwndCB;
    int     nDrive = 3;
    char    szDrive[3];
    DWORD   dwDriveType;

    hwndCB = GetDlgItem(hDlg, IDD_DRIVE);
    SendMessage(hwndCB, CB_RESETCONTENT, 0, 0L);
    szDrive[2] = '\0';
    szDrive[1] = ':';
    while (nDrive < MAX_DRIVE) {
        szDrive[0] = (char) ('A' + nDrive);
#ifdef WIN32
        if ((dwDriveType = GetDriveType (szDrive)) == 1)
#endif
#ifdef WIN16
        if (!GetDriveType (nDrive))
#endif
            SendMessage(hwndCB, CB_ADDSTRING, 0, (DWORD_PTR)(LPSTR)szDrive);
        nDrive++;
    }
    SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);
}


BOOL FAR PASCAL GetTaskVisibleWindow (
    HWND    hWnd,
    LPARAM  lpTaskVisWnd
){
    if (IsWindowVisible (hWnd)) {
        *(HWND FAR *)lpTaskVisWnd = hWnd;
         return FALSE;
    }

    return TRUE;
}

void INTERNAL RemoveNetName (LPOBJECT_LE lpobj)
{
    if (lpobj->aNetName) {
        GlobalDeleteAtom (lpobj->aNetName);
        lpobj->aNetName = (ATOM)0;
    }

    lpobj->cDrive = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\ledde.c ===
/****************************** Module Header ******************************\
* Module Name: LEDDE.C
*
* Purpose: ?????
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik   (../../1990,91)  Designed and coded
*   curts created portable version for win16/32
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"
#include "pict.h"

#define LN_FUDGE        16      // [],(), 3 * 3 (2 double quotes and comma)
#define RUNITEM

#define OLEVERB_CONNECT     0xFFFF

// Definitions for sending the server sys command.
char *srvrSysCmd[] = {"StdNewFromTemplate",
                      "StdNewDocument",
                      "StdEditDocument",
                      "StdOpenDocument"
                      };

#define EMB_ID_INDEX    11          // index of ones digit in #00
extern  char    embStr[];
extern  BOOL    gbCreateInvisible;
extern  BOOL    gbLaunchServer;

extern  ATOM    aMSDraw;

extern  BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// !!! set error hints

OLESTATUS FARINTERNAL LeDoVerb (
    LPOLEOBJECT lpoleobj,
    UINT        verb,
    BOOL        fShow,
    BOOL        fActivate
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->verb = verb;
    lpobj->fCmd = ACT_DOVERB;

    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_RUN, DOCSHOW);
    return DocShow (lpobj);
}



OLESTATUS FARINTERNAL LeShow (
   LPOLEOBJECT lpoleobj,
   BOOL        fActivate
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    UNREFERENCED_PARAMETER(fActivate);

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->fCmd = ACT_SHOW;
    InitAsyncCmd (lpobj, OLE_SHOW, DOCSHOW);
    return DocShow (lpobj);
}


// DocShow : If the server is connected, show the item
// for editing. For embedded objects us NULL Item.
OLESTATUS DocShow (LPOBJECT_LE lpobj)
{
    switch (lpobj->subRtn) {

        case 0:
            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


void SendStdShow (LPOBJECT_LE lpobj)
{
    UINT    len;
    UINT    size;
    LPSTR   lpdata = NULL;
    HANDLE  hdata = NULL;
    BOOL    bShow;

    lpobj->subErr = OLE_OK;

    if (lpobj->verb == OLEVERB_CONNECT) {
        lpobj->verb = 0;
        return;
    }

    if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB)))
        return;

    if (bShow = (!lpobj->bOleServer || !(lpobj->fCmd & ACT_DOVERB))) {

        // show is off, do not show the server.
        if (!(lpobj->fCmd & ACT_SHOW))
            return;

        SETERRHINT(lpobj, OLE_ERROR_SHOW);
        //  and 18 "[StdShowItem(\"")for 5 extra for ",FALSE
        len = 18 + 7;
    } else {
        // 19 for the string [StdDoVerbItem(\"") and
        // 18 extra is for ",000,FALSE,FALSE
        SETERRHINT(lpobj, OLE_ERROR_DOVERB);
        len = 19 + 18;
    }

    len += GlobalGetAtomLen (lpobj->item);

    len +=  4;                 // ")]" + NULL

    hdata = GlobalAlloc (GMEM_DDESHARE, size = len);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    if (bShow)
        lstrcpy (lpdata, "[StdShowItem(\"");
    else
        lstrcpy (lpdata, "[StdDoVerbItem(\"");

    len = lstrlen (lpdata);

    if (lpobj->item)
        GlobalGetAtomName (lpobj->item , lpdata + len, size - len);

    if (!bShow) {

        lstrcat (lpdata, (LPSTR)"\",");
        // assume that the number of verbs are < 10

        len = lstrlen (lpdata);
#ifdef  FIREWALLS
        ASSERT ( (lpobj->verb & 0x000f) < 9 , "Verb value more than 9");
#endif
        lpdata += len;
        *lpdata++ = (char)((lpobj->verb & 0x000f) + '0');
        *lpdata = 0;

        if (lpobj->fCmd & ACT_SHOW)
            lstrcat (lpdata, (LPSTR) ",TRUE");
        else
            lstrcat (lpdata, (LPSTR) ",FALSE");
                // StdVerbItem (item, verb, TRUE
        // add TRUE/FALSE constant for the activate
        if (!(lpobj->fCmd & ACT_ACTIVATE))
            lstrcat (lpdata, (LPSTR) ",TRUE)]");
        else
            lstrcat (lpdata, (LPSTR) ",FALSE)]");
            // [StdDoVerb ("item", verb, FALSE, FALSE)]
    } else
        lstrcat (lpdata, (LPSTR)"\")]");
        // apps like excel and wingraph do not suuport activate at
        // item level.


    GlobalUnlock (hdata);
    DocExecute (lpobj, hdata);
    return;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);

    lpobj->subErr = OLE_ERROR_MEMORY;
    return;
}



OLESTATUS FARINTERNAL  LeQueryOpen (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (QueryOpen(lpobj))
       return OLE_OK;
    else
       return OLE_ERROR_NOT_OPEN;

}


BOOL    INTERNAL  QueryOpen (LPOBJECT_LE lpobj)
{

    if (lpobj->pDocEdit &&  lpobj->pDocEdit->hClient) {
        if (IsServerValid (lpobj))
            return TRUE;
        // destroy the windows and pretend as if the server was never
        // connected.

        DestroyWindow (lpobj->pDocEdit->hClient);
        if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
            DestroyWindow (lpobj->pSysEdit->hClient);

    }
    return FALSE;
}



OLESTATUS FARINTERNAL  LeActivate (
    LPOLEOBJECT lpoleobj,
    UINT        verb,
    BOOL        fShow,
    BOOL        fActivate,
    HWND        hWnd,
    OLE_CONST RECT FAR* lprc
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    lpobj->verb = verb;
    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbOpen (lpobj, fShow, fActivate, hWnd, (LPRECT)lprc);

#ifdef  FIREWALLS
    ASSERT (lpobj->head.ctype == CT_LINK, "unknown object");
#endif
    return LnkOpen (lpobj, fShow, fActivate, hWnd, (LPRECT)lprc);

}


OLESTATUS FARINTERNAL  LeUpdate (
    LPOLEOBJECT lpoleobj
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbUpdate (lpobj);

#ifdef  FIREWALLS
    ASSERT (lpobj->head.ctype == CT_LINK, "unknown object");
#endif
    return LnkUpdate (lpobj);
}



OLESTATUS FARINTERNAL  EmbOpen (
   LPOBJECT_LE lpobj,
   BOOL        fShow,
   BOOL        fActivate,
   HWND        hWnd,
   LPRECT      lprc
){
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if(QueryOpen (lpobj))
        return LeDoVerb ((LPOLEOBJECT)lpobj, lpobj->verb, fShow, fActivate);

    // show the window
    // advise for data only on close
    // and shut down the conv  after the advises.

    lpobj->fCmd = LN_EMBACT | ACT_DOVERB | ACT_ADVISE | ACT_CLOSE;
    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL  EmbUpdate (lpobj)
*
* This function updates an EMB object. If the server is connected
* simply send a request for the native as well as the display formats.
* If the server is connected, then tries to start the conversationa and
* get the data. If the conversation fails, then load the server and
* start the conversation. The embeded objects may have links in it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FARINTERNAL  EmbUpdate (LPOBJECT_LE lpobj)
{

    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    lpobj->fCmd = LN_EMBACT | ACT_REQUEST | (QueryOpen(lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



OLESTATUS FARINTERNAL  EmbOpenUpdate (LPOBJECT_LE lpobj)
{

    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step6);
            SendSrvrMainCmd  (lpobj, lpobj->lptemplate);
            lpobj->lptemplate = NULL;
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            // Init doc conversation should set the failure error
            if (!InitDocConv (lpobj, !POPUP_NETDLG))
                 goto errRtn;

            // If there is no native data, do not do any poke.
            // creates will not have any poke data to start with

            SKIP_TO (!(lpobj->hnative), step6);
            PokeNativeData (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            if (ProcessErr (lpobj))
                 goto errRtn;
            // Now poke the hostnames etc stuff.
            PokeHostNames (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 3:

            // do not worry about the poke hostname errors
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 4:

            PokeDocDimensions (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 5:

            PokeColorScheme (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 6:

            step6:

            // wingraph does not accept the  doc dimensions
            // after sttedit.
            CLEAR_STEP_ERROR (lpobj);
            SETSTEP (lpobj, 6);
            STEP_NOP (lpobj);
            // step_nop simply increments the step numebr
            // merge the steps later on



        case 7:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step13);
            lpobj->optUpdate = oleupdate_onsave;
            lpobj->pDocEdit->nAdviseSave = 0;
            AdviseOn (lpobj, cfNative, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 8:

            // do not go for errors on /save. Some servers may not support
            // this.

            CLEAR_STEP_ERROR (lpobj);
            AdvisePict (lpobj, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 9:

            // see if server will positive ack a metafile advise if enhmetafile
            // advise failed
            if (ChangeEMFtoMFneeded(lpobj,aSave))
               WAIT_FOR_ASYNC_MSG (lpobj);


        case 10:

            if (!lpobj->subErr && lpobj->bNewPict)
               if (!ChangeEMFtoMF(lpobj))
                  goto errRtn;

            // do not worry about the error case for save. Ignore them

            CLEAR_STEP_ERROR (lpobj);
            lpobj->optUpdate = oleupdate_onclose;
            lpobj->pDocEdit->nAdviseClose = 0;
            AdviseOn (lpobj, cfNative, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 11:
            if (ProcessErr(lpobj))
                goto errRtn;

            AdvisePict (lpobj, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 12:
            if (ChangeEMFtoMFneeded(lpobj,aClose))
               WAIT_FOR_ASYNC_MSG (lpobj);

        case 13:

            step13:
            SETSTEP (lpobj, 13);
            if (ProcessErr(lpobj))
                goto errRtn;

            if (lpobj->bNewPict && !ChangeEMFtoMF(lpobj))
                  goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step15);

            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

            // If request pict fails, then native and pict are
            // not in sync.

        case 14:
            if (ProcessErr(lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 15:

            step15:
            SETSTEP(lpobj, 15);

            if (ProcessErr(lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 16:


            if (ProcessErr(lpobj))
                goto errRtn;

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step17);
            return EndAsyncCmd (lpobj);


        case 17:

errRtn:
            step17:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE)
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);

            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;


      default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}




OLESTATUS FARINTERNAL  LnkOpen (
   LPOBJECT_LE lpobj,
   BOOL        fShow,
   BOOL        fActivate,
   HWND        hWnd,
   LPRECT      lprc
){
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(lprc);

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if(QueryOpen (lpobj))
        return LeDoVerb ((LPOLEOBJECT)lpobj, lpobj->verb, fShow, fActivate);

    // Just end the system conversation. we are not unloading
    // this instance at all.

    lpobj->fCmd = LN_LNKACT |  ACT_DOVERB;

    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;
    else if (lpobj->optUpdate == oleupdate_onsave)
        lpobj->fCmd |= ACT_ADVISE;

    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);

}


OLESTATUS FARINTERNAL  LnkUpdate (LPOBJECT_LE lpobj)
{
    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    lpobj->fCmd = LN_LNKACT | ACT_REQUEST | (QueryOpen (lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}



OLESTATUS FARINTERNAL  LnkOpenUpdate (LPOBJECT_LE lpobj)
{
    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step2);
            InitDocConv (lpobj, !POPUP_NETDLG);
            if (QueryOpen(lpobj)) {
                if (lpobj->app == aPackage)
                    RemoveLinkStringFromTopic (lpobj);
                goto step2;
            }

            SendSrvrMainCmd (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            if (lpobj->app == aPackage)
                RemoveLinkStringFromTopic (lpobj);

            if (!InitDocConv (lpobj, POPUP_NETDLG)) {
                lpobj->subErr = OLE_ERROR_OPEN;
                goto errRtn;
            }

        case 2:

            step2:

            SETSTEP (lpobj, 2);
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 3:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step7);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step4);
            AdviseOn (lpobj, cfNative, (ATOM)0);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 4:
            step4:
            SETSTEP  (lpobj, 4);
            if (ProcessErr (lpobj))
                goto errRtn;

            AdvisePict (lpobj, (ATOM)0);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 5:

            // see if server will positive ack a metafile advise if enhmetafile
            // advise failed
            if (ChangeEMFtoMFneeded(lpobj,(ATOM)0))
               WAIT_FOR_ASYNC_MSG (lpobj);

       case 6:

            if (ProcessErr (lpobj))
                goto errRtn;

            if (lpobj->bNewPict && !ChangeEMFtoMF(lpobj))
                goto errRtn;

            // Now send advise for renaming the documnet.
            AdviseOn (lpobj, cfBinary, aStdDocName);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 7:

            step7:
            // if name advise fails ignore it
            SETSTEP (lpobj, 7);

            CLEAR_STEP_ERROR (lpobj);
            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step9);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step8);

            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 8:
            step8:

            SETSTEP (lpobj, 8);
            if (ProcessErr (lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 9:

            step9:
			
   			if (lpobj->subErr && CF_ENHMETAFILE == GetPictType(lpobj)) {
      	   		CLEAR_STEP_ERROR (lpobj);

               	if (!ChangeEMFtoMF(lpobj))
               		goto errRtn;
				
               	RequestPict (lpobj);
               	WAIT_FOR_ASYNC_MSG (lpobj);

   			}

            else if (ProcessErr (lpobj))
                goto errRtn;

            SETSTEP     (lpobj, 9);
			
            SKIP_TO (!(lpobj->fCmd & ACT_TERMDOC), step11);
            // terminate the document conversataion.
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 10:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteDocEdit (lpobj);

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step15);
            return EndAsyncCmd (lpobj);

      case 11:

            step11:
            SETSTEP     (lpobj, 11);

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_TERMSRVR), step13);

            // terminate the server conversataion.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 12:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


      case 13:

            step13:
            SETSTEP     (lpobj, 13);
            if (ProcessErr (lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 14:

            if (ProcessErr (lpobj))
                goto errRtn;
            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step15);
            return EndAsyncCmd (lpobj);


      case 15:

            errRtn:
            step15:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE)
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);

            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;

       default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



OLESTATUS EmbLnkClose (LPOBJECT_LE lpobj)
{
    switch (lpobj->subRtn) {

        case    0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS FARINTERNAL  LeClose (
   LPOLEOBJECT lpoleobj
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    PROBE_ASYNC (lpobj);
    if (IS_SVRCLOSING(lpobj))
        return OLE_OK;


    lpobj->fCmd = 0;

    if (lpobj->head.ctype == CT_EMBEDDED) {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKDELETE);
        return EmbLnkDelete (lpobj);
    }
    else {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKCLOSE);
        return EmbLnkClose (lpobj);
    }
}



OLESTATUS FARINTERNAL  LeReconnect (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    // check for the existing conversation.
    // if the client window is non-null, then
    // connection exits.

    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;     // allow only for linked

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (QueryOpen (lpobj))
        return OLE_OK;

    // start just the conversation. Do not load
    // the app.

    if (!InitDocConv (lpobj, !POPUP_NETDLG))
         return OLE_OK;             // document is not loaded , it is OK.

    lpobj->fCmd = LN_LNKACT;
    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;

    InitAsyncCmd (lpobj, OLE_RECONNECT, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}




OLESTATUS INTERNAL PokeNativeData (LPOBJECT_LE lpobj)
{
   SETERRHINT(lpobj, OLE_ERROR_POKE_NATIVE);
   return SendPokeData (
            lpobj,
            lpobj->item,
            lpobj->hnative,
            cfNative
   );
}




BOOL INTERNAL PostMessageToServer (
   PEDIT_DDE   pedit,
   UINT        msg,
   LPARAM      lparam
){

#ifdef  FIREWALLS
    ASSERT (pedit, "Dde edit block is NULL");
#endif
    // save the lparam and msg fpr possible reposting incase of error.

    // we are in abort state.  no messages except for terminate.

    if (pedit->bAbort && msg != WM_DDE_TERMINATE)
        return FALSE;

    pedit->lParam = lparam;
    pedit->msg    = msg;

    if (pedit->hClient && pedit->hServer) {
        while (TRUE){
            if (!IsWindowValid (pedit->hServer))
                return FALSE;
            if (PostMessage (pedit->hServer, msg, (WPARAM)pedit->hClient, lparam) == FALSE)
                Yield ();
            else
                return TRUE;
        }
    }
    return FALSE;
}


OLESTATUS FARINTERNAL LeCreateFromTemplate (
    LPOLECLIENT         lpclient,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    char            buf[MAX_STR];

    if (!MapExtToClass (lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;

    return CreateFromClassOrTemplate (lpclient, (LPSTR) buf, lplpoleobject,
                        optRender, cfFormat, LN_TEMPLATE, lptemplate,
                        lhclientdoc, lpobjname);
}


OLESTATUS FARINTERNAL LeCreate (
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    if (gbCreateInvisible) {
        // this is in fact a call for invisible create
        return LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname,
                        lplpoleobject, optRender, cfFormat, gbLaunchServer);
    }

    return CreateFromClassOrTemplate (lpclient, lpclass, lplpoleobject,
                        optRender, cfFormat, LN_NEW, NULL,
                        lhclientdoc, lpobjname);
}



OLESTATUS FARINTERNAL CreateFromClassOrTemplate (
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    UINT                lnType,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname
){
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [32];

    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;

    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }

    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    SetEmbeddedTopic (lpobj);
    lpobj->item          = (ATOM)0;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 32);
    lpobj->aServer       = aServer;

    // launch the app and start the system conversation.

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj,
                optRender, cfFormat, lpclass))
        goto errRtn;


    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = (UINT)(lnType | ACT_SHOW | ACT_ADVISE | ACT_CLOSE);
    InitAsyncCmd (lpobj, lptemplate? OLE_CREATEFROMTEMPLATE : OLE_CREATE, EMBOPENUPDATE);
    *lplpoleobject = (LPOLEOBJECT)lpobj;

    lpobj->lptemplate = lptemplate;

    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }

    return retval;
}



OLESTATUS FARINTERNAL CreateEmbLnkFromFile (
   LPOLECLIENT         lpclient,
   LPCSTR              lpclass,
   LPSTR               lpfile,
   LPSTR               lpitem,
   LHCLIENTDOC         lhclientdoc,
   LPSTR               lpobjname,
   LPOLEOBJECT FAR *   lplpoleobject,
   OLEOPT_RENDER       optRender,
   OLECLIPFORMAT       cfFormat,
   LONG                objType
){
    OLESTATUS           retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE         lpobj = NULL;
    ATOM                aServer;
    char                buf[MAX_STR];
    OLE_RELEASE_METHOD  releaseMethod;
    UINT                wFlags = 0;
    char                chVerb[32];

    if (!lpclass && (lpclass = (LPSTR) buf)
            && !MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;

    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;

    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK))) {
        GlobalDeleteAtom (aServer);
        goto errFileCreate;
    }

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->topic         = GlobalAddAtom (lpfile);
    lpobj->aServer       = aServer;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 32);
    if ((retval = SetNetName (lpobj)) != OLE_OK)
        goto errFileCreate;

    if (lpitem)
        lpobj->item = GlobalAddAtom (lpitem);

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj,
                optRender, cfFormat, lpclass)) {
        retval = OLE_ERROR_MEMORY;
        goto errFileCreate;
    }

    *lplpoleobject = (LPOLEOBJECT) lpobj;

    if (objType == CT_EMBEDDED) {
        releaseMethod = OLE_CREATEFROMFILE;
        if ((optRender == olerender_format) && (cfFormat == cfNative))
            wFlags = 0;
        else
            wFlags = ACT_NATIVE;
    }
    else {
        // caller wants linked object to be created

        // if no presentation data is requested and the link is to the whole
        // file, then there is no need to launch the server.

        if ((optRender == olerender_none) && !lpobj->item)
            return FileExists (lpobj);

        // we want to establish hot link
        wFlags = ACT_ADVISE;
        releaseMethod = OLE_CREATELINKFROMFILE;
    }

    lpobj->fCmd = (UINT)(LN_LNKACT | ACT_REQUEST | ACT_UNLAUNCH | wFlags);
    InitAsyncCmd (lpobj, releaseMethod , LNKOPENUPDATE);

    if ((retval = LnkOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.


errFileCreate:

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }

    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FARINTERNAL LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bActivate)
//
//  Arguments:
//
//     lpclient -
//     lpclass  -
//     lhclientdoc  -
//     lpobjname    -
//     lplpoleobject    -
//     optRender    -
//     cfFormat -
//     fActivate    -
//
//  Returns:
//
//      OLE_ERROR_CLASS -
//      OLE_OK  -
//      EmbOpenUpdate (lpobj)   -
//      retval  -
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeCreateInvisible (
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                fActivate
){
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [32];

    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;

    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }

    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->item          = (ATOM)0;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 32);
    lpobj->aServer       = aServer;
    lpobj->lptemplate    = NULL;
    SetEmbeddedTopic (lpobj);

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj,
                optRender, cfFormat, lpclass))
        goto errRtn;

    *lplpoleobject = (LPOLEOBJECT)lpobj;

    if (!fActivate)
        return OLE_OK;

    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = LN_NEW | ACT_ADVISE | ACT_CLOSE;
    InitAsyncCmd (lpobj, OLE_CREATEINVISIBLE, EMBOPENUPDATE);

    // launch the app and start the system conversation.
    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }

    return retval;
}



// LeSetUpdateOptions: sets the update options. If the server
// is connectd then it unadvises for the current options and
// advises for the new options.

OLESTATUS   FARINTERNAL LeSetUpdateOptions (
    LPOLEOBJECT         lpoleobj,
    OLEOPT_UPDATE       options
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    PROBE_OLDLINK (lpobj);
    PROBE_ASYNC (lpobj);

    //!!! make sure the options are within range.

    if (lpobj->head.ctype != CT_LINK)
        return (OLE_ERROR_OBJECT);

    if (options > oleupdate_oncall)
        return OLE_ERROR_OPTION;

    if (lpobj->optUpdate == options)
        return OLE_OK;

    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
       lpobj->optUpdate = options;
       return OLE_OK;
    }

    lpobj->optNew = options;
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETUPDATEOPTIONS, LNKSETUPDATEOPTIONS);
    return LnkSetUpdateOptions (lpobj);

}

OLESTATUS   LnkSetUpdateOptions (LPOBJECT_LE lpobj)
{

    switch (lpobj->subRtn) {

        case 0:

            if (lpobj->optUpdate == oleupdate_oncall)
                goto step1;

            // If the server is active then unadvise for old
            // options.

            UnAdvisePict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            step1:

            SETSTEP (lpobj, 1);
            ProcessErr (lpobj);

            lpobj->optUpdate = lpobj->optNew;
            if (lpobj->optUpdate == oleupdate_oncall)
                goto step3;

            AdvisePict (lpobj, (ATOM)0);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            SETSTEP (lpobj, 2);
            if (ProcessErr (lpobj))
                goto errRtn;

            if (lpobj->optUpdate == oleupdate_onsave)
                goto step3;

            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 3:
            errRtn:
            step3:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



//AdvisePict: Sends advise for pict data

void    INTERNAL AdvisePict (
    LPOBJECT_LE lpobj,
    ATOM        aAdvItem
){
    int         cftype;

    if (cftype = GetPictType (lpobj))
        AdviseOn (lpobj, cftype, aAdvItem);
}


//UnAdvisePict: Sends unadvise for pict data

void   INTERNAL UnAdvisePict (LPOBJECT_LE lpobj)
{
    int         cftype;

    SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);
    if (cftype = GetPictType (lpobj))
         UnAdviseOn (lpobj, cftype);
}

// GetPictType: Given the object, returns the pict type.

int     INTERNAL GetPictType (LPOBJECT_LE lpobj)
{
    if (lpobj->lpobjPict)
        return (int)(*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, 0);
    return 0;
}


// AdviseOn : Sends advise for a given picture type
// Send advise only if the advise options is not on call.

void  INTERNAL AdviseOn (
    LPOBJECT_LE lpobj,
    int         cftype,
    ATOM        advItem
){
    HANDLE          hopt   = NULL;
    DDEADVISE FAR   *lpopt = NULL;
    ATOM            item   = (ATOM)0;
    PEDIT_DDE       pedit;
    OLESTATUS       retval= OLE_ERROR_MEMORY;
    LPARAM          lParamNew;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_ADVISE_NATIVE);
    else {
        if (cftype == (int)cfBinary)
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_RENAME);
        else
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);

    }

    if (lpobj->optUpdate == oleupdate_oncall)
        return;

    if(!(hopt = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof(DDEADVISE))))
        goto errRtn;

    retval = OLE_ERROR_MEMORY;
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    pedit = lpobj->pDocEdit;
    lpopt->fAckReq = TRUE;

    // get data always. Currently there is no way for the
    // deferred updates.

    lpopt->fDeferUpd = 0;
    lpopt->cfFormat = (WORD)cftype;
    GlobalUnlock (hopt);

    pedit->hopt = hopt;

    if (advItem == aStdDocName)
        item = DuplicateAtom (advItem);
    else
        item = ExtendAtom (lpobj, lpobj->item);

    retval = OLE_ERROR_COMM;
    if (!PostMessageToServer(pedit, WM_DDE_ADVISE,
               lParamNew = MAKE_DDE_LPARAM(WM_DDE_ADVISE, (UINT_PTR)hopt, item)))
    {
        DDEFREE(WM_DDE_ADVISE,lParamNew);
        goto errRtn;
    }

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
    pedit->awaitAck = AA_ADVISE;
    lpobj->bAsync    = TRUE;

    if (advItem == aClose)
       lpobj->pDocEdit->nAdviseClose++;
    else if (advItem == aSave)
       lpobj->pDocEdit->nAdviseSave++;

    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);

    if (lpopt)
        GlobalUnlock (hopt);

    if (hopt)
        GlobalFree (hopt);
    lpobj->subErr = retval;

    return ;


}



//UnAdviseOn: Sends unadvise for an item.
void INTERNAL UnAdviseOn (
    LPOBJECT_LE lpobj,
    int         cftype
){
    ATOM        item;
    PEDIT_DDE   pedit;

    UNREFERENCED_PARAMETER(cftype);

    pedit  =  lpobj->pDocEdit;
    item    = ExtendAtom (lpobj, lpobj->item);

    if (!PostMessageToServer(pedit, WM_DDE_UNADVISE, MAKELONG (NULL, item)))
        lpobj->subErr = OLE_ERROR_COMM;
    else {
#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
        lpobj->bAsync   = TRUE;
        pedit->awaitAck = AA_UNADVISE;
    }
}

// RequestOn: Semd WM_DDE_REQUEST for the item of the
// for a given type;

void INTERNAL RequestOn (
    LPOBJECT_LE lpobj,
    int         cftype
){
    ATOM        item = (ATOM)0;
    PEDIT_DDE   pedit;
    OLESTATUS   retval = OLE_ERROR_COMM;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_NATIVE);
    else
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_PICT);

    pedit = lpobj->pDocEdit;

    item = DuplicateAtom (lpobj->item);
    if (!PostMessageToServer (pedit, WM_DDE_REQUEST, MAKELONG (cftype, item)))
        goto errRtn;

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif

    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_REQUEST;
    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);
    return ;

}


//RequestPict: Sends request for apicture type.
void INTERNAL RequestPict (LPOBJECT_LE lpobj)
{
    int cftype;

    if (cftype = GetPictType (lpobj))
        RequestOn (lpobj, cftype);
}



// LeSetHostNames: Sets the host names. If the server is connected
// send the host names to the server.
OLESTATUS FARINTERNAL  LeSetHostNames (
    LPOLEOBJECT    lpoleobj,
    OLE_LPCSTR     lpclientName,
    OLE_LPCSTR     lpdocName
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS   retval = OLE_ERROR_MEMORY;

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);
    if ((retval = SetHostNamesHandle (lpobj, (LPSTR)lpclientName, (LPSTR)lpdocName))
            != OLE_OK)
        return retval;


    // If the server is connected poke the hostnames
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeHostNames (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



OLESTATUS   FARINTERNAL  LeSetTargetDevice (
    LPOLEOBJECT lpoleobj,
    HANDLE      hdata
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    HANDLE      hdup = NULL;
    OLESTATUS   retval;

    PROBE_ASYNC (lpobj);

    if(!(hdup = DuplicateGlobal (hdata, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    if (lpobj->htargetDevice)
        GlobalFree (lpobj->htargetDevice);

    lpobj->htargetDevice = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeTargetDeviceInfo (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



OLESTATUS FARINTERNAL  LeSetBounds(
    LPOLEOBJECT         lpoleobj,
    OLE_CONST RECT FAR* lprcBounds
){
    LPOBJECT_LE     lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    HANDLE          hdata = NULL;
    LPBOUNDSRECT    lprc  = NULL;

    PROBE_ASYNC (lpobj);

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    if(!(hdata = GlobalAlloc (GMEM_MOVEABLE, (UINT)sizeof (BOUNDSRECT))))
        return OLE_ERROR_MEMORY;

    if (!(lprc = (LPBOUNDSRECT)GlobalLock (hdata)))
        goto errrtn;

    //
    // Now set the data
    //
    // Note: The 16-bit implementations are expecting USHORT sized values
    // Actually, they are expected a 16-bit RECT which is 4 ints. Why we
    // are sending a LPBOUNDSRECT instead of a 16-bit RECT is a mystery,
    // but thats the backward compatible story.
    //

    lprc->defaultWidth    = (USHORT) (lprcBounds->right  - lprcBounds->left);
    lprc->defaultHeight   = (USHORT) -(lprcBounds->bottom - lprcBounds->top);
    lprc->maxWidth        = (USHORT) (lprcBounds->right  - lprcBounds->left);
    lprc->maxHeight       = (USHORT) -(lprcBounds->bottom - lprcBounds->top);

    GlobalUnlock (hdata);

    if (lpobj->hdocDimensions)
        GlobalFree (lpobj->hdocDimensions);

    lpobj->hdocDimensions = hdata;
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeDocDimensions (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;

errrtn:
    if (lprc)
        GlobalUnlock (hdata);
    if (hdata)
        GlobalFree (hdata);

    return retval;
}


OLESTATUS FARINTERNAL LeSetData (
    LPOLEOBJECT     lpoleobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE          hData
){
    LPOBJECT_LE     lpobj = (LPOBJECT_LE)lpoleobj;
    OLESTATUS       retVal = OLE_OK;
    BOOL            fKnown = FALSE;

    PROBE_ASYNC (lpobj);

    if ((cfFormat == cfObjectLink) || (cfFormat == cfOwnerLink))
        return ChangeDocAndItem (lpobj, hData);

    if (fKnown = (cfFormat && (cfFormat == (OLECLIPFORMAT)GetPictType (lpobj)))) {
        retVal =  (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                                    hData, lpobj->head.lpclient, FALSE);

        (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict,
                                cfFormat, &hData);
    }
    else if (fKnown = (cfFormat == cfNative)) {
        retVal = LeChangeData (lpoleobj, hData, lpobj->head.lpclient, FALSE);
        hData = lpobj->hnative;
    }

    if (retVal != OLE_OK)
        return retVal;

    if (fKnown)
        ContextCallBack ((LPOLEOBJECT)lpobj, OLE_CHANGED);

    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
        if (!fKnown)
            return OLE_ERROR_NOT_OPEN;
        return OLE_OK;
    }

    // except for the following formats all the other data will be copied
    // into DDEPOKE block. So there is no need to duplicate the data of the
    // other formats
    if (  cfFormat == CF_METAFILEPICT
          || cfFormat == CF_ENHMETAFILE
          || cfFormat == CF_BITMAP
          || cfFormat == CF_DIB)
    {

        if (!(hData = DuplicateGDIdata (hData, cfFormat)))
            return OLE_ERROR_MEMORY;
    }

    // *** The last parameter must be NULL, don't change it ***
    InitAsyncCmd (lpobj, OLE_SETDATA, 0);
    if ((retVal = SendPokeData (lpobj, lpobj->item, hData, cfFormat))
            != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retVal;
}



OLESTATUS   FARINTERNAL  LeSetColorScheme (
    LPOLEOBJECT               lpoleobj,
    OLE_CONST LOGPALETTE FAR* lplogpal
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;
    HANDLE      hdup = NULL;
    DWORD       cblogpal;
    OLESTATUS   retval;
    LPBYTE      lptemp;

    lptemp = (LPBYTE) lplogpal;

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);

    FARPROBE_READ(lptemp + (cblogpal = 2*sizeof(UINT)));
    cblogpal += ((sizeof(PALETTEENTRY) * lplogpal->palNumEntries) -1);
    if (!FarCheckPointer (lptemp + cblogpal, READ_ACCESS))
        return OLE_ERROR_PALETTE;

    if (!(hdup = CopyData ((LPSTR) lplogpal, cblogpal)))
        return OLE_ERROR_MEMORY;

    if (lpobj->hlogpal)
        GlobalFree (lpobj->hlogpal);

    lpobj->hlogpal = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    if ((retval = PokeColorScheme (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



//PokeHostNames: Pokes hostname data to the server
OLESTATUS INTERNAL PokeHostNames (LPOBJECT_LE lpobj)
{
    OLESTATUS   retVal = OLE_ERROR_MEMORY;

    // if the server is connectd then poke the host names
    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

    if (!lpobj->hhostNames)
        return OLE_OK;

    aStdHostNames = GlobalAddAtom ("StdHostNames");
    return SendPokeData (lpobj,aStdHostNames,lpobj->hhostNames,cfBinary);
}


OLESTATUS INTERNAL  PokeTargetDeviceInfo (LPOBJECT_LE lpobj)
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->htargetDevice)
        return OLE_OK;

   aStdTargetDevice = GlobalAddAtom ("StdTargetDevice");
   return SendPokeData (lpobj, aStdTargetDevice,
                    lpobj->htargetDevice,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeDocDimensions (LPOBJECT_LE lpobj)
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hdocDimensions)
        return OLE_OK;

   aStdDocDimensions = GlobalAddAtom ("StdDocDimensions");
   return SendPokeData (lpobj, aStdDocDimensions,
                    lpobj->hdocDimensions,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeColorScheme (LPOBJECT_LE lpobj)
{
   // if the server is connected then poke the palette info
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hlogpal)
        return OLE_OK;

   aStdColorScheme = GlobalAddAtom ("StdColorScheme");
   return SendPokeData (lpobj, aStdColorScheme,
                    lpobj->hlogpal,
                    cfBinary);
}


OLESTATUS INTERNAL SendPokeData (
    LPOBJECT_LE     lpobj,
    ATOM            aItem,
    HANDLE          hdata,
    OLECLIPFORMAT   cfFormat
){
    HANDLE      hdde = NULL;
    DDEPOKE FAR * lpdde = NULL;
    LPSTR       lpdst = NULL;
    LPSTR       lpsrc = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    DWORD       dwSize = 0;
    PEDIT_DDE   pedit;
    BOOL        bGDIdata = FALSE;
    LPARAM      lParamNew;

    pedit = lpobj->pDocEdit;

    // If it is GDI data then we can stuff the handle into POKE block.
    // Otherwise we have to copy the data into DDE data block. There
    // is a special case with old MSDraw, that will be handled by
    // the routine CanPutHandleInPokeBlock()

    if (!(bGDIdata = CanPutHandleInPokeBlock (lpobj, cfFormat))) {
        if (!(dwSize = (DWORD)GlobalSize (hdata)))
            return OLE_ERROR_MEMORY;

        if (!(lpsrc = (LPSTR) GlobalLock (hdata)))
            return OLE_ERROR_MEMORY;

        GlobalUnlock (hdata);
    }

    // Now allocate the DDE data block

    if (!(hdde = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT,
                 (dwSize + sizeof(DDEPOKE) - sizeof(BYTE) + sizeof(HANDLE)))))
        goto errRtn;

    if (!(lpdde = (DDEPOKE FAR *)GlobalLock (hdde)))
        goto errRtn;

    GlobalUnlock (hdde);

    // !!! We may want to set it TRUE, for performance reasons. But it
    // will require some rework on the server side
    lpdde->fRelease = 0;
    lpdde->cfFormat = (WORD)cfFormat;

    if (bGDIdata) {
#ifdef _WIN64
        if (lpdde->cfFormat == CF_METAFILEPICT)
            *(void* _unaligned*)lpdde->Value = hdata;
        else
#endif
            *(LONG*)lpdde->Value = HandleToLong(hdata);

    } else {
        lpdst = (LPSTR)lpdde->Value;
        UtilMemCpy (lpdst, lpsrc, dwSize);

        // For the CF_METAFILEPICT format, we would come here only if we are
        // dealing with the old version of MSDraw. In that case we want to
        // free the handle to METAFILEPICT strcuture, because we've already
        // copied its contents to DDEPOKE structure.

        // Note that that the old MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (cfFormat == CF_METAFILEPICT) {
            GlobalFree (hdata);
            hdata = NULL;
        }
    }

    // *** From here onwards if there is an error call FreePokeData(), don't
    // jump to errRtn

    aItem = DuplicateAtom (aItem);

    ASSERT(pedit->hData == NULL, "Poke data is not null");

    pedit->hData = hdde;
    if (!PostMessageToServer (pedit, WM_DDE_POKE,
            lParamNew = MAKE_DDE_LPARAM(WM_DDE_POKE, (UINT_PTR)hdde, aItem)))
   {
        if (aItem)
            GlobalDeleteAtom (aItem);
        FreePokeData (lpobj, pedit);
        DDEFREE(WM_DDE_POKE,lParamNew);
        return (lpobj->subErr = OLE_ERROR_COMM);
    }

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
    if (lpobj->asyncCmd == OLE_NONE)
        lpobj->asyncCmd = OLE_OTHER;

    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_POKE;
    // !!! after poke of the hostnames etc. we are not processing error.,

    // Data is freed after the Poke is acknowledged. OLE_RELEASE will be sent
    // to when ACK comes.

    return OLE_WAIT_FOR_RELEASE;

errRtn:
    if (hdata)
        FreeGDIdata (hdata, cfFormat);

    if (hdde)
        GlobalFree (hdde);

    pedit->hData = NULL;

    return (lpobj->subErr = retval);
}



// FreePokeData: Frees the poked data.
void  INTERNAL FreePokeData (
    LPOBJECT_LE lpobj,
    PEDIT_DDE   pedit
){
    DDEPOKE FAR * lpdde;

#ifdef  FIREWALLS
    ASSERT (pedit->hData, "Poke data handle is null");

#endif

    if (lpdde = (DDEPOKE FAR *) GlobalLock (pedit->hData)) {
        GlobalUnlock (pedit->hData);

        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && (lpobj->app == aMSDraw)
                && (lpdde->cfFormat == CF_METAFILEPICT)) {
            DeleteMetaFile (((LPMETAFILEPICT) ((LPSTR) &lpdde->Value))->hMF);
        }
        else {
#ifdef _WIN64
            if (lpdde->cfFormat == CF_METAFILEPICT)
                FreeGDIdata(*(void* _unaligned*)lpdde->Value, lpdde->cfFormat);
            else
#endif
                FreeGDIdata (LongToHandle(*(LONG*)lpdde->Value), lpdde->cfFormat);
        }
    }

    GlobalFree (pedit->hData);
    pedit->hData = NULL;
}



BOOL INTERNAL  SendSrvrMainCmd (
    LPOBJECT_LE lpobj,
    LPSTR       lptemplate
){
    UINT        size;
    UINT        len;
    OLESTATUS   retval = OLE_ERROR_COMM;
    int         cmd = 0;
    HANDLE      hInst = NULL;
    LPSTR       lpdata= NULL;
    HANDLE      hdata = NULL;
    BOOL        bLaunch = TRUE;

    Puts("Launch App and Send Sys command");

#ifdef  FIREWALLS
    ASSERT (lpobj->aServer, "Serevr is NULL");
#endif

    if (!lpobj->aServer) {
        retval = OLE_ERROR_REGISTRATION;
        goto errRtn;
    }

    if (!lpobj->bOldLink) {
        bLaunch = !(lpobj->fCmd & ACT_NOLAUNCH);
        cmd = lpobj->fCmd & LN_MASK;
    }

    if (cmd == LN_LNKACT) {
        // take care of network based document
        char    cDrive = lpobj->cDrive;

        if ((retval = CheckNetDrive (lpobj, POPUP_NETDLG)) != OLE_OK) {
            lpobj->cDrive = cDrive;
            goto errRtn;
        }

        if (cDrive != lpobj->cDrive)
            ContextCallBack ((LPOLEOBJECT)lpobj, OLE_RENAMED);
    }

    if (!InitSrvrConv (lpobj, hInst)) {

        if (!bLaunch)
            goto errRtn;

        if (!(hInst = LeLaunchApp (lpobj))) {
            // We failed to launch the app. If it is a linked object, see
            // whether the docname is valid for new servers.  We wouldn't
            // have given the doc name on the command line for the old
            // servers. So, there is no point in checking for file existance
            // in that case.
            if (lpobj->bOleServer && (lpobj->bOldLink || (cmd == LN_LNKACT))){
                if ((retval = FileExists (lpobj)) != OLE_OK)
                    goto errRtn;
            }

            retval = OLE_ERROR_LAUNCH;
            goto errRtn;
        }

        if (lpobj->bOldLink)
            return TRUE;

        if (lpobj->bOleServer && (cmd == LN_LNKACT)) {
            // We are not using any data blocks if the object is old link.
            // we launched with docname, and don't have to establish system
            // level and also we don't have to send exec strings.

            // for non-ole servers like excel, we do want to connect at
            // the system level, so that we can send "StdOpen". We also
            // have to send "StdExit" for the server to exit in the
            // invisible launch case.

            return TRUE;
        }

        retval = OLE_ERROR_COMM;
        if(!InitSrvrConv (lpobj, hInst))
            goto errRtn;
#ifdef OLD
        if (!lpobj->bOleServer && (cmd == LN_LNKACT))
            return TRUE;
#endif
    }

    if (!lpobj->bOldLink) {
        cmd = lpobj->fCmd & LN_MASK;
        len =  lstrlen (srvrSysCmd[cmd >> LN_SHIFT]);

        // for template and new, add the class name also
        if (cmd == LN_NEW || cmd == LN_TEMPLATE)
            len += GlobalGetAtomLen (lpobj->app);

        // Now add the document length.
        len += GlobalGetAtomLen (lpobj->topic);

        // add the length of the template name
        if (lptemplate)
            len += lstrlen (lptemplate);

        // now add the fudge factor for the Quotes etc.
        len += LN_FUDGE;

        // allocate the buffer and set the command.
        hdata = GlobalAlloc (GMEM_DDESHARE, size = len);

        retval = OLE_ERROR_MEMORY;
        SETERRHINT(lpobj, OLE_ERROR_MEMORY);

        if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
            goto errRtn;
    }

    lstrcpy (lpdata, (LPSTR)"[");           // [
    lstrcat (lpdata, srvrSysCmd[cmd >> LN_SHIFT]);      // [Std....
    lstrcat (lpdata, "(\"");                // [std...("

    if (cmd == LN_NEW  || cmd == LN_TEMPLATE) {
        len = lstrlen (lpdata);
        GlobalGetAtomName (lpobj->app, (LPSTR)lpdata + len, size - len);
                                            // [std...("class
        lstrcat (lpdata, "\",\"");          // [std...("class", "
    }
    len = lstrlen (lpdata);
    // now get the topic name.
    GlobalGetAtomName (lpobj->topic, lpdata + len, (UINT)size - len);
                                            // [std...("class","doc
    if (lptemplate) {
        lstrcat (lpdata, "\",\"");          // [std...("class","doc","
        lstrcat  (lpdata, lptemplate);      // [std...("class","doc","temp
    }

    lstrcat (lpdata, "\")]");               // [std...("class","doc","temp")]

    GlobalUnlock (hdata);

    // !!!optimize with mapping.
    SETERRHINT(lpobj, (OLE_ERROR_TEMPLATE + (cmd >> LN_SHIFT)));

    return SrvrExecute (lpobj, hdata);

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    lpobj->subErr = retval;
    return FALSE;
}




// ExtendAtom: Create a new atom, which is the old one plus extension

ATOM INTERNAL ExtendAtom (
    LPOBJECT_LE lpobj,
    ATOM    item
){
    char    buffer[MAX_ATOM+1];
    LPSTR   lpext;

    Puts("ExtendAtom");

    buffer[0] = 0;
    if (item)
        GlobalGetAtomName (item, buffer, MAX_ATOM);

    switch (lpobj->optUpdate) {


        case oleupdate_always:
            lpext = (LPSTR)"";
            break;

        case oleupdate_onsave:
            lpext = (LPSTR)"/Save";
            break;

        case oleupdate_onclose:
            lpext = (LPSTR)"/Close";
            break;

        default:
            ASSERT (FALSE, "on call options not expected here");
            break;

    }

    lstrcat (buffer, lpext);
    if (buffer[0])
        return GlobalAddAtom (buffer);
    else
        return (ATOM)0;
}


BOOL INTERNAL CreatePictObject (
    LHCLIENTDOC     lhclientdoc,
    LPSTR           lpobjname,
    LPOBJECT_LE     lpobj,
    OLEOPT_RENDER   optRender,
    OLECLIPFORMAT   cfFormat,
    LPCSTR          lpclass
){
    LPOLEOBJECT lpPictObj = NULL;
    ATOM        aClass;

    lpobj->lpobjPict = NULL;
    if (optRender == olerender_format) {
        switch (cfFormat) {
            case 0:
                return FALSE;

            case CF_ENHMETAFILE:
                if (!(lpPictObj = (LPOLEOBJECT) EmfCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE)))
                return FALSE;

            case CF_METAFILEPICT:
                if (!(lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;

            case CF_DIB:
                if (!(lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;

            case CF_BITMAP:
                if (!(lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;

            default:
                aClass = GlobalAddAtom (lpclass);
                if (!(lpPictObj = (LPOLEOBJECT) GenCreateBlank (lhclientdoc,
                                            lpobjname, CT_PICTURE, aClass)))
                    return FALSE;

                ((LPOBJECT_GEN)lpPictObj)->cfFormat = cfFormat;
                break;
        }
    }
    else if (optRender == olerender_draw) {
#ifdef WIN32HACK
          if (!(lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE)))
                return FALSE;
#else
          if (!(lpPictObj = (LPOLEOBJECT) EmfCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE)))
                return FALSE;
#endif
#ifdef LATER
        if (AdviseOn (lpobj, (cfFormat = CF_METAFILEPICT), NULL))
            lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE);
        // !!! for the time being take assume we need to get metafile.
        else if (AdviseOn (lpobj, (cfFormat = CF_DIB), NULL))
            lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE);
        else if (AdviseOn (lpobj, (cfFormat = CF_BITMAP), NULL))
            lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc,
                                                lpobjname, CT_PICTURE);
        else
            goto errPict;
#endif

    }
    else
        return (optRender == olerender_none);

    if (lpobj->lpobjPict = lpPictObj)
        lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    return TRUE;
}


OLESTATUS LnkChangeLnk (LPOBJECT_LE lpobj)
{

    switch (lpobj->subRtn) {

        case 0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);

            // now try to activate the new link.
            SKIP_TO (!InitDocConv (lpobj, !POPUP_NETDLG), step3);
            lpobj->fCmd = LN_LNKACT | ACT_ADVISE | ACT_REQUEST;
            InitAsyncCmd (lpobj, OLE_SETDATA, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);

        case    3:
            step3:
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS INTERNAL ChangeDocAndItem (
    LPOBJECT_LE lpobj,
    HANDLE      hinfo
){
    LPSTR       lpinfo;
    ATOM        aNewTopic, aNewItem = (ATOM)0, aOldTopic;
    OLESTATUS   retVal = OLE_ERROR_BLANK;

    PROBE_SVRCLOSING(lpobj);

    if (!(lpinfo = GlobalLock (hinfo)))
        return OLE_ERROR_MEMORY;

    lpinfo += lstrlen (lpinfo) + 1;
    aNewTopic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        aNewItem = GlobalAddAtom (lpinfo);

    if (!aNewTopic && (lpobj->head.ctype == CT_LINK))
        goto errRtn;

    aOldTopic = lpobj->topic;
    lpobj->topic = aNewTopic;
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        goto errRtn;
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);

    if (lpobj->item)
        GlobalDeleteAtom (lpobj->item);

    lpobj->item = aNewItem;

    // As the atoms have already changed, lpobj->hLink becomes irrelevant.
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    GlobalUnlock(hinfo);

    // Now disconnect the old link and try to connect to the new one.
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETDATA, LNKCHANGELNK);
    return LnkChangeLnk (lpobj);

errRtn:

    if (aNewItem)
        GlobalDeleteAtom (aNewItem);

    GlobalUnlock (hinfo);
    return retVal;
}


BOOL    QueryUnlaunch (LPOBJECT_LE lpobj)
{
    if (!(lpobj->fCmd & ACT_UNLAUNCH))
        return FALSE;

    // only if we loaded the app
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient && lpobj->pSysEdit->hInst)
        return TRUE;

    return FALSE;
}


BOOL     QueryClose (LPOBJECT_LE lpobj)
{
    if (!((lpobj->fCmd & ACT_UNLAUNCH) ||
            (lpobj->head.ctype == CT_EMBEDDED)))
        return FALSE;

    // only if we loaded the documnet
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
        return TRUE;

    return FALSE;
}


OLESTATUS INTERNAL SetHostNamesHandle (
    LPOBJECT_LE lpobj,
    LPSTR       lpclientName,
    LPSTR       lpdocName
){
    UINT        cbClient;
    UINT        size;
    HANDLE      hhostNames      = NULL;
    LPHOSTNAMES lphostNames     = NULL;
    LPSTR       lpdata;

    // 4 bytes  is for the two offsets
    size = (cbClient = lstrlen(lpclientName)+1) + (lstrlen(lpdocName)+1) + 2*sizeof(UINT);

    if ((hhostNames = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size))
            == NULL)
        goto errRtn;

    if ((lphostNames = (LPHOSTNAMES)GlobalLock (hhostNames)) == NULL)
        goto errRtn;

    lphostNames->clientNameOffset = 0;
    lphostNames->documentNameOffset = (WORD)cbClient;

    lpdata = (LPSTR)lphostNames->data;
    lstrcpy (lpdata, lpclientName);
    lstrcpy (lpdata + cbClient, lpdocName);
    if (lpobj->hhostNames)
        GlobalFree ( lpobj->hhostNames);
    GlobalUnlock (hhostNames);
    lpobj->hhostNames = hhostNames;
    return OLE_OK;

errRtn:
    if (lphostNames)
        GlobalUnlock (hhostNames);

    if (hhostNames)
        GlobalFree (hhostNames);

    return  OLE_ERROR_MEMORY;
}


#if 0
OLESTATUS  FARINTERNAL LeAbort (LPOBJECT_LE lpobj)
{


    BOOL        bAbort = FALSE;
    PEDIT_DDE   pedit;


    // check whether the any transaction pending for
    // the document level.

    //  channel open
    //  any transaction pending.
    //  and we are not in terminate mode.


    if ((pedit = lpobj->pDocEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        // delete any data we need to delete. Ricght now
        // we kill only the timer. We can not delete any
        // since the server could potentially look at the data.

        DeleteAbortData (lpobj, pedit);
    }

    if ((pedit = lpobj->pSysEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        DeleteAbortData (lpobj, pedit);

    }

    if (!bAbort)
        return OLE_OK;

    // Now send the EndAsync
    lpobj->mainErr = OLE_ERROR_ABORT;
    EndAsyncCmd (lpobj);
    return OLE_OK;

}
#endif


OLESTATUS  FARINTERNAL ProbeAsync(LPOBJECT_LE lpobj)
{

    if (lpobj->asyncCmd == OLE_NONE)
        return OLE_OK;

    if (!IsServerValid (lpobj)) {

        // Now send the EndAsync
        lpobj->mainErr = OLE_ERROR_TASK;
        EndAsyncCmd (lpobj);
        return OLE_OK;
    }

    return OLE_BUSY;
}


BOOL    INTERNAL IsWindowValid (HWND hwnd)
{

#define TASK_OFFSET 0x00FA

    HANDLE  htask;

    if (!IsWindow (hwnd))
        return FALSE;

    // now get the task handle and find out it is valid.
    htask  = GetWindowTask (hwnd);

#ifdef WIN16
{
    LPSTR   lptask;
    if (bWLO)
        return TRUE;

    if ((wWinVer == 0x0003) || !lpfnIsTask) {
        lptask = (LPSTR)(MAKELONG (TASK_OFFSET, htask));

        if (!FarCheckPointer(lptask, READ_ACCESS))
            return FALSE;

        // now check for the signature bytes of task block in kernel
        if (*lptask++ == 'T' && *lptask == 'D')
            return TRUE;
    }
    else {
        // From win31 onwards the API IsTask can be used for task validation
        if ((*lpfnIsTask)(htask))
            return TRUE;
    }
}
#endif

#ifdef WIN32
//   if (IsTask(htask))
      return TRUE;
#endif

    return FALSE;
}



BOOL    INTERNAL IsServerValid (LPOBJECT_LE lpobj)
{

    MSG msg;
    BOOL    retval = FALSE;


    if (lpobj->pDocEdit && lpobj->pDocEdit->hServer) {

        retval = TRUE;

        if (!IsWindowValid (lpobj->pDocEdit->hServer)) {
            if (!PeekMessage ((LPMSG)&msg, lpobj->pDocEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                            PM_NOREMOVE | PM_NOYIELD)){
#ifdef  FIREWALLS
                ASSERT (FALSE, "Server truely died");
#endif
                return FALSE;
            }

        }

    }

    if (lpobj->pSysEdit && lpobj->pSysEdit->hServer) {
        retval = TRUE;

        if (!IsWindowValid (lpobj->pSysEdit->hServer)) {

            if (!PeekMessage ((LPMSG)&msg, lpobj->pSysEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                                PM_NOREMOVE | PM_NOYIELD)){
#ifdef  FIREWALLS
                ASSERT (FALSE, "Server truely died");
#endif
                return FALSE;

            }


        }
    }

   return retval;
}


OLESTATUS FARINTERNAL LeExecute (
    LPOLEOBJECT lpoleobj,
    HANDLE      hCmds,
    UINT        wReserve
){
    LPOBJECT_LE lpobj = (LPOBJECT_LE)lpoleobj;

    UNREFERENCED_PARAMETER(wReserve);

    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);

    if (!(lpobj =  (*lpobj->head.lpvtbl->QueryProtocol) (lpoleobj,
                                            PROTOCOL_EXECUTE)))
        return OLE_ERROR_PROTOCOL;

    if (!QueryOpen (lpobj))
        return OLE_ERROR_NOT_OPEN;

    if (!(hCmds = DuplicateGlobal (hCmds, GMEM_MOVEABLE|GMEM_DDESHARE)))
        return OLE_ERROR_MEMORY;

    InitAsyncCmd (lpobj, OLE_OTHER, 0);
    SETERRHINT(lpobj, OLE_ERROR_COMMAND);
    if (DocExecute(lpobj, hCmds))
        return OLE_WAIT_FOR_RELEASE;
    else
        return OLE_ERROR_COMMAND;
}


void INTERNAL FreeGDIdata (
    HANDLE          hData,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }

    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);

    else if (cfFormat == CF_DIB)
        GlobalFree (hData);

    else if (cfFormat == CF_ENHMETAFILE)
        DeleteEnhMetaFile(hData);

}

// This routine figures out whether the handle to data block can be copied
// to DDEPOKE block rather than the contents of the handle

BOOL INTERNAL CanPutHandleInPokeBlock (
    LPOBJECT_LE     lpobj,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_BITMAP || cfFormat == CF_DIB || cfFormat == CF_ENHMETAFILE)
        return TRUE;

    if (cfFormat == CF_METAFILEPICT) {
        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && lpobj->app == aMSDraw)
            return FALSE;

        return TRUE;
    }

    return FALSE;
}

// MakeMFfromEMF()
// make a metafile from and enhanced metafile

HMETAFILE MakeMFfromEMF (
   HENHMETAFILE hemf
){
    HANDLE hBytes;
    LPBYTE lpBytes = NULL;
    LONG   lSizeBytes;
    HDC    hdc = GetDC(NULL);
    HMETAFILE    hmf = NULL;

    if (!(lSizeBytes = GetWinMetaFileBits((HENHMETAFILE)hemf, 0, NULL, MM_ANISOTROPIC, hdc)) ) {
        if (hdc) ReleaseDC(NULL, hdc);
        return NULL;
    }

    if (!(hBytes = GlobalAlloc(GHND, lSizeBytes)) )
        goto error;

    if (!(lpBytes = (LPBYTE)GlobalLock(hBytes)) )
        goto error;

    GetWinMetaFileBits((HENHMETAFILE)hemf, lSizeBytes, lpBytes, MM_ANISOTROPIC, hdc);

#ifdef NOBUGS
    if (GetWinMetaFileBits(((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf, lSizeBytes, lpBytes, MM_ANISOTROPIC, hdc) != lSizeBytes) {
        retval = OLE_ERROR_METAFILE;
        goto error;
    }
#endif

    (HMETAFILE)hmf = SetMetaFileBitsEx(lSizeBytes,lpBytes);

error:
    if (lpBytes)
        GlobalUnlock(hBytes);

    if (hBytes)
        GlobalFree(hBytes);

    if (hdc)
      ReleaseDC(NULL, hdc);

    return hmf;
}


// MakeMFPfromEMF()
// make a metafile picture structure from an enhanced metafile

HANDLE MakeMFPfromEMF (
   HENHMETAFILE hemf,
   HANDLE hmf

){
    HANDLE         hmfp;
    LPMETAFILEPICT lpmfp = NULL;
    ENHMETAHEADER  enhmetaheader;

    if (GetEnhMetaFileHeader((HENHMETAFILE)hemf, sizeof(enhmetaheader), &enhmetaheader) == GDI_ERROR)
        goto error;

    if (!(hmfp = GlobalAlloc(GHND, sizeof(METAFILEPICT))) )
        goto error;

    if (!(lpmfp = (LPMETAFILEPICT)GlobalLock(hmfp)) )
        goto error;

    lpmfp->xExt = enhmetaheader.rclFrame.right - enhmetaheader.rclFrame.left;
    lpmfp->yExt = enhmetaheader.rclFrame.bottom - enhmetaheader.rclFrame.top;
    lpmfp->mm   = MM_ANISOTROPIC;
    lpmfp->hMF  = hmf;

    GlobalUnlock(hmfp);
    return hmfp;

error:

    if (lpmfp)
        GlobalUnlock(hmfp);

    if (hmfp)
        GlobalFree(hmfp);

    return NULL;

}

// ChangeEMFtoMF
// Change and enhanced metafile object to a metafile object

BOOL INTERNAL ChangeEMFtoMF(
    LPOBJECT_LE   lpobj
){
    HMETAFILE      hmf;
    HANDLE         hmfp = NULL;
    LPOBJECT_MF    lpobjMF;
    char           szobjname[MAX_ATOM];
    DWORD          dwSize = MAX_ATOM;


    // the blank picture case

    if (!((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf) {
        GlobalGetAtomName(lpobj->head.aObjName, (LPSTR)szobjname, dwSize);
        if (!(lpobjMF = MfCreateBlank (lpobj->head.lhclientdoc, (LPSTR)szobjname, CT_PICTURE)))
             return FALSE;
        EmfRelease(lpobj->lpobjPict);
        lpobj->lpobjPict = (LPOLEOBJECT)lpobjMF;
        return TRUE;
    }

    // the normal case

    if (!(hmf = MakeMFfromEMF(((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf)) )
        goto error;

    if (!(hmfp = MakeMFPfromEMF(((LPOBJECT_EMF)(lpobj->lpobjPict))->hemf, hmf)) )
        goto error;

    GlobalGetAtomName(lpobj->head.aObjName, (LPSTR)szobjname, dwSize);

    if (!(lpobjMF = MfCreateObject(
         hmfp,
         lpobj->head.lpclient,
         TRUE,
         lpobj->head.lhclientdoc,
         szobjname,
         CT_PICTURE
    ))) goto error;

    EmfRelease(lpobj->lpobjPict);
    lpobj->lpobjPict = (LPOLEOBJECT)lpobjMF;

    return TRUE;

error:

    if (hmf)
        DeleteMetaFile((HMETAFILE)hmf);

    if (hmfp)
        GlobalFree(hmfp);

    return FALSE;

}

BOOL INTERNAL ChangeEMFtoMFneeded(LPOBJECT_LE lpobj, ATOM advItem)
{

   lpobj->bNewPict = FALSE;
   if (lpobj->subErr && CF_ENHMETAFILE == GetPictType(lpobj)) {
      CLEAR_STEP_ERROR (lpobj);

      if (advItem == aClose)
         lpobj->pDocEdit->nAdviseClose--;
      else if (advItem == aSave)
         lpobj->pDocEdit->nAdviseSave--;

      AdviseOn (lpobj, CF_METAFILEPICT, advItem);
      lpobj->bNewPict = TRUE;
      return TRUE;
   }
   else
   {
      lpobj->subRtn++;
      return FALSE;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\mf.c ===
/****************************** Module Header ******************************\
* Module Name:MF.C (Extensible Compound Documents - Metafile)
*
* PURPOSE:Handles all API routines for the metafile sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*
*   Raor, Srinik    (../../1990,91)  Designed, coded
*   Curts create NT version
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

WORD    wGDIds = 0;
OLESTATUS FARINTERNAL wCreateDummyMetaFile (LPOBJECT_MF, int, int);

#ifdef WIN16
#pragma alloc_text(_TEXT, MfSaveToStream, MfLoadFromStream, GetBytes, PutBytes, PutStrWithLen, MfQueryBounds, OleIsDcMeta, GetGDIds, IsMetaDC)
#endif

OLEOBJECTVTBL    vtblMF = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        MfRelease,         // Release
        ErrShow,           // show
        ErrPlay,           // play
        MfGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//
        ErrSetBounds,      // set viewport bounds
        MfEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //
        MfRelease,         // delete
        ErrSetHostNames,   //

        MfSaveToStream,    // write to file
        MfClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Lnk

        MfEqual,           // compares the given objects for data equality

        MfCopy,            // copy to clip

        MfDraw,            // draw the object

        ErrActivate,       // open
        ErrExecute,        // excute
        ErrClose,          // stop
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name
        ObjQueryType,      // Object type
        MfQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current

        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryReleaseMethod,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        MfChangeData       // change data of the existing object
};




OLESTATUS FARINTERNAL  MfRelease (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;
    HOBJECT hobj;

    if (lpobj->mfp.hMF) {
        DeleteMetaFile (lpobj->mfp.hMF);
        lpobj->mfp.hMF = NULL;
    }

    if (lpobj->hmfp)
        GlobalFree (lpobj->hmfp);

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT)lpobj);

    if (hobj = lpobj->head.hobj) {
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}


OLESTATUS FARINTERNAL  MfSaveToStream (
    LPOLEOBJECT lpoleobj,
    LPOLESTREAM lpstream
){
    DWORD       dwFileVer = GetFileVersion(lpoleobj);
    LPOBJECT_MF lpobj     = (LPOBJECT_MF)lpoleobj;
    OLESTATUS   retVal    = OLE_ERROR_STREAM;
    HANDLE      hBits;
    LPSTR       lpBits;
    LONG        lSizeBytes;

    lSizeBytes = lpobj->sizeBytes - sizeof(METAFILEPICT)
                                  + sizeof(WIN16METAFILEPICT);

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    if (PutBytes (lpstream, (LPSTR) &dwFileVer, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"METAFILEPICT"))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lSizeBytes, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (!(hBits = MGetMetaFileBits (lpobj->mfp.hMF)))
        return OLE_ERROR_MEMORY;

    if (lpBits = (LPSTR) GlobalLock (hBits)) {
        WIN16METAFILEPICT   w16mfp;

        ConvertMF32to16(&lpobj->mfp, &w16mfp);

        if (!PutBytes (lpstream, (LPSTR)&w16mfp, sizeof(WIN16METAFILEPICT)))
            if (!PutBytes (lpstream, (LPSTR)lpBits,
                        lSizeBytes - sizeof(WIN16METAFILEPICT)))
                retVal = OLE_OK;

        GlobalUnlock(hBits);
    }
    else
        retVal = OLE_ERROR_MEMORY;

    lpobj->mfp.hMF = MSetMetaFileBits (hBits);
    return retVal;
}




OLESTATUS FARINTERNAL  MfClone (
    LPOLEOBJECT       lpoleobjsrc,
    LPOLECLIENT       lpclient,
    LHCLIENTDOC       lhclientdoc,
    OLE_LPCSTR        lpobjname,
    LPOLEOBJECT FAR * lplpoleobj
){
    LPOBJECT_MF lpobjsrc = (LPOBJECT_MF)lpoleobjsrc;
    LPOBJECT_MF lpobjMf;
    HANDLE      hmf;

    *lplpoleobj = (LPOLEOBJECT)NULL;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    if (!(hmf = CopyMetaFile (lpobjsrc->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    if (lpobjMf = MfCreateBlank (lhclientdoc, (LPSTR)lpobjname,
                        lpobjsrc->head.ctype)) {
        lpobjMf->mfp            = lpobjsrc->mfp;
        lpobjMf->sizeBytes      = lpobjsrc->sizeBytes;
        lpobjMf->mfp.hMF        = hmf;
        lpobjMf->head.lpclient  = lpclient;
        lpobjMf->head.mm        = lpobjMf->mfp.mm;
        MfSetExtents (lpobjMf);

        *lplpoleobj = (LPOLEOBJECT)lpobjMf;
        return OLE_OK;
    }

    return OLE_ERROR_MEMORY;
}



OLESTATUS FARINTERNAL  MfEqual (
    LPOLEOBJECT lpoleobj1,
    LPOLEOBJECT lpoleobj2
){
    LPOBJECT_MF lpobj1 = (LPOBJECT_MF)lpoleobj1;
    LPOBJECT_MF lpobj2 = (LPOBJECT_MF)lpoleobj2;
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    OLESTATUS   retval = OLE_ERROR_NOT_EQUAL;

    if (!(hBits1 = MGetMetaFileBits (lpobj1->mfp.hMF)))
        goto errEqual;

    if (!(hBits2 = MGetMetaFileBits (lpobj2->mfp.hMF)))
        goto errEqual;

    if (CmpGlobals (hBits1, hBits2))
        retval = OLE_OK;

errEqual:
    if (hBits1)
        lpobj1->mfp.hMF = MSetMetaFileBits (hBits1);

    if (hBits2)
        lpobj2->mfp.hMF = MSetMetaFileBits (hBits2);

    return retval;
}


OLESTATUS FARINTERNAL  MfCopy (LPOLEOBJECT lpoleobj)
{
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;
    HANDLE      hMF;

    if (!(hMF = CopyMetaFile (lpobj->mfp.hMF, NULL)))
        return OLE_ERROR_MEMORY;

    return (MfCopyToClip (lpobj, hMF));
}



OLESTATUS FARINTERNAL MfQueryBounds (
    LPOLEOBJECT lpoleobj,
    LPRECT      lpRc
){
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;
    Puts("MfQueryBounds");

    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    // Bounds are given in MM_HIMETRIC mode.

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL  MfEnumFormat (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat
){
    LPOBJECT_MF   lpobj = (LPOBJECT_MF)lpoleobj;

    if (!cfFormat)
        return CF_METAFILEPICT;

    return 0;
}


OLESTATUS FARINTERNAL MfGetData (
    LPOLEOBJECT   lpoleobj,
    OLECLIPFORMAT cfFormat,
    LPHANDLE      lphandle
){
    LPOBJECT_MF lpobj = (LPOBJECT_MF)lpoleobj;

    if (cfFormat != CF_METAFILEPICT)
        return OLE_ERROR_FORMAT;

    if (!(*lphandle = GetHmfp (lpobj)))
        return OLE_ERROR_BLANK;

    return OLE_OK;
}


LPOBJECT_MF FARINTERNAL  MfCreateObject (
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete,
    LHCLIENTDOC     lhclientdoc,
    LPCSTR          lpobjname,
    LONG            objType
){
    LPOBJECT_MF     lpobj;

    if (lpobj = MfCreateBlank (lhclientdoc, (LPSTR)lpobjname, objType)) {
        if (MfChangeData ((LPOLEOBJECT)lpobj, hMeta, lpclient, fDelete) != OLE_OK) {
            MfRelease ((LPOLEOBJECT)lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}

// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hMeta, and the hMF it contains will be deleted
// whether the routine is successful or not.

OLESTATUS FARINTERNAL MfChangeData (
    LPOLEOBJECT     lpoleobj,
    HANDLE          hMeta,
    LPOLECLIENT     lpclient,
    BOOL            fDelete
){
    LPOBJECT_MF     lpobj = (LPOBJECT_MF)lpoleobj;
    HANDLE          hNewMF;
    LPMETAFILEPICT  lpMetaPict;

    if ((lpMetaPict = (LPMETAFILEPICT) GlobalLock (hMeta)) == NULL) {
        if (fDelete)
            GlobalFree (hMeta);
        return OLE_ERROR_MEMORY;
    }

    GlobalUnlock (hMeta);

    if (!fDelete) {
        if (!(hNewMF = CopyMetaFile (lpMetaPict->hMF, NULL)))
            return OLE_ERROR_MEMORY;
    }
    else {
        hNewMF = lpMetaPict->hMF;
    }

    return MfUpdateStruct (lpobj, lpclient, hMeta, lpMetaPict, hNewMF, fDelete);
}


OLESTATUS INTERNAL MfUpdateStruct (
    LPOBJECT_MF     lpobj,
    LPOLECLIENT     lpclient,
    HANDLE          hMeta,
    LPMETAFILEPICT  lpMetaPict,
    HANDLE          hMF,
    BOOL            fDelete
){
    OLESTATUS   retVal;
    DWORD       size;
    HANDLE      hOldMF;

    hOldMF = lpobj->mfp.hMF;

    ASSERT(lpMetaPict->mm == MM_ANISOTROPIC, "Wrong mapping mode")
    if (lpMetaPict->mm != MM_ANISOTROPIC)
        retVal = OLE_ERROR_METAFILE;
    else if (!(size = MfGetSize (&hMF)))
        retVal = OLE_ERROR_BLANK;
    else {
        lpobj->mfp     = *lpMetaPict;
        lpobj->mfp.hMF = hMF;
        lpobj->sizeBytes = size + sizeof(METAFILEPICT);
        lpobj->head.lpclient = lpclient;
        lpobj->head.mm = lpobj->mfp.mm;
        if (lpobj->hmfp) {
            GlobalFree (lpobj->hmfp);
            lpobj->hmfp = NULL;
        }
        MfSetExtents (lpobj);
        if (hOldMF)
            DeleteMetaFile (hOldMF);
        retVal =  OLE_OK;
    }

    if (retVal != OLE_OK)
        DeleteMetaFile (hMF);

    if (fDelete)
        GlobalFree (hMeta);
    return retVal;
}


LPOBJECT_MF FARINTERNAL MfCreateBlank(
    LHCLIENTDOC lhclientdoc,
    LPSTR       lpobjname,
    LONG        objType
){
    HOBJECT     hobj;
    LPOBJECT_MF lpobj;

    if(!(hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_MF))))
        return NULL;

    if (!(lpobj = (LPOBJECT_MF) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblMF;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.hobj        = hobj;

    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc,
                    (LPOLEOBJECT) lpobj, lpobjname);

    // Unlock will be done at object deletion time.
    return lpobj;
}


OLESTATUS  FARINTERNAL  MfLoadFromStream (
    LPOLESTREAM         lpstream,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType
){
    LPOLEOBJECT  lpoleobj  = NULL;
    OLESTATUS    retval    = OLE_ERROR_STREAM;
    HANDLE       hBytes    = NULL;
    LPSTR        lpBytes   = NULL;
    DWORD        dwSizeBytes;
    METAFILEPICT mfp;


    // Class name would've been read by this time.

    *lplpobj = NULL;

    switch (HIWORD(dwVerFromFile)) {

         case OS_WIN32:
            if (!(lpoleobj = (LPOLEOBJECT)EmfCreateBlank (lhclientdoc, lpobjname, objType)))
               return OLE_ERROR_MEMORY;
            break;

         case OS_WIN16:
         case OS_MAC:
            if (!(lpoleobj = (LPOLEOBJECT)MfCreateBlank (lhclientdoc, lpobjname, objType)))
               return OLE_ERROR_MEMORY;
            break;

         default:
            return OLE_ERROR_FILE_VER;

    }

    lpoleobj->lpclient = lpclient;

    if (GetBytes (lpstream, (LPSTR) &lpoleobj->cx, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &lpoleobj->cy, sizeof(LONG)))
        goto error;

    if (GetBytes (lpstream, (LPSTR) &dwSizeBytes, sizeof(LONG)))
        goto error;

    if (!dwSizeBytes) {
        retval = OLE_ERROR_BLANK;
        goto error;
    }

    // if we are reading a MAC object we want to skip this
    if (HIWORD(dwVerFromFile) != OS_MAC) {
        WIN16METAFILEPICT w16mfp;

        if (GetBytes (lpstream, (LPSTR) &w16mfp, sizeof(WIN16METAFILEPICT)))
            goto error;

        ConvertMF16to32(&w16mfp, &mfp);
    }


    retval       = OLE_ERROR_MEMORY;
    dwSizeBytes -= sizeof(WIN16METAFILEPICT);

    if (!(hBytes = GlobalAlloc (GMEM_MOVEABLE, dwSizeBytes)))
        goto error;

    if (!(lpBytes = (LPSTR)GlobalLock (hBytes)))
        goto error;

    if (GetBytes (lpstream, (LPSTR)lpBytes, dwSizeBytes))
        goto error;

    switch (HIWORD(dwVerFromFile)){

      case OS_WIN32: {
        LPOBJECT_EMF lpemfobj = (LPOBJECT_EMF)lpoleobj;

        lpemfobj->sizeBytes = dwSizeBytes;
        if (!((HENHMETAFILE)lpemfobj->hemf = SetWinMetaFileBits(dwSizeBytes, lpBytes, 0 , &mfp)))
            goto error;
        EmfSetExtents (lpemfobj);

        break;
      }

      case OS_WIN16: {
         LPOBJECT_MF lpmfobj = (LPOBJECT_MF)lpoleobj;
		
        lpmfobj->mfp =  mfp;
        lpmfobj->sizeBytes = dwSizeBytes + sizeof(METAFILEPICT);
        lpmfobj->head.mm = lpmfobj->mfp.mm;
		GlobalUnlock (hBytes);
		lpBytes = NULL;
        if (!(lpmfobj->mfp.hMF = MSetMetaFileBits(hBytes)))
            goto error;
		hBytes = NULL;
        MfSetExtents (lpmfobj);

        break;
      }

      case OS_MAC: {
        LPOBJECT_MF lpmfobj = (LPOBJECT_MF)lpoleobj;

        lpmfobj->mfp.xExt = (int) lpmfobj->head.cx;
        lpmfobj->mfp.yExt = (int) lpmfobj->head.cy;

        if ((retval = wCreateDummyMetaFile (lpmfobj, lpmfobj->mfp.xExt,
                                   lpmfobj->mfp.yExt)) != OLE_OK)
            goto error;

        break;
      }

    }

    *lplpobj = lpoleobj;
    retval   = OLE_OK;

error:

    if (hBytes)
    {
        if (lpBytes)
            GlobalUnlock (hBytes);
        GlobalFree (hBytes);
    }

    if (retval != OLE_OK)
      OleDelete (lpoleobj);

    return retval;
}




OLESTATUS FARINTERNAL  MfPaste (
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    LONG                objType
){
    HANDLE      hMeta;

    *lplpoleobject = NULL;

    if((hMeta = GetClipboardData (CF_METAFILEPICT)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) MfCreateObject (hMeta, lpclient,
                                                FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    return OLE_OK;
}




OLESTATUS INTERNAL MfCopyToClip (
    LPOBJECT_MF lpobj,
    HANDLE      hMF
){
    LPMETAFILEPICT  lpMeta;
    HANDLE          hMeta;

    if (!(hMeta = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return OLE_ERROR_MEMORY;

    if (lpMeta = (LPMETAFILEPICT) GlobalLock(hMeta)){
        *lpMeta = lpobj->mfp;
        if (hMF)
            lpMeta->hMF = hMF;
        else
            lpobj->mfp.hMF = NULL;
        GlobalUnlock (hMeta);
        SetClipboardData(CF_METAFILEPICT, hMeta);
        return OLE_OK;
    }

    GlobalFree(hMeta);
    return OLE_ERROR_MEMORY;
}



void FARINTERNAL MfSetExtents (LPOBJECT_MF lpobj)
{
    if (lpobj->mfp.xExt > 0) {
        // The extents are assumed to be in MM_HIMETIRC units
        lpobj->head.cx = (LONG) lpobj->mfp.xExt;
        lpobj->head.cy = (LONG) - lpobj->mfp.yExt;
    }
}


DWORD INTERNAL MfGetSize (LPHANDLE lphmf)
{
    HANDLE hBits;
    DWORD  size;

    if ((hBits = MGetMetaFileBits (*lphmf)) == NULL)
        return 0;

    size = (DWORD)GlobalSize(hBits);
    *lphmf = MSetMetaFileBits (hBits);
    return size;
}



HANDLE INTERNAL GetHmfp (LPOBJECT_MF lpobj)
{
    HANDLE          hmfp;
    LPMETAFILEPICT  lpmfp = NULL;

    if (lpobj->hmfp)
        return lpobj->hmfp;

    if (!(hmfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        return NULL;

    if (!(lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp))) {
        GlobalFree (hmfp);
        return NULL;
    }

    *lpmfp = lpobj->mfp;
    GlobalUnlock (hmfp);
    return (lpobj->hmfp = hmfp);
}



OLESTATUS FARINTERNAL wCreateDummyMetaFile (
    LPOBJECT_MF     lpobj,
    int             xExt,
    int             yExt
){
    HDC hMetaDC;

    if (!(hMetaDC = CreateMetaFile (NULL)))
        return OLE_ERROR_MEMORY;

    MSetWindowOrg (hMetaDC, 0, 0);
    MSetWindowExt (hMetaDC, xExt, yExt);
    Rectangle (hMetaDC, 0, 0, xExt, yExt);
    if (!(lpobj->mfp.hMF = CloseMetaFile (hMetaDC)))
        return OLE_ERROR_MEMORY;
    lpobj->mfp.mm    = MM_ANISOTROPIC;
    lpobj->sizeBytes = MfGetSize ( (LPHANDLE) &lpobj->mfp.hMF) + sizeof(METAFILEPICT);
    return OLE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\ole.c ===
/******************************* Module Header *******************************
* Module Name: OLE.C
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* PURPOSE: API routines for handling generic objects (which may be static,
*    linked, or embedded).  These routines will be made into a DLL.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik  (../../90, 91)    Designed/coded.
*   curts created portable version for WIN16/32
*
*****************************************************************************/

#include <windows.h>

#include "dll.h"

extern DLL_ENTRY        lpDllTable[];
extern char             packageClass[];
extern OLECLIPFORMAT    cfFileName;
extern DWORD            dwOleVer;

DWORD           dwVerFromFile;
HANDLE          hInfo = NULL;
CLIENTDOC       lockDoc = {{'C', 'D'}, 0L, 0L, 0, 0, 0, 0L, 0L};
LHCLIENTDOC     lhLockDoc = (LHCLIENTDOC) ((LPCLIENTDOC) &lockDoc);
BOOL            gbCreateInvisible = FALSE;
BOOL            gbLaunchServer;

OLESTATUS INTERNAL LockServer (LPOBJECT_LE);

#ifdef WIN16
#pragma alloc_text(_DDETEXT, OleLockServer, OleUnlockServer, LockServer, IsServerValid, DeleteSrvrEdit, InitSrvrConv, LeLaunchApp)
#endif

#ifdef USE_FILE_VERSION_APIS
//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleSetFileVer ()
//
//////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL OleSetFileVer (
    LHCLIENTDOC lhclientdoc,
    WORD        wFileVer
){
   LPCLIENTDOC lpclientdoc = (LPCLIENTDOC)lhclientdoc;
char lpstr[256];

   switch (wFileVer)
   {
      case OS_WIN16:
      case OS_WIN32:
         lpclientdoc->dwFileVer = (DWORD)MAKELONG(wReleaseVer,wFileVer);
         return OLE_OK;
      default:
         return OLE_ERROR_FILE_VER;
    }

}

//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleQueryFileVer ()
//
//////////////////////////////////////////////////////////////////////////////


DWORD FAR PASCAL OleQueryFileVer (
    LPCLIENTDOC lpclientdoc
){

    return (lpclientdoc->dwFileVer);

}

#endif

//////////////////////////////////////////////////////////////////////////////
//
//  LPVOID FAR PASCAL OleQueryProtocol (lpobj, lpprotocol)
//
//  Tells whether the object supports the specified protocol.
//
//  Arguments:
//
//      lpobj       -   object pointer
//      lpprotocol  -   protocol string
//
//  Returns:
//
//      long ptr to object if the protocol is supported
//      NULL if not.
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


LPVOID FAR PASCAL OleQueryProtocol (
    LPOLEOBJECT lpobj,
    LPCSTR       lpprotocol
){
    if (!CheckObject(lpobj))
        return NULL;

    return (*lpobj->lpvtbl->QueryProtocol) (lpobj, lpprotocol);
}



//////////////////////////////////////////////////////////////////////////////
//
//  OLESTATUS FAR PASCAL  OleDelete (lpobj)
//
//  Deletes the given object and all memory associated with its sub-parts.
//  The calling function should cease to use 'lpobj', as it is now invalid.
//  If handler dll is used reference count is reduced by one, and if it
//  reaches zero the hanlder dll will be freed up.
//
//  Arguments:
//
//      lpobj   -   object pointer
//
//  Returns:
//
//      OLE_OK
//      OLE_ERROR_OBJECT
//      OLE_WAIT_FOR_RELEASE
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL  OleDelete (
    LPOLEOBJECT    lpobj
){
    Puts("OleDelete");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Delete) (lpobj);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRelease (lpobj)
*
* OleRelease:
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRelease (
    LPOLEOBJECT    lpobj
){
    Puts("OleRelease");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Release) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleSaveToStream (lpobj, lpstream)
*
* oleSaveToStream: This will read <hobj> to the stream based on the <hfile>
* structure.  It will return TRUE on success.  This is the only object
* function for which it is not an error to pass a NULL <hobj>.  In the case
* of NULL, this function will simply put a placemarker for an object.
* See oleLoadFromStream.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleSaveToStream (
    LPOLEOBJECT    lpobj,
    LPOLESTREAM    lpstream
){
    Puts("OleSaveToStream");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ(lpstream);

    return ((*lpobj->lpvtbl->SaveToStream) (lpobj, lpstream));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleLoadFromStream (lpstream, lpprotcol, lpclient, lhclientdoc, lpobjname, lplpobj)
*
*  oleLoadFromStream: This will read an object out of the stream based on the
*  <hfile> structure.  It will return a HANDLE to the object it creates.
*  On error, the return value is NULL, but since NULL is also a valid object
*  in the file, the <error> parameter should be checked as well.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleLoadFromStream (
    LPOLESTREAM         lpstream,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    LONG            len;
    OLESTATUS       retVal = OLE_ERROR_STREAM;
    char            class[100];
    ATOM            aClass;
    BOOL            bEdit = FALSE, bStatic = FALSE;
    LONG            ctype;
    int             objCount;
    int             iTable = INVALID_INDEX;

    Puts("OleLoadFromStream");

    *lplpobj = NULL;

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpstream);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleLoadFromStream\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (!(bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)))
        if (!(bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)))
            return OLE_ERROR_PROTOCOL;

    if (GetBytes (lpstream, (LPSTR) &dwVerFromFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (GetBytes (lpstream, (LPSTR)&ctype, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (ctype == CT_NULL)
        return (bStatic ? OLE_OK: OLE_ERROR_PROTOCOL);

    if (((ctype != CT_PICTURE) && (ctype != CT_STATIC) && bStatic) ||
            ((ctype != CT_LINK) && (ctype != CT_OLDLINK)
                && (ctype != CT_EMBEDDED) && bEdit))
        return OLE_ERROR_PROTOCOL;

    //** Get Class
    if (GetBytes(lpstream, (LPSTR)&len, sizeof(len)))
        return OLE_ERROR_STREAM;

    if (len == 0)
        return OLE_ERROR_STREAM;

    if (GetBytes(lpstream, (LPSTR)&class, len))
        return OLE_ERROR_STREAM;

    aClass = GlobalAddAtom (class);

    if ((ctype == CT_PICTURE) || (ctype == CT_STATIC))
        retVal = DefLoadFromStream (lpstream, (LPSTR)lpprotocol, lpclient,
                    lhclientdoc, (LPSTR)lpobjname, lplpobj, ctype, aClass, 0);

    //!!! It's the DLL's responsibility to delete the atom. But in case of
    // failure we delete the atom if our DefLoadFromStream().

    else if ((iTable = LoadDll (class)) == INVALID_INDEX) {
        retVal = DefLoadFromStream (lpstream, (LPSTR)lpprotocol, lpclient,
                        lhclientdoc, (LPSTR)lpobjname, lplpobj, ctype, aClass, 0);
    }
    else {
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Load) (lpstream, (LPSTR)lpprotocol, lpclient,
                       lhclientdoc, (LPSTR)lpobjname, lplpobj, ctype, aClass, 0);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;
    }

    return retVal;
}



OLESTATUS FAR PASCAL  OleClone (
    LPOLEOBJECT         lpobjsrc,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    OLESTATUS   retVal;

    Puts("OleClone");

    if (!CheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpclient);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleClone\n");
#endif

    PROBE_READ(lpobjname);

    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    PROBE_WRITE(lplpobj);

    *lplpobj = NULL;

    retVal = (*lpobjsrc->lpvtbl->Clone) (lpobjsrc, lpclient,
                        lhclientdoc, lpobjname, lplpobj);

    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;

    return retVal;
}


OLESTATUS FAR PASCAL  OleCopyFromLink (
    LPOLEOBJECT         lpobjsrc,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    OLESTATUS   retVal;

    Puts("OleCopyFromLnk");

    if (!CheckObject(lpobjsrc))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);
    PROBE_READ(lpclient);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCopyFromLink\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    *lplpobj = NULL;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    retVal = (*lpobjsrc->lpvtbl->CopyFromLink) (lpobjsrc, lpclient,
                        lhclientdoc, lpobjname, lplpobj);

    if ((lpobjsrc->iTable != INVALID_INDEX) && (retVal <= OLE_WAIT_FOR_RELEASE))
        lpDllTable[lpobjsrc->iTable].cObj++;


    return retVal;

}



OLESTATUS FAR PASCAL  OleEqual (
    LPOLEOBJECT lpobj1,
    LPOLEOBJECT lpobj2
){
    if (!CheckObject(lpobj1))
        return OLE_ERROR_OBJECT;

    if (!CheckObject(lpobj2))
        return OLE_ERROR_OBJECT;

    if (lpobj1->ctype != lpobj2->ctype)
        return OLE_ERROR_NOT_EQUAL;

    return ((*lpobj1->lpvtbl->Equal) (lpobj1, lpobj2));
}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryLinkFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryFromClip: Returns OLE_OK if a linked object can be created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryLinkFromClip (
    LPCSTR          lpprotocol,
    OLEOPT_RENDER   optRender,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleQueryLinkFromClip");
    return LeQueryCreateFromClip ((LPSTR)lpprotocol, optRender,
                       cfFormat, CT_LINK);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryCreateFromClip (lpprotcol, optRender, cfFormat)
*
* oleQueryCreateFromClip: Returns true if a non-linked object can be
* created.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FAR PASCAL OleQueryCreateFromClip (
    LPCSTR          lpprotocol,
    OLEOPT_RENDER   optRender,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleQueryCreateFromClip");
    return (LeQueryCreateFromClip ((LPSTR)lpprotocol, optRender,
                        cfFormat, CT_EMBEDDED));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateLinkFromClip (lpprotcol, lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
*
*
*  oleCreateLinkFromClip: This function creates the LP to an object from the
*  clipboard.  It will try to create a linked object.  Return value is OLE_OK
*  is the object is successfully created it
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateLinkFromClip (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT  FAR *  lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    int         objCount;
    int         iTable = INVALID_INDEX;
    OLESTATUS   retVal;
    LPSTR       lpInfo;

    Puts("OleCreateLinkFromClip");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_WRITE(lplpobj);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateLinkFromClip\n");
#endif

    PROBE_READ(lpobjname);

    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    *lplpobj = NULL;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (IsClipboardFormatAvailable (cfFileName))
        return CreatePackageFromClip (lpclient, lhclientdoc, (LPSTR)lpobjname,
                        lplpobj, optRender, cfFormat, CT_LINK);

    if (!(hInfo = GetClipboardData (cfObjectLink)))
        return OLE_ERROR_CLIPBOARD;

    if (!(lpInfo = GlobalLock(hInfo)))
        return OLE_ERROR_CLIPBOARD;

    iTable = LoadDll (lpInfo);
    GlobalUnlock (hInfo);


    if (iTable == INVALID_INDEX)
        retVal = DefCreateLinkFromClip ((LPSTR)lpprotocol, lpclient, lhclientdoc,
                        (LPSTR)lpobjname, lplpobj, optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Link) ((LPSTR)lpprotocol, lpclient,
                    lhclientdoc, (LPSTR)lpobjname, lplpobj, optRender, cfFormat);
        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;
    }

    hInfo = NULL;
    return retVal;
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCreateFromClip (lpprotcol, lpclient, lplpoleobject, optRender, cfFormat)
*
*
* oleCreateFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create an embedded object if
*  OwnerLink and Native are available, otherwise it will create a static
*  picture.  Return value is OLE_OK if the object is successfully
*  created it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCreateFromClip (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS       retVal;
    LONG            ctype;
    int             iTable = INVALID_INDEX;
    LPSTR           lpInfo;
    LPSTR           lpClass = NULL;
    int             objCount;
    OLECLIPFORMAT   cfEnum = 0;

    Puts("OleCreateFromClip");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_WRITE(lplpobj);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromClip\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    *lplpobj = NULL;

    if (!lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (optRender == olerender_none)
            return OLE_ERROR_OPTION;

        if ( (optRender == olerender_format) &&
             (cfFormat != CF_METAFILEPICT) &&
             (cfFormat != CF_DIB) &&
             (cfFormat != CF_BITMAP) &&
             (cfFormat != CF_ENHMETAFILE))
            return OLE_ERROR_FORMAT;

        if (!IsClipboardFormatAvailable (CF_METAFILEPICT)
                && !IsClipboardFormatAvailable (CF_DIB)
                && !IsClipboardFormatAvailable (CF_BITMAP)
                && !IsClipboardFormatAvailable (CF_ENHMETAFILE) )
            return OLE_ERROR_FORMAT;

        return CreatePictFromClip (lpclient, lhclientdoc,
                        (LPSTR)lpobjname, lplpobj, optRender,
                        cfFormat, NULL, CT_STATIC);
    }
    else if (!lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {
        if (IsClipboardFormatAvailable (cfFileName))
            return CreatePackageFromClip (lpclient, lhclientdoc, (LPSTR)lpobjname,
                            lplpobj, optRender, cfFormat, CT_EMBEDDED);

        if (!(hInfo = GetClipboardData (cfOwnerLink)))
            return OLE_ERROR_CLIPBOARD;

        while (TRUE) {
            cfEnum = (OLECLIPFORMAT)EnumClipboardFormats ((WORD)cfEnum);
            if (cfEnum == (OLECLIPFORMAT)cfNative) {
                ctype = CT_EMBEDDED;
                break;
            }
            else if (cfEnum == cfOwnerLink) {
                ctype = CT_LINK;
                break;
            }
        }

        if (!(lpInfo = GlobalLock(hInfo)))
            return OLE_ERROR_CLIPBOARD;

        iTable = LoadDll (lpInfo);
        GlobalUnlock (hInfo);
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }

    if (iTable == INVALID_INDEX)
        retVal = DefCreateFromClip ((LPSTR)lpprotocol, lpclient, lhclientdoc,
                        (LPSTR)lpobjname, lplpobj, optRender, cfFormat, ctype);
    else {
        objCount = lpDllTable[iTable].cObj;
        retVal = (*lpDllTable[iTable].Clip) ((LPSTR)lpprotocol, lpclient,
                            lhclientdoc, (LPSTR)lpobjname, lplpobj,
                            optRender, cfFormat, ctype);

        if (retVal > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpobj)->iTable = iTable;
    }

    hInfo = NULL;
    return retVal;
}




/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleCopyToClipboard (lpobj)
*
*
* oleCopyToClipboard: This routine executes the standard "Copy" menu item
* on the typical "Edit" menu. Returns TRUE if successful.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleCopyToClipboard (
    LPOLEOBJECT lpobj
){
    Puts("OleCopyToClipboard");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->CopyToClipboard) (lpobj));
}


OLESTATUS FAR PASCAL OleSetHostNames (
    LPOLEOBJECT lpobj,
    LPCSTR      lpclientName,
    LPCSTR      lpdocName
){
    Puts ("OleSetHostNames");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_READ(lpclientName);
    PROBE_READ(lpdocName);

    return ((*lpobj->lpvtbl->SetHostNames) (lpobj, lpclientName, lpdocName));
}



OLESTATUS   FAR PASCAL OleSetTargetDevice (
    LPOLEOBJECT lpobj,
    HANDLE      hDevInfo
){
    Puts("OleSetTargetDevice");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->SetTargetDevice) (lpobj, hDevInfo));
}



OLESTATUS   FAR PASCAL OleSetColorScheme (
    LPOLEOBJECT           lpobj,
    const LOGPALETTE FAR *lplogpal
){
    Puts("OleSetColorScheme");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return ((*lpobj->lpvtbl->SetColorScheme) (lpobj, (LOGPALETTE FAR *)lplogpal));
}



OLESTATUS FAR PASCAL  OleSetBounds(
    LPOLEOBJECT     lpobj,
    const RECT FAR *lprc
){
    Puts("OleSetBounds");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_READ((RECT FAR *)lprc);

    return ((*lpobj->lpvtbl->SetBounds) (lpobj, (RECT FAR *)lprc));

}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQueryBounds (lpobj, lpRc)
*
* Returns the bounds of the object in question in MM_HIMETRIC mode.
*           width  = lprc->right - lprc->left;  in HIMETRIC units
*           height = lprc->top - lprc->bottom;  in HIMETRIC units
*
* Returns OLE_OK or OLE_ERROR_MEMORY.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryBounds (
    LPOLEOBJECT    lpobj,
    LPRECT         lprc
){

    Puts("OleQueryBounds");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lprc);

    return (*lpobj->lpvtbl->QueryBounds) (lpobj, lprc);
}



/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleQuerySize (lpobj, lpsize)
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQuerySize (
    LPOLEOBJECT    lpobj,
    DWORD FAR *    lpdwSize
){
    Puts("OleQuerySize");

    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    PROBE_WRITE(lpdwSize);

    *lpdwSize = 0;
    return (*lpobj->lpvtbl->QuerySize) (lpobj, lpdwSize);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleDraw (lpobj, hdc, lprc, lpWrc, lphdcTarget)
*
* oleObjectDraw: This displays the given object on the device context <hcd>.
* The <htargetdc> parameter is not currently used. Returns same as Draw().
*
* Expects rectangle coordinates in MM_HIMETRIC units.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleDraw (
    LPOLEOBJECT     lpobj,
    HDC             hdc,
    const RECT FAR *lprc,
    const RECT FAR *lpWrc,
    HDC             hdcTarget
){

    Puts("OleObjectDraw");

    if (!FarCheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_READ((RECT FAR *)lprc);
    if (lpWrc)
        PROBE_READ((RECT FAR *)lpWrc);

    return ((*lpobj->lpvtbl->Draw) (lpobj, hdc, (RECT FAR *)lprc, (RECT FAR *)lpWrc, hdcTarget));
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleQueryOpen (lpobj)
*
* returns TRUE is an object has been activated.
*
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleQueryOpen (
    LPOLEOBJECT lpobj
){
    Puts("OleQueryOpen");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOpen) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleActivate (lpobj)
*
* Activates an object. For embeded objects always a new instance is
* loaded and the instance is destroyed once the data is transferred
* at close time. For linked objects, an instance of the render is created
* only if one does not exist.
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleActivate (
    LPOLEOBJECT     lpobj,
    UINT            verb,
    BOOL            fShow,
    BOOL            fActivate,
    HWND            hWnd,
    const RECT FAR *lprc
){

    Puts("OleActivate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    /* PROBE_READ(lprc); */

    return (*lpobj->lpvtbl->Activate) (lpobj, verb, fShow, fActivate, hWnd, (RECT FAR *)lprc);
}




OLESTATUS FAR PASCAL OleClose (
    LPOLEOBJECT lpobj
){

    Puts("OleClose");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

     return (*lpobj->lpvtbl->Close) (lpobj);
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleUpdate (lpobj)
*
* If there exists a link, sends advise for getting the latest rendering
* infromation. If there is no link, loads an instance, advises for the
* render information and closes the instance once the data is available.
* (If possible should not show the window).
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleUpdate (
   LPOLEOBJECT lpobj
){

    Puts("OleUpdate");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Update) (lpobj);

}


/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL OleReconnect (lpobj)
*
* Reconnects to the renderer if one does not exist already.
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FAR PASCAL OleReconnect (
    LPOLEOBJECT lpobj
){
    Puts("OleReconnect");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->Reconnect) (lpobj);
}


OLESTATUS FAR PASCAL OleGetLinkUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE FAR * lpOptions
){
    Puts("OleGetLinkUpdateOptions");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lpOptions);

    return (*lpobj->lpvtbl->GetLinkUpdateOptions) (lpobj, lpOptions);
}



OLESTATUS FAR PASCAL OleSetLinkUpdateOptions (
    LPOLEOBJECT         lpobj,
    OLEOPT_UPDATE       options
){
    Puts("OleSetLinkUpdateOptions");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetLinkUpdateOptions) (lpobj, options);

}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL OleEnumFormats (lpobj, cfFormat)
*
* Returns OLE_YES if the object is of type LINK or EMBEDDED.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLECLIPFORMAT FAR PASCAL OleEnumFormats (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleEnumFormats");

    if (!CheckObject(lpobj))
        return 0;

    return (*lpobj->lpvtbl->EnumFormats) (lpobj, cfFormat);
}

OLESTATUS FAR PASCAL OleRequestData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!cfFormat)
        return OLE_ERROR_FORMAT;

    return (*lpobj->lpvtbl->RequestData) (lpobj, cfFormat);
}


OLESTATUS FAR PASCAL OleGetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    LPHANDLE        lphandle
){
    Puts("OleGetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE((LPVOID)lphandle);

    return (*lpobj->lpvtbl->GetData) (lpobj, cfFormat, lphandle);
}


OLESTATUS FAR PASCAL OleSetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE          hData
){
    Puts("OleSetData");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->SetData) (lpobj, cfFormat, hData);
}



OLESTATUS FAR PASCAL OleQueryOutOfDate (
    LPOLEOBJECT lpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryOutOfDate) (lpobj);
}


OLESTATUS FAR PASCAL OleLockServer (
    LPOLEOBJECT     lpobjsrc,
    LHSERVER FAR *  lplhsrvr
){
    LPOBJECT_LE lpobj;
    OLESTATUS   retVal = OLE_OK;
    ATOM        aCliClass, aSvrClass;

    Puts ("OleLockServer");

    if (!FarCheckObject(lpobjsrc))
        return OLE_ERROR_OBJECT;

    if (lpobjsrc->ctype == CT_STATIC)
        return OLE_ERROR_STATIC;

    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(((LPOBJECT_LE)lpobjsrc));
    FARPROBE_WRITE(lplhsrvr);

    aCliClass = ((LPCLIENTDOC)(lpobjsrc->lhclientdoc))->aClass;
    aSvrClass = ((LPOBJECT_LE)lpobjsrc)->app;

    // See whether the server is already locked
    lpobj = (LPOBJECT_LE) (lockDoc.lpHeadObj);
    while (lpobj) {
        if ((lpobj->app == aSvrClass) && (lpobj->topic == aCliClass)) {
            if (!lpobj->head.cx) {
                // The unlocking process of server handle has started. This
                // is an asynchronous process. We want to let it complete.
                // Let's try the next handle

                ;
            }
            else {
                if (!IsServerValid (lpobj)) {
                    DeleteSrvrEdit (lpobj);
                    retVal = LockServer (lpobj);
                }
                else {
                    // Lock count
                    lpobj->head.cx++;
                }

                if (retVal == OLE_OK)
                    *lplhsrvr = (LHSERVER) lpobj;

                return retVal;
            }
        }

        lpobj = (LPOBJECT_LE) (lpobj->head.lpNextObj);
    }


    if (!(lpobj = LeCreateBlank(lhLockDoc, NULL, OT_EMBEDDED)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient    = NULL;
    lpobj->head.lpvtbl      = lpobjsrc->lpvtbl;
    lpobj->app              = DuplicateAtom (aSvrClass);
    lpobj->topic            = DuplicateAtom (aCliClass);
    lpobj->aServer          = DuplicateAtom(((LPOBJECT_LE)lpobjsrc)->aServer);
    lpobj->bOleServer       = ((LPOBJECT_LE)lpobjsrc)->bOleServer;

    if ((retVal = LockServer (lpobj)) == OLE_OK) {
        // Change signature
        lpobj->head.objId[0] = 'S';
        lpobj->head.objId[1] = 'L';
        *lplhsrvr = (LHSERVER) lpobj;
    }
    else {
        LeRelease ((LPOLEOBJECT)lpobj);
    }

    return retVal;
}


OLESTATUS INTERNAL LockServer (
    LPOBJECT_LE lpobj
){
    HANDLE hInst;

    if (!InitSrvrConv (lpobj, NULL)) {
        if (!lpobj->bOleServer)
            lpobj->fCmd = ACT_MINIMIZE;
        else
            lpobj->fCmd = 0;

        if (!(hInst = LeLaunchApp (lpobj)))
            return OLE_ERROR_LAUNCH;

        if (!InitSrvrConv (lpobj, hInst))
            return OLE_ERROR_COMM;

    }

    // lock count
    lpobj->head.cx++;
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleUnlockServer (
    LHSERVER lhsrvr
){
    LPOBJECT_LE lpobj;
    OLESTATUS   retval;

    Puts ("OleUnlockServer");

    if (!FarCheckPointer ((lpobj = (LPOBJECT_LE)lhsrvr), WRITE_ACCESS))
        return OLE_ERROR_HANDLE;

    if (lpobj->head.objId[0] != 'S' || lpobj->head.objId[1] != 'L')
        return OLE_ERROR_HANDLE;

    if (!lpobj->head.cx)
        return OLE_OK;

    if (--lpobj->head.cx)
        return OLE_OK;

    //change signature
    lpobj->head.objId[0] = 'L';
    lpobj->head.objId[1] = 'E';

    if ((retval = LeRelease((LPOLEOBJECT)lpobj)) == OLE_WAIT_FOR_RELEASE)
        DocDeleteObject ((LPOLEOBJECT)lpobj);

    return retval;
}


OLESTATUS FAR PASCAL OleObjectConvert (
    LPOLEOBJECT         lpobj,
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_WRITE(lplpobj);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleObjectConvert\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;


    return (*lpobj->lpvtbl->ObjectConvert) (lpobj, lpprotocol, lpclient,
                    lhclientdoc, lpobjname, lplpobj);
}


//OleCreateFromTemplate: Creates an embedded object from Template

OLESTATUS FAR PASCAL OleCreateFromTemplate (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromTemplate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lptemplate);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromTemplate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (!MapExtToClass ((LPSTR)lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;


    // !!! we found the class name. At this point, we need to load
    // the right library and call the right entry point;

    iTable = LoadDll (buf);
    if (iTable == INVALID_INDEX)
        retval = DefCreateFromTemplate ((LPSTR)lpprotocol, lpclient,
                            (LPSTR)lptemplate,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromTemplate) ((LPSTR)lpprotocol,
                                lpclient, (LPSTR)lptemplate,
                                lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreate: Creates an embedded object from the class.

OLESTATUS FAR PASCAL OleCreate (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreate");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX)
        retval = DefCreate ((LPSTR)lpprotocol, lpclient, (LPSTR)lpclass,
                        lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                        optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].Create) ((LPSTR)lpprotocol,
                            lpclient, (LPSTR)lpclass,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FAR PASCAL OleCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bLaunchServer)
//
// Creates an embedded object from the class.
//
//  Arguments:
//
//     lpprotocol   -
//     lpclient -
//     lpclass  -
//     lhclientdoc  -
//     lpobjname    -
//     lplpoleobject    -
//     optRender    -
//     cfFormat -
//     bLaunchServer -
//
//  Returns:
//
//      OLE_ERROR_HANDLE    -
//      OLE_ERROR_NAME      -
//      OLE_ERROR_PROTOCOL  -
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FAR PASCAL OleCreateInvisible (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                bLaunchServer
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    int         objCount;
    int         iTable = INVALID_INDEX;


    Puts("OleCreateInvisible");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpclass);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreate\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    iTable = LoadDll (lpclass);
    if (iTable == INVALID_INDEX) {
        retval = DefCreateInvisible ((LPSTR)lpprotocol, lpclient, (LPSTR)lpclass,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat, bLaunchServer);
    }
    else {
        objCount = lpDllTable[iTable].cObj;

        if (!(lpDllTable[iTable].CreateInvisible)) {
            // dll didn't export this function. Lets call DllCreate, so that
            // handler will get a chance to replace the methods. The flag is
            // used to tell the internal functions that this call infact wants
            // to achieve the effect of CreateInvisble.
            gbCreateInvisible = TRUE;
            gbLaunchServer = bLaunchServer;
            retval = (*lpDllTable[iTable].Create) ((LPSTR)lpprotocol,
                                    lpclient, (LPSTR)lpclass,
                                    lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                    optRender, cfFormat);
            gbCreateInvisible = FALSE;
        }
        else {
            retval   = (*lpDllTable[iTable].CreateInvisible) ((LPSTR)lpprotocol,
                                    lpclient, (LPSTR)lpclass,
                                    lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                    optRender, cfFormat, bLaunchServer);
        }

        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateFromFile: Creates an embedded object from file

OLESTATUS FAR PASCAL OleCreateFromFile (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LPCSTR              lpfile,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateFromFile\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
    if (lpclass)
        PROBE_READ(lpclass);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;

        if (!lstrcmp (lpclass, packageClass))
            iTable = INVALID_INDEX;
        else
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass ((LPSTR)lpfile, buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateFromFile ((LPSTR)lpprotocol,
                            lpclient, (LPSTR)lpclass, (LPSTR)lpfile,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);
    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateFromFile) ((LPSTR)lpprotocol,
                                lpclient, (LPSTR)lpclass, (LPSTR)lpfile,
                                lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}


//OleCreateLinkFromFile: Creates a linked object from file

OLESTATUS FAR PASCAL OleCreateLinkFromFile (
    LPCSTR              lpprotocol,
    LPOLECLIENT         lpclient,
    LPCSTR              lpclass,
    LPCSTR              lpfile,
    LPCSTR              lpitem,
    LHCLIENTDOC         lhclientdoc,
    LPCSTR              lpobjname,
    LPOLEOBJECT FAR *   lplpoleobject,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    char        buf[MAX_STR+6];
    int         objCount;
    int         iTable = INVALID_INDEX;

    Puts("OleCreateLinkFromFile");

    PROBE_MODE(bProtMode);

    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpprotocol);
    PROBE_READ(lpclient);
    PROBE_READ(lpfile);
    PROBE_WRITE(lplpoleobject);

#ifdef FIREWALLS
    ASSERT (lpobjname, "NULL lpobjname passed to OleCreateLinkFromFile\n");
#endif

    PROBE_READ(lpobjname);
    if (!lpobjname[0])
        return OLE_ERROR_NAME;
    if (lpclass)
        PROBE_READ(lpclass);
    if (lpitem)
        PROBE_READ(lpitem);

    if (lstrcmpi (lpprotocol, PROTOCOL_EDIT))
        return OLE_ERROR_PROTOCOL;

    if (lpclass) {
        if (!QueryApp (lpclass, lpprotocol, buf))
            return OLE_ERROR_CLASS;

        if (!lstrcmp (lpclass, packageClass)) {
            lstrcpy (buf, lpfile);
            lstrcat (buf, "/Link");
            return  CreateEmbLnkFromFile (lpclient, packageClass, buf,
                                NULL, lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat, OT_EMBEDDED);
        }
        else
            iTable = LoadDll (lpclass);
    }
    else if (MapExtToClass ((LPSTR)lpfile, buf, MAX_STR))
        iTable = LoadDll (buf);
    else
        return OLE_ERROR_CLASS;

    if (iTable == INVALID_INDEX)
        retval = DefCreateLinkFromFile ((LPSTR)lpprotocol,
                            lpclient, (LPSTR)lpclass, (LPSTR)lpfile, (LPSTR)lpitem,
                            lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                            optRender, cfFormat);

    else {
        objCount = lpDllTable[iTable].cObj;
        retval   = (*lpDllTable[iTable].CreateLinkFromFile) ((LPSTR)lpprotocol,
                                lpclient, (LPSTR)lpclass, (LPSTR)lpfile, (LPSTR)lpitem,
                                lhclientdoc, (LPSTR)lpobjname, lplpoleobject,
                                optRender, cfFormat);
        if (retval > OLE_WAIT_FOR_RELEASE)
            lpDllTable[iTable].cObj = objCount - 1;
        else
            (*lplpoleobject)->iTable = iTable;
    }

    return retval;
}



// Routines related to asynchronous operations.
OLESTATUS   FAR PASCAL  OleQueryReleaseStatus (
    LPOLEOBJECT lpobj
){
    if (!CheckPointer (lpobj, WRITE_ACCESS))
        return OLE_ERROR_OBJECT;

    // make sure that it is a long pointer to L&E object or a lock handle
    if (!(lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
            && !(lpobj->objId[0] == 'S' && lpobj->objId[1] == 'L'))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->QueryReleaseStatus) (lpobj);
}


OLESTATUS   FAR PASCAL  OleQueryReleaseError  (
    LPOLEOBJECT lpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseError) (lpobj);
}

OLE_RELEASE_METHOD FAR PASCAL OleQueryReleaseMethod (
    LPOLEOBJECT lpobj
){
    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    return (*lpobj->lpvtbl->QueryReleaseMethod) (lpobj);
}


OLESTATUS FAR PASCAL OleRename (
    LPOLEOBJECT lpobj,
    LPCSTR       lpNewName
){
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Rename) (lpobj, lpNewName);
}


OLESTATUS FAR PASCAL OleExecute (
    LPOLEOBJECT lpobj,
    HANDLE      hCmds,
    UINT        wReserved
){
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->Execute) (lpobj, hCmds, wReserved);
}


OLESTATUS FAR PASCAL OleQueryName (
    LPOLEOBJECT lpobj,
    LPSTR       lpBuf,
    UINT FAR *  lpcbBuf
){
    if (!CheckObject(lpobj))
        return OLE_ERROR_OBJECT;

    return (*lpobj->lpvtbl->QueryName) (lpobj, lpBuf, lpcbBuf);
}

OLESTATUS FAR PASCAL OleQueryType (
    LPOLEOBJECT lpobj,
    LPLONG      lptype
){
    Puts("OleQueryType");

    if (!CheckObject(lpobj))
        return(OLE_ERROR_OBJECT);

    PROBE_WRITE(lptype);

    return (*lpobj->lpvtbl->QueryType) (lpobj, lptype);
}



DWORD FAR PASCAL OleQueryClientVersion ()
{
    return dwOleVer;
}


OLESTATUS INTERNAL LeQueryCreateFromClip (
    LPSTR               lpprotocol,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    LONG                cType
){
    OLESTATUS   retVal = TRUE;
    BOOL        bEdit = FALSE, bStatic = FALSE;

    PROBE_MODE(bProtMode);
    PROBE_READ(lpprotocol);

    if (bEdit = !lstrcmpi (lpprotocol, PROTOCOL_EDIT)) {
        if (IsClipboardFormatAvailable (cfFileName))
            return OLE_OK;

        if (cType == CT_LINK)
            retVal = IsClipboardFormatAvailable (cfObjectLink);
#ifdef OLD
                        || IsClipboardFormatAvailable (cfLink) ;
#endif
        else if (cType == CT_EMBEDDED)
            retVal = IsClipboardFormatAvailable (cfOwnerLink);

        if (!retVal)
            return OLE_ERROR_FORMAT;

        if (optRender == olerender_none)
            return OLE_OK;
    }
    else if (bStatic = !lstrcmpi (lpprotocol, PROTOCOL_STATIC)) {
        if (cType == CT_LINK)
            return OLE_ERROR_PROTOCOL;

        if (optRender == olerender_none)
            return OLE_ERROR_FORMAT;
    }
    else {
        return OLE_ERROR_PROTOCOL;
    }

    if (optRender == olerender_draw) {
        if (!IsClipboardFormatAvailable (CF_METAFILEPICT) &&
                !IsClipboardFormatAvailable (CF_DIB)      &&
                !IsClipboardFormatAvailable (CF_BITMAP)   &&
                !IsClipboardFormatAvailable (CF_ENHMETAFILE)   &&
                !(bEdit && QueryHandler((cType == CT_LINK) ? cfObjectLink : cfOwnerLink)))
            return OLE_ERROR_FORMAT;
    }
    else if (optRender == olerender_format) {
        if (!IsClipboardFormatAvailable (cfFormat))
            return OLE_ERROR_FORMAT;

        if (bStatic &&
            (cfFormat != CF_METAFILEPICT) &&
            (cfFormat != CF_ENHMETAFILE) &&
            (cfFormat != CF_DIB) &&
            (cfFormat != CF_BITMAP))
            return OLE_ERROR_FORMAT;

    }
    else {
        return OLE_ERROR_FORMAT;
    }

    return OLE_OK;
}



BOOL INTERNAL CheckObject(
    LPOLEOBJECT lpobj
){
    if (!CheckPointer(lpobj, WRITE_ACCESS))
        return FALSE;

    if (lpobj->objId[0] == 'L' && lpobj->objId[1] == 'E')
        return TRUE;

    return FALSE;
}

BOOL FARINTERNAL FarCheckObject(
    LPOLEOBJECT lpobj
){
    return (CheckObject (lpobj));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\clidemo.h ===
/*
 * clidemo.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define CXDEFAULT       400     //* Default object size:  400 x 300 
#define CYDEFAULT       300
#define COBJECTSMAX     50      //* max number of objects in our app 

//*** PROTOTYPES ***

//*** Exported window procedures 

LONG  APIENTRY  FrameWndProc(HWND, UINT, DWORD, LONG);

//*** FAR 

VOID FAR             FixObjectBounds(LPRECT lprc);

//*** Local

static LPOLECLIENT   InitClient(HANDLE);
static VOID          EndClient(LPOLECLIENT);
static LPAPPSTREAM   InitStream(HANDLE);
static VOID          EndStream(LPAPPSTREAM);
static VOID          ProcessCmdLine(LPSTR);
static BOOL          InitApplication(HANDLE); 
static BOOL          InitInstance(HANDLE);
static VOID          SetTitle(PSTR);
static VOID          MyOpenFile(PSTR,LHCLIENTDOC *, LPOLECLIENT, LPAPPSTREAM);
static VOID          NewFile(PSTR,LHCLIENTDOC *, LPAPPSTREAM); 
static BOOL          SaveFile(PSTR, LHCLIENTDOC, LPAPPSTREAM);
static VOID          SaveasFile(PSTR, LHCLIENTDOC, LPAPPSTREAM);
static BOOL          LoadFile(PSTR, LHCLIENTDOC, LPOLECLIENT, LPAPPSTREAM); 
static VOID          ClearAll(LHCLIENTDOC, BOOL);
static VOID          EndInstance(VOID);
static BOOL          SaveAsNeeded(PSTR,LHCLIENTDOC,LPAPPSTREAM);
static VOID          UpdateMenu(HMENU);
static BOOL          RegDoc(PSTR, LHCLIENTDOC *);
static VOID          DeregDoc(LHCLIENTDOC);
static BOOL          InitAsOleClient(HANDLE, HWND, PSTR, LHCLIENTDOC *, LPOLECLIENT *,  LPAPPSTREAM *);
VOID FAR             ClearItem(APPITEMPTR);
static LONG          QueryEndSession(PSTR, LHCLIENTDOC, LPAPPSTREAM);

//*** MACROS *** 

/*
 * ANY_OBJECT_BUSY
 * checks to see if any object in the document is busy. This prevents 
 * a new document from being saved to file if there are objects in 
 * asynchronous states.
 */

#define ANY_OBJECT_BUSY  {\
    if (ObjectsBusy()) \
         break; \
}
   

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\pbhandlr.c ===
/****************************** Module Header ******************************\
* Module Name: Pbhandlr.C -- Native data based handler (for Pbrush server) 
*
* PURPOSE: Contains handler routines for Pbrush server. This handler makes
*   use of most of the standard library methods. It replaces only the "Draw",
*   "QueryBounds", "CopyToClipboard" methods of the OLE object. Note that this
*   handler draws the picture from the native data.
*
* Created: December 1990
*
* Copyright (c) 1990  Microsoft Corporation
*
* History:
*   SriniK  (../12/1990)    Original
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"


OLESTATUS FAR PASCAL _LOADDS PbDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FAR PASCAL _LOADDS PbQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FAR PASCAL _LOADDS PbCopyToClipboard (LPOLEOBJECT);
OLESTATUS FAR PASCAL _LOADDS PbGetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);
OLECLIPFORMAT FAR PASCAL _LOADDS PbEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);

extern OLESTATUS  FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);


void    PbGetExtents (LPSTR, LPPOINT);
void    PbReplaceFunctions (LPOLEOBJECT);
HANDLE  PbGetPicture (LPOLEOBJECT);
BOOL    IsStandardPict (LPOLEOBJECT);

extern void FARINTERNAL DibGetExtents(LPSTR, LPPOINT);

OLEOBJECTVTBL   vtblDLL;

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;

OLESTATUS (FAR PASCAL *DefQueryBounds)      (LPOLEOBJECT, LPRECT);
OLESTATUS (FAR PASCAL *DefDraw)             (LPOLEOBJECT, HDC, LPRECT, LPRECT, HDC);
OLESTATUS (FAR PASCAL *DefCopyToClipboard)  (LPOLEOBJECT);
OLECLIPFORMAT (FAR PASCAL *DefEnumFormats)  (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS (FAR PASCAL *DefGetData)          (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR *);


OLESTATUS FAR PASCAL PbLoadFromStream (
    LPOLESTREAM         lpstream,
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    LONG                objType,
    ATOM                aClass,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (objType == OT_LINK) 
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfNative);
    else
        retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient, 
                        lhclientdoc, lpobjname, lplpobj, 
                        objType, aClass, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    LONG                objType
){
    OLESTATUS   retVal;
    
    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {       
        if (objType == OT_EMBEDDED) 
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_none, 0, objType);
        else
            retVal =  DefCreateFromClip (lpprotocol, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, 
                                olerender_format, cfNative, objType);
    }
    else {
        retVal = DefCreateFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat, objType);
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);
        
    return retVal;
}



OLESTATUS FAR PASCAL PbCreateLinkFromClip (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS       retVal;

    if ((optRender == olerender_draw) 
            && (IsClipboardFormatAvailable (cfNative))) {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);
    }
    else {
        retVal =  DefCreateLinkFromClip (lpprotocol, lpclient, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);       
    }
    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromTemplate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lptemplate,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, 0);

    else 
        retVal = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreate (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, 0);
    else 
        retVal = DefCreate (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}



OLESTATUS FAR PASCAL PbCreateFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_none, 0);

    else 
        retVal = DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, 
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}


OLESTATUS FAR PASCAL PbCreateLinkFromFile (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LPSTR               lpfile,
    LPSTR               lpitem,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw) 
        retVal =  DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            olerender_format, cfNative);

    else 
        retVal = DefCreateLinkFromFile (lpprotocol, lpclient, 
                            lpclass, lpfile, lpitem,
                            lhclientdoc, lpobjname, lplpobj, 
                            optRender, cfFormat);
                        
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;                          
}



OLESTATUS FAR PASCAL PbCreateInvisible (
    LPSTR               lpprotocol,
    LPOLECLIENT         lpclient,
    LPSTR               lpclass,
    LHCLIENTDOC         lhclientdoc,
    LPSTR               lpobjname,
    LPOLEOBJECT FAR *   lplpobj,
    OLEOPT_RENDER       optRender,
    OLECLIPFORMAT       cfFormat,
    BOOL                fActivate
){
    OLESTATUS   retVal;
    
    if (optRender == olerender_draw)
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        olerender_none, 0, fActivate);
    else 
        retVal = DefCreateInvisible (lpprotocol, lpclient, lpclass, 
                        lhclientdoc, lpobjname, lplpobj, 
                        optRender, cfFormat, fActivate);
                    
    if (retVal <= OLE_WAIT_FOR_RELEASE)
        PbReplaceFunctions (*lplpobj);

    return retVal;
}


void PbReplaceFunctions (
    LPOLEOBJECT lpobj
){
    if (IsStandardPict (lpobj))
        return;
    
    vtblDLL = *lpobj->lpvtbl;
    lpobj->lpvtbl = (LPOLEOBJECTVTBL) &vtblDLL;
    
    DefDraw                         = lpobj->lpvtbl->Draw;
    DefQueryBounds                  = lpobj->lpvtbl->QueryBounds;
    DefCopyToClipboard              = lpobj->lpvtbl->CopyToClipboard;
    DefEnumFormats                  = lpobj->lpvtbl->EnumFormats;
    DefGetData                      = lpobj->lpvtbl->GetData;   
    
    lpobj->lpvtbl->Draw             = PbDraw;
    lpobj->lpvtbl->QueryBounds      = PbQueryBounds;
    lpobj->lpvtbl->CopyToClipboard  = PbCopyToClipboard;
    lpobj->lpvtbl->EnumFormats      = PbEnumFormats;    
    lpobj->lpvtbl->GetData          = PbGetData;        
}



OLESTATUS  FAR PASCAL _LOADDS PbQueryBounds (
    LPOLEOBJECT lpobj,
    LPRECT      lprc
){
    OLESTATUS     retVal;
    HANDLE        hData = NULL;
    LPSTR         lpData;
    POINT         point;
	 HANDLE        hbminfo = NULL;
	 LPBITMAPINFO  lpbminfo;

    if ((retVal = (*DefQueryBounds) (lpobj, lprc)) == OLE_OK) {
        if (lprc->top || lprc->bottom || lprc->right || lprc->left)
            return OLE_OK;
    }
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return retVal;

    if (!hData)
        return OLE_ERROR_BLANK;     
            
    if (!(lpData = GlobalLock (hData)))
		  goto error;
	 
	 if (!(hbminfo = GlobalAlloc(GHND, sizeof(BITMAPINFO))) )
		  goto error;

	 if (!(lpbminfo = (LPBITMAPINFO)GlobalLock(hbminfo)) )
		  goto error;
	 
    memcpy((LPSTR)lpbminfo, (LPSTR)(lpData+sizeof(BITMAPFILEHEADER)), sizeof(BITMAPINFO));
	 
    DibGetExtents ((LPSTR)lpbminfo, &point);
	 
    GlobalUnlock (hData);
	 GlobalUnlock (hbminfo);
	 GlobalFree (hbminfo);
    
    lprc->left     = 0;
    lprc->top      = 0;
    lprc->right    = point.x;
    lprc->bottom   = point.y;
    
    return OLE_OK;

error:

    if (hData)
       GlobalUnlock (hData);
	 
	 if (hbminfo)
	 {   
		 GlobalUnlock (hbminfo);
	    GlobalFree (hbminfo);
	 }   

	 return OLE_ERROR_MEMORY;
	 
}


OLESTATUS  FAR PASCAL _LOADDS PbDraw (
    LPOLEOBJECT         lpobj,
    HDC                 hdc,
    OLE_CONST RECT FAR* lprc,
    OLE_CONST RECT FAR* lpWrc,
    HDC                 hdcTarget
){
    HANDLE  hData;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return (*DefDraw) (lpobj, hdc, (LPRECT)lprc, (LPRECT)lpWrc, hdcTarget);

    return wDibDraw (hData, hdc, (LPRECT)lprc, (LPRECT)lpWrc, hdcTarget, TRUE);
}


OLECLIPFORMAT FAR PASCAL _LOADDS PbEnumFormats (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat
){
    OLECLIPFORMAT   retFormat = 0;

    if (cfFormat == CF_METAFILEPICT)
        return 0;
    
    if (!(retFormat =  (*DefEnumFormats) (lpobj, cfFormat))) 
        return CF_METAFILEPICT;
    
    return retFormat;
}


OLESTATUS  FAR PASCAL _LOADDS PbGetData (
    LPOLEOBJECT     lpobj,
    OLECLIPFORMAT   cfFormat,
    HANDLE FAR *    lpHandle
){
    OLESTATUS retval;
    
    retval = (*DefGetData) (lpobj, cfFormat, lpHandle);

    if (retval == OLE_OK || retval == OLE_BUSY || retval  == OLE_ERROR_BLANK)
        return retval;
    
    if (cfFormat == CF_METAFILEPICT) {
        if (*lpHandle = PbGetPicture (lpobj))
            return OLE_WARN_DELETE_DATA;
        
        return OLE_ERROR_MEMORY;
    }

    return OLE_ERROR_FORMAT;
}



OLESTATUS  FAR PASCAL _LOADDS PbCopyToClipboard (
    LPOLEOBJECT     lpobj
){
    OLESTATUS   retVal;
    HANDLE      hPict; 
    
    if ((retVal = (*DefCopyToClipboard) (lpobj)) == OLE_OK) {
        if (hPict = PbGetPicture (lpobj))
            SetClipboardData (CF_METAFILEPICT, hPict);
        else
            return OLE_ERROR_MEMORY;         
    }
    
    return retVal;
}

HANDLE PbGetPicture (
    LPOLEOBJECT lpobj
){
    HANDLE          hMF, hMfp;
	 HANDLE          hData = NULL;
	 HANDLE          hbminfo = NULL;
    RECT            rc = {0, 0, 0, 0};
    POINT           point;
    HDC             hMetaDC;
    LPMETAFILEPICT  lpmfp;
    OLESTATUS       retVal;
    LPSTR           lpData;
	 LPBITMAPINFO    lpbminfo;
    
    if ((*DefGetData) (lpobj, cfNative, &hData) != OLE_OK)
        return NULL;
    
    if (!hData)
        return NULL;
            
    if (!(lpData = GlobalLock (hData)))
        return NULL;
	  
	 if (!(hbminfo = GlobalAlloc(GHND, sizeof(BITMAPINFO))) )
		  goto memory_error;

	 if (!(lpbminfo = (LPBITMAPINFO)GlobalLock(hbminfo)) )
		  goto memory_error;
	 
    memcpy((LPSTR)lpbminfo, (LPSTR)(lpData+sizeof(BITMAPFILEHEADER)), sizeof(BITMAPINFO));

    rc.right  = (int) lpbminfo->bmiHeader.biWidth;
    rc.bottom = (int) lpbminfo->bmiHeader.biHeight;
    DibGetExtents((LPSTR)lpbminfo, &point);
	 
    GlobalUnlock (hData);
	 GlobalUnlock (hbminfo);
	 GlobalFree (hbminfo);
	
    if (!(hMetaDC = CreateMetaFile (NULL)))
        return NULL;
    
    MSetWindowOrg (hMetaDC, 0, 0);
    MSetWindowExt (hMetaDC, rc.right, rc.bottom);
    retVal = PbDraw (lpobj, hMetaDC, &rc, NULL, NULL);
    hMF = CloseMetaFile (hMetaDC);

    if (retVal != OLE_OK) 
        goto error;

    if (hMF && (hMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT)))
            && (lpmfp = (LPMETAFILEPICT) GlobalLock (hMfp))) {
        lpmfp->hMF = hMF;
        lpmfp->xExt = point.x;
        lpmfp->yExt = -point.y;
        lpmfp->mm   = MM_ANISOTROPIC;
        GlobalUnlock (hMfp);
        return hMfp;
    }

error:

    if (hMF)
        DeleteMetaFile (hMF);
    
    if (hMfp)
        GlobalFree (hMfp);

    return NULL;

memory_error:

	 GlobalUnlock(hData);

	 if (hbminfo)
	 {   
	    GlobalUnlock(hbminfo);
		 GlobalFree(hbminfo);
	 }
 
	 return(NULL);
	 
}


// normal handler can't do this. since this handler is part of olecli.dll, we
// we are doing this.

BOOL IsStandardPict (
    LPOLEOBJECT lpobj
){
    LPOBJECT_LE lpLEobj;
    LONG        type;
    
    lpLEobj = (LPOBJECT_LE) lpobj;
    if (!lpLEobj->lpobjPict)
        return FALSE;
    
    if ((*lpLEobj->lpobjPict->lpvtbl->QueryType) (lpLEobj->lpobjPict, &type)
            == OLE_ERROR_GENERIC)
        return FALSE;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\cliver.h ===
#define CLIVER_DEBUG    0
#define CLIVER_PRERELEASE   1

#define CLIVER_FILEFLAGS    (CLIVER_PRERELEASE|CLIVER_DEBUG)

#define CLIVER_FILEOS           VOS_DOS_WINDOWS16
#define CLIVER_FILEVERSION      1,01
#define CLIVER_PRODUCTVERSION   1,01,0,00
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\demorc.h ===
/*
 * demorc.h - Header file for OLE demo's resource file.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

/* Application resource ID */

#define ID_APPLICATION 1

#define POS_FILEMENU    0
/* File menu */
#define IDM_NEW         0x100
#define IDM_OPEN        0x101
#define IDM_SAVE        0x102
#define IDM_SAVEAS      0x103
#define IDM_EXIT        0x104
#define IDM_ABOUT       0x105

#define POS_EDITMENU    1
/* Edit menu */
#define IDM_CUT         0x200
#define IDM_COPY        0x201
#define IDM_PASTE       0x202
#define IDM_PASTELINK   0x203
#define IDM_CLEAR       0x204
#define IDM_CLEARALL    0x205
#define IDM_LINKS       0x206

/* Object popup menu */
#define POS_OBJECT	   9	// position of Object item in Edit menu
#define IDM_OBJECT      0x210
#define IDM_VERBMIN     0x211
#define IDM_VERBMAX     0x220	// Put this up to 220 (15 verbs) !!!
#define CVERBSMAX       (IDM_VERBMAX - IDM_VERBMIN + 1)

#define POS_OBJECTMENU  2
#define IDM_INSERT	   0x300
#define IDM_INSERTFILE  0x301

#define IDM_UNDO        0x400	/* Only used internally */
#define IDM_LOAD	      0x401
#define IDM_UPDATE      0x402


/* Dialog box ids */
#define DTPROP          1
#define DTINVALIDLINK   2
#define DTCREATE        3

#define IDD_LINKNAME    0x200
#define IDD_AUTO	      0x201	// Auto update
#define IDD_MANUAL	   0x202	// Manual update
#define IDD_EDIT	      0x203	// Edit Object button
#define IDD_FREEZE	   0x204	// Cancel Link button
#define IDD_UPDATE	   0x205	// Update Now Button
#define IDD_CHANGE	   0x206	// Change Links Button
#define IDD_LINKDONE	   0x207	// ???
#define IDD_PLAY	      0x208	// Activate Button
#define IDD_LISTBOX	   0x209	// List of Links List Box
#define IDD_DESTROY     0x20A

#define IDD_YES         0x210
#define IDD_NO          0x211	
#define IDD_RETRY       0x212	
#define IDD_SWITCH      0x213
#define IDD_RETRY_TEXT1 0x214
#define IDD_RETRY_TEXT2 0x215

/* String table constants */
#define CBMESSAGEMAX       80
#define IDS_APPNAME        0x100
#define IDS_UNTITLED       0x101
#define IDS_MAYBESAVE      0x102
#define IDS_OPENFILE	      0x103
#define IDS_SAVEFILE	      0x104
#define IDS_INSERTFILE	   0x105
#define IDS_FILTER	      0x106
#define IDS_EXTENSION	   0x107
#define IDS_CHANGELINK     0x108
#define IDS_ALLFILTER      0x109
#define IDS_EMBEDDED       0x10a
#define IDS_UPDATELINKS    0x10b
#define IDS_RENAME         0x10c
#define IDS_INVALID_LINK   0x10d
#define IDS_SAVE_CHANGES   0x10e
#define IDS_UPDATE_OBJ     0x110
#define IDS_RETRY_TEXT1    0x111
#define IDS_RETRY_TEXT2    0x112

/* Error messages */
#define E_FAILED_TO_OPEN_FILE           0x200
#define E_FAILED_TO_READ_FILE           0x201
#define E_FAILED_TO_SAVE_FILE           0x202
#define E_INVALID_FILENAME              0x203
#define E_CREATE_FROM_TEMPLATE          0x204
#define E_FAILED_TO_WRITE_OBJECT        0x205
#define E_FAILED_TO_READ_OBJECT         0x206
#define E_FAILED_TO_DELETE_OBJECT       0x207
#define E_CLIPBOARD_CUT_FAILED          0x208
#define E_CLIPBOARD_COPY_FAILED         0x209
#define E_GET_FROM_CLIPBOARD_FAILED     0x20a
#define E_FAILED_TO_CREATE_CHILD_WINDOW 0x20b
#define E_FAILED_TO_CREATE_OBJECT	    0x20c
#define E_OBJECT_BUSY			          0x20d
#define E_UNEXPECTED_RELEASE            0x20e
#define E_FAILED_TO_LAUNCH_SERVER       0x20f
#define E_FAILED_TO_UPDATE              0x210
#define E_FAILED_TO_FREEZE              0x211
#define E_FAILED_TO_UPDATE_LINK         0x212
#define E_SERVER_BUSY                   0x213
#define E_FAILED_TO_RECONNECT_OBJECT    0x214
#define E_FAILED_TO_CONNECT		       0x215
#define E_FAILED_TO_RELEASE_OBJECT      0x216
#define E_FAILED_TO_ALLOC               0x217
#define E_FAILED_TO_LOCK                0x218     
#define E_FAILED_TO_DO_VERB             0x219

#define W_IMPROPER_LINK_OPTIONS         0x300
#define W_STATIC_OBJECT                 0x301
#define W_FAILED_TO_CLONE_UNDO          0x302
#define W_FAILED_TO_NOTIFY              0x303

#define SZAUTO    0x400
#define SZMANUAL  0x401
#define SZFROZEN  0x402

#define E_OLE_ERROR_PROTECT_ONLY          3 
#define E_OLE_ERROR_MEMORY                4
#define E_OLE_ERROR_STREAM                5
#define E_OLE_ERROR_STATIC                6
#define E_OLE_ERROR_BLANK                 7
#define E_OLE_ERROR_DRAW                  8
#define E_OLE_ERROR_METAFILE              9
#define E_OLE_ERROR_ABORT                 10
#define E_OLE_ERROR_CLIPBOARD             11
#define E_OLE_ERROR_FORMAT                12
#define E_OLE_ERROR_OBJECT                13
#define E_OLE_ERROR_OPTION                14
#define E_OLE_ERROR_PROTOCOL              15
#define E_OLE_ERROR_ADDRESS               16
#define E_OLE_ERROR_NOT_EQUAL             17
#define E_OLE_ERROR_HANDLE                18
#define E_OLE_ERROR_GENERIC               19
#define E_OLE_ERROR_CLASS                 20
#define E_OLE_ERROR_SYNTAX                21
#define E_OLE_ERROR_DATATYPE              22
#define E_OLE_ERROR_PALETTE               23
#define E_OLE_ERROR_NOT_LINK              24
#define E_OLE_ERROR_NOT_EMPTY             25
#define E_OLE_ERROR_SIZE                  26
#define E_OLE_ERROR_DRIVE                 27
#define E_OLE_ERROR_NETWORK               28
#define E_OLE_ERROR_NAME                  29
#define E_OLE_ERROR_TEMPLATE              30
#define E_OLE_ERROR_NEW                   31
#define E_OLE_ERROR_EDIT                  32
#define E_OLE_ERROR_OPEN                  33
#define E_OLE_ERROR_NOT_OPEN              34
#define E_OLE_ERROR_LAUNCH                35
#define E_OLE_ERROR_COMM                  36
#define E_OLE_ERROR_TERMINATE             37
#define E_OLE_ERROR_COMMAND               38
#define E_OLE_ERROR_SHOW                  39
#define E_OLE_ERROR_DOVERB                40
#define E_OLE_ERROR_ADVISE_NATIVE         41 
#define E_OLE_ERROR_ADVISE_PICT           42
#define E_OLE_ERROR_ADVISE_RENAME         43
#define E_OLE_ERROR_POKE_NATIVE           44
#define E_OLE_ERROR_REQUEST_NATIVE        45
#define E_OLE_ERROR_REQUEST_PICT          46
#define E_OLE_ERROR_SERVER_BLOCKED        47
#define E_OLE_ERROR_REGISTRATION          48
#define E_OLE_ERROR_ALREADY_REGISTERED    49
#define E_OLE_ERROR_TASK                  50
#define E_OLE_ERROR_OUTOFDATE             51
#define E_OLE_ERROR_CANT_UPDATE_CLIENT    52
#define E_OLE_ERROR_UPDATE                53
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\dialog.h ===
/*
 * dialog.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ***

#include <commdlg.h>

//*** PROTOTYPES ***

//*** FAR 
BOOL FAR          FullyQualify(LPSTR, LPSTR);
BOOL FAR          OfnGetName(HWND, LPSTR, WORD);
LPSTR FAR         OfnGetNewLinkName(HWND, LPSTR);
VOID FAR          OfnInit(HANDLE);
BOOL APIENTRY     fnInsertNew(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY     fnProperties(HWND, UINT, WPARAM, LPARAM);
VOID FAR          LinkProperties(VOID);
VOID FAR          AboutBox(VOID);
BOOL  APIENTRY    fnAbout( HWND, UINT, WPARAM, LPARAM);
VOID FAR          RetryMessage (APPITEMPTR,LONG);
BOOL  APIENTRY    fnRetry(HWND, UINT, WPARAM, LPARAM);
VOID FAR          InvalidLink(VOID);
BOOL  APIENTRY    fnInvalidLink(HWND, UINT, WPARAM, LPARAM);

//*** Local
static VOID       AddExtension(LPOPENFILENAME);
static VOID       Normalize(LPSTR);
static BOOL       InitLinkDlg (HWND, INT *, HWND, APPITEMPTR **);
static VOID       UpdateLinkButtons(HWND, INT, HWND, APPITEMPTR *);
static BOOL       ChangeLinks(HWND, INT, HWND, APPITEMPTR *);
static VOID       CancelLinks(HWND, INT, HWND, APPITEMPTR *);
static VOID       DisplayUpdate(INT, HWND, APPITEMPTR *, BOOL);
static VOID       UndoObjects(VOID);
static VOID       DelUndoObjects(BOOL);
static VOID       ChangeUpdateOptions(HWND, INT, HWND, APPITEMPTR *, OLEOPT_UPDATE);
static VOID       MakeListBoxString(LPSTR, LPSTR, OLEOPT_UPDATE);

//*** MACROS ***

#define END_PROP_DLG(hDlg,pLinks) { \
   HANDLE handle; \
   handle = LocalHandle((LPSTR)pLinks); \
   LocalUnlock(handle); \
   LocalFree(handle); \
   Hourglass(FALSE); \
   hwndProp = (HWND)NULL; \
   EndDialog(hDlg, TRUE); \
}

#define CHANGE_LISTBOX_STRING(hwnd,i,pItem,lpLinkData) {\
   char pString[CBMESSAGEMAX*4];\
   MakeListBoxString(lpLinkData,pString,pItem->uoObject);\
   SendMessage(hwndList,LB_DELETESTRING, i , 0L);\
   SendMessage(hwndList,LB_INSERTSTRING, i , (long)((LPSTR)pString));\
   SendMessage(hwndList,LB_SETSEL, 1, (long)i);\
}

#define CHECK_IF_STATIC(pItem) {\
   if (pItem->otObject == OT_STATIC)\
      continue;\
}

#define BLOCK_BUSY(fTest) {\
   if (fTest)\
   {\
      fTest = FALSE;\
      return TRUE;\
   }\
   if (cOleWait)\
   {\
      fTest = TRUE;\
      RetryMessage(NULL,RD_CANCEL);\
      fTest = FALSE;\
      return TRUE;\
   }\
}




 

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\object.h ===
/*
 * object.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTOTYPES ***

//* OLE Callbacks

INT  APIENTRY CallBack(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);

//* Exported Windows procedures

LONG  APIENTRY ItemWndProc(HWND, UINT, DWORD, LONG);

//* Far
VOID FAR       ObjDelete(APPITEMPTR, BOOL);
VOID FAR       ConvertToClient(LPRECT);
OLESTATUS FAR  Error(OLESTATUS);
APPITEMPTR FAR PreItemCreate(LPOLECLIENT, BOOL, LHCLIENTDOC);
BOOL FAR       PostItemCreate(LPOLEOBJECT, LONG, LPRECT, APPITEMPTR);
VOID FAR       ObjPaste(BOOL, LHCLIENTDOC, LPOLECLIENT);
BOOL FAR       ObjCopy(APPITEMPTR);
BOOL FAR       ObjGetData (APPITEMPTR, LPSTR);
VOID FAR       ObjChangeLinkData(APPITEMPTR, LPSTR);
VOID FAR       ObjSaveUndo(APPITEMPTR);
VOID FAR       ObjDelUndo(APPITEMPTR); 
VOID FAR       ObjUndo(APPITEMPTR);
VOID FAR       ObjFreeze(APPITEMPTR);
VOID FAR       ObjInsert(LHCLIENTDOC, LPOLECLIENT);
VOID FAR       ObjCreateFromTemplate(LHCLIENTDOC, LPOLECLIENT);
VOID FAR       ObjCreateWrap(HANDLE, LHCLIENTDOC, LPOLECLIENT);
VOID FAR       UpdateObjectMenuItem(HMENU);
VOID FAR       ExecuteVerb(UINT, APPITEMPTR);

//* Local
static VOID    Release(APPITEMPTR);
BOOL FAR       ObjSetBounds(APPITEMPTR);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\register.h ===
/*
 * <register.h>
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTOTYPES ***

//* Far

BOOL FAR    RegCopyClassName(HWND hwndList, LPSTR lpstrClassName);
VOID FAR    RegGetClassId(LPSTR lpstrName, LPSTR lpstrClass);
BOOL FAR    RegGetClassNames(HWND hwndList);
VOID FAR    RegInit(HANDLE hInst);
INT  FAR    RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, LPSTR lpstrFilterSpec);
VOID FAR    RegTerm(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\pict.h ===
/****************************** Module Header ******************************\
* Module Name: pict.h
*
* PURPOSE: Private definitions file for presentation object related files
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*  curts created portable version for WIN16/32
*
\***************************************************************************/


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MF.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL MfRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL MfSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL MfClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL MfEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL MfCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL MfQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL MfGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL MfSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL MfChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    MfCopyToClip (LPOBJECT_MF, HANDLE);
void      FARINTERNAL MfSetExtents (LPOBJECT_MF);
DWORD     INTERNAL    MfGetSize (LPHANDLE);
HANDLE    INTERNAL    GetHmfp (LPOBJECT_MF);
OLESTATUS INTERNAL    MfUpdateStruct (LPOBJECT_MF, LPOLECLIENT, HANDLE, 
                            LPMETAFILEPICT, HANDLE, BOOL);
OLECLIPFORMAT FARINTERNAL MfEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in EMF.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL EmfRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL EmfSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL EmfClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL EmfEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL EmfCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL EmfQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL EmfGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLE