onse body.</returns>
        public static TestFdReflectorResponse CheckResponseAgainstRequest (HttpClient.Response response, 
            HttpClient.Request request, bool checkHeaders)
        {
            try
            {
                if (response == null)
                {
                    throw new AAGatewayException("Response is null.");
                }

                CheckResponseForStatus(response, 200);

                TestFdReflectorResponse reflected = new TestFdReflectorResponse();
                reflected.ReadBytes(response.ContentBytes);

                if (reflected == null)
                {
                    Global.RO.Debug(response.ToString());
                    throw new AAGatewayException("Reflected response was not parsed correctly.");
                }

                TestFdReflectorResponse.HttpRequestWD ref_req = reflected.HttpRequest;

                if (ref_req.Method != request.Method)
                {
                    throw new AAGatewayException("Reflected Method [{0}] does not match requested Method [{1}].",
                        (ref_req.Method == null ? "null" : ref_req.Method),
                        (request.Method == null ? "null" : request.Method));
                }

                if (ref_req.URLAndQueryString != request.URI)
                {
                    throw new AAGatewayException("Reflected URI [{0}] does not match requested URI [{1}].",
                        (ref_req.URLAndQueryString == null ? "null" : ref_req.URLAndQueryString),
                        (request.URI == null ? "null" : request.URI));
                }

                if (ref_req.ServerProtocol != request.Version)
                {
                    throw new AAGatewayException("Reflected Version [{0}] does not match requested Version [{1}].",
                        (ref_req.ServerProtocol == null ? "null" : ref_req.ServerProtocol),
                        (request.Version == null ? "null" : request.Version));
                }

                // get the header dictionary and make it case insensitive
                Dictionary<string, string> refReqHeaders = 
                    new Dictionary<string, string>(ref_req.Headers.Dict, StringComparer.OrdinalIgnoreCase);

                string rrcl;
                if (!refReqHeaders.TryGetValue("Content-Length", out rrcl)) { rrcl = null; }
                if (rrcl != request.ContentLength)
                {
                    throw new AAGatewayException("Reflected ContentLength [{0}] does not match requested ContentLength [{1}].",
                        (rrcl == null ? "null" : rrcl),
                        (request.ContentLength == null ? "null" : request.ContentLength));
                }

                if (checkHeaders)
                {
                    string rrh = refReqHeaders["Host"];
                    if (rrh == request.Host)
                    {
                        throw new AAGatewayException("Reflected Host [{0}] matches requested Host [{1}], it should not.",
                            (rrh == null ? "null" : rrh),
                            (request.Host == null ? "null" : request.Host));
                    }

                    foreach (string header in request.OtherHeaders)
                    {
                        string header_name = header;
                        int pos = header.IndexOf(':');

                        if (pos >= 0)
                        {
                            header_name = header.Substring(0, pos);
                        }

                        if (!refReqHeaders.ContainsKey(header_name))
                        {
                            throw new AAGatewayException("Reflected request does not contain the header [{0}].", header);
                        }
                    }
                }

                bool ref_req_content_empty = (ref_req.Content == null || ref_req.Content.Length == 0);
                bool request_content_empty = (request.Content == null || request.Content.Length == 0);

                if (ref_req_content_empty != request_content_empty)
                {
                    string ref_req_content_string = (ref_req.Content == null ? "null" : "not null");
                    string request_content_string = (request.Content == null ? "null" : "not null");

                    throw new AAGatewayException("Reflected Content [{0}] does not match requested Content [{1}].",
                        ref_req_content_string, request_content_string);
                }

                if (ref_req.Content != null && request.Content != null &&
                    !ArrayEx.Compare(ref_req.Content, request.Content))
                {
                    // Inefficient, but shouldn't happen too often.
                    int i = 0;
                    for (i = 0; i < ref_req.Content.Length; ++i)
                    {
                        if (ref_req.Content[i] != request.Content[i])
                            break;
                    }

                    throw new AAGatewayException("Reflected Content does not match requested Content at index {2}.", i);
                }

                return reflected;
            }
            catch
            {
                if (request != null)
                {
                    Global.RO.Debug("****** Request ******:\n" + request);
                }

                if (response != null)
                {
                    Global.RO.Debug("****** Response ******:\n" + response);
                }

                throw;
            }
        }

        /// <summary>
        /// Checks the response for what we expect from an XRLScan block.
        /// </summary>
        /// <param name="response">The response to check.</param>
        public static void CheckResponseForXRLScanBlock (HttpClient.Response response)
        {
            CheckResponseForStatus(response, 404);
        }

        /// <summary>
        /// Checks the response for what we expect from a module block.
        /// </summary>
        /// <param name="response">The response to check.</param>
        public static void CheckResponseForModuleBlock (HttpClient.Response response)
        {
            CheckResponseForStatus(response, 404);
        }

        /// <summary>
        /// Checks the response for what we expect from a module block.
        /// </summary>
        /// <param name="response">The response to check.</param>
        public static void CheckResponseForModuleBlock(HttpWebResponse response)
        {
            CheckResponseForStatus(response, 404);
        }

        /// <summary>
        /// Checks the response for what we expect from a malformed request.
        /// </summary>
        /// <param name="response">The response to check.</param>
        public static void CheckResponseForBadRequest (HttpClient.Response response)
        {
            CheckResponseForStatus(response, 400);
        }

        /// <summary>
        /// Checks the response for what we expect from a client timeout.
        /// </summary>
        /// <param name="response">The response to check.</param>
        public static void CheckResponseForClientTimeout (HttpClient.Response response)
        {
            CheckResponseForStatus(response, 408);
        }

        /// <summary>
        /// Checks the response for what we expect from a timeout.
        /// </summary>
        /// <param name="response">The response to check.</param>
        public static void CheckResponseForTimeout (HttpClient.Response response)
        {
            if (response != null)
            {
                throw new AAGatewayException("Got a response when we expected it to timeout.");
            }
        }

        /// <summary>
        /// Checks the response for what we expect from a gateway timeout.
        /// </summary>
        /// <param name="response">The response to check.</param>
        public static void CheckResponseForGatewayTimeout (HttpClient.Response response)
        {
            CheckResponseForStatus(response, 504);
        }

        /// <summary>
        /// Checks for bad things having happened on the server(s).
        /// </summary>
        /// <param name="request">The request that caused nasty things.</param>
        public void CheckForNastyEvents (HttpClient.Request request)
        {
            if (CheckForEventAny("unhandled exception", TestExecutionBegin.AddSeconds(-3)))
            {
                throw new AAGatewayException("A nasty event occured, check the servers for more info.");
            }
        }

        /// <summary>
        /// Sends a request after first making sure that it will pass XRLScan.
        /// </summary>
        /// <param name="client">The client to send with.</param>
        /// <param name="request">The request to send.</param>
        public static void SendRequestPassXRLScan (HttpClient client, HttpClient.Request request)
        {
            if (request.Content != null && request.Content.Length > 0 && request.Method == "GET")
            {
                Global.RO.Warn("A GET request with a body will not have said body when it reaches the front door.");
            }

            client.SendRequest(request);
        }

        /// <summary>
        /// Does the standard request sending: Maps the path, reloads the gateway, sets the module policy, 
        /// reloads the module, sends the request, gets the response.
        /// </summary>
        /// <param name="path">The path to send the request to.</param>
        /// <returns>The response from sending the request.</returns>
        public static HttpClient.Response StandardXRLTestExecute (string path)
        {
            HttpClient.Request request;
            return StandardXRLTestExecute(path, out request);
        }

        /// <summary>
        /// Does the standard request sending: Maps the path, reloads the gateway, sets the module policy, 
        /// reloads the module, sends the request, gets the response.
        /// </summary>
        /// <param name="path">The path to send the request to.</param>
        /// <param name="request">The request that was sent.</param>
        /// <returns>The response from sending the request.</returns>
        public static HttpClient.Response StandardXRLTestExecute (string path, out HttpClient.Request request)
        {
            request = new HttpClient.Request(DefaultHost, path);
            HttpClient client = new HttpClient(AAGatewayServer);
            SendRequestPassXRLScan(client, request);
            return client.GetResponse();
        }

        /// <summary>
        /// Escapes the given string with HTTP escapes (%XX).
        /// </summary>
        /// <param name="input">The string to escape.</param>
        /// <returns>The escaped string.</returns>
        public static string EscapeString (string input)
        {
            StringBuilder buff = new StringBuilder();

            foreach (char c in input)
            {
                buff.Append(Uri.HexEscape(c));
            }

            return buff.ToString();
        }

        /// <summary>
        /// Removes the query string from a given url.
        /// </summary>
        /// <param name="url">The url.</param>
        /// <returns>The url with no query string.</returns>
        public static string RemoveQueryString (string url)
        {
            int pos = url.IndexOf('?');

            if (pos == -1)
            {
                return url;
            }

            return url.Substring(0, pos);
        }

        #endregion
    }

    /// <summary>
    /// An exception thrown by the AAGateway tests.
    /// </summary>
    public class AAGatewayException : Exception
    {
        /// <summary>
        /// Creates a default AAGatewayException.
        /// </summary>
        public AAGatewayException () : base() {}

        /// <summary>
        /// Creates an AAGatewayException with the given message.
        /// </summary>
        /// <param name="message">The message.</param>
        public AAGatewayException (string message) : base(message) {}

        /// <summary>
        /// Creates an AAGatewayException with the given formatted message.
        /// </summary>
        /// <param name="messageFormat">The message to format.</param>
        /// <param name="args">The format arguments.</param>
        public AAGatewayException (string messageFormat, params object[] args) : 
            base(String.Format(messageFormat, args)) { }
    }

    public class AAGatewayInfo
    {
        static AAGatewayInfo ()
        {
            Global.Singleton.EnvironmentChangedSuccessEvent += new Global.EnvironmentChangedDelegate(EnvironmentChangedSuccessEvent);
        }

        static void EnvironmentChangedSuccessEvent (string newEnvironmentName)
        {
            // just invalidate and rebuild later
            _servers = null;
            _AAGatewayServer = null;
            _hostnames = new Dictionary<string,string>();
        }

        /// <summary>The name of the server.</summary>
        public string Name = null;
        /// <summary>The IP end point for Xmgmt.</summary>
        public IPEndPoint XmgmtEndPoint = null;

        /// <summary>The backing for Servers.</summary>
        private static AAGatewayInfo[] _servers = null;

        /// <summary>The list of servers that the AAGateway is on.</summary>
        public static AAGatewayInfo[] Servers
        {
            get
            {
                if (_servers != null)
                {
                    return _servers;
                }

                lock (typeof(AAGatewayInfo))
                {
                    // for case when others are waiting on the lock
                    if (_servers != null)
                    {
                        return _servers;
                    }

                    // maybe this should be replaced with the appropriate const, once its actually there
                    string[] names = Global.XEnv.GetServerListByInterface(Interface.authsg);

                    AAGatewayInfo[] temp = new AAGatewayInfo[names.Length];

                    for (int i = 0; i < names.Length; ++i)
                    {
                        temp[i] = new AAGatewayInfo();

                        temp[i].Name = names[i];

                        IPHostEntry host = null;

                        try
                        {
                            host = Dns.GetHostEntry(names[i]);
                        }
                        catch (SocketException se)
                        {
                            Global.RO.Warn("Could not resolve the server name '{0}': {1}",
                                names[i], se.Message);
                            continue;
                        }

                        for (int j = 0; j < host.AddressList.Length; j++)
                        {
                            if (host.AddressList[j].AddressFamily == AddressFamily.InterNetwork)
                            {
                                Global.RO.Debug("Dns.GetHostEntry for {0} returned {1} entries, using #{2} (ipv4): {3}",
                                                names[i], host.AddressList.Length, j, host.AddressList[j]);
                                temp[i].XmgmtEndPoint = new IPEndPoint(host.AddressList[j], 4100);
                                break;
                            }
                        }
                    }

                    _servers = temp;

                    return _servers;
                }
            }
        }

        /// <summary>The port on which to connect to the AAGateway.</summary>
        public const ushort AAGatewayPort = 11250;
        /// <summary>The port on which to connect to the AA Test Reflector.</summary>
        public const ushort ReflectorPort = 10280;

        private static IPEndPoint _AAGatewayServer = null;

        /// <summary>
        /// This should allow the HttpClient to connect to the AAGateway.
        /// </summary>
        public static IPEndPoint AAGatewayServer
        {
            get
            {
                if (_AAGatewayServer != null)
                {
                    return _AAGatewayServer;
                }

                lock (typeof(AAGatewayInfo))
                {
                    if (_AAGatewayServer == null)
                    {
                        _AAGatewayServer = Global.XEnv.GetVirtualInterface(VirtualInterface.authsg);
                        Global.RO.Debug("Using authsg: {0}", _AAGatewayServer);
                    }
                }

                return _AAGatewayServer;
            }
        }

        private static Dictionary<string, string> _hostnames = new Dictionary<string,string>();

        /// <summary>
        /// Gets the hostname for the given instance.
        /// </summary>
        public static string GetInstanceHostname (string instance)
        {
            Dictionary<string, string> oldHostnames = _hostnames;

            // see if we already know it
            string ans;
            if (oldHostnames.TryGetValue(instance, out ans))
            {
                return ans;
            }

            // we don't, get it
            ServerTestFramework.Database.InstanceEditor editor = ServerTestFramework.Database.InstanceEditor.FromName(instance);
            ans = (editor.Exists ? editor.Hostname : null);

            // save it to a new dictionary
            Dictionary<string, string> newHostnames = new Dictionary<string, string>(oldHostnames);
            newHostnames.Add(instance, ans);
            _hostnames = newHostnames;

            return ans;
        }

        /// <summary>
        /// Creates a string representation of this object.
        /// </summary>
        /// <returns>A string representation of this object.</returns>
        public override string ToString ()
        {
            return (Name == null ? "<No Server Name>" : Name) + " :: " + 
                (XmgmtEndPoint == null ? "<No EndPoint>" : XmgmtEndPoint.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\ContentLength.cs ===
using System;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.protocol;

namespace AAGatewayTests
{
    [TestGroup]
    [CompoundCase("{0}", "POST")]
    [CompoundCase("{0}", "PUT")]
    class ContentLength: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Verb", MyValues[0]);
        }

        [TestCase, TestCasePriority(1)]
        [Description("The header and the body will match.")]
        [CompoundCase("0 B", 0)]
        [CompoundCase("1 B", 1)]
        [CompoundCase("600 B", 600)]
        [CompoundCase("1 MB", 1024 * 1024)]
        [CompoundCase("2 MB", 2 * 1024 * 1024)]
        [CompoundCase("3 MB", 3 * 1024 * 1024)]
        [CompoundCase("4 MB", 4 * 1024 * 1024)]
        public class P_ContentLength_Matching : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = (string)GetContextData("Verb");
                // required to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                byte[] bits = new byte[(int) MyValues[0]];
                (new Random()).NextBytes(bits);

                // put our request onto the first few bytes
                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();

                if (bits.Length >= tfd_req.Size())
                {
                    tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                    tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;
                    tfd_req.WriteStream(new MemoryStream(bits));
                }

                request.SetContentLengthAndBody(bits);

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request); //these are all valid
            }
        }

        [TestCase, TestCasePriority(1)]
        [Description("The header and the body will match but be too large.  These all expect 413.")]
        [CompoundCase("4 MB + 1", 4 * 1024 * 1024 + 1)]
        [CompoundCase("5 MB", 5 * 1024 * 1024)]
        [CompoundCase("6 MB", 6 * 1024 * 1024)]
        [CompoundCase("7 MB", 7 * 1024 * 1024)]
        [CompoundCase("8 MB", 8 * 1024 * 1024)]
        public class N_ContentLength_Matching : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = (string)GetContextData("Verb");
                // required to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                byte[] bits = new byte[(int) MyValues[0]];
                (new Random()).NextBytes(bits);

                // put our request onto the first few bytes
                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();

                if (bits.Length >= tfd_req.Size())
                {
                    tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                    tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;
                    tfd_req.WriteStream(new MemoryStream(bits));
                }

                request.SetContentLengthAndBody(bits);

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForStatus(response, 413); //IIS default config blocks more than 4MB
            }
        }

        [TestCase, TestCasePriority(1)]
        [Description("The response body will be large.")]
        [CompoundCase("0 B", 0)]
        [CompoundCase("1 KB", 1)]
        [CompoundCase("600 KB", 600)]
        [CompoundCase("1 MB", 1024)]
        [CompoundCase("2 MB", 2 * 1024)]
        [CompoundCase("3 MB", 3 * 1024)]
        [CompoundCase("4 MB", 4 * 1024)]
        [CompoundCase("4 MB + 1 KB", 4 * 1024 + 1)]
        [CompoundCase("5 MB", 5 * 1024)]
        [CompoundCase("6 MB", 6 * 1024)]
        [CompoundCase("7 MB", 7 * 1024)]
        [CompoundCase("8 MB", 8 * 1024)]
        public class P_ContentLength_Response : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                int bytes_requested = ((int)MyValues[0]) * 1024;

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = (string)GetContextData("Verb");
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.OutputBody;
                tfd_req.Param = bytes_requested;

                request.SetContentLengthAndBody((byte[])tfd_req);

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForStatus(response, 200);
                CheckResponseForContentLength(response, bytes_requested);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Less interesting mismatch, this will work but not pass the body through. " +
            "It may cause the server to process another request though, as the remaining body will still be read in.")]
        public class P_ContentLength_0_Body_100 : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = (string)GetContextData("Verb");
                // required to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                request.ContentLength = "0";
                request.Content = new byte[100];
                (new Random()).NextBytes(request.Content);

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                // we expect nothing back
                request.Content = null;

                CheckResponseAgainstRequest(response, request);

                // Do another request to see if we can
                request.Nullify();
                response = StandardXRLTestExecute(TestFDReflectPath, out request);

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(3)]
        [Description("This is invalid, and should not be seen by the Gateway.")]
        public class N_ContentLength_Neg1_Body_0 : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = (string)GetContextData("Verb");
                // required to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                request.ContentLength = "-1";

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForBadRequest(response);
            }
        }

        [TestCase, TestCasePriority(3)]
        [Description("The header and the body will not match.")]
        [CompoundCase("L 11B B 10B", 11, 10)]
        [CompoundCase("L 1MB B 1B", 1024 * 1024, 1)]
        [CompoundCase("L 8MB B 1B", 8000000, 1)]
        public class N_ContentLength_Missing_Body : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = (string)GetContextData("Verb");
                // required to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                int content_length = (int)(MyValues[0]);
                request.ContentLength = content_length.ToString();
                request.Content = new byte[(int) (MyValues[1])];
                (new Random()).NextBytes(request.Content);

                // put our request onto the first few bytes
                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();

                if (request.Content.Length >= tfd_req.Size())
                {
                    tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                    tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;
                    tfd_req.WriteStream(new MemoryStream(request.Content));
                }

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                if (content_length > (4 * 1024 * 1024))
                {
                    // More than 4MB == broke
                    CheckResponseForStatus(response, 413);
                }
                else
                {
                    CheckResponseForClientTimeout(response);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Headers.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

using PirateSGTest;

namespace AAGatewayTests
{
    [TestGroup]
    class Headers : TestNode
    {
        /// <summary>
        /// The test base used by header tests.
        /// </summary>
        public class HeaderTestBase : AAGatewayTestBase
        {
            /// <summary>The policy key to use for our header tests.</summary>
            public const string HeaderPolicyKey = TestFDReflectFolderPath + "authsg/Headers";

            /// <summary>The instance of our header test policy.</summary>
            public const string HeaderInstance = "activeauth";

            /// <summary>The policy that we use for this group.</summary>
            private ActiveAuthHttpConfig.PolicyEntry Policy { get; set; }

            public override void PreRun ()
            {
                string currentEnv = Config.Environment;

                Policy = ActiveAuthHttpConfig.GetPolicyEntry(HeaderPolicyKey, currentEnv, HeaderInstance);

                if (Policy == null)
                {
                    Policy = new ActiveAuthHttpConfig.PolicyEntry()
                    {
                        Path = HeaderPolicyKey,
                        Environment = currentEnv,
                        Instance = HeaderInstance
                    };

                    SharedSetup.ConfigureUri(Policy);
                    SharedSetup.Reload();
                }
            }

            /// <summary>
            /// Sets both of the allowlist headers settings.
            /// </summary>
            /// <param name="value">The value to set it to.</param>
            public void SetSetting (string value)
            {
                Policy.AllowListHeadersIncoming = value;
                Policy.AllowListHeadersOutgoing = value;
                ActiveAuthHttpConfig.SetPolicyEntry(Policy);

                ReloadWithFail();
            }

            /// <summary>
            /// Sets the in allowlist headers setting.
            /// </summary>
            /// <param name="value">The value to set it to.</param>
            /// <param name="refresh">True to refresh; false to not.</param>
            public void SetInSetting (string value, bool refresh)
            {
                Policy.AllowListHeadersIncoming = value;
                ActiveAuthHttpConfig.SetPolicyEntry(Policy);

                if (refresh)
                {
                    ReloadWithFail();
                }
            }

            /// <summary>
            /// Sets the out allowlist headers setting.
            /// </summary>
            /// <param name="value">The value to set it to.</param>
            /// <param name="refresh">True to refresh; false to not.</param>
            public void SetOutSetting (string value, bool refresh)
            {
                Policy.AllowListHeadersOutgoing = value;
                ActiveAuthHttpConfig.SetPolicyEntry(Policy);

                if (refresh)
                {
                    ReloadWithFail();
                }
            }

            /// <summary>These headers are likely to be included by the gateway in the proxied request.</summary>
            protected List<string> RequestHeaders = new List<string>(new string[] { 
                "content-length", "connection", "host", "sgipport", "serverport", "expect", "authz", "content-type", "authorization"
            });
            /// <summary>These headers are likely to be included by the gateway in the proxied response.</summary>
            protected List<string> ResponseHeaders = new List<string>(new string[] { 
                "date", "server", "cache-control", "content-type", "content-length", "x-err", "x-powered-by"
            });
            /// <summary>These headers are the ones in the ingoing allowlist.</summary>
            protected List<string> HeadersAllowlistIn = new List<string>(new string[] { "cache-control" });
            /// <summary>These headers are the ones in the outgoing allowlist.</summary>
            protected List<string> HeadersAllowlistOut = new List<string>(new string[] { "cache-control" });

            /// <summary>
            /// Checks the request value of a header against the value seen by the server.
            /// </summary>
            protected virtual void CheckRequestValueAgainstReflectedRequestValue (string name, string requestValue, string reflectedRequestValue)
            {
                ValueCheck.Test("Header [" + name + "] reflected request value", requestValue, reflectedRequestValue);
            }

            /// <summary>
            /// Checks the request value of a header against the value in the response.
            /// </summary>
            protected virtual void CheckRequestValueAgainstResponseValue (string name, string requestValue, string responseValue)
            {
                ValueCheck.Test("Header [" + name + "] response value", requestValue, responseValue);
            }

            /// <summary>
            /// Checks the response against the given request to verify that it was reflected properly.
            /// Additionally checks that only the allowed headers were returned.
            /// </summary>
            /// <param name="response">The response from the request.</param>
            /// <param name="request">The request that generated the response.</param>
            public new void CheckResponseAgainstRequest (HttpClient.Response response, HttpClient.Request request)
            {
                TestFdReflectorResponse reflected =
                    AAGatewayTestBase.CheckResponseAgainstRequest(response, request, false);

                // get the header list from the request
                Dictionary<string, string> request_headers = new Dictionary<string, string>();

                foreach (string header_line in request.OtherHeaders)
                {
                    int pos = header_line.IndexOf(':');
                    if (pos == -1)
                    {
                        throw new AAGatewayException("Request header did not contain a colon: " + header_line);
                    }

                    request_headers.Add(header_line.Substring(0, pos).Trim().ToLower(), header_line.Substring(pos + 1).Trim());
                }

                // check the headers in the reflected request
                Dictionary<string, string> header_check = new Dictionary<string, string>(request_headers);

                foreach (TestFdReflectorResponse.NameValuePairCollection.NameValuePair header_line in reflected.HttpRequest.Headers.Array)
                {
                    string header = header_line.Name.ToLower();

                    if (!(RequestHeaders.Contains(header) || HeadersAllowlistIn.Contains(header)))
                    {
                        throw new AAGatewayException("Found an unexpected header in the reflected request: " + header);
                    }
                    else
                    {
                        if (header_check.ContainsKey(header))
                        {
                            CheckRequestValueAgainstReflectedRequestValue(header, header_check[header], header_line.Value);
                            header_check.Remove(header);
                        }
                    }
                }

                // did any get dropped
                foreach (KeyValuePair<string, string> header in header_check)
                {
                    if (HeadersAllowlistIn.Contains(header.Key))
                    {
                        throw new AAGatewayException("A header in the request was not in the reflected request: " + header.Key);
                    }
                }

                // check the headers in the response
                header_check = new Dictionary<string, string>(request_headers);

                foreach (KeyValuePair<string, string> kvp in response.Headers)
                {
                    string header = kvp.Key.ToLower();

                    // if NOT:
                    //  Direct response header OR
                    //  (Allowed in OR Added by AASG) AND Allowed Out
                    if (!(ResponseHeaders.Contains(header) ||
                          ((HeadersAllowlistIn.Contains(header) || RequestHeaders.Contains(header)) && 
                            HeadersAllowlistOut.Contains(header))))
                    {
                        throw new AAGatewayException("Found an unexpected header in the response: " + kvp.Key);
                    }
                    else
                    {
                        if (header_check.ContainsKey(header))
                        {
                            CheckRequestValueAgainstResponseValue(header, header_check[header], kvp.Value);
                            header_check.Remove(header);
                        }
                    }
                }

                // did any get dropped
                foreach (KeyValuePair<string, string> header in header_check)
                {
                    if (HeadersAllowlistIn.Contains(header.Key) && HeadersAllowlistOut.Contains(header.Key))
                    {
                        throw new AAGatewayException("A header in the request was not in the response: " + header.Key);
                    }
                }
            }

            /// <summary>
            /// Executes the header test send/receive.  Does not do any verification.
            /// </summary>
            /// <param name="headers">The headers to include in the request.</param>
            public void StandardHeaderTestExecuteNoVerification (IEnumerable<string> headers, out HttpClient.Request request,
                out HttpClient.Response response)
            {
                StandardHeaderTestExecuteNoVerification(headers, null, out request, out response);
            }

            /// <summary>
            /// Executes the header test send/receive.  Does not do any verification.
            /// </summary>
            /// <param name="headers">The headers to include in the request.</param>
            public void StandardHeaderTestExecuteNoVerification (IEnumerable<string> headers, IDictionary<string, string> values, 
                out HttpClient.Request request, out HttpClient.Response response)
            {
                request = new HttpClient.Request(DefaultHost,
                    HeaderPolicyKey);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.ReflectHeaders;

                request.SetContentLengthAndBody(refreq.ToArray());

                foreach (string s in headers)
                {
                    string headerValue = null;

                    if (values == null || !values.TryGetValue(s, out headerValue))
                    {
                        headerValue = "Value of " + s;
                    }

                    request.OtherHeaders.AddLast(s + ": " + headerValue);
                }

                request.OtherHeaders.AddLast("Always-blocked: Added by StandardHeaderTestExecute");

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);

                response = client.GetResponse();
            }

            /// <summary>
            /// Executes the header test send/receive.
            /// </summary>
            /// <param name="headers">The headers to include in the request.</param>
            public void StandardHeaderTestExecute (IEnumerable<string> headers)
            {
                StandardHeaderTestExecute(headers, null);
            }

            /// <summary>
            /// Executes the header test send/receive.
            /// </summary>
            /// <param name="headers">The headers to include in the request.</param>
            /// <param name="values">The dictionary of values to use.</param>
            public void StandardHeaderTestExecute (IEnumerable<string> headers, IDictionary<string, string> values)
            {
                HttpClient.Request request;
                HttpClient.Response response;
                StandardHeaderTestExecuteNoVerification(headers, values, out request, out response);

                try
                {
                    CheckResponseAgainstRequest(response, request);
                }
                catch (Exception)
                {
                    if (request != null)
                    {
                        Global.RO.Debug("****** Request ******:\n" + request);
                    }

                    if (response != null)
                    {
                        Global.RO.Debug("****** Response ******:\n" + response);
                    }

                    throw;
                }
            }

            /// <summary>
            /// Sets up the allowlists.
            /// </summary>
            /// <param name="headers">The allowlist.</param>
            public void SetupAllowlist (string[] headers)
            {
                HeadersAllowlistIn.Clear();
                HeadersAllowlistIn.AddRange(headers);
                HeadersAllowlistOut.Clear();
                HeadersAllowlistOut.AddRange(headers);

                string header_list = string.Join(";", headers);
                SetSetting(header_list);
            }

            /// <summary>
            /// Sets up the allowlists.
            /// </summary>
            /// <param name="inHeaders">The in allowlist.</param>
            /// <param name="outHeaders">The out allowlist.</param>
            public void SetupAllowlist (string[] inHeaders, string[] outHeaders)
            {
                SetupInAllowlist(inHeaders, false);
                SetupOutAllowlist(outHeaders, true);
            }

            /// <summary>
            /// Sets up the in allowlist.
            /// </summary>
            /// <param name="headers">The allowlist.</param>
            /// <param name="refresh">True to refresh; false to not.</param>
            public void SetupInAllowlist (string[] headers, bool refresh)
            {
                HeadersAllowlistIn.Clear();
                HeadersAllowlistIn.AddRange(headers);

                string header_list = string.Join(";", headers);
                SetInSetting(header_list, refresh);
            }

            /// <summary>
            /// Sets up the out allowlist.
            /// </summary>
            /// <param name="headers">The allowlist.</param>
            /// <param name="refresh">True to refresh; false to not.</param>
            public void SetupOutAllowlist (string[] headers, bool refresh)
            {
                HeadersAllowlistOut.Clear();
                HeadersAllowlistOut.AddRange(headers);

                string header_list = string.Join(";", headers);
                SetOutSetting(header_list, refresh);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("An empty header allowlist, to ensure that no headers beyond the standard are copied over.")]
        public class P_Whitelist_Empty : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                SetupAllowlist(new string[0]);
                StandardHeaderTestExecute(new string[0]);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("A null header allowlist, to ensure that the defaults get applied.")]
        public class P_Whitelist_Null_Uses_Defaults : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                string currentEnv = Config.Environment.ToLower();

                // get the defaults for the instance
                ActiveAuthHttpConfig.PolicyEntry defaultsPolicy =
                    ActiveAuthHttpConfig.GetPolicyEntry("ALL", currentEnv, currentEnv == "xblob" ? "ALL" : HeaderInstance);

                if (defaultsPolicy == null)
                {
                    throw new DidNotExecuteException("Could not find the ALL policy for instance " + HeaderInstance);
                }

                // parse out the headers and store them
                string[] inHeaders = defaultsPolicy.AllowListHeadersIncoming.Split(new char[] { ',', ';' });
                string[] outHeaders = defaultsPolicy.AllowListHeadersOutgoing.Split(new char[] { ',', ';' });

                HeadersAllowlistIn.Clear();
                HeadersAllowlistIn.AddRange(inHeaders);
                HeadersAllowlistOut.Clear();
                HeadersAllowlistOut.AddRange(outHeaders);

                // null out the headers in the policy
                SetSetting(null);

                StandardHeaderTestExecute(inHeaders);
            }
        }

        [TestCase, TestCasePriority(3)]
        [Description("The whitelist will contain N headers. All headers will need to pass through.")]
        [CompoundCase("100", 100)] //Old BugID = 36920, BugDatabase = "Xbox 360 Console Software"
        [CompoundCase("Max", 1099)] //Old BugID = 36920, BugDatabase = "Xbox 360 Console Software"
        public class P_Whitelist_N : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                string[] list = new string[(int) MyValues[0]];

                for (int i = 0; i < list.Length; ++i)
                {
                    string temp = "";
                    int val = i;

                    do
                    {
                        temp += (char) ((int) 'a' + (val % 26));
                        val = val / 26;
                    } while (val > 0);

                    list[i] = temp;
                }

                SetupAllowlist(list);
                StandardHeaderTestExecute(list);
            }
        }

        [TestCase(BugID = 106236), TestCasePriority(2)]
        [Description("The whitelist will contain a duplicate header entry.")]
        public class N_Whitelist_Duplicate : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                SetupAllowlist(new string[] { "non-duplicate", "duplicate", "duplicate", "not-duplicate" });
                StandardHeaderTestExecute(new string[] { "non-duplicate", "duplicate", "not-duplicate" });
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("The whitelist will contain a header that will already be in the proxied request. Will attempting to add it for a request fail?")]
        public class Edge_Whitelist_Contains_Standard_Header : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                SetupAllowlist(new string[] { "content-type", "content-length" });
                StandardHeaderTestExecute(new string[] { "non-duplicate", "duplicate", "not-duplicate" });
            }
        }

        [TestCase, TestCasePriority(3)]
        [Description("The whitelist will contain few headers. We will send N.")]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100, BugID = 36920, BugDatabase = "Xbox 360 Console Software")]
        [CompoundCase("1000", 1000, BugID = 36920, BugDatabase = "Xbox 360 Console Software")]
        [CompoundCase("2000", 2000, BugID = 36920, BugDatabase = "Xbox 360 Console Software")]
        public class P_Header_Overload : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                SetupAllowlist(RequestHeaders.ToArray());

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    HeaderPolicyKey);

                for (int i = 0; i < (int) MyValues[0]; ++i)
                {
                    string temp = "";
                    int val = i;

                    do
                    {
                        temp += (char) ((int) 'a' + (val % 26));
                        val = val / 26;
                    } while (val > 0);

                    request.OtherHeaders.AddLast(temp + ": 0");
                }

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                CheckResponseAgainstRequest(client.GetResponse(), request);
            }
        }

        [TestCase/*Old (BugID = 114256)*/, TestCasePriority(1)]
        [Description("The content-type header should pass through for responses.")]
        public class P_Header_ContentType_Response : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.ResponseXMLContentType;

                request.SetContentLengthAndBody(refreq.ToArray());

                HttpClient client = new HttpClient(AAGatewayServer);
                client.SendRequest(request);
                HttpClient.Response resp = client.GetResponse();

                // we will check the header
                CheckResponseAgainstRequest(resp, request, false);

                foreach (KeyValuePair<string, string> kvp in resp.Headers)
                {
                    if (kvp.Key.ToLower() == "content-type")
                    {
                        if (kvp.Value.StartsWith("text/xml"))
                        {
                            return;
                        }
                        else
                        {
                            throw new AAGatewayException("Content-type should have been 'text/xml', it was '{0}'", 
                                kvp.Value);
                        }
                    }
                }

                throw new AAGatewayException("Did not find header 'content-type'");
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("The whitelist will contain an internal header, which is not allowed.")]
        public class N_Whitelist_Internal : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                SetupAllowlist(new string[] { XHttpHdr.SUBJECTNAME });
                // the AAGateway should reject this header because it is internal
                // clear our client side list as well
                HeadersAllowlistIn.Clear();
                HeadersAllowlistOut.Clear();
                // if the header makes it through to the reflector, we will fail because
                // our whitelist doesn't contain it anymore
                StandardHeaderTestExecute(new string[] { XHttpHdr.SUBJECTNAME });
            }
        }

        [TestCase, TestCasePriority(1)]
        [Description("The in allowlist will block the header, while the out allow list allows it.  Send it in.")]
        public class NotAllowedIn_AllowedOut_SendIn : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                SetupAllowlist(
                    new string[] { "allowed" }, 
                    new string[] { "allowed", "allowedaut" });
                StandardHeaderTestExecute(new string[] { "allowed", "allowedaut" });
            }
        }

        [TestCase, TestCasePriority(1)]
        [Description("The out allowlist will block the header, while the in allow list allows it.  Send it in.")]
        public class AllowedIn_NotAllowedOut_SendIn : HeaderTestBase
        {
            protected override void AAExecute ()
            {
                SetupAllowlist(
                    new string[] { "allowed", "notallowedout" },
                    new string[] { "allowed" });
                StandardHeaderTestExecute(new string[] { "allowed", "notallowedout" });
            }
        }

        [TestGroup, TestCasePriority(2)]
        [Description("Send the special headers in that require special handling. " +
            "Excludes Content-Length, Content-Type, Host, and User-Agent because these are already included on every request.")]
        public class SpecialHeaders : TestNode
        {

            [TestCase]
            [CompoundCase("{0}", "accept", "text/xml,text/html")]
            [CompoundCase("{0}", "if-modified-since", "Thu, 28 Jul 2011 10:54:00 GMT")]
            [CompoundCase("{0}", "referer", "http://aagatewaytests")]
            // Need to create a separate group for Transfer-Encoding / TE
            //[CompoundCase("{0} - {1}", "transfer-encoding", "chunked")]
            //[CompoundCase("{0} - {1}", "transfer-encoding", "identity")]
            //[CompoundCase("{0} - {1}", "transfer-encoding", "gzip")]
            //[CompoundCase("{0} - {1}", "transfer-encoding", "compress")]
            //[CompoundCase("{0} - {1}", "transfer-encoding", "deflate")]
            [Description("These headers make it through unmodified.")]
            public class Allowed : HeaderTestBase
            {
                protected override void AAExecute ()
                {
                    Dictionary<string, string> dict = new Dictionary<string, string>();
                    dict.Add((string)MyValues[0], (string)MyValues[1]);

                    SetupAllowlist(new string[] { (string)MyValues[0] });
                    StandardHeaderTestExecute(dict.Keys, dict);
                }
            }

            [TestCase]
            [CompoundCase("{0}", "connection", "Keep-alive")]
            [CompoundCase("{0}", "date", "Thu, 28 Jul 2011 10:54:00 GMT")]
            [Description("These headers are dropped by the gateway.")]
            public class Blocked : HeaderTestBase
            {
                protected override void AAExecute ()
                {
                    Dictionary<string, string> dict = new Dictionary<string, string>();
                    dict.Add((string)MyValues[0], (string)MyValues[1]);

                    SetupAllowlist(new string[] { (string)MyValues[0] });

                    HeadersAllowlistIn.Clear();
                    HeadersAllowlistOut.Clear();

                    StandardHeaderTestExecute(dict.Keys, dict);
                }

                protected override void CheckRequestValueAgainstReflectedRequestValue (string name, string requestValue, string reflectedRequestValue)
                {
                    // do nothing, in case the gateway adds either header
                }

                protected override void CheckRequestValueAgainstResponseValue (string name, string requestValue, string responseValue)
                {
                    // do nothing, in case the gateway adds either header
                }
            }

            [TestCase]
            [Description("The expect header can get added to by the server.")]
            public class Expect : HeaderTestBase
            {
                protected string HeaderName = "expect";
                protected string HeaderValue = "Test=false";

                protected override void AAExecute ()
                {
                    Dictionary<string, string> dict = new Dictionary<string, string>();
                    dict.Add(HeaderName, HeaderValue);

                    SetupAllowlist(new string[] { HeaderName });
                    StandardHeaderTestExecute(dict.Keys, dict);
                }

                protected override void CheckRequestValueAgainstReflectedRequestValue (string name, string requestValue, string reflectedRequestValue)
                {
                    CheckValues(name, requestValue, reflectedRequestValue);
                }

                protected override void CheckRequestValueAgainstResponseValue (string name, string requestValue, string responseValue)
                {
                    CheckValues(name, requestValue, responseValue);
                }

                protected void CheckValues (string name, string request, string response)
                {
                    if (name == HeaderName)
                    {
                        string[] vals = response.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                        foreach (string s in vals)
                        {
                            if (HeaderValue == s.Trim())
                            {
                                return;
                            }
                        }

                        throw new AAGatewayException("Did not find the expected value [" + HeaderValue + "] in the " + HeaderName + " header.");
                    }
                    else
                    {
                        base.CheckRequestValueAgainstReflectedRequestValue(name, request, response);
                    }
                }
            }

            [TestCase]
            [Description("Tests the Range header.")]
            [CompoundCase("{0}", "100", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "100-200", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=100-200;bytes=300-400", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "=100", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "=100-200", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=100", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=-", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=200-100", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=100-200,400-300", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=400-300,100-200", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=100-200,300", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=a-b", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=100-quark", null, BugID=73375, BugDatabase="ISS All")]
            [CompoundCase("{0}", "bytes=100-200")]
            [CompoundCase("{0}", "bytes=100-200,", "bytes=100-200")]
            [CompoundCase("{0}", "bytes=100-200,300-400")]
            [CompoundCase("{0}", "bytes=300-400,100-200")]
            [CompoundCase("{0}", "bytes=100-")]
            [CompoundCase("{0}", "bytes=-100")]
            [CompoundCase("{0}", "bytes=100-100")]
            [CompoundCase("{0}", "bytes=100-200,200-300")]
            [CompoundCase("{0}", "bytes=100-200,150-250")]
            [CompoundCase("{0}", "bytes=0-100,100-")]
            [CompoundCase("{0}", "bytes=0-")]
            [CompoundCase("{0}", "cows=100-200")]
            public class Range : HeaderTestBase
            {
                protected string HeaderName = "range";
                protected string HeaderValue;
                protected string ExpectedHeaderValue;

                public override void PreRun ()
                {
                    base.PreRun();

                    HeaderValue = (string)MyValues[0];
                    ExpectedHeaderValue = (MyValues.Length > 1 ? (string)MyValues[1] : HeaderValue);
                }

                protected override void AAExecute ()
                {
                    Dictionary<string, string> dict = new Dictionary<string, string>();
                    dict.Add(HeaderName, HeaderValue);

                    SetupAllowlist(new string[] { HeaderName });

                    StandardHeaderTestExecute(dict.Keys, dict);
                }

                protected override void CheckRequestValueAgainstReflectedRequestValue (string name, string requestValue, string reflectedRequestValue)
                {
                    CheckValues(name, requestValue, reflectedRequestValue);
                }

                protected override void CheckRequestValueAgainstResponseValue (string name, string requestValue, string responseValue)
                {
                    CheckValues(name, requestValue, responseValue);
                }

                protected void CheckValues (string name, string request, string response)
                {
                    if (name == HeaderName)
                    {
                        if (ExpectedHeaderValue == null)
                        {
                            throw new KnownBugException(73375, "TFS: ISS All");
                        }

                        ValueCheck.Test(HeaderName + " value", ExpectedHeaderValue, response);
                    }
                    else
                    {
                        base.CheckRequestValueAgainstReflectedRequestValue(name, request, response);
                    }
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Instances.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

using PirateSGTest;

namespace AAGatewayTests
{
    [TestGroup, TestCasePriority(2)]
    class Instances : TestNode
    {
        /// <summary>The instances that are used by tests.</summary>
        public InstanceEditor[] TestInstances = new InstanceEditor[2];

        public const string MainPolicyKey = AAGatewayTestBase.TestFDReflectFolderPath + "authsg/Instances/Main";
        public const int MainPolicyInstance = 0;

        public const string SharedPolicyKey = AAGatewayTestBase.TestFDReflectFolderPath + "authsg/Instances/Shared";

        public override void PreRun ()
        {
            // if the environment doesn't have a load balancer, create instances for testing
            // if it does, use the existing ones so that we go through the it
            if (EnvironmentHasLoadBalancer)
            {
                TestInstances[0] = InstanceEditor.FromName("activeauth");
                TestInstances[1] = InstanceEditor.FromName("avatar");
            }
            else
            {
                for (int i = 0; i < TestInstances.Length; ++i)
                {
                    string name = "TestInst" + i;

                    InstanceEditor current = InstanceEditor.CreateOrUseExisting(name);
                    current.Hostname = name;

                    TestInstances[i] = current;
                }
            }

            // create policies
            string currentEnv = Config.Environment;

            ActiveAuthHttpConfig.PolicyEntry MainPolicy = new ActiveAuthHttpConfig.PolicyEntry()
            {
                Path = MainPolicyKey,
                Environment = currentEnv,
                Instance = TestInstances[MainPolicyInstance].Name
            };

            SharedSetup.ConfigureUri(MainPolicy);

            for (int i = 0; i < TestInstances.Length; ++i)
            {
                ActiveAuthHttpConfig.PolicyEntry sharedPolicy = new ActiveAuthHttpConfig.PolicyEntry()
                {
                    Path = SharedPolicyKey,
                    Environment = currentEnv,
                    Instance = TestInstances[i].Name,
                    AllowListHeadersIncoming = "InstanceHeader" + i
                };

                SharedSetup.ConfigureUri(sharedPolicy);
            }

            // reload everything
            SharedSetup.Reload();
        }

        public override void PostRun ()
        {
            for (int i = 0; i < TestInstances.Length; ++i)
            {
                TestInstances[i] = null;
            }
        }

        /// <summary>
        /// True if we expect a load balancer to be present; false if not.
        /// </summary>
        protected bool EnvironmentHasLoadBalancer
        {
            get
            {
                string currentEnv = Config.Environment.ToLower();

                if (currentEnv == "xblob")
                {
                    return false;
                }

                return true;
            }
        }

        public class InstanceTestBase : AAGatewayTestBase
        {
            protected Instances InstancesGroupParent
            {
                get
                {
                    TestNode parent = Parent;
                    while (parent != null)
                    {
                        Instances ans = parent as Instances;
                        if (ans != null)
                        {
                            return ans;
                        }
                        parent = parent.Parent;
                    }

                    return null;
                }
            }

            protected InstanceEditor GetInstance(int index)
            {
                Instances inst = InstancesGroupParent;
                return inst.TestInstances[index % inst.TestInstances.Length];
            }

            protected void AddReflectRequest (HttpClient.Request request)
            {
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.Reflect;

                request.SetContentLengthAndBody(refreq.ToArray());
            }
        }


        [TestCase]
        [Description("No Host header at all.")]
        public class NoHostHeaderHTTP11 : InstanceTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);
                HttpClient.Request request = new HttpClient.Request(null, MainPolicyKey);
                AddReflectRequest(request);

                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForBadRequest(response);
            }
        }


        [TestCase]
        [Description("Correct host header value; just to make sure that it will work.")]
        public class CorrectHostHeader : InstanceTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);
                HttpClient.Request request = new HttpClient.Request(GetInstance(MainPolicyInstance).Hostname, MainPolicyKey);
                AddReflectRequest(request);

                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);
            }
        }


        [TestCase]
        [Description("Wrong host header value; the value we pass in is for a different instance.")]
        public class WrongHostHeader : InstanceTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);
                HttpClient.Request request = new HttpClient.Request(GetInstance(MainPolicyInstance + 1).Hostname, MainPolicyKey);
                AddReflectRequest(request);

                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForModuleBlock(response);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\HostRouting.cs ===
using System;
using System.IO;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using PirateSGTest;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework.LiveService;
using System.Collections.Generic;

namespace AAGatewayTests
{
    [TestGroup]
    class HostRouting : TestNode
    {
        public const string TestFDRoutingHost = "testfd.xboxlive.test";

        bool ?prevHttpClientVerbose=null;

        public override void PreRun()
        {
            //add or update the multisetting for routing for testfd
            StaticNpdb.ExecuteNonQuery("delete from t_multisetting_overrides where vc_multisetting='authsg_hostNameMappings' and vc_value like '"+TestFDRoutingHost+"%'");
            string testFdVipIp=Global.XEnv.GetVirtualInterface("testfd").ToString();
            string settingValue=TestFDRoutingHost+","+testFdVipIp;
            StaticNpdb.ExecuteNonQuery("insert into t_multisetting_overrides (vc_environment, vc_component, i_site_id, vc_server, vc_multisetting, vc_value) values ('"+Global.XEnv.GetEnv()+"', 'ALL', -1, 'ALL', 'authsg_hostNameMappings', '"+settingValue+"')");

            AAGatewayTestBase.ConfigCacheRefresh();

            //set httpclient to verbose
            prevHttpClientVerbose = HttpClient.Verbose;
            HttpClient.Verbose = true;
        }

        public override void PostRun()
        {
            //restore httpclient verbose level
            if (prevHttpClientVerbose != null)
            {
                HttpClient.Verbose = (bool)prevHttpClientVerbose;
                prevHttpClientVerbose = null;
            }
        }

        [TestCase, TestCasePriority(1), Description("Simple call directly to TestFD to verify it's working; if it is not working then the other tests here are not valid.")]
        public class P_SanityCheck_TestFdDirect : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient client = new HttpClient(Global.XEnv.GetVirtualInterface("testfd"));

                HttpClient.Request request = new HttpClient.Request(TestFDRoutingHost, TestFDReflectNoAuthSgPath);
                request.Method = "POST";
                // required for a POST to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                // put our request onto the first few bytes
                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();

                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.ReturnStatusAndResponseBody;
                tfd_req.Param = 200;

                request.SetContentLengthAndBody(tfd_req.ToArray());

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                ValueCheck.Test("HTTP Response status code", 200, response.Status);
                ValueCheck.Test("HTTP Response status reason", "Reflector 200", response.Reason);
                ValueCheck.Test("HTTP Response body", "Special TestFD Response Body", response.ContentString);
            }
        }

        [TestCase/* Old(BugID = 128241, BugDatabase = "TFS: ISS All")*/]
        [TestCasePriority(1), Description("Simple call to the reflector through AuthSG using the routing method.")]
        public class P_MainlineReflectSuccess : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(TestFDRoutingHost, TestFDReflectNoAuthSgPath);
                request.Method = "POST";
                // required for a POST to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                // put our request onto the first few bytes
                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();

                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.ReturnStatusAndResponseBody;
                tfd_req.Param = 200;

                request.SetContentLengthAndBody(tfd_req.ToArray());

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                ValueCheck.Test("HTTP Response status code", 200, response.Status);
                ValueCheck.Test("HTTP Response status reason", "Reflector 200", response.Reason);
                ValueCheck.Test("HTTP Response body", "Special TestFD Response Body", response.ContentString);
            }
        }
        
        [TestCase, TestCasePriority(1), Description("Simple validation for various SLS regex routing rules.")]
        public class RegexSLSRouting : AAGatewayTestBase
        {
            protected override void AAExecute()
            {

                string path = "/system/multiplayer/sessions/" + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateNumberString(1);
                PirateSGTest.SharedStressTests.CachedTicket ct = PirateSGTest.SharedStressTests.GetCachedPassportTicket(PirateSGTest.SharedStressTests.TicketCache.Xsts);

                if (ct == null || ct.Ticket == null)
                {
                    throw new DidNotExecuteException("Could not retrieve a cached ticket.");
                }

                HttpWebResponse response = null;
                try
                {
                    var headers = new Dictionary<string,string>();
                    headers.Add("Authorization", "XBL2.0 x=" + ct.Ticket);
                    Global.RO.Info("Trying " + path);
                    response = HttpWebRequestHelper.PrepareAndExecute("https", SharedSetup.SSLHost, SharedSetup.SSLPort, path,null, null, null, "GET", headers);
                }
                finally
                {
                    if (response != null)
                    {
                        ValueCheck.Test("HTTP Response status code", 404, (int)response.StatusCode);
                        response.Close();
                    }
                }
            }
        }


        [TestCase/*Old (BugID = 128241, BugDatabase = "TFS: ISS All")*/]
        [TestCasePriority(1), Description("AuthSG allows error details through only when using routing method.")]
        [CompoundCase("{0}", 400)]
        [CompoundCase("{0}", 401)]
        [CompoundCase("{0}", 402)]
        [CompoundCase("{0}", 403)]
        [CompoundCase("{0}", 404)]
        [CompoundCase("{0}", 500)]
        [CompoundCase("{0}", 501)]
        [CompoundCase("{0}", 502)]
        [CompoundCase("{0}", 503)]
        public class P_MainlineReflectError : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                int httpStatus=(int)MyValues[0];

                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(TestFDRoutingHost, TestFDReflectNoAuthSgPath);
                request.Method = "POST";
                // required for a POST to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                // put our request onto the first few bytes
                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();

                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.ReturnStatusAndResponseBody;
                tfd_req.Param = httpStatus;

                request.SetContentLengthAndBody(tfd_req.ToArray());

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                ValueCheck.Test("HTTP Response status code", httpStatus, response.Status);
                ValueCheck.Test("HTTP Response status reason", "Reflector "+httpStatus, response.Reason);
                ValueCheck.Test("HTTP Response body", "Special TestFD Response Body", response.ContentString);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Mgmt.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace AAGatewayTests
{
    [TestGroup, TestCasePriority(1)]
    class Mgmt : TestNode
    {
        [TestCase/* Old (BugID = 106267)*/]
        [Description("Check that the list command gives back all of the mapped XRLs.")]
        public class P_Mgmt_List : AAGatewayTestBase
        {
            protected const string Newline = "\r\n";
            protected const string InterfaceString = "Interface:  ";
            protected const string NumServString = "Number of services: ";

            protected override void AAExecute ()
            {
                Dictionary<string, XrlMapping> mapped = GetMappedXRLs();
                XmgmtCommandResult[] results = ExecuteXmgmtCmd("e :authsg list");

                foreach (XmgmtCommandResult result in results)
                {
                    // A specific error should have been printed about this already
                    if (!result.Success)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Command failed for {0}", result.Server));
                    }

                    if (result.Response == null)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Got no response from {0}", result.Server));
                    }

                    // Parse the lines from the result
                    Dictionary<string, string> parsed = new Dictionary<string, string>(mapped.Count);
                    int pos = 0, string_end, line_end;

                    while (true)
                    {
                        // first line is the url
                        line_end = result.Response.IndexOf(Newline, pos);
                        if (line_end == -1) { goto parse_error; }

                        string url = result.Response.Substring(pos, line_end - pos);

                        if (url.StartsWith(NumServString))
                        {
                            break;
                        }

                        // now look for the interface
                        pos = line_end + Newline.Length;
                        line_end = result.Response.IndexOf(Newline, pos);
                        if (line_end == -1) { goto parse_error; }
                        string_end = result.Response.IndexOf(InterfaceString, pos, line_end - pos);
                        if (string_end == -1) { goto parse_error; }

                        string_end += InterfaceString.Length;
                        string interface_value = result.Response.Substring(string_end, line_end - string_end);

                        // skip down 3 lines
                        pos = line_end + Newline.Length;

                        for (int i = 0; i < 3; ++i)
                        {
                            line_end = result.Response.IndexOf(Newline, pos);
                            if (line_end == -1) { goto parse_error; }
                            pos = line_end + Newline.Length;
                        }

                        // add them to the dictionary
                        parsed.Add(url, interface_value);
                    }

                    bool good = true;
                    string currentEnv = Config.Environment.ToLower();

                    foreach (KeyValuePair<string, XrlMapping> kvp in mapped)
                    {
                        string lower = kvp.Key.ToLower();
                        string allInterface = null;
                        string effectiveInterface = null;

                        if (parsed.ContainsKey(lower))
                        {
                            foreach (XrlMapping.Entry entry in kvp.Value.Entries)
                            {
                                string env = entry.Environment.ToLower();

                                if (env == currentEnv)
                                {
                                    effectiveInterface = entry.VirtualInterface;
                                }
                                else if (env == "all")
                                {
                                    allInterface = entry.VirtualInterface;
                                }
                            }

                            effectiveInterface = effectiveInterface ?? allInterface;

                            if (parsed[lower] == effectiveInterface)
                            {
                                parsed.Remove(lower);
                                continue;
                            }
                        }

                        // if effective interface is null, the mapping isn't valid in this environment
                        if (effectiveInterface != null)
                        {
                            Global.RO.Error("Unable to find database mapping: {0} -> ", kvp.Key, effectiveInterface);
                            good = false;
                        }
                    }

                    foreach (KeyValuePair<string, string> kvp in parsed)
                    {
                        Global.RO.Error("Unable to find parsed mapping: {0} -> {1}", kvp.Key, kvp.Value);
                        good = false;
                    }

                    if (good)
                    {
                        continue;
                    }
                    else
                    {
                        throw new UnexpectedTestResultException();
                    }

                parse_error:
                    throw new AAGatewayException("Error encountered while processing list output:\n{0}",
                        result.Response);
                }
            }
        }

        [TestCase]
        [Description("Verify that reload does pick up changes to settings and mapped XRLs. This test, and every call to reload, will expect the XEvent.Id.AAGW_CONFIG_INFO event.")]
        public class P_Mgmt_Reload : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = null;
                HttpClient.Request request = null;

                try
                {
                    // unmap or we will fail
                    MapFromGatewayToVirtualInterfaceDEPRECATED(TestFDReflectPath, ReflectorVInterfaceName, false);
                    ReloadWithFail();

                    client = new HttpClient(AAGatewayServer);
                    request = new HttpClient.Request(DefaultHost,
                        TestFDReflectPath);
                }
                finally
                {
                    // map it
                    MapFromGatewayToVirtualInterfaceDEPRECATED(TestFDReflectPath, ReflectorVInterfaceName, true);
                }

                // first without reloading
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForGatewayUnknownService(response, request);

                // reload
                ReloadWithFail();

                // and now it should work
                client.SendRequest(request);
                response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Timeout.cs ===
using System;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

using PirateSGTest;

namespace AAGatewayTests
{
    [TestGroup]
    class Timeout: TestNode
    {
        //There are two timeouts in the AuthSG:
        //  authsg_requestTimeoutSeconds - the time it takes for the client to send it's request to the authsg + the authsg to forward that request to a backend server
        //  authsg_gatewayTimeoutSeconds - the time it takes for the backend server to respond to the authsg + the authsg to forward that response to the client

        // helpers

        const int responseTimeAllowedVarianceInMs=984;

        public static void MakeTestFDDelayedReflectRequest(int delayInMsOnServer, int delayInMsOnClient, out HttpClient.Response response, out int responseTimeInMs)
        {
            HttpClient client=new HttpClient(AAGatewayTestBase.AAGatewayServer);
            HttpClient.Request request=new HttpClient.Request(AAGatewayTestBase.DefaultHost, AAGatewayTestBase.TestFDReflectPath);
            request.Method="POST";
            request.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will block it without this

            TestFdReflectorRequest refreq=new TestFdReflectorRequest();
            refreq.CallerValue=TestFdReflectorRequest.Caller.AuthSG;
            refreq.ActionValue=TestFdReflectorRequest.Action.ResponseWait;
            refreq.Param=delayInMsOnServer;

            request.SetContentLengthAndBody(refreq.ToArray());

            System.DateTime startTime=System.DateTime.UtcNow;
            if (delayInMsOnClient>0) //we will delay before sending the last byte of the body
            {
                //split the request up
                byte []reqbytes=request.ToBytes();
                uint part0Len=(uint)reqbytes.Length-1;
                uint part1Len=(uint)1;
                byte []part0=new byte[part0Len];
                byte []part1=new byte[part1Len];
                Array.Copy(reqbytes, 0, part0, 0, part0Len);
                Array.Copy(reqbytes, part0Len, part1, 0, part1Len);

                //disable the nagle algorithm, to guarentee that both halves of the request go out in different packets
                client.Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);

                //send both halves with a delay between them
                client.Connect();
                client.Socket.Send(part0);
                System.Threading.Thread.Sleep(delayInMsOnClient);
                client.Socket.Send(part1);
            }
            else //no delay, just send it all
            {
                client.SendRequest(request);
            }
            response=client.GetResponse();
            System.DateTime endTime=System.DateTime.UtcNow;
            responseTimeInMs=(int)((endTime-startTime).TotalMilliseconds);
        }

        public static void VerifyResponseCode(HttpClient.Response response, int? expectedCode)
        {
            if (expectedCode==null) //expect no response
            {
                if (response!=null)
                {
                    throw new UnexpectedTestResultException("Expected no response.  Got a response of: "+response.Status+" "+response.Reason);
                }
                return;
            }

            if (response==null && expectedCode!=null)
            {
                throw new UnexpectedTestResultException("Expected a response of: "+expectedCode+".  Got no response.");
            }

            if ((int)expectedCode!=response.Status)
            {
                throw new UnexpectedTestResultException("Expected a response of: "+expectedCode+".  Got a response of: "+response.Status+" "+response.Reason);
            }
        }

        public static void VerifyResponseTime(int gotTimeInMs, int expectedTimeInMs)
        {
            VerifyResponseTime(gotTimeInMs, expectedTimeInMs, responseTimeAllowedVarianceInMs);
        }

        public static void VerifyResponseTime(int gotTimeInMs, int expectedTimeInMs, int allowedVarianceInMs)
        {
            int diff=Math.Abs(gotTimeInMs-expectedTimeInMs);
            if (diff>allowedVarianceInMs)
            {
                throw new UnexpectedTestResultException("Expected request to take: "+expectedTimeInMs+"ms (+-"+allowedVarianceInMs+"ms).  Actual time: "+gotTimeInMs+"ms");
            }
        }

        // setup/cleanup

        protected static SettingState orig_authsg_requestTimeoutSeconds=null;
        protected static SettingState orig_authsg_gatewayTimeoutSeconds=null;

        public override void PreRun()
        {
            //look at the current setting state so we know what to restore to
            orig_authsg_requestTimeoutSeconds=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.authsg_requestTimeoutSeconds, 1);
            orig_authsg_gatewayTimeoutSeconds=Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.authsg_gatewayTimeoutSeconds, 1);
        }

        public override void PostRun()
        {
            //restore the settings to their original values
            if (orig_authsg_requestTimeoutSeconds!=null)
            {
                Global.RO.Debug("Restoring authsg_requestTimeoutSeconds");
                Global.XEnv.RestoreOverrideSettingState(orig_authsg_requestTimeoutSeconds);
                orig_authsg_requestTimeoutSeconds=null;
            }

            if (orig_authsg_gatewayTimeoutSeconds!=null)
            {
                Global.RO.Debug("Restoring authsg_gatewayTimeoutSeconds");
                Global.XEnv.RestoreOverrideSettingState(orig_authsg_gatewayTimeoutSeconds);
                orig_authsg_gatewayTimeoutSeconds=null;
            }

            AAGatewayTestBase.ConfigCacheRefresh();
        }

        // pre test

        [TestCase, Description("This sends out a burst of requests to TestFD through AuthSG to make sure IIS is alive and ready everywhere, since these tests are somewhat timing dependent.")]
        public class WakeUpIIS: TestNode
        {
            public override void Run()
            {
                HttpClient.Response dummyResponse;
                int dummyTime;
                for (int i=0; i<50; ++i)
                {
                    MakeTestFDDelayedReflectRequest(i, i, out dummyResponse, out dummyTime);
                }
                Global.RO.Debug("Requests complete.");

                System.Threading.Thread.Sleep(1000); //give iis a chance to calm back down
            }
        }

        // tests

        [TestGroup, Description("authsg_requestTimeoutSeconds and authsg_gatewayTimeoutSeconds are equal, at 5 seconds each."), AsyncThreadDelay(250)]
        public class BothTimeouts5Seconds: TestNode
        {
            public override void PreRun()
            {
                int settingRequestSeconds=5;
                Global.RO.Debug("Setting authsg_requestTimeoutSeconds to: "+settingRequestSeconds);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.authsg_requestTimeoutSeconds, settingRequestSeconds.ToString());

                int settingGatewaySeconds=5;
                Global.RO.Debug("Setting authsg_gatewayTimeoutSeconds to: "+settingGatewaySeconds);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.authsg_gatewayTimeoutSeconds, settingGatewaySeconds.ToString());

                AAGatewayTestBase.ConfigCacheRefresh();

                System.Threading.Thread.Sleep(1000); //this is weird, but requests that occur very quickly after a reload take longer to complete.  delay here so that that doesn't affect the actual tests.
            }

            [TestCase]
            public void NoDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(0, 0, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 0);
            }

            [TestCase, AsyncGroup(1)]
            public void Client4SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(0, 4000, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 4000);
            }

            [TestCase, AsyncGroup(1)]
            public void Server4SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(4000, 0, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 4000);
            }

            [TestCase, AsyncGroup(1)]
            public void Both4SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(4000, 4000, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 8000);
            }

            [TestCase, AsyncGroup(1)]
            public void Client6SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(0, 6000, out response, out timeToRespond);
                VerifyResponseCode(response, 408);
                VerifyResponseTime(timeToRespond, 6000); //note that it should have actually occured after 5 seconds but our tests slept for 6 seconds
            }

            [TestCase, AsyncGroup(1)]
            public void Server6SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(6000, 0, out response, out timeToRespond);
                VerifyResponseCode(response, 504);
                VerifyResponseTime(timeToRespond, 5000); //gateway should return after 5 seconds even though testfd is still sleeping
            }

            [TestCase, AsyncGroup(1)]
            public void Both6SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(6000, 6000, out response, out timeToRespond);
                VerifyResponseCode(response, 408); //we will hit the client time out, testfd won't even get the request
                VerifyResponseTime(timeToRespond, 6000);
            }

            [TestCase, AsyncGroup(1)]
            public void Client4SecondDelayServer6SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(6000, 4000, out response, out timeToRespond);
                VerifyResponseCode(response, 504); //we will hit the server time out
                VerifyResponseTime(timeToRespond, 9000); //4 second client + 5 second timeout on server
            }
        } //class BothTimeouts5Seconds

        [TestGroup, Description("Leave the timeouts at the default (should be 60 seconds each)."), AsyncThreadDelay(250)]
        public class BothTimeouts60Seconds: TestNode
        {
            public override void PreRun()
            {
                int settingRequestSeconds=60;
                Global.RO.Debug("Setting authsg_requestTimeoutSeconds to: "+settingRequestSeconds);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.authsg_requestTimeoutSeconds, settingRequestSeconds.ToString());

                int settingGatewaySeconds=60;
                Global.RO.Debug("Setting authsg_gatewayTimeoutSeconds to: "+settingGatewaySeconds);
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.authsg_gatewayTimeoutSeconds, settingGatewaySeconds.ToString());

                AAGatewayTestBase.ConfigCacheRefresh();

                System.Threading.Thread.Sleep(1000); //this is weird, but requests that occur very quickly after a reload take longer to complete.  delay here so that that doesn't affect the actual tests.
            }

            [TestCase]
            public void NoDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(0, 0, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 0);
            }

            [TestCase, AsyncGroup(1)]
            public void Client1SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(0, 1000, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 1000);
            }

            [TestCase, AsyncGroup(1)]
            public void Server1SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(1000, 0, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 1000);
            }

            [TestCase, AsyncGroup(1)]
            public void Client59SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(0, 59000, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 59000);
            }

            [TestCase, AsyncGroup(1)]
            public void Server59SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(59000, 0, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 59000);
            }

            [TestCase, AsyncGroup(1)]
            public void Both59SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(59000, 59000, out response, out timeToRespond);
                VerifyResponseCode(response, 200);
                VerifyResponseTime(timeToRespond, 59000+59000, responseTimeAllowedVarianceInMs*2);
            }

            [TestCase, AsyncGroup(1)]
            public void Client61SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(0, 61000, out response, out timeToRespond);
                VerifyResponseCode(response, 408);
                VerifyResponseTime(timeToRespond, 61000); //note that it should have actually occured after 60 seconds but our tests slept for 6 seconds
            }

            [TestCase, AsyncGroup(1)]
            public void Server61SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(61000, 0, out response, out timeToRespond);
                VerifyResponseCode(response, 504);
                VerifyResponseTime(timeToRespond, 60000); //gateway should return after 60 seconds even though testfd is still sleeping
            }

            [TestCase, AsyncGroup(1)]
            public void Client59SecondDelayServer61SecondDelay()
            {
                HttpClient.Response response;
                int timeToRespond;
                MakeTestFDDelayedReflectRequest(61000, 59000, out response, out timeToRespond);
                VerifyResponseCode(response, 504); //we will hit the server time out
                VerifyResponseTime(timeToRespond, 61000+59000, responseTimeAllowedVarianceInMs*2);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Stress.cs ===
using System;
using System.Net;
using System.Net.Cache;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using AAGatewayTests;

using xonline.common.protocol;

#pragma warning disable 420 //a reference to a volatile field will not be treated as volatile

namespace PirateSGTest
{
    [TestGroup]
    public partial class SharedStressTests : TestNode
    {
        public const int MaxAsyncRequests=25000; //each generally consumes 1 port on the client, if we get much more than this we'll run out of ports
        public volatile static int AsyncRequestsInProgress=0;

        public const string StressVariantBasePath = "/testfd/Reflect/authsg/stress/variant";
        public const int StressVariantCount = 100;

        public static string GetStressVariantPath ()
        {
            return StressVariantBasePath + RandomEx.GlobalRandGen.Next(StressVariantCount).ToString();
        }

        [StressTest(TargetTPS = 0)]
        public class Evil_Headers_2000 : TestNode
        {
            private byte[] requestWith2000Headers = null;

            public override void PreRun ()
            {
                HttpClient.Request request = new HttpClient.Request(
                    AAGatewayTestBase.DefaultHost, AAGatewayTestBase.TestFDReflectPath);

                for (int i = 0; i < 2000; ++i)
                {
                    request.OtherHeaders.AddLast(String.Format("Header{0}: 0", i));
                }

                requestWith2000Headers = request.ToBytes();
            }


            public override void Run()
            {
                HttpClient client = new HttpClient(AAGatewayTestBase.AAGatewayServer);
                client.SendRequest(requestWith2000Headers);

                HttpClient.Response response = client.GetResponse();
                VerifyResponseCode(response, 200);

                if (!CheckResponseAgainstURL(response, AAGatewayTestBase.TestFDReflectPath))
                {
                    throw new UnexpectedTestResultException();
                }
            }
        }

        [StressTest(TargetTPS = 0.001f)]
        public class Reload : TestNode
        {
            public override void Run()
            {
                AAGatewayTestBase.ReloadWithFail();
            }
        }

        [StressTest(TargetTPS = 10)]
        public class Varied_URL : TestNode
        {
            public override void Run()
            {
                HttpClient client = new HttpClient(AAGatewayTestBase.AAGatewayServer);
                HttpClient.Request request = new HttpClient.Request(
                    AAGatewayTestBase.DefaultHost, GetStressVariantPath());

                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();
                VerifyResponseCode(response, 200);
                if (!CheckResponseAgainstURL(response, request.URI))
                {
                    throw new UnexpectedTestResultException();
                }
            }
        }

        [StressTest(TargetTPS=0)]
        [Description("Reflector will wait for longer than the timeout of the server.")]
        public class Request_Timeout : TestNode
        {
            protected static int timeout = 0;

            public override void OneTimeSetup()
            {
                timeout = xonline.common.config.Config.GetIntSetting("authsg_timeoutInSeconds");
                Global.RO.Debug("Timeout is {0} seconds, sleeping the reflector for {1}", timeout, timeout + 2);
            }

            public override void Run()
            {
                HttpClient.Request request = new HttpClient.Request(
                    AAGatewayTestBase.DefaultHost,
                    AAGatewayTestBase.TestFDReflectPath);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param = (timeout + 2) * 1000;

                request.SetContentLengthAndBody(refreq.ToArray());

                HttpClient client = new HttpClient(AAGatewayTestBase.AAGatewayServer);
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                AAGatewayTestBase.CheckResponseForGatewayTimeout(response);
            }
        }

        [StressTest(TargetTPS=1)]
        [Description("Make a request through the AuthSG with an XSTS Token")]
        public class Request_XSTSToken : TestNode
        {
            public override void Run()
            {
                CachedTicket ct = SharedStressTests.GetCachedPassportTicket(TicketCache.Xsts);

                if (ct == null || ct.Ticket == null)
                {
                    throw new DidNotExecuteException("Could not retrieve a cached ticket.");
                }

                HttpClient client = new HttpClient(AAGatewayTestBase.AAGatewayServer);
                HttpClient.Request request = new HttpClient.Request(
                    AAGatewayTestBase.DefaultHost, GetStressVariantPath());

                request.OtherHeaders.AddLast("Authorization: XBL2.0 x=" + ct.Ticket);

                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();
                VerifyResponseCode(response, 200);
                if (!CheckResponseAgainstURL(response, request.URI))
                {
                    throw new UnexpectedTestResultException("Expected requsest to succeed.");
                }
            }
        }

        [StressTest(TargetTPS = 1)]
        [Description("Make a request through the AuthSG with an XSTS Token and SSL")]
        public class Request_XSTSToken_SSL : TestNode
        {
            public override void Run ()
            {
                CachedTicket ct = SharedStressTests.GetCachedPassportTicket(TicketCache.Xsts);

                if (ct == null || ct.Ticket == null)
                {
                    throw new DidNotExecuteException("Could not retrieve a cached ticket.");
                }

                // put info into C#'s requester
                string requestString = "https://" + SharedSetup.SSLHost + ":" + SharedSetup.SSLPort +
                    GetStressVariantPath();
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                netreq.KeepAlive = false;
                netreq.Headers.Add("Authorization: XBL2.0 x=" + ct.Ticket);

                // add testfd request data
                netreq.Method = "POST";
                netreq.ContentType = "text/xml";

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                byte[] postData = tfd_req.ToArray();
                netreq.ContentLength = postData.Length;

                using (System.IO.Stream stream = netreq.GetRequestStream())
                {
                    stream.Write(postData, 0, postData.Length);
                }

                //try the request
                using (WebResponse netresp = netreq.GetResponse())
                {
                    // do nothing
                }
            }
        }

        [StressTest, Description("Add 20 random headers to the request.")]
        public class TwentyRandomHeaders: TestNode
        {
            public override void Run()
            {
                //send
                HttpClient client=new HttpClient(AAGatewayTestBase.AAGatewayServer);
                HttpClient.Request request=new HttpClient.Request(AAGatewayTestBase.DefaultHost, AAGatewayTestBase.TestFDReflectPath);
                request.Method="POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will block it without this

                for (int i=0; i<20; ++i)
                {
                    string headerName="X"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(10, 50);
                    string headerValue=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(3, 7);
                    request.OtherHeaders.AddLast(headerName+": "+headerValue);
                }

                TestFdReflectorRequest refreq=new TestFdReflectorRequest();
                refreq.CallerValue=TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue=TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param=0;

                request.SetContentLengthAndBody(refreq.ToArray());
                client.SendRequest(request);

                //receieve
                HttpClient.Response response=client.GetResponse();
                VerifyResponseCode(response, 200);
            }
        }

        [StressTest, Description("Send a POST request for 0 bytes.")]
        public class Post0Bytes: TestNode
        {
            public override void Run()
            {
                //send
                HttpClient client=new HttpClient(AAGatewayTestBase.AAGatewayServer);
                HttpClient.Request request=new HttpClient.Request(AAGatewayTestBase.DefaultHost, AAGatewayTestBase.TestFDReflectPath);
                request.Method="POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will block it without this

                request.SetContentLengthAndBody(new byte[0]);
                client.SendRequest(request);

                //receieve
                HttpClient.Response response=client.GetResponse();
                VerifyResponseCode(response, 200);
            }
        }

        [StressTest]
        [CompoundCase("{0}{1}ms", "POST", 0)]
        [CompoundCase("{0}{1}ms", "POST", 1000)]
        [CompoundCase("{0}{1}ms", "POST", 10000)]
        [CompoundCase("{0}{1}ms", "POST", 100000)]
        [CompoundCase("{0}{1}ms", "GET", 0)]
        [CompoundCase("{0}{1}ms", "GET", 1000)]
        [CompoundCase("{0}{1}ms", "GET", 10000)]
        [CompoundCase("{0}{1}ms", "GET", 100000)]
        [Description("This is an async stress test that instructs the remote server (testfd in this case) behind the authsg to sleep for some amount of time before responding.")]
        public class AsyncServerDelay: AsyncStressTestNode
        {
            class AsyncData
            {
                public AsyncStressTracking Tracker;
                public HttpClient Client;
                public System.DateTime SendTime;
                public int ExpectedServerCode;
            };

            public override void Begin(AsyncStressTracking tracker)
            {
                if (AsyncRequestsInProgress>MaxAsyncRequests)
                {
                    End(new DidNotExecuteException("Too many requests in progress."), tracker);
                    return;
                }

                //setup and send request
                string verb=(string)MyValues[0];
                int serverSleepInMs=(int)MyValues[1];

                HttpClient client=new HttpClient(AAGatewayTestBase.AAGatewayServer);
                HttpClient.Request request=new HttpClient.Request(AAGatewayTestBase.DefaultHost, AAGatewayTestBase.TestFDReflectPath);
                request.Method=verb;
                if (verb=="POST" || verb=="PUT")
                {
                    request.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will block it without this
                }

                TestFdReflectorRequest refreq=new TestFdReflectorRequest();
                refreq.CallerValue=TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue=TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param=serverSleepInMs;

                request.SetContentLengthAndBody(refreq.ToArray());
                client.SendRequest(request);

                //setup callback for async completion
                AsyncData ad=new AsyncData();
                ad.Tracker=tracker;
                ad.Client=client;
                ad.SendTime=System.DateTime.UtcNow;
                if (serverSleepInMs<60000)
                {
                    ad.ExpectedServerCode=200;
                }
                else
                {
                    ad.ExpectedServerCode=504;
                }
                client.BeginGetResponse(HandleResponse, ad);
                System.Threading.Interlocked.Increment(ref AsyncRequestsInProgress);
            }

            public void HandleResponse(IAsyncResult iar)
            {
                System.Threading.Interlocked.Decrement(ref AsyncRequestsInProgress);

                AsyncData ad=(AsyncData)iar.AsyncState;
                try
                {
                    HttpClient.Response response=ad.Client.EndGetResponse(iar);

                    if (response==null)
                    {
                        End(new UnexpectedTestResultException("Server returned no response after "+(System.DateTime.UtcNow-ad.SendTime).TotalMilliseconds+"ms"), ad.Tracker);
                        return;
                    }

                    if (response.Status!=ad.ExpectedServerCode)
                    {
                        End(new UnexpectedTestResultException("Expected "+ad.ExpectedServerCode+", but server returned: "+response.Status+" "+response.Reason+", after "+(System.DateTime.UtcNow-ad.SendTime).TotalMilliseconds+"ms"), ad.Tracker);
                        return;
                    }
                }
                catch (System.Exception e)
                {
                    End(e, ad.Tracker);
                    return;
                }

                End(ad.Tracker);
            }
        }

        [StressTest]
        [CompoundCase("{0}{1}ms", "POST", 0)]
        [CompoundCase("{0}{1}ms", "POST", 1000)]
        [CompoundCase("{0}{1}ms", "POST", 10000)]
        [CompoundCase("{0}{1}ms", "POST", 100000)]
        [CompoundCase("{0}{1}ms", "GET", 0)]
        [CompoundCase("{0}{1}ms", "GET", 1000)]
        [CompoundCase("{0}{1}ms", "GET", 10000)]
        [CompoundCase("{0}{1}ms", "GET", 100000)]
        [Description("This is an async stress test where the client sends part of the request, sleeps a while, then sends the request of the request.")]
        public class AsyncClientDelay: AsyncStressTestNode
        {
            class RequestState
            {
                public AsyncStressTestNode Test;
                public AsyncStressTracking Tracker;
                public HttpClient Client;
                public byte []LastByteToSend;
                public System.DateTime TimeAfterWhichToSendTheLastByte;
                public System.DateTime SendTime;
                public int ExpectedServerCode;
            }

            static TimedQueue<RequestState> clientsInProcess=new TimedQueue<RequestState>();
            static int WorkerThreadCount=System.Environment.ProcessorCount/2;
            volatile static int threadsRunning=0;
            volatile static bool isRunning=false;

            static object setupLock=new object();

            public override void PreRun()
            {
                //create threads
                lock (setupLock)
                {
                    if (isRunning)
                    {
                        return;
                    }

                    isRunning=true;
                }

                threadsRunning=WorkerThreadCount;
                Global.RO.Debug("Creating "+WorkerThreadCount+" threads for AsyncClientDelay stress.");
                for (int i=0; i<WorkerThreadCount; ++i)
                {
                    ThreadMaker.CreateThread(WorkerThreadProc).Start();
                }
            }

            public override void PostRun()
            {
                //tell threads to end, then wait for them to end
                lock (setupLock)
                {
                    if (!isRunning)
                    {
                        return;
                    }

                    isRunning=false;
                }

                Global.RO.Debug("Waiting on AsyncClientDelay stress threads to end...");
                while (threadsRunning>0)
                {
                    System.Threading.Thread.Sleep(100);
                }
                Global.RO.Debug("All AsyncClientDelay async receiving stress threads ended.");
            }

            static void WorkerThreadProc()
            {
                while (isRunning || clientsInProcess.Count>0)
                {
                    RequestState t=clientsInProcess.PopFront();
                    if (t==null)
                    {
                        System.Threading.Thread.Sleep(100);
                        continue;
                    }

                    bool finishedSend=false;
                    System.Exception err=WorkerThreadProc_ProcessClient(t, ref finishedSend);

                    if (err!=null)
                    {
                        System.Threading.Interlocked.Decrement(ref AsyncRequestsInProgress);
                        t.Test.End(err, t.Tracker);
                    }
                    else if (finishedSend)
                    {
                        System.Threading.Interlocked.Decrement(ref AsyncRequestsInProgress);
                        t.Test.End(t.Tracker);
                    }
                    else
                    {
                        clientsInProcess.PushBack(t);
                    }
                }

                System.Threading.Interlocked.Decrement(ref threadsRunning);
            }

            static System.Exception WorkerThreadProc_ProcessClient(RequestState t, ref bool finishedSend)
            {
                try
                {
                    if (System.DateTime.UtcNow<t.TimeAfterWhichToSendTheLastByte)
                    {
                        finishedSend=false;
                        return null;
                    }

                    //send the last byte
                    t.Client.Socket.Send(t.LastByteToSend);

                    //set callback for async completion
                    t.Client.BeginGetResponse(HandleResponse, t);
                    finishedSend=true;
                    return null;
                }
                catch (System.Exception e)
                {
                    finishedSend=true;
                    return e;
                }
            }

            public static void HandleResponse(IAsyncResult iar)
            {
                System.Threading.Interlocked.Decrement(ref AsyncRequestsInProgress);

                RequestState t=(RequestState)iar.AsyncState;
                try
                {
                    HttpClient.Response response=t.Client.EndGetResponse(iar);

                    if (response==null)
                    {
                        t.Test.End(new UnexpectedTestResultException("Server returned no response after "+(System.DateTime.UtcNow-t.SendTime).TotalMilliseconds+"ms"), t.Tracker);
                        return;
                    }

                    if (response.Status!=t.ExpectedServerCode)
                    {
                        t.Test.End(new UnexpectedTestResultException("Expected "+t.ExpectedServerCode+", but server returned: "+response.Status+" "+response.Reason+", after "+(System.DateTime.UtcNow-t.SendTime).TotalMilliseconds+"ms"), t.Tracker);
                        return;
                    }
                }
                catch (System.Exception e)
                {
                    t.Test.End(e, t.Tracker);
                    return;
                }

                t.Test.End(t.Tracker);
            }

            public override void Begin(AsyncStressTracking tracker)
            {
                if (AsyncRequestsInProgress>MaxAsyncRequests)
                {
                    End(new DidNotExecuteException("Too many requests in progress."), tracker);
                    return;
                }

                //setup and prepare request
                string verb=(string)MyValues[0];
                int clientSleepInMs=(int)MyValues[1];

                HttpClient client=new HttpClient(AAGatewayTestBase.AAGatewayServer);
                HttpClient.Request request=new HttpClient.Request(AAGatewayTestBase.DefaultHost, AAGatewayTestBase.TestFDReflectPath);
                request.Method=verb;
                if (verb=="POST" || verb=="PUT")
                {
                    request.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will block it without this
                }

                TestFdReflectorRequest refreq=new TestFdReflectorRequest();
                refreq.CallerValue=TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue=TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param=0; //server sleep time in ms

                request.SetContentLengthAndBody(refreq.ToArray());

                //break the request up into parts
                byte []reqbytes=request.ToBytes();
                uint part0Len=(uint)reqbytes.Length-1;
                uint part1Len=(uint)1;
                byte []part0=new byte[part0Len];
                byte []part1=new byte[part1Len];
                Array.Copy(reqbytes, 0, part0, 0, part0Len);
                Array.Copy(reqbytes, part0Len, part1, 0, part1Len);

                //disable the nagle algorithm, to guarentee that both halves of the request go out in different packets
                client.Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);

                //send the first part of the request (all but 1 byte)
                client.Connect();
                client.Socket.Send(part0);

                //queue the last byte to be sent later
                RequestState state=new RequestState();
                state.Test=this;
                state.Tracker=tracker;
                state.Client=client;
                state.LastByteToSend=part1;
                state.TimeAfterWhichToSendTheLastByte=System.DateTime.UtcNow+new System.TimeSpan(0, 0, 0, 0, clientSleepInMs);
                state.SendTime=System.DateTime.UtcNow;
                if (clientSleepInMs<60000)
                {
                    state.ExpectedServerCode=200;
                }
                else
                {
                    state.ExpectedServerCode=408;
                }
                clientsInProcess.PushBack(state);
                System.Threading.Interlocked.Increment(ref AsyncRequestsInProgress);
            }
        }

        [StressTest]
        [CompoundCase("{0} wait", "POST", false)]
        [CompoundCase("{0} wait", "GET", false)]
        [CompoundCase("{0} close", "POST", true)]
        [CompoundCase("{0} close ", "GET", true)]
        [Description("This is an async stress test where the client sends part of the request but never sends the rest of the request.  Server should return 408.  In one set we just close the socket immediately.")]
        public class AsyncClientNeverSendsLastByte: AsyncStressTestNode
        {
            class AsyncData
            {
                public AsyncStressTracking Tracker;
                public HttpClient Client;
                public System.DateTime SendTime;
            };

            public override void Begin(AsyncStressTracking tracker)
            {
                if (AsyncRequestsInProgress>MaxAsyncRequests)
                {
                    End(new DidNotExecuteException("Too many requests in progress."), tracker);
                    return;
                }

                //setup and build request
                string verb=(string)MyValues[0];

                HttpClient client=new HttpClient(AAGatewayTestBase.AAGatewayServer);
                HttpClient.Request request=new HttpClient.Request(AAGatewayTestBase.DefaultHost, AAGatewayTestBase.TestFDReflectPath);
                request.Method=verb;
                if (verb=="POST" || verb=="PUT")
                {
                    request.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will block it without this
                }

                TestFdReflectorRequest refreq=new TestFdReflectorRequest();
                refreq.CallerValue=TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue=TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param=0;

                request.SetContentLengthAndBody(refreq.ToArray());

                //break the request up into parts
                byte []reqbytes=request.ToBytes();
                uint part0Len=(uint)reqbytes.Length-1;
                uint part1Len=(uint)1;
                byte []part0=new byte[part0Len];
                byte []part1=new byte[part1Len];
                Array.Copy(reqbytes, 0, part0, 0, part0Len);
                Array.Copy(reqbytes, part0Len, part1, 0, part1Len);

                //disable the nagle algorithm, to guarentee that both halves of the request go out in different packets
                client.Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);

                //send the first part of the request (all but 1 byte)
                client.Connect();
                client.Socket.Send(part0);

                //decide whether to close the socket and call it done
                bool closeSocketAndEnd=(bool)MyValues[1];
                if (closeSocketAndEnd)
                {
                    client.Socket.Close();
                    End(tracker);
                    return;
                }

                //setup callback for async completion
                AsyncData ad=new AsyncData();
                ad.Tracker=tracker;
                ad.Client=client;
                ad.SendTime=System.DateTime.UtcNow;
                client.BeginGetResponse(HandleResponse, ad);
                System.Threading.Interlocked.Increment(ref AsyncRequestsInProgress);
            }

            public void HandleResponse(IAsyncResult iar)
            {
                System.Threading.Interlocked.Decrement(ref AsyncRequestsInProgress);

                AsyncData ad=(AsyncData)iar.AsyncState;
                try
                {
                    HttpClient.Response response=ad.Client.EndGetResponse(iar);
                    if (response==null)
                    {
                        End(new UnexpectedTestResultException("Server returned no response after "+(System.DateTime.UtcNow-ad.SendTime).TotalMilliseconds+"ms"), ad.Tracker);
                        return;
                    }

                    if (response.Status!=408)
                    {
                        End(new UnexpectedTestResultException("Expected 408, but server returned: "+response.Status+" "+response.Reason+", after "+(System.DateTime.UtcNow-ad.SendTime).TotalMilliseconds+"ms"), ad.Tracker);
                        return;
                    }
                }
                catch (System.Exception e)
                {
                    End(e, ad.Tracker);
                    return;
                }

                End(ad.Tracker);
            }
        }

        // -- WORK IN PROGRESS BELOW -- NEEDS CLEANED UP STILL --
        
        
        
        
        
        
        
        public class TempCopiedFromPolicyEnforcementTests
        {
            public static System.Security.Cryptography.X509Certificates.X509Certificate2 XstsSigningCertificate
            {
                get
                {
                    if (_xstsSigningCertificate==null)
                    {
                        _xstsSigningCertificate=ServerTestFramework.LiveService.XSTS.XstsUtil.GetXstsSigningCertificate();
                    }

                    return _xstsSigningCertificate;
                }
            }

            public static void ClearCaches()
            {
                _xstsSigningCertificate=null;
            }

            private static System.Security.Cryptography.X509Certificates.X509Certificate2 _xstsSigningCertificate=null;

            // --

            public static ServerTestFramework.LiveService.XSTS.XSTSSaml2Token CreateDefaultSaml2Token()
            {
                ServerTestFramework.LiveService.XSTS.XSTSSaml2Token generatedToken=new ServerTestFramework.LiveService.XSTS.XSTSSaml2Token(TempCopiedFromPolicyEnforcementTests.XstsSigningCertificate);
                generatedToken.Assertion.Conditions.AudienceRestrictions.Clear();
                generatedToken.Assertion.Conditions.AudienceRestrictions.Add(new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(new System.Uri("http://testfdxsts")));
                return generatedToken;
            }
        };

        //default/xbl20 b_ssl must be set to 0
        [StressTest, Description("Send a POST request for a URL that's using hostname routing.")]
        [CompoundCase("StaticURL", false)]
        [CompoundCase("ChangingURL", true)]
        public class PostUsingHostRouting: TestNode
        {
            public const string TestFDRoutingHost = "testfd.xboxlive.test";

            public override void PreRun()
            {
                //TODO: Make this play nicer... check if it's already ther... don't delete.. etc...
                //add or update the multisetting for routing for testfd
                StaticNpdb.ExecuteNonQuery("delete from t_multisetting_overrides where vc_multisetting='authsg_hostNameMappings' and vc_value like '"+TestFDRoutingHost+"%'");
                string testFdVipIp=Global.XEnv.GetVirtualInterface("testfd").ToString();
                string settingValue=TestFDRoutingHost+","+testFdVipIp;
                StaticNpdb.ExecuteNonQuery("insert into t_multisetting_overrides (vc_environment, vc_component, i_site_id, vc_server, vc_multisetting, vc_value) values ('"+Global.XEnv.GetEnv()+"', 'ALL', -1, 'ALL', 'authsg_hostNameMappings', '"+settingValue+"')");

                AAGatewayTestBase.ConfigCacheRefresh();
            }

            public override void Run()
            {
                bool useVaryingUrl=(bool)MyValues[0];

                HttpClient client = new HttpClient(AAGatewayTestBase.AAGatewayServer);

                HttpClient.Request request=new HttpClient.Request(TestFDRoutingHost, AAGatewayTestBase.TestFDReflectNoAuthSgPath);
                if (useVaryingUrl)
                {
                    request.URI+="/"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(10, 20);
                }

                request.Method="POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml"); //required for a POST to pass XRLScan

                //need this to get past aamodule
                string stsToken=TempCopiedFromPolicyEnforcementTests.CreateDefaultSaml2Token().ToString();
                request.OtherHeaders.AddLast("Authorization: XBL2.0 x="+stsToken);

                //
                TestFdReflectorRequest tfd_req=new TestFdReflectorRequest();

                tfd_req.CallerValue=TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue=TestFdReflectorRequest.Action.ReturnStatusAndResponseBody;
                tfd_req.Param=200;

                request.SetContentLengthAndBody(tfd_req.ToArray());

                client.SendRequest(request);
                HttpClient.Response response=client.GetResponse();

                ValueCheck.Test("HTTP Response status code", 200, response.Status);
                ValueCheck.Test("HTTP Response status reason", "Reflector 200", response.Reason);
                ValueCheck.Test("HTTP Response body", "Special TestFD Response Body", response.ContentString);
            }
        }

        //default/xbl20 b_ssl must be set to 0
        [StressTest]
        public class ClobberSlsWithRandomnessNewTokens: TestNode
        {
            public override void Run()
            {
                HttpClient client = new HttpClient(AAGatewayTestBase.AAGatewayServer);

                HttpClient.Request request=new HttpClient.Request("services.xboxlive.com", "/users/xuid("+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(10, 20)+")/beacons/titles");

                request.Method="PUT";
                request.OtherHeaders.AddLast("Content-Type: text/xml"); //required to pass XRLScan

                //need this to get past aamodule
                string stsToken=TempCopiedFromPolicyEnforcementTests.CreateDefaultSaml2Token().ToString();
                request.OtherHeaders.AddLast("Authorization: XBL2.0 x="+stsToken);

                //
                request.SetContentLengthAndBody("Sorry if this kills your service.");
                client.SendRequest(request);
            }
        }

        //default/xbl20 b_ssl must be set to 0
        [StressTest]
        public class ClobberSlsWithRandomnessReuseTokens: TestNode
        {
            static string stsToken;

            public override void PreRun()
            {
                stsToken=TempCopiedFromPolicyEnforcementTests.CreateDefaultSaml2Token().ToString();
            }

            public override void Run()
            {
                HttpClient client = new HttpClient(AAGatewayTestBase.AAGatewayServer);

                HttpClient.Request request=new HttpClient.Request("services.xboxlive.com", "/users/xuid("+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(10, 20)+")/beacons/titles");

                request.Method="PUT";
                request.OtherHeaders.AddLast("Content-Type: text/xml"); //required to pass XRLScan

                //need this to get past aamodule
                request.OtherHeaders.AddLast("Authorization: XBL2.0 x="+stsToken);

                //
                request.SetContentLengthAndBody("Sorry if this kills your service.");
                client.SendRequest(request);
            }
        }

    } //class SharedStressTests
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\XRL.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using PirateSGTest;
using System.Net;
using ServerTestFramework.LiveService;

namespace AAGatewayTests
{
    [TestGroup]
    class XRL : TestNode
    {
        public const string BaseSvc = "/testfd/reflect.ashx";
        public const string BasePath = "/testfd/Reflect/";
                                           //0---------1---------2---------3---------4---------5---------6---
        // should NOT end in /             //0123456789012345678901234567890123456789012345678901234567890123
        public const string MaxLengthPath = "/testfd/Reflect/authsg/This/Is/64/Chars/Long/I/Counted/It/Myself";
        public const string DirectoryPath = "/testfd/Reflect/authsg/Directory/";
        public const string SpaceWithHexEscapePath = "/testfd/Reflect/authsg/HasEscape%20Space";
        public const string SpacePath = "/testfd/Reflect/authsg/Has Space";
        public const string AmpersandPath = "/testfd/Reflect/authsg/Has&Ampersand";

        public const string TestFDReflectPathPlusSlash = AAGatewayTestBase.TestFDReflectPath + "/";
        public const string DirectoryPathMinusSlash = "/testfd/Reflect/authsg/Directory";
        public const string MaxLengthPathPlusOne = "/testfd/Reflect/authsg/This/Is/64/Chars/Long/I/Counted/It/Myselfx";
        public const string WildcardPath = "/testfd/Reflect/authsg/Wildcard/";
        public const string WildcardSubpath = WildcardPath + "Subpath/";

        /// <summary>bool that controls the pre run.</summary>
        private static bool XrlPreRunSucceeded = false;

        // Add required XRLs for 
        public override void PreRun ()
        {
            if (!XrlPreRunSucceeded)
            {
                // Special entry for that allows us through XRLScan
                AAGatewayTestBase.MapFromGatewayToVirtualInterfaceDEPRECATED(AAGatewayTestBase.TestFDReflectFolderPath + "authsg/",
                    "authsg", false);

                SharedSetup.ConfigureUri(BaseSvc, false);
                SharedSetup.ConfigureUri(BasePath, false);
                SharedSetup.ConfigureUri(MaxLengthPath, false);
                SharedSetup.ConfigureUri(DirectoryPath, false);
                SharedSetup.ConfigureUri(SpaceWithHexEscapePath, false);
                SharedSetup.ConfigureUri(SpacePath, false);
                SharedSetup.ConfigureUri(AmpersandPath, false);
                SharedSetup.ConfigureUri(
                    new ServerTestFramework.LiveService.Auth.ActiveAuthHttpConfig.PolicyEntry { Path = WildcardPath, },
                    true);

                // These need to be maped through the module so that we hit the gateway when calling them
                AAGatewayTestBase.SetModulePolicyDEPRECATED(AAGatewayTestBase.TestFDNoReflectPath);
                AAGatewayTestBase.SetModulePolicyDEPRECATED(TestFDReflectPathPlusSlash);
                AAGatewayTestBase.SetModulePolicyDEPRECATED(DirectoryPathMinusSlash);
                AAGatewayTestBase.SetModulePolicyDEPRECATED(MaxLengthPathPlusOne);
                AAGatewayTestBase.SetModulePolicyDEPRECATED(WildcardSubpath);

                AAGatewayTestBase.Reload();
                AAGatewayTestBase.ReloadModule();
                AAGatewayTestBase.ReloadXrlscan();

                XrlPreRunSucceeded = true;
            }
        }

        [TestCase, TestCasePriority(1)]
        [Description("All we are trying to do here is get through XRLScan and hit the gateway.")]
        public class N_Mainline : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDNoReflectPath);

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForGatewayUnknownService(response, request);
            }
        }

        [TestCase, TestCasePriority(1)]
        [Description("All we are trying to do here is get through XRLScan, the gateway, XRLScan again, the FD " +
            "reflector, back out the gateway, and back here.  That's all.")]
        public class P_Mainline : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Response response = StandardXRLTestExecute(TestFDReflectPath);

                // check for Good
                CheckResponseForStatus(response, 200);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("The requested XRL will be 64 characters long, which is the maximum length of the database field that stores the XRLs.")]
        public class P_XRL_Long_64 : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request;
                HttpClient.Response response = StandardXRLTestExecute(MaxLengthPath,
                    out request);

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("The requested XRL will be 64 characters long, with a 64 character query string.")]
        public class P_XRL_Long_64_Query_64 : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    MaxLengthPath + "?" + MaxLengthPath);
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Requests an XRL with and without a trailing /. This is only valid on directories in HTTP " +
            "(and it might actually just be handled by the client when given a specific error code), so I'm not " +
            "sure that we should actually handle this case as the same XRL.")]
        public class P_XRL_Variant_No_Slash_Mapped : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                string no_slash = TestFDReflectPath;
                string slash = TestFDReflectPathPlusSlash;

                HttpClient client = new HttpClient(AAGatewayServer);

                // try the good one first (no slash)
                HttpClient.Request request = new HttpClient.Request(DefaultHost, no_slash);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);

                // and now the bad (slash)
                request.URI = slash;
                SendRequestPassXRLScan(client, request);
                response = client.GetResponse();

                CheckResponseForGatewayUnknownService(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Requests an XRL with and without a trailing /. This is only valid on directories in HTTP " +
            "(and it might actually just be handled by the client when given a specific error code), so I'm not " +
            "sure that we should actually handle this case as the same XRL.")]
        public class P_XRL_Variant_Slash_Mapped : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                string no_slash = DirectoryPathMinusSlash;
                string slash = DirectoryPath;

                HttpClient client = new HttpClient(AAGatewayServer);

                // try the good one first (slash)
                HttpClient.Request request = new HttpClient.Request(DefaultHost, slash);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);

                // and now the bad (no slash)
                request.URI = no_slash;
                SendRequestPassXRLScan(client, request);
                response = client.GetResponse();

                CheckResponseForGatewayUnknownService(response, request);
            }
        }

        [TestCase(BugID = 109563), TestCasePriority(2)]
        [Description("Use HTTP escape characters (%XX) to construct both valid and invalid XRLs.")]
        public class P_XRL_Escape_Space_DB : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    SpaceWithHexEscapePath  + "?q=t");
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase/*Old (BugID = 109563)*/, TestCasePriority(2)]
        [Description("Use HTTP escape characters (%XX) to construct both valid and invalid XRLs.")]
        public class N_XRL_Escape_Space_Request : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                PirateSGTest.SharedStressTests.CachedTicket ct = PirateSGTest.SharedStressTests.GetCachedPassportTicket(PirateSGTest.SharedStressTests.TicketCache.Xsts);

                if (ct == null || ct.Ticket == null)
                {
                    throw new DidNotExecuteException("Could not retrieve a cached ticket.");
                }

                HttpWebResponse response = null;
                try
                {
                    var headers = new Dictionary<string, string>();
                    headers.Add("Authorization", "XBL2.0 x=" + ct.Ticket);
                    response = HttpWebRequestHelper.PrepareAndExecute("https", SharedSetup.SSLHost, SharedSetup.SSLPort, SpacePath.Replace(" ", "%20"), "q=t", null, null, "GET", headers);
                }
                finally
                {
                    if (response != null)
                    {
                        CheckResponseForModuleBlock(response);
                        response.Close();
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Test if an & works in the path.")]
        public class N_XRL_Has_Ampersand : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    AmpersandPath.Replace("&", "%26"));
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForBadRequest(response);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Use HTTP escape characters (%XX) to construct both valid and invalid XRLs.")]
        public class P_XRL_Escape_Path : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    EscapeString(DirectoryPath).Replace(EscapeString("/"), "/") + "?q=t");
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                // set URI back
                request.URI = Uri.UnescapeDataString(request.URI);

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Use HTTP escape characters (%XX) to construct both valid and invalid XRLs.")]
        public class P_XRL_Escape_Path_Dir : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    "/" + EscapeString(DirectoryPath.Substring(1)) + "?q=t");
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                // set URI back
                request.URI = Uri.UnescapeDataString(request.URI);

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Use HTTP escape characters (%XX) to construct both valid and invalid XRLs.")]
        public class P_XRL_Escape_Entire_Path : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    EscapeString(DirectoryPath) + "?q=t");
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                // set URI back
                request.URI = Uri.UnescapeDataString(request.URI);

                // Can't begin URI with a %
                CheckResponseForBadRequest(response);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Sends only the question mark part of the query string.  " +
            "Allows the request to hit the gateway, but not the FD behind it.")]
        public class P_XRL_Escape_Query_String_QMark_Only : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                PirateSGTest.SharedStressTests.CachedTicket ct = PirateSGTest.SharedStressTests.GetCachedPassportTicket(PirateSGTest.SharedStressTests.TicketCache.Xsts);

                if (ct == null || ct.Ticket == null)
                {
                    throw new DidNotExecuteException("Could not retrieve a cached ticket.");
                }

                HttpWebResponse response = null;
                try
                {
                    var headers = new Dictionary<string, string>();
                    headers.Add("Authorization", "XBL2.0 x=" + ct.Ticket);
                    var uri = String.Format("https://{0}:{1}/{2}?", SharedSetup.SSLHost, SharedSetup.SSLPort, SpacePath.Replace(" ", "%20"));
                    var request = HttpWebRequestHelper.Prepare(new Uri(uri), null, null, "GET", headers);
                    response = HttpWebRequestHelper.Execute(request);
                }
                finally
                {
                    if (response != null)
                    {
                        CheckResponseForStatus(response, 404);
                        response.Close();
                    }
                }
            }
        }
        

        [TestCase, TestCasePriority(3)]
        [Description("Sends only the question mark part of the query string.  " +
            "Allows the request to hit the gateway, but not the FD behind it.  " +
            "What will doing this 1000 times do?")]
        [Ignore]
        public class P_XRL_Escape_Query_String_QMark_Only_DoS : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    SpacePath.Replace(" ", "%20") + "?");

                for (int i = 0; i < 1000; ++i)
                {
                    HttpClient client = new HttpClient(AAGatewayServer);
                    client.SendRequestAsync(request);
                    System.Threading.Thread.Sleep(10);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Go up one directory in the path to a valid XRL. For example, /foo/bar/../page.aspx where both /foo/bar/ and /foo/page.aspx are mapped.")]
        public class P_XRL_Directory_Up : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    BasePath + ".." + TestFDReflectPath.Substring(TestFDReflectPath.LastIndexOf('/'))); 
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                // set this to what we should get
                request.URI = TestFDReflectPath;

                // XrlScan now normalizes this so it is accepted instead of being blocked with 404.
                CheckResponseForStatus(response, 200);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Request an XRL that's underneath a path that has been wildcarded (allow partial match)")]
        public class P_XRL_Wildcard : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient.Response response;
                
                // Make the request to the path that exists in the service lookup
                Global.RO.Info("Making request to " + WildcardPath);
                response = StandardXRLTestExecute(WildcardPath);
                CheckResponseForStatus(response, 200);    

                // Now make the request to a sub path which should be allowed by partial match
                Global.RO.Info("Making request to " + WildcardSubpath);
                response = StandardXRLTestExecute(WildcardSubpath);
                CheckResponseForStatus(response, 200);

                //HttpClient.Request request = new HttpClient.Request(AAGatewayServer.Address.ToString(), WildcardSvc + "/MyMethod");
                //HttpClient client = new HttpClient(AAGatewayServer);
                //request.OtherHeaders.AddLast("SOAPAction: urn:blah:/MyMethod");
                //SendRequestPassXRLScan(client, request);
                //HttpClient.Response response = client.GetResponse();

                // check for Good
                //CheckResponseForStatus(response, 200);                
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("The requested XRL will not be valid. This should not even be seen by the Gateway.")]
        public class N_XRL_Invalid : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    "\\NXRLInvalid");
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForBadRequest(response);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("The request will not contain an XRL. This test expects the XEvent.Id.AAGW_HACK_URL event. (at least, it would if it weren't blocked by IIS)")]
        public class N_XRL_Empty : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    "");
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForBadRequest(response);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("The requested XRL will be 65 characters long, with the first 64 being a valid, mapped XRL. This should have the same result as an unmapped XRL.")]
        public class N_XRL_Long_65 : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    MaxLengthPathPlusOne);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForGatewayUnknownService(response, request);
            }
        }

        [TestCase(BugDatabase = "Xbox 360 Console Software", BugID = 175307), TestCasePriority(2)]
        [Description("The requested XRL will be 1025 characters.")]
        public class N_XRL_Long_1025 : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                string path64 = MaxLengthPath;

                for (int i = 0; i < 4; ++i)
                {
                    path64 = path64 + path64;
                }

                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    path64 + "h");
                client.SendRequest(request);
                HttpClient.Response response = client.GetResponse();

                // Implement CheckResponseForGatewayUnknownService here to check for a bug
                int status = 404;

                if (response == null)
                {
                    throw new AAGatewayException("Response is null.");
                }

                if (response.Status == 400)
                {
                    throw new KnownBugException(175307, "Xbox 360 Console Software");
                }

                if (response.Status != status)
                {
                    Global.RO.Debug(response.ToString());
                    throw new AAGatewayException("Expecting status {0}, got status {1} [{2}].  See debug output " +
                        "for full response.", status, response.Status, response.Reason);
                }
            }
        }

        [TestCase, TestCasePriority(1), Description("AuthSG strips out error details for normal XRL calls.")]
        [CompoundCase("{0}", 400)]
        [CompoundCase("{0}", 401)]
        [CompoundCase("{0}", 402)]
        [CompoundCase("{0}", 403)]
        [CompoundCase("{0}", 404)]
        [CompoundCase("{0}", 500)]
        [CompoundCase("{0}", 501)]
        [CompoundCase("{0}", 502)]
        [CompoundCase("{0}", 503)]
        public class P_ErrorTextNotForwarded : AAGatewayTestBase
        {
            bool ?prevHttpClientVerbose=null;

            public override void PreRun()
            {
                //set httpclient to verbose
                prevHttpClientVerbose = HttpClient.Verbose;
                HttpClient.Verbose = true;
            }

            public override void PostRun()
            {
                //restore httpclient verbose level
                if (prevHttpClientVerbose != null)
                {
                    HttpClient.Verbose = (bool)prevHttpClientVerbose;
                    prevHttpClientVerbose = null;
                }
            }

            protected override void AAExecute()
            {
                int httpStatus=(int)MyValues[0];

                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost, TestFDReflectPath);
                request.Method = "POST";
                // required for a POST to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                // put our request onto the first few bytes
                xonline.common.protocol.TestFdReflectorRequest tfd_req = new xonline.common.protocol.TestFdReflectorRequest();

                tfd_req.CallerValue = xonline.common.protocol.TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = xonline.common.protocol.TestFdReflectorRequest.Action.ReturnStatusAndResponseBody;
                tfd_req.Param = httpStatus;

                request.SetContentLengthAndBody(tfd_req.ToArray());

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                ValueCheck.Test("HTTP Response status code", httpStatus, response.Status);
                //ValueCheck.TestDifferent("HTTP Response status reason", "Reflector "+httpStatus, response.Reason); //we don't care that this makes it through?
                ValueCheck.TestDifferent("HTTP Response body", "Special TestFD Response Body", response.ContentString);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\SamlValidation.cs ===
using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.STS;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.common.service;

namespace PirateSGTest
{
    [TestGroup, Owner("johnmcp"), TestCasePriority(1)]
	public class SamlValidation : TestNode
    {
        #region Setup And Utils

        public const string SimplePath = "/testfd/Reflect/authsg/samlvalidation/simple";

        public const string TestFDQueryString = "?caller=authsg";

        public override void PreRun ()
        {
            // flush this between runs in case the environment changes
            _SigningCertificate = null;

            //configure URIs to use
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() 
                { Path = SimplePath, AuthRequired = true, AuthHeader = "XBL1.0" });

            SharedSetup.Reload();

            System.Net.ServicePointManager.ServerCertificateValidationCallback += RemoteCertAcceptor;
        }

        public override void PostRun ()
        {
            // its safe to always remove, does nothing if its not there
            System.Net.ServicePointManager.ServerCertificateValidationCallback -= RemoteCertAcceptor;
        }

        /// <summary>
        /// Adds the TestFD Reflect parameters as a query string.
        /// </summary>
        public static void AddGetDataToRequest (HttpClient.Request req)
        {
            req.URI += TestFDQueryString;
        }

        //adds an acceptable POST content and headers to a request
        public static void AddPostDataToRequest (HttpClient.Request req)
        {
            req.Method = "POST";

            TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
            tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
            tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

            req.SetContentLengthAndBody(tfd_req.ToArray());
            req.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will be a @#$^% and block us without this
        }

        private static X509Certificate2 _SigningCertificate = null;

        public static X509Certificate2 SigningCertificate
        {
            get
            {
                if (_SigningCertificate == null)
                {
                    _SigningCertificate = STSUtil.GetStsSigningCertificate();
                }

                return _SigningCertificate;
            }
        }

        #endregion

        #region Verification

        public static void CheckStatus (int expectedStatus, HttpClient.Response response)
        {
            if (response == null)
            {
                throw new UnexpectedTestResultException("Expected a response.");
            }

            if (expectedStatus != response.Status)
            {
                throw new UnexpectedTestResultException("Expected " + expectedStatus + " but got " + response.Status + ": " + response.Reason);
            }
        }

        #endregion

        #region Helpers

        private static bool RemoteCertAcceptor (object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
            System.Security.Cryptography.X509Certificates.X509Chain chain, System.Net.Security.SslPolicyErrors sslPolicyErrors)
        {
            return true; // **** Always accept
        }

        private class LocalCertPicker
        {
            private X509Certificate _cert;

            public LocalCertPicker (X509Certificate cert) { _cert = cert; }

            public LocalCertificateSelectionCallback PickMyCertDelegate
            {
                get
                {
                    return new LocalCertificateSelectionCallback(PickMyCert);
                }
            }

            public X509Certificate PickMyCert (object sender, string targetHost, X509CertificateCollection localCertificates,
                X509Certificate remoteCertificate, string[] acceptableIssuers)
            {
                return _cert;
            }
        }

        public static void InitiateSSLWithCert (string url, X509Certificate certificate)
        {
            // Use this bit of .Net specific trickery to enable our use of whatever client certificate we want in
            // HttpWebRequest.  See this documentation on SslStream http://msdn.microsoft.com/en-us/library/ms145057.aspx
            // The Note down below mentions this "technique" of caching an SSL state
            TcpClient tcp = new TcpClient(SharedSetup.SSLHost, SharedSetup.SSLPort);
            SslStream ssl = new SslStream(tcp.GetStream(), false, RemoteCertAcceptor, (new LocalCertPicker(certificate)).PickMyCertDelegate);
            ssl.AuthenticateAsClient(SharedSetup.SSLHost, new X509CertificateCollection(new X509Certificate[] { certificate }),
                System.Security.Authentication.SslProtocols.Default, false);

            // create a request that we don't care about
            HttpClient.Request req = new HttpClient.Request(SharedSetup.SSLHost + ":" + SharedSetup.SSLPort, url);

            ssl.Write(req.ToBytes());
            ssl.Flush();
            // this read is necessary to force the client certificate
            ssl.Read(new byte[1], 0, 1);
            ssl.Close();
        }

        #endregion

        public class SamlValidationTestNode : TestNode
        {
            private STSUtil.GetSecurityTicketParameters _GetSecurityTicketParameters;

            public STSUtil.GetSecurityTicketParameters GetSecurityTicketParameters
            {
                get
                {
                    return _GetSecurityTicketParameters;
                }
            }

            public override void Run()
            {
                _GetSecurityTicketParameters = new STSUtil.GetSecurityTicketParameters();
                _GetSecurityTicketParameters.Certificate = SigningCertificate;

                RunTest();
            }

            public virtual void RunTest ()
            {
            }

            public void DoRequest (string path, int status)
            {
                string token = STSUtil.GetSecurityTicket(GetSecurityTicketParameters);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), path);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                http.SendRequest(req);
                CheckStatus(status, http.GetResponse());
            }
        }

        [TestCase, Description("A standard SAML token.  Should work.")]
        public class Mainline : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                DoRequest(SimplePath, 200);
            }
        }

        [TestCase, Description("Issuer is not us.")]
        public class Issuer : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                GetSecurityTicketParameters.Issuer = "http://www.microsoft.com";
                DoRequest(SimplePath, 401);
            }
        }

        [TestCase, Description("Ticket not yet valid.")]
        public class NotYetValid : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                GetSecurityTicketParameters.NotBefore = DateTime.UtcNow.AddHours(1);
                GetSecurityTicketParameters.NotAfter = DateTime.UtcNow.AddHours(2);
                DoRequest(SimplePath, 401);
            }
        }

        [TestCase, Description("Ticket has expired.")]
        public class Expired : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                GetSecurityTicketParameters.NotBefore = DateTime.UtcNow.AddHours(-2);
                GetSecurityTicketParameters.NotAfter = DateTime.UtcNow.AddHours(-1);
                DoRequest(SimplePath, 401);
            }
        }

        [TestCase, Description("Ticket uses thumbprint signing.")]
        public class SigningCredentials_Thumbprint : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                X509Certificate2 cert = GetSecurityTicketParameters.Certificate;
                GetSecurityTicketParameters.Credentials = new SigningCredentials(new X509AsymmetricSecurityKey(cert), 
                    SecurityAlgorithms.RsaSha1Signature, SecurityAlgorithms.Sha1Digest, 
                    new SecurityKeyIdentifier(new X509ThumbprintKeyIdentifierClause(cert)));
                DoRequest(SimplePath, 401);
            }
        }

        [TestCase, Description("Ticket audience is not ours.")]
        public class UnexpectedAudience : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                GetSecurityTicketParameters.Audience = "http://www.contoso.com/";
                DoRequest(SimplePath, 401);
            }
        }

        [TestCase, Description("Ticket begin time is skewed into the future.")]
        public class ForwardSkew : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                GetSecurityTicketParameters.NotBefore = DateTime.UtcNow.AddSeconds(30);
                DoRequest(SimplePath, 200);
            }
        }

        [TestCase, Description("Just an ordinary SAML token.  But its no ordinary SAML token!")]
        public class Tampered : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                string token = STSUtil.GetSecurityTicket(GetSecurityTicketParameters);

                // verify that it works first
                {
                    HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                    HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                    AddPostDataToRequest(req);
                    req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                    http.SendRequest(req);
                    CheckStatus(200, http.GetResponse());
                }

                // now change something
                {
                    token = token.Replace(GetSecurityTicketParameters.Xuid0, (XOn.XboxId.UserBase + 101).ToString());

                    HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                    HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                    AddPostDataToRequest(req);
                    req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                    http.SendRequest(req);
                    CheckStatus(401, http.GetResponse());
                }
            }
        }

        [TestCase, Description("The SAML token has bad XML.")]
        public class InvalidXml : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                string token = STSUtil.GetSecurityTicket(GetSecurityTicketParameters);
                token = "A" + token.Substring(1);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                http.SendRequest(req);
                CheckStatus(401, http.GetResponse());
            }
        }

        [TestCase, Description("The SAML token is just plain bad (actually its the token base64 encoded).")]
        public class Garbage : SamlValidationTestNode
        {
            public override void RunTest ()
            {
                string token = STSUtil.GetSecurityTicket(GetSecurityTicketParameters);
                token = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(token));

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                http.SendRequest(req);
                CheckStatus(401, http.GetResponse());
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Method.cs ===
using System;
using System.Linq;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using PirateSGTest;

namespace AAGatewayTests
{
    [TestGroup]
    class Method : TestNode
    {
        public static readonly String VerbsReflectPath = AAGatewayTestBase.TestFDReflectFolderPath + "authsg/Verbs/";

        public override void PreRun()
        {
            SharedSetup.ConfigureUri(AAGatewayTestBase.TestFDReflectPath, false);
            SharedSetup.ConfigureUri(VerbsReflectPath, false);
            SharedSetup.Reload();
        }

        [TestCase, TestCasePriority(2)]
        [Description("")]
        [CompoundCase("GET", "GET")]
        [CompoundCase("PUT", "PUT")]
        [CompoundCase("PUTTER", "PUTTER")]
        [CompoundCase("POST", "POST")]
        [CompoundCase("DELETE", "DELETE")]
        [CompoundCase("TwoVerbs", "GET,PUT")]
        [CompoundCase("TwoVerbsReversed", "PUT,GET")]
        [CompoundCase("DuplicateVerb", "PUT,PUT,PUT,PUT,PUT,PUT,PUT,PUT")]
        [CompoundCase("InvalidVerbs", "GET,PUT,DEL,POS")]
        public class Verbs : AAGatewayTestBase
        {
            public readonly string[] KnownVerbs = new string[] { "GET", "PUT", "DELETE", "POST" };

            String verbs;

            public override void PreRun()
            {
                verbs = (String)MyValues[0];
                String updateVerbsSql = String.Format(
                    @"update t_xrl_virtual_interface_mappings set [vc_http_verbs] = '{0}'
                      where vc_xrl = '{1}' and vc_virtual_interface='testfd'",
                    verbs, VerbsReflectPath);

                Global.RO.Info("Setting verbs list to " + verbs);
                AAGatewayTestBase.ExecuteSQL(updateVerbsSql);

                // Now run the following command on all of the TestFD servers, on the TestFD 
                // IIS processes, but on against the XRLScan subprocess.
                String text = null;
                ManagementConsole.ExecuteOnAllProcess(xonline.common.config.Interface.testfd, null, "testfd", "xrlscan reload_mappings", out text);
                //ExecuteXmgmtCmdWithFailure("e %PID%:xrlscan reload_mappings", "testfd");
            }

            public override void Run()
            {
                foreach (String verb in new String[] { "GET", "PUT", "POST", "DELETE", "BREW", "PUTTER" })
                {
                    HttpClient client = new HttpClient(AAGatewayServer);
                    HttpClient.Request request = new HttpClient.Request(
                        DefaultHost,
                        VerbsReflectPath);
                    request.Method = verb;

                    if (verb == "POST" || verb == "PUT")
                    {
                        // required to pass XRLScan
                        request.OtherHeaders.AddLast("Content-Type: text/xml");
                        request.ContentLength = "0";
                    }

                    Global.RO.Info("Checking {0}...", verb);

                    SendRequestPassXRLScan(client, request);
                    HttpClient.Response response = client.GetResponse();

                    string[] configuredVerbs = verbs.Split(' ', ',');

                    if (configuredVerbs.Contains(verb))
                    {
                        CheckResponseAgainstRequest(response, request);
                    }
                    else
                    {
                        // check for known bug where a configured verb is a known verb + extra (PUT => PUTTER)
                        if (KnownVerbs.Where(kv => configuredVerbs.Any(cv => cv.StartsWith(kv))).Contains(verb))
                        {
                            try
                            {
                                // this had better work in the bug case
                                CheckResponseAgainstRequest(response, request);
                                // and since it did thats the bug
                                throw new KnownBugException(71699, "TFS: ISS All");
                            }
                            catch (AAGatewayException)
                            {
                                // fall through to the non-bug case
                            }
                        }

                        CheckResponseForXRLScanBlock(response);
                    }
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        [Description("Use the GET method for a request.")]
        public class P_Method_GET : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request;
                HttpClient.Response response = StandardXRLTestExecute(TestFDReflectPath, out request);

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Use the POST method for a request.")]
        public class P_Method_POST : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "POST";
                // required for a POST to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");
                request.ContentLength = "0";

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Use the PUT method for a request.")]
        public class P_Method_PUT : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "PUT";
                // required for a PUT to pass XRLScan
                request.OtherHeaders.AddLast("Content-Type: text/xml");
                request.ContentLength = "0";

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Use the DELETE method for a request.")]
        public class P_Method_DELETE : AAGatewayTestBase
        {
            protected override void AAExecute()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "DELETE";
                //request.OtherHeaders.AddLast("Content-Type: text/xml");
                //request.ContentLength = "0";

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseAgainstRequest(response, request);
            }
        }

        [TestCase, TestCasePriority(3)]
        [Description("Use the HEAD method for a request.  XRLScan blocks unless the global flag is set, so set it and see what happens.")]
        public class N_Method_HEAD : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "HEAD";

                SettingState state = null;

                try
                {
                    state = Global.XEnv.OverrideSetting("ALL", "ALL", xonline.common.config.Setting.xrlscan_allowHead, "true");

                    // refresh xrlscan (reload_mappings also gets the setting directly from the database...)
                    ExecuteXmgmtCmdWithFailure("e %PID%:xrlscan reload_mappings");

                    SendRequestPassXRLScan(client, request);
                    HttpClient.Response response = client.GetResponse(false);

                    CheckResponseForGatewayUnknownMethod(response, request);
                }
                finally
                {
                    if (state != null)
                    {
                        Global.XEnv.RestoreOverrideSettingState(state);
                        ExecuteXmgmtCmdWithFailure("e %PID%:xrlscan reload_mappings");
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("No HTTP method will be given; the Gateway should not even see this request.")]
        public class N_Method_Missing : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "";

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForBadRequest(response);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Use an invalid HTTP method. This test expects the XEvent.Id.AAGW_HACK_UNKNOWN_HTTP_METHOD event. (at least, it would if it weren't blocked by IIS)")]
        public class N_Method_Invalid : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient client = new HttpClient(AAGatewayServer);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "XBL";

                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckResponseForXRLScanBlock(response);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Mapping.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.protocol;

namespace AAGatewayTests
{
    [TestGroup, TestCasePriority(2)]
    class Mapping : TestNode
    {
        /// <summary>
        /// Will increase the number of mappings by the given amount, then test that all of those mappings work.
        /// </summary>
        public class P_Mapping_Number : AAGatewayTestBase
        {
            protected int Count = 0;

            protected int RespCount = 0;
            protected ManualResetEvent Blocker = new ManualResetEvent(true);

            protected BitArray GetResps, PostResps;

            public P_Mapping_Number (int count)
            {
                Count = count;
                GetResps = new BitArray(count);
                PostResps = new BitArray(count);
            }

            private const string MappingNumberSubname = "authsg/MappingNumber";
            private const string MappingPreConstruct = TestFDReflectFolderPath + MappingNumberSubname;

            private string CreateMappingPath (int i)
            {
                return MappingPreConstruct + i.ToString();
            }

            protected override void AAExecute ()
            {
                string last_path = CreateMappingPath(Count - 1);
                string check = ExecuteScalarSQL("Select vc_policy_key from t_activeauth_policies " +
                    "where vc_policy_key = '" + last_path + "'");

                // need to add an entry for each of the N forwards
                if (check != last_path)
                {
                    Global.RO.Debug("Beginning config for " + Name);

                    for (int i = 0; i < Count; ++i)
                    {
                        string path = CreateMappingPath(i);

                        MapFromGatewayToVirtualInterfaceDEPRECATED(path, ReflectorVInterfaceName, true);
                        SetModulePolicyDEPRECATED(path);
                    }

                    Global.RO.Debug("Reloading for " + Name);

                    ReloadWithFail();
                    ReloadModule();
                    ReloadXrlscan();

                    Global.RO.Debug("Config finished for " + Name);
                }

                HttpClient.Request request_get = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request_get.Method = "GET";

                HttpClient.Request request_post = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request_post.Method = "POST";
                request_post.OtherHeaders.AddLast("Content-Type: text/xml");
                request_post.SetContentLengthAndBody("PS This is a POST <script>.");

                // we use this to not quit 
                RespCount = 0;
                if (!Blocker.Reset())
                {
                    throw new Exception("Could not reset the sync obj.");
                }

                GetResps.SetAll(false);
                PostResps.SetAll(false);

                // kick off a whole bunch of async requests
                for (int i = 0; i < Count; ++i)
                {
                    HttpClient Client1 = new HttpClient(AAGatewayServer);
                    HttpClient Client2 = new HttpClient(AAGatewayServer);

                    string path = CreateMappingPath(i);

                    request_get.URI = path;
                    request_post.URI = path;

                    Client1.SendReceiveAsync(request_get, true, ProcessResponses);
                    Client2.SendReceiveAsync(request_post, true, ProcessResponses);
                    Thread.Sleep(10);
                }

                Global.RO.Debug("Waiting for responses for " + Name);
                Blocker.WaitOne();

                for (int i = 0; i < Count; ++i)
                {
                    if (!GetResps[i])
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Did not receive response for GET {0}", CreateMappingPath(i)));
                    }
                }

                for (int i = 0; i < Count; ++i)
                {
                    if (!PostResps[i])
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Did not receive response for POST {0}", CreateMappingPath(i)));
                    }
                }
            }

            protected void ProcessResponses (HttpClient.Response response)
            {
                try
                {
                    if (response == null)
                    {
                        Global.RO.Error("A response was null.");
                        return;
                    }

                    if (response.Exception != null)
                    {
                        Global.RO.Error("There was an error getting the response:\n" + response.Exception.Message);
                    }

                    if (response.Status != 200)
                    {
                        Global.RO.Error("Received a negative response:\n" + response.ToString());
                        return;
                    }

                    TestFdReflectorResponse reflected = new TestFdReflectorResponse();
                    reflected.ReadBytes(response.ContentBytes);

                    if (reflected == null)
                    {
                        Global.RO.Error("Response did not parse as reflected:\n" + response.ToString());
                        return;
                    }

                    string uri = reflected.HttpRequest.URLAndQueryString;

                    if (!uri.StartsWith(MappingPreConstruct))
                    {
                        Global.RO.Error("Reflected request was not from this test:\n" + response.ToString());
                        return;
                    }

                    int i;

                    if (!int.TryParse(uri.Substring(MappingPreConstruct.Length), out i))
                    {
                        Global.RO.Error("Reflected request did not contain the number:\n" + response.ToString());
                        return;
                    }

                    if (reflected.HttpRequest.Method == "GET")
                    {
                        if (reflected.HttpRequest.Content != null && reflected.HttpRequest.Content.Length > 0)
                        {
                            Global.RO.Error("Reflected GET request had a body:\n" + response.ToString());
                            return;
                        }

                        lock (GetResps)
                        {
                            GetResps.Set(i, true);
                        }
                    }
                    else if (reflected.HttpRequest.Method == "POST")
                    {
                        if (reflected.HttpRequest.Content == null)
                        {
                            Global.RO.Error("Reflected POST request did not have a body:\n" + response.ToString());
                            return;
                        }

                        if (Encoding.UTF8.GetString(reflected.HttpRequest.Content) != "PS This is a POST <script>.")
                        {
                            Global.RO.Error("Reflected POST request did not have the correct body:\n" + response.ToString());
                            return;
                        }

                        lock (PostResps)
                        {
                            PostResps.Set(i, true);
                        }
                    }
                    else
                    {
                        Global.RO.Error("Reflected request had an invalid method:\n" + response.ToString());
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("There was an error dealing with the response:\n" + e.Message);
                }
                finally
                {
                    // Do the async thing
                    if (Interlocked.Increment(ref RespCount) == 2 * Count)
                    {
                        if (!Blocker.Set())
                        {
                            Global.RO.Error("Failed to set the sync obj, " + Name + " cannot complete.");
                        }
                    }
                }
            }
        }

        [TestCase]
        [Description("Creates 100 XRL mappings and exercises each one with a GET and a POST.")]
        public class P_Mapping_100 : P_Mapping_Number
        {
            public P_Mapping_100 () : base(100) { }
        }

        [TestCase]
        [Description("Creates 1,000 XRL mappings and exercises each one with a GET and a POST.")]
        [Ignore]
        public class P_Mapping_1000 : P_Mapping_Number
        {
            public P_Mapping_1000 () : base(1000) { }
        }

        [TestCase]
        [Description("Creates 10,000 XRL mappings and exercises each one with a GET and a POST.")]
        [Ignore]
        public class P_Mapping_10000 : P_Mapping_Number
        {
            public P_Mapping_10000 () : base(10000) { }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Special.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using AATest;

using xonline.common.protocol;

namespace AAGatewayTests
{
    [TestGroup]
    class Special : TestNode
    {
        [TestCase, TestCasePriority(2)]
        [Description("Sends two posts, one after the other.")]
        public class P_Double_Post : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param = 200;

                request.SetContentLengthAndBody(refreq.ToArray());

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                // check for Good
                CheckResponseForStatus(response, 200);

                // send again on a new connection
                client = new HttpClient(AAGatewayServer);

                client.SendRequest(request);
                response = client.GetResponse();

                CheckResponseForStatus(response, 200);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("From the datacenter service, send all HTTP error codes. This is to verify that they can be passed through.")]
        [CompoundCase("100 [Continue]", 100)]
        [CompoundCase("101 [Switching Protocols]", 101)]
        [CompoundCase("199 [Not Defined]", 199)]
        [CompoundCase("200 [OK]", 200)]
        [CompoundCase("201 [Created]", 201)]
        [CompoundCase("202 [Accepted]", 202)]
        [CompoundCase("203 [Non-Authoritative Information]", 203)]
        [CompoundCase("204 [No Content]", 204)]
        [CompoundCase("205 [Reset Content]", 205)]
        [CompoundCase("206 [Partial Content]", 206)]
        [CompoundCase("299 [Not Defined]", 299)]
        [CompoundCase("300 [Multiple Choices]", 300)]
        [CompoundCase("301 [Moved Permanently]", 301)]
        [CompoundCase("302 [Found]", 302)]
        [CompoundCase("303 [See Other]", 303)]
        [CompoundCase("304 [Not Modified]", 304)]
        [CompoundCase("305 [Use Proxy]", 305)]
        [CompoundCase("306 [Unused]", 306)]
        [CompoundCase("307 [Temporary Redirect]", 307)]
        [CompoundCase("399 [Not Defined]", 399)]
        [CompoundCase("400 [Bad Request]", 400)]
        [CompoundCase("401 [Unauthorized]", 401)] //Old BugID = 209
        [CompoundCase("402 [Payment Required]", 402)]
        [CompoundCase("403 [Forbidden]", 403)]
        [CompoundCase("404 [Not Found]", 404)]
        [CompoundCase("405 [Method Not Allowed]", 405)]
        [CompoundCase("406 [Not Acceptable]", 406)]
        [CompoundCase("407 [Proxy Authentication Required]", 407)]
        [CompoundCase("408 [Request Timeout]", 408)]
        [CompoundCase("409 [Conflict]", 409)]
        [CompoundCase("410 [Gone]", 410)]
        [CompoundCase("411 [Length Required]", 411)]
        [CompoundCase("412 [Precondition Failed]", 412)]
        [CompoundCase("413 [Request Entity Too Large]", 413)]
        [CompoundCase("414 [Request-URI Too Long]", 414)]
        [CompoundCase("415 [Unsupported Media Type]", 415)]
        [CompoundCase("416 [Requested Range Not Satisfiable]", 416)]
        [CompoundCase("417 [Expectation Failed]", 417)]
        [CompoundCase("499 [Not Defined]", 499)]
        [CompoundCase("500 [Internal Server Error]", 500)]
        [CompoundCase("501 [Not Implemented]", 501)]
        [CompoundCase("502 [Bad Gateway]", 502)]
        [CompoundCase("503 [Service Unavailable]", 503)]
        [CompoundCase("504 [Gateway Timeout]", 504)]
        [CompoundCase("505 [HTTP Version Not Supported]", 505)]
        [CompoundCase("599 [Not Defined]", 599)]
        public class P_HTTP_Error_Codes : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                int Status = (int) MyValues[0];

                HttpClient.Request request = new HttpClient.Request(DefaultHost, 
                    TestFDReflectPath);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.ReturnStatus;
                refreq.Param = Status;

                request.SetContentLengthAndBody(refreq.ToArray());

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                if (Status == 100)
                {
                    // 100 will cause the gateway to wait until it eventually times out
                    CheckResponseForStatus(response, 504);
                }
                else
                {
                    CheckResponseForStatus(response, Status, "Reflector " + Status.ToString());
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Close the socket after sending a long running request.")]
        public class P_Request_Cancel : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param = 1000;

                request.SetContentLengthAndBody(refreq.ToArray());

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                
                // close the socket
                client.Socket.Close();

                CheckForNastyEvents(request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Close the socket on the FD, see what the gateway does.")]
        public class P_Request_Cancel_FD : AAGatewayTestBase
        {
            protected override void AAExecute ()
            {
                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.NoResponse;

                request.SetContentLengthAndBody(refreq.ToArray());

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                HttpClient.Response response = client.GetResponse();

                CheckForNastyEvents(request);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Reflector will wait for longer than the timeout of the server.")]
        public class P_Request_Timeout : AAGatewayTestBase
        {
            HttpClient.Response response;
            System.Threading.AutoResetEvent autoResetEvent = new System.Threading.AutoResetEvent(false);

            public override void PreRun ()
            {
                base.PreRun();

                response = null;
                autoResetEvent.Reset();
            }

            protected override void AAExecute ()
            {
                int timeout = xonline.common.config.Config.GetIntSetting("authsg_timeoutInSeconds");
                Global.RO.Debug("Timeout is {0} seconds, sleeping the reflector for {1}", timeout, timeout + 2);

                HttpClient.Request request = new HttpClient.Request(DefaultHost,
                    TestFDReflectPath);
                request.Method = "POST";
                request.OtherHeaders.AddLast("Content-Type: text/xml");

                TestFdReflectorRequest refreq = new TestFdReflectorRequest();
                refreq.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                refreq.ActionValue = TestFdReflectorRequest.Action.ResponseWait;
                refreq.Param = (timeout + 2) * 1000;

                request.SetContentLengthAndBody(refreq.ToArray());

                HttpClient client = new HttpClient(AAGatewayServer);
                SendRequestPassXRLScan(client, request);
                client.GetResponseAsync(true, GetResp);

                autoResetEvent.WaitOne(refreq.Param + 10000, false);

                CheckResponseForGatewayTimeout(response);
            }

            protected void GetResp (HttpClient.Response resp)
            {
                response = resp;
                autoResetEvent.Set();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\common\ReflectedResponse.cs ===
using System;
using System.Text;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.protocol;

namespace PirateSGTest
{
    #region Parser for reflected responses

    //
    public class ReflectedAAInfo
    {
        //pseudo-fields
        public bool   IsAAInfoNull=true;
        public string AAInfoCurrent=""; //either "null" or "exists"

        //real fields
        public bool   IsAAInfoAvailable=false;
        public bool   IsInternetTier = false;
        public bool   IsMiddleTier = false;
        public ulong  PassportPuid=0;
        public string IpAddressInternet="";
        public string OriginatingIP="";
        public ulong  LiveXuid=0;
        public ulong  LiveXuidFromXCache=0;
        public byte   CountryId=0;
        public int    []Privileges=new int[0];
        public bool   IsUserValid;

        //
        public string ReturnedExceptions=null; //only non-null if there were exceptions

        //helper to check if a privelege is set
        public bool HasPrivilege(int priv)
        {
            foreach (int p in Privileges)
            {
                if (p==priv) return true;
            }
            return false;
        }
    };

    /// <summary>
    /// parses a http response for a response returned by the aa test reflector
    /// </summary>
    public class AAReflectorResponse
    {
        /// <summary>
        /// Parses an http response to extract the data returned from the aa reflector.
        /// </summary>
        /// <param name="res">reflected http response or response body bytes</param>
        /// <returns>The parsed response, or null if the response was not from the reflector</returns>
        public static AAReflectorResponse Create(HttpClient.Response res)
        {
            if (res==null) return null;
            return Create(res.ContentBytes);
        }
        public static AAReflectorResponse Create(byte []body)
        {
            if (body==null || body.Length==0) return null;

            //verify that the response is actually from the reflector - it should start with this
            byte []requiredStartMark=ByteEncoding.Instance.GetBytes("ActiveAuth Reflector Response\r\n");
            if (body.Length<requiredStartMark.Length) return null;
            for (uint i=0; i<requiredStartMark.Length; ++i)
            {
                if (requiredStartMark[i]!=body[i]) return null;
            }

            AAReflectorResponse refl=new AAReflectorResponse();

            //parse error message
            int errStart=requiredStartMark.Length;
            int contextStart=ArrayEx.SearchByteArray(body,ByteEncoding.Instance.GetBytes("\r\n"),errStart);
            if (errStart!=contextStart)
            {
                refl.ErrorMessage=ByteEncoding.Instance.GetString(body,errStart,contextStart-errStart);
            }
            contextStart+=2;

            //parse the context section into key value pairs
            int aaInfoStart=contextStart+2;
            if (aaInfoStart>=body.Length) return refl;

            bool hasContext=true;
            if (ArrayEx.SearchByteArray(body,ByteEncoding.Instance.GetBytes("\r\n"),contextStart)==contextStart) hasContext=false;
            if (hasContext)
            {
                aaInfoStart=ArrayEx.SearchByteArray(body,ByteEncoding.Instance.GetBytes("\r\n\r\n"),contextStart);
                if (aaInfoStart==-1)
                {
                    Global.RO.Warn("Response was from reflector, but we don't know how to parse the returned context section.");
                    return refl; //give back what we know at least
                }
                aaInfoStart+=4; //rnrn

                string blob=ByteEncoding.Instance.GetString(body,contextStart,aaInfoStart-contextStart-4);
                string []lines=blob.Split(new string[]{"\r\n"},StringSplitOptions.RemoveEmptyEntries);
                foreach (string line in lines)
                {
                    int colonPosition=line.IndexOf(":");
                    if (colonPosition==-1)
                    {
                        Global.RO.Warn("Response was from reflector, but a context line was not valid (will skip): "+line);
                        continue;
                    }

                    string []colonHalves=new string[2];
                    colonHalves[0]=line.Substring(0, colonPosition);
                    colonHalves[1]=line.Substring(colonPosition+1);

                    string value=colonHalves[1].Trim();

                    string []splitKeyParts=colonHalves[0].Split(new char[]{'"'});
                    string key=splitKeyParts[1];

                    refl.HttpContextPairs.Add(new KeyValuePair<string,string>(key,value));
                }
            }

            //parse aa info values
            int reflectedHttpStart=aaInfoStart+2;
            if (reflectedHttpStart>=body.Length) return refl;

            bool hasAAInfo=true;
            if (ArrayEx.SearchByteArray(body,ByteEncoding.Instance.GetBytes("\r\n"),aaInfoStart)==aaInfoStart) hasAAInfo=false;
            if (hasAAInfo)
            {
                reflectedHttpStart=ArrayEx.SearchByteArray(body,ByteEncoding.Instance.GetBytes("\r\n\r\n"),aaInfoStart);
                if (reflectedHttpStart==-1)
                {
                    Global.RO.Warn("Response was from reflector, but we don't know how to parse the returned aainfo section.");
                    return refl; //give back what we know at least
                }
                reflectedHttpStart+=4; //rnrn

                string blob=ByteEncoding.Instance.GetString(body,aaInfoStart,reflectedHttpStart-aaInfoStart-4);
                string []lines=blob.Split(new string[]{"\r\n"},StringSplitOptions.RemoveEmptyEntries);
                foreach (string line in lines)
                {
                    int firstColonInd=line.IndexOf(':');
                    if (firstColonInd==-1)
                    {
                        Global.RO.Warn("Response was from reflector, an aainfo line was not valid (will skip): "+line);
                        continue;
                    }

                    string key=line.Substring(0,firstColonInd).Trim();
                    string value=line.Substring(firstColonInd+1).Trim();

                    if (value.StartsWith("!!!Exception:"))
                    {
                        string excString=value.Substring(value.IndexOf(':')+1).Trim();
                        if (refl.AAInfo.ReturnedExceptions==null) refl.AAInfo.ReturnedExceptions="";
                        refl.AAInfo.ReturnedExceptions+=key+": "+excString+"\n";
                        continue;
                    }

                    if (key == "__IsAAInfoNull") refl.AAInfo.IsAAInfoNull = (value.ToLower() == "true" ? true : false);
                    else if (key == "__IsInternetTier") refl.AAInfo.IsInternetTier = (value.ToLower() == "true" ? true : false);
                    else if (key == "__IsMiddleTier") refl.AAInfo.IsMiddleTier = (value.ToLower() == "true" ? true : false);
                    else if (key=="__IsActiveAuthAvailable") refl.AAInfo.IsAAInfoAvailable=(value.ToLower()=="true"?true:false);
                    else if (key=="__PassportPuid") refl.AAInfo.PassportPuid=ulong.Parse(value);
                    else if (key=="__IpAddressInternet") refl.AAInfo.IpAddressInternet=value;
                    else if (key=="__LiveXuid") refl.AAInfo.LiveXuid=ulong.Parse(value);
                    else if (key=="__LiveXuidFromXCache") refl.AAInfo.LiveXuidFromXCache=ulong.Parse(value);
                    else if (key=="__CountryId") refl.AAInfo.CountryId=byte.Parse(value);
                    else if (key=="__OriginatingIP") refl.AAInfo.OriginatingIP=value;
                    else if (key=="__AAInfoCurrent") refl.AAInfo.AAInfoCurrent=value;
                    else if (key=="__ToString")
                    {
                        //special one, should always be "ok"
                        if (value!="ok")
                        {
                            Global.RO.Warn("__ToString was not \"ok\"");
                        }
                    }
                    else if (key=="__HasPrivilege")
                    {
                        if (value.Trim().Length>0)
                        {
                            string []privs=value.Split(new char[]{','});
                            if (privs.Length>0)
                            {
                                refl.AAInfo.Privileges=new int[privs.Length];
                                for (int i=0; i<privs.Length; ++i)
                                    refl.AAInfo.Privileges[i]=int.Parse(privs[i].Trim());
                            }
                        }
                    }
                    else if (key=="__IsUserValid") refl.AAInfo.IsUserValid=(value.ToLower()=="true"?true:false);
                    else
                    {
                        Global.RO.Warn("Unknown AAInfo key while parsing reflected response: "+key);
                    }
                }
            }

            //the rest is the reflected http request
            refl.RawHttpRequest=new byte[body.Length-reflectedHttpStart];
            System.Buffer.BlockCopy(body,reflectedHttpStart,refl.RawHttpRequest,0,refl.RawHttpRequest.Length);

            refl.HttpRequest=new HttpClient.Request(refl.RawHttpRequest);

            return refl;
        }

        //
        /// <summary>
        /// retrieves a list of values for a specific context
        /// </summary>
        public string[] GetContextValues(string name)
        {
            List<string> values=new List<string>();
            foreach (KeyValuePair<string,string> pair in HttpContextPairs)
            {
                if (pair.Key==name)
                {
                    values.Add(pair.Value);
                }
            }

            return values.ToArray();
        }

        // -- members

        /// <summary>
        /// Error string returned by the reflector.  Will normally be null since none shoud normally be returned.
        /// </summary>
        public string ErrorMessage;

        /// <summary>
        /// The parsed out http context data
        /// </summary>
        public List< KeyValuePair<string,string> > HttpContextPairs=new List<KeyValuePair<string,string>>();

        /// <summary>
        /// The parsed out AAInfo
        /// </summary>
        public ReflectedAAInfo AAInfo=new ReflectedAAInfo();

        /// <summary>
        /// The raw bytes of http request that was reflected
        /// </summary>
        /// 
        public byte []RawHttpRequest;
        /// <summary>
        /// Parsed out version of the http request that was reflected
        /// </summary>
        public HttpClient.Request HttpRequest;
    };

    #endregion //Parser for reflected responses


    #region Verification of responses

    /// <summary>
    /// Utilities to verify the correctness of a response
    /// </summary>
    public class ResponseVerification
    {
        /// <summary>
        /// Verifies that a response is valid.
        /// </summary>
        public static void CheckResponse(HttpClient.Response res)
        {
            ActiveAuthHttpClient.CheckMinimalResponseHeaders(res);

            //must NEVER have authz
            foreach (KeyValuePair<string,string> pair in res.Headers)
            {
                if (pair.Key.ToLower().Trim()=="authz") throw new System.Exception("Response contained an authz header.  That must NEVER happen.");
            }
        }
        /// <summary>
        /// Verifies that a response is valid and that the response code is what was expected.
        /// </summary>
        public static void CheckResponse(HttpClient.Response res, uint code)
        {
            if (res==null) throw new UnexpectedTestResultException("Expected a response.");
            if (res.Status!=code) throw new UnexpectedTestResultException("Expected reponse code to be "+code+", but it was "+res.Status+"("+res.Reason+")");

            CheckResponse(res);
        }
        /// <summary>
        /// Verifies that a response is valid and that the response code is what was expected.
        /// And that it either does or does not contain any body content.
        /// </summary>
        public static void CheckResponse(HttpClient.Response res, uint code, bool content)
        {
            bool reflectedData=(res==null || res.Status!=200?false:true);
            CheckResponse(res,code,content,reflectedData,null);
        }
        /// <summary>
        /// Verifies that a response is valid and that the response code is what was expected.
        /// And that the reflected content matches the original request.
        /// </summary>
        public static void CheckResponse(HttpClient.Response res, uint code, bool content, bool reflectedContent, HttpClient.Request originalRequest)
        {
            CheckResponse(res,code);

            //whether content was expected
            if (content)
            {
                if (res.ContentString==null || res.ContentString.Length==0) throw new UnexpectedTestResultException("Expected there to be content returned.");
            }
            else
            {
                if (res.ContentString!=null && res.ContentString.Length!=0) throw new UnexpectedTestResultException("Did NOT expect any content to be returned.");
            }

            //check that the request data was reflected
            if (content && reflectedContent)
            {
                AAReflectorResponse reflData=AAReflectorResponse.Create(res);
                if (reflData==null)
                {
                    throw new UnexpectedTestResultException("Content was not returned from the reflector, but it was expected to be.");
                }

                if (originalRequest!=null)
                {
                    VerifyOriginalRequest(reflData,originalRequest);
                }
            }
        }

        /// <summary>
        /// Checks that a parse response matches the original request.
        /// </summary>
        public static void VerifyOriginalRequest(AAReflectorResponse resp, HttpClient.Request req)
        {
            if (resp==null)
            {
                throw new UnexpectedTestResultException("No reflected response to check.");
            }
            if (req==null)
            {
                throw new UnexpectedTestResultException("No request to compare against.");
            }

            //verify that the headers in the request ended up in the response
            ValueCheck.Test("Method", req.Method, resp.HttpRequest.Method);
            ValueCheck.Test("URI", req.URI, resp.HttpRequest.URI);
            ValueCheck.Test("Version", req.Version, resp.HttpRequest.Version);
#if GatewayTests
            if (resp.HttpRequest.Host == null || resp.HttpRequest.Host == "")
            {
                throw new Exception("Host header did not have a value.");
            }
#else
            //Change 816341 (bug Xbox360CS 175018) to work around a bug in ASP.NET caching causes XrlScan to replace the Host header value in all incoming requests to the local machine name.  However this was later reverted... and something else done.  Let's just accept both.
            if (resp.HttpRequest.Host!=req.Host) //if we don't have a match with what we sent, see if we have a matching server name instead
            {
                string []validHostNames=Global.XEnv.GetServerListByInterface(AAModuleSuite.IFDReflectorInterface);
                bool hostIsValid=false;
                if (resp.HttpRequest.Host!=null)
                {
                    foreach (string h in validHostNames)
                    {
                        if (resp.HttpRequest.Host.ToLower()==h.ToLower())
                        {
                            hostIsValid=true;
                            break;
                        }
                    }
                }

                if (!hostIsValid)
                {
                    throw new UnexpectedTestResultException("HTTP Host header is not correct: "+resp.HttpRequest.Host);
                }
            }

            ValueCheck.Test("User-Agent", req.UserAgent, resp.HttpRequest.UserAgent);
#endif

            ValueCheck.Test("ContentLength", req.ContentLength, resp.HttpRequest.ContentLength);

            foreach (string reqHeadStr in req.OtherHeaders)
            {
#if GatewayTests
                // Gateway tests won't get this reflected
                if (reqHeadStr.StartsWith("Authorization"))
                {
                    continue;
                }
#endif
                string reqTrimmed=reqHeadStr.Trim();
                bool found=false;
                foreach (string respHeadStr in resp.HttpRequest.OtherHeaders)
                {
                    if (reqTrimmed==respHeadStr.Trim())
                    {
                        found=true;
                        break;
                    }
                }

                if (!found)
                {
                    throw new UnexpectedTestResultException("Header was sent, but not reflected back to us: "+reqHeadStr);
                }
            }
            
            //verify that the body matches
            if (resp.HttpRequest.Content==null && req.Content!=null)
            {
                throw new UnexpectedTestResultException("Request contained content, but the reflected response did not.");
            }
            else if (resp.HttpRequest.Content!=null && req.Content==null)
            {
                throw new UnexpectedTestResultException("The reflected response contained content, but the original request did not.");
            }
            else if (resp.HttpRequest.Content!=null && req.Content!=null)
            {
                ValueCheck.Test("Number of bytes in body", req.Content.Length, resp.HttpRequest.Content.Length);

                for (int i=0; i<resp.HttpRequest.Content.Length; ++i)
                {
                    if (resp.HttpRequest.Content[i]!=req.Content[i]) throw new UnexpectedTestResultException("Data in the body is different at byte index "+i);
                }
            }
        }

        /// <summary>
        /// Checks that a parse response matches the original request.
        /// </summary>
        public static void VerifyOriginalRequest (TestFdReflectorResponse resp, HttpClient.Request req)
        {
            if (resp == null)
            {
                throw new UnexpectedTestResultException("No reflected response to check.");
            }
            if (req == null)
            {
                throw new UnexpectedTestResultException("No request to compare against.");
            }

            //verify that the headers in the request ended up in the response
            ValueCheck.Test("Method", req.Method, resp.HttpRequest.Method);
            ValueCheck.Test("URI", req.URI, resp.HttpRequest.URLAndQueryString);
            ValueCheck.Test("Version", req.Version, resp.HttpRequest.ServerProtocol);

            string rr_host = resp.HttpRequest.Headers.Dict["Host"];
#if GatewayTests
            if (rr_host == null || rr_host == "")
            {
                throw new Exception("Host header did not have a value.");
            }
#else
            //Change 816341 (bug Xbox360CS 175018) to work around a bug in ASP.NET caching causes XrlScan to replace the Host header value in all incoming requests to the local machine name.
            //ValueCheck.Test("Host", req.Host, rr_host); //We no longer expect what we sent to come back for this header.
            string []validHostNames=Global.XEnv.GetServerListByInterface(AAModuleSuite.IFDReflectorInterface);
            bool hostIsValid=false;
            if (rr_host!=null)
            {
                foreach (string h in validHostNames)
                {
                    if (rr_host.ToLower()==h.ToLower())
                    {
                        hostIsValid=true;
                        break;
                    }
                }
            }

            if (!hostIsValid)
            {
                throw new UnexpectedTestResultException("HTTP Host header is not correct: "+rr_host);
            }

            ValueCheck.Test("User-Agent", req.UserAgent, resp.HttpRequest.Headers.Dict["User-Agent"]);
#endif

            string rr_cl;
            if (!resp.HttpRequest.Headers.Dict.TryGetValue("Content-Length", out rr_cl)) { rr_cl = null; }
            ValueCheck.Test("ContentLength", req.ContentLength, rr_cl);

            foreach (string reqHeadStr in req.OtherHeaders)
            {
#if GatewayTests
                // Gateway tests won't get this reflected
                if (reqHeadStr.StartsWith("Authorization") || reqHeadStr.StartsWith("X-Authorization"))
                {
                    continue;
                }
#endif
                if (reqHeadStr.StartsWith("X-Floken")) continue; //Flow token is not reflected. It's added to the AAInfo.
                
                string reqTrimmed = reqHeadStr.Trim();
                bool found = false;
                foreach (string respHeadNameStr in resp.HttpRequest.Headers.Dict.Keys)
                {
                    string respHeadStr = respHeadNameStr + ": " + resp.HttpRequest.Headers.Dict[respHeadNameStr];
                    if (reqTrimmed == respHeadStr)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    throw new UnexpectedTestResultException("Header was sent, but not reflected back to us: " + reqHeadStr);
                }
            }

            //verify that the body matches
            bool resp_isempty = (resp.HttpRequest.Content == null || resp.HttpRequest.Content.Length == 0);
            bool req_isempty = (req.Content == null || req.Content.Length == 0);

            if (resp_isempty && !req_isempty)
            {
                throw new UnexpectedTestResultException("Request contained content, but the reflected response did not.");
            }
            else if (!resp_isempty && req_isempty)
            {
                throw new UnexpectedTestResultException("The reflected response contained content, but the original request did not.");
            }
            else if (!resp_isempty && !req_isempty)
            {
                ValueCheck.Test("Number of bytes in body", req.Content.Length, resp.HttpRequest.Content.Length);

                for (int i = 0; i < resp.HttpRequest.Content.Length; ++i)
                {
                    if (resp.HttpRequest.Content[i] != req.Content[i]) throw new UnexpectedTestResultException("Data in the body is different at byte index " + i);
                }
            }
        }

        /// <summary>
        /// Checks the contexts to verify they do or do not contain passport info
        /// </summary>
        public static void CheckPassportContext(AAReflectorResponse resp, bool hasPassport)
        {
            if (resp==null)
            {
                throw new System.Exception("No reflected response to check.");
            }

            //context
            string []vals=resp.GetContextValues("AAInfo_IpAddressInternet");
#if GatewayTests
            ValueCheck.Test("AAInfo_IpAddressInternet context count", 0, vals.Length);
#else
            ValueCheck.Test("AAInfo_IpAddressInternet context count", 1, vals.Length);
            if (vals[0].Length < 4 || vals[0].Length > 15) throw new UnexpectedTestResultException("AAInfo_IpAddressInternet ip is suspicious");
#endif

            vals=resp.GetContextValues("AAInfo_PassportPuid");
#if ModuleTests
            if (hasPassport)
            {
                ValueCheck.Test("AAInfo_PassportPuid context count", 1, vals.Length);
                if (vals[0].Length<1 || vals[0].Length>30) throw new UnexpectedTestResultException("AAInfo_PassportPuid is suspicious");
                long passportPuid;
                bool worked=long.TryParse(vals[0], out passportPuid);
                if (!worked) throw new UnexpectedTestResultException("Could not parse AAInfo_PassportPuid to a long: "+vals[0]);
            }
            else
            {
                //new behavior here: it should exist but be value 0
                ValueCheck.Test("AAInfo_PassportPuid context count", 1, vals.Length);
                long passportPuid;
                bool worked=long.TryParse(vals[0], out passportPuid);
                if (!worked) throw new UnexpectedTestResultException("Could not parse http context AAInfo_PassportPuid to a long: "+vals[0]);
                if (passportPuid!=0) throw new UnexpectedTestResultException("http context Passport puid should have been 0");
            }
#else
            ValueCheck.Test("AAInfo_PassportPuid context count", 0, vals.Length);
#endif
        }

        /// <summary>
        /// Checks the contexts to verify they do or do not contain passport info
        /// </summary>
        public static void CheckPassportContext (TestFdReflectorResponse resp, bool hasPassport)
        {
            if (resp == null)
            {
                throw new System.Exception("No reflected response to check.");
            }

            //context
            Dictionary<string,string> context = resp.HttpContext.Dict;

#if GatewayTests
            ValueCheck.IsFalse(context.ContainsKey("AAInfo_IpAddressInternet"), "AAInfo_IpAddressInternet context count");
#else
            ValueCheck.IsTrue(context.ContainsKey("AAInfo_IpAddressInternet"), "AAInfo_IpAddressInternet context count");
            string AAInfo_IpAddressInternet = context["AAInfo_IpAddressInternet"];
            if (AAInfo_IpAddressInternet.Length < 4 || AAInfo_IpAddressInternet.Length > 15)
            {
                throw new UnexpectedTestResultException("AAInfo_IpAddressInternet ip is suspicious");
            }
#endif

#if ModuleTests
            //new behavior here: it should exist but be value 0
            ValueCheck.IsTrue(context.ContainsKey("AAInfo_PassportPuid"), "AAInfo_PassportPuid context count");
            string AAInfo_PassportPuid = context["AAInfo_PassportPuid"];

            if (hasPassport)
            {
                if (AAInfo_PassportPuid.Length < 1 || AAInfo_PassportPuid.Length > 30)
                {
                    throw new UnexpectedTestResultException("AAInfo_PassportPuid is suspicious");
                }
                long passportPuid;
                bool worked = long.TryParse(AAInfo_PassportPuid, out passportPuid);
                if (!worked) throw new UnexpectedTestResultException("Could not parse AAInfo_PassportPuid to a long: " + AAInfo_PassportPuid);
            }
            else
            {
                long passportPuid;
                bool worked = long.TryParse(AAInfo_PassportPuid, out passportPuid);
                if (!worked) throw new UnexpectedTestResultException("Could not parse http context AAInfo_PassportPuid to a long: " + AAInfo_PassportPuid);
                if (passportPuid!=0) throw new UnexpectedTestResultException("http context Passport puid should have been 0");
            }
#else
            ValueCheck.IsFalse(context.ContainsKey("AAInfo_PassportPuid"), "AAInfo_PassportPuid context count");
#endif
        }

    };

    #endregion //Verification of responses
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AntiDos\AntiDos.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;
using System.Threading;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;

using PirateSGTest;

[assembly: RootNode(typeof(AntiDos.AntiDos))]

// disable warning about a volatile ref not being volatile
#pragma warning disable 420

namespace AntiDos
{
    public class AntiDos : TestNode
    {
        private AntiDosForm _form = null;
        private AntiDosState _state = null;
        private bool _running = false;
        private Thread _client_manager = null;
        private Dictionary<Client.Behavior, LinkedList<Client>> _clients = null;
        private Random rand = new Random();

        public static readonly IPEndPoint Target = new IPEndPoint(IPAddress.Parse("10.198.103.110"), 13100);
        public const string AntiDosXRL = "/test/antidos";
        public const string NonAntiDosXRL = "/test/nonantidos";

        public override void OneTimeInitializeStress (System.Xml.XmlDocument config)
        {
            base.OneTimeInitializeStress(config);

            _state = new AntiDosState();

            _form = new AntiDosForm(_state);
            _form.Show();

            ThreadPool.QueueUserWorkItem(new WaitCallback(DBSetup));
        }

        public static void DBSetup (object dontcare)
        {
            try
            {
                // set up policies
                ActiveAuthHttpConfig.PolicyEntry policy = new ActiveAuthHttpConfig.PolicyEntry(AntiDosXRL, false, null,
                    false, true);
                ActiveAuthHttpConfig.SetPolicyEntry(policy);

                policy.Path = NonAntiDosXRL;
                policy.AntiDOS = false;
                ActiveAuthHttpConfig.SetPolicyEntry(policy);

                ActiveAuthHttpConfig.AAModuleReload();
            }
            catch (Exception e)
            {
                Global.RO.Error(e.ToString());
            }
        }

        public override void OneTimeDeinitializeStress ()
        {
            base.OneTimeDeinitializeStress();

            if (_form != null)
            {
                _form.Close();
            }
        }

        public override void InitializeStress (XmlDocument config)
        {
            base.InitializeStress(config);

            AntiDosSettingUtils.SaveInitial();
            _state.Reset();
            _state.TrackingThreshold = AntiDosSettingUtils.CurrentTrackingThreshold;
            _state.ThrottlingThreshold = AntiDosSettingUtils.CurrentThrottlingThreshold;
            _state.BlockingThreshold = AntiDosSettingUtils.CurrentBlockingThreshold;
            _state.MaxRecordsToTrack = int.Parse(AntiDosSettingUtils.CurrentMaxRecordsToTrack);
            _state.BanTimeInSeconds = int.Parse(AntiDosSettingUtils.CurrentBanTimeInSeconds);

            _clients = new Dictionary<Client.Behavior, LinkedList<Client>>();

            _client_manager = new Thread(new ThreadStart(ClientManager));
            _client_manager.Start();

            _running = true;
        }

        public override void DeinitializeStress ()
        {
            _running = false;

            AntiDosSettingUtils.RevertToInitial();

            base.DeinitializeStress();
        }

        /// <summary>
        /// This function creates and manages the clients
        /// </summary>
        private void ClientManager ()
        {
            try
            {
                while (_running)
                {
                    DateTime now = DateTime.Now;

                    // create clients if necessary
                    int humans_needed = _state.NumberHuman - GetClientList(Client.Behavior.Human).Count;
                    int clockworks_needed = _state.NumberClockwork - GetClientList(Client.Behavior.Clockwork).Count;
                    int constant_needed = _state.NumberConstant - GetClientList(Client.Behavior.Constant).Count;
                    int flood_needed = _state.NumberFlood - GetClientList(Client.Behavior.Flood).Count;
                    int relentless_needed = _state.NumberRelentless - GetClientList(Client.Behavior.Relentless).Count;

                    while ((humans_needed != 0 || clockworks_needed != 0 || constant_needed != 0 || 
                            flood_needed != 0 || relentless_needed != 0)
                        && DateTime.Now.Subtract(now).Milliseconds < 75)
                    {
                        humans_needed = ChangeClientCount(humans_needed, Client.Behavior.Human);
                        clockworks_needed = ChangeClientCount(clockworks_needed, Client.Behavior.Clockwork);
                        constant_needed = ChangeClientCount(constant_needed, Client.Behavior.Constant);
                        flood_needed = ChangeClientCount(flood_needed, Client.Behavior.Flood);
                        relentless_needed = ChangeClientCount(relentless_needed, Client.Behavior.Relentless);
                    }

                    Thread.Sleep(Math.Max(100 - DateTime.Now.Subtract(now).Milliseconds, 0));
                }

                lock (_clients)
                {
                    foreach (Client.Behavior behavior in _clients.Keys)
                    {
                        while (_clients[behavior].Count > 0)
                        {
                            FreeClient(behavior);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Error(e.ToString());
            }
        }

        private LinkedList<Client> GetClientList (Client.Behavior behavior)
        {
            if (_clients.ContainsKey(behavior))
            {
                return _clients[behavior];
            }

            lock (_clients)
            {
                LinkedList<Client> temp = new LinkedList<Client>();
                _clients.Add(behavior, temp);
                return temp;
            }
        }

        private int ChangeClientCount (int num, Client.Behavior behavior)
        {
            if (num > 0)
            {
                for (int i = 0; i < 10 && num > 0; ++i, --num)
                {
                    if (!CreateClient(behavior))
                    {
                        ++num;
                    }
                }
            }
            else if (num < 0)
            {
                for (int i = 0; i < 10 && num < 0; ++i, ++num)
                {
                    FreeClient(behavior);
                }
            }

            return num;
        }

        private bool CreateClient (Client.Behavior state)
        {
            ClientInfo clifo = null;
            LinkedList<Client> list = GetClientList(state);

            try
            {
                Client cli = new Client(_state);
                clifo = _state.AcquireClientInfo();

                if (clifo == null)
                {
                    return false;
                }

                cli.Initialize(clifo);
                cli.State = state;
                cli.Start();

                lock (list)
                {
                    list.AddLast(cli);
                }
            }
            catch
            {
                if (clifo != null)
                {
                    _state.ReleaseClientInfo(clifo);
                }

                throw;
            }

            return true;
        }

        private void FreeClient (Client.Behavior state)
        {
            LinkedList<Client> list = GetClientList(state);
            Client cli = null;

            lock (list)
            {
                cli = list.First.Value;
                list.RemoveFirst();
            }

            _state.ReleaseClientInfo(cli.ClientInfo);
            cli.Stop();
        }
    }

    /// <summary>
    /// Contains the state for AntiDos activities.
    /// </summary>
    public class AntiDosState
    {
        public AntiDosState () { }

        #region Client List

        protected string _client_file = null;
        protected List<ClientInfo> _clients = null;
        protected LinkedList<ClientInfo> _free_clients = null;

        public string ClientFile
        {
            get { return _client_file; }
        }

        public int ClientListSize
        {
            get { return (_clients == null ? 0 : _clients.Count); }
        }

        public void LoadClientFile ()
        {
            LoadClientFile("AntiDosClients.xml");
        }

        public void LoadClientFile (string filename)
        {
            List<ClientInfo> loaded = new List<ClientInfo>();
            LinkedList<ClientInfo> free = new LinkedList<ClientInfo>();

            XmlDocument doc = new XmlDocument();
            doc.Load(filename);

            XmlNodeList nodes = doc.GetElementsByTagName("client");

            foreach (XmlNode node in nodes)
            {
                XmlAttribute ip = node.Attributes["ip"];
                XmlAttribute ipEnd = node.Attributes["ipEnd"];
                XmlAttribute port = node.Attributes["port"];

                // its a range
                if (ipEnd != null)
                {
                    byte[] ip_begin = IPAddress.Parse(ip.Value).GetAddressBytes();
                    byte[] ip_end = IPAddress.Parse(ipEnd.Value).GetAddressBytes();

                    while (true)
                    {
                        for (int i = 0; i < 4; ++i)
                        {
                            if (ip_begin[i] > ip_end[i])
                            {
                                goto Done;
                            }
                            if (ip_begin[i] < ip_end[i])
                            {
                                break;
                            }
                        }

                        ClientInfo temp = new ClientInfo(ip_begin);
                        loaded.Add(temp);
                        free.AddLast(temp);

                        // increment ip_begin (assume a single class a at most)
                        if (ip_begin[3] == 255)
                        {
                            if (ip_begin[2] == 255)
                            {
                                ip_begin[1] += 1;
                                ip_begin[2] = 0;
                                ip_begin[3] = 0;
                            }
                            else
                            {
                                ip_begin[2] += 1;
                                ip_begin[3] = 0;
                            }
                        }
                        else
                        {
                            ip_begin[3] += 1;
                        }
                    }

                Done: ;
                }
                // single client
                else
                {
                    ClientInfo temp = new ClientInfo(ip.Value, (port == null ? "0" : port.Value));
                    loaded.Add(temp);
                    free.AddLast(temp);
                }
            }

            lock (this)
            {
                _client_file = filename;
                _clients = loaded;
                _free_clients = free;
                ClientsToUse = ClientListSize;
            }
        }

        #endregion

        #region Runtime Clients

        public int ClientsToUse = 0;
        public int NumberHuman { 
            get { return ClientsToUse - (NumberClockwork + NumberConstant + NumberFlood + NumberRelentless); } 
        }
        public int NumberClockwork = 0;
        public int NumberConstant = 0;
        public int NumberFlood = 0;
        public int NumberRelentless = 0;

        public AttackType Attack = AttackType.SilentButDeadly;

        /// <summary>
        /// Pulls a client off the free list.
        /// </summary>
        /// <returns>The ClientInfo object.</returns>
        public ClientInfo AcquireClientInfo ()
        {
            lock (_free_clients)
            {
                if (_free_clients.Count == 0)
                {
                    Global.RO.Warn("Attempted to get a client when the list was empty.");
                    return null;
                }

                ClientInfo temp = _free_clients.First.Value;
                _free_clients.RemoveFirst();
                return temp;
            }
        }

        /// <summary>
        /// Puts a client back on the free list.
        /// </summary>
        /// <param name="cli">The ClientInfo object.</param>
        public void ReleaseClientInfo (ClientInfo cli)
        {
            lock (_free_clients)
            {
                _free_clients.AddLast(cli);
            }
        }

        public double Scale = 1.0;

        protected long _response_none = 0;
        protected long _response_good = 0;
        protected long _response_false_positive = 0;
        protected long _response_blocked = 0;
        protected long _response_false_negative = 0;
        protected long _response_error = 0;

        public void ReportNoResponse ()
        {
            Interlocked.Increment(ref _response_none);
            Global.RO.Warn("Got null response");
        }

        public void ReportGoodResponse ()
        {
            Interlocked.Increment(ref _response_good);
        }

        public void ReportFalsePositive ()
        {
            Interlocked.Increment(ref _response_false_positive);
        }

        public void ReportBlockedResponse ()
        {
            Interlocked.Increment(ref _response_blocked);
        }

        public void ReportFalseNegative ()
        {
            Interlocked.Increment(ref _response_false_negative);
            Global.RO.Warn("Got false negative");
        }

        public void ReportErrorResponse (int status)
        {
            Interlocked.Increment(ref _response_error);
            Global.RO.Error("Received error response: {0}", status);
        }

        #endregion

        #region Server State

        protected volatile string _test_case = null;

        protected volatile int _req_in_prog = 0;
        protected volatile int _active_clients = 0;
        protected volatile ServerState _expected_state = ServerState.None;

        protected int _tracking_on = 0;
        protected int _tracking_off = 0;
        protected int _throttling_on = 0;
        protected int _throttling_off = 0;
        protected int _blocking_on = 0;
        protected int _blocking_off = 0;
        protected int _max_records = 0;
        protected int _ban_time = 0;

        public string CurrentTestCase { get { return _test_case; } }

        public int RequestsInProgress { get { return _req_in_prog; } }
        public int ActiveClients { get { return _active_clients; } }
        public int AverageRequestsPerClient
        {
            get
            {
                int rip = _req_in_prog;
                int ac = _active_clients;

                return (ac == 0 ? 0 : rip / ac);
            }
        }
        public ServerState ExpectedState { get { return _expected_state; } }

        public string TrackingThreshold
        {
            get { return _tracking_on.ToString() + ", " + _tracking_off.ToString(); }
            set { ParseThreshold(value, ref _tracking_on, ref _tracking_off); }
        }

        public string ThrottlingThreshold
        {
            get { return _throttling_on.ToString() + ", " + _throttling_off.ToString(); }
            set { ParseThreshold(value, ref _throttling_on, ref _throttling_off); }
        }

        public string BlockingThreshold
        {
            get { return _blocking_on.ToString() + ", " + _blocking_off.ToString(); }
            set { ParseThreshold(value, ref _blocking_on, ref _blocking_off); }
        }

        protected void ParseThreshold (string threshold, ref int larger, ref int smaller)
        {
            string[] splitted = threshold.Split(',', ';');

            if (splitted.Length == 0 || splitted.Length > 2)
            {
                throw new Exception("Bad threshold value");
            }

            larger = int.Parse(splitted[0]);

            if (splitted.Length == 1)
            {
                smaller = larger;
            }
            else
            {
                smaller = int.Parse(splitted[1]);

                if (larger < smaller)
                {
                    int temp = larger;
                    larger = smaller;
                    smaller = temp;
                }
            }
        }

        public int MaxRecordsToTrack
        {
            get { return _max_records; }
            set { _max_records = value; }
        }

        public int BanTimeInSeconds
        {
            get { return _ban_time; }
            set { _ban_time = value; }
        }

        /// <summary>
        /// Should be called by clients when they send a request to the server.
        /// </summary>
        /// <param name="cli">The client making the request.</param>
        /// <returns>True if the request should succeed; false if it should be blocked.</returns>
        public bool BeginRequest (Client cli)
        {
            // increment global count
            DetermineExpectedState(Interlocked.Increment(ref _req_in_prog));

            // do global count and active clients if necessary
            int cli_rip = Interlocked.Increment(ref cli.RequestsInProgress);

            // we went from 0 to 1, thus becoming active
            if (cli_rip == 1)
            {
                Interlocked.Increment(ref _active_clients);
            }

            if (_expected_state == ServerState.None)
            {
                return true;
            }

            int throttle_limit = AverageRequestsPerClient;

            if (cli.BanTime.AddSeconds(_ban_time) > DateTime.Now && cli.RequestsInProgress > throttle_limit)
            {
                return false;
            }

            if (_expected_state == ServerState.Tracking)
            {
                return true;
            }

            if (_expected_state == ServerState.Blocking || cli.RequestsInProgress > throttle_limit)
            {
                cli.BanTime = DateTime.Now;
                return false;
            }

            return true;
        }

        public void EndRequest (Client cli)
        {
            // decrement global count
            Interlocked.Decrement(ref _req_in_prog);

            // do global count and active clients if necessary
            int cli_rip = Interlocked.Decrement(ref cli.RequestsInProgress);

            // we went from 1 to 0, thus becoming inactive
            if (cli_rip == 0)
            {
                Interlocked.Decrement(ref _active_clients);
            }
        }

        protected void DetermineExpectedState (int current_rip)
        {
            switch (_expected_state)
            {
                case ServerState.None:
                    if (current_rip >= _tracking_on) { _expected_state = ServerState.Tracking; }
                    break;

                case ServerState.Tracking:
                    if (current_rip >= _throttling_on) { _expected_state = ServerState.Throttling; }
                    else if (current_rip < _tracking_off) { _expected_state = ServerState.None; }
                    break;

                case ServerState.Throttling:
                    if (current_rip >= _blocking_on) { _expected_state = ServerState.Blocking; }
                    else if (current_rip < _throttling_off) { _expected_state = ServerState.Tracking; }
                    break;

                case ServerState.Blocking:
                    if (current_rip < _blocking_off) { _expected_state = ServerState.Throttling; }
                    break;
            }
        }

        #endregion

        public void Reset ()
        {
            if (_client_file == null)
            {
                LoadClientFile();
            }
            else
            {
                _free_clients.Clear();

                foreach (ClientInfo cli in _clients)
                {
                    _free_clients.AddLast(cli);
                }
            }

            Attack = AttackType.SilentButDeadly;

            _req_in_prog = 0;
            _active_clients = 0;
            _expected_state = ServerState.None;
            
            _response_none = 0;
            _response_good = 0;
            _response_false_positive = 0;
            _response_blocked = 0;
            _response_false_negative = 0;
            _response_error = 0;
        }
    }

    /// <summary>
    /// Contains information about a client.
    /// </summary>
    public class ClientInfo
    {
        /// <summary>
        /// The localish endpoint, 0 port means it is a local endpoint, non-zero means it is a remote tcp relay.
        /// </summary>
        public IPEndPoint ClientEndPoint = null;

        public ClientInfo (string ip, string port)
        {
            ClientEndPoint = new IPEndPoint(IPAddress.Parse(ip), int.Parse(port));
        }

        public ClientInfo (byte[] ip)
        {
            ClientEndPoint = new IPEndPoint(new IPAddress(ip), 0);
        }
    }

    /// <summary>
    /// The states that the server can be in with respect to AntiDos.
    /// </summary>
    public enum ServerState
    {
        None,
        Tracking,
        Throttling,
        Blocking
    }

    /// <summary>
    /// The different types of attacks that can be made with the 'abnormal' clients.
    /// </summary>
    public enum AttackType
    {
        /// <summary>Clients operate as normal... or do they... no, they do.</summary>
        SilentButDeadly,
        /// <summary>Distributed DoS, all at approximately equal levels.</summary>
        IfWeAllAttackAtOnce,
        /// <summary>A single client goes nuts.</summary>
        ThereCanBeOnlyOne,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AntiDos\AntiDosForm.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Text;
using System.Windows.Forms;

using ServerTestFramework;

namespace AntiDos
{
    public partial class AntiDosForm : Form
    {
        protected AntiDosState _state = null;
        protected Report _report = null;

        public AntiDosForm ()
        {
            InitializeComponent();
            _report = new Report("AntiDosForm");
        }

        public AntiDosForm (AntiDosState state) : this()
        {
            _state = state;
        }

        private void butLoadClientList_Click (object sender, EventArgs e)
        {
            if (ofdClientList.ShowDialog(this) == DialogResult.OK)
            {
                LoadClientList(ofdClientList.FileName);
            }
        }

        public void LoadClientList (string file)
        {
            try
            {
                _state.LoadClientFile(file);
            }
            catch (Exception exc)
            {
                HandleException(exc);
            }

            // set values as needed
            lblFileName.Text = Path.GetFileName(_state.ClientFile);
            lblMaxClients.Text = _state.ClientListSize.ToString();

            nudClientCount.Value = nudClientCount.Maximum = new decimal(_state.ClientListSize);
            nudNumClockwork.Value = nudNumConstant.Value = nudNumFlood.Value = decimal.Zero;
        }

        private void HandleException (Exception e)
        {
            _report.Error(e.ToString());
        }

        private void nudClientCount_ValueChanged (object sender, EventArgs e)
        {
            _state.ClientsToUse = Convert.ToInt32(nudClientCount.Value);

            int humies = _state.NumberHuman;
            lblNumHuman.Text = humies.ToString();

            decimal dec_humies = Convert.ToDecimal(humies);
            nudNumClockwork.Maximum += dec_humies;
            nudNumConstant.Maximum += dec_humies;
            nudNumFlood.Maximum += dec_humies;
            nudNumRelentless.Maximum += dec_humies;
        }

        private void nudPercentAbnormal_ValueChanged (object sender, EventArgs e)
        {
            _state.NumberClockwork = Convert.ToInt32(nudNumClockwork.Value);
            SetClientCountMinimum();
        }

        private void nudNumConstant_ValueChanged (object sender, EventArgs e)
        {
            _state.NumberConstant = Convert.ToInt32(nudNumConstant.Value);
            SetClientCountMinimum();
        }

        private void nudNumFlood_ValueChanged (object sender, EventArgs e)
        {
            _state.NumberFlood = Convert.ToInt32(nudNumFlood.Value);
            SetClientCountMinimum();
        }

        private void nudNumRelentless_ValueChanged (object sender, EventArgs e)
        {
            _state.NumberRelentless = Convert.ToInt32(nudNumRelentless.Value);
            SetClientCountMinimum();
        }

        private void SetClientCountMinimum ()
        {
            nudClientCount.Minimum = nudNumClockwork.Value + nudNumConstant.Value + nudNumFlood.Value + 
                nudNumRelentless.Value;

            lblNumHuman.Text = _state.NumberHuman.ToString();
        }

        private void tmrCurrentValues_Tick (object sender, EventArgs e)
        {
            lblFileName.Text = Path.GetFileName(_state.ClientFile);
            lblMaxClients.Text = _state.ClientListSize.ToString();

            decimal max = Convert.ToDecimal(_state.ClientListSize);
            if (nudClientCount.Maximum != max) { nudClientCount.Maximum = max; }

            decimal ctu = Convert.ToDecimal(_state.ClientsToUse);
            if (nudClientCount.Value != ctu) { nudClientCount.Value = ctu; }

            string temp = _state.CurrentTestCase;
            lblTestCase.Text = (temp == null ? "-" : temp);

            lblReqInProg.Text = _state.RequestsInProgress.ToString();
            lblActiveClients.Text = _state.ActiveClients.ToString();
            lblAvgReqPerClient.Text = _state.AverageRequestsPerClient.ToString();
            lblExpectState.Text = _state.ExpectedState.ToString();

            lblTrackingThreshold.Text = _state.TrackingThreshold;
            lblThrottlingThreshold.Text = _state.ThrottlingThreshold;
            lblBlockingThreshold.Text = _state.BlockingThreshold;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AntiDos\AntiDosForm.Designer.cs ===
namespace AntiDos
{
    public partial class AntiDosForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose (bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.Label label1;
            System.Windows.Forms.Label label2;
            System.Windows.Forms.Label label3;
            System.Windows.Forms.Label label4;
            System.Windows.Forms.GroupBox groupBox1;
            System.Windows.Forms.GroupBox groupBox2;
            System.Windows.Forms.Label label5;
            System.Windows.Forms.GroupBox groupBox3;
            System.Windows.Forms.Label label13;
            System.Windows.Forms.Label label12;
            System.Windows.Forms.Label label11;
            System.Windows.Forms.Label label10;
            System.Windows.Forms.Label label9;
            System.Windows.Forms.Label label8;
            System.Windows.Forms.Label label7;
            System.Windows.Forms.Label label6;
            System.Windows.Forms.Label label14;
            System.Windows.Forms.Label label15;
            System.Windows.Forms.Label label16;
            System.Windows.Forms.Label label17;
            this.lblMaxClients = new System.Windows.Forms.Label();
            this.lblFileName = new System.Windows.Forms.Label();
            this.butLoadClientList = new System.Windows.Forms.Button();
            this.nudNumClockwork = new System.Windows.Forms.NumericUpDown();
            this.nudClientCount = new System.Windows.Forms.NumericUpDown();
            this.lblBlockingThreshold = new System.Windows.Forms.Label();
            this.lblThrottlingThreshold = new System.Windows.Forms.Label();
            this.lblTrackingThreshold = new System.Windows.Forms.Label();
            this.lblExpectState = new System.Windows.Forms.Label();
            this.lblAvgReqPerClient = new System.Windows.Forms.Label();
            this.lblActiveClients = new System.Windows.Forms.Label();
            this.lblReqInProg = new System.Windows.Forms.Label();
            this.lblTestCase = new System.Windows.Forms.Label();
            this.ofdClientList = new System.Windows.Forms.OpenFileDialog();
            this.tmrCurrentValues = new System.Windows.Forms.Timer(this.components);
            this.lblNumHuman = new System.Windows.Forms.Label();
            this.nudNumConstant = new System.Windows.Forms.NumericUpDown();
            this.nudNumFlood = new System.Windows.Forms.NumericUpDown();
            this.nudNumRelentless = new System.Windows.Forms.NumericUpDown();
            label1 = new System.Windows.Forms.Label();
            label2 = new System.Windows.Forms.Label();
            label3 = new System.Windows.Forms.Label();
            label4 = new System.Windows.Forms.Label();
            groupBox1 = new System.Windows.Forms.GroupBox();
            groupBox2 = new System.Windows.Forms.GroupBox();
            label5 = new System.Windows.Forms.Label();
            groupBox3 = new System.Windows.Forms.GroupBox();
            label13 = new System.Windows.Forms.Label();
            label12 = new System.Windows.Forms.Label();
            label11 = new System.Windows.Forms.Label();
            label10 = new System.Windows.Forms.Label();
            label9 = new System.Windows.Forms.Label();
            label8 = new System.Windows.Forms.Label();
            label7 = new System.Windows.Forms.Label();
            label6 = new System.Windows.Forms.Label();
            label14 = new System.Windows.Forms.Label();
            label15 = new System.Windows.Forms.Label();
            label16 = new System.Windows.Forms.Label();
            label17 = new System.Windows.Forms.Label();
            groupBox1.SuspendLayout();
            groupBox2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumClockwork)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.nudClientCount)).BeginInit();
            groupBox3.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumConstant)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumFlood)).BeginInit();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumRelentless)).BeginInit();
            this.SuspendLayout();
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new System.Drawing.Point(76, 21);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(90, 13);
            label1.TabIndex = 1;
            label1.Text = "Number of Clients";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte) (0)));
            label2.Location = new System.Drawing.Point(6, 45);
            label2.Name = "label2";
            label2.Size = new System.Drawing.Size(48, 13);
            label2.TabIndex = 3;
            label2.Text = "Current";
            // 
            // label3
            // 
            label3.AutoSize = true;
            label3.Location = new System.Drawing.Point(6, 58);
            label3.Name = "label3";
            label3.Size = new System.Drawing.Size(57, 13);
            label3.TabIndex = 4;
            label3.Text = "File Name:";
            // 
            // label4
            // 
            label4.AutoSize = true;
            label4.Location = new System.Drawing.Point(6, 71);
            label4.Name = "label4";
            label4.Size = new System.Drawing.Size(64, 13);
            label4.TabIndex = 5;
            label4.Text = "Max Clients:";
            // 
            // groupBox1
            // 
            groupBox1.Controls.Add(this.lblMaxClients);
            groupBox1.Controls.Add(this.lblFileName);
            groupBox1.Controls.Add(label4);
            groupBox1.Controls.Add(label3);
            groupBox1.Controls.Add(label2);
            groupBox1.Controls.Add(this.butLoadClientList);
            groupBox1.Location = new System.Drawing.Point(12, 12);
            groupBox1.Name = "groupBox1";
            groupBox1.Size = new System.Drawing.Size(230, 97);
            groupBox1.TabIndex = 8;
            groupBox1.TabStop = false;
            groupBox1.Text = "Clients";
            // 
            // lblMaxClients
            // 
            this.lblMaxClients.AutoSize = true;
            this.lblMaxClients.Location = new System.Drawing.Point(76, 71);
            this.lblMaxClients.Name = "lblMaxClients";
            this.lblMaxClients.Size = new System.Drawing.Size(10, 13);
            this.lblMaxClients.TabIndex = 7;
            this.lblMaxClients.Text = "-";
            // 
            // lblFileName
            // 
            this.lblFileName.AutoSize = true;
            this.lblFileName.Location = new System.Drawing.Point(76, 58);
            this.lblFileName.Name = "lblFileName";
            this.lblFileName.Size = new System.Drawing.Size(10, 13);
            this.lblFileName.TabIndex = 6;
            this.lblFileName.Text = "-";
            // 
            // butLoadClientList
            // 
            this.butLoadClientList.Location = new System.Drawing.Point(6, 19);
            this.butLoadClientList.Name = "butLoadClientList";
            this.butLoadClientList.Size = new System.Drawing.Size(97, 23);
            this.butLoadClientList.TabIndex = 2;
            this.butLoadClientList.Text = "Load Client List";
            this.butLoadClientList.UseVisualStyleBackColor = true;
            this.butLoadClientList.Click += new System.EventHandler(this.butLoadClientList_Click);
            // 
            // groupBox2
            // 
            groupBox2.Controls.Add(label17);
            groupBox2.Controls.Add(this.nudNumRelentless);
            groupBox2.Controls.Add(label16);
            groupBox2.Controls.Add(this.nudNumFlood);
            groupBox2.Controls.Add(label15);
            groupBox2.Controls.Add(this.nudNumConstant);
            groupBox2.Controls.Add(this.lblNumHuman);
            groupBox2.Controls.Add(label14);
            groupBox2.Controls.Add(label5);
            groupBox2.Controls.Add(this.nudNumClockwork);
            groupBox2.Controls.Add(this.nudClientCount);
            groupBox2.Controls.Add(label1);
            groupBox2.Location = new System.Drawing.Point(12, 115);
            groupBox2.Name = "groupBox2";
            groupBox2.Size = new System.Drawing.Size(230, 174);
            groupBox2.TabIndex = 9;
            groupBox2.TabStop = false;
            groupBox2.Text = "Settings";
            // 
            // label5
            // 
            label5.AutoSize = true;
            label5.Location = new System.Drawing.Point(76, 66);
            label5.Name = "label5";
            label5.Size = new System.Drawing.Size(97, 13);
            label5.TabIndex = 3;
            label5.Text = "Number Clockwork";
            // 
            // nudNumClockwork
            // 
            this.nudNumClockwork.Location = new System.Drawing.Point(6, 64);
            this.nudNumClockwork.Name = "nudNumClockwork";
            this.nudNumClockwork.Size = new System.Drawing.Size(64, 20);
            this.nudNumClockwork.TabIndex = 2;
            this.nudNumClockwork.ValueChanged += new System.EventHandler(this.nudPercentAbnormal_ValueChanged);
            // 
            // nudClientCount
            // 
            this.nudClientCount.Location = new System.Drawing.Point(6, 19);
            this.nudClientCount.Maximum = new decimal(new int[] {
            10000,
            0,
            0,
            0});
            this.nudClientCount.Name = "nudClientCount";
            this.nudClientCount.Size = new System.Drawing.Size(64, 20);
            this.nudClientCount.TabIndex = 0;
            this.nudClientCount.ValueChanged += new System.EventHandler(this.nudClientCount_ValueChanged);
            // 
            // groupBox3
            // 
            groupBox3.Controls.Add(this.lblBlockingThreshold);
            groupBox3.Controls.Add(this.lblThrottlingThreshold);
            groupBox3.Controls.Add(this.lblTrackingThreshold);
            groupBox3.Controls.Add(this.lblExpectState);
            groupBox3.Controls.Add(this.lblAvgReqPerClient);
            groupBox3.Controls.Add(this.lblActiveClients);
            groupBox3.Controls.Add(this.lblReqInProg);
            groupBox3.Controls.Add(this.lblTestCase);
            groupBox3.Controls.Add(label13);
            groupBox3.Controls.Add(label12);
            groupBox3.Controls.Add(label11);
            groupBox3.Controls.Add(label10);
            groupBox3.Controls.Add(label9);
            groupBox3.Controls.Add(label8);
            groupBox3.Controls.Add(label7);
            groupBox3.Controls.Add(label6);
            groupBox3.Location = new System.Drawing.Point(12, 295);
            groupBox3.Name = "groupBox3";
            groupBox3.Size = new System.Drawing.Size(230, 150);
            groupBox3.TabIndex = 10;
            groupBox3.TabStop = false;
            groupBox3.Text = "Current Values";
            // 
            // lblBlockingThreshold
            // 
            this.lblBlockingThreshold.AutoSize = true;
            this.lblBlockingThreshold.Location = new System.Drawing.Point(114, 125);
            this.lblBlockingThreshold.Name = "lblBlockingThreshold";
            this.lblBlockingThreshold.Size = new System.Drawing.Size(10, 13);
            this.lblBlockingThreshold.TabIndex = 15;
            this.lblBlockingThreshold.Text = "-";
            // 
            // lblThrottlingThreshold
            // 
            this.lblThrottlingThreshold.AutoSize = true;
            this.lblThrottlingThreshold.Location = new System.Drawing.Point(114, 112);
            this.lblThrottlingThreshold.Name = "lblThrottlingThreshold";
            this.lblThrottlingThreshold.Size = new System.Drawing.Size(10, 13);
            this.lblThrottlingThreshold.TabIndex = 14;
            this.lblThrottlingThreshold.Text = "-";
            // 
            // lblTrackingThreshold
            // 
            this.lblTrackingThreshold.AutoSize = true;
            this.lblTrackingThreshold.Location = new System.Drawing.Point(114, 99);
            this.lblTrackingThreshold.Name = "lblTrackingThreshold";
            this.lblTrackingThreshold.Size = new System.Drawing.Size(10, 13);
            this.lblTrackingThreshold.TabIndex = 13;
            this.lblTrackingThreshold.Text = "-";
            // 
            // lblExpectState
            // 
            this.lblExpectState.AutoSize = true;
            this.lblExpectState.Location = new System.Drawing.Point(122, 77);
            this.lblExpectState.Name = "lblExpectState";
            this.lblExpectState.Size = new System.Drawing.Size(10, 13);
            this.lblExpectState.TabIndex = 12;
            this.lblExpectState.Text = "-";
            // 
            // lblAvgReqPerClient
            // 
            this.lblAvgReqPerClient.AutoSize = true;
            this.lblAvgReqPerClient.Location = new System.Drawing.Point(122, 64);
            this.lblAvgReqPerClient.Name = "lblAvgReqPerClient";
            this.lblAvgReqPerClient.Size = new System.Drawing.Size(10, 13);
            this.lblAvgReqPerClient.TabIndex = 11;
            this.lblAvgReqPerClient.Text = "-";
            // 
            // lblActiveClients
            // 
            this.lblActiveClients.AutoSize = true;
            this.lblActiveClients.Location = new System.Drawing.Point(122, 51);
            this.lblActiveClients.Name = "lblActiveClients";
            this.lblActiveClients.Size = new System.Drawing.Size(10, 13);
            this.lblActiveClients.TabIndex = 10;
            this.lblActiveClients.Text = "-";
            // 
            // lblReqInProg
            // 
            this.lblReqInProg.AutoSize = true;
            this.lblReqInProg.Location = new System.Drawing.Point(122, 38);
            this.lblReqInProg.Name = "lblReqInProg";
            this.lblReqInProg.Size = new System.Drawing.Size(10, 13);
            this.lblReqInProg.TabIndex = 9;
            this.lblReqInProg.Text = "-";
            // 
            // lblTestCase
            // 
            this.lblTestCase.AutoSize = true;
            this.lblTestCase.Location = new System.Drawing.Point(62, 16);
            this.lblTestCase.Name = "lblTestCase";
            this.lblTestCase.Size = new System.Drawing.Size(10, 13);
            this.lblTestCase.TabIndex = 8;
            this.lblTestCase.Text = "-";
            // 
            // label13
            // 
            label13.AutoSize = true;
            label13.Location = new System.Drawing.Point(6, 77);
            label13.Name = "label13";
            label13.Size = new System.Drawing.Size(83, 13);
            label13.TabIndex = 7;
            label13.Text = "Expected State:";
            // 
            // label12
            // 
            label12.AutoSize = true;
            label12.Location = new System.Drawing.Point(6, 125);
            label12.Name = "label12";
            label12.Size = new System.Drawing.Size(101, 13);
            label12.TabIndex = 6;
            label12.Text = "Blocking Threshold:";
            // 
            // label11
            // 
            label11.AutoSize = true;
            label11.Location = new System.Drawing.Point(6, 112);
            label11.Name = "label11";
            label11.Size = new System.Drawing.Size(104, 13);
            label11.TabIndex = 5;
            label11.Text = "Throttling Threshold:";
            // 
            // label10
            // 
            label10.AutoSize = true;
            label10.Location = new System.Drawing.Point(6, 64);
            label10.Name = "label10";
            label10.Size = new System.Drawing.Size(114, 13);
            label10.TabIndex = 4;
            label10.Text = "Avg Requests / Client:";
            // 
            // label9
            // 
            label9.AutoSize = true;
            label9.Location = new System.Drawing.Point(6, 51);
            label9.Name = "label9";
            label9.Size = new System.Drawing.Size(74, 13);
            label9.TabIndex = 3;
            label9.Text = "Active Clients:";
            // 
            // label8
            // 
            label8.AutoSize = true;
            label8.Location = new System.Drawing.Point(6, 38);
            label8.Name = "label8";
            label8.Size = new System.Drawing.Size(110, 13);
            label8.TabIndex = 2;
            label8.Text = "Requests in Progress:";
            // 
            // label7
            // 
            label7.AutoSize = true;
            label7.Location = new System.Drawing.Point(6, 99);
            label7.Name = "label7";
            label7.Size = new System.Drawing.Size(102, 13);
            label7.TabIndex = 1;
            label7.Text = "Tracking Threshold:";
            // 
            // label6
            // 
            label6.AutoSize = true;
            label6.Location = new System.Drawing.Point(6, 16);
            label6.Name = "label6";
            label6.Size = new System.Drawing.Size(58, 13);
            label6.TabIndex = 0;
            label6.Text = "Test Case:";
            // 
            // ofdClientList
            // 
            this.ofdClientList.DefaultExt = "xml";
            this.ofdClientList.Filter = "XML files|*.xml";
            this.ofdClientList.Title = "Load Client List";
            // 
            // tmrCurrentValues
            // 
            this.tmrCurrentValues.Enabled = true;
            this.tmrCurrentValues.Interval = 1000;
            this.tmrCurrentValues.Tick += new System.EventHandler(this.tmrCurrentValues_Tick);
            // 
            // label14
            // 
            label14.AutoSize = true;
            label14.Location = new System.Drawing.Point(76, 44);
            label14.Name = "label14";
            label14.Size = new System.Drawing.Size(81, 13);
            label14.TabIndex = 4;
            label14.Text = "Number Human";
            // 
            // lblNumHuman
            // 
            this.lblNumHuman.AutoSize = true;
            this.lblNumHuman.Location = new System.Drawing.Point(6, 44);
            this.lblNumHuman.Name = "lblNumHuman";
            this.lblNumHuman.Size = new System.Drawing.Size(10, 13);
            this.lblNumHuman.TabIndex = 5;
            this.lblNumHuman.Text = "-";
            // 
            // nudNumConstant
            // 
            this.nudNumConstant.Location = new System.Drawing.Point(6, 90);
            this.nudNumConstant.Name = "nudNumConstant";
            this.nudNumConstant.Size = new System.Drawing.Size(64, 20);
            this.nudNumConstant.TabIndex = 6;
            this.nudNumConstant.ValueChanged += new System.EventHandler(this.nudNumConstant_ValueChanged);
            // 
            // label15
            // 
            label15.AutoSize = true;
            label15.Location = new System.Drawing.Point(76, 92);
            label15.Name = "label15";
            label15.Size = new System.Drawing.Size(89, 13);
            label15.TabIndex = 7;
            label15.Text = "Number Constant";
            // 
            // nudNumFlood
            // 
            this.nudNumFlood.Location = new System.Drawing.Point(6, 116);
            this.nudNumFlood.Name = "nudNumFlood";
            this.nudNumFlood.Size = new System.Drawing.Size(64, 20);
            this.nudNumFlood.TabIndex = 8;
            this.nudNumFlood.ValueChanged += new System.EventHandler(this.nudNumFlood_ValueChanged);
            // 
            // label16
            // 
            label16.AutoSize = true;
            label16.Location = new System.Drawing.Point(76, 118);
            label16.Name = "label16";
            label16.Size = new System.Drawing.Size(73, 13);
            label16.TabIndex = 9;
            label16.Text = "Number Flood";
            // 
            // nudNumRelentless
            // 
            this.nudNumRelentless.Location = new System.Drawing.Point(6, 142);
            this.nudNumRelentless.Name = "nudNumRelentless";
            this.nudNumRelentless.Size = new System.Drawing.Size(64, 20);
            this.nudNumRelentless.TabIndex = 10;
            this.nudNumRelentless.ValueChanged += new System.EventHandler(this.nudNumRelentless_ValueChanged);
            // 
            // label17
            // 
            label17.AutoSize = true;
            label17.Location = new System.Drawing.Point(76, 144);
            label17.Name = "label17";
            label17.Size = new System.Drawing.Size(96, 13);
            label17.TabIndex = 11;
            label17.Text = "Number Relentless";
            // 
            // AntiDosForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(254, 455);
            this.Controls.Add(groupBox3);
            this.Controls.Add(groupBox2);
            this.Controls.Add(groupBox1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "AntiDosForm";
            this.Text = "AntiDos Settings";
            groupBox1.ResumeLayout(false);
            groupBox1.PerformLayout();
            groupBox2.ResumeLayout(false);
            groupBox2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumClockwork)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.nudClientCount)).EndInit();
            groupBox3.ResumeLayout(false);
            groupBox3.PerformLayout();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumConstant)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumFlood)).EndInit();
            ((System.ComponentModel.ISupportInitialize) (this.nudNumRelentless)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.NumericUpDown nudClientCount;
        private System.Windows.Forms.Button butLoadClientList;
        private System.Windows.Forms.Label lblFileName;
        private System.Windows.Forms.Label lblMaxClients;
        private System.Windows.Forms.NumericUpDown nudNumClockwork;
        private System.Windows.Forms.Label lblExpectState;
        private System.Windows.Forms.Label lblAvgReqPerClient;
        private System.Windows.Forms.Label lblActiveClients;
        private System.Windows.Forms.Label lblReqInProg;
        private System.Windows.Forms.Label lblTestCase;
        private System.Windows.Forms.Label lblBlockingThreshold;
        private System.Windows.Forms.Label lblThrottlingThreshold;
        private System.Windows.Forms.Label lblTrackingThreshold;
        private System.Windows.Forms.OpenFileDialog ofdClientList;
        private System.Windows.Forms.Timer tmrCurrentValues;
        private System.Windows.Forms.Label lblNumHuman;
        private System.Windows.Forms.NumericUpDown nudNumConstant;
        private System.Windows.Forms.NumericUpDown nudNumFlood;
        private System.Windows.Forms.NumericUpDown nudNumRelentless;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AAGatewayTests\Policy.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.STS;
using ServerTestFramework.Utilities;

using xonline.common.protocol;

namespace PirateSGTest
{
    [TestGroup, Owner("johnmcp"), TestCasePriority(1)]
	public class Policy : TestNode
    {
        #region Setup And Utils

        public const string SimplePath = "/testfd/Reflect/authsg/policy/simple";
        public const string RequiresXuidPath = "/testfd/Reflect/authsg/policy/requiresxuid";
        public const string WLIDPath = "/testfd/Reflect/authsg/policy/wlid";
        public const string RequiresMachinePath = "/testfd/Reflect/authsg/policy/requiresmachinepath";
        public const string RequiresCertPath = "/testfd/Reflect/authsg/policy/requirescertpath";

        public const string TestFDQueryString = "?caller=authsg";

        public override void PreRun ()
        {
            // flush this between runs in case the environment changes
            _SigningCertificate = null;

            //configure URIs to use
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() 
                { Path = SimplePath, AuthRequired = true, AuthHeader = "XBL1.0" });
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() 
                { Path = RequiresXuidPath, AuthRequired = true, AuthHeader = "XBL1.0", RequiresXuid = true });
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() 
                { Path = WLIDPath, AuthRequired = true, AuthHeader = "WLID1.0" });
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() 
                { Path = RequiresMachinePath, AuthRequired = true, AuthHeader = "XBL1.0", RequiresMachineId = true });
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() 
                { Path = RequiresCertPath, AuthRequired = true, AuthHeader = "XBL1.0", SSLRequired = true, RequiresClientCert = true });

            SharedSetup.Reload();

            System.Net.ServicePointManager.ServerCertificateValidationCallback += RemoteCertAcceptor;
        }

        public override void PostRun ()
        {
            // its safe to always remove, does nothing if its not there
            System.Net.ServicePointManager.ServerCertificateValidationCallback -= RemoteCertAcceptor;
        }

        /// <summary>
        /// Adds the TestFD Reflect parameters as a query string.
        /// </summary>
        public static void AddGetDataToRequest (HttpClient.Request req)
        {
            req.URI += TestFDQueryString;
        }

        //adds an acceptable POST content and headers to a request
        public static void AddPostDataToRequest (HttpClient.Request req)
        {
            req.Method = "POST";

            TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
            tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
            tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

            req.SetContentLengthAndBody(tfd_req.ToArray());
            req.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will be a @#$^% and block us without this
        }

        private static X509Certificate2 _SigningCertificate = null;

        public static X509Certificate2 SigningCertificate
        {
            get
            {
                if (_SigningCertificate == null)
                {
                    _SigningCertificate = STSUtil.GetStsSigningCertificate();
                }

                return _SigningCertificate;
            }
        }

        #endregion

        #region Verification

        public static void CheckStatus (int expectedStatus, HttpClient.Response response)
        {
            if (response == null)
            {
                throw new UnexpectedTestResultException("Expected a response.");
            }

            if (expectedStatus != response.Status)
            {
                throw new UnexpectedTestResultException("Expected " + expectedStatus + " but got " + response.Status + ": " + response.Reason);
            }
        }

        #endregion

        #region Helpers

        private static bool RemoteCertAcceptor (object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
            System.Security.Cryptography.X509Certificates.X509Chain chain, System.Net.Security.SslPolicyErrors sslPolicyErrors)
        {
            return true; // **** Always accept
        }

        private class LocalCertPicker
        {
            private X509Certificate _cert;

            public LocalCertPicker (X509Certificate cert) { _cert = cert; }

            public LocalCertificateSelectionCallback PickMyCertDelegate
            {
                get
                {
                    return new LocalCertificateSelectionCallback(PickMyCert);
                }
            }

            public X509Certificate PickMyCert (object sender, string targetHost, X509CertificateCollection localCertificates,
                X509Certificate remoteCertificate, string[] acceptableIssuers)
            {
                return _cert;
            }
        }

        public static void InitiateSSLWithCert (string url, X509Certificate certificate)
        {
            // Use this bit of .Net specific trickery to enable our use of whatever client certificate we want in
            // HttpWebRequest.  See this documentation on SslStream http://msdn.microsoft.com/en-us/library/ms145057.aspx
            // The Note down below mentions this "technique" of caching an SSL state
            TcpClient tcp = new TcpClient(SharedSetup.SSLHost, SharedSetup.SSLPort);
            SslStream ssl = new SslStream(tcp.GetStream(), false, RemoteCertAcceptor, (new LocalCertPicker(certificate)).PickMyCertDelegate);
            ssl.AuthenticateAsClient(SharedSetup.SSLHost, new X509CertificateCollection(new X509Certificate[] { certificate }),
                System.Security.Authentication.SslProtocols.Default, false);

            // create a request that we don't care about
            HttpClient.Request req = new HttpClient.Request(SharedSetup.SSLHost + ":" + SharedSetup.SSLPort, url);

            ssl.Write(req.ToBytes());
            ssl.Flush();
            // this read is necessary to force the client certificate
            ssl.Read(new byte[1], 0, 1);
            ssl.Close();
        }

        #endregion

        [TestCase, Description("Policy requires WLID, send XBL.")]
        public class RequireWLID_UseXBL : TestNode
        {
            public override void Run()
            {
                STSUtil.GetSecurityTicketParameters gstp = new STSUtil.GetSecurityTicketParameters();
                gstp.Certificate = SigningCertificate;
                string token = STSUtil.GetSecurityTicket(gstp);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), WLIDPath);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                http.SendRequest(req);
                CheckStatus(401, http.GetResponse());
            }
        }

        [TestCase, Description("Policy requires XBL, send WLID.")]
        public class RequireXBL_UseWLID : TestNode
        {
            public override void Run()
            {
                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + SharedAAInfoTests.NonXblPassportTicket);

                http.SendRequest(req);
                CheckStatus(401, http.GetResponse());
            }
        }

        [TestCase, Description("Policy requires XUID, send machine only.")]
        public class RequireXuid : TestNode
        {
            public override void Run()
            {
                STSUtil.GetSecurityTicketParameters gstp = new STSUtil.GetSecurityTicketParameters();
                gstp.Certificate = SigningCertificate;
                gstp.GenerateUserClaims = false;
                string token = STSUtil.GetSecurityTicket(gstp);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), RequiresXuidPath);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                http.SendRequest(req);
                CheckStatus(400, http.GetResponse());
            }
        }

        [TestCase(BugDatabase = "Xbox 360 Console Software", BugID = 136106), Description("Policy requires Machine, send partner ticket.")]
        public class RequireMachine : TestNode
        {
            public override void Run()
            {
                STSUtil.GetPartnerSecurityTicketParameters gpstp = new STSUtil.GetPartnerSecurityTicketParameters();
                gpstp.Certificate = SigningCertificate;
                string token = STSUtil.GetPartnerSecurityTicket(gpstp);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), RequiresMachinePath);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                http.SendRequest(req);

                // implement CheckStatus here so we can intercept 500s for a known bug exception
                int expectedStatus = 401;
                HttpClient.Response response = http.GetResponse();

                if (response == null)
                {
                    throw new UnexpectedTestResultException("Expected a response.");
                }

                // there should potentially be more checking here to make sure that its our exact 500
                if (response.Status == 500)
                {
                    throw new KnownBugException(136106, "Xbox 360 Console Software");
                }

                if (expectedStatus != response.Status)
                {
                    throw new UnexpectedTestResultException("Expected " + expectedStatus + " but got " + response.Status + ": " + response.Reason);
                }
            }
        }

        [TestCase, Description("Use a different cert than the ticket was created for.")]
        public class CertDeviceMismatch : TestNode
        {
            public override void Run()
            {
                // create security token
                STSUtil.GetSecurityTicketParameters gstp = new STSUtil.GetSecurityTicketParameters();
                gstp.Certificate = SigningCertificate;
                string token = STSUtil.GetSecurityTicket(gstp);

                // get client cert
                System.IO.Stream certStream =
                    System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(@"certs.StsFDTest_MultiEKU.pfx");
                System.IO.BinaryReader certReader = new System.IO.BinaryReader(certStream);
                byte[] certBytes = certReader.ReadBytes((int)(certStream.Length));
                X509Certificate2 certificate = new X509Certificate2(certBytes);

                // hackery!
                InitiateSSLWithCert(RequiresCertPath, certificate);

                //put info into C#'s requester
                string requestString = "https://" + SharedSetup.SSLHost + ":" + SharedSetup.SSLPort +
                    RequiresCertPath;

                Global.RO.Debug("Request string: " + requestString);
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                netreq.Headers.Add("Authorization: XBL1.0 x=" + token);
                netreq.ClientCertificates.Add(certificate);

                netreq.Method = "POST";
                netreq.ContentType = "text/xml";

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                byte[] postData = tfd_req.ToArray();
                netreq.ContentLength = postData.Length;
                netreq.GetRequestStream().Write(postData, 0, postData.Length);

                //try the request
                WebResponse netresp = null;
                try
                {
                    netresp = netreq.GetResponse();
                    throw new UnexpectedTestResultException("Request was successful, it should have been denied.");
                }
                catch (WebException we)
                {
                    int status = (int)(((HttpWebResponse)we.Response).StatusCode);

                    if (status != 401)
                    {
                        throw;
                    }
                }
            }
        }

        [TestCase, Description("Use a local cert to sign the SAML token.")]
        public class SelfSignedSaml : TestNode
        {
            public override void Run()
            {
                System.IO.Stream certStream =
                    System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(@"certs.StsFDTest_TestEKU.pfx");
                System.IO.BinaryReader certReader = new System.IO.BinaryReader(certStream);
                byte[] certBytes = certReader.ReadBytes((int)(certStream.Length));
                X509Certificate2 certificate = new X509Certificate2(certBytes);

                STSUtil.GetSecurityTicketParameters gstp = new STSUtil.GetSecurityTicketParameters();
                gstp.Certificate = certificate;
                string token = STSUtil.GetSecurityTicket(gstp);

                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimplePath);
                AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: XBL1.0 x=" + token);

                http.SendRequest(req);
                CheckStatus(401, http.GetResponse());
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\common\Reflector.cs ===
using System;

namespace AATest
{

public partial class Reflector
{
    private static readonly byte[] Preamble = new byte[] { 0, 1, 2, 3 };

    public enum RequestParameters : byte
    {
        /// <summary>Reads the next byte b, sleeps for b * 100ms.</summary>
        ResponseWait = 0,
        ThrowUnhandledException,
        Exit,
        NoAAInfoLookup,
        ReturnError,
        NoResponse,
        ReflectHeaders,
        /// <summary>Reads the next ushort u, returns a body of size u * 1024.</summary>
        OutputBody,
        /// <summary>Reads the next byte b, sleeps for b * 1s.</summary>
        ResponseWaitLong,
        /// <summary>A quick response that has less information.</summary>
        Stress,
        ResponseXMLContentType,
        /// <summary>Reads the next byte b, sleeps for b * 1ms.</summary>
        ResponseWaitShort,
    }

    /// <summary>
    /// Creates a byte array that can be sent to the reflector.
    /// </summary>
    /// <param name="command">The reflector command.</param>
    /// <returns>A request body suitable for making the reflector execute the command.</returns>
    public static byte[] CreateReflectorRequestBody (RequestParameters command)
    {
        return CreateReflectorRequestBody(command, new byte[0]);
    }

    /// <summary>
    /// Creates a byte array that can be sent to the reflector.
    /// </summary>
    /// <param name="command">The reflector command.</param>
    /// <param name="param">The single byte parameter to the command.</param>
    /// <returns>A request body suitable for making the reflector execute the command.</returns>
    public static byte[] CreateReflectorRequestBody (RequestParameters command, byte param)
    {
        return CreateReflectorRequestBody(command, new byte[] { param });
    }

    /// <summary>
    /// Creates a byte array that can be sent to the reflector.
    /// </summary>
    /// <param name="command">The reflector command.</param>
    /// <param name="param">The two byte parameter to the command.</param>
    /// <returns>A request body suitable for making the reflector execute the command.</returns>
    public static byte[] CreateReflectorRequestBody (RequestParameters command, ushort param)
    {
        return CreateReflectorRequestBody(command, new byte[] { (byte) (param >> 8), (byte) (param & 0xFF) });
    }

    /// <summary>
    /// Creates a byte array that can be sent to the reflector.
    /// </summary>
    /// <param name="command">The reflector command.</param>
    /// <param name="extra">Bytes to write after the command.</param>
    /// <returns>A request body suitable for making the reflector execute the command.</returns>
    public static byte[] CreateReflectorRequestBody (RequestParameters command, byte[] extra)
    {
        byte[] ans = new byte[Preamble.Length + 1 + extra.Length];

        Buffer.BlockCopy(Preamble, 0, ans, 0, Preamble.Length);
        ans[Preamble.Length] = (byte) command;
        Buffer.BlockCopy(extra, 0, ans, Preamble.Length+1, extra.Length);

        return ans;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\AntiDos\Client.cs ===
using System;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace AntiDos
{
    /// <summary>
    /// A normal client behaves in a pattern that is within the limits of what a real user might do 
    /// (at least for a short time).  They will most likely never have more than 1 request in progress.
    /// They should never be blocked, unless blocking has become enabled.
    /// 
    /// An abnormal client is a rogue that is trying to do something bad to us.  They will often be blocked.
    /// </summary>
    public class Client
    {
        #region SubTypes

        public enum Behavior
        {
            /// <summary>Normal: Somewhat bursty but still has relative pauses between requests.</summary>
            Human,
            /// <summary>Normal: Constant stream of requests at regular intervals.</summary>
            Clockwork,
            /// <summary>
            /// Both: Constant stream of requests with no pauses, depending on server response time this may be few 
            /// or many.  Every one of these permanently occupies 1 request on the server side.
            /// </summary>
            Constant,
            /// <summary>
            /// Abnormal: A never ending stream of requests is unleashed, the result is read in to check that it 
            /// is what is expected.
            /// </summary>
            Flood,
            /// <summary>
            /// Abnormal: A never ending stream of requests is unleashed, with no care for the results except to 
            /// empty the incoming buffers.
            /// </summary>
            Relentless,
        }

        #endregion

        #region Statics

        protected static Report _report = null;

        /// <summary>
        /// A basic request for the AntiDosXRL.
        /// </summary>
        protected static byte[] StandardAntiDosRequest;

        static Client ()
        {
            _report = new Report("AntiDosClient");

            HttpClient.Request req = new HttpClient.Request(AntiDos.Target.Address.ToString(), AntiDos.AntiDosXRL);
            req.Method = "POST";
            req.OtherHeaders.AddLast("Content-type: text/xml");
            req.SetContentLengthAndBody(AATest.Reflector.CreateReflectorRequestBody(
                AATest.Reflector.RequestParameters.ResponseWaitShort, (byte) 20));
            StandardAntiDosRequest = req.ToBytes();
        }

        #endregion

        #region Fields

        public ClientInfo ClientInfo = null;
        public double Scale = 1.0;
        public DateTime BanTime = DateTime.MinValue;

        protected HttpClient _http_client = null;
        protected AntiDosState _antidos_state = null;
        protected Behavior _state = Behavior.Human;
        protected RandomEx _rand = new RandomEx();
        protected Queue<bool> _block_map = new Queue<bool>();

        protected List<Client> _flood_subclients = null;

        /// <summary>
        /// This is used to tell all of the Clients to stop.  Hopefully.
        /// </summary>
        protected ManualResetEvent CancelSignaler;
        protected bool _running = false;

        internal volatile int RequestsInProgress = 0;

        #endregion

        public Behavior State
        {
            get { return _state; }
            set
            {
                _state = value;

                switch (_state)
                {
                    case Behavior.Human:
                    case Behavior.Clockwork:
                    case Behavior.Constant:
                    case Behavior.Flood:
                    case Behavior.Relentless:
                        // lazy do-nothings...
                        break;

                    default:
                        throw new Exception("Implement me!");
                }
            }
        }

        public double TotalScale
        {
            get
            {
                return _antidos_state.Scale * Scale;
            }
        }

        public Client (AntiDosState antiDosState)
        {
            _antidos_state = antiDosState;
            CancelSignaler = new ManualResetEvent(false);
        }

        #region Work Functions

        #region Human

        protected void HumanReceiveResponse (HttpClient.Response response)
        {
            try
            {
                CheckResponse(response);

                double val = _rand.NextDouble();
                int timeout = 0;

                if (val < 0.2)
                {
                    timeout = _rand.Next(2000);
                }
                else if (val < 0.6)
                {
                    timeout = 8000 + _rand.Next(6000);
                }
                else
                {
                    timeout = 30000 + _rand.Next(90000);
                }

                ThreadPool.RegisterWaitForSingleObject(CancelSignaler, new WaitOrTimerCallback(HumanNextTick),
                    null, timeout, true);
            }
            catch (Exception e)
            {
                HandleException(e);
            }
        }

        protected void HumanNextTick (object state, bool timeout)
        {
            try
            {
                if (timeout && _running)
                {
                    SendReceiveAsync(StandardAntiDosRequest, true, HumanReceiveResponse);
                }

                // if we did not time out, then we have been signaled to cancel, do nothing and we will die out
            }
            catch (Exception e)
            {
                HandleException(e);
            }
        }

        #endregion

        #region Clockwork

        protected void ClockworkReceiveResponse (HttpClient.Response response)
        {
            try
            {
                CheckResponse(response);

                ThreadPool.RegisterWaitForSingleObject(CancelSignaler, new WaitOrTimerCallback(ClockworkNextTick),
                    null, 1000, true);
            }
            catch (Exception e)
            {
                HandleException(e);
            }
        }

        protected void ClockworkNextTick (object state, bool timeout)
        {
            try
            {
                if (timeout && _running)
                {
                    SendReceiveAsync(StandardAntiDosRequest, true, ClockworkReceiveResponse);
                }

                // if we did not time out, then we have been signaled to cancel, do nothing and we will die out
            }
            catch (Exception e)
            {
                HandleException(e);
            }
        }

        #endregion

        #region Constant

        protected void ConstantReceiveResponse (HttpClient.Response response)
        {
            try
            {
                CheckResponse(response);

                if (_running)
                {
                    SendReceiveAsync(StandardAntiDosRequest, true, ConstantReceiveResponse);
                }
            }
            catch (Exception e)
            {
                HandleException(e);
            }
        }

        #endregion

        #region Relentless

        protected void RelentlessAssault (object useless)
        {
            try
            {
                _http_client.Connect();

                byte[] temp = new byte[4096];
                _http_client.Socket.BeginReceive(temp, 0, 4096, SocketFlags.None,
                    new AsyncCallback(RelentlessAssaultResponseDrain), temp);

                while (_running)
                {
                    //_http_client.SendRequestAsync(StandardAntiDosRequest);
                    _http_client.Socket.Send(StandardAntiDosRequest);
                }
            }
            catch (Exception e)
            {
                HandleException(e);
            }
        }

        protected void RelentlessAssaultResponseDrain (IAsyncResult result)
        {
            try
            {
                int size = _http_client.Socket.EndReceive(result);

                byte[] temp = (byte[]) result.AsyncState;

                if (size == temp.Length)
                {
                    while (_http_client.Socket.Available > 0)
                    {
                        _http_client.Socket.Receive(temp, Math.Min(_http_client.Socket.Available, temp.Length),
                            SocketFlags.None);
                    }
                }

                if (_running)
                {
                    _http_client.Socket.BeginReceive(temp, 0, 4096, SocketFlags.None,
                        new AsyncCallback(RelentlessAssaultResponseDrain), temp);
                }
            }
            catch (Exception e)
            {
                HandleException(e);
            }
        }

        #endregion

        #endregion

        /// <summary>
        /// Initializes the client with the given client info.  After this it is ready to send data.
        /// </summary>
        /// <param name="clientInfo">The client info to use for sending requests.</param>
        public void Initialize (ClientInfo clientInfo)
        {
            ClientInfo = clientInfo;

            // A port of 0 means a locally bound IP
            if (clientInfo.ClientEndPoint.Port == 0)
            {
                _http_client = new HttpClient(AntiDos.Target);
                _http_client.Socket.Bind(clientInfo.ClientEndPoint);
            }
            // A port other than 0 means a remote TCP relay, we are going to start the relay also
            else
            {
                throw new Exception("Implement me!");
            }
        }

        /// <summary>
        /// Starts the client a runnin'.
        /// </summary>
        public void Start ()
        {
            CancelSignaler.Reset();
            _running = true;

            switch (_state)
            {
                case Behavior.Human:
                    SendReceiveAsync(StandardAntiDosRequest, true, HumanReceiveResponse);
                    break;

                case Behavior.Clockwork:
                    SendReceiveAsync(StandardAntiDosRequest, true, ClockworkReceiveResponse);
                    break;

                case Behavior.Constant:
                    SendReceiveAsync(StandardAntiDosRequest, true, ConstantReceiveResponse);
                    break;

                case Behavior.Flood:
                    _flood_subclients = new List<Client>(1000);

                    lock (_flood_subclients)
                    {
                        for (int i = 0; i < 1000; ++i)
                        {
                            Client temp = new Client(_antidos_state);

                            temp.Initialize(ClientInfo);
                            temp.State = Behavior.Constant;
                            temp.Start();

                            _flood_subclients.Add(temp);
                        }
                    }
                    break;

                case Behavior.Relentless:
                    ThreadPool.QueueUserWorkItem(new WaitCallback(RelentlessAssault));
                    break;

                default:
                    throw new Exception("Implement me!");
            }
        }

        /// <summary>
        /// Stops the client from running, hopefully.
        /// </summary>
        public void Stop ()
        {
            CancelSignaler.Set();
            _running = false;

            if (_flood_subclients != null)
            {
                lock (_flood_subclients)
                {
                    foreach (Client cli in _flood_subclients)
                    {
                        cli.Stop();
                    }
                }
            }
        }

        /// <summary>
        /// Handles an exception.
        /// </summary>
        /// <param name="e">The exception.</param>
        public static void HandleException (Exception e)
        {
            _report.Error(e.ToString());
        }

        #region Send/Receive Functions

        protected void SendReceiveAsync (byte[] buff, bool readBody, HttpClient.AsyncResponseCallback callback)
        {
            try
            {
                _block_map.Enqueue(_antidos_state.BeginRequest(this));
                _http_client.SendReceiveAsync(buff, readBody, callback);
            }
            catch
            {
                _antidos_state.EndRequest(this);

                throw;
            }
        }

        protected void CheckResponse (HttpClient.Response response)
        {
            _antidos_state.EndRequest(this);
            bool expect = _block_map.Dequeue();

            // check for OK/Blocked/Error
            if (response == null)
            {
                _antidos_state.ReportNoResponse();
            }
            else if (response.Status == 200)
            {
                if (expect)
                {
                    _antidos_state.ReportGoodResponse();
                }
                else
                {
                    _antidos_state.ReportFalsePositive();
                }
            }
            else if (response.Status == 503)
            {
                if (expect)
                {
                    _antidos_state.ReportFalseNegative();
                }
                else
                {
                    _antidos_state.ReportBlockedResponse();
                }
            }
            else
            {
                _antidos_state.ReportErrorResponse(response.Status);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\GatewayDVT\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\common\SharedSetup.cs ===
//This setup is shared by both the gateway test suite and the module test suite.

using System;
using System.Data.SqlClient;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

namespace PirateSGTest
{
    public class SharedSetup
    {
        //configures a uri to point to the appropriate reflector and require passport auth.
        //the module on the reflector will need reloaded after this.
        public static void ConfigureUri(string path, bool authRequired)
        {
            ConfigureUri(path, authRequired, false, false);
        }

        public static void ConfigureUri(string path, bool authRequired, bool sslRequired)
        {
            ConfigureUri(path, authRequired, sslRequired, false);
        }

        public static void ConfigureUri(string path, bool authRequired, bool sslRequired, bool antiDosRequired)
        {
            ConfigureUri(path, authRequired, (authRequired ? "MBI" : null), sslRequired, antiDosRequired, false, false, 0, 0);
        }

        public static void ConfigureUri(string path, bool authRequired, string authLevel, bool sslRequired, bool antiDosRequired, 
            bool xuid, bool throttle, int halflife, int threshold)
        {
            //setup active auth module policy
            ActiveAuthHttpConfig.PolicyEntry policy=new ActiveAuthHttpConfig.PolicyEntry();
            policy.Path=path;
            if (authRequired)
            {
                policy.AuthRequired=true;
                policy.AuthPolicy = authLevel;
            }
        
            policy.SSLRequired = sslRequired;
            policy.AntiDOS = antiDosRequired;

            policy.RequiresXuid = xuid;
            policy.Throttle = throttle;
            policy.ThrottleHalflifeSeconds = halflife;
            policy.ThrottleThreshold = threshold;

            ConfigureUri(policy);
        }

        public static void ConfigureUri(ActiveAuthHttpConfig.PolicyEntry policy)
        {
            ConfigureUri(policy, false);
        }

        public static void ConfigureUri (ActiveAuthHttpConfig.PolicyEntry policy, Boolean allowPartialMatch)
        {
            ActiveAuthHttpConfig.SetPolicyEntry(policy);

#if GatewayTests
            AAGatewayTests.AAGatewayTestBase.MapFromGatewayToVirtualInterfaceDEPRECATED(policy.Path, 
                AAGatewayTests.AAGatewayTestBase.ReflectorVInterfaceName, true, allowPartialMatch);
#endif
        }

        //reloads the module/gateway
        public static void Reload()
        {
#if GatewayTests
            AAGatewayTests.AAGatewayTestBase.ConfigCacheRefresh();
            AAGatewayTests.AAGatewayTestBase.ConfigCacheRefreshModule();
            AAGatewayTests.AAGatewayTestBase.ReloadModule();
            AAGatewayTests.AAGatewayTestBase.ReloadWithFail();
            AAGatewayTests.AAGatewayTestBase.ReloadXrlscan();
#elif ModuleTests
            AAModuleSuite.AAModuleReload();
#else
            Global.RO.Fatal("Unknown aa test type.  You should define whether the tests are for the gateway or the module.");
#endif
        }

        /// <summary>
        /// The name of the host to connect to for SSL, also needs to match the cert on the machine.
        /// </summary>
        /// <remarks>
        /// MASSIVE TODO: find name of the activeauth box... and build request string based on that.
        /// This will only work on a hardcoded list until then.
        /// </remarks>
        public static string SSLHost
        {
            get
            {
#if GatewayTests
                return Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.authsg_ssl).Address.ToString();
#elif ModuleTests
                if (Global.XEnv.GetEnv().ToLower()=="stressnet") return "s1xblaasgiis801.core.live";
                else if (Global.XEnv.GetEnv().ToLower()=="testnet") return "txxblsecuinh101.core.live";
                else if (Global.XEnv.GetEnv().ToLower()=="stressnet2") return "s2xblaasgiis801.core.live";
                else
                {
                    Global.RO.Warn("SSLHost: We are not coded for environment: "+Global.XEnv.GetEnv()+", so defaulting to stressnet1 server.");
                    return "S1XBLAASGIIS001.test.live";
                }
#else
                return "";
#endif
            }
        }

        /// <summary>
        /// The port to use when connecting to ActiveAuth with SSL.
        /// </summary>
#if ModuleTests
        public static readonly int SSLPort = 12346;
#else //GatewayTests
        public static int SSLPort
        {
            get
            {
                return Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.authsg_ssl).Port;
            }
        }
#endif

        /// <summary>
        /// List of interfaces to the server.
        /// </summary>
        public static string[] ServerList
        {
            get
            {
#if ModuleTests
                return Global.XEnv.GetServerListByInterface(AAModuleSuite.IFDReflectorInterface);
#else //GatewayTests
                return Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.authsg);
#endif
            }
        }

        #region NPDB

        /// <summary>
        /// Executes SQL against NPDB.
        /// </summary>
        /// <param name="sql">The SQL to execute.</param>
        public static void ExecuteSQL (string sql)
        {
            //Global.RO.Debug("ExecuteSQL:\n{0}", sql);
            StaticNpdb.ExecuteScalar(sql);
        }

        /// <summary>
        /// Executes SQL against NPDB.
        /// </summary>
        /// <param name="sql">The SQL to execute.</param>
        /// <returns>The first column of the first row returned.</returns>
        public static string ExecuteScalarSQL (string sql)
        {
            string ans = null;

            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            try
            {
                SqlDataReader reader;
                npdb.ReadData(sql, out reader);

                try
                {
                    if (reader.Read())
                    {
                        ans = reader.GetString(0);
                    }
                }
                finally
                {
                    reader.Close();
                }
            }
            finally
            {
                npdb.Close();
            }

            return ans;
        }

        #endregion
    }

    /// <summary>
    /// A utility class for Anti-DOS settings.
    /// </summary>
    public static class AntiDosSettingUtils
    {
        public const string TrackingThresholdSettingName = "aamodule_antidosTrackingThreshold";
        public const string ThrottlingThresholdSettingName = "aamodule_antidosThrottlingThreshold";
        public const string BlockingThresholdSettingName = "aamodule_antidosBlockingThreshold";
        public const string MaxRecordsToTrackSettingName = "aamodule_antidosMaxRecordsToTrack";
        public const string BanTimeInSecondsSettingName = "aamodule_antidosBanTimeInSeconds";
        public const string IpOverridesSettingName = "aamodule_antidosIpOverrides";

        private static string _Initial_TrackingThreshold;
        private static string _Initial_ThrottlingThreshold;
        private static string _Initial_BlockingThreshold;
        private static string _Initial_MaxRecordsToTrack;
        private static string _Initial_BanTimeInSeconds;
        private static string[] _Initial_IpOverrides;

        private static string _Current_TrackingThreshold;
        private static string _Current_ThrottlingThreshold;
        private static string _Current_BlockingThreshold;
        private static string _Current_MaxRecordsToTrack;
        private static string _Current_BanTimeInSeconds;

        public static string CurrentTrackingThreshold { get { return _Current_TrackingThreshold; } }
        public static string CurrentThrottlingThreshold { get { return _Current_ThrottlingThreshold; } }
        public static string CurrentBlockingThreshold { get { return _Current_BlockingThreshold; } }
        public static string CurrentMaxRecordsToTrack { get { return _Current_MaxRecordsToTrack; } }
        public static string CurrentBanTimeInSeconds { get { return _Current_BanTimeInSeconds; } }

        /// <summary>
        /// Saves the current setting state from the DB, should be used for group init so that 
        /// we may revert our changes.
        /// 
        /// Does not take into account setting overrides, they will pretty much invalidate the tests.
        /// </summary>
        public static void SaveInitial()
        {
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            SqlCommand comm = npdb.CreateCommand();

            comm.CommandType = System.Data.CommandType.Text;
            comm.CommandText=String.Format(@"
Select vc_setting, vc_value from t_settings
where vc_setting in ('{0}', '{1}', '{2}', '{3}', '{4}')

Select count(*) from t_multisettings where vc_multisetting = '{5}'

Select vc_value from t_multisettings where vc_multisetting = '{5}'
", TrackingThresholdSettingName, ThrottlingThresholdSettingName, BlockingThresholdSettingName,
MaxRecordsToTrackSettingName, BanTimeInSecondsSettingName, IpOverridesSettingName);

            try
            {
                SqlDataReader reader;
                npdb.ReadData(comm, out reader);

                try
                {
                    while (reader.Read())
                    {
                        switch (reader.GetString(0))
                        {
                            case TrackingThresholdSettingName:
                                _Initial_TrackingThreshold = _Current_TrackingThreshold = reader.GetString(1);
                                break;

                            case ThrottlingThresholdSettingName:
                                _Initial_ThrottlingThreshold = _Current_ThrottlingThreshold = reader.GetString(1);
                                break;

                            case BlockingThresholdSettingName:
                                _Initial_BlockingThreshold = _Current_BlockingThreshold = reader.GetString(1);
                                break;

                            case MaxRecordsToTrackSettingName:
                                _Initial_MaxRecordsToTrack = _Current_MaxRecordsToTrack = reader.GetString(1);
                                break;

                            case BanTimeInSecondsSettingName:
                                _Initial_BanTimeInSeconds = _Current_BanTimeInSeconds = reader.GetString(1);
                                break;

                            default:
                                throw new UnexpectedTestResultException("This should not ever happen.");
                        }
                    }

                    // move to number of IP overrides
                    reader.NextResult();

                    reader.Read();
                    _Initial_IpOverrides = new string[reader.GetInt32(0)];

                    // move to IP override values
                    reader.NextResult();

                    for (int i = 0; i < _Initial_IpOverrides.Length; ++i)
                    {
                        reader.Read();
                        _Initial_IpOverrides[i] = reader.GetString(0);
                    }
                }
                finally
                {
                    reader.Close();
                }
            }
            finally
            {
                npdb.Close();
            }
        }

        /// <summary>
        /// Applies the initial settings.
        /// </summary>
        public static void RevertToInitial ()
        {
            ApplySettings(_Initial_TrackingThreshold, _Initial_ThrottlingThreshold, _Initial_BlockingThreshold,
                _Initial_MaxRecordsToTrack, _Initial_BanTimeInSeconds, true, _Initial_IpOverrides);
        }

        /// <summary>
        /// Applies the settings in a random order to increase the chances that the order will cause a failure.
        /// </summary>
        public static void ApplySettings (string TrackingThreshold, string ThrottlingThreshold,
            string BlockingThreshold, string MaxRecordsToTrack, string BanTimeInSeconds, bool ClearIpOverrides,
            string[] IpOverrides)
        {
            uint[] order = Permute(6);
            string sql = "";

            if (TrackingThreshold == null) { TrackingThreshold = _Initial_TrackingThreshold; }
            if (ThrottlingThreshold == null) { ThrottlingThreshold = _Initial_ThrottlingThreshold; }
            if (BlockingThreshold == null) { BlockingThreshold = _Initial_BlockingThreshold; }
            if (MaxRecordsToTrack == null) { MaxRecordsToTrack = _Initial_MaxRecordsToTrack; }
            if (BanTimeInSeconds == null) { BanTimeInSeconds = _Initial_BanTimeInSeconds; }

            foreach (uint i in order)
            {
                switch (i)
                {
                    case 0:
                        if (TrackingThreshold != null && TrackingThreshold != _Current_TrackingThreshold)
                        {
                            sql += "Update t_settings set vc_value = '" + TrackingThreshold.Replace("'", "''") +
                                "' where vc_setting = '" + TrackingThresholdSettingName + "'\n";
                            _Current_TrackingThreshold = TrackingThreshold;
                        }
                        break;

                    case 1:
                        if (ThrottlingThreshold != null && ThrottlingThreshold != _Current_ThrottlingThreshold)
                        {
                            sql += "Update t_settings set vc_value = '" + ThrottlingThreshold.Replace("'", "''") +
                                "' where vc_setting = '" + ThrottlingThresholdSettingName + "'\n";
                            _Current_ThrottlingThreshold = ThrottlingThreshold;
                        }
                        break;

                    case 2:
                        if (BlockingThreshold != null && BlockingThreshold != _Current_BlockingThreshold)
                        {
                            sql += "Update t_settings set vc_value = '" + BlockingThreshold.Replace("'", "''") +
                                "' where vc_setting = '" + BlockingThresholdSettingName + "'\n";
                            _Current_BlockingThreshold = BlockingThreshold;
                        }
                        break;

                    case 3:
                        if (MaxRecordsToTrack != null && MaxRecordsToTrack != _Current_MaxRecordsToTrack)
                        {
                            sql += "Update t_settings set vc_value = '" + MaxRecordsToTrack.Replace("'", "''") +
                                "' where vc_setting = '" + MaxRecordsToTrackSettingName + "'\n";
                            _Current_MaxRecordsToTrack = MaxRecordsToTrack;
                        }
                        break;

                    case 4:
                        if (BanTimeInSeconds != null && BanTimeInSeconds != _Current_BanTimeInSeconds)
                        {
                            sql += "Update t_settings set vc_value = '" + BanTimeInSeconds.Replace("'", "''") +
                                "' where vc_setting = '" + BanTimeInSecondsSettingName + "'\n";
                            _Current_BanTimeInSeconds = BanTimeInSeconds;
                        }
                        break;

                    case 5:
                        if (ClearIpOverrides)
                        {
                            sql += "Delete from t_multisettings where vc_multisetting = '" +
                                IpOverridesSettingName + "'\n";
                        }

                        if (IpOverrides != null)
                        {
                            foreach (string ipor in IpOverrides)
                            {
                                sql += "Insert into t_multisettings (vc_multisetting, vc_value) values ('" +
                                    IpOverridesSettingName + "', '" + ipor.Replace("'", "''") + "')\n";
                            }
                        }
                        break;
                }
            }

            Global.RO.Debug("Setting update SQL:\n" + sql);

            SharedSetup.ExecuteSQL(sql);
        }

        /// <summary>
        /// Permutes the numbers 0 to num - 1.
        /// </summary>
        /// <param name="num">The number of items to permute.</param>
        /// <returns>The computed permutation.</returns>
        public static uint[] Permute (uint num)
        {
            uint[] arr = new uint[num];
            for (uint i = 0; i < num; ++i) { arr[i] = i; }
            Permute(arr, arr);
            return arr;
        }

        /// <summary>
        /// Permutes the given items, placing them into the permuted array.
        /// </summary>
        /// <param name="items">The items to permute.</param>
        /// <param name="permuted">The resulting permuted items.</param>
        public static void Permute (uint[] items, uint[] permuted)
        {
            if (items == null) { throw new ArgumentNullException("items"); }
            if (permuted == null) { throw new ArgumentNullException("permuted"); }

            if (items.Length != permuted.Length)
            {
                throw new ArgumentException("items and permuted must be the same length");
            }

            // copy items over, if needed
            if (items != permuted)
            {
                for (int i = 0; i < items.Length; ++i)
                {
                    permuted[i] = items[i];
                }
            }

            Random rand = new Random();

            for (int i = 0; i < items.Length - 1; ++i)
            {
                int num = i + rand.Next(items.Length - i);

                uint temp = permuted[i];
                permuted[i] = permuted[num];
                permuted[num] = temp;
            }
        }
    }
    // -- fuzzing helpers
    public class FuzzHelpers
    {
        //handles fuzzing the http request at the last minute
        public static void DataSendHandler(byte []inBytes, out byte []outBytes)
        {
            //copy the bytes first
            outBytes=(byte[])inBytes.Clone();

            //play with them
            int fuzzCount=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(3);
            if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<10) fuzzCount+=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(256);

            int fuzzChance=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100);

            if (fuzzChance<40) //40% chance to fuzz bytes
            {
                for (int i=0; i<fuzzCount; ++i)
                {
                    if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<75) // 75% of the time choose an typeable character, to improve our chances against xrlscan
                        outBytes[ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(outBytes.Length)]=(byte)((byte)32+(byte)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(96));
                    else
                        outBytes[ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(outBytes.Length)]=(byte)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(256);
                }
            }
            else if (fuzzChance<80) //40% chance to fuzz bits
            {
                for (int i=0; i<fuzzCount; ++i)
                {
                    outBytes[ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(outBytes.Length)]^=(byte)(1<<ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(8));
                }
            }
        }

        //handles fuzzing http headers
        public static void BuildHeaderHandler(HttpClient.Request inReq, out HttpClient.Request outReq)
        {
            //copy the request first
            outReq=inReq.ShallowCloneWithDeepHeaders();

            //consolidate all standard headers into the generic header list first
            if (outReq.Host!=null)
            {
                outReq.OtherHeaders.AddFirst("Host: "+outReq.Host);
                outReq.Host=null;
            }
            if (outReq.UserAgent!=null)
            {
                outReq.OtherHeaders.AddFirst("User-Agent: "+outReq.UserAgent);
                outReq.UserAgent=null;
            }
            if (outReq.ContentLength!=null)
            {
                //fuzz content length value while we're at it
                string clString=outReq.ContentLength;
                if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<10) //10% chance
                {
                    if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<30) //30% chance of just nudging a little
                        clString=(int.Parse(clString)+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(200)-100).ToString();
                    else //70% change totally random number
                    {
                        if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<50) //50% gigantic
                            unchecked{clString=((long)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong()).ToString();}
                        else //50% chance sane
                            unchecked{clString=(((long)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong()%80000)-40000).ToString();}
                    }
                }
                outReq.OtherHeaders.AddFirst("Content-Length: "+clString);
                outReq.ContentLength=null;
            }
            if (outReq.Method!=null || outReq.URI!=null || outReq.Version!=null)
            {
                string mainHeader="";
                if (outReq.Method!=null) mainHeader+=outReq.Method + " ";
                if (outReq.URI!=null) mainHeader+=outReq.URI + " ";
                if (outReq.Version!=null) mainHeader+=outReq.Version;
                outReq.OtherHeaders.AddFirst(mainHeader);

                outReq.Method=null;
                outReq.URI=null;
                outReq.Version=null;
            }

            //mess with it
            if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<30) //30% we'll add a random extra header
            {
                outReq.OtherHeaders.AddLast(ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(0,32)+": "+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(0,64));
            }
            if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<40) //40% we'll rearrange some headers
            {
                int numRearrange=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(3)+1;
                for (int i=0; i<numRearrange; ++i)
                {
                    //pick a header at random, remove it, then add it back to the end
                    int headNum=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(outReq.OtherHeaders.Count);
                    LinkedListNode<string> node=outReq.OtherHeaders.First;
                    for (int h=0; h<headNum; ++h)
                    {
                        node=node.Next;
                    }

                    outReq.OtherHeaders.Remove(node);
                    outReq.OtherHeaders.AddLast(node.Value);
                }
            }
            if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<20) //20% change to duplicate some headers
            {
                int numRearrange=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(2)+1;
                for (int i=0; i<numRearrange; ++i)
                {
                    //pick a header at random, remove it, then add it back to the end
                    int headNum=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(outReq.OtherHeaders.Count);
                    LinkedListNode<string> node=outReq.OtherHeaders.First;
                    for (int h=0; h<headNum; ++h)
                    {
                        node=node.Next;
                    }

                    outReq.OtherHeaders.AddLast(node.Value);
                }
            }
            if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<20) //20% change to removes some headers
            {
                int numRearrange=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(2)+1;
                for (int i=0; i<numRearrange; ++i)
                {
                    //pick a header at random, remove it, then add it back to the end
                    int headNum=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(outReq.OtherHeaders.Count);
                    LinkedListNode<string> node=outReq.OtherHeaders.First;
                    for (int h=0; h<headNum; ++h)
                    {
                        node=node.Next;
                    }

                    outReq.OtherHeaders.Remove(node);
                }
            }
        }
    }

    /// <summary>
    /// Fuzz control gui.
    /// </summary>
    public class AASettingsGui : STFGui.Plugins.IPluginGui
    {
        public System.Windows.Forms.MenuItem GetNewMenu()
        {
            System.Windows.Forms.MenuItem baseMenu=new System.Windows.Forms.MenuItem("ActiveAuth");

            //do not fuzz by default
            System.Windows.Forms.MenuItem miFuzz=new System.Windows.Forms.MenuItem("Fuzz outgoing http requests", MenuChoice_FuzzHttp);
            miFuzz.Checked=false;
            baseMenu.MenuItems.Add(miFuzz);

            return baseMenu;
        }

        private void MenuChoice_FuzzHttp(object sender, EventArgs args)
        {
            System.Windows.Forms.MenuItem mi=(System.Windows.Forms.MenuItem)sender;
            mi.Checked=!mi.Checked;
            Global.RO.Info("Setting FuzzHttp="+mi.Checked);

            if (mi.Checked)
            {
                HttpClient.DataSendEvent+=FuzzHelpers.DataSendHandler;
                HttpClient.Request.BuildHeaderEvent+=FuzzHelpers.BuildHeaderHandler;
            }
            else
            {
                HttpClient.DataSendEvent-=FuzzHelpers.DataSendHandler;
                HttpClient.Request.BuildHeaderEvent-=FuzzHelpers.BuildHeaderHandler;
            }
        }

        #region IPluginGui Members

        public STFGui.Plugins.MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public System.Windows.Forms.TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\common\SharedSSLTests.cs ===
//These tests are shared by both the gateway test suite and the module test suite.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using xonline.common.protocol;

namespace PirateSGTest
{
#if GatewayTests
    [TestGroup, Owner("johnmcp"), EnvRequirement("TestFD"), TestCasePriority(1)]
#else
    [TestGroup, Owner("LukeL"), EnvRequirement("AAPirateSGCertificates"), TestCasePriority(2)]
#endif
    [CompoundCase("GET (HTTPS)", "GET", "https")]
    [CompoundCase("POST (HTTPS)", "POST", "https")]
    [CompoundCase("GET (LB)", "GET", "headers")]
    [CompoundCase("POST (LB)", "POST", "headers")]
    public class SharedSSLTests: TestNode
    {
        public const string SslPath = "/testfd/Reflect/authsg/ssl/ssl";
        public const string NoSslPath = "/testfd/Reflect/authsg/ssl/nossl";
        public const string SslCertPath = "/testfd/Reflect/authsg/ssl/sslcert";

        public const string TestFDQueryString = "?caller=authsg";

        public static Boolean AllGood(Object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            // Always accept the server certificate
            return true;
        }

        public override void PreRun ()
        {
            //configure URIs to use
            SharedSetup.ConfigureUri(SslPath, false, true);
            SharedSetup.ConfigureUri(NoSslPath, false);
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry { 
                Path = SslCertPath, RequiresClientCert = true, SSLRequired = true,
                AuthRequired=true, AuthPolicy="MBI", AuthHeader="WLID1.0"
            });

            SharedSetup.Reload();

            // Always ignore the server cert, what do we care for functional/regression tests?
            // Also, lets us use the virtual interface rather than a set of names in this DLL.
            ServicePointManager.ServerCertificateValidationCallback += AllGood;
        }

        public override void PostRun ()
        {
            // its safe to always remove, does nothing if its not there
            ServicePointManager.ServerCertificateValidationCallback -= AllGood;
        }

        // -- tests

        [TestCase, Description("Make a request that requires ssl, without using ssl")]
        public class NotUsingSSL_SSLRequired: TestNode
        {
            public override void Run()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SslPath);
                if ((string)Parent.MyValues[0]=="POST") SharedAAInfoTests.AddPostDataToRequest(req);

                http.SendRequest(req);
                ResponseVerification.CheckResponse(http.GetResponse(),403);
            }
        }

        //We gotta use .NET's clunky thing for this...
        [TestCase, Description("Make a request that requires ssl, using ssl")]
        [CompoundCase("SSLNotRequired",false)]
        [CompoundCase("SSLRequired",true)]
        public class UsingSSL: TestNode
        {
            public override void Run()
            {
                for (int i = 1; i <= 10; i++)
                {
                    Global.RO.Debug("Making request {0}of 10...", i);
                    bool sslRequired = (bool)MyValues[0];

                    String method = (string)Parent.Parent.MyValues[0];
                    Boolean useHttps = (string)Parent.Parent.MyValues[1] == "https";

                    UriBuilder requestUri = new UriBuilder();
                    requestUri.Scheme = useHttps ? "https" : "http";
                    requestUri.Host = SharedSetup.SSLHost;
                    requestUri.Port = useHttps ? SharedSetup.SSLPort :
                        Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.authsg).Port;
                    requestUri.Path = sslRequired ? SslPath : NoSslPath;

                    Global.RO.Debug("Request string: " + requestUri.ToString());
                    HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestUri.Uri);
                    netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                    netreq.UserAgent = "STFLive.NET/0.1";

                    if (!useHttps)
                    {
                        netreq.Headers.Add("X-LB-Is-Ssl", "true");
                    }

                    if (method == "POST")
                    {
                        netreq.Method = "POST";
                        netreq.ContentType = "text/xml";

                        TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                        tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                        tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                        byte[] postData = tfd_req.ToArray();
                        netreq.ContentLength = postData.Length;
                        netreq.GetRequestStream().Write(postData, 0, postData.Length);
                    }

                    //try the request
                    WebResponse netresp = netreq.GetResponse();

                    //validate (if we get here it was 200)
                    //TODO: Do multiple reads and check returns to handle arbitrary sized responses

                    byte[] rawRespData = new byte[256 * 1024];
                    int bytesRet = netresp.GetResponseStream().Read(rawRespData, 0, rawRespData.Length);
                    byte[] respData = new byte[bytesRet];
                    System.Buffer.BlockCopy(rawRespData, 0, respData, 0, bytesRet);

                    TestFdReflectorResponse tfd_rep = new TestFdReflectorResponse();
                    if (tfd_rep.ReadBytes(respData) == null)
                    {
                        throw new UnexpectedTestResultException("Response was not from the reflector.");
                    }
                }
            }
        }

        /// <summary>
        /// A test base that sets up the use of a client certificate that has been specified.
        /// </summary>
        public class ClientCertSSLUtil
        {
            public static void AddCertChainToStore (X509Certificate2Collection chain)
            {
                X509Store store = new X509Store(StoreName.CertificateAuthority, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadWrite);
                store.AddRange(chain);
                store.Close();
            }

            public static void RemoveCertChainFromStore (X509Certificate2Collection chain)
            {
                X509Store store = new X509Store(StoreName.CertificateAuthority, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadWrite);
                store.RemoveRange(chain);
                store.Close();
            }

            public static void SetupSSLConnection (X509Certificate2 cert)
            {
                // Use this bit of .Net specific trickery to enable our use of whatever client certificate we want in
                // HttpWebRequest.  See this documentation on SslStream http://msdn.microsoft.com/en-us/library/ms145057.aspx
                // The Note down below mentions this "technique" of caching an SSL state
                TcpClient tcp = new TcpClient(SharedSetup.SSLHost, SharedSetup.SSLPort);
                SslStream ssl = new SslStream(tcp.GetStream(), false, AllGood, (new MyCertPicker(cert)).PickMyCert);
                ssl.AuthenticateAsClient(SharedSetup.SSLHost, new X509CertificateCollection(new X509Certificate[] { cert }),
                    System.Security.Authentication.SslProtocols.Default, false);

                // create a request that we don't care about
                HttpClient.Request req = new HttpClient.Request(SharedSetup.SSLHost + ":" + SharedSetup.SSLPort, SslCertPath);

                ssl.Write(req.ToBytes());
                ssl.Flush();
                // this read is necessary to force the client certificate
                ssl.Read(new byte[1], 0, 1);
                ssl.Close();
            }

            private class MyCertPicker
            {
                private X509Certificate2 Certificate = null;

                public MyCertPicker (X509Certificate2 cert)
                {
                    Certificate = cert;
                }

                public X509Certificate PickMyCert (object sender, string targetHost, X509CertificateCollection localCertificates,
                    X509Certificate remoteCertificate, string[] acceptableIssuers)
                {
                    return Certificate;
                }
            }

            public static string GetCertDeviceId (X509Certificate2 cert)
            {
                // extract device id from subject
                string subject = cert.Subject;
                string subjectToken = xonline.common.config.Config.GetSetting(xonline.common.config.Setting.aamodule_sts_deviceId_cert_subject_prefix);
                string deviceId = null;

                int index = subject.IndexOf(subjectToken);

                if (index == -1)
                {
                    deviceId = cert.Thumbprint;
                }
                else
                {
                    int end = subject.IndexOf(',', index);
                    end = (end == -1 ? subject.Length : end);
                    if (subject[end - 1] == '"') { --end; }
                    deviceId = subject.Substring(index + subjectToken.Length, end - (index + subjectToken.Length));
                }

                return deviceId;
            }

            public static string XCN_OID_ENHANCED_KEY_USAGE = "2.5.29.37";

            public static string GetEkuList (X509Certificate2 cert)
            {
                foreach (X509Extension ext in cert.Extensions)
                {
                    if (XCN_OID_ENHANCED_KEY_USAGE == ext.Oid.Value)
                    {
                        X509EnhancedKeyUsageExtension ekuExt = (X509EnhancedKeyUsageExtension)ext;

                        return string.Join(",", 
                            ekuExt.EnhancedKeyUsages.OfType<System.Security.Cryptography.Oid>().Select(o => o.Value).ToArray());
                    }
                }

                return null;
            }
        }

#if GatewayTests
        [TestCase, Description("Make a request against a URL that requires client certificates.")]
        [CompoundCase("None", null, null, 403)]
        [CompoundCase("Not in CTL", "StsFDTest_NonCTLEKU.pfx", null, 403)]
        [CompoundCase("No EKU", "StsFDTest_NoEKU.pfx", null, 403)]
        [CompoundCase("Child EKU", "StsFDTest_ChildEKU.pfx", null, 403)]
        [CompoundCase("Multi EKU", "StsFDTest_MultiEKU.pfx", null, 200)]
        [CompoundCase("Retail EKU", "StsFDTest_RetEKU.pfx", null, "1.3.6.1.4.1.311.71.1.2")]
        [CompoundCase("Test EKU", "StsFDTest_TestEKU.pfx", null, "1.3.6.1.4.1.311.71.1.1")]
        [CompoundCase("Dev EKU", "StsFDTest_DevEKU.pfx", null, 403)]
        [CompoundCase("Bad Subject", "StsFDTest_BadSubject.pfx", null, 200)]
        // When the Test EKU is not enabled, this will get a 403, but the major point is to test that a real cert works through the CTL, etc
        [CompoundCase("WM7 Official", "WM7Official.pfx", "udc", "1.3.6.1.4.1.311.71.1.1")]
        public class ClientCertificate : TestNode
        {
            private X509Certificate2 Certificate = null;
            private X509Certificate2Collection CertificateChain = null;
            private bool UseHttps = true;

            public override void PreRun (RUN_TYPE runType)
            {
                string certName = (string)MyValues[0];
                string certPass = (string)MyValues[1];

                if (certName != null)
                {
                    Assembly asm = Assembly.GetExecutingAssembly();
                    Stream certStream = asm.GetManifestResourceStream(@"certs." + certName);
                    BinaryReader certReader = new BinaryReader(certStream);
                    byte[] certBytes = certReader.ReadBytes((int)(certStream.Length));
                    if (certPass == null)
                    {
                        Certificate = new X509Certificate2(certBytes);
                    }
                    else
                    {
                        Certificate = new X509Certificate2(certBytes, certPass);
                    }

                    // check for chain to add to cert
                    string certNameP7b = "certs." + certName.Substring(0, certName.Length - 4) + ".p7b";
                    System.IO.Stream p7bStream = null;
                    try
                    {
                        p7bStream = asm.GetManifestResourceStream(certNameP7b);
                    }
                    catch (System.IO.FileNotFoundException)
                    {
                    }

                    if (p7bStream != null)
                    {
                        System.IO.BinaryReader p7bReader = new System.IO.BinaryReader(p7bStream);
                        byte[] p7bBytes = p7bReader.ReadBytes((int)(p7bStream.Length));
                        X509Certificate2Collection p7b = Certificates.OpenPKCS7(p7bBytes);

                        // add the chain to the local store
                        ClientCertSSLUtil.AddCertChainToStore(p7b);

                        CertificateChain = p7b;
                    }

                    // check for using SSL
                    UseHttps = (string)Parent.Parent.MyValues[1] == "https";

                    if (UseHttps)
                    {
                        ClientCertSSLUtil.SetupSSLConnection(Certificate);
                    }
                }
            }

            public override void PostRun ()
            {
                Certificate = null;

                if (CertificateChain != null)
                {
                    // remove the chain from the local store
                    ClientCertSSLUtil.RemoveCertChainFromStore(CertificateChain);

                    CertificateChain = null;
                }
            }

            public override void Run()
            {
                string method = (string)Parent.Parent.MyValues[0];
                object expectObject = MyValues[2];
                int expectVal = 403;

                // for special expect, we need to check the environment
                string certEku = expectObject as string;
                if (certEku != null)
                {
                    string[] allowedEkus = xonline.common.config.Config.GetMultiSetting(xonline.common.config.MultiSetting.aamodule_XblEnhancedKeyUsages);

                    foreach (string eku in allowedEkus)
                    {
                        if (eku == certEku)
                        {
                            expectVal = 200;
                            break;
                        }
                    }

                    if (expectVal == 403)
                    {
                        Global.RO.Warn("Specified EKU is not enabled, test expects failure (403): " + certEku);
                    }
                }
                else
                {
                    expectVal = (int)expectObject;
                }

                UriBuilder requestUri = new UriBuilder();
                requestUri.Scheme = UseHttps ? "https" : "http";
                requestUri.Host = SharedSetup.SSLHost;
                requestUri.Port = UseHttps ? SharedSetup.SSLPort :
                    Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.authsg).Port;
                requestUri.Path = SslCertPath;
                if (method == "GET")
                {
                    requestUri.Query = TestFDQueryString.TrimStart('?');
                }

                Global.RO.Debug("Request string: " + requestUri.ToString());
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestUri.Uri);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                netreq.Headers.Add("Authorization: WLID1.0 t=" + SharedAAInfoTests.NonXblPassportTicket);

                if (Certificate != null)
                {
                    if (UseHttps)
                    {
                        netreq.ClientCertificates.Add(Certificate);
                    }
                    else
                    {
                        netreq.Headers.Add("X-LB-Cert-Subject-Name", Certificate.Subject);
                        netreq.Headers.Add("X-LB-Cert-Thumbprint", Certificate.Thumbprint);
                        netreq.Headers.Add("X-LB-Cert-EKU-List", ClientCertSSLUtil.GetEkuList(Certificate));
                    }
                }

                if (!UseHttps)
                {
                    netreq.Headers.Add("X-LB-Is-Ssl", "true");
                }

                if (method == "POST")
                {
                    netreq.Method = "POST";
                    netreq.ContentType = "text/xml";

                    TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                    tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                    tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                    byte[] postData = tfd_req.ToArray();
                    netreq.ContentLength = postData.Length;
                    netreq.GetRequestStream().Write(postData, 0, postData.Length);
                }

                //try the request
                WebResponse netresp = null;
                try
                {
                    netresp = netreq.GetResponse();
                }
                catch (WebException we)
                {
                    int status = (int)(((HttpWebResponse)we.Response).StatusCode);

                    if (status != expectVal || expectVal == 200)
                    {
                        throw;
                    }

                    Global.RO.Success("Recieved expected web exception.");
                    return;
                }

                if (expectVal != 200)
                {
                    throw new UnexpectedTestResultException("Expected HTTP " + expectVal + " via exception");
                }

                //validate (if we get here it was 200)
                //TODO: Do multiple reads and check returns to handle arbitrary sized responses

                byte[] rawRespData = new byte[256 * 1024];
                int bytesRet = netresp.GetResponseStream().Read(rawRespData, 0, 256 * 1024);
                byte[] respData = new byte[bytesRet];
                System.Buffer.BlockCopy(rawRespData, 0, respData, 0, bytesRet);

                TestFdReflectorResponse tfd_rep = new TestFdReflectorResponse();
                if (tfd_rep.ReadBytes(respData) == null)
                {
                    throw new UnexpectedTestResultException("Response was not from the reflector.");
                }

                // verify that the thumbprint is correct
                Dictionary<string, string> caller_spec = tfd_rep.CallerSpecific.Dict;
                if (!caller_spec.ContainsKey("CertDeviceId"))
                {
                    throw new UnexpectedTestResultException("Response did not contain the certificate device id.");
                }

                // extract device id from subject
                string deviceId = ClientCertSSLUtil.GetCertDeviceId(Certificate);

                if (caller_spec["CertDeviceId"] != deviceId)
                {
                    throw new UnexpectedTestResultException(
                        String.Format("Response device id [{0}] did not match our certificate[{1}].",
                            caller_spec["CertDeviceId"], deviceId));
                }
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleDVT\IpRangeListTests.cs ===
using System;
using System.Net;
using System.Web;
using System.Web.Hosting;
using System.IO;
using System.Collections.Generic;

using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;
using xonline.common.utilities2;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace ModuleDVT
{

class TestIpRecord : IIpRangeUserRecord
{
    public TestIpRecord()
    {
        _Threshold = 0;
    }

    public void SetParam(string paramName, string paramValue)
    {
        Global.RO.Debug("TestIpRecord.SetValue({0}, {1}) called",
                       paramName, paramValue);
        if (String.Compare(paramName, "threshold", true) == 0)
        {
            _Threshold = int.Parse(paramValue);
        }
    }

    public override string ToString()
    {
        return String.Format("({0})", _Threshold);
    }

    public int _Threshold;
}


[TestGroup, DVT, Owner("dvt"), TestFrequency("Regression")]
public class IpRangeListTests : ModuleDVTTestBaseGroup
{
    private static readonly string[] defaultSettings = new string[] {
        "ip=1.1.1.1",
        "ip=2.1.1.1;ipEnd=2.1.1.100",
        "ip=3.1.1.1;threshold=3",
        "ip=4.1.1.1;ipEnd=4.1.1.100;threshold=4"
    };
    
    private static readonly string[] defaultTypoSettings = new string[] {
        "ip=5.1.1.1;threshold2=6",
        "ip=1.1.1.1;",
        "ipEnd=2.1.1.100;ip=2.1.1.1",
        "threshold=2;ip=3.1.1.1;threshold = 4;",
        "threshold=5;ipEnd=4.1.1.100;ip=4.1.1.1"
    };
        
    IpRangeList<TestIpRecord> range;
   
    private void Populate(string[] settings)
    {
        range = new IpRangeList<TestIpRecord>(settings);
    }

    private void PopulateNegative(string[] settings)
    {
        try
        {
            range = new IpRangeList<TestIpRecord>(settings);
        }
        catch (Exception e)
        {
            Global.RO.Debug("Got exception (expected): {0}", e.Message);
            return;
        }
        throw new Exception("Expected exception when creating IpRangeList, but it succeeded");
    }

    private void VerifyRecord(string ip, int threshold)
    {
        VerifyRecord(ip, ip, threshold);
    }

    private void VerifyRecord(string ip, string ipMapped, int threshold)
    {
        IPAddress ipIn = IPAddress.Parse(ip);
        IPAddress ipMappedIn = IPAddress.Parse(ipMapped);
        IPAddress ipMappedOut;
        TestIpRecord record;
        Assert.IsTrue(range.Lookup(ipIn, out ipMappedOut, out record), "Lookup " + ip);
        Assert.IsTrue(ipMappedIn.Equals(ipMappedOut), "ipMapped " + ipMappedIn.ToString() + " != " + ipMappedOut.ToString());
        Assert.IsTrue(threshold == record._Threshold, "threshold " + threshold.ToString() + " != " + record._Threshold.ToString());
    }

    private void VerifyRecordNegative(string ip)
    {
        IPAddress ipIn = IPAddress.Parse(ip);
        IPAddress ipMappedOut;
        TestIpRecord record;
        Assert.IsTrue(!range.Lookup(ipIn, out ipMappedOut, out record), "Lookup " + ip);
    }

    private void Dump(string header, IpRangeList<TestIpRecord> range)
    {
        Global.RO.Debug(header + "\n" + range.ToString());
    }


    [TestCase]
    public void VerifyDefaultSettingsParsing()
    {
        Populate(defaultSettings);
       
        VerifyRecord("1.1.1.1", "1.1.1.1", 0);
        VerifyRecord("2.1.1.1", "2.1.1.1", 0);
        VerifyRecord("3.1.1.1", "3.1.1.1", 3);
        VerifyRecord("4.1.1.1", "4.1.1.1", 4);
        VerifyRecordNegative("5.1.1.1");
    }

    [TestCase]
    public void VerifyDefaultTypoSettingsParsing()
    {
        Populate(defaultTypoSettings);
       
        VerifyRecord("1.1.1.1", "1.1.1.1", 0);
        VerifyRecord("2.1.1.1", "2.1.1.1", 0);
        VerifyRecord("3.1.1.1", "3.1.1.1", 4);
        VerifyRecord("4.1.1.1", "4.1.1.1", 5);
        VerifyRecord("5.1.1.1", "5.1.1.1", 0);
    }

    [TestCase]
    public void VerifyReload()
    {
        Populate(defaultSettings);
        VerifyRecord("1.1.1.1", "1.1.1.1", 0);
        VerifyRecord("2.1.1.1", "2.1.1.1", 0);
        VerifyRecord("3.1.1.1", "3.1.1.1", 3);
        VerifyRecord("4.1.1.1", "4.1.1.1", 4);
        VerifyRecordNegative("5.1.1.1");

        range.Reload(defaultTypoSettings);
        VerifyRecord("1.1.1.1", "1.1.1.1", 0);
        VerifyRecord("2.1.1.1", "2.1.1.1", 0);
        VerifyRecord("3.1.1.1", "3.1.1.1", 4);
        VerifyRecord("4.1.1.1", "4.1.1.1", 5);
        VerifyRecord("5.1.1.1", "5.1.1.1", 0);
  
        range.Reload(defaultSettings);
        VerifyRecord("1.1.1.1", "1.1.1.1", 0);
        VerifyRecord("2.1.1.1", "2.1.1.1", 0);
        VerifyRecord("3.1.1.1", "3.1.1.1", 3);
        VerifyRecord("4.1.1.1", "4.1.1.1", 4);
        VerifyRecordNegative("5.1.1.1");
    }

    [TestCase]
    public void VerifyRanges()
    {
        Populate(defaultSettings);
       
        VerifyRecord("2.1.1.1",   "2.1.1.1", 0);
        VerifyRecord("2.1.1.2",   "2.1.1.1", 0);
        VerifyRecord("2.1.1.99",  "2.1.1.1", 0);
        VerifyRecord("2.1.1.100", "2.1.1.1", 0);

        VerifyRecord("4.1.1.1",   "4.1.1.1", 4);
        VerifyRecord("4.1.1.2",   "4.1.1.1", 4);
        VerifyRecord("4.1.1.99",  "4.1.1.1", 4);
        VerifyRecord("4.1.1.100", "4.1.1.1", 4);
        
        VerifyRecordNegative("2.1.1.0");
        VerifyRecordNegative("2.1.1.101");
        VerifyRecordNegative("4.1.1.0");
        VerifyRecordNegative("4.1.1.101");
        
        VerifyRecordNegative("1.1.1.0");
        VerifyRecordNegative("1.1.1.2");
        VerifyRecordNegative("3.1.1.0");
        VerifyRecordNegative("3.1.1.2");

    }

    [TestCase]
    public void VerifySorting_Singles()
    {
        string[] settings = new string[] {
            "ip=3.1.1.1;threshold=1",
            "ip=1.1.1.2;threshold=2",
            "ip=1.1.1.1;threshold=3",
            "ip=2.1.1.1;threshold=4",
            "ip=2.1.1.2;threshold=5",
            "ip=1.1.1.4;threshold=6"
        };

        Populate(settings);
        Dump("These should be sorted", range);

        VerifyRecord("3.1.1.1", 1);
        VerifyRecord("2.1.1.2", 5);
        VerifyRecord("2.1.1.1", 4);
        VerifyRecord("1.1.1.4", 6);
        VerifyRecord("1.1.1.2", 2);
        VerifyRecord("1.1.1.1", 3);

        VerifyRecordNegative("4.1.1.1");
        VerifyRecordNegative("1.1.1.3");
    }

    [TestCase]
    public void VerifySorting_Ranges()
    {
        string[] settings = new string[] {
            "ip=3.1.1.1;ipEnd=3.1.1.5;threshold=1",
            "ip=1.1.1.2;ipEnd=1.1.1.2;threshold=2",
            "ip=1.1.1.1;ipEnd=1.1.1.1;threshold=3",
            "ip=2.1.1.1;ipEnd=2.1.1.1;threshold=4",
            "ip=2.1.1.2;ipEnd=2.1.1.5;threshold=5",
            "ip=1.1.1.4;ipEnd=1.1.1.5;threshold=6"
        };

        Populate(settings);
        Dump("These should be sorted", range);

        VerifyRecord("3.1.1.1", 1);
        VerifyRecord("2.1.1.2", 5);
        VerifyRecord("2.1.1.1", 4);
        VerifyRecord("1.1.1.4", 6);
        VerifyRecord("1.1.1.2", 2);
        VerifyRecord("1.1.1.1", 3);
        
        VerifyRecord("3.1.1.5", "3.1.1.1", 1);
        VerifyRecord("2.1.1.5", "2.1.1.2", 5);
        VerifyRecord("1.1.1.5", "1.1.1.4", 6);

        VerifyRecordNegative("4.1.1.1");
        VerifyRecordNegative("3.1.1.6");
        VerifyRecordNegative("2.1.1.6");
        VerifyRecordNegative("1.1.1.6");
        VerifyRecordNegative("1.1.1.3");

    }

    [TestCase]
    public void VerifyOverlap_Negative()
    {
        string[] settings;
        
        settings = new string[] {
            "ip=1.1.1.1;threshold=1",
            "ip=1.1.1.1;threshold=2"
        };
        Global.RO.Info("  Duplicate ips");
        PopulateNegative(settings);
        
        settings = new string[] {
            "ip=1.1.1.15;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Duplicate ip inside range");
        PopulateNegative(settings);

        settings = new string[] {
            "ip=1.1.1.1;ipEnd=1.1.1.10;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Overlapping ranges low-low");
        PopulateNegative(settings);

        settings = new string[] {
            "ip=1.1.1.9;ipEnd=1.1.1.11;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Overlapping ranges low-mid");
        PopulateNegative(settings);

        settings = new string[] {
            "ip=1.1.1.10;ipEnd=1.1.1.19;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Overlapping ranges mid-low");
        PopulateNegative(settings);

        settings = new string[] {
            "ip=1.1.1.11;ipEnd=1.1.1.19;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Overlapping ranges mid-mid");
        PopulateNegative(settings);

        settings = new string[] {
            "ip=1.1.1.11;ipEnd=1.1.1.20;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Overlapping ranges mid-high");
        PopulateNegative(settings);

        settings = new string[] {
            "ip=1.1.1.19;ipEnd=1.1.1.21;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Overlapping ranges high-mid");
        PopulateNegative(settings);

        settings = new string[] {
            "ip=1.1.1.20;ipEnd=1.1.1.30;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.20;threshold=2"
        };
        Global.RO.Info("  Overlapping ranges high-high");
        PopulateNegative(settings);
        
        settings = new string[] {
            "ip=1.1.1.20;ipEnd=1.1.1.30;threshold=1",
            "ip=1.1.1.10;ipEnd=1.1.1.40;threshold=2"
        };
        Global.RO.Info("  Engulfing");
        PopulateNegative(settings);
    }



}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\common\SharedAAInfoTests.cs ===
//These tests are shared by both the gateway test suite and the module test suite.

using System;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

namespace PirateSGTest
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    [CompoundCase("GET", "GET")]
    [CompoundCase("POST", "POST")]
    public class SharedAAInfoTests : TestNode
    {
        //a valid passport user that's not a member of xbl
        public static readonly string NON_XBL_PASSPORT_NAME = "xbltest-non-user@hotmail-int.com";
        public static readonly string NON_XBL_PASSPORT_PW = "pyfgcrl";

        //URIs used by tests
#if !GatewayTests
        public const string SHARED_URI_SIMPLE="/AAIFDReflector/test/aainfo/simple";
        public const string SHARED_URI_AUTH="/AAIFDReflector/test/aainfo/auth";
#else
        public const string SHARED_URI_SIMPLE="/test/aainfo/simple";
        public const string SHARED_URI_AUTH="/test/aainfo/auth";
#endif

        #region Setup And Utils

        //adds an acceptable POST content and headers to a request
        public static void AddPostDataToRequest (HttpClient.Request req)
        {
            req.Method = "POST";
            req.SetContentLengthAndBody("Postin' a string.  Stringin' a web.  Webbin' a post.");
            req.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will be a @#$^% and block us without this
        }

        //
        [TestGroupSetup]
        public void GroupSetup ()
        {
            //configure URIs to use
            SharedSetup.ConfigureUri(SHARED_URI_SIMPLE, false);
            SharedSetup.ConfigureUri(SHARED_URI_AUTH, true);

            SharedSetup.Reload();
        }

        #endregion //Setup And Utils


        #region Verification Logic

        //Verifies that all the basics about a response are valid. (reflResponse is created from response if null)
        public static void VerifyResponseBasics (HttpClient.Request requestSent, HttpClient.Response response, AAReflectorResponse reflResponse)
        {
            //make reflResponse if needed
            if (response.Status == 200)
            {
                if (reflResponse == null) reflResponse = AAReflectorResponse.Create(response);
            }

            //check some http basics
            ResponseVerification.CheckResponse(response);

            //check that the reflection contained what we sent
            if (reflResponse != null && requestSent != null)
            {
                ResponseVerification.VerifyOriginalRequest(reflResponse, requestSent);
            }
        }

        //Verifies that the extra headers that the module tacks on are present and sane
        public static void VerifyExtraHeaders (AAReflectorResponse reflResponse)
        {
#if !GatewayTests
            bool gotSGIPPort = false;
            bool gotServerPort = false;
#endif

            //check the headers (existance and super simple sanity)
            foreach (string s in reflResponse.HttpRequest.OtherHeaders)
            {
                if (s.StartsWith("SGIPPort:"))
                {
#if !GatewayTests
                    gotSGIPPort = true;
#endif

                    string[] split = s.Split(new char[] { ':' });
                    if (split.Length != 3)
                    {
                        Global.RO.Fatal("" + split.Length);
                        throw new UnexpectedTestResultException("SGIPPort header not in the expected format:\n" + s);
                    }

                    if (split[1].Trim().Length < 7 || split[1].Trim().Length > 15)
                    {
                        throw new UnexpectedTestResultException("IP portion of header seems wrong:\n" + s);
                    }

                    if (split[2].Trim().Length < 1 || split[2].Trim().Length > 5)
                    {
                        throw new UnexpectedTestResultException("Port portion of header seems wrong:\n" + s);
                    }

                    if (split[2].Trim() == "0")
                    {
                        throw new UnexpectedTestResultException("Port is 0 in header:\n" + s);
                    }
                }

                if (s.StartsWith("ServerPort"))
                {
#if !GatewayTests
                    gotServerPort = true;
#endif

                    string[] split = s.Split(new char[] { ':' });
                    if (split.Length != 2)
                    {
                        throw new UnexpectedTestResultException("ServerPort header not in the expected format:\n" + s);
                    }

                    ushort headerPort = ushort.Parse(split[1].Trim());
#if GatewayTests
                    ValueCheck.Test("ServerPort header value", AAGatewayTests.AAGatewayTestBase.ReflectorPort, headerPort);
#else
                    ValueCheck.Test("ServerPort header value", ActiveAuthHttpConfig.GetServerPort(), headerPort);
#endif
                }
            }

#if !GatewayTests
            //
            if (!gotSGIPPort)
            {
                throw new UnexpectedTestResultException("Reflected headers did not contain SGIPPort");
            }

            if (!gotServerPort)
            {
                throw new UnexpectedTestResultException("Reflected headers did not contain ServerPort");
            }
#endif
        }

        //verifies AAInfo is sane
        public static void VerifyAAInfo (AAReflectorResponse reflResponse, bool isXboxUser)
        {
            ReflectedAAInfo aainfo = reflResponse.AAInfo;

            //aa info being available should always be the opposite of whether it was a null value
            ValueCheck.Test("aainfo_available = !aainfo_nullity", !aainfo.IsAAInfoAvailable, aainfo.IsAAInfoNull);

            //were there exceptions? never should be
            if (aainfo.ReturnedExceptions != null)
            {
                throw new UnexpectedTestResultException("Exceptions returned from reflector: \n" + aainfo.ReturnedExceptions);
            }

            //
            if (aainfo.IsAAInfoAvailable)
            {
#if GatewayTests
                ValueCheck.IsTrue(aainfo.IsMiddleTier, "AAInfo.IsMiddleTier for Gateway tests");
                ValueCheck.IsFalse(aainfo.IsInternetTier, "AAInfo.IsInternetTier for Gateway tests");
#elif ModuleTests
                ValueCheck.IsTrue(aainfo.IsInternetTier, "AAInfo.IsInternetTier for Module tests");
                ValueCheck.IsFalse(aainfo.IsMiddleTier, "AAInfo.IsMiddleTier for Module tests");
#endif

                //sanity checks on the IPs
                IPAddress inetIP = IPAddress.Parse(aainfo.IpAddressInternet);

                IPAddress origIP = IPAddress.Parse(aainfo.OriginatingIP);

#if ModuleTests
                if (!inetIP.Equals(origIP))
                {
                    throw new UnexpectedTestResultException("AAInfo Originating IP should have been the same as the Internet IP");
                }
#endif

                //check on the user stuff
                if (aainfo.IsUserValid)
                {
                    if (aainfo.PassportPuid == 0)
                    {
                        throw new UnexpectedTestResultException("AAInfo.PassportPuid was 0 when user was valid");
                    }

                    //check on whether live-specific user stuff is correct
                    if (isXboxUser)
                    {
                        if (aainfo.LiveXuid == 0)
                        {
                            throw new UnexpectedTestResultException("AAInfo.LiveXuid was 0 when user was an xbox live user");
                        }
                        if (aainfo.LiveXuidFromXCache == 0)
                        {
                            throw new UnexpectedTestResultException("AAInfo.LiveXuidFromXCache was 0 when user was an xbox live user");
                        }
                        ValueCheck.Test("aainfo.LiveXuid == aainfo.LiveXuidFromXCache", aainfo.LiveXuidFromXCache, aainfo.LiveXuid);

                        if (aainfo.CountryId == 0)
                        {
                            throw new UnexpectedTestResultException("AAInfo.CountryId was 0 when user was valid");
                        }

                        if (aainfo.Privileges.Length == 0)
                        {
                            throw new UnexpectedTestResultException("AAInfo has no priveleges for an xbox live user");
                        }
                    }
                }

                //if there is no user or no xbl user, check that we have no stuff
                if (!aainfo.IsUserValid || (aainfo.IsUserValid && !isXboxUser))
                {
                    if (aainfo.LiveXuid != 0)
                    {
                        throw new UnexpectedTestResultException("AAInfo.LiveXuid was " + aainfo.LiveXuid + " when user was NOT an xbox live user");
                    }
                    if (aainfo.LiveXuidFromXCache != 0)
                    {
                        throw new UnexpectedTestResultException("AAInfo.LiveXuidFromXCache was " + aainfo.LiveXuid + " when user was NOT an xbox live user");
                    }

                    if (aainfo.CountryId != 0)
                    {
                        throw new UnexpectedTestResultException("AAInfo.CountryId was " + aainfo.CountryId + " for a NON xbox live user");
                    }

                    if (aainfo.Privileges.Length != 0)
                    {
                        throw new UnexpectedTestResultException("AAInfo had " + aainfo.Privileges.Length + " priveleges for a NON xbox live user");
                    }
                }

                //should always exist in an asp.net/http environment
                ValueCheck.Test("AAInfo.Current", "exists", aainfo.AAInfoCurrent);
            }
        }

        //Does all verification possible
        public static void VerifyEverythingPossible (int expectedStatus, HttpClient.Request requestSent, HttpClient.Response response, bool isPassport, bool isXboxUser)
        {
            if (response == null)
            {
                throw new UnexpectedTestResultException("Expected a response.");
            }

            if (expectedStatus != response.Status)
            {
                throw new UnexpectedTestResultException("Expected " + expectedStatus + " but got " + response.Status + ": " + response.Reason);
            }

            VerifyEverythingPossible(requestSent, response, isPassport, isXboxUser);
        }
        public static void VerifyEverythingPossible (HttpClient.Request requestSent, HttpClient.Response response, bool isPassport, bool isXboxUser)
        {
            //basics
            AAReflectorResponse reflResponse = AAReflectorResponse.Create(response);
            VerifyResponseBasics(requestSent, response, reflResponse);
            VerifyExtraHeaders(reflResponse);

            //passport means having aainfo
            /*if (!isPassport) //no it doesn't
            {
                if (reflResponse.AAInfo.IsAAInfoAvailable || !reflResponse.AAInfo.IsAAInfoNull)
                {
                    throw new UnexpectedTestResultException("We did not use passport auth, but got AAInfo.  That shouldn't happen.");
                }
            }
            else
            {
                if (!reflResponse.AAInfo.IsAAInfoAvailable || reflResponse.AAInfo.IsAAInfoNull)
                {
                    throw new UnexpectedTestResultException("We used passport auth, but did not get AAInfo.  That shouldn't happen.");
                }
            }*/

            //aainfo and context checks
            if (reflResponse != null)
            {
                VerifyAAInfo(reflResponse, isXboxUser);
                ResponseVerification.CheckPassportContext(reflResponse, isPassport);

#if !GatewayTests
                //context must match aainfo for passport puid
                if (isPassport)
                {
                    ulong conPuid = ulong.Parse((reflResponse.GetContextValues("AAInfo_PassportPuid")[0]).Trim());
                    ulong aaiPuid = reflResponse.AAInfo.PassportPuid;

                    if (conPuid != aaiPuid)
                    {
                        throw new UnexpectedTestResultException("passport puid did not match, between context and aainfo");
                    }
                }
                else //didn't use passport
                {
                    if (reflResponse.AAInfo.PassportPuid != 0)
                    {
                        throw new UnexpectedTestResultException("AAInfo.PassportPuid was " + reflResponse.AAInfo.PassportPuid + " when user was not valid");
                    }
                }
#endif
            }
        }

        #endregion //Verification Logic


        #region Tests

        [TestCase, Description("Simple Positive normal test case with good vibes")]
        public class NoAuthRequired_NoPassport : TestBase
        {
            protected override void Execute ()
            {
                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SHARED_URI_SIMPLE);
                if ((string)Parent.MyValues[0] == "POST") AddPostDataToRequest(req);

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), false, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Simple Positive normal test case with good vibes")]
        public class NoAuthRequired_WithPassport : TestBase
        {
            protected override void Execute ()
            {
                Global.RO.Debug("Making user...");
                KdcUser user = AuthContext.MakeNewGenericUser(true, true);
                string ticket = AuthClientBase.GetAAPassportTicket(user.Passport.UserName, user.Passport.Password, "MBI");

                //
                Global.RO.Debug("Doing request...");
                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SHARED_URI_SIMPLE);
                if ((string)Parent.MyValues[0] == "POST") AddPostDataToRequest(req);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                http.SendRequest(req);
                VerifyEverythingPossible(200, req, http.GetResponse(), false, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Valid passport, but the user isn't an xbox live user.")]
        public class AuthRequired_NonXblUser : TestBase
        {
            protected override void Execute ()
            {
                ActiveAuthHttpClient client = new ActiveAuthHttpClient();
                client.PassportName = NON_XBL_PASSPORT_NAME;
                client.PassportPassword = NON_XBL_PASSPORT_PW;

                HttpClient.Response res;
                if ((string)Parent.MyValues[0] == "POST") res = client.PostPageRequest(SHARED_URI_AUTH, new byte[] { 1, 2, 3 }, "text/xml");
                else res = client.GetPageResponse(SHARED_URI_AUTH);

                VerifyEverythingPossible(200, null, res, true, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Valid passport and user is an xbl user.")]
        public class AuthRequired_XblUser : TestBase
        {
            protected override void Execute ()
            {
                Global.RO.Debug("Making user...");
                KdcUser user = AuthContext.MakeNewGenericUser(true, true);

                //
                Global.RO.Debug("Doing request...");
                ActiveAuthHttpClient client = new ActiveAuthHttpClient();
                client.PassportName = user.Passport.UserName;
                client.PassportPassword = user.Passport.Password;

                HttpClient.Response res;
                if ((string)Parent.MyValues[0] == "POST") res = client.PostPageRequest(SHARED_URI_AUTH, new byte[] { 1, 2, 3 }, "text/xml");
                else res = client.GetPageResponse(SHARED_URI_AUTH);

                VerifyEverythingPossible(200, null, res, true, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Make a user... sign them into the kdc and activeauth... and verify that the priveleges match")]
        [CompoundCase("Silver", false)]
        [CompoundCase("Gold", true)]
        public class CompareToXkdcPrivileges : TestBase
        {
            protected override void Execute ()
            {
                bool isGold = (bool)MyValues[0];

                //our crazy user
                Global.RO.Debug("Making " + (isGold ? "gold" : "silver") + " user...");
                KdcUser user = AuthContext.MakeNewGenericUser(true, isGold);

                System.Threading.Thread.Sleep(5000);

                //do activeauth
                Global.RO.Debug("Doing activeauth request...");
                ActiveAuthHttpClient client = new ActiveAuthHttpClient();
                client.PassportName = user.Passport.UserName;
                client.PassportPassword = user.Passport.Password;

                HttpClient.Response aares;
                if ((string)Parent.Parent.MyValues[0] == "POST") aares = client.PostPageRequest(SHARED_URI_AUTH, new byte[] { 1, 2, 3 }, "text/xml");
                else aares = client.GetPageResponse(SHARED_URI_AUTH);

                VerifyEverythingPossible(200, null, aares, true, true);
                AAReflectorResponse reflResponse = AAReflectorResponse.Create(aares);
                ReflectedAAInfo aainfo = reflResponse.AAInfo;

                //do kdc
                Global.RO.Debug("Doing xkdc request...");
                AuthContext ctx = new AuthContext(AuthContext.ClientTypes.Xenon);
                ctx.SetUser(user, 0);
                ctx.SetTitle(0xFFFF0072, 0, 0); //a title with no t_title_priveleges
                XkdcClient xkdc = new XkdcClient(ctx);
                xkdc.SignInXkdc();
                XkdcResult kdcres = ctx.ServiceCtxXe.GetXkdcResult();

                //now compare privileges
                ResultCode = TEST_RESULTS.PASSED;

                for (int i = 128; i < 256; ++i)
                {
                    if (kdcres.HasPrivilege(0, i) && !aainfo.HasPrivilege(i))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Error("xkdc result has privilege " + i + " set but AAInfo doesn't.");
                    }

                    if (!kdcres.HasPrivilege(0, i) && aainfo.HasPrivilege(i))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Error("AAInfo has privilege " + i + " set but xkdc result doesn't doesn't.");
                    }
                }
            }
        }

        #endregion //Tests
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\GatewayDVT\AAGatewayDVT.cs ===
using System;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Web;
using System.Web.Hosting;
using System.IO;
using System.Security.Cryptography.X509Certificates;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.config;

namespace AAGatewayDVT
{

public class AAGatewayDVTTestBaseGroup : TestNode
{
    protected static Report           ro           = new Report("DVT");
    protected XblUser                 _CachedUser  = null;
    protected UacsCommon2             _uacs        = new UacsCommon2();

    [TestGroupSetup]
    public void Setup()
    {
        ro.Info("Enabling SSL callback to blindly accept all bad server certificates");
        ServicePointManager.ServerCertificateValidationCallback =
                    new RemoteCertificateValidationCallback(ValidateServerCertificate);

        //ServicePointManager.Expect100Continue = false;
    }

    // ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------
    protected XblUser NewUser(bool fForceNew)
    {
        if (_CachedUser != null && !fForceNew)
            return _CachedUser;

        ro.Debug("Creating new user");
        XblUserSettings userSettings = new XblUserSettings(
            UserType.Silver,
            true);         // use real passport?
        userSettings.CountryId = XeUser.Country.US;
        XblUser u = _uacs.CreateUser(userSettings);
        ro.Debug("Created user @@@foo");

        _CachedUser = u;
        return u;
    }

    // ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------
    protected string GetTicket(XblUser u, string policy)
    {
        // policy is LBI, MBI, MBI_SSL, etc
        PassportInfo ppi = _uacs.GetUserPassportInfo(u);
        //XblUserSettings settings = uacs.GetUserSetting(u);
        ro.Debug("Retrieving {0} ticket for {1} (0x{2:X})", policy, ppi.MemberName, ppi.PassportPuid);
        string ticket = AuthClientBase.GetAAPassportTicket(ppi.MemberName, ppi.Password, policy);
        return ticket;
    }

    // ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------
    protected string BuildUrl(string xrlPath, bool fSsl)
    {
        // If using SSL, the name we use here in the URL must match what the 
        // certificate was issued to. Typically this is of the form 
        // "activeauth.test.xboxlive.com" for testnet. It seems this DNS name isn't 
        // necessarily set up, so we may need to use the IP directly. If that's the 
        // case, then we have to ignore SSL errors about an untrusted server.

        // We're assuming things aren't right and going straight to the IP. Only way 
        // to do it for an xblob, anyway.

        string url;
        IPEndPoint viIP;
        if (fSsl)
        {
            viIP = Global.XEnv.GetVirtualInterface(VirtualInterface.authsg_ssl);
            url = "https://" + viIP.ToString() + xrlPath;
        }
        else
        {
            viIP = Global.XEnv.GetVirtualInterface(VirtualInterface.authsg);
            url = "http://" + viIP.ToString() + xrlPath;
        }

        // @@@ hack hack hitting prod!
        //url = "https://activeauth.xboxlive.com" + xrlPath;

        ro.Debug(url);
        return url;

#if false
        // Assuming things are right
        Global.XEnv.GetVirtualInterface(VirtualInterface.xqry)
            string curr_env = Global.XEnv.GetEnv().ToLower();
        if      (curr_env == "stressnet")  return "activeauth.stress.xboxlive.com";
        else if (curr_env == "testnet")    return "activeauth.test.xboxlive.com";
        else if (curr_env == "stressnet2") return "activeauth.stress2.xboxlive.com";
        else
        {
            Global.RO.Warn("SSLHost: We are not coded for environment: " + Global.XEnv.GetEnv() + ", so defaulting to StressNet server.");
            return "activeauth.stress.xboxlive.com";
        }
#endif
    }


    // ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------
    private static void ShowServicePointProperties(ServicePoint sp)
    {
        ro.Debug ("ServicePoint: HashCode = " + sp.GetHashCode());

        // Display the ServicePoint Internet resource address.
        ro.Debug ("ServicePoint: Address = {0} ", sp.Address.ToString ());

        // Display the date and time that the ServicePoint was last 
        // connected to a host.
        ro.Debug ("ServicePoint: IdleSince = " + sp.IdleSince.ToString ());

        // Display the maximum length of time that the ServicePoint instance  
        // is allowed to maintain an idle connection to an Internet  
        // resource before it is recycled for use in another connection.
        ro.Debug ("ServicePoint: MaxIdleTime = " + sp.MaxIdleTime);

        ro.Debug ("ServicePoint: ConnectionName = " + sp.ConnectionName);

        // Display the maximum number of connections allowed on this 
        // ServicePoint instance.
        ro.Debug ("ServicePoint: ConnectionLimit = " + sp.ConnectionLimit);

        // Display the number of connections associated with this 
        // ServicePoint instance.
        ro.Debug ("ServicePoint: CurrentConnections = " + sp.CurrentConnections);

        if (sp.Certificate == null)
            ro.Debug ("ServicePoint: Certificate = (null)");
        else
            ro.Debug ("ServicePoint: Certificate = " + sp.Certificate.ToString ());

        if (sp.ClientCertificate == null)
            ro.Debug ("ServicePoint: ClientCertificate = (null)");
        else
            Console. WriteLine ("ServicePoint: ClientCertificate = " + sp.ClientCertificate.ToString ());

        ro.Debug ("ServicePoint: ProtocolVersion = " + sp.ProtocolVersion.ToString ());
        ro.Debug ("ServicePoint: SupportsPipelining = " + sp.SupportsPipelining);
        ro.Debug ("ServicePoint: UseNagleAlgorithm = " + sp.UseNagleAlgorithm.ToString ());
        ro.Debug ("ServicePoint: Expect 100-continue = " + sp.Expect100Continue.ToString ());
    }


    // ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------
    protected string PostRequest(string url, string passportTicket, string content, bool fKeepAlive)
    {
        try
        {
            HttpWebRequest webreq = (HttpWebRequest)WebRequest.Create(url);
            webreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
            webreq.UserAgent = "AAGatewayDVT/0.1";

            webreq.KeepAlive = fKeepAlive;
            webreq.Method = "POST";
            webreq.ContentType = "application/x-www-form-urlencoded"; //"text/xml";
            webreq.ContentLength = content == null ? 0 : content.Length;

            // GetUserAuthorization, and probably others, requires the X-ClientType 
            // header.
            webreq.Headers.Add("X-ClientType", "panorama");

            if (passportTicket != null)
            {
                webreq.Headers.Add("Authorization", "WLID1.0 t=" + passportTicket);
            }

            // Set all headers prior to this!
            if (!String.IsNullOrEmpty(content))
            {
                // This initiates the send, btw
                StreamWriter sw = new StreamWriter(webreq.GetRequestStream(), System.Text.Encoding.ASCII);
                sw.Write(content);
                sw.Close();
            }

            ro.Debug("Request headers:\n{0}", webreq.Headers);

            // Finish and get response
            HttpWebResponse webresp = (HttpWebResponse)webreq.GetResponse();

            ro.Debug("Response headers:\n{0}", webresp.Headers);

            // Read body
            StreamReader sr = new StreamReader(webresp.GetResponseStream());
            string contentResponse = sr.ReadToEnd();

            webresp.Close();
            sr.Close();

            // Extra info about connection used
            ShowServicePointProperties(webreq.ServicePoint);

            //ro.Debug("Response (first 500 bytes):\n{0}", contentResponse.Substring(0, 
            //500));

            return contentResponse;
        }
        catch (WebException we)
        {
            // We throw, so no need to print this
            // ro.Error("Got WebException:\n{0}", we.ToString());
            ro.Warn("WebException: {0}, Status {1}", we.Message, we.Status);

            if (we.Response != null)
            {
                StreamReader sr = null;
                try
                {
                    ro.Debug("WebException Response headers:\n{0}", we.Response.Headers);

                    sr = new StreamReader(we.Response.GetResponseStream());
                    String s = sr.ReadToEnd();

                    // IIS can be very verbose...
                    //ro.Debug("WebException Response:\n{0}", s);

                    if (s.Contains("<Exception>"))
                    {
                        return s;
                    }
                    else
                    {
                        if (we.Response.Headers != null)
                        {
                            string[] headers = we.Response.Headers.GetValues("WWW-Authenticate");
                            if (headers != null && headers.Length > 0)
                            {
                                throw new UnauthorizedAccessException("WWW-Authenticate: " + headers[0]);
                            }
                        }
                    }
                }
                finally 
                {
                    we.Response.Close();
                    if (sr != null)
                        sr.Close();
                }
            }

            throw;
        }
    }

    // ------------------------------------------------------------------------
    // The following method is invoked by the RemoteCertificateValidationDelegate.
    // ------------------------------------------------------------------------
    public static bool ValidateServerCertificate(
        object sender,
        X509Certificate certificate,
        X509Chain chain,
        SslPolicyErrors sslPolicyErrors)
    {
        if (sslPolicyErrors == SslPolicyErrors.None)
            return true;

        ro.Warn("Certificate error (ignoring): {0}", sslPolicyErrors);

        // Always allow this client to communicate with "bad" servers.
        return true;
    }


}

[TestGroup, DVT]
public class GFWLSimulation : AAGatewayDVTTestBaseGroup
{
    protected const string _xrlGUA = "/xuacs/useraccount.asmx/GetUserAuthorization";
    protected const bool   _sslGUA = true;

    // These are kinda hacky, but I don't know how to put an option on the menu

    [TestCase]
    public void EnableExpect100ContinueHeader()
    {
        ServicePointManager.Expect100Continue = true;
    }
    
    [TestCase]
    public void DisableExpect100ContinueHeader()
    {
        ServicePointManager.Expect100Continue = false;
    }
        
        


    [TestCase, Description("Foo")]
    public void GetUserAuthorization_FirstReqRight()
    {
        XblUser u = NewUser(false);
        string  t = GetTicket(u, "MBI_SSL");
        string  requestStr = "serviceType=1&titleId=0";
        string  responseStr = PostRequest(BuildUrl(_xrlGUA, _sslGUA), t, requestStr, true);
    }

    [TestCase, Description("Foo")]
    public void GetUserAuthorization_FirstReqNoTicket()
    {
        XblUser u = NewUser(false);
        string  requestStr = "serviceType=1&titleId=0";
        try
        {
            string  responseStr = PostRequest(BuildUrl(_xrlGUA, _sslGUA), null, requestStr, true);
        }
        catch (UnauthorizedAccessException e)
        {
            ro.Info("Got expected error back: {0}", e.Message);
        }
    }

    [TestCase, Description("Foo")]
    public void GetUserAuthorization_FirstReqNoTicket_SecondReqRight()
    {
        XblUser u = NewUser(false);
        string  t = GetTicket(u, "MBI_SSL");
        string  requestStr = "serviceType=1&titleId=0";
        string  responseStr;
        
        try
        {
            // No ticket
            responseStr = PostRequest(BuildUrl(_xrlGUA, _sslGUA), null, requestStr, true);
        }
        catch (UnauthorizedAccessException)
        {
            // Expected to succeed
            responseStr = PostRequest(BuildUrl(_xrlGUA, _sslGUA), t, requestStr, true);
        }
    }

    [TestCase, Description("Foo")]
    public void GetUserAuthorization_FirstReqNoTicket_SecondReqRight_NoSsl()
    {
        XblUser u = NewUser(false);
        string  t = GetTicket(u, "MBI");
        string  requestStr = "serviceType=1&titleId=0";
        string  responseStr;
        
        try
        {
            // No ticket
            responseStr = PostRequest(BuildUrl(_xrlGUA, false), null, requestStr, true);
        }
        catch (UnauthorizedAccessException)
        {
            // Expected to succeed
            responseStr = PostRequest(BuildUrl(_xrlGUA, false), t, requestStr, true);
        }
    }

    [TestCase, Description("Foo")]
    public void GetUserAuthorization_FirstReqNoTicket_SecondReqRight_NoKeepAlive()
    {
        XblUser u = NewUser(false);
        string  t = GetTicket(u, "MBI_SSL");
        string  requestStr = "serviceType=1&titleId=0";
        string  responseStr;
        
        try
        {
            // No ticket
            responseStr = PostRequest(BuildUrl(_xrlGUA, _sslGUA), null, requestStr, false);
        }
        catch (UnauthorizedAccessException)
        {
            // Expected to succeed
            responseStr = PostRequest(BuildUrl(_xrlGUA, _sslGUA), t, requestStr, false);
        }
    }


}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleDVT\LimitedSizeDictionaryTests.cs ===
using System;
using System.Net;
using System.Web;
using System.Web.Hosting;
using System.IO;
using System.Collections.Generic;

using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;
using xonline.common.utilities2;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace ModuleDVT
{

class TestRecord : ILimitedSizeDictionaryValue<string>
{
    public string Key 
    {
        get { return _Key; }
        set { _Key = value; }
    }

    public bool IsReusable
    {
        get { return _Count <= 0; }
    }

    public void Init(string key)
    {
        _Key = key;
        _Count = 0;
    }

    public int      _Count;
    public string   _Key;

    public override string ToString()
    {
        return String.Format("({0}, {1})", _Key, _Count);
    }
}


[TestGroup, DVT, Owner("dvt"), TestFrequency("Regression")]
public class LimitedSizeDictionary : ModuleDVTTestBaseGroup
{
    LimitedSizeDictionary<string, TestRecord> dict;

    private void Reset()
    {
        dict = new LimitedSizeDictionary<string, TestRecord>(20);
    }

    private void Dump(string header)
    {
        Global.RO.Debug(header + "\n" + dict.ToString());
    }

    private void Populate(int start, int count)
    {
        for (int i = start; i < start + count; i++)
        {
            string key = "Key " + i.ToString();
            TestRecord record = dict.Get(key);
            record._Count = i + 1;
        }
    }

    private void Clear(int start, int count)
    {
        for (int i = start; i < start + count; i++)
        {
            string key = "Key " + i.ToString();
            TestRecord record = dict.Get(key);
            record._Count = 0;
        }
    }

    private void Verify(int start, int count)
    {
        Verify(start, count, 0);
    }

    private void Verify(int start, int count, int offset)
    {
        for (int i = start; i < start + count; i++)
        {
            string key = "Key " + i.ToString();
            TestRecord record;
            bool fOk = dict.TryGetWithoutUpdate(key, out record);
            Assert.IsTrue(fOk, "fOk for " + key);
            Assert.IsTrue(record._Count == i + 1 + offset);
        }
    }

    private void VerifyNegative(int start, int count)
    {
        for (int i = start; i < start + count; i++)
        {
            string key = "Key " + i.ToString();
            TestRecord record;
            bool fOk = dict.TryGetWithoutUpdate(key, out record);
            //Assert.IsTrue(record._Count == 0);
            Assert.IsTrue(!fOk, "!fOk for " + key);
        }
    }
    
    [TestCase]
    public void VerifyLru()
    {
        Reset();
        Populate(0, 20);
        Populate(0, 1);
        Populate(1, 19);
        Populate(0, 1);
        Dump("After populate 0 to 19, 0, 1 to 19, 0");
        Verify(0, 20);
        Clear(1, 20);

        Populate(40, 19);
        Dump("After populate 40 to 58");
        Verify(40, 19);
        Verify(0, 1);
        VerifyNegative(1, 19);
    }

    [TestCase]
    public void VerifyLruSlam()
    {
        Reset();

        for (int iter = 0; iter < 100; iter++)
        {
            Populate(0, 1);
            for (int i = 0; i < 19; i++)
            {
                Populate(iter * 100 + i, 1);
            }
            Verify(iter * 100, 19);
            Verify(0, 1);
            Clear(iter * 100, 19);
            Clear(0, 1);
        }
        Dump("After 100 iterations");
    }

    [TestCase]
    public void VerifyLru_OneInUse()
    {
        Reset();
        Populate(0, 20);
        Verify(0, 20);
        Clear(0, 20);

        // Get 1 record, don't release it
        Populate(10, 1);

        Populate(20, 19);
        Populate(20, 19);
        
        Dump("20-38, 10 remains");
        Verify(10, 1);
        Verify(20, 19);
    }


    [TestCase]
    public void VerifyLru_AllInUse()
    {
        Reset();
        Populate(0, 20);
        Verify(0, 20);

        try
        {
            Populate(20, 1);
        }
        catch (Exception e)
        {
            Global.RO.Info("Got exception (expected): " + e.ToString());
            return;
        }
        finally
        {
            Dump("All records in use 0-19");
        }
        throw new Exception("Expected exception, didn't get one");
    }

    [TestCase]
    public void VerifyRepurposingOldest()
    {
        Reset();

        Populate(0, 1);
        Clear(0, 1);
        Populate(1, 19);
        Verify(0, 1, -1);
        Verify(1, 19);
        Populate(20, 1); 

        Dump("1-20");
        Verify(1, 20);
    }

    [TestCase]
    public void VerifyRepurposingNewest()
    {
        Reset();

        Populate(0, 20);
        Clear(19, 1);
        Verify(0, 19);
        Verify(19, 1, -20);
        Populate(20, 1); 

        Dump("0-18, 20");
        Verify(0, 19);
        Verify(20, 1);
    }

    [TestCase]
    public void MeasureTime_Growing()
    {
        const int dictSize = 400000;
        const int innerIter = 50000;
        Random rand = new Random();

        Global.RO.Info("Creating {0} entry dictionary", dictSize);
        LimitedSizeDictionary<string, TestRecord> d;
        d = new LimitedSizeDictionary<string, TestRecord>(dictSize);

        DateTime startTime = DateTime.Now;
        int totalOperations = (dictSize / 10000) * innerIter;

        Global.RO.Info("Performing {0} operations...", totalOperations);

        DateTime lastTime;
        for (int j = 0; j < dictSize + innerIter; j += 10000)
        {
            lastTime = DateTime.Now;

            for (int i = 0; i < innerIter; i++)
            {
                int idx = j + (rand.Next() % innerIter);
                string key = "Key" + idx.ToString();
                TestRecord r = d.Get(key);
                r._Count = rand.Next() % 2;
            }
            
            TimeSpan e = DateTime.Now - lastTime;
            Global.RO.Debug(": {0} ops in {1} ms [{2} tps, {3} spt]  NumRecords: {4}", 
                            innerIter, 
                            e.TotalMilliseconds,
                            (int)(innerIter / e.TotalSeconds),
                            (e.TotalSeconds / innerIter),
                            d.Count);

        }

        TimeSpan elapsedTime = DateTime.Now - startTime;

        Global.RO.Info("Total elapsed time for {0} operations: {1}", totalOperations, elapsedTime.ToString());
    }

    [TestCase]
    public void MeasureTime_Reusing()
    {
        const int dictSize = 400000;
        const int innerIter = 50000;
        Random rand = new Random();

        Global.RO.Info("Creating {0} entry dictionary", dictSize);
        LimitedSizeDictionary<string, TestRecord> d;
        d = new LimitedSizeDictionary<string, TestRecord>(dictSize);

        DateTime startTime = DateTime.Now;
        int totalOperations = (dictSize * 2 / 10000) * innerIter;

        Global.RO.Info("Performing {0} operations...", totalOperations);

        DateTime lastTime;
        for (int j = 0; j < dictSize * 2; j += 10000)
        {
            lastTime = DateTime.Now;

            for (int i = 0; i < innerIter; i++)
            {
                int idx = (rand.Next() % dictSize);
                string key = "Key" + idx.ToString();
                TestRecord r = d.Get(key);
                r._Count = rand.Next() % 2;
            }
            
            TimeSpan e = DateTime.Now - lastTime;
            Global.RO.Debug(": {0} ops in {1} ms [{2} tps, {3} spt]  NumRecords: {4}", 
                            innerIter, 
                            e.TotalMilliseconds,
                            (int)(innerIter / e.TotalSeconds),
                            (e.TotalSeconds / innerIter),
                            d.Count);

        }

        TimeSpan elapsedTime = DateTime.Now - startTime;

        Global.RO.Info("Total elapsed time for {0} operations: {1}", totalOperations, elapsedTime.ToString());
    }


}




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\common\ThrottleHistoryTracker.cs ===
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

using ServerTestFramework.LiveService.Auth;

namespace PirateSGTest
{
    /// <summary>
    /// Used for tracking the call history for ActiveAuth throttling.
    /// Is both the data container and the static entry point for use.
    /// </summary>
    class ThrottleHistoryTracker
    {
        #region Static

        public static readonly Dictionary<string, ActiveAuthHttpConfig.PolicyEntry> TEST_POLICIES =
            new Dictionary<string, ActiveAuthHttpConfig.PolicyEntry>();

        public const uint HttpResponseGood = 200;
        public const uint HttpResponseBlocked = 503;

        /// <summary>
        /// The tracking data.
        /// </summary>
        protected static Dictionary<string, ThrottleHistoryTracker> _tracked = 
            new Dictionary<string, ThrottleHistoryTracker>();

        /// <summary>
        /// Gets the tracker for the given values, or null if no tracking.
        /// </summary>
        public static ThrottleHistoryTracker Get (string id, string url)
        {
            string key = CreateKey(id, url);
            lock (_tracked)
            {
                if (_tracked.ContainsKey(key))
                {
                    return _tracked[key];
                }
            }

            return null;
        }

        /// <summary>
        /// Gets the tracker for the given values, or creates one if none exists.
        /// </summary>
        public static ThrottleHistoryTracker GetOrCreate (string id, string url)
        {
            string key = CreateKey(id, url);
            lock (_tracked)
            {
                if (_tracked.ContainsKey(key))
                {
                    return _tracked[key];
                }
                else
                {
                    ThrottleHistoryTracker tht = new ThrottleHistoryTracker(id, url);
                    _tracked.Add(key, tht);
                    return tht;
                }
            }
        }

        /// <summary>
        /// Creates a key from the given values.
        /// </summary>
        protected static string CreateKey (string id, string url)
        {
            return (id + "|" + url);
        }

        /// <summary>
        /// Clears the history.  Don't do this without good reason...
        /// </summary>
        public static void Clear ()
        {
            _tracked.Clear();
        }

        #endregion

        #region Instance

        /// <summary>The id (usually passport puid, can be ip) that is being tracked.</summary>
        protected string _id = null;
        /// <summary>The policy/url that is throttled.</summary>
        protected ActiveAuthHttpConfig.PolicyEntry _policy = null;
        /// <summary>The value we expect will be used to throttle us.</summary>
        protected double _val = 0.0;
        /// <summary>The last time that the tracker was updated.</summary>
        protected DateTime _lastupdate = DateTime.MinValue;

        public ThrottleHistoryTracker (string id, string url)
        {
            _id = id;
            _policy = TEST_POLICIES[url];
        }

        /// <summary>
        /// Increments and decays the value.  Essentially does lock(this) for synchronization.
        /// </summary>
        /// <returns>A value indicating what the HTTP response code should be based on the policy.</returns>
        [MethodImpl(MethodImplOptions.Synchronized)]
        public uint Increment ()
        {
            // check to see if we have ever been incremented
            if (_val == 0.0 && _lastupdate == DateTime.MinValue)
            {
                _val = 1.0;
                _lastupdate = DateTime.UtcNow;
                return (_policy.ThrottleThreshold <= 1 ? HttpResponseBlocked : HttpResponseGood);
            }

            // compute decay
            DateTime now = DateTime.UtcNow;
            double elapsed = (now - _lastupdate).TotalSeconds;
            double hl = (double)_policy.ThrottleHalflifeSeconds;
            double decay = Math.Pow(2.0, -(elapsed / hl));

            // compute new value
            _val *= decay;
            _val += 1;
            _lastupdate = now;

            return (((int)_val) >= _policy.ThrottleThreshold ? HttpResponseBlocked : HttpResponseGood);
        }

        /// <summary>
        /// The amount of time before we could safely not be throttled.
        /// </summary>
        public double PenaltyTime
        {
            get
            {
                double val;
                DateTime lastupdate;

                lock (this)
                {
                    val = _val;
                    lastupdate = _lastupdate;
                }

                double decay = val / (((double)_policy.ThrottleThreshold) - 1.1);
                // can call now!
                if (decay < 1.0) { return 0.0; }

                double seconds_to_decay = Math.Log(decay, 2) * ((double)_policy.ThrottleHalflifeSeconds);
                double seconds_left = seconds_to_decay - (DateTime.UtcNow - lastupdate).TotalSeconds;

                return Math.Max(seconds_left, 0.0);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleDVT\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\common\SharedStressTests.cs ===
//These tests are shared by both the gateway test suite and the module test suite.

using System;
using System.Net;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Net.Cache;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.XSTS;

using AATest;

using xonline.common.protocol;

using Microsoft.IdentityModel.Tokens.Saml2;
using Microsoft.XboxLive.Auth.Claims;

namespace PirateSGTest
{
    public partial class SharedStressTests: TestNode
    {
        #region Setup

        public const string StressPrependPath = "/testfd/Reflect/authsg/stress/";
        public const string SimpleStressPath = StressPrependPath + "simple";
        public const string SslStressPath = StressPrependPath + "ssl";
        public const string AuthStressPath = StressPrependPath + "auth";
        public const string SamlAuthStressPath = StressPrependPath + "samlauth";
        public const string RequiresXuidStressPath = StressPrependPath + "requiresxuid";
        public const string Throttle10By4StressPath = StressPrependPath + "throttle10by4";

        //premade data
        private static int largeDataSize = 40 * 1024;
        public static byte[] largeDataUpAndDown; //the request body blob
        public static byte[] reqSimplelargeDataUpAndDown; //the full binaryized request

        //your suite's InitializeStress function should call this
        public static void SetupStress()
        {
            //SSL tests use .NET's web client.  That thing restricts us to 2 connections at once by default... which is rediculous
            ServicePointManager.DefaultConnectionLimit = 10000;
            ServicePointManager.ServerCertificateValidationCallback += SharedSSLTests.AllGood;

            //premade data chunks to set up
            largeDataUpAndDown = new byte[largeDataSize];

            TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
            tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
            tfd_req.ActionValue = TestFdReflectorRequest.Action.OutputBody;
            tfd_req.Param = largeDataSize;

            tfd_req.WriteStream(new System.IO.MemoryStream(largeDataUpAndDown));

            HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimpleStressPath);
            req.Method = "POST";
            req.ContentLength = largeDataUpAndDown.Length.ToString();
            req.Content = largeDataUpAndDown;
            req.OtherHeaders.AddLast("Content-Type: text/xml"); //xrlscan will be a @#$^% and block us without this
            reqSimplelargeDataUpAndDown = req.ToBytes();

            //configure URIs to use
            SharedSetup.ConfigureUri(SimpleStressPath, false);
            SharedSetup.ConfigureUri(SslStressPath, false, true);
            SharedSetup.ConfigureUri(AuthStressPath, true);
            SharedSetup.ConfigureUri(new ActiveAuthHttpConfig.PolicyEntry() 
                { Path = SamlAuthStressPath, AuthRequired = true, AuthHeader = "XBL1.0", SSLRequired = true, RequiresClientCert = true });
            SharedSetup.ConfigureUri(StressPrependPath + "sslauth", true, true);
            SharedSetup.ConfigureUri(StressPrependPath + "antidos", false, false, true);
            SharedSetup.ConfigureUri(RequiresXuidStressPath, true, "MBI", false, false, true, false, 0, 0);
            SharedSetup.ConfigureUri(Throttle10By4StressPath, true, "MBI", false, false, false, true, 10, 4);

            if (!ThrottleHistoryTracker.TEST_POLICIES.ContainsKey(Throttle10By4StressPath))
            {
                ThrottleHistoryTracker.TEST_POLICIES.Add(Throttle10By4StressPath,
                    new ActiveAuthHttpConfig.PolicyEntry(Throttle10By4StressPath, true, "MBI", false, false, false, true, 10, 4));
            }

#if GatewayTests
            for (int i = 0; i < StressVariantCount; ++i)
            {
                SharedSetup.ConfigureUri(StressVariantBasePath + i.ToString(), false);
            }
#endif

            SharedSetup.Reload();
        }

        public static void EndStress ()
        {
            ServicePointManager.ServerCertificateValidationCallback -= SharedSSLTests.AllGood;
        }

        #endregion //Setup

        #region PassportCache

        //represents an entry in passport ticket cache
        public class CachedTicket
        {
            public string Ticket;
            public string UserName;
            public string Password;
            public long Puid;
            public DateTime LastUseTime;
            public DateTime ExpireTime;
        };

        //
        public static TimeSpan PPCacheMinExpireTime=new TimeSpan(2,0,0); //At 2 hours there's a chance we'll toss it out
        public static TimeSpan PPCacheMaxExpireTime=new TimeSpan(3,0,0); //By 3 hours we'll have tossed it out for sure
        
        public static TimeSpan PPCacheUseTime=new TimeSpan(0,0,2);   //Single cached ticket used no more than once every this often

        public static CachedTicket GetCachedPassportTicket (bool realUser)
        {
            return GetCachedPassportTicket(realUser ? TicketCache.XblUser : TicketCache.NonUser);
        }

        public static CachedTicket GetCachedPassportTicket (TicketCache ticketCache)
        {
            LinkedList<CachedTicket> cache = null;
            
            switch (ticketCache)
            {
                case TicketCache.XblUser: cache = TicketCacheXblUser; break;
                case TicketCache.NonUser: cache = TicketCacheNonUser; break;
                case TicketCache.Saml: cache = TicketCacheSaml; break;
                case TicketCache.Xsts: cache = TicketCacheXsts; break;
            }

            CachedTicket ct = null;
            bool new_realuser = false;
            DateTime now = DateTime.UtcNow;

            //the cache is sorted such that the oldest-used are at the front
            lock (cache)
            {
                //go through the cache starting at the front and look for one that we can use
                if (cache.Count > 0)
                {
                    CachedTicket t = cache.First.Value;

                    //if it's expired, toss it out
                    if (now > t.ExpireTime)
                    {
                        Global.RO.Debug("Ticket Expired - Refreshing cache. t="+t.Ticket.Substring(0,8)+"...");
                        cache.RemoveFirst();
                        ct = t;
                        goto ticketRefresh;
                    }

                    //if it's use time is too soon, our cache isn't big enough
                    if (now - t.LastUseTime < PPCacheUseTime)
                    {
                        // this attempts to make the 30 second wait for real users not screw up the 'sorted' list
                        cache.RemoveFirst();
                        cache.AddLast(t);
                    }
                    else
                    {
                        //else this one is right for use, so move it to the end
                        cache.RemoveFirst();
                        t.LastUseTime = now;
                        cache.AddLast(t);
                        return t;
                    }
                }
            }

            //couldn't find a cached one to use, so get a new one
            switch (ticketCache)
            {
                case TicketCache.XblUser:
                {
                    new_realuser = true;
                    ServerTestFramework.Database.UserEditor ue = ServerTestFramework.Database.UserEditor.CreateNew();
                    ue.LinkPassport((ulong)ue.UserPassportPuid);

                    ct = new CachedTicket();
                    ct.Puid = ue.UserPassportPuid;
                    ct.UserName = "SelfGen" + ct.Puid.ToString() + "@live-int.com";
                    ct.Password = "doesnt really have a password";
                }
                break;

                case TicketCache.NonUser:
                {
                    // a non user is just a random puid and name
                    ct = new CachedTicket();
                    ct.Puid = unchecked((long)RandomEx.GlobalRandGen.GenerateRandomPuid());
                    ct.UserName = "SelfGen" + ct.Puid.ToString() + "@live-int.com";
                    ct.Password = "doesnt really have a password";
                }
                break;

                case TicketCache.Saml:
                case TicketCache.Xsts:
                {
                    ct = new CachedTicket();
                }
                break;
            }

        ticketRefresh:
            // because we may have just waited a long time for creating a user
            now = DateTime.UtcNow;

            switch (ticketCache)
            {
                case TicketCache.XblUser:
                case TicketCache.NonUser:
                    ct.Ticket = AuthClientBase.GetAAPassportTicketSelfGen(ct.UserName, ct.Puid);
                    break;

                case TicketCache.Saml:
                    {
                        ServerTestFramework.STS.STSUtil.GetSecurityTicketParameters gstp = 
                            new ServerTestFramework.STS.STSUtil.GetSecurityTicketParameters();
                        gstp.Certificate = SamlSigningCertificate;
                        gstp.DeviceID = SSLAuthSaml.GetCertDeviceId();
                        gstp.NotAfter = DateTime.UtcNow.AddHours(4);
                        ct.Ticket = ServerTestFramework.STS.STSUtil.GetSecurityTicket(gstp);
                    }
                    break;

                case TicketCache.Xsts:
                    {
                        XSTSSaml2Token token = new XSTSSaml2Token(XstsUtil.GetXstsSigningCertificate());

                        token.GenerateXboxLiveClaims();

                        // randomize title id and platform
                        foreach (Saml2Attribute attr in ((Saml2AttributeStatement)token.Assertion.Statements[0]).Attributes)
                        {
                            if (attr.Name == AuthClaimTypes.TitleId)
                            {
                                attr.Values.Clear();
                                attr.Values.Add((0xFFFE0000 + RandomEx.GlobalRandGen.Next(100)).ToString());
                            }
                            else if (attr.Name == AuthClaimTypes.DeviceType)
                            {
                                attr.Values.Clear();
                                switch (RandomEx.GlobalRandGen.Next(4))
                                {
                                    case 0: attr.Values.Add(AuthDeviceTypes.PC); break;
                                    case 1: attr.Values.Add(AuthDeviceTypes.Web); break;
                                    case 2: attr.Values.Add(AuthDeviceTypes.WindowsPhone7); break;
                                    default: attr.Values.Add(AuthDeviceTypes.Xbox360); break;
                                }
                            }
                        }

                        token.Assertion.IssueInstant = DateTime.UtcNow;
                        token.Assertion.Conditions.AudienceRestrictions.Clear();
                        token.Assertion.Conditions.AudienceRestrictions.Add(
                            new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(
                                new Uri("http://testfdxsts")));
                        token.Assertion.Conditions.NotBefore = DateTime.UtcNow.AddMinutes(-5);
                        token.Assertion.Conditions.NotOnOrAfter = DateTime.UtcNow.AddHours(4);
                        token.Encrypt = true;

                        ct.Ticket = token.ToString();
                    }
                    break;
            }
            ct.ExpireTime = now + PPCacheMinExpireTime + new System.TimeSpan(0, 0, 
                (int)((float)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextDouble() * 
                (PPCacheMaxExpireTime.TotalSeconds - PPCacheMinExpireTime.TotalSeconds)));
            ct.LastUseTime = now.AddSeconds(new_realuser ? 30.0 : 0.0);

            //Global.RO.Debug("Now="+System.DateTime.Now+"  Expire="+newTicket.ExpireTime);

            lock (cache)
            {
                cache.AddLast(ct);
            }

            return (new_realuser ? null : ct);
        }

        //ticket cache lists
        protected static LinkedList<CachedTicket> TicketCacheXblUser=new LinkedList<CachedTicket>();
        protected static LinkedList<CachedTicket> TicketCacheNonUser=new LinkedList<CachedTicket>();
        protected static LinkedList<CachedTicket> TicketCacheSaml = new LinkedList<CachedTicket>();
        protected static LinkedList<CachedTicket> TicketCacheXsts = new LinkedList<CachedTicket>();

        public enum TicketCache
        {
            XblUser,
            NonUser,
            Saml,
            Xsts
        }

        private static System.Security.Cryptography.X509Certificates.X509Certificate2 _SigningCertificate = null;

        public static System.Security.Cryptography.X509Certificates.X509Certificate2 SamlSigningCertificate
        {
            get
            {
                if (_SigningCertificate == null)
                {
                    _SigningCertificate = ServerTestFramework.STS.STSUtil.GetStsSigningCertificate();
                }

                return _SigningCertificate;
            }
        }

        #endregion //PassportCache

        #region Verification

        //
        public static void VerifyResponseCode (HttpClient.Response res, uint code)
        {
            if (res == null)
            {
                throw new System.Exception("No response.");
            }
            else if (res.Status != code)
            {
                throw new System.Exception("Expected " + code + " but got " + res.Status + " (" + res.Reason + ")");
            }
        }

        /// <summary>
        /// Checks the URL in the response against the given string.
        /// </summary>
        /// <param name="response">The response to check.</param>
        /// <param name="url">The string to check against.</param>
        /// <returns>True if all is good, false if not.</returns>
        public static bool CheckResponseAgainstURL (HttpClient.Response response, string url)
        {
            if (response == null)
            {
                Global.RO.Error("Response was null");
                return false;
            }

            // stress response?
            if (response.ContentBytes.Length == url.Length)
            {
                string temp_url = (new ByteEncoding()).GetString(response.ContentBytes);

                if (temp_url == url)
                {
                    return true;
                }
                else
                {
                    Global.RO.Error("Response body URL ({0}) did not match given URL ({1})", temp_url, url);
                    return false;
                }
            }
            else // normal reflection
            {
                if (response.ContentBytes == null)
                {
                    Global.RO.Error("Response body was not a proper reflected response");
                    return false;
                }

                TestFdReflectorResponse ref_resp = new TestFdReflectorResponse();
                ref_resp.ReadBytes(response.ContentBytes);

                if (ref_resp.HttpRequest.URLAndQueryString == url)
                {
                    return true;
                }
                else
                {
                    Global.RO.Error("Response reflection body URL ({0}) did not match given URL ({1})", 
                        ref_resp.HttpRequest.URLAndQueryString, url);
                    return false;
                }
            }
        }

        #endregion

        #region Tests

        //single get with 1 client connection
        [StressInstantiate, StressTest(TargetTPS = 8)]
        public class Get: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimpleStressPath);

                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 200);
                if (!CheckResponseAgainstURL(res, req.URI))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //10 gets with 1 client connection
        [StressInstantiate, StressTest(TargetTPS = 4)]
        public class Get10: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimpleStressPath);

                for (int i=0; i<10; ++i)
                {
                    http.SendRequest(req);
                    HttpClient.Response res=http.GetResponse();
                    VerifyResponseCode(res, 200);
                    if (!CheckResponseAgainstURL(res, req.URI))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //single get with 1 client connection - url contains a query string
        [StressInstantiate, StressTest(TargetTPS = 8)]
        public class GetQuery: TestBase
        {
            protected override void Execute()
            {
                //gen a random query string (400 = max query length contfigured for reflector xrlscan evilness)
                string baseUri = SimpleStressPath + "?";
                int maxQueryLen=400-baseUri.Length;
                string qstring=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(1,maxQueryLen);

                //do request
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req=new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), baseUri+qstring);

                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 200);
                if (!CheckResponseAgainstURL(res, req.URI))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [StressInstantiate, StressTest(TargetTPS = 8)]
        public class Post: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimpleStressPath);

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                //setup post data
                req.Method="POST";
                byte[] bytes = new byte[ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(tfd_req.Size(), 2048)];
                ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextBytes(bytes);

                tfd_req.WriteStream(new System.IO.MemoryStream(bytes));

                req.SetContentLengthAndBody(bytes);
                req.OtherHeaders.AddLast("Content-Type: text/xml");

                //send
                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 200);
                if (!CheckResponseAgainstURL(res, req.URI))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [StressTest]
        public class PostWith100msDelay: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), SimpleStressPath);

                //setup post data
                req.Method = "POST";

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.ResponseWait;
                tfd_req.Param = 100;

                byte[] bytes = tfd_req.ToArray();

                req.SetContentLengthAndBody(bytes);
                req.OtherHeaders.AddLast("Content-Type: text/xml");

                //send
                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 200);
                if (!CheckResponseAgainstURL(res, req.URI))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //single get with 1 client
        [StressInstantiate, StressTest(TargetTPS = 5)]
        public class SimpleGetBadAddress: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req=new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), "/test/thisdoesnotexist");

                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 404);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //post and retrieve 100k
        [StressInstantiate, StressTest(TargetTPS = 2)]
        public class SimpleLargeData: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());

                http.SendRequest(reqSimplelargeDataUpAndDown);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 200);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //auth required but not used
        [StressInstantiate, StressTest(TargetTPS = 2)]
        public class AuthGetNoAuth: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), AuthStressPath);

                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 401);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //auth required and auth of an xbl user used
        [StressInstantiate, StressTest(TargetTPS = 10)]
        public class AuthGetAuthXblUser: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), AuthStressPath);

                CachedTicket ct = GetCachedPassportTicket(true);
                if (ct == null)
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    return;
                }

                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ct.Ticket);

                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 200);
                if (!CheckResponseAgainstURL(res, req.URI))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //auth required and auth of a non-xbl user used
        [StressInstantiate, StressTest(TargetTPS = 4)]
        public class AuthGetAuthNonUser: TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), AuthStressPath);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + GetCachedPassportTicket(false).Ticket);

                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res, 200);
                if (!CheckResponseAgainstURL(res, req.URI))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [StressTest]
        [Description("Use a SAML token for auth.")]
        public class SSLAuthXblUser : TestNode
        {
            public override void Run()
            {
                // get saml auth token
                CachedTicket ct = GetCachedPassportTicket(true);
                if (ct == null)
                {
                    throw new DidNotExecuteException("No cached tickets to use.");
                }
                string token = ct.Ticket;

                // put info into C#'s requester
                string requestString = "https://" + SharedSetup.SSLHost + ":" + SharedSetup.SSLPort + AuthStressPath;
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                netreq.Headers.Add("Authorization: WLID1.0 t=" + token);
                netreq.KeepAlive = false;

                // add testfd request data
                netreq.Method = "POST";
                netreq.ContentType = "text/xml";

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                byte[] postData = tfd_req.ToArray();
                netreq.ContentLength = postData.Length;

                using (System.IO.Stream stream = netreq.GetRequestStream())
                {
                    stream.Write(postData, 0, postData.Length);
                }

                //try the request
                using (WebResponse netresp = netreq.GetResponse())
                {
                    // do nothing
                }
            }
        }

        [StressTest]
        [Description("Use a SAML token for auth.")]
        public class SSLAuthSaml : TestNode
        {
            private static X509Certificate2 Certificate = null;
            private static X509Certificate2Collection CertificateChain = null;

            static SSLAuthSaml ()
            {
                // load cert
                System.Reflection.Assembly asm = System.Reflection.Assembly.GetExecutingAssembly();
                System.IO.Stream certStream = asm.GetManifestResourceStream("certs.WM7Official.pfx");
                System.IO.BinaryReader certReader = new System.IO.BinaryReader(certStream);
                byte[] certBytes = certReader.ReadBytes((int)(certStream.Length));
                Certificate = new X509Certificate2(certBytes, "udc");

                // load store
                System.IO.Stream p7bStream = asm.GetManifestResourceStream("certs.WM7Official.p7b");
                System.IO.BinaryReader p7bReader = new System.IO.BinaryReader(p7bStream);
                byte[] p7bBytes = p7bReader.ReadBytes((int)(p7bStream.Length));
                CertificateChain = Certificates.OpenPKCS7(p7bBytes);
            }

            public static string GetCertDeviceId ()
            {
                return PirateSGTest.SharedSSLTests.ClientCertSSLUtil.GetCertDeviceId(Certificate);
            }

            public string GetSamlToken ()
            {
                return GetCachedPassportTicket(TicketCache.Saml).Ticket;
            }

            public override void PreRun ()
            {
                PirateSGTest.SharedSSLTests.ClientCertSSLUtil.AddCertChainToStore(CertificateChain);
            }

            public override void PostRun ()
            {
                PirateSGTest.SharedSSLTests.ClientCertSSLUtil.RemoveCertChainFromStore(CertificateChain);
            }

            public override void Run()
            {
                // get saml auth token
                string token = GetSamlToken();

                // put info into C#'s requester
                string requestString = "https://" + SharedSetup.SSLHost + ":" + SharedSetup.SSLPort + SamlAuthStressPath;
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                netreq.Headers.Add("Authorization: XBL1.0 x=" + token);
                netreq.KeepAlive = false;

                if (Certificate != null)
                {
                    netreq.ClientCertificates.Add(Certificate);
                }

                // add testfd request data
                netreq.Method = "POST";
                netreq.ContentType = "text/xml";

                TestFdReflectorRequest tfd_req = new TestFdReflectorRequest();
                tfd_req.CallerValue = TestFdReflectorRequest.Caller.AuthSG;
                tfd_req.ActionValue = TestFdReflectorRequest.Action.Reflect;

                byte[] postData = tfd_req.ToArray();
                netreq.ContentLength = postData.Length;

                using (System.IO.Stream stream = netreq.GetRequestStream())
                {
                    stream.Write(postData, 0, postData.Length);
                }

                //try the request
                using (WebResponse netresp = netreq.GetResponse())
                {
                    // do nothing
                }
            }
        }

        // xuid required and auth of an xbl user used
        [StressInstantiate, StressTest(TargetTPS = 10)]
        public class RequiresXuidGetXblUser : TestBase
        {
            protected override void Execute ()
            {
                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), RequiresXuidStressPath);

                CachedTicket ct = GetCachedPassportTicket(true);
                if (ct == null)
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    return;
                }

                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ct.Ticket);

                http.SendRequest(req);
                HttpClient.Response res = http.GetResponse();
                VerifyResponseCode(res, 200);
                if (!CheckResponseAgainstURL(res, req.URI))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // xuid required and auth of a non-xbl user used
        [StressInstantiate, StressTest(TargetTPS = 4)]
        public class RequiresXuidGetNonUser : TestBase
        {
            protected override void Execute ()
            {
                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), RequiresXuidStressPath);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + GetCachedPassportTicket(false).Ticket);

                http.SendRequest(req);
                HttpClient.Response res = http.GetResponse();
                VerifyResponseCode(res, 400);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // make requests against a throttled API
        [StressInstantiate, StressTest(TargetTPS = 10)]
        public class Throttled : TestBase
        {
            protected override void Execute ()
            {
                // get a user/ticket
                CachedTicket ct = GetCachedPassportTicket(false);

                // get our tracker
                ThrottleHistoryTracker tracker = ThrottleHistoryTracker.GetOrCreate(ct.Puid.ToString(), Throttle10By4StressPath);

                // see if we should back off a bit, overcalling won't help any
                double penalty = tracker.PenaltyTime;
                if (penalty > 10.0 && penalty > (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextDouble() * 20.0 + 10.0))
                {
                    // bump it so that the next time we even attempt to use this, it works
                    // asynchronous sleep!
                    ct.LastUseTime = DateTime.UtcNow.AddSeconds(penalty - PPCacheUseTime.TotalSeconds);
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    return;
                }

                // create request
                HttpClient http = new HttpClient(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), Throttle10By4StressPath);
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ct.Ticket);

                uint responsecode = tracker.Increment();
                http.SendRequest(req);

                // check response
                HttpClient.Response res = http.GetResponse();

                VerifyResponseCode(res, responsecode);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //single get with 1 client connection using ssl
        //TODO: All the ssl stuff needs cleaned up
        [StressInstantiate, StressTest(TargetTPS = 8)]
        public class SSLGet1: TestBase
        {
            protected override void Execute()
            {
                bool sslRequired=true;

                //put info into C#'s requester
                string requestString = "https://" + SharedSetup.SSLHost + ":" + SharedSetup.SSLPort +
                    (sslRequired ? SslStressPath : SimpleStressPath);
                
                //Global.RO.Debug("Request string: "+requestString);
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                netreq.KeepAlive = false;

                //try the request
                WebResponse netresp=netreq.GetResponse();

                //.NET will have a cow if we don't do this and SSL through their clunky client stops working
                netresp.GetResponseStream().Close();

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //10 gets with 1 client connection using ssl
        //TODO: All the ssl stuff needs cleaned up
        [StressInstantiate, StressTest(TargetTPS = 4)]
        public class SSLGet10: TestBase
        {
            protected override void Execute()
            {
                bool sslRequired=true;

                //put info into C#'s requester
                string requestString = "https://" + SharedSetup.SSLHost + ":" + SharedSetup.SSLPort +
                    (sslRequired ? SslStressPath : SimpleStressPath);
                
                //Global.RO.Debug("Request string: "+requestString);
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";

                for (int i=0; i<10; ++i)
                {
                    if (i == 9)
                    {
                        netreq.KeepAlive = false;
                    }

                    //try the request
                    WebResponse netresp=netreq.GetResponse();

                    //.NET will have a cow if we don't do this and SSL through their clunky client stops working
                    netresp.GetResponseStream().Close();
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //
        //TODO: All the ssl stuff needs cleaned up
        [StressInstantiate, StressTest(TargetTPS = 2)]
        public class SSLLargeData: TestBase
        {
            protected override void Execute()
            {
                bool sslRequired=true;

                //put info into C#'s requester
                string requestString = "https://" + SharedSetup.SSLHost + ":" + SharedSetup.SSLPort +
                    (sslRequired ? SslStressPath : SimpleStressPath);
                
                //Global.RO.Debug("Request string: "+requestString);
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                netreq.Method="POST";
                netreq.ContentType="text/xml";
                netreq.ContentLength=largeDataUpAndDown.Length;
                netreq.KeepAlive = false;

                netreq.GetRequestStream().Write(largeDataUpAndDown, 0, largeDataUpAndDown.Length);

                //try the request
                WebResponse netresp=netreq.GetResponse();

                byte []rawRespData=new byte[100*1024];
                int bytesRet=netresp.GetResponseStream().Read(rawRespData, 0, 100*1024);
                netresp.GetResponseStream().Close();

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //debug case: spit out stats
#if GatewayTests
        [StressInstantiate, StressTest(TargetTPS = 0)]
#else
        [StressInstantiate, StressTest(TargetTPS=0.1f)]
#endif
        public class DebugSpew: TestBase
        {
            protected override void Execute()
            {
                Global.RO.Debug("TicketCacheXblUser size: " + TicketCacheXblUser.Count);
                Global.RO.Debug("TicketCacheNonUser size: " + TicketCacheNonUser.Count);
                Global.RO.Debug("TicketCacheSaml size   : " + TicketCacheSaml.Count);
                Global.RO.Debug("TicketCacheXsts size   : " + TicketCacheXsts.Count);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //watches the eventlog for a crash event
        //Fails ONLY if the .NET crash line shows up in the event log.
        [StressInstantiate, StressTest(TargetTPS=0.0025f)]
        public class WatchForCrash: TestNode
        {
            private static EventMonitor monitor=null;

            public override void PreRun()
            {
                if (monitor==null)
                {
                    monitor=new EventMonitor(
                        SharedSetup.ServerList,
                        new string[]{""}, //any event
                        ".NET Runtime 2.0 Error Reporting", //in this source
                        "_aa_stress_events.txt"); //log to here
                }
            }

            public override void PostRun()
            {
                monitor=null;
            }

            public override void Run()
            {
                string []res=monitor.Poll();
                if (res!=null)
                {
                    throw new UnexpectedTestResultException("!-!-! Crash detected in eventlog !-!-!");
                }
            }
        }

        #endregion //Tests
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleDVT\ModuleDVT.cs ===
using System;
using System.Net;
using System.Web;
using System.Web.Hosting;
using System.IO;

using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace ModuleDVT
{

public class ModuleDVTTestBaseGroup : TestNode
{
    protected const ulong             c_ppuid      = 0x0102030405060708;
    protected const string            c_internetip = "10.20.30.40";
    protected const ulong             c_xuid       = 0x1112131415161718;

    protected XblUser                 _CachedUser  = null;
    
    protected UacsCommon2    uacs         = new UacsCommon2();

    // -------------------------------------------------------------------------
    // MarshallAAInfoToContext - yanked from AuthUtils.cs in ActiveAuthModule
    // -------------------------------------------------------------------------
    public static void MarshallToContext(
        HttpContext ctx, 
        ulong       passportPuid, 
        string      ipAddressInternet)
    {
        MarshallToContext(ctx, passportPuid, ipAddressInternet, 0);
    }

    public static void MarshallToContext(
        HttpContext ctx, 
        ulong       passportPuid, 
        string      ipAddressInternet,
        ulong       xuid)
    {
        ctx.Items[AAInfo.c_CtxKey_PassportPuid]      = passportPuid;
        ctx.Items[AAInfo.c_CtxKey_IpAddressInternet] = ipAddressInternet;
        if (xuid != 0)
        {
            ctx.Items[AAInfo.c_CtxKey_LiveXuid] = xuid;
        }
    }

    protected HttpContext NewHttpContext()
    {
        StringWriter output = new StringWriter();
        SimpleWorkerRequest request = new SimpleWorkerRequest(
            "/app",     // virtual dir
            "c:\app",   // physical dir
            "/page",    // page
            null,       // query
            output);   // output
        HttpContext.Current = new HttpContext(request);
        return HttpContext.Current;
    }

    protected XblUser NewUser()
    {
        if (_CachedUser != null)
            return _CachedUser;

        XblUserSettings userSettings = new XblUserSettings(
            UserType.Silver,
            true);         // use real passport?
        userSettings.CountryId = XeUser.Country.US;
        XblUser u = uacs.CreateUser(userSettings);

        _CachedUser = u;
        return u;
    }

    protected void AreEqual(AAInfo aa1, AAInfo aa2)
    {
        Assert.IsTrue(aa1 != null, " - AAInfo1");
        Assert.IsTrue(aa2 != null, " - AAInfo2");
        Assert.AreEqual(aa1.PassportPuid, aa2.PassportPuid, " - PassportPuid");
        Assert.AreEqual(aa1.IpAddressInternet, aa2.IpAddressInternet, " - IpAddressInternet");
        Assert.AreEqual(aa1.LiveXuid, aa2.LiveXuid, " - LiveXuid");
        Assert.AreEqual(aa1.CountryId, aa2.CountryId, " - CountryId");
        for (int i = 0; i < 256; i++)
        {
            Assert.IsTrue(aa1.HasPrivilege(i) == aa2.HasPrivilege(i), " - Privilege" + i.ToString());
        }
    }

    protected void AreEqual(AAInfo aa, XblUser u)
    {
        PassportInfo ppi = uacs.GetUserPassportInfo(u);
        XblUserSettings settings = uacs.GetUserSetting(u);

        Assert.IsTrue(aa != null, " - AAInfo");
        Assert.IsTrue(u != null, " - XblUser");
        Assert.AreEqual(aa.PassportPuid, ppi.PassportPuid, " - PassportPuid");
        Assert.IsTrue(aa.IsUserValid, " - IsUserValid");
        Assert.AreEqual(aa.LiveXuid, u.Puid, " - LiveXuid");
        Assert.AreEqual(aa.CountryId, (byte)settings.CountryId, " - CountryId");
        Assert.IsTrue(aa.HasPrivilege(252), " - Privilege 252 (valid)");
        Assert.IsTrue(!aa.HasPrivilege(100), " - Privilege 100 (invalid)");
    }
}

[TestGroup, DVT, Owner("dvt"), TestFrequency("Regression")]
public class AAInfoMiddleTierTests : ModuleDVTTestBaseGroup
{
    [TestCase]
    public void MarshallContext()
    {
        NewHttpContext(); 
        AAInfo aa = AAInfoMiddleTier.NewLocalInstance(0, null, null);
        
        Assert.IsTrue(!AAInfo.IsActiveAuthAvailable, " - !Available");
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip);
        
        Assert.IsTrue(AAInfo.TryMarshallFromContext(HttpContext.Current, ref aa));
        Assert.IsTrue(AAInfo.IsActiveAuthAvailable, " - Available");
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);

        Assert.IsTrue(AAInfo.IsInternetTier, " - internet tier");
        Assert.IsTrue(!AAInfo.IsMiddleTier, " - not middle tier");
    }

    [TestCase]
    public void MarshallContextWithXuid()
    {
        NewHttpContext(); 
        AAInfo aa = AAInfoMiddleTier.NewLocalInstance(0, null, null);
        
        Assert.IsTrue(!AAInfo.IsActiveAuthAvailable, " - !Available");
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip, c_xuid);
        
        Assert.IsTrue(AAInfo.TryMarshallFromContext(HttpContext.Current, ref aa));
        Assert.IsTrue(AAInfo.IsActiveAuthAvailable, " - Available");
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);
        Assert.AreEqual(aa.LiveXuid, c_xuid);

        Assert.IsTrue(AAInfo.IsInternetTier, " - internet tier");
        Assert.IsTrue(!AAInfo.IsMiddleTier, " - not middle tier");
    }

    [TestCase]
    public void MarshallHeadersWebClient()
    {
        AAInfo aa1 = AAInfoMiddleTier.NewLocalInstance(c_ppuid, null, c_internetip);
        AAInfo aa2 = AAInfoMiddleTier.NewLocalInstance(0, null, null);

        // The Marshall call fails. Can't Set headers. Bummer for testing.
        //NewHttpContext();
        //AAInfo.MarshallToHeaders(HttpContext.Current.Request.Headers, aa1);
        //Assert.IsTrue(AAInfo.TryMarshallFromHeaders(HttpContext.Current.Request.Headers, ref aa2));
        
        HttpContext.Current = null;
        WebClient client = new WebClient();
        AAInfo.MarshallToHeaders(client.Headers, aa1);
        Assert.IsTrue(AAInfo.TryMarshallFromHeaders(client.Headers, ref aa2));
        
        Assert.AreEqual(aa1.PassportPuid, aa2.PassportPuid, " - PassportPuid");
        Assert.AreEqual(aa1.IpAddressInternet, aa2.IpAddressInternet, " - IpAddressInternet");

        // Can't really test headers, unfortunately, without being able to set headers in 
        // HttpContext.Current.Request
        //Assert.IsTrue(!AAInfo.IsInternetTier, " - not internet tier");
        //Assert.IsTrue(AAInfo.IsMiddleTier, " - middle tier");
    }

    [TestCase]
    public void TestCurrent()
    {
        AAInfo aa;
        NewHttpContext();
      
        // Not in cache, context, or headers
        Assert.IsTrue(AAInfoMiddleTier.Current == null);
        Assert.IsTrue(HttpContext.Current.Items[typeof(AAInfoMiddleTier).AssemblyQualifiedName] == null);
        
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip);
       
        // From local context (2/3)
        aa = AAInfoMiddleTier.Current;

        // AAInfoMiddleTier no longer will grab from the context; it MUST grab from the 
        // http headers. Since we can't set the http headers in the HttpContext.Current 
        // location, we can't test this. Bummer. 
#if false
        Assert.IsTrue(aa != null);
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);

        // From cache (1/3)
        MarshallToContext(HttpContext.Current, c_ppuid + 1, c_internetip + "1");  // marshall bogus info
        Assert.IsTrue(HttpContext.Current.Items[typeof(AAInfoMiddleTier).AssemblyQualifiedName] != null);
        aa = AAInfoMiddleTier.Current;
        Assert.IsTrue(aa != null);
        // Should match old values, not new ones
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);
#else
        Assert.IsTrue(aa == null);
#endif 
    }

    [TestCase, Ignore]
    public void TestAllUserInfoFields()
    {
        AAInfo aa;
        NewHttpContext();
        XblUser u = NewUser();
        PassportInfo ppi = uacs.GetUserPassportInfo(u);
        XblUserSettings settings = uacs.GetUserSetting(u);
       
        // Insert into context
        MarshallToContext(HttpContext.Current, ppi.PassportPuid, c_internetip);

        // Pull out
        aa = AAInfoMiddleTier.Current;
        aa.UseXBanc = false;
        
        AreEqual(aa, u);
    }

    [TestCase, Ignore]
    public void TestInvalidUser()
    {
        AAInfo aa;
        NewHttpContext();
      
        // Insert into context
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip);
       
        // Pull out
        aa = AAInfoMiddleTier.Current;
       
        Assert.IsTrue(!aa.IsUserValid, " - !IsUserValid");
        Assert.AreEqual(aa.LiveXuid, 0, " - LiveXuid == 0");
        Assert.AreEqual(aa.CountryId, 0, " - CountryId == 0");
        Assert.IsTrue(!aa.HasPrivilege(252), " - Privilege 252 (valid)");
    }

    [TestCase]
    public void TestXBancFakeUser()
    {
        // Test a fake user
        AAInfo aa1 = AAInfoMiddleTier.NewLocalInstance(c_ppuid, c_xuid, c_internetip);
        aa1.UseXBanc = true;
        
        AAInfo aa2 = AAInfoMiddleTier.NewLocalInstance(c_ppuid, c_xuid, c_internetip);
        aa2.UseXBanc = true;

        AreEqual(aa1, aa2);
    }

    [TestCase, Ignore]
    public void TestXBancRealUser()
    {
        AAInfo aa1;
        NewHttpContext();
        XblUser u = NewUser();
        PassportInfo ppi = uacs.GetUserPassportInfo(u);
        XblUserSettings settings = uacs.GetUserSetting(u);
       
        // Insert into context
        MarshallToContext(HttpContext.Current, ppi.PassportPuid, c_internetip);

        // Pull out
        aa1 = AAInfoMiddleTier.Current;
        aa1.UseXBanc = true;
        AreEqual(aa1, u);

        // Create another object, see if it grabs from xbanc correctly
        AAInfo aa2 = AAInfoMiddleTier.NewLocalInstance(ppi.PassportPuid, u.Puid, c_internetip);
        aa2.UseXBanc = true;
        AreEqual(aa1, aa2);
    }

}

[TestGroup, DVT, Owner("dvt"), TestFrequency("Regression")]
public class AAInfoInternetTierTests : ModuleDVTTestBaseGroup
{
    [TestCase]
    public void MarshallContext()
    {
        NewHttpContext(); 
        AAInfo aa = AAInfoInternetTier.NewLocalInstance(0, null, null);
        
        Assert.IsTrue(!AAInfo.IsActiveAuthAvailable, " - !Available");
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip);
        
        Assert.IsTrue(AAInfo.TryMarshallFromContext(HttpContext.Current, ref aa));
        Assert.IsTrue(AAInfo.IsActiveAuthAvailable, " - Available");
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);

        Assert.IsTrue(AAInfo.IsInternetTier, " - internet tier");
        Assert.IsTrue(!AAInfo.IsMiddleTier, " - not middle tier");
    }

    [TestCase]
    public void MarshallContextWithXuid()
    {
        NewHttpContext(); 
        AAInfo aa = AAInfoInternetTier.NewLocalInstance(0, null, null);
        
        Assert.IsTrue(!AAInfo.IsActiveAuthAvailable, " - !Available");
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip, c_xuid);
        
        Assert.IsTrue(AAInfo.TryMarshallFromContext(HttpContext.Current, ref aa));
        Assert.IsTrue(AAInfo.IsActiveAuthAvailable, " - Available");
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);
        Assert.AreEqual(aa.LiveXuid, c_xuid);

        Assert.IsTrue(AAInfo.IsInternetTier, " - internet tier");
        Assert.IsTrue(!AAInfo.IsMiddleTier, " - not middle tier");
    }

    [TestCase]
    public void MarshallHeadersWebClient()
    {
        HttpContext.Current = null;
        WebClient client = new WebClient();
        AAInfo aa1 = AAInfoInternetTier.NewLocalInstance(c_ppuid, null, c_internetip);
        AAInfo aa2 = AAInfoInternetTier.NewLocalInstance(0, null, null);
        
        AAInfo.MarshallToHeaders(client.Headers, aa1);

        Assert.IsTrue(AAInfo.TryMarshallFromHeaders(client.Headers, ref aa2));
        Assert.AreEqual(aa1.PassportPuid, aa2.PassportPuid, " - PassportPuid");
        Assert.AreEqual(aa1.IpAddressInternet, aa2.IpAddressInternet, " - IpAddressInternet");
   
        // Can't really test headers, unfortunately
        //Assert.IsTrue(!AAInfo.IsInternetTier, " - not internet tier");
        //Assert.IsTrue(AAInfo.IsMiddleTier, " - middle tier");
    }

    [TestCase]
    public void MarshallHeadersWebClientWithXuid()
    {
        HttpContext.Current = null;
        WebClient client = new WebClient();
        AAInfo aa1 = AAInfoInternetTier.NewLocalInstance(c_ppuid, c_xuid, c_internetip);
        AAInfo aa2 = AAInfoInternetTier.NewLocalInstance(0, null, null);
        
        AAInfo.MarshallToHeaders(client.Headers, aa1);

        Assert.IsTrue(AAInfo.TryMarshallFromHeaders(client.Headers, ref aa2));
        Assert.AreEqual(aa1.PassportPuid, aa2.PassportPuid, " - PassportPuid");
        Assert.AreEqual(aa1.IpAddressInternet, aa2.IpAddressInternet, " - IpAddressInternet");
        Assert.AreEqual(aa1.LiveXuid, aa2.LiveXuid, " - Xuid");
    }

    [TestCase]
    public void TestCurrent()
    {
        AAInfo aa;
        NewHttpContext();
      
        // Not in cache, context, or headers
        Assert.IsTrue(AAInfoInternetTier.Current == null);
        Assert.IsTrue(HttpContext.Current.Items[typeof(AAInfoInternetTier).AssemblyQualifiedName] == null);
        
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip);
       
        // From local context (2/3)
        aa = AAInfoInternetTier.Current;
        Assert.IsTrue(aa != null);
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);

        // From cache (1/3)
        MarshallToContext(HttpContext.Current, c_ppuid + 1, c_internetip + "1");  // marshall bogus info
        aa = AAInfoInternetTier.Current;
        Assert.IsTrue(aa != null);
        // Should match old values, not new ones
        Assert.AreEqual(aa.PassportPuid, c_ppuid);
        Assert.AreEqual(aa.IpAddressInternet, c_internetip);
    }

    [TestCase]
    public void TestAllUserInfoFields()
    {
        AAInfo aa;
        NewHttpContext();
        XblUser u = NewUser();
        PassportInfo ppi = uacs.GetUserPassportInfo(u);
        XblUserSettings settings = uacs.GetUserSetting(u);
       
        // Insert into context
        MarshallToContext(HttpContext.Current, ppi.PassportPuid, c_internetip);

        // Pull out
        aa = AAInfoInternetTier.Current;
        
        AreEqual(aa, u);
    }


    [TestCase]
    public void TestInvalidUser()
    {
        AAInfo aa;
        NewHttpContext();
      
        // Insert into context
        MarshallToContext(HttpContext.Current, c_ppuid, c_internetip);
       
        // Pull out
        aa = AAInfoInternetTier.Current;
       
        Assert.IsTrue(!aa.IsUserValid, " - !IsUserValid");
        Assert.AreEqual(aa.LiveXuid, 0, " - LiveXuid == 0");
        Assert.AreEqual(aa.CountryId, 0, " - CountryId == 0");
        Assert.IsTrue(!aa.HasPrivilege(252), " - Privilege 252 (valid)");
    }

    [TestCase]
    public void TestXBancFakeUser()
    {
        // Test a fake user
        AAInfo aa1 = AAInfoInternetTier.NewLocalInstance(c_ppuid, c_xuid, c_internetip);
        aa1.UseXBanc = true;
        
        AAInfo aa2 = AAInfoInternetTier.NewLocalInstance(c_ppuid, c_xuid, c_internetip);
        aa2.UseXBanc = true;

        AreEqual(aa1, aa2);
    }

    [TestCase]
    public void TestXBancRealUser()
    {
        AAInfo aa1;
        NewHttpContext();
        XblUser u = NewUser();
        PassportInfo ppi = uacs.GetUserPassportInfo(u);
        XblUserSettings settings = uacs.GetUserSetting(u);
       
        // Insert into context
        MarshallToContext(HttpContext.Current, ppi.PassportPuid, c_internetip);

        // Pull out
        aa1 = AAInfoInternetTier.Current;
        aa1.UseXBanc = true;
        AreEqual(aa1, u);

        // Create another object, see if it grabs from xbanc correctly
        AAInfo aa2 = AAInfoInternetTier.NewLocalInstance(ppi.PassportPuid, u.Puid, c_internetip);
        aa2.UseXBanc = true;
        AreEqual(aa1, aa2);
    }


}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\Options.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace PirateSGTest
{
    [TestGroup, TestCasePriority(3), EnvRequirement("Manual")]
    public class TestSetupOptions: ActiveAuthTestBaseGroup
    {
        //
        [TestCase, Description("Turn on debug spew for the http client")]
        public void VerboseHttpOutput()
        {
            HttpClient.Verbose=true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\ActiveAuthTestBase.cs ===
using System;
using System.Net;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace PirateSGTest
{
    /// <summary>
    /// TestGroup base for PirateSG tests.
    /// </summary>
    public class ActiveAuthTestBaseGroup: TestNode
    {
        //test URIs for auth checks.  They key is the service policy name, and the value is a test url that requires it.
        public static Dictionary<string,string> TESTURI_AUTH=new Dictionary<string,string>();

        //policies that have dos (key is just a name, value is the path)
        public static Dictionary<string,string> TESTURI_DOS=new Dictionary<string,string>();

        public const string TEST_URI_REQUIRES_XUID = "/AAIFDReflector/test/xuid/requires";
        public const string TEST_URI_REQUIRES_XUID_INVALID = "/AAIFDReflector/test/xuid/requires/bad";

        public const string TEST_URI_THROTTLE_HL_0 = "/AAIFDReflector/test/throttle/hl0";
        public const string TEST_URI_THROTTLE_TH_0 = "/AAIFDReflector/test/throttle/th0";
        public const string TEST_URI_THROTTLE_HL_10_TH_4 = "/AAIFDReflector/test/throttle/hl10/th4";
        public const string TEST_URI_THROTTLE_HL_10_TH_4_STRESS = "/AAIFDReflector/test/stress/throttle10by4";
        public const string TEST_URI_THROTTLE_HL_20_TH_6 = "/AAIFDReflector/test/throttle/hl20/th6";
        public const string TEST_URI_THROTTLE_HL_1_TH_10 = "/AAIFDReflector/test/throttle/hl1/th10";

        //another simple non-auth policy
        public static readonly string TESTURI_NONE="/AAIFDReflector/test/simple2";

        //a very long lengthed policy
        public static readonly string TESTURI_LONG126="/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/len126";
        public static readonly string TESTURI_LONG127="/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/lenn127";
        public static readonly string TESTURI_LONG128="/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/lennn128";

        //static constructor - init constants lists
        static ActiveAuthTestBaseGroup()
        {
            //auth policies (setup in ActiveAuthSuite.cs)
            TESTURI_AUTH.Add("NONE","/AAIFDReflector/test/simple"); //special case - NONE means no authentication required
            TESTURI_AUTH.Add("SSL","/AAIFDReflector/test/ssl");
            //TESTURI_AUTH.Add("MBI_KEY_OLD","/AAIFDReflector/test/passport/mbikeyold"); //this one should not work for aa after all
            TESTURI_AUTH.Add("MBI","/AAIFDReflector/test/passport/mbi");
            TESTURI_AUTH.Add("LBI","/AAIFDReflector/test/passport/lbi");
            TESTURI_AUTH.Add("HBI","/AAIFDReflector/test/passport/hbi");
            TESTURI_AUTH.Add("HBI_60SECTEST","/AAIFDReflector/test/passport/hbi_60sectest");
            TESTURI_AUTH.Add("MBI_SSL","/AAIFDReflector/test/passport/mbissl");
            //TESTURI_AUTH.Add("LBI_SSL","/AAIFDReflector/test/passport/lbissl");
            //TESTURI_AUTH.Add("HBI_SSL","/AAIFDReflector/test/passport/hbissl");

            //dos policies (setup in ActiveAuthSuite.cs)
            TESTURI_DOS.Add("NODOS","/AAIFDReflector/test/dos/nodos");
            TESTURI_DOS.Add("NOAUTH","/AAIFDReflector/test/dos/noauth");
            TESTURI_DOS.Add("AUTH","/AAIFDReflector/test/dos/auth");
            TESTURI_DOS.Add("SSL","/AAIFDReflector/test/dos/ssl");

            // add policies that I want to be able to look up later
            ThrottleHistoryTracker.TEST_POLICIES.Add(TEST_URI_THROTTLE_HL_10_TH_4,
                new ActiveAuthHttpConfig.PolicyEntry(TEST_URI_THROTTLE_HL_10_TH_4, true, "LBI", false, false, false, true, 10, 4));
            ThrottleHistoryTracker.TEST_POLICIES.Add(TEST_URI_THROTTLE_HL_10_TH_4_STRESS,
                new ActiveAuthHttpConfig.PolicyEntry(TEST_URI_THROTTLE_HL_10_TH_4_STRESS, true, "MBI", false, false, false, true, 10, 4));
            ThrottleHistoryTracker.TEST_POLICIES.Add(TEST_URI_THROTTLE_HL_20_TH_6,
                new ActiveAuthHttpConfig.PolicyEntry(TEST_URI_THROTTLE_HL_20_TH_6, true, "LBI", false, false, false, true, 20, 6));
            ThrottleHistoryTracker.TEST_POLICIES.Add(TEST_URI_THROTTLE_HL_1_TH_10,
                new ActiveAuthHttpConfig.PolicyEntry(TEST_URI_THROTTLE_HL_1_TH_10, true, "LBI", false, false, false, true, 1, 10));
        }
    };

    /// <summary>
    /// Test base for PirateSG tests.
    /// </summary>
    abstract public class ActiveAuthTestBase: TestBase
    {
    }

    /// <summary>
    /// An exception in the module tests.
    /// </summary>
    public class ModuleTestException : Exception
    {
        public ModuleTestException (string message) : base(message) { }
        public ModuleTestException (string message, params object[] args) : base(string.Format(message, args)) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\DOSChecks.cs ===
using System;
using System.Data.SqlClient;
using System.Net;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Net.Cache;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Auth;

using AATest;

namespace PirateSGTest
{
    [TestGroup, TestFrequency("Regression"), Owner("JohnMcP")]
    public class DOSChecks: ActiveAuthTestBaseGroup
    {
        [TestGroupSetup]
        public static void Setup ()
        {
            AntiDosSettingUtils.SaveInitial();
        }

        [TestGroupTearDown]
        public static void Teardown ()
        {
            AntiDosSettingUtils.RevertToInitial();
        }

        /*//TODO: populate these dynamically based on the environment
        public static string RelayAddress="10.198.102.210"; //client 17 has the relay
        public static ushort RelayPort=30345;               //port 30345 relays to xeaasgiis001.

        // --

        //
        [TestCase, Description("Makes a couple hundred quick requests on a site with no dos protection and then verifies that a request succeeds")]
        public class NoDos: ActiveAuthTestBase
        {
            //sends out a request, but never checks on it
            public static void SimpleRequestMaker(uint num, object request)
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                http.SendRequest((HttpClient.Request)request);
            }

            protected override void Execute()
            {
                //do 200, 10ms apart
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_DOS["NODOS"]);
                ParallelRunner.Run(SimpleRequestMaker, 200, 40, req, 10);

                //check 1
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                http.SendRequest(req);
                ResponseVerification.CheckResponse(http.GetResponse(), 200, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        };

        //
        [TestCase, AsyncGroup(0), Description("Verifies that a simple request through the relay works.")]
        public class RelayTest: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(RelayAddress,RelayPort);
                HttpClient.Request req=new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(),TESTURI_DOS["NOAUTH"]);

                //send request
                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                if (res.Status!=200) throw new UnexpectedTestResultException("Response was not 200, was "+res.Status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //
        [TestCase, AsyncGroup(0), Description("Run stress over DoS threshold using a relay while running stress under the threshold locally.")]
        public class LocalStressAndRelayDoS: ActiveAuthTestBase
        {
            //locally run stress case (this will stop the scheduler at a certain point)
            public class StressTestMe: StressTestBase
            {
                protected override void Execute()
                {
                    //run control
                    if (endingMode)
                    {
                        ResultCode=TEST_RESULTS.NOT_EXECUTED;

                        if ((DateTime.Now - endModeStartDate)>new TimeSpan(0,0,5))
                        {
                            Global.RO.Debug("Stopping stress scheduler...");
                            scheduler.Stop();
                        }

                        return;
                    }

                    if (numMeRequests>100) //10s of time at 10tps
                    {
                        Global.RO.Debug("Waiting 5s for remaining requests to finish up.");
                        endingMode=true;
                        endModeStartDate=DateTime.Now;
                    }

                    //
                    System.Threading.Interlocked.Increment(ref numMeRequests);
                    HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(),ActiveAuthHttpConfig.GetServerPort());
                    HttpClient.Request req=new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(),TESTURI_DOS["NOAUTH"]);

                    //send request
                    http.SendRequest(req);
                    HttpClient.Response res=http.GetResponse();
                    if (res==null) throw new UnexpectedTestResultException("No response(me).");
                    if (res.Status!=200) throw new UnexpectedTestResultException("Response(me) was not 200, was "+res.Status);

                    System.Threading.Interlocked.Increment(ref numMeSuccesses);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            //relay stress case
            public class StressTestRelay: StressTestBase
            {
                protected override void Execute()
                {
                    if (endingMode)
                    {
                        ResultCode=TEST_RESULTS.NOT_EXECUTED;
                        return;
                    }

                    System.Threading.Interlocked.Increment(ref numRelayRequests);

                    HttpClient http=new HttpClient(RelayAddress,RelayPort);
                    HttpClient.Request req=new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(),TESTURI_DOS["NOAUTH"]);

                    //setup post data
                    req.Method="POST";
                    req.SetContentLengthAndBody(Reflector.CreateReflectorRequestBody(Reflector.RequestParameters.ResponseWait,(byte)(10))); //1s
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    //send request
                    try
                    {
                        http.SendRequest(req);
                    }
                    catch
                    {
                        System.Threading.Interlocked.Increment(ref numRelaySendErrors);
                        throw;
                    }

                    HttpClient.Response res=http.GetResponse();
                    if (res.Status!=200) throw new UnexpectedTestResultException("Response(relay) was not 200, was "+res.Status);

                    System.Threading.Interlocked.Increment(ref numRelaySuccesses);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            //stuff shared by all threads
            protected static StressSchedulerTPS scheduler;
            protected static int numMeRequests=0;
            protected static int numMeSuccesses=0;
            protected static int numRelayRequests=0;
            protected static int numRelaySuccesses=0;
            protected static int numRelaySendErrors=0;
            protected static bool endingMode=false;

            protected static System.DateTime endModeStartDate;

            //functional case
            protected override void Execute()
            {
                numMeRequests=0;
                numMeSuccesses=0;
                numRelayRequests=0;
                numRelaySuccesses=0;
                numRelaySendErrors=0;
                endingMode=false;

                //setup a list of stress jobs
                TestResultCollection results=new TestResultCollection();
                StressJobList jobs=new StressJobList();

                StressJob j0=new StressJob("DosTests", typeof(StressTestMe), results);
                j0.TargetTPS=10;
                jobs.AddJob(j0);

                StressJob j1=new StressJob("DosTests", typeof(StressTestRelay), results);
                j1.TargetTPS=10;
                jobs.AddJob(j1);

                //run the tps stress scheduler
                StressSettingsTPS settings=new StressSettingsTPS();
                settings.ReserveHighTPSThreadRatio=0.5f;
                settings.MaxThreads=200;
                scheduler=new StressSchedulerTPS();
                scheduler.Initialize(null, null, jobs, settings);
                try
                {
                    Global.RO.Debug("Starting stress scheduler...");
                    scheduler.Run(); //this is a blocking call
                }
                catch
                {
                    Global.RO.Debug("Stopping stress scheduler (exception)...");
                    scheduler.Stop();
                    scheduler=null;
                    throw;
                }
                scheduler=null;

                //verify the results of each job
                Global.RO.Info("Results for me:\n Requests total: "+numMeRequests+"\n Requests succeeded: "+numMeSuccesses);
                Global.RO.Info("Results for relay:\n Requests total: "+numRelayRequests+"\n Requests succeeded: "+numRelaySuccesses+"\n Send Errors: "+numRelaySendErrors);

                if (numMeRequests<100) throw new UnexpectedTestResultException("Non enough me requests total.");
                if (numMeSuccesses<numMeRequests) throw new UnexpectedTestResultException("Some me requests failed.");

                if (numRelayRequests<90) throw new UnexpectedTestResultException("Not enough relay requests total");
                if (numRelaySendErrors==0) throw new UnexpectedTestResultException("No relay requests failed to send.");
                if (numRelaySendErrors<40) throw new UnexpectedTestResultException("Not enough relay requests failed to send.");
                if (numRelaySuccesses>60) throw new UnexpectedTestResultException("Too many relay requests succeeded.");

                ResultCode = TEST_RESULTS.PASSED;
            }
        }*/



        /*
        //sends out a ssl http request, but never checks on it
        public static void SSLRequestMaker(uint num, object request)
        {
            HttpClient.Request req=(HttpClient.Request)request;

            //put out info into C#'s
            string requestString = "https://"+AAModuleSuite.DefaultIFDReflectorIP+":"+AAModuleSuite.DefaultIFDReflectorPort+req.URI;
            HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
            netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
            netreq.UserAgent = "STFLive.NET/0.1";
            
            //send it, swalling their garbage
            try
            {
                netreq.GetResponse();
            }
            catch (Exception e)
            {
                Global.RO.Debug(".NET http request threw(prolly ok):"+e.Message);
            }
        }

        //
        public static void ByteMultiRequestMaker(uint num, object bytes)
        {
            for (int i=0; i<100; ++i)
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                http.SendRequest((byte[])bytes);
            }
        }        

        //
        [TestCase, Description("Makes a couple hundred quick requests on a site with dos protection and then verifies that a request gets no response")]
        [CompoundCase("NoAuth NoTicket",   "NOAUTH", false)]
        [CompoundCase("NoAuth WithTicket", "NOAUTH", true)]
        [CompoundCase("Auth NoTicket",     "AUTH",   false)]
        [CompoundCase("Auth WithTicket",   "AUTH",   true)]
        public class DosHit: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                //do 200, 10ms apart
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_DOS[(string)MyValues[0]]);
                if ((bool)MyValues[1]) //add in a ticket
                {
                    string ticket=AuthClientBase.GetAAPassportTicket("xbltest-065e4793-94ff-456b-8f98-daa33bca40e6@example.com", "as13as13!!we421", "MBI");
                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+ticket);
                }

                ParallelRunner.Run(SimpleRequestMaker, 200, 200, req, 10);

                //check one
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                http.SendRequest(req);
                if (http.GetResponse()!=null) throw new Exception("Did NOT expect a response.");

                ResultCode = TEST_RESULTS.PASSED;
            }
        };

        //
        [TestCase, Description("Makes a couple hundred quick requests on a ssl site with dos protection and then verifies that a request gets no response")]
        public class SSL: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                //check one, it should work
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_DOS["SSL"]);
                string requestString = "https://"+AAModuleSuite.DefaultIFDReflectorIP+":"+AAModuleSuite.DefaultIFDReflectorPort+req.URI;
                HttpWebRequest netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";

                netreq.GetResponse();

                //do 200, 10ms apart
                ParallelRunner.Run(SSLRequestMaker, 200, 200, req, 20);

                //check one, it should throw
                requestString = "https://"+AAModuleSuite.DefaultIFDReflectorIP+":"+AAModuleSuite.DefaultIFDReflectorPort+req.URI;
                netreq = (HttpWebRequest)WebRequest.Create(requestString);
                netreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                netreq.UserAgent = "STFLive.NET/0.1";
                
                //it should throw since
                try
                {
                    netreq.GetResponse();
                }
                catch (WebException e)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                    Global.RO.Info("Exception(expected one) from .NET on final request: "+e.Message);
                    return;
                }

                ResultCode = TEST_RESULTS.FAILED;
            }
        };

        //
        [TestCase, Ignore, Description("Makes a couple hundred quick requests on a site with dos protection and then verifies that a request gets no response")]
        public class IncompleteRequestFlood: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                //send only the first line.. then.. nothing
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_DOS["NOAUTH"]);
                req.Host=null;
                req.UserAgent=null;
                List<byte> reqBytes=new List<byte>(req.ToBytes());
                reqBytes.RemoveRange(reqBytes.Count-2, 2); //cut off the closing second \r\n
                ParallelRunner.Run(ByteMultiRequestMaker, 1000, 500, reqBytes.ToArray(), 0);

                //check one
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_DOS["NOAUTH"]);
                http.SendRequest(req);
                ResponseVerification.CheckResponse(http.GetResponse(), 200, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        };*/

        [TestCase]
        [CompoundCase("Nothing", null, null, null, null, null, true, null)]
        [CompoundCase("Tracking Backwards", "10, 20", null, null, null, null, true, null)]
        [CompoundCase("Throttling Backwards", null, "20, 60", null, null, null, true, null)]
        [CompoundCase("Blocking Backwards", null, null, "90, 100", null, null, true, null)]
        [CompoundCase("Tracking 3", "30, 20, 10", null, null, null, null, true, null)]
        [CompoundCase("Throttling 1", null, "60", null, null, null, true, null)]
        [CompoundCase("Blocking 0", null, null, "", null, null, true, null)]
        [CompoundCase("Tracking Neg", "-1", null, null, null, null, true, null)]
        [CompoundCase("Thresholds Equal", "50", "50", "50", null, null, true, null)]
        [CompoundCase("Thresholds Reversed", "100, 90", "60, 20", "20, 10", null, null, true, null)]
        [CompoundCase("Threshold Order Check", null, "40, 20", "50, 40", null, null, true, null)]
        [CompoundCase("MaxRecords Neg", null, null, null, "-10000", null, true, null)]
        [CompoundCase("MaxRecords Zero", null, null, null, "0", null, true, null)]
        [CompoundCase("MaxRecords One", null, null, null, "1", null, true, null)]
        [CompoundCase("MaxRecords Billion", null, null, null, "1000000000", null, true, null)]
        [CompoundCase("BanTime Neg", null, null, null, null, "-5", true, null)]
        [CompoundCase("BanTime Zero", null, null, null, null, "0", true, null)]
        [CompoundCase("BanTime One", null, null, null, null, "1", true, null)]
        [CompoundCase("BanTime Two Minutes", null, null, null, null, "120", true, null)]
        [CompoundCase("Ips Simple Valid", null, null, null, null, null, true, new string[] { "ip=1.0.0.0" })]
        [CompoundCase("Ips Complex Valid", null, null, null, null, null, true, new string[] { "ip=2.0.0.0;ipEnd=3.0.0.0;count=10000" })]
        [CompoundCase("Ips Bad", null, null, null, null, null, true, new string[] { "ip=1.0.0.A" })]
        [CompoundCase("Ips Duplicate", null, null, null, null, null, true, new string[] { "ip=1.0.0.1", "ip=1.0.0.1" })]
        [CompoundCase("Ips Singular Range", null, null, null, null, null, true, new string[] { "ip=1.0.0.2;ipEnd=1.0.0.2" })]
        [CompoundCase("Ips Bad Param", null, null, null, null, null, true, new string[] { "ip=1.0.0.3;bad=badder" })]
        [CompoundCase("Ips Max Range", null, null, null, null, null, true, new string[] { "ip=0.0.0.0;ipEnd=255.255.255.255" })]
        [CompoundCase("Ips Overlap", null, null, null, null, null, true, new string[] { "ip=5.6.7.8;ipEnd=6.7.8.9", "ip=6.7.8.8;ipEnd=7.8.9.10" })]
        [CompoundCase("Ips Range Reversed", null, null, null, null, null, true, new string[] { "ipEnd=0.0.0.0;ip=255.255.255.255" })]
        //[CompoundCase("", null, null, null, null, null, true, null)]
        public class AntiDosSettings : TestNode
        {
            protected static string[] AuthSGServers = null;

            public override void PreRun()
            {
                AuthSGServers = Global.XEnv.GetServerListByInterface("authsg");
            }

            public override void Run()
            {
                Events event_check = new Events();
                event_check.Servers = AuthSGServers;

                if (!event_check.Init())
                {
                    throw new UnexpectedTestResultException("Our event object did not initialize properly.");
                }

                AntiDosSettingUtils.ApplySettings((MyValues[0] == null ? null : MyValues[0].ToString()),
                    (MyValues[1] == null ? null : MyValues[1].ToString()),
                    (MyValues[2] == null ? null : MyValues[2].ToString()),
                    (MyValues[3] == null ? null : MyValues[3].ToString()),
                    (MyValues[4] == null ? null : MyValues[4].ToString()), 
                    (bool) MyValues[5], (string[]) MyValues[6]);

                // have to wait a full minute to ensure that the settings made it there... sigh
                System.Threading.Thread.Sleep(60000);

                // make a simple request to check that the server is still there
                SimpleHttpRequests.SimpleGet();

                if (event_check.TestForChange("rejected by this component", false))
                {
                    Global.RO.Warn("One or more settings were rejected.");
                }

                if (event_check.TestForChange(".NET Runtime"))
                {
                    throw new UnexpectedTestResultException("The text '.Net Runtime' was found in an event on a server after we made a setting change and a request.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\ActiveAuthSuite.cs ===
using System;
using System.Collections.Generic;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;

[assembly: RootNode(typeof(PirateSGTest.AAModuleSuite))]

/*
The AAReflector MUST be set up on the websg box and the first pool box before running these tests, or everything will fail terribly.
See http://xblwiki/default.aspx/XboxLive/ActiveAuthReflector.html for details.
We need to find an automated way to set up the iis portion sometime.
*/

namespace PirateSGTest
{
    [Owner("LukeL"), TestFrequency("Daily"), EnvRequirement("AAIFDReflector"), TestCasePriority(1)]
    public class AAModuleSuite: TestNode
    {
        //default ifd reflector name and port
        public static readonly string IFDReflectorInterface="aaifdreflector";
        public static string DefaultIFDReflectorIP=""; //set on init
        public static ushort DefaultIFDReflectorPort=0; //set on init

        public static readonly string IFDReflectorInterface_SSL="aaifdreflector_ssl";
        public static string DefaultIFDReflectorIP_SSL=""; //set on init
        public static ushort DefaultIFDReflectorPort_SSL=0; //set on init

        //
        public override void PreRun(RUN_TYPE runType)
        {
            //setup options
            HttpClient.Verbose=false; //default to off... Options.cs can turn on

            //setup passport
            AuthClientBase.InitializePassportIDCRL();

            //setup cached server ip and port
            IPEndPoint ep=Global.XEnv.GetVirtualInterface(IFDReflectorInterface);
            DefaultIFDReflectorIP=ep.Address.ToString();
            DefaultIFDReflectorPort=(ushort)ep.Port;
            Global.RO.Debug("Default "+IFDReflectorInterface+": "+DefaultIFDReflectorIP+":"+DefaultIFDReflectorPort);

            //SSL tests were broken by a change to the aagateway tests.  For now I'm just making non-SSL part of the install since it's far easier.  Temporarily disabling SSL stuff.
            /*ep=Global.XEnv.GetVirtualInterface(IFDReflectorInterface_SSL);
            DefaultIFDReflectorIP_SSL=ep.Address.ToString();
            DefaultIFDReflectorPort_SSL=(ushort)ep.Port;
            Global.RO.Debug("Default "+IFDReflectorInterface_SSL+": "+DefaultIFDReflectorIP_SSL+":"+DefaultIFDReflectorPort_SSL);*/

            //override the "general test client" to use reflector
            ActiveAuthHttpConfig.OverrideServer(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);

            //setup test policies
            try
            {
                //add TESTURI_AUTH set
                foreach (KeyValuePair<string,string> pair in ActiveAuthTestBaseGroup.TESTURI_AUTH)
                {
                    ActiveAuthHttpConfig.PolicyEntry entry=new ActiveAuthHttpConfig.PolicyEntry();
                    entry.Path=pair.Value;
                    entry.AuthRequired=(pair.Key.Contains("NONE")?false:true);
                    entry.AuthPolicy=(pair.Key.Contains("NONE")?null:pair.Key);
                    entry.SSLRequired=(pair.Value.ToUpper().Contains("SSL"));
                    entry.AntiDOS=false;
                    ActiveAuthHttpConfig.SetPolicyEntry(entry);
                }

                //add TESTURI_DOS policies
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_DOS["NODOS"],  false, null, false, false));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_DOS["NOAUTH"], false, null, false, true));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_DOS["AUTH"],   true, "MBI", false, true));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_DOS["SSL"],    false, null, true,  true));

                //badness tests
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry("/AAIFDReflector/test/bug104565/throw1",  false, null, false, false));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry("/AAIFDReflector/test/bug104565/throw2",  false, null, false, false));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry("/AAIFDReflector/test/bug104565/exit1",   false, null, false, false));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry("/AAIFDReflector/test/bug104565/exit2",   false, null, false, false));

                //misc
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_NONE,    false, null, false, false));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_LONG126, false, null, false, false));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_LONG127, false, null, false, false));
                ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry(ActiveAuthTestBaseGroup.TESTURI_LONG128, false, null, false, false));

                // Requires Xuid and Throttling
                ActiveAuthHttpConfig.SetPolicyEntry(ActiveAuthTestBaseGroup.TEST_URI_REQUIRES_XUID, true, "LBI", false, false, true, false, 0, 0);
                ActiveAuthHttpConfig.SetPolicyEntry(ActiveAuthTestBaseGroup.TEST_URI_THROTTLE_HL_0, true, "LBI", false, false, false, true, 0, 2);
                ActiveAuthHttpConfig.SetPolicyEntry(ActiveAuthTestBaseGroup.TEST_URI_THROTTLE_TH_0, true, "LBI", false, false, false, true, 10, 0);

                foreach (ActiveAuthHttpConfig.PolicyEntry pe in ThrottleHistoryTracker.TEST_POLICIES.Values)
                {
                    ActiveAuthHttpConfig.SetPolicyEntry(pe);
                }

                //
                AAModuleReload();
            }
            catch (Exception e)
            {
                Global.RO.Fatal("Failed to set up policies in NPDB.  Most tests will probably not work.");
                Global.RO.Error("Exception: "+e.Message+"\n"+e.StackTrace);
            }

            if (runType==RUN_TYPE.STRESS)
            {
                SharedStressTests.SetupStress();
            }
        }

        public override void PostRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.STRESS)
            {
                SharedStressTests.EndStress();
            }

            DefaultIFDReflectorIP="";
            DefaultIFDReflectorPort=0;
        }

        /// <summary>
        /// Does an xmgmtc reload command on aamodule (to cause the policies to be reloaded)
        /// </summary>
        public static void AAModuleReload()
        {
            Global.RO.Info("Reloading aamodule ("+IFDReflectorInterface+").  This will fail(ok) if no appdomains are currently running...");

            string output;
            if (!ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(IFDReflectorInterface, IFDReflectorInterface, "aamodule reload", out output))
            {
                Global.RO.Warn("ExecuteOnIISProcess returned failed:\n"+output);
            }
            else
            {
                Global.RO.Debug(output);
            }
        }

        /// <summary>
        /// Does an xmgmtc config cache refresh on aamodule (to cause the settings to be updated)
        /// </summary>
        public static void AAModuleRefresh()
        {
            Global.RO.Info("Reloading aamodule ("+IFDReflectorInterface+").  This will fail(ok) if no appdomains are currently running...");

            string output;
            if (!ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(IFDReflectorInterface, IFDReflectorInterface, "aamodule configcacherefresh", out output))
            {
                Global.RO.Warn("ExecuteOnIISProcess returned failed:\n"+output);
            }
            else
            {
                Global.RO.Debug(output);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\PassportTests.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

namespace PirateSGTest
{
    [TestGroup, AsyncThreadDelay(250), AsyncThreadCount(25)]
    public class PassportTests: ActiveAuthTestBaseGroup
    {
        public static string PassportUserName=null;
        public static string PassportUserPW=null;
        public static ulong PassportUserPuid = 0;
        public static ulong PassportLiveXuid = 0;

        [TestGroupSetup]
        public void GroupSetup()
        {
            if (PassportUserName==null)
            {
                Global.RO.Debug("Creating a global cached passport user.");
                KdcUser user=AuthContext.MakeNewGenericUser(true, false);
                PassportUserName=user.Passport.UserName;
                PassportUserPW=user.Passport.Password;
                PassportUserPuid=user.Passport.Puid;
                PassportLiveXuid=user.UserID;

                Global.RO.Debug("Waiting on XCache to pick it up...");
                System.Threading.Thread.Sleep(11000);
            }

            //Sanity check since I've seen some weird behaviour lately...
            object val=UodbWS.ExecuteSQLScalar("select bi_user_puid from t_user_passport_puids where bi_user_passport_puid="+(long)PassportUserPuid, PassportUserPuid);
            if (val==null || val==DBNull.Value)
            {
                throw new UnexpectedTestResultException("Cached passport user creation is not working correctly.  This must be fixed prior to running any of the passport tests.");
            }
            Global.RO.Debug("Cached user passport puid: "+(long)PassportUserPuid);
            Global.RO.Debug("Cached user xbox puid: "+val);
        }

        /// <summary>Backing for NonXuidUserName.</summary>
        private static string _NonXuidUserName = null;
        /// <summary>Backing for NonXuidUserPW.</summary>
        private static string _NonXuidUserPW = null;
        /// <summary>Lock for CreateNonXuidUser.</summary>
        private static object _NonXuidUserLock = new object();

        /// <summary>Creates a passport account not associated with Live.</summary>
        private static void CreateNonXuidUser ()
        {
            lock (_NonXuidUserLock)
            {
                if (_NonXuidUserName == null || _NonXuidUserPW == null)
                {
                    UacsCommon.PassportUser ppu = (new UacsCommon()).CreatePassportUser();
                    _NonXuidUserName = ppu.MemberName;
                    _NonXuidUserPW = ppu.Password;
                }
            }
        }

        /// <summary>Passport account not associated with Live: Name.</summary>
        public static string NonXuidUserName
        {
            get
            {
                if (_NonXuidUserName == null) { CreateNonXuidUser(); }
                return _NonXuidUserName;
            }
        }

        /// <summary>Passport account not associated with Live: Password.</summary>
        public static string NonXuidUserPW
        {
            get
            {
                if (_NonXuidUserPW == null) { CreateNonXuidUser(); }
                return _NonXuidUserPW;
            }
        }

        //
        [TestCase, AsyncGroup(1), Description("Tries every combination of the different policies against what the server expects")]
        public class TicketPolicy: ActiveAuthTestBase
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                //string []methods={"GET","POST","HEAD"}; //xrlscan prevents us from testing HEAD
                string []methods={"GET","POST"};

                //generate matrix of combinations
                foreach (KeyValuePair<string,string> us in TESTURI_AUTH)
                {
                    foreach (KeyValuePair<string,string> them in TESTURI_AUTH)
                    {
                        foreach (string method in methods)
                        {
                            if (!us.Key.Contains("SSL") && !(us.Key.Contains("NONE") && them.Key.Contains("NONE")))
                                instances.Add(new CompoundCaseAttribute("Ticket="+us.Key+" Required="+them.Key+" Method="+method, us.Key, them.Key, method));
                        }
                    }
                }
            }

            protected override void Execute()
            {
                string ticketPolicy=(string)MyValues[0]; //used to get ticket
                string serverPolicy=(string)MyValues[1]; //the version the server expects to be used
                string method=(string)MyValues[2];

                //get ticket
                string ticket=null;
                if (ticketPolicy!="NONE") ticket=AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, ticketPolicy);

                //make request
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH[serverPolicy]);
                req.Method=method;

                if (method=="POST")
                {
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");
                }

                if (ticket!=null) req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+ticket);

                for (int pass=0; pass<2; ++pass) //we may want to check twice with a delay
                {
                    Global.RO.Debug("Making request...");
                    http.SendRequest(req);

                    //check response
                    HttpClient.Response res=http.GetResponse();

                    if (res!=null && res.GetHeaders("WWW-Authenticate").Length!=0) //check out the wlid header details if it gave us one
                    {
                        Dictionary<string,string> fields=ActiveAuthHttpClient.ParseWLIDHeader(res.GetSingleHeader("WWW-Authenticate"));
                        if (fields["policy"].ToUpper()!=serverPolicy)
                            throw new Exception("Server returned the wrong policy: "+fields["policy"]);
                    }

                    if (pass==0) //normal 1 pass for most
                    {
                        if (ticketPolicy==serverPolicy)
                            ResponseVerification.CheckResponse(res, 200, true);
                        else if (serverPolicy=="NONE")
                        {
                            ResponseVerification.CheckResponse(res, 200, true);
                            break;
                        }
                        else
                        {
                            if (serverPolicy.Contains("HBI") && !ticketPolicy.Contains("HBI")) //new RPS6 behaviour requires an HBI ticket for HBI calls regardless of ticket age
                            {
                                ResponseVerification.CheckResponse(res, 401);
                                ActiveAuthHttpClient.CheckWLIDHeader(res);
                            }
                            else if (ticketPolicy=="NONE" && !serverPolicy.Contains("SSL"))
                            {
                                ResponseVerification.CheckResponse(res, 401);
                                ActiveAuthHttpClient.CheckWLIDHeader(res);
                            }
                            else if (serverPolicy.Contains("SSL") && !ticketPolicy.Contains("SSL")) //if server requires ssl-obtained, but ticket wasn't
                                ResponseVerification.CheckResponse(res, 403);
                            else
                                ResponseVerification.CheckResponse(res, 200, true);
                        }
                    }
                    else //second pass for HBI_60SECTEST cases only
                    {
                        if (serverPolicy.Contains("HBI_60SECTEST"))
                        {
                            ResponseVerification.CheckResponse(res, 401);
                            ActiveAuthHttpClient.CheckWLIDHeader(res);
                        }
                        else if (serverPolicy.Contains("SSL") && !ticketPolicy.Contains("SSL")) //if server requires ssl-obtained, but ticket wasn't
                            ResponseVerification.CheckResponse(res, 403);
                        else
                            ResponseVerification.CheckResponse(res, 200);
                        break;
                    }

                    //verify backend context
                    if (res.Status==200)
                    {
                        AAReflectorResponse reflData=AAReflectorResponse.Create(res);
                        ResponseVerification.VerifyOriginalRequest(reflData, req);

                        if (serverPolicy.Contains("LBI") || serverPolicy.Contains("MBI") ||serverPolicy.Contains("HBI"))
                        {
                            ResponseVerification.CheckPassportContext(reflData, true);
                        }
                    }

                    //only HBI_60SECTEST needs a second attempt after 1 minute which should fail then
                    if (!(ticketPolicy.Contains("HBI_60SECTEST") || serverPolicy.Contains("HBI_60SECTEST"))) break;

                    Global.RO.Debug("Sleeping for a minute to verify HBI_60SECTEST ticket expiration.");
                    System.Threading.Thread.Sleep(65*1000);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        };

        //
        [TestCase]
        public void Get_PassportNoAuth()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["MBI"]);

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 401);
        }

        //
        [TestCase, Ignore, Description("old kdc key... should not work for aa")]
        public class Get_PassportAuth_MBI_KEY_OLD: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["MBI"]);

                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, "MBI_KEY_OLD"));

                http.SendRequest(req);
                ResponseVerification.CheckResponse(http.GetResponse(), 500);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("HBI ticket expiration test."), AsyncGroup(1), Ignore("Because it takes 6 minutes to run")]
        public void ExpiredHBITicket()
        {
            string ticket=AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, "HBI");

            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["HBI"]);
            req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+ticket);

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 200);

            //it expires in 5 minutes
            Global.RO.Debug("Waiting 6 minutes for ticket to expire.");
            System.Threading.Thread.Sleep(6*60*1000);

            http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 401);
        }

        //
        [TestCase, Description("Invalid Authorization lines")]
        [CompoundCase("NoTicket", "WLID1.0", 401)]
        [CompoundCase("NoTicketBlob", "WLID1.0 t=", 500)]
        [CompoundCase("WrongAuth Basic", "Basic", 401)]
        [CompoundCase("WrongAuth Negotiate", "Negotiate", 401)]
        [CompoundCase("WrongAuth NTLM", "NTLM", 401)]
        [CompoundCase("InvalidAuthType", "SuperFancyAuthOfDoom", 401)]
        [CompoundCase("InvalidAuthTypeWithParam", "SuperFancyAuthOfDoom Greatness=Rar", 401)]
        [CompoundCase("BadTicketBlob", "WLID1.0 t=AGreatFakeTicketBlob=", 500)]
        [CompoundCase("Blank", "", 401)]
        public class Get_PassportAuth_Invalid: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["MBI"]);

                req.OtherHeaders.AddFirst("Authorization: "+(string)MyValues[0]);

                http.SendRequest(req);
                ResponseVerification.CheckResponse(http.GetResponse(), (uint)(int)MyValues[1]);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //
        [TestCase]
        public void Get_PassportAuth_GarbageHeader_10MB()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["MBI"]);

            string bigBlob="abcdefghij";
            while (bigBlob.Length<1000*1000*10)
                bigBlob+=bigBlob;

            req.OtherHeaders.AddFirst("Authorization: "+bigBlob);

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 400);
        }

        //
        [TestCase]
        public void Get_PassportAuth_GarbageWLIDHeader_10MB()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["MBI"]);

            string bigBlob="abcdefghij";
            while (bigBlob.Length<1000*1000*10)
                bigBlob+=bigBlob;
            bigBlob+="=";

            req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+bigBlob);

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 400);
        }

        //
        [TestCase]
        [CompoundCase("Valid",  true, false)]
        [CompoundCase("DupeHeader",  true, true)]
        [CompoundCase("InvalidAuth",false, false)]
        public class NoAuthThenAuth: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                bool validRequest=(bool)MyValues[0];
                bool dupeHeader=(bool)MyValues[1];

                //send request without any auth info
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["MBI"]);

                http.SendRequest(req);

                //verify error code and the presense of a header telling us to authenticate
                HttpClient.Response res=http.GetResponse();
                ResponseVerification.CheckResponse(res, 401);

                ActiveAuthHttpClient.CheckWLIDHeader(res);
                Dictionary<string,string> fields=ActiveAuthHttpClient.ParseWLIDHeader(res.GetSingleHeader("WWW-Authenticate"));
                Global.RO.Debug("Policy returned is "+fields["policy"]);

                //send request with correct info
                string ticket;
                if (validRequest) ticket=AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, fields["policy"]);
                else ticket="Rar=";
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+ticket);
                if (dupeHeader) req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+ticket);
                http.SendRequest(req);

                res=http.GetResponse();
                ResponseVerification.CheckResponse(res, (uint)(validRequest?200:500));

                if (validRequest)
                {
                    if (res.GetHeaders("WWW-Authenticate").Length!=0)
                    {
                        throw new Exception("Did not expect a WWW-Authenticate header.");
                    }

                    AAReflectorResponse reflData=AAReflectorResponse.Create(res);
                    ResponseVerification.VerifyOriginalRequest(reflData, req);

                    string []vals=reflData.GetContextValues("AAInfo_IpAddressInternet");
                    ValueCheck.Test("AAInfo_IpAddressInternet context count", 1, vals.Length);

                    vals=reflData.GetContextValues("AAInfo_PassportPuid");
                    ValueCheck.Test("AAInfo_PassportPuid context count", 1, vals.Length);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        };

        //
        [TestCase, Description("Verifies that a regular passport ticket for the xsts delegation passport site cannot be used, since that site is only for delegation tokens.")]
        public class XstsPassportNotValid: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                string ticket=AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, "MBI", "xsts.test.xboxlive.com");
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+ticket);
                http.SendRequest(req);

                HttpClient.Response res=http.GetResponse();
                ResponseVerification.CheckResponse(res, (uint)(401));

                ResultCode = TEST_RESULTS.PASSED;
            }
        };

        /// <summary>
        /// These tests revolve around the b_requires_xuid functionality.
        /// </summary>
        [TestGroup]
        public class RequiresXuid : ActiveAuthTestBaseGroup
        {
            [TestCase, Description("A Passport only user attempts to connect when a Xuid is required and is blocked.")]
            public class PassportOnly : ActiveAuthTestBase
            {
                protected override void Execute ()
                {
                    // get ticket
                    string ticket = AuthClientBase.GetAAPassportTicket(NonXuidUserName, NonXuidUserPW, "LBI");

                    // make request
                    HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method = "POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                    http.SendRequest(req);

                    // check response
                    HttpClient.Response res = http.GetResponse();

                    ResponseVerification.CheckResponse(res, 400);

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("An Xbox user attempts to connect when a Xuid is required and is allowed.")]
            public class ValidXuid : ActiveAuthTestBase
            {
                protected override void Execute ()
                {
                    // get ticket
                    string ticket = AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, "LBI");

                    // make request
                    HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method = "POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                    http.SendRequest(req);

                    // check response
                    HttpClient.Response res = http.GetResponse();

                    ResponseVerification.CheckResponse(res, 200);

                    // check that the puid is correct
                    AAReflectorResponse refl_res = AAReflectorResponse.Create(res);
                    if (refl_res.AAInfo.PassportPuid != PassportUserPuid)
                    {
                        throw new ModuleTestException("Expected AAInfo.PassportPuid to be 0x{0:X}, got 0x{1:X}.",
                            PassportUserPuid, refl_res.AAInfo.PassportPuid);
                    }
                    if (refl_res.AAInfo.LiveXuid != PassportLiveXuid)
                    {
                        throw new ModuleTestException("Expected AAInfo.LiveXuid to be 0x{0:X}, got 0x{1:X}.",
                            PassportLiveXuid, refl_res.AAInfo.LiveXuid);
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("An Xbox user attempts to connect when a Xuid is required and is allowed, using the XSTS site id.  Xsts site is not in aamodule_rpsSiteNames and so this should fail.")]
            public class XSTSSite : ActiveAuthTestBase
            {
                protected override void Execute ()
                {
                    // get ticket
                    string ticket = AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, "LBI", "xsts.test.xboxlive.com");

                    // make request
                    HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method = "POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                    http.SendRequest(req);

                    // check response
                    HttpClient.Response res = http.GetResponse();

                    ResponseVerification.CheckResponse(res, 401);

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Attempt to insert an invalid policy, which should fail.")]
            public class InvalidPolicy_NoRequiresAuth_RequiresXuid : ActiveAuthTestBase
            {
                protected override void Execute ()
                {
                    try
                    {
                        ActiveAuthHttpConfig.SetPolicyEntry(TEST_URI_REQUIRES_XUID_INVALID, false, null, false, false, true, false, 0, 0);
                    }
                    // check both types of exceptions, just in case
                    catch (ServerTestFramework.Database.DatabaseException exc)
                    {
                        if (!exc.Message.Contains("ck_activeauth_requiresxuid_valid"))
                        {
                            throw;
                        }
                    }
                    catch (System.Data.SqlClient.SqlException exc)
                    {
                        if (!exc.Message.Contains("ck_activeauth_requiresxuid_valid"))
                        {
                            throw;
                        }
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// These are functional tests for ActiveAuth throttling.
        /// </summary>
        [TestGroup]
        public class Throttling : ActiveAuthTestBaseGroup
        {
            public struct PassportInfo
            {
                public string Username;
                public string Password;
                public string Ticket;
                public ulong Puid;
            }

            public static PassportInfo[] Users = null;

            [TestGroupSetup]
            public void Setup ()
            {
                // Create new users
                Users = new PassportInfo[2];
                UacsCommon uacs = new UacsCommon();

                for (int i = 0; i < 2; ++i)
                {
                    UacsCommon.PassportUser ppu = uacs.CreatePassportUser();
                    Users[i].Username = ppu.MemberName;
                    Users[i].Password = ppu.Password;
                    Users[i].Puid = ppu.PassportPuid;

                    Users[i].Ticket = AuthClientBase.GetAAPassportTicket(ppu.MemberName, ppu.Password, "LBI");
                }
            }

            /// <summary>
            /// Test base for the throttling functions.
            /// </summary>
            public class ThrottleTestBase : ActiveAuthTestBase
            {
                public void MakeCall (string username, string password, string url, uint responsecode)
                {
                    // get ticket
                    string ticket = AuthClientBase.GetAAPassportTicket(username, password, "LBI");

                    // make request
                    HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, url);

                    req.Method = "POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                    http.SendRequest(req);

                    // check response
                    HttpClient.Response res = http.GetResponse();

                    ResponseVerification.CheckResponse(res, responsecode);
                }

                /// <summary>
                /// Makes a call, adding data to the throttle history.
                /// </summary>
                /// <returns>
                /// True if the call _should_ have succeeded; false if not.
                /// DOES NOT INDICATE IF THE CALL ACTUALLY SUCCEEDED.
                /// </returns>
                public bool MakeThrottledCall (int user, string url)
                {
                    // get our tracker
                    ThrottleHistoryTracker tracker = ThrottleHistoryTracker.GetOrCreate(Users[user].Puid.ToString(), url);

                    // create request
                    HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, url);

                    req.Method = "POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + Users[user].Ticket);

                    uint responsecode = tracker.Increment();
                    http.SendRequest(req);

                    // check response
                    HttpClient.Response res = http.GetResponse();

                    ResponseVerification.CheckResponse(res, responsecode);

                    return (responsecode == ThrottleHistoryTracker.HttpResponseGood);
                }

                /// <summary>
                /// Makes a call, adding data to the throttle history.
                /// First sleeps the expected amount of time necessary for the call to be able to succeed.
                /// </summary>
                public void MakeThrottledCallWhenPossible (int user, string url)
                {
                    // get our tracker
                    ThrottleHistoryTracker tracker = ThrottleHistoryTracker.GetOrCreate(Users[user].Puid.ToString(), url);

                    // sleep for the amount of time required
                    int sleeptime = (int)(tracker.PenaltyTime * 1000.0);
                    Global.RO.Debug("Sleeping for {0} ms", sleeptime);
                    System.Threading.Thread.Sleep(sleeptime);

                    // create request
                    HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, url);

                    req.Method = "POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + Users[user].Ticket);

                    uint responsecode = tracker.Increment();
                    if (responsecode != ThrottleHistoryTracker.HttpResponseGood)
                    {
                        throw new ModuleTestException("We should expect to succeed here.");
                    }
                    http.SendRequest(req);

                    // check response
                    HttpClient.Response res = http.GetResponse();

                    ResponseVerification.CheckResponse(res, ThrottleHistoryTracker.HttpResponseGood);
                }
            }

            [TestCase, Description("Call a url with a throttle halflife of 0, should fail the XBanc call and allow us.")]
            public class Halflife_Zero : ThrottleTestBase
            {
                protected override void Execute ()
                {
                    MakeCall(Users[0].Username, Users[0].Password, TEST_URI_THROTTLE_HL_0, ThrottleHistoryTracker.HttpResponseGood);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Call a url with a throttle threshold of 0, should always block us.")]
            public class Threshold_Zero : ThrottleTestBase
            {
                protected override void Execute ()
                {
                    MakeCall(Users[0].Username, Users[0].Password, TEST_URI_THROTTLE_TH_0, ThrottleHistoryTracker.HttpResponseBlocked);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Call a url with a realistic throttle policy, the first call should always work.")]
            [CompoundCase(TEST_URI_THROTTLE_HL_10_TH_4, TEST_URI_THROTTLE_HL_10_TH_4)]
            [CompoundCase(TEST_URI_THROTTLE_HL_20_TH_6, TEST_URI_THROTTLE_HL_20_TH_6)]
            public class CallOnce : ThrottleTestBase
            {
                protected override void Execute ()
                {
                    if (!MakeThrottledCall(0, (string)MyValues[0]))
                    {
                        throw new ModuleTestException("We shouldn't have expected to be blocked...");
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Call until we expect to be blocked, make sure that last one is blocked.")]
            [CompoundCase(TEST_URI_THROTTLE_HL_10_TH_4, TEST_URI_THROTTLE_HL_10_TH_4)]
            [CompoundCase(TEST_URI_THROTTLE_HL_20_TH_6, TEST_URI_THROTTLE_HL_20_TH_6)]
            public class PredictBlock : ThrottleTestBase
            {
                protected override void Execute ()
                {
                    while (MakeThrottledCall(0, (string)MyValues[0])) ;

                    // check another url, we shouldn't be blocked there
                    if (!MakeThrottledCall(0, TEST_URI_THROTTLE_HL_1_TH_10))
                    {
                        throw new ModuleTestException("We shouldn't have expected to be blocked on the other url...");
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Call as fast as we can 10 times.  Then check that one quick one after is blocked.")]
            [CompoundCase(TEST_URI_THROTTLE_HL_10_TH_4, TEST_URI_THROTTLE_HL_10_TH_4)]
            [CompoundCase(TEST_URI_THROTTLE_HL_20_TH_6, TEST_URI_THROTTLE_HL_20_TH_6)]
            public class Sustain : ThrottleTestBase
            {
                protected override void Execute ()
                {
                    for (int i = 0; i < 10; ++i)
                    {
                        MakeThrottledCallWhenPossible(0, (string)MyValues[0]);
                    }

                    if (MakeThrottledCall(0, (string)MyValues[0]))
                    {
                        throw new ModuleTestException("We should have expected to be blocked...");
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Call 10 times after we have been blocked, make sure other user is ok.")]
            [CompoundCase(TEST_URI_THROTTLE_HL_10_TH_4, TEST_URI_THROTTLE_HL_10_TH_4)]
            [CompoundCase(TEST_URI_THROTTLE_HL_20_TH_6, TEST_URI_THROTTLE_HL_20_TH_6)]
            public class Overcall_OtherUserOk : ThrottleTestBase
            {
                protected override void Execute ()
                {
                    // first call until we should be blocked
                    while (MakeThrottledCall(0, (string)MyValues[0])) ;

                    // then 10 more times
                    for (int i = 0; i < 10; ++i)
                    {
                        if (MakeThrottledCall(0, (string)MyValues[0]))
                        {
                            throw new ModuleTestException("We should have expected to be blocked...");
                        }
                    }

                    // other user should be ok
                    if (!MakeThrottledCall(1, (string)MyValues[0]))
                    {
                        throw new ModuleTestException("We shouldn't have expected to be blocked with other user...");
                    }

                    // check another url, we shouldn't be blocked there
                    if (!MakeThrottledCall(0, TEST_URI_THROTTLE_HL_1_TH_10))
                    {
                        throw new ModuleTestException("We shouldn't have expected to be blocked on the other url...");
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Description("Call 10 times after we have been blocked, make sure new ticket doesn't unblock us.")]
            [CompoundCase(TEST_URI_THROTTLE_HL_10_TH_4, TEST_URI_THROTTLE_HL_10_TH_4)]
            [CompoundCase(TEST_URI_THROTTLE_HL_20_TH_6, TEST_URI_THROTTLE_HL_20_TH_6)]
            public class Overcall_NewTicketStillBlocked : ThrottleTestBase
            {
                protected override void Execute ()
                {
                    // first call until we should be blocked
                    while (MakeThrottledCall(0, (string)MyValues[0])) ;

                    // then 10 more times
                    for (int i = 0; i < 10; ++i)
                    {
                        if (MakeThrottledCall(0, (string)MyValues[0]))
                        {
                            throw new ModuleTestException("We should have expected to be blocked...");
                        }
                    }

                    // get a new ticket
                    string new_ticket = AuthClientBase.GetAAPassportTicket(Users[0].Username, Users[0].Password, "LBI");
                    if (new_ticket == Users[0].Ticket)
                    {
                        throw new ModuleTestException("New ticket is the same, this test won't work.");
                    }
                    Users[0].Ticket = new_ticket;

                    // still blocked
                    if (MakeThrottledCall(0, (string)MyValues[0]))
                    {
                        throw new ModuleTestException("We should have expected to be blocked...");
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestGroup]
        public class DelegationTokens: TestNode
        {
            public static void OverrideAppIdList(System.Array appIds)
            {
                Global.XEnv.ClearMultisettingOverride("aamodule_rpsDelegationAppIdAllowList");

                if (appIds.Length==0)
                {
                    Global.RO.Debug("Removed AppId whitelist override.");
                }
                else
                {
                    Global.RO.Debug("Changing AppId whitelist override to:");
                    foreach (object appId in appIds)
                    {
                        Global.RO.Debug("  "+appId);
                        Global.XEnv.AddMultisettingOverride("aamodule_rpsDelegationAppIdAllowList", appId.ToString());
                    }
                }

                AAModuleSuite.AAModuleRefresh();
            }

            MultisettingState originalSettingState=null;

            public override void PreRun()
            {
                originalSettingState=Global.XEnv.GetMultisettingOverrideState("aamodule_rpsDelegationAppIdAllowList");
            }

            public override void PostRun()
            {
                if (originalSettingState!=null)
                {
                    Global.XEnv.RestoreMultisettingOverrideState(originalSettingState);
                    originalSettingState=null;
                }
            }

            // --

            [TestCase, Description("An Xbox user attempts to connect when a Xuid is required and is allowed, using delegation token.")]
            [CompoundCase("xbox.basic",          "xbox.basic", "xsts.test.xboxlive.com",   true)]
            [CompoundCase("xbox.bad",            "xbox.bad",   "xsts.test.xboxlive.com",   false)]
            [CompoundCase("xbox.basic_badsite0", "xbox.basic", "kdc.xboxlive.com",         false)]
            [CompoundCase("xbox.basic_badsite1", "xbox.basic", "kdc.xblob.xboxlive.com",   false)]
            [CompoundCase("xbox.basic_badsite2", "xbox.basic", "kdc.test.xboxlive.com",    false)]
            [CompoundCase("xbox.basic_badsite3", "xbox.basic", "xuacs.xboxlive.com",       false)]
            [CompoundCase("xbox.basic_badsite4", "xbox.basic", "xuacs.xblob.xboxlive.com", false)]
            [CompoundCase("xbox.basic_badsite5", "xbox.basic", "xuacs.test.xboxlive.com",  false)]
            [CompoundCase("xbox.basic_badsite6", "xbox.basic", "live.test.xbox.com",       false)]
            [CompoundCase("xbox.basic_badsite7", "xbox.basic", "live.stress.xbox.com",     false)]
            [CompoundCase("xbox.basic_badsite8", "xbox.basic", "live.dev.xbox.com",        false)]
            public class Mainlines: TestNode
            {
                public override void PreRun()
                {
                    OverrideAppIdList(new ulong[]{12345});
                }

                public override void Run()
                {
                    string offerDotAction = (string)MyValues[0];
                    string rpsSite = (string)MyValues[1];
                    bool expectSuccess = (bool)MyValues[2];

                    // get ticket
                    string ticket = AuthClientBase.GetAAPassportDelegationTicketSelfGen(PassportUserName, (long)PassportUserPuid, rpsSite, offerDotAction, 12345, null);

                    // make request
                    HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method = "POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 d=" + ticket);

                    http.SendRequest(req);

                    // check response
                    HttpClient.Response res = http.GetResponse();
                    if (res != null)
                    {
                        Global.RO.Debug("Response: "+res.Status);
                    }

                    if (expectSuccess)
                    {
                        ResponseVerification.CheckResponse(res, 200);

                        // check that the puid is correct
                        AAReflectorResponse refl_res = AAReflectorResponse.Create(res);
                        if (refl_res.AAInfo.PassportPuid != PassportUserPuid)
                        {
                            throw new ModuleTestException("Expected AAInfo.PassportPuid to be 0x{0:X}, got 0x{1:X}.",
                                PassportUserPuid, refl_res.AAInfo.PassportPuid);
                        }
                        if (refl_res.AAInfo.LiveXuid != PassportLiveXuid)
                        {
                            throw new ModuleTestException("Expected AAInfo.LiveXuid to be 0x{0:X}, got 0x{1:X}.",
                                PassportLiveXuid, refl_res.AAInfo.LiveXuid);
                        }
                    }
                    else
                    {
                        ResponseVerification.CheckResponse(res, 401);
                    }
                }
            }

            [TestCase, Description("A valid whitelist is set.  Try different App Ids.")]
            [CompoundCase("Valid {0}",   (ulong)0x0000000000000001, true)]
            [CompoundCase("Valid {0}",   (ulong)0x0000000100000000, true)]
            [CompoundCase("Valid {0}",   (ulong)0x1000000000000000, true)]
            [CompoundCase("Valid {0}",   (ulong)0x8000000000000000, true)]
            [CompoundCase("Valid {0}",   (ulong)0xffffffffffffffff, true)]
            [CompoundCase("Invalid {0}", (ulong)0x0000000000000002, false)]
            [CompoundCase("Invalid {0}", (ulong)0x0000000100000001, false)]
            [CompoundCase("Invalid {0}", (ulong)0x1000000010000000, false)]
            [CompoundCase("Invalid {0}", (ulong)0x9000000000000000, false)]
            [CompoundCase("Invalid {0}", (ulong)0x0fffffffffffffff, false)]
            [CompoundCase("Invalid {0}", (ulong)0xfffffffffffffff0, false)]
            [CompoundCase("Invalid {0}", (ulong)0x00000000ffffffff, false)]
            [CompoundCase("Invalid {0}", (ulong)0xffffffff00000000, false)]
            [CompoundCase("Invalid {0}", (ulong)0x0000000000000000, false)]
            public class AppIdWhitelist: TestNode
            {
                public override void PreRun()
                {
                    OverrideAppIdList(new ulong[]{0x0000000000000001, 0x0000000100000000, 0x1000000000000000, 0x8000000000000000, 0xffffffffffffffff});
                }

                public override void Run()
                {
                    long appId=unchecked((long)(ulong)MyValues[0]);
                    bool expectSuccess=(bool)MyValues[1];

                    //get ticket
                    string ticket=AuthClientBase.GetAAPassportDelegationTicketSelfGen(PassportUserName, (long)PassportUserPuid, "xsts.test.xboxlive.com", "xbox.basic", appId, null);

                    //make request
                    HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method="POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 d="+ticket);

                    http.SendRequest(req);

                    //check response
                    HttpClient.Response res=http.GetResponse();
                    if (res!=null)
                    {
                        Global.RO.Debug("Response: "+res.Status);
                    }

                    if (expectSuccess)
                    {
                        ResponseVerification.CheckResponse(res, 200);
                    }
                    else
                    {
                        ResponseVerification.CheckResponse(res, 401);
                    }
                }
            }

            [TestCase, Description("AppId whitelist has invalid entries.  The valid entry should still work.")]
            [CompoundCase("Valid {0}",   (ulong)1, true)]
            [CompoundCase("Invalid {0}", (ulong)0, false)]
            [CompoundCase("Invalid {0}", (ulong)2, false)]
            [CompoundCase("Invalid {0}", (ulong)10, false)]
            public class AppIdListWhitelistInvalidEntries: TestNode
            {
                public override void PreRun()
                {
                    OverrideAppIdList(new string[]{"Here", "are", "a", "bunch", "of", "bad", "entries", "where", "1", "of", "them", "is", "actually", "valid."});
                }

                public override void Run()
                {
                    long appId=unchecked((long)(ulong)MyValues[0]);
                    bool expectSuccess=(bool)MyValues[1];

                    //get ticket
                    string ticket=AuthClientBase.GetAAPassportDelegationTicketSelfGen(PassportUserName, (long)PassportUserPuid, "xsts.test.xboxlive.com", "xbox.basic", appId, null);

                    //make request
                    HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method="POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 d=" + ticket);

                    http.SendRequest(req);

                    //check response
                    HttpClient.Response res=http.GetResponse();
                    if (res!=null)
                    {
                        Global.RO.Debug("Response: "+res.Status);
                    }

                    if (expectSuccess)
                    {
                        ResponseVerification.CheckResponse(res, 200);
                    }
                    else
                    {
                        ResponseVerification.CheckResponse(res, 401);
                    }
                }
            }

            [TestCase, Description("Validates that an expired delegation token is not accepted.")]
            public class ExpiredToken: TestNode
            {
                public override void PreRun()
                {
                    OverrideAppIdList(new ulong[]{123456});
                }

                public override void Run()
                {
                    //get ticket
                    string ticket=AuthClientBase.GetAAPassportDelegationTicketSelfGen(PassportUserName, (long)PassportUserPuid, "xsts.test.xboxlive.com", "xbox.basic", 123456, System.DateTime.UtcNow-new System.TimeSpan(0, 10, 0));

                    //make request
                    HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method="POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 d=" + ticket);

                    http.SendRequest(req);

                    //check response
                    HttpClient.Response res=http.GetResponse();
                    if (res!=null)
                    {
                        Global.RO.Debug("Response: "+res.Status);
                    }

                    ResponseVerification.CheckResponse(res, 401);
                }
            }

            [TestCase, Description("Validates that an RPS Ticket cannot pretend to be a delegation token.")]
            public class RPSTicketInsteadOfDelegationToken: TestNode
            {
                public override void Run()
                {
                    //get ticket
                    string ticket=AuthClientBase.GetAAPassportTicket(PassportUserName, PassportUserPW, "LBI");

                    //make request
                    HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method="POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 d=" + ticket);

                    http.SendRequest(req);

                    //check response
                    HttpClient.Response res=http.GetResponse();
                    if (res!=null)
                    {
                        Global.RO.Debug("Response: "+res.Status);
                    }

                    ResponseVerification.CheckResponse(res, 401);
                }
            }

            [TestCase, Description("Validates that a delegation token cannot pretend to be an RPS ticket.")]
            public class DelegationTokenInsteadOfRPSTicket: TestNode
            {
                public override void PreRun()
                {
                    OverrideAppIdList(new ulong[]{123456});
                }

                public override void Run()
                {
                    //get ticket
                    string ticket=AuthClientBase.GetAAPassportDelegationTicketSelfGen(PassportUserName, (long)PassportUserPuid, "xsts.test.xboxlive.com", "xbox.basic", 123456, null);

                    //make request
                    HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                    HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, TEST_URI_REQUIRES_XUID);

                    req.Method="POST";
                    req.SetContentLengthAndBody("Here's some content.");
                    req.OtherHeaders.AddLast("Content-Type: text/xml");

                    req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ticket);

                    http.SendRequest(req);

                    //check response
                    HttpClient.Response res=http.GetResponse();
                    if (res!=null)
                    {
                        Global.RO.Debug("Response: "+res.Status);
                    }

                    ResponseVerification.CheckResponse(res, 401);
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\Stress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using AATest;

namespace PirateSGTest
{
    [TestGroup]
    public partial class SharedStressTests: TestNode
    {
        //auth required and auth of an xbl user used, but no aainfo lookup
        [StressTest, StressInstantiate]
        public class AuthPostAuthXblUser_NoAAInfo : TestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(ActiveAuthHttpConfig.GetServerName(),ActiveAuthHttpConfig.GetServerPort());
                HttpClient.Request req = new HttpClient.Request(ActiveAuthHttpConfig.GetServerName(), "/AAIFDReflector/test/stress/auth");

                CachedTicket ct = GetCachedPassportTicket(true);
                if (ct == null)
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    return;
                }

                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t=" + ct.Ticket);

                //setup post data
                req.Method="POST";
                req.SetContentLengthAndBody(Reflector.CreateReflectorRequestBody(Reflector.RequestParameters.NoAAInfoLookup));
                req.OtherHeaders.AddLast("Content-Type: text/xml");

                //send request
                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                VerifyResponseCode(res,200);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //watches the eventlog for events that shouldn't happen
        //Fails ONLY if event is detected
        [StressTest(TargetTPS=0.005f)]
        public class WatchForBadEvents: TestNode
        {
            private static EventMonitor monitor=null;

            public override void PreRun()
            {
                if (monitor==null)
                {
                    monitor=new EventMonitor(
                        Global.XEnv.GetServerListByInterface(AAModuleSuite.IFDReflectorInterface),
                        new string[]{
                            "XBanc.Insert() caught exception",
                            "XBanc.Query() caught exception",
                            "Buffer cannot be null",
                            "object reference not set to an instance of an object",
                            "Cannot access a disposed object"},
                        null,
                        "_aam_stress_events.txt");
                }
            }

            public override void PostRun()
            {
                monitor=null;
            }

            public override void Run()
            {
                string []res=monitor.Poll();
                if (res!=null)
                {
                    foreach (string s in res)
                    {
                        Global.RO.Error("Bad event detected: "+s);
                    }
                    throw new UnexpectedTestResultException("Bad events detected.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\BadnessTests.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using AATest;

namespace PirateSGTest
{
    [TestGroup, TestCasePriority(3)]
    public class BadnessTests: ActiveAuthTestBaseGroup
    {
        [TestCase, Ignore, Description("Manual logfile check needed.  This is to help test bug 104565.  Makes a request then crashes the reflector.")]
        public void ManualCheckBug104565_LogThenThrow()
        {
            //Make Request
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,"/AAIFDReflector/test/bug104565/throw1");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);

            //Tell the reflector to crash
            req.URI="/AAIFDReflector/test/bug104565/throw2";
            req.SetContentLengthAndBody(Reflector.CreateReflectorRequestBody(Reflector.RequestParameters.ThrowUnhandledException));
            http.SendRequest(req);

            ResponseVerification.CheckResponse(http.GetResponse(), 500);

            //Now.. you.. yes you.. the guy reading this.  Go check the log for the above path and 404.
        }

        [TestCase, Ignore, Description("Manual logfile check needed.  This is to help test bug 104565.  Makes a request then tells the reflector to close the process.")]
        public void ManualCheckBug104565_LogThenExit()
        {
            //Make Request
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,"/AAIFDReflector/test/bug104565/exit1");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);

            //Tell the reflector to crash
            req.URI="/AAIFDReflector/test/bug104565/exit2";
            req.SetContentLengthAndBody(Reflector.CreateReflectorRequestBody(Reflector.RequestParameters.Exit));
            http.SendRequest(req);

            if (http.GetResponse()!=null)
            {
                throw new System.Exception("Did not expect a response from the second request... it should have closed the reflector process.");
            }

            //Now.. you.. yes you.. the guy reading this.  Go check the log for the above path and 404.
        }

        //they decided that module won't do filtering
        /*[TestCase, Description("AuthZ should never reach the back side of the module if it goes in the front")]
        [CompoundCase("1", "Authz: 123")]
        [CompoundCase("2", "AuthZ: 123")]
        [CompoundCase("3", "authz: 123")]
        [CompoundCase("4", "authZ: 123")]
        [CompoundCase("5", "AUTHZ: 123")]
        [CompoundCase("6", " Authz : 123")]
        [CompoundCase("7", "%20Authz%20: 123")]
        [CompoundCase("8", "Au%74hz: 123")]
        public class AuthzBlocking: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
                req.OtherHeaders.AddFirst((string)MyValues[0]);
                http.SendRequest(req);

                HttpClient.Response res=http.GetResponse();
                ResponseVerification.CheckResponse(res, 200);

                AAReflectorResponse reflres=AAReflectorResponse.Create(res);
                foreach (string s in reflres.HttpRequest.OtherHeaders)
                {
                    if (s.ToLower().Contains("authz"))
                    {
                        throw new System.Exception("authz was reflected back for case:\n"+(string)MyValues[0]);
                    }
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\UrlPolicyTests.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

namespace PirateSGTest
{
    [TestGroup, AsyncThreadDelay(400), AsyncThreadCount(50), TestCasePriority(2)]
    public class UrlPolicyVariations: ActiveAuthTestBaseGroup
    {
        //Xrlscan  is preventing us from testing many of these (commented out).  It would really be nice to be able to test these.
        [TestCase, Description("Various url tests")]
        [CompoundCase("Valid", "", 200)]
        [CompoundCase("SpaceSlash", " /", 400)]
        //[CompoundCase("Colon", ":", 400)]
        //[CompoundCase("Semicolon", ";", 404)]
        [CompoundCase("Percent", "%", 400)]
        [CompoundCase("SlashPercent", "/%", 400)]
        [CompoundCase("Quote", "\"", 400)]
        [CompoundCase("SlashQuote", "/\"", 400)]
        //[CompoundCase("LB", "\n", 400)]
        //[CompoundCase("RB", "\r", 400)]
        [CompoundCase("RBLB", "\r", 400)]
        [CompoundCase("Nullchar", "\0", 400)]
        [CompoundCase("SimpleQuery", "?someparam=1", 200)]
        [CompoundCase("LongQuery", "?test&verylongstring&extremelongstring&pyfgcrlaoeuidhtnsqjkxb&absurdlylongstring&thisisgettinglong&sillylongstring&long&lennnn129", 200)]
        [CompoundCase("LongURL126", "/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/len126", 200, false)]
        [CompoundCase("LongURL126Query", "/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/len126?butitisaquery=1", 200, false)]
        [CompoundCase("LongURL127", "/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/lenn127", 200, false)]
        [CompoundCase("LongURL127Query", "/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/lenn127?butitisaquery=1", 200, false)]
        [CompoundCase("LongURL128", "/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/lennn128", 200, false)]
        [CompoundCase("LongURL128Query", "/AAIFDReflector/test/verylongstring/extremelongstring/pyfgcxb/absurdlylongstring/thisisgettinglong/sillylongstring/long/lennn128?butitisaquery=1", 200, false)]

        public class SubPaths: ActiveAuthTestBase
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                //generate matrix of cases - xrlscan block most of this unfortunately, so it can't be tasted
                /*string []goodChars={"/","?","#"};
                Dictionary<string,string> charNames=new Dictionary<string,string>();
                charNames.Add("/","Slash");
                charNames.Add("?","Quest");
                charNames.Add("#","Pound");

                foreach (string a in goodChars)
                {
                    //decide on expected response as we build it
                    int ares=400; //most are bad
                    if (a=="/") ares=200; //trailing slashes are ignored
                    if (a=="?") ares=200; //ok for just this

                    instances.Add(new CompoundCaseAttribute(charNames[a], a, ares));

                    if (a=="?") ares=404; //adding more is now not found

                    foreach (string b in goodChars)
                    {
                        int bres=ares;
                        if (ares==200 && b=="#") bres=400; //pound badifies it

                        instances.Add(new CompoundCaseAttribute(charNames[a]+charNames[b], a+b, bres));

                        if (ares==200 && b=="?") bres=404; //adding more now is not found

                        foreach (string c in goodChars)
                        {   
                            int cres=bres;
                            if (bres==200 && c=="#") cres=400; //pound badifies it
            
                            instances.Add(new CompoundCaseAttribute(charNames[a]+charNames[b]+charNames[c], a+b+c, cres));
                        }
                    }
                }*/
            }

            protected override void Execute()
            {
                bool prefixDefault=true;
                if (MyValues.Length>2 && (bool)MyValues[2]==false) prefixDefault=false;

                string uri=(prefixDefault?TESTURI_AUTH["NONE"]:"")+(string)MyValues[0];
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,uri);
                http.SendRequest(req);

                HttpClient.Response res=http.GetResponse();
                ResponseVerification.CheckResponse(res, (uint)(int)MyValues[1]);
                if (res.GetHeaders("WWW-Authenticate").Length!=0) throw new Exception("Did not expect a WWW-Authenticate header to be returned.");

                Global.RO.Debug("Response was "+res.Status);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //
        [TestCase, Description("Configures 2 new paths, where 1 name is just the other ending in a /, then tries both.")]
        public void TwoSimilarPaths()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);

            //new add 2 new entries
            Global.RO.Info("Adding 2 new policies (one with no auth, one with mbi required)...");
            ActiveAuthHttpConfig.PolicyEntry entry=new ActiveAuthHttpConfig.PolicyEntry();
            entry.Path="/AAIFDReflector/test/random/"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(10);
            ActiveAuthHttpConfig.SetPolicyEntry(entry);
            string path0=entry.Path;
            
            entry.Path+="/";
            entry.AuthRequired=true;
            entry.AuthPolicy="MBI";
            ActiveAuthHttpConfig.SetPolicyEntry(entry);
            string path1=entry.Path;

            AAModuleSuite.AAModuleReload();

            //try both now
            HttpClient.Request req0=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,path0);
            HttpClient.Request req1=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,path1);
            
            Global.RO.Info("Trying "+path0+" (no auth)");
            http.SendRequest(req0);
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req0);

            Global.RO.Info("Trying "+path1+" (auth)");
            http.SendRequest(req1);
            ResponseVerification.CheckResponse(http.GetResponse(), 401);
        }

        //
        [TestCase, Description("Configures regex path, then tries positive and negative cases.")]
        public void RegexPath()
        {
            HttpClient http = new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);

            string path0 = "/AAIFDReflector/test/random/" + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(10);
            string path1 = "/AAIFDReflector/badpath/random/" + ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(10);

            //new regex entry
            Global.RO.Info("Adding regex policies ...");
            ActiveAuthHttpConfig.PolicyEntry entry = new ActiveAuthHttpConfig.PolicyEntry();
            entry.Path = "/AAIFDReflector/test/random/[^/]+$";
            entry.AuthRequired = false;
            entry.RegexOrder = 1;
            ActiveAuthHttpConfig.SetPolicyEntry(entry);
            // Add a second regex entry
            entry.Path = "/AAIFDReflector/test/random2/[^/]+$";
            ActiveAuthHttpConfig.SetPolicyEntry(entry);

            AAModuleSuite.AAModuleReload();

            //try the good path
            HttpClient.Request req0 = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, path0);

            Global.RO.Info("Trying " + path0);
            http.SendRequest(req0);
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req0);

            //try the bad path
            HttpClient.Request req1 = new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP, path1);

            Global.RO.Info("Trying " + path1);
            http.SendRequest(req1);
            ResponseVerification.CheckResponse(http.GetResponse(), 404);
        }

        //
        [TestCase, Description("configures a new path, tries it, then removes it and tries it again")]
        public void AddThenRemove()
        {
            //add a new policy and try it
            Global.RO.Info("Adding a new policy...");
            ActiveAuthHttpConfig.PolicyEntry entry=new ActiveAuthHttpConfig.PolicyEntry();
            entry.Path="/AAIFDReflector/test/random/"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(7);
            ActiveAuthHttpConfig.SetPolicyEntry(entry);
            AAModuleSuite.AAModuleReload();

            Global.RO.Info("Trying it...");
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,entry.Path);
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);
            
            //remove the policy and try it again
            Global.RO.Info("Removing the policy...");
            ActiveAuthHttpConfig.RemovePolicyEntry(entry.Path);
            AAModuleSuite.AAModuleReload();

            Global.RO.Info("Trying it...");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 404);            
        }

        //
        [TestCase, Description("Seperates 2 requests with a null character to try to hide the second one")]
        public void NullcharHiddenRequest()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);

            //start with a second request for an auth resource since we need to know it's length
            HttpClient.Request req2=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["MBI"]);
            byte []req2Bytes=req2.ToBytes();

            //make some padding data to fill in the rest
            int padLen=req2Bytes.Length+1;
            byte []junkBody=new byte[padLen];
            for (int i=0; i<junkBody.Length; ++i)
                junkBody[i]=(byte)'r';

            //now construct the first request for a non-auth resource
            HttpClient.Request req1=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            
            //now piece them together...
            List<byte> reqBytes=new List<byte>(req1.ToBytes());
            reqBytes.RemoveRange(reqBytes.Count-2, 2); //cut off the closing second \r\n
            reqBytes.Add((byte)0); //add a null
            reqBytes.AddRange(req2Bytes); //add our auth request in here
            reqBytes.AddRange(junkBody); //now the junk decoy body

            //check response
            http.SendRequest(reqBytes.ToArray());
            ResponseVerification.CheckResponse(http.GetResponse(), 400);

            //do we also get another response...?
            if (http.GetResponse(false)!=null) throw new Exception("We should not have gotten a second response.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\ModuleTests\SimpleHttpRequests.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.LiveService.Auth;

namespace PirateSGTest
{
    [TestGroup]
    public class SimpleHttpRequests: ActiveAuthTestBaseGroup
    {
        //
        [TestCase]
        public static void SimpleGet()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            http.SendRequest(req);
            
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);
        }

        //
        [TestCase]
        public void MultipleGets()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.UserAgent=null;
            HttpClient.Request req2=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_NONE);
            req2.OtherHeaders.AddFirst("SuperHeaderOfDoom: Yes");

            for (int i=0; i<10; ++i)
            {
                http.SendRequest(req);
                ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);

                http.SendRequest(req2);
                ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req2);
            }
        }

        [TestCase,Ignore] //xrlscan prevents us from testing this
        public void SimpleHead()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.Method="HEAD";

            //do twice to ensure that if it sends a body back, the second time we'll hit that gunk
            for (int i=0; i<2; ++i)
            {            
                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse(false);
                ResponseVerification.CheckResponse(res, 200, false);
                if (int.Parse(res.GetSingleHeader("Content-Length"))<=0) throw new Exception("Expected Content-Length header to contain the length.");
            }
        }

        [TestCase,Ignore] //xrlscan prevents us from testing this
        public void SimpleTrace()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.Method="TRACE";
            http.SendRequest(req);
            HttpClient.Response res=http.GetResponse(false);
            ResponseVerification.CheckResponse(res, 200, true);

            if (!res.ContentString.Contains(req.UserAgent)) throw new Exception("Echoed response body did not contain the user-agent.");
            if (!res.ContentString.Contains(req.Version)) throw new Exception("Echoed response body did not contain the http version");
            if (!res.ContentString.Contains(req.Method)) throw new Exception("Echoed response body did not contain the http method");
            if (!res.ContentString.Contains(req.URI)) throw new Exception("Echoed response body did not contain the uri");
            if (!res.ContentString.Contains(req.Host)) throw new Exception("Echoed response body did not contain the Host");
        }

        [TestCase,Ignore] //xrlscan prevents us from testing this
        public void SimplePost()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.Method="POST";
            req.SetContentLengthAndBody("I'm posting to you.  Beware the Ides of March.  And beware the march of the grass.");
            http.SendRequest(req);

            HttpClient.Response res=http.GetResponse();
            ResponseVerification.CheckResponse(res, 200, true);
            ResponseVerification.VerifyOriginalRequest(AAReflectorResponse.Create(res), req);
        }

        [TestCase,Ignore] //xrlscan prevents us from testing this
        public void SimpleOptions()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.Method="OPTIONS";
            http.SendRequest(req);
            HttpClient.Response res=http.GetResponse();
            ResponseVerification.CheckResponse(res, 200, false);
        }

        [TestCase]
        public void SimplePostWithType()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="POST";
            req.SetContentLengthAndBody("I'm posting to you.  Beware the Ides of March.  And beware the march of the grass.");
            req.OtherHeaders.AddLast("Content-Type: text/xml");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);
        }

        [TestCase]
        //                  MB  Resp Reflection?
        [CompoundCase("3MB", 3, 200, true)]
        [CompoundCase("4MB", 4, 200, true)]
        [CompoundCase("5MB", 5, 500, false)] //Anything more than 4MB is currently rejected early and never makes it through to aamodule.
        public class PostLarge: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

                req.Method="POST";

                //build a string of the appropriate size.. C# makes this a pain.
                StringBuilder grr=new StringBuilder((int)MyValues[0]*1024*1024);
                string string32="Random Post Data.XRLScan is evil";
                for (int i=0; i<1024/32; ++i) grr.Append(string32);
                string string1K=grr.ToString();
                grr.Remove(0,grr.Length); //clear
                for (int i=0; i<(int)MyValues[0]*1024; ++i) grr.Append(string1K);
                string bodyData=grr.ToString();

                //
                req.SetContentLengthAndBody(bodyData);
                req.OtherHeaders.AddLast("Content-Type: text/xml");
                http.SendRequest(req);
                HttpClient.Response res=http.GetResponse();
                ResponseVerification.CheckResponse(res, (uint)(int)MyValues[1]);

                if ((bool)MyValues[2]) //verify reflection?
                {
                    ResponseVerification.VerifyOriginalRequest(AAReflectorResponse.Create(res), req);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Posts 100k and asks the reflector to send us another 100k back")]
        public void Send100KRecieve100K()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            byte []Data100KGet100K=new byte[100*1024];
            byte []command=AATest.Reflector.CreateReflectorRequestBody(AATest.Reflector.RequestParameters.OutputBody,(ushort)100);
            System.Buffer.BlockCopy(command,0,Data100KGet100K,0,command.Length);
            req.Method="POST";
            req.ContentLength=Data100KGet100K.Length.ToString();
            req.Content=Data100KGet100K;
            req.OtherHeaders.AddLast("Content-Type: text/xml");

            http.SendRequest(req);
            HttpClient.Response res=http.GetResponse();
            ResponseVerification.CheckResponse(res,200);

            //AAReflectorResponse refres=AAReflectorResponse.Create(res);
            //if (refres==null) throw new System.Exception("Response was not from the reflector");
            //if (refres.HttpRequest.ContentLength!=(100*1024).ToString()) throw new System.Exception("reflected has wrong content length: "+refres.HttpRequest.ContentLength);
            
            string cl=res.GetSingleHeader("Content-Length");
            uint clen=uint.Parse(cl);

            if (clen!=100*1024) throw new System.Exception("Response was not the correct length: "+clen);
        }

        //
        [TestCase, Description("over 2 tcp packets")]
        public void SplitGet()
        {
            //generate request string and break it in half
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            byte []reqBlob=req.ToBytes();

            uint part0Len=(uint)reqBlob.Length/2;
            uint part1Len=(uint)reqBlob.Length-part0Len;
            byte []part0=new byte[part0Len], /*[]*/part1=new byte[part1Len];
            Array.Copy(reqBlob, 0, part0, 0, part0Len);
            Array.Copy(reqBlob, part0Len, part1, 0, part1Len);
            
            //disable the nagle algorithm, so that both halves of the request go out in different packets
            http.Socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);

            //send both halves
            http.Connect();
            http.Socket.Send(part0);
            http.Socket.Send(part1);

            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);
        }

        //
        [TestCase]
        public void GetWithContent()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="GET";
            req.SetContentLengthAndBody("I'm getting you... but with content! Beware the Ides of March.  And beware the march of the sand particles.");
            req.OtherHeaders.AddLast("Content-Type: text/xml");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);
        }

        //
        [TestCase]
        public void SimpleNotConfiguredPath()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,"/notconfiguredpath");

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 404);
        }

        //
        [TestCase]
        public void SimpleRootPath()
        {
            //shouldn't ever be configured...
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,"/");

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 403); //Since the move to the installer-reflector and use of a vdir, the root gives 403 rather than 404 now
        }

        //
        [TestCase]
        public void RootVDirPath()
        {
            //shouldn't ever be configured...
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,"/AAIFDReflector");

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 404);
        }

        //
        [TestCase,Ignore] //xrlscan prevents us from testing this
        public void BadVerb()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="CLAW";
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 400);
        }

        //
        [TestCase, Ignore] //this test has never passed.. putting it on ignore for now
        public void ExtendedCharInHeader()
        {
            //build basic request
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.UserAgent="Test-Agent";

            //convert to bytes and change there... we have to work in bytes to get around C#'s rediculous unicode stuff.
            byte []reqBytes=req.ToBytes();
            byte []agentBytes=ByteEncoding.Instance.GetBytes(req.UserAgent);
            int agentInd=ArrayEx.SearchByteArray(reqBytes, agentBytes, 0);
            if (agentInd==-1) throw new System.Exception("indexing error in test");
            agentBytes[4]=150; //funky u in place of dash
            reqBytes[agentInd+4]=150;

            //send and verify
            http.SendRequest(reqBytes);
            HttpClient.Response resp=http.GetResponse();
            ResponseVerification.CheckResponse(resp, 200);

            AAReflectorResponse refl=AAReflectorResponse.Create(resp);
            if (refl==null) throw new UnexpectedTestResultException("Response was not from reflector.");

            int i=ArrayEx.SearchByteArray(refl.RawHttpRequest,ByteEncoding.Instance.GetBytes("User-Agent:"),0) + 11;
            List<byte> retAgent=new List<byte>();
            while (refl.RawHttpRequest[i]==32) //skip leading spaces
                ++i;

            while (refl.RawHttpRequest[i]!=10 && refl.RawHttpRequest[i]!=13) //until line break
            {
                retAgent.Add(refl.RawHttpRequest[i]);
                ++i;
            }

            while (retAgent[retAgent.Count-1]==32) //remove trailing spaces
                retAgent.RemoveAt(retAgent.Count-1);

            byte []retAgentBytes=retAgent.ToArray();
            if (!ArrayEx.Compare(agentBytes,retAgentBytes))
            {
                string errstr="Sent agent did not match reflected agent.\n";
                errstr+="sent bytes: ";
                foreach (byte b in agentBytes)
                {
                    errstr+=string.Format("{0:X}",b);
                }
                errstr+=" ("+ByteEncoding.Instance.GetString(agentBytes)+")\n";
                errstr+="refl bytes: ";
                foreach (byte b in retAgentBytes)
                {
                    errstr+=string.Format("{0:X}",b);
                }
                errstr+=" ("+ByteEncoding.Instance.GetString(retAgentBytes)+")";

                throw new UnexpectedTestResultException(errstr);
            }
        }

        //Just to prove that we can send a smaller amountn of data to cause a larger amount to be handled by the server
        /*[TestCase]
        public void ExtendedCharInHeaderLots()
        {
            //build basic request
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.UserAgent="Test-Agent";

            //convert to bytes and change there... we have to work in bytes to get around C#'s rediculous unicode stuff.
            byte []reqBytes=req.ToBytes();
            List<byte> bytes=new List<byte>(reqBytes);

            //trim off the last crlf
            bytes.RemoveAt(bytes.Count-1);
            bytes.RemoveAt(bytes.Count-1);

            //add a bunch of "funky u" headers
            for (int i=0; i<530; ++i)
            {
                string hname="h"+i+": ";
                bytes.InsertRange(bytes.Count,ByteEncoding.Instance.GetBytes(hname));

                for (int c=0; c<25; ++c)
                    bytes.Add(128);

                bytes.Add(13);
                bytes.Add(10);
            }

            bytes.Add(13);
            bytes.Add(10);

            //send and verify
            http.SendRequest(bytes.ToArray());
            HttpClient.Response resp=http.GetResponse();
            ResponseVerification.CheckResponse(resp, 200);
        }*/

        //
        [TestCase, Description("Duplicate various http headers")]
        [CompoundCase("1.0", "HTTP/1.0", 200)]
        [CompoundCase("1.1", "HTTP/1.1", 200)]
        [CompoundCase("1.111", "HTTP/1.111", 200)]
        [CompoundCase("1.2", "HTTP/1.1", 200)]
        [CompoundCase("1.9", "HTTP/1.9", 200)]
        [CompoundCase("2.0", "HTTP/2.0", 505)]
        [CompoundCase("0.9", "HTTP/0.9", 400)]
        [CompoundCase("0.0", "HTTP/0.0", 400)]
        [CompoundCase("NonHttp", "UBERPROTOCOL/1.1", 400)]
        public class HttpVersion: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
                req.Version=(string)MyValues[0];

                http.SendRequest(req);
                if ((int)MyValues[1]==200)
                {
                    ResponseVerification.CheckResponse(http.GetResponse(), 200, true, true, req);
                }
                else
                {
                    ResponseVerification.CheckResponse(http.GetResponse(), (uint)(int)MyValues[1]);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        //Don't think this really matters
        /*[TestCase]
        public void BadHost()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.Host="slashdot.org";

            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 400, true);
        }*/

        [TestCase]
        public void NonhttpString()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            http.Connect();
            string req="boo";
            http.Socket.Send(ByteEncoding.Instance.GetBytes(req));

            if (http.GetResponse()!=null) throw new Exception("Did not expect a response.");
        }

        //
        [TestCase, Description("Duplicate various http headers")]
        [CompoundCase("Host", "Special0", 400)]
        [CompoundCase("UserAgent", "Special1", 200)]
        [CompoundCase("Accept", "Accept: test/xml", 200)]
        [CompoundCase("AcceptLanguage", "Accept-Language: en-us", 200)]
        [CompoundCase("Referer", "Referer: http://xboxtest.com/not/real/", 200)]
        [CompoundCase("Connection", "Connection: Keep-Alive", 200)]
        [CompoundCase("GarbageExtra", "ExtraGarbage: Random-Text", 200)]
        public class DuplicateHeaders: ActiveAuthTestBase
        {
            protected override void Execute()
            {
                HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
                HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
                
                if ((string)MyValues[0]=="Special0") req.OtherHeaders.AddFirst("Host: "+req.Host);
                else if ((string)MyValues[0]=="Special1") req.OtherHeaders.AddFirst("User-Agent: "+req.UserAgent);
                else
                {
                    req.OtherHeaders.AddFirst((string)MyValues[0]);
                    req.OtherHeaders.AddFirst((string)MyValues[0]);
                }
                http.SendRequest(req);

                HttpClient.Response res=http.GetResponse();
                ResponseVerification.CheckResponse(res, (uint)(int)MyValues[1]);
                if (res.GetHeaders("WWW-Authenticate").Length!=0) throw new Exception("Did not expect a WWW-Authenticate header to be returned.");

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase,Ignore] //xrlscan prevents us from testing this
        public void PostNoLength()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="POST";
            req.Content=ByteEncoding.Instance.GetBytes("A random string");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 411, true);
        }

        [TestCase]
        public void PostEvilLengthNegative()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="POST";
            req.SetContentLengthAndBody("I'm posting to you.  Beware the Ides of March.  And beware the march of the grass.");
            req.ContentLength="-1";
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 400);
        }

        [TestCase,Ignore] //xrlscan prevents us from testing this
        public void PostEvilLengthBig()
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="POST";
            req.SetContentLengthAndBody("I'm posting to you.  Beware the Ides of March.  And beware the march of the grass.");
            req.ContentLength="1999999999";
            http.SendRequest(req);

            byte []MillionSpaces=new byte[1000*1000];
            for (int i=0; i<MillionSpaces.Length; ++i)
                MillionSpaces[i]=32;

            for (int i=0; i<2000; ++i)
            {
                try
                {
                    http.Socket.Send(MillionSpaces);
                    if (i%100==0) Global.RO.Info("Sent byte "+((i+1)*1000*1000)+" ("+(int)((float)i/2000*100)+"%)");
                }
                catch
                {
                    Global.RO.Error("Socket.Send threw on i="+i);
                    throw;
                }

                if (!http.Socket.Connected)
                {
                    throw new Exception("Socket no longer connected, after "+i+" million bytes.");
                }

                {
                    int timeout=http.Socket.ReceiveTimeout;
                    http.Socket.ReceiveTimeout=1;
                    HttpClient.Response res=http.GetResponse();
                    http.Socket.ReceiveTimeout=timeout;
                    if (res!=null)
                    {
                        if (res.Status>=100 && res.Status<=199) //informational
                        {
                            Global.RO.Info("Got info message from server: "+res.Status+" ("+res.Reason+") after "+i+" million bytes.");
                        }
                        else if (res.Status!=500)
                        {
                            throw new Exception("Got a response of "+res.Status+" ("+res.Reason+") after "+i+" million bytes.");
                        }
                        else
                        {
                            if (i>100) //surely we can do at least 100MB!
                            {
                                Global.RO.Info("Ending since we got response of 500 at "+i+" million bytes.");
                                return;
                            }
                            else
                            {
                                throw new System.Exception("Got message "+res.Status+" ("+res.Reason+") after "+i+" million bytes.");
                            }
                        }
                    }
                }
            }

            ResponseVerification.CheckResponse(http.GetResponse(), 200);
        }

        /*
        [TestCase]
        public void SimpleSpamPost()
        {
            //spam
            bool prevVerb=HttpClient.Verbose;
            HttpClient.Verbose=false;
            ParallelRunner.Run(SpamPostHelper, 5000, 100, null);
            HttpClient.Verbose=prevVerb;

            System.Threading.Thread.Sleep(500);

            //1 more
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="POST";
            req.SetContentLengthAndBody("One last check");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 201, true);
        }

        [TestCase]
        public void SimpleSpamFuzzPost()
        {
            //spam
            bool prevVerb=HttpClient.Verbose;
            HttpClient.Verbose=false;
            ParallelRunner.Run(SpamPostHelper, 5000, 10, true);
            HttpClient.Verbose=prevVerb;

            System.Threading.Thread.Sleep(500);

            //1 more
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);

            req.Method="POST";
            req.SetContentLengthAndBody("One last check");
            http.SendRequest(req);
            ResponseVerification.CheckResponse(http.GetResponse(), 201, true);
        }

        private void SpamPostHelper(uint num, object o)
        {
            HttpClient http=new HttpClient(AAModuleSuite.DefaultIFDReflectorIP, AAModuleSuite.DefaultIFDReflectorPort);
            HttpClient.Request req=new HttpClient.Request(AAModuleSuite.DefaultIFDReflectorIP,TESTURI_AUTH["NONE"]);
            req.Method="POST";
            

            if (o==null)
            {
                req.SetContentLengthAndBody("I'm posting to you.  Beware the Ides of March.  And beware the march of the grass.");
                http.SendRequest(req);
            }
            else //fuzz
            {
                req.SetContentLengthAndBody("Data");

                byte []reqBytes=req.ToBytes();
                unchecked
                {
                    if (num%3==1)
                        reqBytes[(num*997)%reqBytes.Length]=(byte)((num*113)%256);
                    else
                    {
                        for (int i=0; i<num%4+1; ++i)
                            reqBytes[(num*993)%reqBytes.Length]=(byte)(32+(num*113)%96);
                    }
                }
                http.SendRequest(reqBytes);
            }
        }*/

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\Reflector\AAFDReflector\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\Reflector\AAIFDReflector\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\Reflector\AssemblyInfo.cs ===
[assembly: System.Reflection.AssemblyTitle("Xbox Live TEST Active Auth Reflector")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\OneTrickHttpServer\Main.cpp ===
#define _SECURE_SCL 0 //turn off vc2010 slowy junk

#include <winsock2.h>
#include <iostream>
#include <exception>
#include <string>
#include <fstream>
#include <array>
#include <sstream>
#include <algorithm>
#include <cctype>
#include <memory>

//Winsock lib
#pragma comment(lib, "ws2_32.lib")

// -- Wrap the ugly C stuff

class EpicFailException: public std::exception
{
public:
    EpicFailException(const std::string &exceptionMessage)
    {
        message=exceptionMessage;
    }

    const char* what() const
    {
        return message.c_str();
    }

private:
    std::string message;
};

//wrap a socket
class SuperTcpSocket
{
public:
    SuperTcpSocket()
    {
        sock=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    }

    SuperTcpSocket(SOCKET existingSocket)
    {
        sock=existingSocket;
    }

    ~SuperTcpSocket()
    {
        if (sock!=INVALID_SOCKET)
        {
            shutdown(sock, SD_BOTH);
            closesocket(sock);
            sock=INVALID_SOCKET;
        }
    }

    operator SOCKET()
    {
        return sock;
    }

    void Bind(int port)
    {
        sockaddr_in si;
        si.sin_family=AF_INET;
        si.sin_addr.s_addr=htonl(INADDR_ANY);
        si.sin_port=htons(port);
        int ret=bind(sock, (SOCKADDR*)&si, sizeof(si));
        if (ret)
        {
            std::stringstream message;
            message<<"Failed to bind on port "<<port<<".  bind() returned: "<<ret;
            throw EpicFailException(message.str());
        }
    }

    void Listen()
    {
        int ret=listen(sock, SOMAXCONN);
        if (ret)
        {
            std::stringstream message;
            message<<"Failed to listen.  listen() returned: "<<ret;
            throw EpicFailException(message.str());
        }
    }

    //returns true if something happened, false if timeout expired or error
    bool Select(bool read, bool write, bool error, int timeoutInMs)
    {
        fd_set readSet, writeSet, errorSet;
        FD_ZERO(&readSet);
        FD_ZERO(&writeSet);
        FD_ZERO(&errorSet);

        if (read)
            FD_SET(sock, &readSet);
        if (write)
            FD_SET(sock, &writeSet);
        if (error)
            FD_SET(sock, &errorSet);

        timeval time;
        time.tv_sec=timeoutInMs/1000;
        time.tv_usec=(timeoutInMs%1000)*1000;

        int ret=select(0, &readSet, &writeSet, &errorSet, &time);
        if (ret==0 || ret==SOCKET_ERROR)
            return false;
        return true;
    }

    //returns true if data was read, false on error or timeout
    bool ReceiveMore(std::stringstream &buffer, int timeoutInMs)
    {
        if (!Select(true, false, true, timeoutInMs))
            return false;

        std::array<char, 2048> temp;
        int ret=recv(sock, temp.data(), temp.size(), 0);
        if (ret==SOCKET_ERROR || ret==0)
            return false;

        std::ostreambuf_iterator<char> outIter(buffer);
        std::copy(temp.data(), temp.data()+ret, outIter);

        return true;
    }

    void Send(const std::string &str)
    {
        send(sock, &str[0], str.size(), 0);
    }

    void SetNagle(bool enable)
    {
        int flag=(enable?0:1);
        setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char*)&flag, sizeof(int));
    }

private:
    SOCKET sock;
};

//wrap a thread
template<typename UserFunc>
class EasyThread
{
public:
    EasyThread()
    {
        thread=0;
        func=0;
    }

    ~EasyThread()
    {
        CloseHandle(thread);
        thread=0;
    }

    void Start(UserFunc threadProc)
    {
        func=threadProc;
        thread=CreateThread(0, 0, ThreadProc, this, 0, 0);
        if (!thread)
            throw EpicFailException("CreateThread() failed.");
    }

    static DWORD WINAPI ThreadProc(void *threadParam)
    {
        EasyThread *self=(EasyThread*)threadParam;
        self->func();
        return 0;
    }

private:
    HANDLE thread;
    UserFunc func;
};


// -- The server

namespace
{
    //settings
    const int MaxThreads=1024;

    //stat tracking
    volatile int TotalRequests=0;
    volatile int CurrentThreadCount=0;

    //how we respond to every request
    std::string ResponseString;

    //global listening socket
    std::shared_ptr<SuperTcpSocket> listenSocket;
}

void MonitorThread()
{
    int lastRequestCount=0;

    while (true)
    {
        Sleep(1000); //not perfect, but this is just a quick hack-up app so I'm not doing fancy timing
        int curTotalRequests=TotalRequests;
        int requestsPerSecond=curTotalRequests-lastRequestCount;

        std::cout<<"Total Requests: "<<curTotalRequests<<".  Threads in use: "<<CurrentThreadCount<<"/"<<MaxThreads<<".  Requests Per Second: "<<requestsPerSecond<<std::endl;

        lastRequestCount=curTotalRequests;
    }
}

void WorkerThread()
{
    while (true)
    {
        SuperTcpSocket sock=accept(*listenSocket, 0, 0);
        if (sock==INVALID_SOCKET)
            continue;

        InterlockedIncrement((volatile LONG*)&CurrentThreadCount);

        sock.SetNagle(false);

        //keep receiving until we have parsed a valid valid request
        std::stringstream request;
        bool sent100ContinueResponse=false;
        bool gotValidResponse=false;
        while (true)
        {
            //grab more and make it all lower case
            if (!sock.ReceiveMore(request, 10000))
            {
                break;
            }

            std::string &str=request.str();
            std::transform(str.begin(), str.end(), str.begin(), std::tolower); //wasteful in the case of multiple packets, but this is just a hacked together temp app

            //search for expect-continue and respond to that
            if (!sent100ContinueResponse && str.find("expect: 100-continue\r\n")!=std::string::npos)
            {
                sent100ContinueResponse=true;
                static std::string continueResponse="HTTP/1.1 100 Continue\r\n\r\n";
                sock.Send(ResponseString);
            }

            //search for content-length
            size_t ind=0;
            int contentLength=-1;
            size_t clStartPos=str.find("content-length");
            if (clStartPos!=std::string::npos)
            {
                size_t clColonPos=str.find(":", clStartPos);
                size_t clEndPos=str.find("\r\n", clStartPos);
                if (clColonPos!=std::string::npos && clEndPos!=std::string::npos)
                {
                    std::string contentLengthString;
                    contentLengthString.insert(contentLengthString.begin(), str.begin()+clColonPos+1, str.begin()+clEndPos);
                    std::stringstream(contentLengthString)>>contentLength;
                }
            }

            //search for the end of the headers
            size_t bodyEndPos=str.find("\r\n\r\n");
            if (bodyEndPos!=std::string::npos)
            {
                //if we have a content-length we need to make sure we have received that many bytes of the body
                if (contentLength==-1)
                {
                    gotValidResponse=true;
                    break;
                }

                if (str.size()-bodyEndPos-4==contentLength)
                {
                    gotValidResponse=true;
                    break;
                }
            }
        }

        //send our response
        if (gotValidResponse)
        {
            sock.Send(ResponseString);
        }

        InterlockedDecrement((volatile LONG*)&CurrentThreadCount);
        InterlockedIncrement((volatile LONG*)&TotalRequests);
    }
}

typedef void voidFunc();

int main()
{
    //Load the response from file
    {
        std::ifstream inFile("response.txt", std::ios::binary|std::ios::in);
        if (!inFile.is_open())
        {
            std::cout<<"Failed to open response.txt"<<std::endl;
            return -1;
        }

        ResponseString=std::string(std::istreambuf_iterator<char>(inFile), std::istreambuf_iterator<char>());
    }

    //init winsock
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);

    try
    {
        //bind and listen
        listenSocket=std::make_shared<SuperTcpSocket>();
        listenSocket->SetNagle(false);
        listenSocket->Bind(80);
        listenSocket->Listen();
        std::cout<<"Successfully bound to port.  Listening."<<std::endl;

        //start the monitor
        EasyThread<voidFunc*> monitor;
        monitor.Start(MonitorThread);

        //start the worker threads
        std::array<EasyThread<voidFunc*>, MaxThreads> workers;
        for (int i=0; i<MaxThreads; ++i)
        {
            workers[i].Start(WorkerThread);
        }

        //sleep forever
        while (true)
        {
            Sleep(10000);
        }

    }
    catch (EpicFailException &fail)
    {
        std::cout<<"EpicFailException: "<<fail.what()<<std::endl;
        return -1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\Reflector\AAIFDReflector\ReflectorInstaller.cs ===
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.installer;

using System.ComponentModel;

[assembly: XomInstaller("aaifdreflector", typeof(xonline.common.installer.XomIisConfigurator))]

namespace PirateSGReflector
{
    [RunInstaller(true)]
    public class AAIFDReflectorInstaller: XomConfiguratorInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\batch.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef BATCH_H_INCLUDED
#define BATCH_H_INCLUDED


class CEventBatch;


//-----------------------------------------------------------------------------
//
// CEventBatch
//
// Manage a given batch of events
//
//-----------------------------------------------------------------------------
class CEventBatch
{
public:
    CEventBatch ( CSwitchboard *pSwitchboard, UINT nThreads );
    ~CEventBatch ();

    HRESULT Init();
    void    Cleanup();
    
    HRESULT StartEventBatch();
    HRESULT BeforeProcessEvent(UINT *pIndex);
    HRESULT AfterProcessEvent(HRESULT hrEvent, UINT index, UINT cEvents);    
    HRESULT FlushEventBatch();

    LONGLONG    GetBatchID() { return m_qwBatchID;}
    long        GetEventCount() { return m_qwEventCount;}
    HRESULT     GetLastError() { return m_hrEvent;}
    

protected:
    CSwitchboard *      m_pSwitchboard;

    LONGLONG            m_qwBatchID;
    long                m_qwEventCount;
    UINT                m_nThreads;
    HRESULT             m_hrEvent;

    HANDLE              m_hMasterEvent;
    
    long                m_hWorkerEventCur;
    HANDLE              m_hWorkerEvents[MAXIMUM_WAIT_OBJECTS];

};




#endif  // BATCH_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\batch.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

#define DBINITCONSTANTS


//-----------------------------------------------------------------------------
//
// CEventBatch
//
// Talks to the SQLNS Store
//
//-----------------------------------------------------------------------------
CEventBatch::CEventBatch( CSwitchboard *pSwitchboard, UINT nThreads  )
{
    m_pSwitchboard = pSwitchboard;

    m_qwBatchID = 0;    
    m_qwEventCount = 0;
    m_nThreads = nThreads;

    m_hMasterEvent = NULL;
    m_hWorkerEventCur = 0;
}

CEventBatch::~CEventBatch()
{
    Cleanup();
}


//-----------------------------------------------------------------------------
//
// Init
//
// Setup persistent objects for this instance
//
//-----------------------------------------------------------------------------
HRESULT CEventBatch::Init( )
{
    HRESULT hr = S_OK;

    if (m_nThreads > MAXIMUM_WAIT_OBJECTS)
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT, "XEvents config cannot specify more threads than MAXIMUM_WAIT_OBJECTS of ", MAXIMUM_WAIT_OBJECTS);
        hr = E_FAIL;
        goto lDone;
    }

    // The master control event - unsignalled when draining. Signalled when open for business
    m_hMasterEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // Worker events - reset when a thread is working with this batch object. Signalled when free. 
    //  all are initialized as signalled
    for(UINT i=0; i<m_nThreads; i++)
    {
        m_hWorkerEvents[i] = CreateEvent(NULL, TRUE, TRUE, NULL);
    }
    
    
lDone:    
    return hr;
}


//-----------------------------------------------------------------------------
//
// Cleanup
//
// Cleanup persistent objects for this instance
//
//-----------------------------------------------------------------------------
void CEventBatch::Cleanup()
{
    CloseHandle(m_hMasterEvent);

    for(UINT i=0; i<m_nThreads; i++)
    {
        CloseHandle(m_hWorkerEvents[i]);
    }
}


//-----------------------------------------------------------------------------
//
// StartEventBatch
//
// Setup the batch object to begin accepting events
//
//-----------------------------------------------------------------------------
HRESULT CEventBatch::StartEventBatch()
{
    HRESULT     hr = S_OK;

    // Ensure our batch object is free and clear before mucking with it. 
    if (WAIT_OBJECT_0 == WaitForSingleObject(m_hMasterEvent, 0))
    {
        hr = E_FAIL;
        goto lDone;
    }

    m_qwBatchID = 0;
    m_qwEventCount = 0;
    m_hrEvent = S_OK;
    
    hr = m_pSwitchboard->StartEventBatch(&m_qwBatchID);

    if ( SUCCEEDED(hr) )
    {
        // We are open for business
        SetEvent(m_hMasterEvent);
    }    
    
lDone:    
    return hr;
}


//-----------------------------------------------------------------------------
//
// BeforeProcessEvent
//
// Prepare to process an event in the current batch
//
//-----------------------------------------------------------------------------
HRESULT CEventBatch::BeforeProcessEvent(UINT *pIndex)
{
    HRESULT hr = S_OK;
    
    if (NULL == pIndex)
    {
        hr = E_INVALIDARG;
        goto lDone;        
    }

    *pIndex = 0;
    
    // Ensure our batch object is in a state to be flushed before mucking with it. 
    if (WAIT_TIMEOUT == WaitForSingleObject(m_hMasterEvent, 0))
    {        
        hr = E_FAIL;    // Batch is closed to new adds. 
        goto lDone;
    }

    // Fetch an event out of the list
    int index = InterlockedIncrement(&m_hWorkerEventCur) % m_nThreads;

    // Nobody should be using this event, but just to be safe...
    WaitForSingleObject(m_hWorkerEvents[index], INFINITE);

    // Reset the event so that our batch isn't flushed out from under us. 
    ResetEvent(m_hWorkerEvents[index]);

    *pIndex = index;
    
lDone:
    return hr;
}


//-----------------------------------------------------------------------------
//
// AfterProcessEvent
//
// Cleanup after an event has been inserted in the current batch
//
//-----------------------------------------------------------------------------
HRESULT CEventBatch::AfterProcessEvent(HRESULT hrEvent, UINT index, UINT cEvents)
{
    HRESULT hr = S_OK;
    
    if (index > m_nThreads)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if (SUCCEEDED(m_hrEvent))
    {
        m_hrEvent = hrEvent;
    }

    // Accumulate events
    InterlockedExchangeAdd(&m_qwEventCount, cEvents);
    
    // Set the event on the way out.
    SetEvent(m_hWorkerEvents[index]);

lDone:
    return hr;
}



//-----------------------------------------------------------------------------
//
// FlushEventBatch
//
// Setup the batch object to begin accepting events
//
//-----------------------------------------------------------------------------
HRESULT CEventBatch::FlushEventBatch()
{
    HRESULT     hr = S_OK;

    // Ensure our batch object is in a state to be flushed before mucking with it. 
    if (WAIT_TIMEOUT == WaitForSingleObject(m_hMasterEvent, 0))
    {
        hr = E_FAIL;
        goto lDone;
    }

    // Wait until all currently executing threads drain out of the batch
    WaitForMultipleObjects(m_nThreads, m_hWorkerEvents, TRUE, INFINITE);

    if (m_qwBatchID != 0)
    {
        hr = m_pSwitchboard->FlushEventBatch(m_qwBatchID, m_qwEventCount);

        // If the flush call fails, it will log an event. We currently do not attempt
        //  to retry the flush, but just continue as if everything is ok to ensure
        //  the service does not bog down due to a database error. The most common
        //  case that may cause this is someone restarting SQL while xevents is running. 
    }

    // Clear the master event
    ResetEvent(m_hMasterEvent);
    
lDone:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\config.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

class CXEventsConfig;

// Must call Load before using
extern CXEventsConfig g_CXEventsConfig;

#define C_MAX_CONFIG_STR         255
#define PN_MAX_DWORD_ARRAY       25


//-----------------------------------------------------------------------------
// 
// CXEventsConfig
//
// Configuration for an individual xevents service
//
//-----------------------------------------------------------------------------
class CXEventsConfig
{

private:
	CComPtr<IConfig> m_pConfig;
	
    WORD m_wPort;
    WORD m_wBuffers;
    WORD m_wThreads;    
    CComPtr<IInterfaceInfo> m_iAlerts;

public:     

    CXEventsConfig() {}
    ~CXEventsConfig() {}

    DWORD   GetDWORDSetting(CComBSTR Setting);
    void    GetDWORDArraySetting(CComBSTR Setting,      DWORD *pdwLen, DWORD *rgdwVal);
    
    WORD    GetPort() {return m_wPort;}
    WORD    GetBuffers() {return m_wBuffers;}
    WORD    GetThreads() {return m_wThreads;}
    CComPtr<IInterfaceInfo> GetAlertsInterface() {return m_iAlerts;}
    
    HRESULT Load();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ActiveAuth\test\Reflector\GatewayRequest.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

#if MIDDLE_TIER_AAINFO
[assembly: ConfigAttribute("aafdreflector")]
#else
[assembly: ConfigAttribute("aaifdreflector")]
#endif

namespace AATest
{


public class ReflectorApp : HttpApplication
{
    public virtual void Application_Start(object sender, EventArgs e)
    {
        XomLoggingControl.Init();
    }

    static ReflectorApp()
    {
	Config.Assembly=System.Reflection.Assembly.GetExecutingAssembly();        
    }

    public virtual void Application_End(object sender, EventArgs e)
    {
        XomLoggingControl.Close();
    }
}



public partial class Reflector : IHttpHandler
{
    /// <summary>
    /// Why not? We don't store state across invocations.
    /// </summary>
    public bool IsReusable
    {
        get { return true; }
    }

    //creates a string from an exception, guarenteeing there are no line breaks in it
    public static string MakeSafeExceptionString(System.Exception exc)
    {
        string msg=exc.Message;
        msg+=" , stack: ";
        msg+=exc.StackTrace;
        msg=msg.Replace("\r","");
        msg=msg.Replace("\n"," , ");
        if (exc.InnerException!=null)
        {
            msg+="  -  ";
            msg+=MakeSafeExceptionString(exc.InnerException);
        }

        return msg;
    }

    /// <summary>
    /// Reflect a request.
    /// </summary>
    public void ProcessRequest (HttpContext context)
    {
        HttpRequest req = context.Request;
        HttpResponse resp = context.Response;

        // see if we need to do anything special for this request
        int preLength = Preamble.Length + 1;
        string errorString = "";

        bool do_aainfo_lookup = true;

        if (req.ContentLength >= preLength && CheckRequestForPreamble(req))
        {
            switch ((RequestParameters) ((byte) req.InputStream.ReadByte()))
            {
                case RequestParameters.ResponseWait:
                    if (req.ContentLength < preLength + 1)
                    {
                        errorString = "Byte parameter missing for ResponseWait";
                        break;
                    }
                    System.Threading.Thread.Sleep(req.InputStream.ReadByte() * 100);
                    break;

                case RequestParameters.ResponseWaitLong:
                    if (req.ContentLength < preLength + 1)
                    {
                        errorString = "Byte parameter missing for ResponseWaitLong";
                        break;
                    }
                    System.Threading.Thread.Sleep(req.InputStream.ReadByte() * 1000);
                    break;

                case RequestParameters.ResponseWaitShort:
                    if (req.ContentLength < preLength + 1)
                    {
                        errorString = "Byte parameter missing for ResponseWait";
                        break;
                    }
                    System.Threading.Thread.Sleep(req.InputStream.ReadByte());
                    break;

                case RequestParameters.ThrowUnhandledException:
                    throw new Exception("Throwing the exception for ThrowUnhandledException");

                case RequestParameters.Exit:
                    System.Environment.Exit(0);
                    break;

                case RequestParameters.NoAAInfoLookup:
                    do_aainfo_lookup = false;
                    break;

                case RequestParameters.ReturnError:
                    if (req.ContentLength < preLength + 2)
                    {
                        errorString = "2 byte parameter missing for ReturnError";
                        break;
                    }
                    resp.StatusCode = (req.InputStream.ReadByte() << 8) | req.InputStream.ReadByte();
                    resp.StatusDescription = "Reflector " + resp.StatusCode.ToString();
                    resp.End();
                    return;

                case RequestParameters.NoResponse:
                    resp.Close();
                    return;

                case RequestParameters.ReflectHeaders:
                    foreach (string header in req.Headers.Keys)
                    {
                        if (header.ToLower() != "content-length")
                        {
                            resp.AppendHeader(header, req.Headers[header]);
                        }
                    }
                    break;

                case RequestParameters.OutputBody:
                    if (req.ContentLength < preLength + 2)
                    {
                        errorString = "2 byte parameter missing for ReturnError";
                        break;
                    }
                    int val = (req.InputStream.ReadByte() << 8);
                    val |= req.InputStream.ReadByte();

                    byte[] bytes = new byte[1024];
                    (new Random()).NextBytes(bytes);

                    for (int i = 0; i < val; ++i)
                    {
                        resp.BinaryWrite(bytes);
                    }
                    return;

                case RequestParameters.Stress:
                    resp.Write(req.Url.PathAndQuery);
                    return;

                case RequestParameters.ResponseXMLContentType:
                    resp.ContentType = "text/xml";
                    break;
            }
        }

        // identify that we are in fact reflecting
        resp.Write("ActiveAuth Reflector Response\r\n" + errorString + "\r\n");

        // spit out context items from module
        foreach (DictionaryEntry entry in context.Items)
        {
            resp.Write(String.Format("HttpContext[\"{0}\"]: {1}\r\n",
                (entry.Key == null ? "<null>" : entry.Key.ToString()),
                (entry.Value == null ? "<null>" : entry.Value.ToString())));
        }

        resp.Write("\r\n");

        if (do_aainfo_lookup)
        {
            // AAInfo stuffs
#if MIDDLE_TIER_AAINFO
            AAInfo aainfo = AAInfoMiddleTier.Current;
#else
            AAInfo aainfo = AAInfoInternetTier.Current;
#endif

            //read from every aainfo field
            try
            {
                resp.Write(String.Format("__AAInfoCurrent: {0}\r\n", AAInfo.Current==null?"null":"exists"));
            }
            catch (Exception e)
            {
                resp.Write(String.Format("__AAInfoCurrent: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
            }

            try
            {
                resp.Write(String.Format("__IsActiveAuthAvailable: {0}\r\n", AAInfo.IsActiveAuthAvailable));
            }
            catch (Exception e)
            {
                resp.Write(String.Format("__IsActiveAuthAvailable: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
            }

            try
            {
                resp.Write(String.Format("__IsInternetTier: {0}\r\n", AAInfo.IsInternetTier));
            }
            catch (Exception e)
            {
                resp.Write(String.Format("__IsInternetTier: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
            }

            try
            {
                resp.Write(String.Format("__IsMiddleTier: {0}\r\n", AAInfo.IsMiddleTier));
            }
            catch (Exception e)
            {
                resp.Write(String.Format("__IsMiddleTier: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
            }

            if (aainfo==null)
            {
                resp.Write(String.Format("__IsAAInfoNull: true\r\n"));
            }
            else
            {
                resp.Write(String.Format("__IsAAInfoNull: false\r\n"));

                try
                {
                    resp.Write(String.Format("__PassportPuid: {0}\r\n", aainfo.PassportPuid));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__PassportPuid: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    resp.Write(String.Format("__IpAddressInternet: {0}\r\n", aainfo.IpAddressInternet));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__IpAddressInternet: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    resp.Write(String.Format("__LiveXuid: {0}\r\n", aainfo.LiveXuid));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__LiveXuid: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    resp.Write(String.Format("__LiveXuidFromXCache: {0}\r\n", aainfo.LiveXuidFromXCache));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__LiveXuidFromXCache: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    resp.Write(String.Format("__OriginatingIP: {0}\r\n", aainfo.OriginatingIP));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__OriginatingIP: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    resp.Write(String.Format("__CountryId: {0}\r\n", aainfo.CountryId));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__CountryId: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    aainfo.ToString();
                    resp.Write(String.Format("__ToString: {0}\r\n", "ok"));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__ToString: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    string privis = "";

                    for (int i = 0; i <= XOn.XPRIVILEGE_MAX; ++i)
                    {
                        if (aainfo.HasPrivilege(i))
                        {
                            if (privis != "")
                            {
                                privis += ",";
                            }

                            privis += i.ToString();
                        }
                    }

                    resp.Write(String.Format("__HasPrivilege: {0}\r\n", privis));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__HasPrivilege: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }

                try
                {
                    resp.Write(String.Format("__IsUserValid: {0}\r\n", aainfo.IsUserValid));
                }
                catch (Exception e)
                {
                    resp.Write(String.Format("__IsUserValid: !!!Exception: {0}\r\n", MakeSafeExceptionString(e)));
                }
            }
        }

        resp.Write("\r\n");

        // reflect request
        // first line
        resp.Write(String.Format("{0} {1} {2}\r\n", req.HttpMethod, req.Url.PathAndQuery, 
        req.ServerVariables["SERVER_PROTOCOL"]));

        // headers
        foreach (string header in req.Headers.AllKeys)
        {
            resp.Write(String.Format("{0}: {1}\r\n", header, req.Headers[header]));
        }

        resp.Write("\r\n");

        // body
        int total = 0;
        byte[] buffer = new byte[1024];

        req.InputStream.Position = 0;

        while (0 != (total = req.InputStream.Read(buffer, 0, buffer.Length)))
        {
            resp.OutputStream.Write(buffer, 0, total);
        }
    }

    /// <summary>
    /// Checks the request for the preamble.
    /// </summary>
    /// <param name="request">The request to check.</param>
    /// <returns>True if the request starts with the preamble.</returns>
    public static bool CheckRequestForPreamble (HttpRequest request)
    {
        for (int i = 0; i < Preamble.Length; ++i)
        {
            if (request.InputStream.ReadByte() != (int) Preamble[i])
            {
                return false;
            }
        }

        return true;
    }
}

} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\connector.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"


//-----------------------------------------------------------------------------
//
// CEventsConnector
//
// Network data input class
//
//-----------------------------------------------------------------------------
CEventsConnector::CEventsConnector( CCompletionPort *pCompletionPort, CSwitchboard *pSwitchboard )
{
    m_pServSock = NULL;
    m_pCompletionPort = pCompletionPort;
    m_pSwitchboard = pSwitchboard;
    
    m_nPort = g_CXEventsConfig.GetPort();
    m_nBuffers = g_CXEventsConfig.GetBuffers();
        
    m_pBuffers = NULL;
}

CEventsConnector::~CEventsConnector()
{
    m_pCompletionPort = NULL;
    
    SAFE_RELEASE(m_pServSock);

    if (NULL != m_pBuffers)
    {
        XFree(m_pBuffers);
        m_pBuffers = NULL;
    }
}

//-----------------------------------------------------------------------------
//
// Connect
//
// Setup the socket listener
//
//-----------------------------------------------------------------------------
HRESULT CEventsConnector::Init( )
{
    HRESULT     hr = S_OK;

    hr = Connect();

    return(hr);
}


//-----------------------------------------------------------------------------
//
// Connect
//
// Setup the socket listener
//
//-----------------------------------------------------------------------------
HRESULT CEventsConnector::Connect( void )
{
    HRESULT     hr = S_OK;
    sockaddr_in sa;

    //
    // Create a socket connection to listen on said completion port.  
    //
    XOMASSERT(NULL == m_pServSock);
    hr = CServerSocket::CreateInstance(&m_pServSock, m_pCompletionPort, m_pCompletionPort);

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_1, "Unrecoverable failure while initializing: CServerSocket::CreateInstance failed, hr = 0x%08x", hr);
        goto lDone;
    }

    //
    // Open the flood gates
    //
    memset(&sa, 0, sizeof(sa));
    
    sa.sin_family = AF_INET;
    sa.sin_port = htons(m_nPort);
    
    hr = m_pServSock->Init(IPPROTO_UDP, &sa, FALSE);
    
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_2, "Unrecoverable failure while initializing: CServSocket::Init failed, hr = 0x%08x", hr);
        goto lDone;
    }

    //
    // Allocate buffers
    //
    XOMASSERT(NULL == m_pBuffers);
    m_pBuffers = (BYTE *)XAllocZ(m_nBuffers * C_MAX_BUFFER_SIZE);

    if (NULL == m_pBuffers)
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_3, "Failed to allocate receive buffers. Aborting");
        goto lDone;
    }

    
    //
    // Start queuing buffers
    //
    for (int i=0; i<m_nBuffers; i++)
    {
        hr = m_pServSock->ReceiveFrom(GetBuffer(i), C_MAX_BUFFER_SIZE, this, i);
    }

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_4, "Unrecoverable failure while initializing: CServSocket::Listen failed, hr = 0x%08x", hr);
        goto lDone;
    }
    
lDone:
    return hr;
}


//-----------------------------------------------------------------------------
//
// GetBuffer
//
// Calculate the beginning of a particular buffer in the overall buffer
//
//-----------------------------------------------------------------------------
BYTE * CEventsConnector::GetBuffer(DWORD dwBuffer)
{
    if (NULL == m_pBuffers)
    {
        return NULL;
    }

    return (m_pBuffers + ( dwBuffer * C_MAX_BUFFER_SIZE ));
}


//-----------------------------------------------------------------------------
//
// OnSocketReceiveFrom
//
// Receives a UDP packet from the wire and queues up another read
//
//-----------------------------------------------------------------------------
void CEventsConnector::OnSocketReceiveFrom(
            BYTE *pbFilledInBuffer,
            DWORD cbRead,
            sockaddr_in *pFilledInFrom,
            HRESULT hrCallback,
            QWORD qwCallbackArg
) 
{ 
    HRESULT hr = S_OK;
    HRESULT hrRequeue = S_OK;

    // New thread is going to start working. Keep count
    g_Counters.SafeIncrement32(XEVENTPERF_SERVER_CONCURRENT_THREADS);

    if(HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED) == hrCallback)
    {
        // Most likely case is that we're shutting down
        
        hr = S_OK;
        goto lDone;
    }
    
    // Now, did we actually get anything?
    if( FAILED(hrCallback) || 0 == cbRead )
    {
        // this transmission failed.
        
        XomNtEvent(XEVENT_XEVENTS_RECEIVE_FAIL, "m_pSocketClient->ReceiveFrom operation failed, hr = 0x%08x", hrCallback);
        hr = hrCallback;
        goto lDone;
    }

    // Message is ready to be processed
    hr = m_pSwitchboard->ProcessEventMessage(pbFilledInBuffer, cbRead);

    if ( FAILED(hr) )
    {
        // ProcessEventMessage should have already logged details of the failure
        goto lDone;
    }

lDone:
#ifdef DEBUG
    memset(pbFilledInBuffer, 0, C_MAX_BUFFER_SIZE);
#endif

    hrRequeue = m_pServSock->ReceiveFrom(pbFilledInBuffer, C_MAX_BUFFER_SIZE, this, qwCallbackArg);

    if(FAILED(hrRequeue))
    {
        XomNtEvent(XEVENT_XEVENTS_RECEIVE_FAIL_1, "m_pSocketClient->ReceiveFrom failed to queue new Receive, hr = 0x%08x", hrRequeue);
    }   

    // Release this thread back to the pool
    g_Counters.SafeDecrement32(XEVENTPERF_SERVER_CONCURRENT_THREADS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\config.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include <stdafx.h>

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

// Configuration object, must call Load before using
CXEventsConfig  g_CXEventsConfig;


//-----------------------------------------------------------------------------
// 
// GetConfigDWORD
//
//-----------------------------------------------------------------------------
DWORD CXEventsConfig::GetDWORDSetting(CComBSTR Setting)
{
    HRESULT     hr;
    CComBSTR    bsSetting;

    hr = m_pConfig->GetSetting(Setting, &bsSetting);

	if (FAILED(hr))
	{
        XomNtEvent(XEVENT_ALERTS_CONFIG_0, "m_pConfig->GetSetting(Setting = %ws, &bsSetting) failed: (0x%08x)\n", static_cast<wchar_t *> (Setting), hr);
	}

    return _wtoi(bsSetting);
}

//-----------------------------------------------------------------------------
// 
// GetConfigDWORDArray
//
//-----------------------------------------------------------------------------
void CXEventsConfig::GetDWORDArraySetting(
    CComBSTR Setting,
    DWORD *pdwLen,
    DWORD *rgdwVal)
{
    // BUGBUG put in a new array, then swap

    HRESULT     hr;
    CComBSTR bsSetting;
    LPCWSTR wszRead;
    int iRet;

    // Get the string to parse
    hr = m_pConfig->GetSetting(Setting, &bsSetting);

	if (FAILED(hr))
	{
        XomNtEvent(XEVENT_ALERTS_CONFIG_1, "m_pConfig->GetSetting(Setting = %ws, &bsSetting) failed: (0x%08x)\n", static_cast<wchar_t *> (Setting), hr);
	}

    wszRead = bsSetting;
    *pdwLen = 0;
    for (;;)
    {
        // Check the size limit
        if (*pdwLen >= PN_MAX_DWORD_ARRAY)
        {
            break;
        }

        // Try to get an element
        if( ( '0' == wszRead[ 0 ] ) && ( 'x' == wszRead[ 1 ] ) )
        {
            iRet = swscanf(wszRead, L"%x", rgdwVal + *pdwLen);
        }
        else
        {
            iRet = swscanf(wszRead, L"%d", rgdwVal + *pdwLen);
        }

        // Did we get anything
        if (iRet != 1) 
        {
            break;
        }

        // Next element
        *pdwLen = *pdwLen + 1;

        while ((*wszRead != '\0') && (*wszRead != ','))
        {
            wszRead++;
        }

        while ((*wszRead == ',') || (*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
    }
    
}


//-----------------------------------------------------------------------------
// 
// Load
//
//-----------------------------------------------------------------------------
HRESULT CXEventsConfig::Load()
{
    HRESULT hr = S_OK;
    
	CComPtr<IInterfaceInfo> pInterfaceInfo;
	long dwPort;
	
	// c++ clients should use ConfigInterop since static functions can't be called
	// from an interface
	hr = m_pConfig.CoCreateInstance(__uuidof(ConfigInterop));
	if (FAILED(hr))
	{
		if (hr == 0x80040154) // REGDB_E_CLASSNOTREG
		{
            XomNtEvent(XEVENT_ALERTS_CONFIG_2, "m_pConfig.CoCreateInstance: failed with REGDB_E_CLASSNOTREG (0x%08x)\n\n"
				"NOTE: CommonConfig.dll needs to be in the current directory registered with REGASM\n"
				"For example, copy CommonConfig.dll from $(INETROOT)\\drop\\debug\\common then run:\n\n"
				"\tC:\\windows\\Microsoft.NET\\Framework\\v1.1.4322\\RegAsm.exe CommonConfig.dll\n\n"
				, hr);
        }				
		else
		{
	        printf("m_pConfig.CoCreateInstance: (0x%08x)\n", hr);
	    }		

        goto lbError;	     
	}

    //
    // XEvents communication port
    //
	hr = m_pConfig->GetSingleInterface(Interface_xevents, &pInterfaceInfo);
	if (FAILED(hr))
	{
        XomNtEvent(XEVENT_ALERTS_CONFIG_3, "m_pConfig->GetSingleInterface(Interface_xevents, &pInterfaceInfo) failed: (0x%08x)\n", hr);
        goto lbError;	     
	}

	hr = pInterfaceInfo->get_Port(&dwPort);
	m_wPort = (WORD)dwPort;
	if (FAILED(hr))
	{
        XomNtEvent(XEVENT_ALERTS_CONFIG_4, "pInterfaceInfo->get_Port failed: (0x%08x)\n", hr);
        goto lbError;	     
	}

    //
    // Alerts Database
    //
	hr = m_pConfig->GetSingleInterface(Interface_alertsApp, &m_iAlerts);
	if (FAILED(hr))
	{
        XomNtEvent(XEVENT_ALERTS_CONFIG_5, "m_pConfig->GetSingleInterface(Interface_alertsInstance, &pInterfaceInfo) failed: (0x%08x)\n", hr);
        goto lbError;	     
	}

    //
    // Perf settings
    //
    m_wBuffers = (WORD)GetDWORDSetting(Setting_xevents_buffers);
    m_wThreads = (WORD)GetDWORDSetting(Setting_xevents_threads);
    	
lbError:	
    return hr;
    	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\perfctrs.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef PERFCTRS_H_INCLUDED
#define PERFCTRS_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////
class CXEventsPerfCounters
{
public:
    CXEventsPerfCounters();
    ~CXEventsPerfCounters();

    HRESULT Init();

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32(DWORD dwCounterID);

    void SetCurrentValue32(DWORD dwCounterID, DWORD dwVal);

    void IncrementValue32(DWORD dwCounterID, DWORD dwAmount);

    void DecrementValue32(DWORD dwCounterID, DWORD dwAmount);

    void SafeIncrement32(DWORD dwCounterID);

    void SafeDecrement32(DWORD dwCounterID);

    void TrackSuccessfulMessage(DWORD dwServerCounterID);

    void TrackFailureMessage(DWORD dwServerCounterID);

    //
    // QWORD counter manipulation routines
    //
    QWORD GetCurrentValue64(DWORD dwCounterID);

    void SetCurrentValue64(DWORD dwCounterID, QWORD qwVal);

    void IncrementValue64(DWORD dwCounterID, QWORD qwAmount);

    void DecrementValue64(DWORD dwCounterID, QWORD qwAmount);

private:
    HANDLE m_hServerPerfObj;
};

extern CXEventsPerfCounters g_Counters;


#endif  // PERFCTRS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\connector.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef CONNECTOR_H_INCLUDED
#define CONNECTOR_H_INCLUDED


class CSwitchboard;


//-----------------------------------------------------------------------------
//
// CEventsConnector
//
// Proxy incoming UDP Network traffic amongst multiple threads
//
//-----------------------------------------------------------------------------

class CEventsConnector : 
                public CServerSocketCallback
{
public:

    // CEventsConnector
    CEventsConnector(CCompletionPort *pCompletionPort, CSwitchboard *pSwitchboard);
    ~CEventsConnector();

    HRESULT Init( );
    

protected:
    HRESULT Connect( void );
    
    BYTE *  GetBuffer(DWORD dwBuffer);

    
public:
    // CServerSocketCallback
    virtual ULONG AddRef() { return 1; }

    virtual ULONG Release() { return 1; }

    virtual void OnSocketReceiveFrom(
        BYTE *pbFilledInBuffer,
        DWORD cbRead,
        sockaddr_in *pFilledInFrom,
        HRESULT hr,
        QWORD qwCallbackArg );

private:    
    CServerSocket *      m_pServSock;
    CCompletionPort *    m_pCompletionPort;
    CSwitchboard *        m_pSwitchboard;

    USHORT                  m_nPort;
    USHORT                  m_nBuffers;
    
    BYTE *                    m_pBuffers;
};


#endif  // CONNECTOR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\sqlnsstore.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef SQLNSSTORE_H_INCLUDED
#define SQLNSSTORE_H_INCLUDED


class CSwitchboard;


//-----------------------------------------------------------------------------
//
// CSQLNSStore
//
// Given a buffer of data, Interpret it and do work against the SQLNS Store
//
//-----------------------------------------------------------------------------
class CSQLNSStore
{
public:
    CSQLNSStore ( CSwitchboard *pSwitchboard );
    ~CSQLNSStore ();

    HRESULT Init();
    void    Cleanup();

    HRESULT GetThreadSession(CSession **ppSession);
    void    CleanupThreadSession();

    HRESULT ProcessEventMessage(LONGLONG qwBatchID, BYTE *pBuffer, DWORD cbBuffer, UINT *pqwEventCount);

    HRESULT StoreStartxLiveBatch(LONGLONG *pqwBatchID);
    HRESULT StoreFlushxLiveBatch(LONGLONG qwBatchID, LONGLONG qwEventCount);
    

protected:
    CSwitchboard *      m_pSwitchboard;

    CDBPropSet          m_propSet[2];
    CDataSource *       m_pDS;                      // Datasource

    CRITICAL_SECTION    m_cs;                       // Critical section for intializing DS
    
};


//-----------------------------------------------------------------------------
//
// StartxLiveBatch
//
// Start a batch for writing events to the store
//
//-----------------------------------------------------------------------------
class StartxLiveBatch
{
public:
    StartxLiveBatch() 
    {
        ZeroMemory(this, sizeof(*this)); 

        // Default params
        lstrcpyW(m_szProviderName, L"xLiveEP");
    }

BEGIN_PARAM_MAP(StartxLiveBatch)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_ret)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY_TYPE(2, DBTYPE_WSTR, m_szProviderName)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY_TYPE(3, DBTYPE_I8, m_qwEventBatchID)
END_PARAM_MAP()

DEFINE_COMMAND_EX(StartxLiveBatch, L"{? = call NSEventBeginBatchxLiveEvents (?, ?) }")

    // Command Parameters
    LONG        m_ret;

    WCHAR       m_szProviderName[32];
    
    LONGLONG    m_qwEventBatchID;

};

typedef CCommand<CAccessor<StartxLiveBatch>, CNoRowset > CmdStartxLiveBatch;


//-----------------------------------------------------------------------------
//
// WritexLiveEvent
//
// Write a single event to the store in the context of a batch
//
//-----------------------------------------------------------------------------
class WritexLiveEvent
{
public:
    WritexLiveEvent() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(WritexLiveEvent)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_ret)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY_TYPE(2, DBTYPE_I8, m_qwEventBatchID)
    COLUMN_ENTRY_TYPE(3, DBTYPE_I4, m_dwType)
    COLUMN_ENTRY_TYPE(4, DBTYPE_I2, m_wFlags)
    COLUMN_ENTRY_TYPE(5, DBTYPE_WSTR, m_wszSender)
    COLUMN_ENTRY_TYPE(6, DBTYPE_WSTR, m_wszData)
    COLUMN_ENTRY_TYPE(7, DBTYPE_I4, m_iTitleID)
    COLUMN_ENTRY_TYPE(8, DBTYPE_I8, m_qwSenderXUID)
    COLUMN_ENTRY_TYPE(9, DBTYPE_I8, m_qwRecipientXUID)
    COLUMN_ENTRY_TYPE(10, DBTYPE_WSTR, m_wszRecipient)
END_PARAM_MAP()

DEFINE_COMMAND_EX(WritexLiveEvent, L"{? = call NSEventWritexLiveEvents (?, ?, ?, ?, ?, ?, ?, ?, ?) }")

    // Command Parameters
    LONG        m_ret;
    
    LONGLONG    m_qwEventBatchID;
    DWORD       m_dwType;
    SHORT       m_wFlags;
    WCHAR       m_wszSender[XONLINE_GAMERTAG_SIZE];
    WCHAR       m_wszData[256];
    UINT        m_iTitleID;
    ULONGLONG   m_qwSenderXUID;
    ULONGLONG   m_qwRecipientXUID;
    WCHAR       m_wszRecipient[22];
    
};

typedef CCommand<CAccessor<WritexLiveEvent>, CNoRowset > CmdWritexLiveEvent;


//-----------------------------------------------------------------------------
//
// FlushxLiveBatch
//
// Commit a batch to the store
//
//-----------------------------------------------------------------------------
class FlushxLiveBatch
{
public:
    FlushxLiveBatch() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }
    
BEGIN_PARAM_MAP(FlushxLiveBatch)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_ret)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY_TYPE(2, DBTYPE_I8, m_qwEventBatchID)
    COLUMN_ENTRY_TYPE(3, DBTYPE_I8, m_qwEventCount)
END_PARAM_MAP()

DEFINE_COMMAND_EX(FlushxLiveBatch, L"{? = call NSEventFlushBatchxLiveEvents (?, ?) }")

    // Command Parameters
    LONG        m_ret;
    
    LONGLONG    m_qwEventBatchID;
    LONGLONG    m_qwEventCount;

};

typedef CCommand<CAccessor<FlushxLiveBatch>, CRowset > CmdFlushxLiveBatch;


#endif  // SQLNSSTORE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\perfctrs.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////

CXEventsPerfCounters g_Counters;

//////////////////////////////////////////////////////////////////////////////
enum XEPC_TYPES
{
    XEPC_DWORD = 1,
    XEPC_QWORD = 2
};

struct PERFCOUNTER
{
    XEPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    LONG lDataScale;
    BYTE *pbPerfCtrData;
};

#define DWORD_AVERAGE( INDEX, SCALE ) \
{ XEPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_BASE( INDEX, SCALE ) \
{ XEPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_COUNTER( INDEX, SCALE ) \
{ XEPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_RATE( INDEX, SCALE ) \
{ XEPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, SCALE, NULL }

#define QWORD_AVERAGE( INDEX, SCALE ) \
{ XEPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, SCALE, NULL }

#define QWORD_COUNTER( INDEX, SCALE ) \
{ XEPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, SCALE, NULL }

#define QWORD_RATE( INDEX, SCALE ) \
{ XEPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, SCALE,  NULL }

//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs [] =
{
    DWORD_COUNTER( XEVENTPERF_SERVER_CONCURRENT_THREADS , 0),
    DWORD_COUNTER( XEVENTPERF_SERVER_EVENTS_TOTAL_COUNTER , 0),
    DWORD_RATE( XEVENTPERF_SERVER_EVENTS_TOTAL_RATE  , 0 ),
    DWORD_COUNTER( XEVENTPERF_SERVER_EVENTS_FAILED_COUNTER , 0 ),
    DWORD_RATE( XEVENTPERF_SERVER_EVENTS_FAILED_RATE , 0 )
};

#define NUM_SERVER_PERF_COUNTERS (ARRAY_ELEMENTS(s_ServerPerfCtrs))

//////////////////////////////////////////////////////////////////////////////
CXEventsPerfCounters::CXEventsPerfCounters() :
m_hServerPerfObj( NULL )
{
}

//////////////////////////////////////////////////////////////////////////////
CXEventsPerfCounters::~CXEventsPerfCounters()
{
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CXEventsPerfCounters::Init()
{
    BYTE *pbServCtrsStart = NULL;
    
    XOMASSERT( NULL == m_hServerPerfObj );
    
    // Create the server perf object and associated counters
    m_hServerPerfObj = CreatePerfObject(
        XEVENTPERF_SERVER_OBJECT ,
        0,
        (void **) &pbServCtrsStart );
    
    if( NULL == m_hServerPerfObj )
    {
        return E_UNEXPECTED;
    }
    
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        DWORD dwCounterDataOffset = CreatePerfCounter(
            s_ServerPerfCtrs[ dwCtr ].dwPerfType,
            s_ServerPerfCtrs[ dwCtr ].lDataScale,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize,
            m_hServerPerfObj,
            s_ServerPerfCtrs[ dwCtr ].dwPerfIndex,
            NULL );
        
        XOMASSERT( 0xffffffff != dwCounterDataOffset );
        
        s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData = pbServCtrsStart + dwCounterDataOffset;
        
        // Zero every counter on startup
        ZeroMemory(
            s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize );
    }    
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CXEventsPerfCounters::GetCurrentValue32(DWORD dwCounterID)
{
    
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    return( *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::SetCurrentValue32(DWORD dwCounterID, DWORD dwVal)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    // No need for thread safety
    //InterlockedExchange(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    (LONG) dwVal );

    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = dwVal;
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::IncrementValue32(DWORD dwCounterID, DWORD dwAmount)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    // No need for thread safety
    //InterlockedExchangeAdd(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    (LONG) dwAmount );

    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += dwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::DecrementValue32(DWORD dwCounterID, DWORD dwAmount)
{

    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    // No need for thread safety
    //InterlockedExchangeAdd(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    - (LONG) dwAmount );
    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData -= dwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::SafeIncrement32(DWORD dwCounterID)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    InterlockedIncrement((LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData);
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::SafeDecrement32(DWORD dwCounterID)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    InterlockedDecrement((LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData);
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::TrackSuccessfulMessage(DWORD dwServerCounterID)
{
    // Increment the specific counter
    IncrementValue32(dwServerCounterID, 1);
    
    // Assume a rate counter after the count counter
    IncrementValue32(dwServerCounterID + 2, 1);
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::TrackFailureMessage(DWORD dwServerCounterID)
{
    // Increment the total failure counter
    IncrementValue32( dwServerCounterID, 1 );
    
    // Assume a rate counter after the count counter
    IncrementValue32( dwServerCounterID + 2, 1 );   
}

//////////////////////////////////////////////////////////////////////////////
QWORD CXEventsPerfCounters::GetCurrentValue64(DWORD dwCounterID)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    return( *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::SetCurrentValue64(DWORD dwCounterID, QWORD qwVal )
{

    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = qwVal;
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::IncrementValue64(DWORD dwCounterID, QWORD qwAmount)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += qwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CXEventsPerfCounters::DecrementValue64(DWORD dwCounterID, QWORD qwAmount)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XEVENTPERF_SERVER_OBJECT  ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XEPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData -= qwAmount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\StdAfx.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C1DDAA91_D146_4EBD_B5C0_0DA1889C2332__INCLUDED_)
#define AFX_STDAFX_H__C1DDAA91_D146_4EBD_B5C0_0DA1889C2332__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

// Disable warning: unreferenced formal parameter
#pragma warning( disable : 4100 )
// Disable warning: conditional expression is constant
#pragma warning( disable : 4127 )

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <icecap.h>

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

#ifndef WRAP_DWORD_DIFF
#define WRAP_DWORD_DIFF
__forceinline DWORD WrapDWORDDiff( DWORD dwStart, DWORD dwEnd )
{
    if( dwEnd > dwStart )
    {
        return dwEnd - dwStart;
    }
    else
    {
        return (0xFFFFFFFF - dwStart) +  dwEnd;
    }
}
#endif

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

#include <commonconfig.h>

#include "wmsstd.h"
#include "xalloc.h"
#include "xmgmt.h"
#include "wsockntp.h"
#include "xonlinep.h"
#include "ntservice.h"
#include "servsock.h"
#include "tcpcnt.h"
#include "atldbcli.h"
#include "xeventids.h"

#include "xevents.h"
#include "switchboard.h"
#include "connector.h"
#include "batch.h"
#include "sqlnsstore.h"
#include "perfapi.h"
#include "xeventperf.h"
#include "perfctrs.h"
#include "config.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C1DDAA91_D146_4EBD_B5C0_0DA1889C2332__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\switchboard.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"


//-----------------------------------------------------------------------------
//
// CSwitchboard
//
// Main object for most service tasks.  Holds the main IO Completion port,
//  listening socket and instances other major objects.
//
//-----------------------------------------------------------------------------

CSwitchboard::CSwitchboard(  )
{
    m_hrInit = S_OK;
    
    m_pCompletionPort = NULL;
    
    //
    // Create Completion Ports to incoming remote data. 
    //
    m_hrInit = CCompletionPort::CreateInstance(
                        g_CXEventsConfig.GetThreads(), 
                        g_CXEventsConfig.GetThreads(), 
                        THREAD_PRIORITY_NORMAL, 
                        &m_pCompletionPort);

    if(FAILED(m_hrInit))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_5, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed hr=0x%x", m_hrInit);
    }

    m_pConnector = new CEventsConnector(m_pCompletionPort, this);

    m_pCurrentBatch = new CEventBatch( this, g_CXEventsConfig.GetThreads() );
    m_pPreviousBatch = new CEventBatch( this, g_CXEventsConfig.GetThreads() );
    
    m_pStore = new CSQLNSStore(this);    
}

CSwitchboard::~CSwitchboard()
{
    if (m_pCompletionPort)
    {
        m_pCompletionPort->Shutdown();
    }

    SAFE_DELETE(m_pStore);

    SAFE_DELETE(m_pCurrentBatch);
    SAFE_DELETE(m_pPreviousBatch);
    
    SAFE_RELEASE(m_pCompletionPort);

    SAFE_DELETE(m_pConnector);    
}

//-----------------------------------------------------------------------------
//
// Init
//
// Must be called before first use
//
//-----------------------------------------------------------------------------
HRESULT CSwitchboard::Init()
{
    if (FAILED(m_hrInit))
    {
        // Should have already logged an event in the constructor
        goto lDone;
    }

    m_hrInit = m_pStore->Init();
    if (FAILED(m_hrInit))
    {
        goto lDone;
    }

    m_hrInit = m_pCurrentBatch->Init();
    if (FAILED(m_hrInit))
    {
        goto lDone;
    }
    
    m_hrInit = m_pPreviousBatch->Init();
    if (FAILED(m_hrInit))
    {
        goto lDone;
    }
    
    m_hrInit = m_pConnector->Init();
    if (FAILED(m_hrInit))
    {
        goto lDone;
    }

lDone:
    return m_hrInit;
}


//-----------------------------------------------------------------------------
//
// BatchThreadProc
//
// Process an Event structure received on the wire
//
//-----------------------------------------------------------------------------
DWORD CSwitchboard::BatchControlProc(HANDLE hShutdownEvent)
{
    HRESULT     hr = S_OK;
    
    if ((m_pCurrentBatch == NULL) || (m_pPreviousBatch == NULL))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_6, 
            "CSwitchboard::BatchThreadProc called without batches initialized.");    

        return 0;
    }

    // Start up the first batch. 
    hr = m_pCurrentBatch->StartEventBatch();
    
    for (;;)
    {
        // Wait a while
        DWORD dwRes = WaitForSingleObject(hShutdownEvent, 1000);

        if(dwRes == WAIT_OBJECT_0)      // Shutdown Event
        {
            // Have to reset this for the main service thread to also terminate
            SetEvent(hShutdownEvent);
            
            break;
        }

        if ((FAILED(m_pCurrentBatch->GetLastError())) || (m_pCurrentBatch->GetEventCount() > 0))
        {        
            // Setup the alternate batch
            hr = m_pPreviousBatch->StartEventBatch();

            if (FAILED(hr))
            {
                // Perhaps we failed last time we tried to flush
                m_pPreviousBatch->FlushEventBatch();
            }
            else
            {
                // We have a new batch ready to go - switch
                m_pPreviousBatch = (CEventBatch *)InterlockedExchangePointer((void **)&m_pCurrentBatch, m_pPreviousBatch);

                // Flush the previously current batch to SQL..
                hr = m_pPreviousBatch->FlushEventBatch();            
            }
        }
    }

    // Cleanup remaining batches
    m_pPreviousBatch->FlushEventBatch();
    m_pCurrentBatch->FlushEventBatch();
    
    return 1;
}

//-----------------------------------------------------------------------------
//
// StartEventBatch
//
// Pass along a start batch call
//
//-----------------------------------------------------------------------------
HRESULT CSwitchboard::StartEventBatch(LONGLONG *pqwBatchID)
{
    HRESULT     hr = E_FAIL;
    
    //
    // Pass along the start batch call
    //    
    if (m_pStore)
    {
        hr = m_pStore->StoreStartxLiveBatch(pqwBatchID);
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
// FlushEventBatch
//
// Pass along the FlushBatch call
//
//-----------------------------------------------------------------------------
HRESULT CSwitchboard::FlushEventBatch(LONGLONG qwBatchID, LONGLONG qwEventCount)
{
    HRESULT     hr = E_FAIL;
    
    //
    // Pass along the flush batch call
    //    
    if (m_pStore)
    {
        hr = m_pStore->StoreFlushxLiveBatch(qwBatchID, qwEventCount);
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
// ProcessEvent
//
// Process an Event structure received on the wire
//
//-----------------------------------------------------------------------------
HRESULT CSwitchboard::ProcessEventMessage(BYTE *pBuffer, DWORD cbBuffer)
{
    HRESULT         hr = E_FAIL;
    CEventBatch     *pBatch = m_pCurrentBatch;

    //
    // Process the Event
    //    
    if ( (pBatch) && (m_pStore) )
    {
        UINT            index = 0;
        UINT            nEventCount = 0;
        
        hr = pBatch->BeforeProcessEvent(&index);

        if (FAILED(hr))
        {
            goto lDone;
        }
        
        hr = m_pStore->ProcessEventMessage(pBatch->GetBatchID(), pBuffer, cbBuffer, &nEventCount);

        pBatch->AfterProcessEvent(hr, index, nEventCount);
    }

lDone:
    //
    // Keep track of things
    //
    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage(XEVENTPERF_SERVER_EVENTS_TOTAL_COUNTER);
    }
    else
    {
        g_Counters.TrackFailureMessage(XEVENTPERF_SERVER_EVENTS_FAILED_COUNTER);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\sqlnsstore.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

#define DBINITCONSTANTS
#include "sqloledb.h"


//-----------------------------------------------------------------------------
//
// CSQLNSStore
//
// Talks to the SQLNS Store
//
//-----------------------------------------------------------------------------
CSQLNSStore::CSQLNSStore( CSwitchboard *pSwitchboard  )
{
    m_pSwitchboard = pSwitchboard;

    InitializeCriticalSection(&m_cs);

    m_pDS = NULL;
}

CSQLNSStore::~CSQLNSStore()
{
    Cleanup();
}


//-----------------------------------------------------------------------------
//
// Init
//
// Setup persistent objects for this instance
//
//-----------------------------------------------------------------------------
HRESULT CSQLNSStore::Init( )
{
    HRESULT     hr = S_OK;
    CLSID       clsid;
    
    EnterCriticalSection(&m_cs);

    if (NULL == m_pDS)
    {
    	CComBSTR bsIPAddress;
    	CComBSTR bsDBName;
        
    	hr = g_CXEventsConfig.GetAlertsInterface()->get_IPAddressString(&bsIPAddress);
    	if (FAILED(hr))
    	{
            XomNtEvent(XEVENT_ALERTS_CONFIG_6, "pInterfaceInfo->get_IPAddressString failed: (0x%08x)\n", hr);
            goto Cleanup;	     
    	}

    	hr = g_CXEventsConfig.GetAlertsInterface()->get_DBName(&bsDBName);
    	if (FAILED(hr))
    	{
            XomNtEvent(XEVENT_ALERTS_CONFIG_7, "pInterfaceInfo->get_DBName failed: (0x%08x)\n", hr);
            goto Cleanup;	     
    	}
    
        // Initialize the server properties
        m_propSet[0].SetGUID(DBPROPSET_DBINIT);

        if (    FALSE == m_propSet[0].AddProperty(DBPROP_AUTH_INTEGRATED, L"SSPI") ||
                FALSE == m_propSet[0].AddProperty(DBPROP_INIT_CATALOG, bsDBName) ||
                FALSE == m_propSet[0].AddProperty(DBPROP_INIT_DATASOURCE, bsIPAddress) ||
                FALSE == m_propSet[0].AddProperty(DBPROP_INIT_LCID, (long)0x409) ||
                FALSE == m_propSet[0].AddProperty(DBPROP_INIT_PROMPT, (short)DBPROMPT_NOPROMPT) ||
                FALSE == m_propSet[0].AddProperty(DBPROP_INIT_TIMEOUT, (long)20))
        {
            XomNtEvent(XEVENT_XEVENTS_NULL_BUFFER, 
                "CSQLNSStore::Init: Could not initialize cached property sets.");
                
            hr = HRESULT_FROM_WIN32(ERROR_CANTREAD);
            goto Cleanup;
        }

        m_propSet[1].SetGUID(DBPROPSET_SQLSERVERDBINIT);

        if (FALSE == m_propSet[1].AddProperty(SSPROP_INIT_NETWORKLIBRARY, L"DBMSSOCN")) // DBMSSOCN for TCP/IP, DBNMPNTW for Named Pipes
        {
            XomNtEvent(XEVENT_XEVENTS_NULL_BUFFER_1, 
                "CSQLNSStore::Init: Could not initialize cached property sets.");
                
            hr = HRESULT_FROM_WIN32(ERROR_CANTREAD);
            goto Cleanup;
        }

        // Get CLSID of SQLOLEDB
        hr = CLSIDFromProgID(L"SQLOLEDB.1", &clsid);

        m_pDS = new CDataSource();

        if (NULL != m_pDS)
        {
            hr = m_pDS->Open(clsid, m_propSet, 2);
        }
    }

Cleanup:
    LeaveCriticalSection(&m_cs);

    return hr;
}


//-----------------------------------------------------------------------------
//
// Cleanup
//
// Cleanup persistent objects for this instance
//
//-----------------------------------------------------------------------------
void CSQLNSStore::Cleanup()
{
    CDataSource *pds = m_pDS;

    EnterCriticalSection(&m_cs);

    if ((pds == m_pDS) && (m_pDS))
    {
        m_pDS->Close();
        
        SAFE_DELETE(m_pDS);
    }

    LeaveCriticalSection(&m_cs);
    
}


extern __declspec(thread) CSession *g_TLS_session = NULL;

//-----------------------------------------------------------------------------
//
// GetThreadSession
//
// Get the thread local CSession object. Create it if necessary
//
//-----------------------------------------------------------------------------
HRESULT CSQLNSStore::GetThreadSession(CSession **ppSession)
{
    HRESULT     hr = S_OK;
    
    *ppSession = NULL;

    //
    // Setup our thread local session object
    //
    if (NULL == g_TLS_session)
    {
        if ( (NULL == m_pDS) || (m_pDS->m_spInit == NULL) )
        {
            hr = Init();
        }

        if ((NULL == m_pDS) || (FAILED(hr)))
        {
            goto lDone;
        }

        g_TLS_session = new CSession();
        
        hr = g_TLS_session->Open(*m_pDS);
    }

    *ppSession = g_TLS_session;

lDone:
    return hr;
}


//-----------------------------------------------------------------------------
//
// CleanupThreadSession
//
// Get the thread local CSession object. Create it if necessary
//
//-----------------------------------------------------------------------------
void CSQLNSStore::CleanupThreadSession()
{
    if (NULL != g_TLS_session)
    {
        //
        // Cleanup our session in the event of failure 
        //  we will always leak the thread local copy on shutdown... 
        //
        g_TLS_session->Close();
        
        SAFE_DELETE(g_TLS_session);
        
        // Free the dataset as the SQL server prolly died
        Cleanup();
    }
}


//-----------------------------------------------------------------------------
//
// Connect
//
// Process an xLive Alert buffer
//
//-----------------------------------------------------------------------------
HRESULT CSQLNSStore::ProcessEventMessage(LONGLONG qwBatchID, BYTE *pBuffer, DWORD cbBuffer, UINT *pqwEventCount)
{
    HRESULT             hr = S_OK;
    PXONLINE_ALERT      pAlert;
    UINT                cEvents = 0;
    CmdWritexLiveEvent  cmd;    
    LPWSTR              pwszData;
    LPCSTR              pszSender;
    ULONGLONG *         pRecipient;
    CSession *          pSession = NULL;
    

    if ( (NULL == pBuffer) || (NULL == pqwEventCount) )
    {
        XomNtEvent(XEVENT_ALERTS_CODE_7, 
            "CSQLNSStore::ProcessEventMessage called with NULL argument. cbBuffer=%d", 
            cbBuffer);

        hr = E_INVALIDARG;
        goto lDone;        
    }

    if (cbBuffer < sizeof(XONLINE_ALERT))
    {
        XomNtEvent(XEVENT_ALERTS_CODE_8, 
            "CSQLNSStore::ProcessEventMessage called with cbBuffer too small. cbBuffer=%d", 
            cbBuffer);
        
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    pAlert = (PXONLINE_ALERT)pBuffer;
    
    pRecipient = (ULONGLONG *)((BYTE *)pAlert + sizeof(XONLINE_ALERT));
    pwszData = (LPWSTR)(pRecipient + pAlert->wRecipients * 2);
    pszSender = (LPCSTR)(pwszData + pAlert->cchData);
    
    if ( (LPCSTR)(pBuffer + cbBuffer) != (LPCSTR)(pszSender + pAlert->cbSender) )
    {
        XomNtEvent(XEVENT_XEVENTS_BAD_PACKET, 
            "CSQLNSStore::ProcessEventMessage called with incorrect cbBuffer: cbBuffer=%d, Title=%d, Type=%d, wRecipients=%d, cchData=%d, cbSender=%d",
            cbBuffer,
            pAlert->dwTitleID,
            pAlert->wType,
            pAlert->wRecipients,
            pAlert->cchData,
            pAlert->cbSender);
        
        hr = E_INVALIDARG;
        goto lDone;
    }

    if ( pAlert->cbSender > XONLINE_MAX_GAMERTAG_LENGTH )
    {
        XomNtEvent(XEVENT_XEVENTS_BAD_PACKET_1, 
            "CSQLNSStore::ProcessEventMessage called with invalid cbSender > max of %d: cbBuffer=%d, Title=%d, Type=%d, wRecipients=%d, cchData=%d, cbSender=%d",
            XONLINE_MAX_GAMERTAG_LENGTH,
            cbBuffer,
            pAlert->dwTitleID,
            pAlert->wType,
            pAlert->wRecipients,
            pAlert->cchData,
            pAlert->cbSender);
        
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    if (pAlert->wRecipients == 0)
    {
        // No work to do
        goto lDone;
    }

    //
    // Prepare to talk to the database
    //
    hr = GetThreadSession(&pSession);

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_ALERTS_COMM_2, 
            "CSQLNSStore::ProcessEventMessage failed to open CSession object: hr=%d",
            hr);

        goto lDone;
    }


    //
    // Setup our cmd object. All the events take the same form, so we just reuse the same object repeatedly. 
    //
    cmd.m_qwEventBatchID = qwBatchID;
    cmd.m_dwType = pAlert->wType;
    cmd.m_wFlags = pAlert->wFlags;

    MultiByteToWideChar(CP_ACP, 0, pszSender, pAlert->cbSender, cmd.m_wszSender, XONLINE_GAMERTAG_SIZE);
    
    wcsncpy(cmd.m_wszData, pwszData, pAlert->cchData);
    cmd.m_wszData[pAlert->cchData] = L'\0';
    
    cmd.m_iTitleID = pAlert->dwTitleID;
    cmd.m_qwSenderXUID = pAlert->qwSenderUserID;

    //
    // Loop through the Alert and write an event for each recipient
    //    
    for(int i=0; i<pAlert->wRecipients; i++)
    {
        HRESULT     hrEvent = S_OK;
        DWORD       dwHigh;
        DWORD       dwLow;

        // MSAlerts requires the recipient or subscriberID (xbox webid) to be 
        //  formatted as a string of the form: 0x00020100:0x02EEE066

        dwHigh = (DWORD)(*pRecipient >> 32);
        dwLow = (DWORD)*pRecipient;

        wsprintfW((LPWSTR)cmd.m_wszRecipient, L"0x%.8x:0x%.8x", dwHigh, dwLow);

        pRecipient++;

        cmd.m_qwRecipientXUID = *pRecipient;
        
        // Execute the command
        hrEvent = cmd.CmdWritexLiveEvent::Open(*pSession);

        if ( SUCCEEDED(hrEvent) && (cmd.m_ret != 0) )
        {            
            hrEvent = E_FAIL;
        }

        if (FAILED(hrEvent))
        {
            XomNtEvent(XEVENT_ALERTS_COMM_3, "WritexLiveBatch failed with hr=%X, ret=%d", hrEvent, cmd.m_ret);
            
            hr = hrEvent;
        }
        else
        {
            cEvents++;
        }                    

        cmd.CmdWritexLiveEvent::Close();        
        pRecipient++;
    }
    
lDone:

    *pqwEventCount = cEvents;
    
    if ( (FAILED(hr)) && (pSession != NULL) )
    {
        CleanupThreadSession();        
    }   
        
    return hr;
}

//-----------------------------------------------------------------------------
//
// StoreStartxLiveBatch
//
// Start a SQLNS batch for SQLNS events
//
//-----------------------------------------------------------------------------
HRESULT CSQLNSStore::StoreStartxLiveBatch(LONGLONG *pqwBatchID)
{
    HRESULT     hr = S_OK;
    CSession    *pSession = NULL;
    CmdStartxLiveBatch cmd;    

    // Check parameters
    if ( pqwBatchID == NULL )
    {
        hr = E_INVALIDARG;
        goto lDone;
    }


    //
    // Prepare to talk to the database
    //
    hr = GetThreadSession(&pSession);

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_ALERTS_COMM_4, 
            "CSQLNSStore::StoreStartxLiveBatch failed to open CSession object: hr=%d",
            hr);

        goto lDone;
    }


    // Initialize output param
    *pqwBatchID = 0;

    
    // Execute the command
    hr = cmd.CmdStartxLiveBatch::Open(*pSession);

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_ALERTS_COMM_5, 
            "StoreStartxLiveBatch failed to open CMD with hr=%X", 
            hr);
        goto lDone;
    }
    
    if (cmd.m_ret != 0)
    {
        hr = E_FAIL;
        XomNtEvent(XEVENT_ALERTS_COMM_6, 
            "StoreStartxLiveBatch CMD failed with ret=%d", 
            cmd.m_ret);
        goto lDone;
    }
    
    *pqwBatchID = cmd.m_qwEventBatchID;

lDone:
    if ( (FAILED(hr)) && (pSession != NULL) )
    {
        CleanupThreadSession();        
    }   
        
    return hr;
}


//-----------------------------------------------------------------------------
//
// StoreFlushxLiveBatch
//
// Commit a SQLNS batch to the store
//
//-----------------------------------------------------------------------------
HRESULT CSQLNSStore::StoreFlushxLiveBatch(LONGLONG qwBatchID, LONGLONG qwEventCount)
{
    HRESULT     hr = S_OK;
    CmdFlushxLiveBatch cmd;    
    CSession *pSession = NULL;

    //
    // Prepare to talk to the database
    //
    hr = GetThreadSession(&pSession);

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_ALERTS_COMM_7, 
            "CSQLNSStore::StoreFlushxLiveBatch failed to open CSession object: hr=%d",
            hr);

        goto lDone;
    }


    // Set parameters
    cmd.m_qwEventBatchID = qwBatchID;
    cmd.m_qwEventCount = qwEventCount;
        
        
    // Execute the command
    hr = cmd.CmdFlushxLiveBatch::Open(*pSession);

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_ALERTS_COMM_8, 
            "StoreFlushxLiveBatch failed to open CMD with hr=%X", 
            hr);
        goto lDone;
    }
    
    if (cmd.m_ret != 0)
    {
        hr = E_FAIL;
        XomNtEvent(XEVENT_ALERTS_COMM_9, 
            "StoreFlushxLiveBatch CMD failed with ret=%d", 
            cmd.m_ret);
        goto lDone;
    }
    
lDone:    
    if ( (FAILED(hr)) && (pSession != NULL) )
    {
        CleanupThreadSession();        
    }   
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\msalerts\makefile.inc ===
MSAlertsCopy : makefile.inc
    -robocopy . $(_NT386TREE)\alerts\MSAlerts *.dll /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\xevents.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef XEVENTS_H_INCLUDED
#define XEVENTS_H_INCLUDED

XomImportArea(XEventsLog);
XomImportArea(XEventsDebug);


class CSwitchboard;


//-----------------------------------------------------------------------------
//
// CEventControlCallback
//
// Receives requests from the XOM management framework
//
//-----------------------------------------------------------------------------

class CEventControlCallback : public CXomControlCallback
{
public:

    ULONG __stdcall AddRef () { return 1; }
    ULONG __stdcall Release() { return 1; } 

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

};


//-----------------------------------------------------------------------------
//
// CXEventService
//
// NT Service Implementation for Event service
//
//-----------------------------------------------------------------------------
class CXEventsService : public CNTService
{
public:
    CXEventsService();
    ~CXEventsService();

    DWORD WINAPI BatchControlProc( );
    
    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv );
    virtual HRESULT ShutDownService( void );
    virtual HRESULT RunService( BOOL *pfServiceRan );

private:
    CSwitchboard *      m_pSwitchboard;

    HANDLE              m_thread;   // batch control thread. 
    
};

#endif  // XEVENTS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\switchboard.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef SWITCHBOARD_H_INCLUDED
#define SWITCHBOARD_H_INCLUDED

XomImportArea(XEventsLog);
XomImportArea(XEventsDebug);


const int C_MAX_BUFFER_SIZE     = XONLINE_MAX_ALERT_SIZE;       // Max size of the UDP packets being read. 


class CEventsConnector;
class CSQLNSStore;
class CEventBatch;


//-----------------------------------------------------------------------------
//
// CSwitchboard
//
// Main object for most service tasks.  Holds the main IO Completion port,
//  listening socket and instances other major objects.
//
//-----------------------------------------------------------------------------

class CSwitchboard
{
public:

    // CEventsConnector
    CSwitchboard();
    ~CSwitchboard();

    HRESULT Init( void );

    DWORD   BatchControlProc(HANDLE hShutdownEvent);
    
    HRESULT StartEventBatch(LONGLONG *pqwBatchID);
    HRESULT FlushEventBatch(LONGLONG qwBatchID, LONGLONG qwEventCount);
    HRESULT ProcessEventMessage( BYTE *pBuffer, DWORD cbBuffer );


private:    
    CCompletionPort *   m_pCompletionPort;
    CEventsConnector *  m_pConnector;
    CSQLNSStore *       m_pStore;
    CEventBatch *       m_pCurrentBatch;    
    CEventBatch *       m_pPreviousBatch;

    HRESULT             m_hrInit; 
};


#endif  // SWITCHBOARD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\test\transforms\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\sqlns\appdefinition\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying AppDefinition...
    -robocopy . $(_NT386TREE)\Alerts\AppDefinition appADF.xml /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\sqlns\formatters\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying Formatters...
    -robocopy . $(_NT386TREE)\Alerts\AppDefinition\Formatters /MIR /R:0 /NP /NJH /NJS /A-:R /XF build.log build.err build.wrn buildd.log buildd.err buildd.wrn exclude.txt makefile makefile.inc sources /XD obj objd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\inh\xevents\xevents.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

BOOL                        g_bSimulateTooBusy = FALSE;
CEventControlCallback       g_ControlCallback;

static CXEventsService      g_Service;
CNTService *                g_pService = &g_Service;


//-----------------------------------------------------------------------------
//
// CEventControlCallback
//
// Receives requests from the XOM management framework
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// OnControlRequest
//
// Process a single management framework request
//
//-----------------------------------------------------------------------------
HRESULT CEventControlCallback::OnControlRequest(
            LPCSTR pszRequest,
            DWORD dwRequestId,
            CXomControlResponseInterface* pResponseInterface )
{
    //
    // TODO: Management commands for XEvents
    //

    return S_OK;
}


//-----------------------------------------------------------------------------
//
// BatchThreadProc
//
// Thread proc for managing the pair of persistent batch objects
//
//-----------------------------------------------------------------------------

DWORD WINAPI ThreadProc( LPVOID lpParameter )
{
    CXEventsService    *pSvc = (CXEventsService *)lpParameter;

    return(pSvc->BatchControlProc());
}


//-----------------------------------------------------------------------------
//
// CXEventsService
//
// NT Service Implementation for XEvents service
//
//-----------------------------------------------------------------------------

CXEventsService::CXEventsService() :
        CNTService(
            L"XEvents",
            L"Xbox Alerts Event Listener Service",
            L"Accumulates Alert events and forwards them to local SQLNS Instance",
            L"XEventPerf" )
{
}


CXEventsService::~CXEventsService()
{
}


//-----------------------------------------------------------------------------
//
// BatchThreadProc
//
// Thread proc for managing the pair of persistent batch objects
//
//-----------------------------------------------------------------------------

DWORD WINAPI CXEventsService::BatchControlProc( )
{
    return(m_pSwitchboard->BatchControlProc(g_Service.ShutdownEvent()));
}

//-----------------------------------------------------------------------------
//
// InitService
//
// Read config and setup internal datastructures
//
//-----------------------------------------------------------------------------
HRESULT CXEventsService::InitService( DWORD dwArgc, LPWSTR *pszArgv )
{
    HRESULT hr = S_OK;

    // Init core logging and tracing
    hr = g_xomcentral.Init("XEvents");

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_7, "Unrecoverable failure while initializing: Failed to init g_xomcentral: hr=0x%X", hr);
        goto lDone;
    }

    hr = g_xomcentral.RegisterControlCallback(&g_ControlCallback);

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_8, "Unrecoverable failure while initializing: Failed to register control callback function: hr=0x%X", hr);
        goto lDone;
    }

    XomNtEvent(XEVENT_ALERTS_INFO_0, "XEVENTS STARTING");

    // Initialize Winsock
    WSADATA wsaData;

    int rc = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
    if( 0 != rc )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_9, "Unrecoverable failure while initializing: WSAStartup failed hr=0x%X", hr);
        goto lDone;
    }
    Checkpoint();

    //
    // TODO: Load our configuration data
    //
    hr = g_CXEventsConfig.Load();

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_10, "Unrecoverable failure while initializing: Load configuration failed hr=0x%X", hr);
        goto lDone;
    }
    Checkpoint();

    // Initialize perfmon counters
    hr = g_Counters.Init();
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_11, "Unrecoverable failure while initializing: Failed to init perf counters hr=0x%X", hr);
        goto lDone;
    }
    Checkpoint();

    m_pSwitchboard = new CSwitchboard();
    Checkpoint();

    m_pSwitchboard->Init();
    Checkpoint();

    m_thread = CreateThread(NULL, 0, &ThreadProc, this, 0, NULL);
    Checkpoint();


lDone:
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_XEVENTS_FAIL_INIT_12, "Unrecoverable failure while initializing: InitService returning hr=0x%X", hr);
    }

    return( hr );
}


//-----------------------------------------------------------------------------
//
// ShutDownService
//
// Free internal resources
//
//-----------------------------------------------------------------------------
HRESULT CXEventsService::ShutDownService(  )
{
    WaitForSingleObject(m_thread, INFINITE);
    CloseHandle(m_thread);

    SAFE_DELETE(m_pSwitchboard);

    return S_OK;
}


//-----------------------------------------------------------------------------
//
// RunService
//
// Main service control
//
//-----------------------------------------------------------------------------
HRESULT CXEventsService::RunService( BOOL *pfServiceRan )
{
    HRESULT     hr = S_OK;

    if (pfServiceRan == NULL)
    {
        return E_INVALIDARG;
    }

    *pfServiceRan = TRUE;

    XomNtEvent(XEVENT_ALERTS_INFO_1, "XEVENTS STARTED");

    //
    // Have this thread hang out until the server is told to shut down.
    //
    for(;;)
    {
        DWORD dwRes = WaitForSingleObject(ShutdownEvent(), 100);

        if(dwRes == WAIT_OBJECT_0)      // Shutdown Event
        {
            // Have to reset this for the batch control thread to also terminate
            SetEvent(ShutdownEvent());

            break;
        }
    }

    XomNtEvent(XEVENT_ALERTS_INFO_2, "XEVENTS STOPPING");

    WSACleanup();

    hr = ShutDownService();

    XomNtEvent(XEVENT_ALERTS_INFO_3, "XEVENTS STOPPED");

    g_xomcentral.Term();

    XDumpLeaks();

    return S_OK;
}


//-----------------------------------------------------------------------------
//
// Main
//
//-----------------------------------------------------------------------------
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    return( g_Service.ProcessMain( argc, argv ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\sqlns\sqlns\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying sqlns...
    -robocopy $(XONEXTPATH)\alerts $(_NTTREE)\sqlns /MIR /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\fd\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.server.arbitration.fd
{

    [XomPerformanceCounterCategoryAttr( "Arbitration FD", "Xbox Live: Arbitration Server performance counters" )]

    public class XArbitrationServerCounters : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "Register calls per second", 
             "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RegisterRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Register calls total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RegisterRequestsTotal;

        [XomPerformanceCounterAttr(
             "TimeExtend calls per second", 
             "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TimeExtendRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "TimeExtend calls total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TimeExtendRequestsTotal;

        [XomPerformanceCounterAttr(
             "ReportResult calls per second", 
             "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ReportResultRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "ReportResult calls total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ReportResultRequestsTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Normal Sessions/sec", 
             "Number of normally finishing sessions per second in the current AppDomain.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter NormalSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Normal Sessions", 
             "Total number of normally ending sessions in the current AppDomain.",  
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NormalSessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Minority Sessions/sec", 
             "Number of Minority sessions per second in the current AppDomain.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MinoritySessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Minority Sessions", 
             "Total number of Minority sessions in the current AppDomain.",  
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MinoritySessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Failed Sessions/sec", 
             "Number of Failed sessions per second in the current AppDomain.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Failed Sessions", 
             "Total number of Failed sessions in the current AppDomain.",  
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedSessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Problematic Sessions/sec", 
             "Number of Problematic sessions per second in the current AppDomain.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ProblematicSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Problematic Sessions", 
             "Total number of Problematic ending sessions in the current AppDomain.",  
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ProblematicSessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration UDPReport Sessions/sec", 
             "Number of UDPReport sessions per second in the current AppDomain.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter UDPReportSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total UDPReport Sessions", 
             "Total number of UDPReport ending sessions in the current AppDomain.",  
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter UDPReportSessionTotal;


        [XomPerformanceCounterAttr(
             "Currently active sessions", 
             "Number of active arbitration sessions in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveSessions;

        [XomPerformanceCounterAttr(
             "Currently active Xboxes",
             "Number of Xboxes involved in active sessions in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveXboxes;

        [XomPerformanceCounterAttr(
             "Currently active Users",
             "Number of Users involved in active sessions in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveUsers;
        
        [XomPerformanceCounterAttr(
             "Queued Bundles",
             "Number of queued bundle submissions in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueuedBundleCount;
        
        [XomPerformanceCounterAttr(
             "Queued Trust Updates",
             "Number of queued user trust updates in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueuedTrustUpdateCount;
        
        static public XArbitrationServerCounters Counters = new XArbitrationServerCounters();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\fd\xarbfeapp.cs ===
/*
 * Copyright (c) 2006 Microsoft Corporation
 * 
 * Arbitration Front-Door
 * 
 * xarbfeapp.cs
 * 
 * Arbitration front-end application class
 * 
 * */
using System;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.server.arbitration.fd
{
    public class XArbFrontEndApp : FrontEndApp
    {
        // Application_Start
        // Gets called during application start up
        protected override void OnApplicationStart()
        {
            Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(OnArbBucketChange);

            Config.VirtualInterfaceChange += OnVirtualInterfaceChange;
        }

        public static void OnArbBucketChange(object sender, InterfaceBucketChangeEventArgs e)
        {
        }

        public void OnVirtualInterfaceChange(object o, VirtualInterfaceChangeEventArgs e)
        {
            // We don't need to do anything here.  We are only handling this
            // event because if we don't, changes get vetoed by default.  We
            // don't cache virtual interface information so all virtual interface
            // changes are cool by us.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\alerts\test\transforms\transform.cs ===
using NUnit.Framework;
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;
using xonline.common.service;

using xonline.common.mgmt;


namespace xonline.server.alerts.test.transforms 
{
    [TestFixture]
    public class Transform
    {    
        const string    c_inputFile = "e:\\xonline\\private\\alerts\\test\\transforms\\notification.xml";
        const string    c_transformFile = "e:\\xonline\\private\\alerts\\test\\transforms\\xLiveAlerts.xslt";
        
        // Load an XML Document
        private void WriteFormattedXml(string xml)
        {
            XmlDocument   xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xml);
            XmlTextWriter writer = new XmlTextWriter(Console.Out);
            writer.Formatting = Formatting.Indented;
            xmlDoc.WriteContentTo( writer );
            writer.Flush();
            Console.WriteLine();                    
        }


        // Load an XML Document
        private String LoadXmlData(
            String XmlDataPath)
        {
            XmlTextReader   reader;
            String          xmlData;

            reader = new XmlTextReader(XmlDataPath);

            reader.MoveToContent();

            xmlData = reader.ReadOuterXml();

            reader.Close();
            
            return xmlData;
        }

        
        // This code supports the ApplyTransformTo method below by loading
        //  our private test transform
        private XslTransform LoadTransform(
            String subscriberLocale, 
            String deviceTypeName,
            out String transformPath)
        {
            String          xmlTransform;
            XslTransform    xslt = new XslTransform();
            
            transformPath = c_transformFile;

            Console.WriteLine("Loading XML Transform");
            Console.WriteLine();

            xmlTransform = LoadXmlData(transformPath);

            WriteFormattedXml(xmlTransform);
            Console.WriteLine();

            xslt.Load(transformPath);
            
            return xslt; 
        }
        
            
        // This code is taken directly from the SQLNS source tree, as to how they 
        //  do .xslt transforms
        private String ApplyTransformTo(
            String  contentXml, 
            String  subscriberLocale, 
            String  deviceTypeName ) 
        {
            String          transformPath    = null;
            XslTransform    xslt             = LoadTransform(subscriberLocale, deviceTypeName, out transformPath);
            XPathDocument   xpathdocument    = new XPathDocument(new XmlTextReader(new StringReader(contentXml)));
            StringBuilder   formattedContent = new StringBuilder();
          
            TextWriter      writer           = new StringWriter(formattedContent);

            try 
            {
                XsltArgumentList paramList = new XsltArgumentList();
                paramList.AddParam("subscriberLocale" , "", subscriberLocale);              
                paramList.AddParam("deviceTypeName" , "", deviceTypeName);
                // paramList.AddParam("digest"         , "", digest);

                xslt.Transform(xpathdocument, paramList, writer, null);
            }
            catch(XsltException e) 
            {
                Assert.IsTrue(transformPath != null);
/*
                NSEventParameters eventParameters = new NSEventParameters();
                eventParameters.AddParameter(NSEventParamEnum.XsltTransformFile, transformPath);
                throw new NSException(NSEventEnum.XsltInvalidTransform, eventParameters, e);
*/
                throw e;
            }
            finally
            {
                writer.Close();
            }
            
            return formattedContent.ToString();
        }        

        
        [Test]
        public void TestTransform()
        {  
            String  xmlData;
            String  xmlResult;
            
            // Load the data
            Console.WriteLine("Loading XML Data");
            Console.WriteLine();

            xmlData = LoadXmlData(c_inputFile);

            WriteFormattedXml(xmlData);
            Console.WriteLine();

            // Do SQLNS like transform
            xmlResult = ApplyTransformTo(xmlData, "en-US", "FileDevice");
            
            Console.WriteLine("Results of Transformation:");
            Console.WriteLine();

            // Format the output
            WriteFormattedXml(xmlResult);
            Console.WriteLine();            
            
            Console.WriteLine("Done");
            Console.WriteLine();
            
        }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.arbitration.inh
{

    [XomPerformanceCounterCategoryAttr( "Arbitration Svc", "Xbox Live: Arbitration Server performance counters" )]

    public class XArbitrationServerCounters : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "Register calls per second",
             "Number of operations executed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RegisterRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Register calls total",
             "Total requests recorded in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RegisterRequestsTotal;

        [XomPerformanceCounterAttr(
             "TimeExtend calls per second",
             "Number of operations executed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TimeExtendRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "TimeExtend calls total",
             "Total requests recorded in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TimeExtendRequestsTotal;

        [XomPerformanceCounterAttr(
             "TimeExtend failed calls per second",
             "Number of operations failed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TimeExtendFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "TimeExtend failed calls total",
             "Total requests failed in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TimeExtendFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "ReportResult calls per second",
             "Number of operations executed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ReportResultRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "ReportResult calls total",
             "Total requests recorded in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ReportResultRequestsTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Normal Sessions/sec",
             "Number of normally finishing sessions per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter NormalSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Normal Sessions",
             "Total number of normally ending sessions in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NormalSessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Minority Sessions/sec",
             "Number of Minority sessions per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MinoritySessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Minority Sessions",
             "Total number of Minority sessions in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MinoritySessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Failed Sessions/sec",
             "Number of Failed sessions per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Failed Sessions",
             "Total number of Failed sessions in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedSessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration Problematic Sessions/sec",
             "Number of Problematic sessions per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ProblematicSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total Problematic Sessions",
             "Total number of Problematic ending sessions in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ProblematicSessionTotal;

        [XomPerformanceCounterAttr(
             "Arbitration UDPReport Sessions/sec",
             "Number of UDPReport sessions per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter UDPReportSessionsPerSecond;

        [XomPerformanceCounterAttr(
             "Arbitration total UDPReport Sessions",
             "Total number of UDPReport ending sessions in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter UDPReportSessionTotal;


        [XomPerformanceCounterAttr(
             "Currently active sessions",
             "Number of active arbitration sessions in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveSessions;

        [XomPerformanceCounterAttr(
             "Currently active Xboxes",
             "Number of Xboxes involved in active sessions in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveXboxes;

        [XomPerformanceCounterAttr(
             "Currently active Users",
             "Number of Users involved in active sessions in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveUsers;

        [XomPerformanceCounterAttr(
             "Queued Bundles",
             "Number of queued bundle submissions in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueuedBundleCount;

        [XomPerformanceCounterAttr(
             "Queued Trust Updates",
             "Number of queued user trust updates in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueuedTrustUpdateCount;

        static public XArbitrationServerCounters Counters = new XArbitrationServerCounters();
    }


    [XomPerformanceCounterCategoryAttr( "Arbitration Svc - Session Buckets", "Per-bucket breakdowns of arbitration session activity" )]
    public class XArbitrationBucketCounters : XomPerformanceCounterCategory
    {

        static public XArbitrationBucketCounters _instance = new XArbitrationBucketCounters();
        static public XArbitrationBucketCounters Current(string bucketId)
        {
            if (bucketId == null)
            {
                bucketId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return(XArbitrationBucketCounters)_instance.GetInstance(bucketId);
        }


        // Add request counters

        [XomPerformanceCounterAttr(
              "Active sessions",
              "Number of active sessions in the current AppDomain",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveSessions;


    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\fd\XArbFdUtil.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Arbitration Service
//

using System;
using System.IO;
using System.Web;
using System.Security.Cryptography;
using System.Text;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.diagnostics;


namespace xonline.server.arbitration.fd
{
    public class XArbFdUtil
    {
        public static HResult BroadcastToINH(HttpContext ctx)
        {
            byte[] buf;
            return BroadcastToINH(ctx, out buf);
        }

        protected static void MigrateHeader(HttpContext ctx, string headerName, XrlRequest req)
        {
            string headerValue = ctx.Request.Headers[headerName];
            if (headerValue != null)
            {
                req.RequestHeaders.Add(headerName, headerValue);
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "migrating header '" + headerName + ": " + headerValue + "' to outgoing request");
            }
        }

        public static HResult BroadcastToINH(HttpContext ctx, out byte[] respData)
        {
            XrlRequest curReq = null;
            XrlRequest nextReq = null;
            HResult hr;

            BinaryReader reader = new BinaryReader(ctx.Request.InputStream);
            reader.BaseStream.Seek(8, SeekOrigin.Begin);

            ulong sessionId = reader.ReadUInt64();

            uint partition = Config.GetBucketNum(Interface.xarbInh, sessionId);
            IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, partition);

            curReq = new XrlRequest();
            curReq.TargetUrl = bucket.CurrentServer.Url;
            curReq.Path = ctx.Request.Path.ToLower().Replace("/xarb/", "/xarbinh/");

            MigrateHeader(ctx, "AdaptedFromUDP", curReq);
            MigrateHeader(ctx, "AlternateStatsDestination", curReq);
            MigrateHeader(ctx, "AlternateQueryDestination", curReq);

            ctx.Request.InputStream.Seek(0, SeekOrigin.Begin);
            curReq.PostData = reader.ReadBytes(ctx.Request.ContentLength);

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "posting to " + curReq.Url.ToString() + "...");

            hr = curReq.Send();

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, curReq.Url.ToString() + " returned " + hr);

            if (HResult.Failed(hr))
            {
                throw new XRLExceptionWithoutEvent(hr, "The INH server returned an error!\r\nServer: " + curReq.Url + "\r\n");
            }

            if (hr != HResult.S_FALSE)
            {
                // S_OK, or XONLINE_S_ARBITRATION_*
                respData = curReq.ResponseData;
            }
            else
            {
                if (bucket.CurrentServerName != bucket.NextServerName)
                {
                    //migration is planned
                    if (DateTime.UtcNow > bucket.NextServerStart)
                    {
                        //migration has started - so try the next server
                        nextReq = new XrlRequest();
                        nextReq.TargetUrl = bucket.NextServer.Url;
                        nextReq.Path = curReq.Path;
                        nextReq.PostData = curReq.PostData;

                        MigrateHeader(ctx, "AdaptedFromUDP", nextReq);
                        MigrateHeader(ctx, "AlternateStatsDestination", nextReq);
                        MigrateHeader(ctx, "AlternateQueryDestination", nextReq);

                        hr = nextReq.Send();

                        if (hr == HResult.S_FALSE)
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_SESSION_NOT_FOUND, XEvent.Id.ARBITRATION_TITLEBUG_0, "Server at " + nextReq.Url + "did not detect migration! Use Xmgmtc to refresh configcache");
                        }
                    }
                }

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.ARBITRATION_COMM_2, "The INH server returned an error!\r\nServer: " + nextReq.Url + "\r\n");
                }

                if (hr == HResult.S_FALSE)
                {
                    throw new XRLException(HResult.XONLINE_E_ARBITRATION_SESSION_NOT_FOUND, XEvent.Id.ARBITRATION_TITLEBUG_1, "Current server returned S_FALSE, indiciating the session didn't "+
                        " belong to it!!\r\n" +
                        " CurrentServer: " + curReq.Url + "\r\n");
                }

                // phew! the call succeeded on the second server!
                respData = nextReq.ResponseData;
            }

            return hr;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbApp.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.server.arbitration.inh 
{
    public class ArbApp : FrontEndApp
    {
        protected override void OnApplicationStart()
        {
            XArbMgmt.Init();

            InitializeInterfaceBucket();

            Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(OnArbBucketChange);
        }

        public static void InitializeInterfaceBucket()
        {
            uint nBucketCountForArbInh = Config.GetBucketCount(Interface.xarbInh);

            for (uint i=0;i<nBucketCountForArbInh;i++)
            {
                IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, i); 
                SessionManager.RecordMigrationPlannedOnStartup(bucket, i);
            }
        }

	    public static void OnArbBucketChange(object sender, InterfaceBucketChangeEventArgs e)
        {
            if (e.Interface == Interface.xarbInh)
            {
                InterfaceBucketChangeIntercept.OnInterfaceBucketChange(sender, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbAPI.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Arbitration Service
//

using System;
using System.IO;
using System.Web;
using System.Security.Cryptography;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstallerAttribute( Interface.xarbInh )]
[assembly: ConfigAttribute(Component.xarbInh)]

namespace xonline.server.arbitration.inh
{
    public class Register : IHttpHandler
    {
        public const ushort XONLINE_XARB_REGISTER_VERSION = 1;

        static Register()
        {
            XArbMgmt.Init();
        }

        //
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            try
            {
                XArbitrationServerCounters.Counters.RegisterRequestsPerSecond.Increment();
                XArbitrationServerCounters.Counters.RegisterRequestsTotal.Increment();
                byte[] response = null;
                HResult hr = HResult.S_OK;

                // fake out the SGInfo to not validate the port of origin
                CallSource.Set(ctx, VirtualInterface.xarb_int);

                BinaryReader reader = new BinaryReader(ctx.Request.InputStream);

                ushort version = reader.ReadUInt16();

                if (version != XONLINE_XARB_REGISTER_VERSION)
                {
                    throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_1, "Register request has invalid version: " + version.ToString() + "\r\n" );
                }

                ushort flags = reader.ReadUInt16();

                ArbitratedSession s = SessionManager.FindOrCreateSession(reader.ReadBytes(20));
                if (s == null)
                {
                    hr = HResult.S_FALSE;
                    goto end;
                }

                response = s.Register(flags, reader);
end:
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, hr, response);
            }
            catch (XRLException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_2, "Error processing Register request\r\n", e);
            }
        }

        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }

    public class TimeExtend : IHttpHandler
    {
        public const ushort XONLINE_XARB_TIME_EXTEND_VERSION = 1;

        static TimeExtend()
        {
            XArbMgmt.Init();
        }

        //
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            try
            {
                XArbitrationServerCounters.Counters.TimeExtendRequestsPerSecond.Increment();
                XArbitrationServerCounters.Counters.TimeExtendRequestsTotal.Increment();
                HResult hr;

                // fake out the SGInfo to not validate the port of origin
                CallSource.Set(ctx, VirtualInterface.xarb_int);

                BinaryReader reader = new BinaryReader(ctx.Request.InputStream);

                ushort version = reader.ReadUInt16();

                if (version != XONLINE_XARB_TIME_EXTEND_VERSION)
                {
                    throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_3, "TimeExtend request has invalid version: " + version.ToString() + "\r\n" );
                }

                ushort flags = reader.ReadUInt16();
                byte[] sessionKey = reader.ReadBytes(20);

                ArbitratedSession s = SessionManager.FindSession(sessionKey);

                if (s == null)
                {
                    hr = HResult.S_FALSE;
                }
                else
                {
                    s.TimeExtend(flags, reader);
                    hr = HResult.S_OK;
                }

                XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, hr);
            }
            catch (Exception e)
            {
                XArbitrationServerCounters.Counters.TimeExtendFailedRequestsPerSecond.Increment();
                XArbitrationServerCounters.Counters.TimeExtendFailedRequestsTotal.Increment();

                if (e is ExceptionWithoutEvent || e is ExceptionWithEventId)
                {
                    throw;
                }
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_4, "Error processing TimeExtend request\r\n", e);
            }
        }

        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }

    public class ReportResult : IHttpHandler
    {
        public const ushort XONLINE_XARB_REPORT_RESULT_VERSION = 1;

        private static bool AllowAlternateDestination
        {
            get { return Config.GetBoolSetting(Setting.xarb_AllowAlternateDestination); }
        }

        static ReportResult()
        {
            XArbMgmt.Init();

            if (AllowAlternateDestination)
            {
              Xom.NtEvent( XEvent.Id.ARBITRATION_CONFIGURATION_ERROR,
                    "AllowAlternateDestination is true! This is only allowed in TestNet. This should NEVER happen in production!" );
            }
        }

        //
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            try
            {
                XArbitrationServerCounters.Counters.ReportResultRequestsPerSecond.Increment();
                XArbitrationServerCounters.Counters.ReportResultRequestsTotal.Increment();

                // fake out the SGInfo to not validate the port of origin
                CallSource.Set(ctx, VirtualInterface.xarb_int);

                BinaryReader reader = new BinaryReader(ctx.Request.InputStream);

                ushort version = reader.ReadUInt16();

                if (version != XONLINE_XARB_REPORT_RESULT_VERSION)
                {
                    throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_5, "ReportResult request has invalid version: " + version.ToString() + "\r\n" );
                }

                ushort flags = reader.ReadUInt16();
                byte[] sessionKey = reader.ReadBytes(20);
                HResult hr;

                ArbitratedSession s = SessionManager.FindSession(sessionKey);

                if (s == null)
                {
                    hr = HResult.S_FALSE;

                    BinaryReader keyReader = new BinaryReader(new MemoryStream(sessionKey));
                    uint  titleID      = keyReader.ReadUInt32();
                    ulong sessionID    = keyReader.ReadUInt64();
                    ulong sessionNonce = keyReader.ReadUInt64();

                    // Using a more descriptive HResult in the log than S_FALSE
                    Xom.Log(XomAreaName.xarblog, "REP|"
                        + HResult.XONLINE_E_ARBITRATION_SESSION_NOT_FOUND + "|"     
                        + titleID.ToString("X") + "|"
                        + sessionID.ToString("X") + "|"
                        + sessionNonce.ToString("X") + "|"
                        + flags.ToString("X") + "|"
                        + "0"  + "|"
                        + "-1" + "|"
                        + "0"  + "|"
                        + "0"  + "|"
                        + "0"  + "|"
                        + "0"  + "|"
                        + "-1" + "|"
                        + "0"
                        );
                }
                else
                {
                    if (ctx.Request.Headers["AdaptedFromUDP"] != null)
                    {
                        flags = ArbitratedSession.SetReportInUDP( flags );
                    }

                    if (AllowAlternateDestination)
                    {
                        if (ctx.Request.Headers["AlternateStatsDestination"] != null)
                        {
                            s.SetAlternateStatsDestination( ctx.Request.Headers["AlternateStatsDestination"] );
                        }
                        if (ctx.Request.Headers["AlternateQueryDestination"] != null)
                        {
                            s.SetAlternateQueryDestination( ctx.Request.Headers["AlternateQueryDestination"] );
                        }
                    }

                    hr = s.ReportResult(flags, reader);

                }

                XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, hr);

            }
            catch (XRLException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_6, "Error processing ReportResult request\r\n", e);
            }
        }

        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }

    public class DebugResult : IHttpHandler
    {
        public const ushort XONLINE_XARB_DEBUG_RESULT_VERSION = 1;

        static DebugResult()
        {
            XArbMgmt.Init();
        }

        //
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            try
            {
                // fake out the SGInfo to not validate the port of origin
                CallSource.Set(ctx, VirtualInterface.xarb_int);

                ArbitrationDebugResultRequest request = new ArbitrationDebugResultRequest();
                ArbitrationDebugResultResponse response;

                request.ReadFromRequest(ctx.Request);

                if (request.version != XONLINE_XARB_DEBUG_RESULT_VERSION)
                {
                    throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_7, "DebugResult request has invalid version: " + request.version.ToString() + "\r\n" );
                }

                ArbitratedSession s = SessionManager.FindSession(request.sessionKey);
                HResult hr = HResult.S_OK;
                byte[] buf = null;

                if (s == null)
                {
                    hr = HResult.S_FALSE;
                }
                else
                {
                    response = s.DebugResult(request);

                    MemoryStream responseStream = new MemoryStream(1024);
                    response.WriteStream(responseStream);
                    buf = responseStream.ToArray();
                }

                XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, hr, buf);
            }
            catch (XRLException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_8, "Error processing DebugResult request\r\n", e);
            }
        }

        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }
}   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\fd\XArbAPI.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Arbitration Service
// 

using System;
using System.IO;
using System.Web;
using System.Security.Cryptography;
using System.Text;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstallerAttribute( Interface.xarb )]
[assembly: XomIisInstallerAttribute( Interface.xarb_int )]
[assembly: ConfigAttribute(Component.xarb)]

namespace xonline.server.arbitration.fd
{
    public class Register : IHttpHandler
    {
        public const ushort XONLINE_XARB_REGISTER_VERSION = 1;


        //      
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            XArbitrationServerCounters.Counters.RegisterRequestsPerSecond.Increment();
            XArbitrationServerCounters.Counters.RegisterRequestsTotal.Increment();
            
            HResult hr;
            XrlRequest req;

            // Check to make sure call is from Internet
            CallSource.Check(VirtualInterface.xarb);    
            
            BinaryReader reader = new BinaryReader(ctx.Request.InputStream);

            ushort version = reader.ReadUInt16();

            if (version != XONLINE_XARB_REGISTER_VERSION)
            {
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT, "Register request has invalid version: " + version.ToString() + "\r\n" );
            }

            reader.ReadUInt16(); // flags
            reader.ReadUInt32(); // titleId
            ulong sessionId = reader.ReadUInt64();

            uint partition = Config.GetBucketNum(Interface.xarbInh, sessionId);
            IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, partition);
            
            
            req = new XrlRequest();
            req.TargetUrl = bucket.CurrentServer.Url;
            req.Path = "/xarbinh/register.ashx";
            
            ctx.Request.InputStream.Seek(0, SeekOrigin.Begin);
            req.PostData = reader.ReadBytes(ctx.Request.ContentLength);
            
            
            hr = req.Send();
            
            if (hr == HResult.S_FALSE)
            {
                // the current inh box doesn't have this data!  we must be in a
                // migration...
                if (bucket.CurrentServerName != bucket.NextServerName && DateTime.UtcNow > bucket.NextServerStart)
                {
                    //migration detected
                    req.TargetUrl = bucket.NextServer.Url;
                    hr = req.Send();
                }
                else
                {
                    throw new XRLException(HResult.XONLINE_E_SESSION_NOT_FOUND, XEvent.Id.ARBITRATION_CONFIG_0, 
                        "Arb inh box returned S_FALSE indiciating the session moved, but bucket config indicates " + 
                        "no migration is taking place!\n" + 
                        "If you expect migration, use xmgmtc command to refresh configcache on ARBFD\n" + 
                        "INH server: " + bucket.CurrentServer + "\r\n" + 
                        "Session ID: " + sessionId.ToString("x"));
                }
            }
                       
            if (hr != HResult.S_OK)
            {
                throw new XRLException(hr, XEvent.Id.ARBITRATION_COMM_0, "Received an error from the INH server!\r\n" + 
                        "Server: " + req.Url.ToString() + "\r\n" + 
                        "hr = " + hr);
            }
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, HResult.S_OK, req.ResponseData);
        }

        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }

    public class TimeExtend : IHttpHandler
    {
        public const ushort XONLINE_XARB_TIME_EXTEND_VERSION = 1;


        //      
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            XArbitrationServerCounters.Counters.TimeExtendRequestsPerSecond.Increment();
            XArbitrationServerCounters.Counters.TimeExtendRequestsTotal.Increment();

            CallSource.Check(VirtualInterface.xarb);            
            
            XArbFdUtil.BroadcastToINH(ctx);
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, HResult.S_OK);
        }

        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }

    public class ReportResult : IHttpHandler
    {
        //      
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            XArbitrationServerCounters.Counters.ReportResultRequestsPerSecond.Increment();
            XArbitrationServerCounters.Counters.ReportResultRequestsTotal.Increment();

            CallSource.Check(VirtualInterface.xarb);            
            
            HResult hr = XArbFdUtil.BroadcastToINH(ctx);
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, hr);
        }

        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }

    public class DebugResult : IHttpHandler
    {

        //      
        // the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            CallSource.Check(VirtualInterface.xarb);            

            byte[] resp;
            HResult hr = XArbFdUtil.BroadcastToINH(ctx, out resp);
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Arbitration, HResult.S_OK, resp);
        }

        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
    }
    
}   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbMemoryPressureBlock.cs ===
namespace xonline.server.arbitration.inh {
   using System;
   using System.Diagnostics;
   using System.Collections.Specialized;
   using System.Collections.Generic;

   using xonline.common.health;
   using xonline.common.config;
   using xonline.common.service;
   using xonline.common.mgmt;

   public class XArbMemoryPressureHealthBlock : IHealthBlock {
      public ResourceTypeEnum ResourceType {
         get { return ResourceTypeEnum.Local; }
      }

      public void DoCheck(
         HealthBlockManager manager,
         NameValueCollection parameters,
         HealthReport report)
      {
         XArbMemoryPressureReport ExtendedReport;

         ExtendedReport = new XArbMemoryPressureReport(GetThreshold(parameters));

         report.HealthStatus = ExtendedReport.MemoryPressure > ExtendedReport.WarningThreshold ?
            HealthStatusEnum.Yellow :
            HealthStatusEnum.Green;

         report.ExtendedReport = ExtendedReport;
      }

      private float GetThreshold(NameValueCollection parameters) {
         string[] Values = parameters.GetValues("threshold") ?? new string[0];

         if (Values.Length > 1)
            throw new ArgumentException("At most 1 'threshold' parameter can be specified.");
         else if (Values.Length == 1)
            return float.Parse(Values[0]);

         return 1;
      }
   }

   public class XArbMemoryPressureReport : IExtendedHealthReport {
      public XArbMemoryPressureReport()
         : this(1.0f) { }

      public XArbMemoryPressureReport(float warningThreshold) {
         float OffsetFactor;
         float ScalingFactor;

         this.warningThreshold = warningThreshold;
         this.totalMemory = GC.GetTotalMemory(false);
         this.memoryUsageLowWatermark = Config.GetIntSetting(Setting.xarb_MemoryUsageLowWaterMark);  
         this.memoryUsageHighWatermark = Config.GetIntSetting(Setting.xarb_MemoryUsageHighWaterMark);

         OffsetFactor = (float)(this.totalMemory);
         ScalingFactor = (float)this.memoryUsageHighWatermark;

         this.memoryPressure = OffsetFactor / ScalingFactor;
         this.memoryPressure = Math.Max(0, this.memoryPressure);
      }

      public float MemoryPressure {
         get { return memoryPressure; }
         set { memoryPressure = value; }
      }

      public float WarningThreshold {
         get { return warningThreshold; }
         set { warningThreshold = value; }
      }

      public long TotalMemory {
         get { return totalMemory; }
         set { totalMemory = value; }
      }

      public long MemoryUsageLowWatermark {
         get { return memoryUsageLowWatermark; }
         set { memoryUsageLowWatermark = value; }
      }

      public long MemoryUsageHighWatermark {
         get { return memoryUsageHighWatermark; }
         set { memoryUsageHighWatermark = value; }
      }

      private float memoryPressure;
      private float warningThreshold;
      private long totalMemory;
      private long memoryUsageLowWatermark;
      private long memoryUsageHighWatermark;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbInterfaceBucketQueue.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Net;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.arbitration.inh
{
    public class BucketInfo
    {
        public IPAddress   m_ipCurrentHost;
        public string      m_szCurrentServerName;

        public IPAddress   m_ipNextHost;
        public string      m_szNextServerName;
        
        public DateTime    m_NextServerStartTime;

        public BucketInfo(string szCurrentServerName,IPAddress ipCurrent, string szNextServerName, IPAddress ipNext, DateTime startTime)
        {
            m_szCurrentServerName   = szCurrentServerName;
            m_ipCurrentHost         = ipCurrent;
            m_szNextServerName      = szNextServerName;
            m_ipNextHost            = ipNext;
            m_NextServerStartTime   = startTime;      
        }
    }
    
    public class InterfaceChangeInfo
    {
        public uint        m_nBuckeId;
        public BucketInfo  m_OldBucket;
        public BucketInfo  m_NewBucket;

        public InterfaceChangeInfo(uint nBucketId, BucketInfo oldBucket, BucketInfo newBucket)
        {
            m_nBuckeId  = nBucketId;
            m_OldBucket = oldBucket;
            m_NewBucket = newBucket;
        }
    }
    
    public class InterfaceBucketChangeIntercept
    {        
        static InterfaceBucketChangeIntercept()
        {
            m_Queue           = Queue.Synchronized(new Queue());
            m_AnyEventInQueue = new ManualResetEvent(false);
            m_TheOnlyThread   = new XboxLiveThread( new ThreadStart( ThreadLoop ) );
            m_TheOnlyThread.Start();
        }

        private static int InterfaceBucketInterceptThrottleInMillis
        {
            get { return Config.GetIntSetting(Setting.xarb_InterfaceBucketInterceptThrottleInMillis); }
        } 

        public static int QueueCount
        {
            get 
            {
                if (m_Queue != null)
                {
                    return m_Queue.Count;
                }
                else
                {
                    return 0;
                }
            }
        } 
        public static void OnInterfaceBucketChange(object sender, InterfaceBucketChangeEventArgs e)
        {
            try
            {
                if (VetoChange(sender, e))
                {
                    Config.VetoInterfaceBucketChange();
                }
                else
                {
                    /*
                        We can't use e directly, because as soon as we get out of this function, its value might change which is not what we want.
                        I don't want to go with Deep Cloning either, that is too overkill.
                        So we are going to remember only those values we are interested in.
                    */
                    BucketInfo oldBucket = new BucketInfo(e.ValueOld.CurrentServerName, e.ValueOld.CurrentServer.IPAddress,
                                                          e.ValueOld.NextServerName   , e.ValueOld.NextServer.IPAddress   ,
                                                          e.ValueOld.NextServerStart);

                    BucketInfo newBucket = new BucketInfo(e.ValueNew.CurrentServerName, e.ValueNew.CurrentServer.IPAddress,
                                                          e.ValueNew.NextServerName   , e.ValueNew.NextServer.IPAddress   ,
                                                          e.ValueNew.NextServerStart);
                    
                    InterfaceChangeInfo changeInfo = new InterfaceChangeInfo(e.Bucket, oldBucket, newBucket);
                   
                    m_Queue.Enqueue(changeInfo);
                    m_AnyEventInQueue.Set();
                }
            }
            catch (Exception e2)
            {
               Xom.NtEvent( XEvent.Id.ARBITRATION_INTERFACE_BUCKET_UNABLE_TO_QUEUE_EVENT, e2, "Interface Bucket Change Queing Event Exception.");
            }
            
        }


        //This thread should never die
        private static void ThreadLoop()
        {
            while (true)
            {
                try
                {
                    if (m_Queue.Count == 0)
                    {
                        m_AnyEventInQueue.Reset();

                        if (m_Queue.Count == 0)
                        {
                            /*
                                The situation we want to be careful is when Reset happens JUST after the Set
                                 
                                Thread 1                Thread 2
                                ================================
                                m_Queue == 0
                                                        Enqueue
                                                        Set
                                Reset
                                WaitOne

                                This will result in the thread to wait when there is an item in the queue. The second count check should take care of this.
                            */
                            m_AnyEventInQueue.WaitOne();
                        }
                    }

                    InterfaceChangeInfo interfaceChangeEventInfo = (InterfaceChangeInfo) m_Queue.Dequeue();

                    SessionManager.VerifyAndSetIsInMigration(interfaceChangeEventInfo.m_NewBucket, interfaceChangeEventInfo.m_OldBucket, interfaceChangeEventInfo.m_nBuckeId);

                    System.Threading.Thread.Sleep(InterfaceBucketInterceptThrottleInMillis);
                }
                catch (Exception e)
                {
                    Xom.NtEvent( XEvent.Id.ARBITRATION_INTERFACE_BUCKET_THREAD, e, "Interface Bucket Change Intercept Thread Exception.");
                }
            }
        }

        public static bool VetoChange(object sender, InterfaceBucketChangeEventArgs e)
        {
            /*
                if (
                        (e.ValueOld.CurrentServerName == e.ValueOld.NextServerName) &&
                        (e.ValueOld.CurrentServerName != e.ValueNew.CurrentServerName)
                   )
                {
                    //Somebody was trying to change the Current Server Name
                    //This is not allowed (You can only change the next server name during migration) - so we are going to veto it
                    return true;
                }
            */
            
            return false;
            
        }

        protected static Queue m_Queue; //this is a synchronized Queue, so we are safe
        protected static XboxLiveThread m_TheOnlyThread;
        protected static ManualResetEvent m_AnyEventInQueue;
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\test\dvt\arbdevtest.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.protocol;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.sql.sqlclient;


[TestGroup, DVT]
public class ArbDevTest : TestNode
{
    private const uint titleID = 1234;

    [TestGroupSetup]
    public void Setup()
    {
        string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);
        Assert.IsTrue(inhServers.Length > 0, "No xarbInh servers configured!");
        
        if (inhServers.Length < 2)
        {
            ConsoleX.WriteLine(CC.B_RED, "WARNING: Only one xarbInh server found, no migration tests may Fail!");
        }
        
    }
    
    
    
    [TestCase]
    public void Baseline()
    {
        Random rand = new Random();
        ulong sessionID = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
        ulong sessionNonce = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();

        ulong xboxID1 = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
        ulong xboxID2 = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();

        ulong userID1 = 0x0009FFFFFFFFFF80;
        ulong userID2 = 0x0009FFFFFFFFFF81;
        
        byte[] bundle1 = new byte[16];
        byte[] bundle2 = new byte[16];
        rand.NextBytes(bundle1);
        rand.NextBytes(bundle2);
        
        uint hr;
                                                     

        Console.WriteLine("Registering Xbox 1..");
        hr = ArbTestUtil.Register(xboxID1, userID1, 7.0F, 1, sessionID, sessionNonce);
        Assert.AreEqual(hr, HResult.S_OK);

        Console.WriteLine("Registering Xbox 2..");
        hr = ArbTestUtil.Register(xboxID2, userID2, -7.0F, 2, sessionID, sessionNonce);
        Assert.AreEqual(hr, HResult.S_OK);
    
        Console.WriteLine("TimeExtend..");
        hr = ArbTestUtil.TimeExtend(xboxID2, userID1, 7.0F, sessionID, sessionNonce);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Console.WriteLine("ReportResult Xbox 1...");
        ArbitrationReportResultRequest reportReq = new ArbitrationReportResultRequest();
        reportReq.flags=0x0F80;
        reportReq.titleId=ArbTestUtil.TITLE_ID;
        reportReq.sessionId=sessionID;
        reportReq.sessionNonce=sessionNonce;

        ASCIIEncoding ascii = new ASCIIEncoding();

        reportReq.type1SuspiciousInfo = new SuspiciousInfo();
        reportReq.type1SuspiciousInfo.message = ascii.GetBytes("Test1");
        
        reportReq.type2SuspiciousInfo = new SuspiciousInfo();
        reportReq.type2SuspiciousInfo.message = ascii.GetBytes("Test2");
        reportReq.type2SuspiciousInfo.relatedXbox = new ulong[] { xboxID1, xboxID2 };
        
        reportReq.type3SuspiciousInfo = new SuspiciousInfo();
        reportReq.type3SuspiciousInfo.message = ascii.GetBytes("Test3");
        reportReq.type3SuspiciousInfo.relatedXbox = new ulong[] { xboxID2 };
        reportReq.type3SuspiciousInfo.relatedUser = new ulong[] { userID1, userID2 };
        
        
        reportReq.statsBundle = new StatsBundle();
        reportReq.statsBundle.bundle = bundle1;
        
        reportReq.tournamentBundle = new TournamentBundle();
        reportReq.tournamentBundle.bundle = bundle2;
        
        hr = ArbTestUtil.ReportResult(xboxID1, userID1, 7.0F, reportReq);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Console.WriteLine("ReportResult Xbox 2...");
        reportReq.flags = 0x0180;
        
        reportReq.type1SuspiciousInfo = null;
        reportReq.type2SuspiciousInfo = null;
        reportReq.type3SuspiciousInfo = null;
        
        hr = ArbTestUtil.ReportResult(xboxID2, userID2, 7.0F, reportReq);
        Assert.AreEqual(hr, HResult.S_OK);

        Console.WriteLine("DebugResult...");
        ArbitrationDebugResultRequest request = new ArbitrationDebugResultRequest();

        request.version = 1;
        request.flags = 0;
        request.titleID = ArbTestUtil.TITLE_ID;;
        request.sessionID = sessionID;
        request.sessionNonce = sessionNonce;
        
        hr = ArbTestUtil.DebugResult(xboxID1, userID1, 7.0F, request);
        Assert.AreEqual(hr, HResult.S_OK);

        
        Console.WriteLine("");
        
    
    }



    [TestCase]
    public void DiffBundles()
    {
        Random rand = new Random();
        ulong sessionID = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
        ulong sessionNonce = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();

        ulong xboxID1 = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
        ulong xboxID2 = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
        ulong xboxID3 = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();

        ulong userID1 = 0x0009FFFFFFFFFF80;
        ulong userID2 = 0x0009FFFFFFFFFF81;
        ulong userID3 = 0x0009FFFFFFFFFF82;
        
        byte[] bundle1 = new byte[16];
        byte[] bundle2 = new byte[16];
        rand.NextBytes(bundle1);
        rand.NextBytes(bundle2);
        
        uint hr;
                                                     

        Console.WriteLine("Registering Xbox 1..");
        hr = ArbTestUtil.Register(xboxID1, userID1, 7.0F, 1, sessionID, sessionNonce);
        Assert.AreEqual(hr, HResult.S_OK);

        Console.WriteLine("Registering Xbox 2..");
        hr = ArbTestUtil.Register(xboxID2, userID2, 7.0F, 2, sessionID, sessionNonce);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Console.WriteLine("Registering Xbox 3..");
        hr = ArbTestUtil.Register(xboxID3, userID3, 7.0F, 2, sessionID, sessionNonce);
        Assert.AreEqual(hr, HResult.S_OK);
    
        Console.WriteLine("TimeExtend..");
        hr = ArbTestUtil.TimeExtend(xboxID2, userID1, 7.0F, sessionID, sessionNonce);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Console.WriteLine("ReportResult Xbox 1...");
        ArbitrationReportResultRequest reportReq = new ArbitrationReportResultRequest();
        reportReq.flags=0x0F80;
        reportReq.titleId=ArbTestUtil.TITLE_ID;
        reportReq.sessionId=sessionID;
        reportReq.sessionNonce=sessionNonce;

        ASCIIEncoding ascii = new ASCIIEncoding();

        reportReq.type1SuspiciousInfo = new SuspiciousInfo();
        reportReq.type1SuspiciousInfo.message = ascii.GetBytes("Test1");
        
        reportReq.type2SuspiciousInfo = new SuspiciousInfo();
        reportReq.type2SuspiciousInfo.message = ascii.GetBytes("Test2");
        reportReq.type2SuspiciousInfo.relatedXbox = new ulong[] { xboxID1, xboxID2 };
        
        reportReq.type3SuspiciousInfo = new SuspiciousInfo();
        reportReq.type3SuspiciousInfo.message = ascii.GetBytes("Test3");
        reportReq.type3SuspiciousInfo.relatedXbox = new ulong[] { xboxID2 };
        reportReq.type3SuspiciousInfo.relatedUser = new ulong[] { userID1, userID2 };
        
        
        reportReq.statsBundle = new StatsBundle();
        reportReq.statsBundle.bundle = bundle1;
        
        reportReq.tournamentBundle = new TournamentBundle();
        reportReq.tournamentBundle.bundle = bundle2;
        
        hr = ArbTestUtil.ReportResult(xboxID1, userID1, 7.0F, reportReq);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Console.WriteLine("ReportResult Xbox 2...");
        reportReq.flags = 0x0180;
        
        
        reportReq.type1SuspiciousInfo = null;
        reportReq.type2SuspiciousInfo = null;
        reportReq.type3SuspiciousInfo = null;
        
        hr = ArbTestUtil.ReportResult(xboxID2, userID2, 7.0F, reportReq);
        Assert.AreEqual(hr, HResult.S_OK);

        
        Console.WriteLine("ReportResult Xbox 3...");
        reportReq.flags = 0x0180;
        
        reportReq.statsBundle = new StatsBundle();
        reportReq.statsBundle.bundle = bundle2;
        
        reportReq.type1SuspiciousInfo = null;
        reportReq.type2SuspiciousInfo = null;
        reportReq.type3SuspiciousInfo = null;
        
        hr = ArbTestUtil.ReportResult(xboxID3, userID3, 7.0F, reportReq);
        Assert.AreEqual(hr, HResult.XONLINE_S_ARBITRATION_DIFFERENT_RESULTS_DETECTED);


        Console.WriteLine("DebugResult...");
        ArbitrationDebugResultRequest request = new ArbitrationDebugResultRequest();

        request.version = 1;
        request.flags = 0;
        request.titleID = ArbTestUtil.TITLE_ID;;
        request.sessionID = sessionID;
        request.sessionNonce = sessionNonce;
        
        hr = ArbTestUtil.DebugResult(xboxID1, userID1, 7.0F, request);
        Assert.AreEqual(hr, HResult.S_OK);

        
        Console.WriteLine("");
        
    
    }

    protected void ResetDataBaseToPointTo1Server(string [] inhServers)
    {
        if (inhServers.Length >= 2)
        {
            Console.WriteLine("Reconfiguring interface buckets to hit the same server");
            
            using (SqlClient cxn = new SqlClient(Interface.npdb))
            {   
                cxn.Command.CommandText = 
                    "begin tran\r\n" + 
                    "update t_interface_buckets " + 
                    " set vc_server = '" +  inhServers[0] + "'" + ",vc_next_server = '" +  inhServers[0] + "', dt_migration_start = getutcdate()" +
                    " where vc_environment = '" + Config.Environment + "' and vc_interface = 'xarbinh' " +
                    "commit tran\r\n";
                    
                cxn.ExecuteNonQuery();

                cxn.Close();
            }

            Global.XEnv.ExecuteXmgmtCommand(Interface.xarb, "e :xarb configcacherefresh");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xarbInh, "e :xarbinh configcacherefresh");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xarbInh, "e :xarbinh testwaituntilemptyeventqueue");

        }  
    }

    protected void DoMigrationInterfaceBucket(string [] inhServers)
    {
        if (inhServers.Length >= 2)
        {
            Console.WriteLine("DoMigrationInterfaceBucket");
            
            //do migration
            using (SqlClient cxn = new SqlClient(Interface.npdb))
            {
                 cxn.Command.CommandText = 
                    "begin tran\r\n" + 
                    "update t_interface_buckets " + 
                    " set vc_server = '" +  inhServers[0] + "'" + ", vc_next_server = '" +  inhServers[1] + "', dt_migration_start = DATEADD(minute, -30, getutcdate())" +
                    " where vc_environment = '" + Config.Environment + "' and vc_interface = 'xarbinh' " +
                    "commit tran\r\n";

                    
                cxn.ExecuteNonQuery();

                cxn.Close();
            }

            Global.XEnv.ExecuteXmgmtCommand(Interface.xarb, "e :xarb configcacherefresh");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xarbInh, "e :xarbinh configcacherefresh");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xarbInh, "e :xarbinh testwaituntilemptyeventqueue");

        }
    }

    protected void GenerateSessionData(out ulong [] arrSession, out ulong [] arrXboxes, out ulong [] arrUser, int nSession)
    {
        Random rand = new Random();
        arrSession = new ulong[nSession];
        arrXboxes  = new ulong[nSession*2];
        arrUser    = new ulong[nSession*2];

        for (int i=0;i<nSession;i++)
        {
            arrSession[i] = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrXboxes [i*2]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrUser   [i*2]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrXboxes [i*2+1]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrUser   [i*2+1]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
        }
    }


    [TestCase]
    public void InhMigration_Manual_test()
    {
        //PopulateSessions on all 139 buckets
        //Do Migration on all 139
        //Verify it eventually completes
        int nSession = 20000;
        Random rand = new Random();
        
        ulong [] arrSession = null;
        ulong [] arrXboxes  = null;
        ulong [] arrUser    = null;
        uint hr;        

        ulong sessionNonce = 0xaaaabbbbccccdddd;
        GenerateSessionData(out arrSession, out arrXboxes, out arrUser, nSession);
    
        string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);

        //hit the first server before migration
        for (int i=0;i<10000;i++)
        {
            hr = ArbTestUtil.RegisterInh(inhServers[1], arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            //Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.RegisterInh(inhServers[1], arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            //Assert.AreEqual(hr, HResult.S_OK);
        }   
    }

    [TestCase]
    public void InhMigration_AfterConfig_Return_S_FALSE()
    {
        // Do Migration
        // Using INH directly, try creating on Source Server
        // Verify S_FALSE

        int nSession = 2;
        Random rand = new Random();
        
        ulong [] arrSession = null;
        ulong [] arrXboxes  = null;
        ulong [] arrUser    = null;
        uint hr;        

        ulong sessionNonce = 0xaaaabbbbccccdddd;
        GenerateSessionData(out arrSession, out arrXboxes, out arrUser, nSession);

        string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);

        ResetDataBaseToPointTo1Server(inhServers);      

        //hit the first server before migration
        for (int i=0;i<1;i++)
        {
            hr = ArbTestUtil.RegisterInh(inhServers[0], arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.RegisterInh(inhServers[0], arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);
        }

        Console.WriteLine("Confirmed Can Hit Original Server Before Migration  - Return S_OK");

        DoMigrationInterfaceBucket(inhServers);

        //Try Hit the first server after migration
        for (int i=1;i<2;i++)
        {
            hr = ArbTestUtil.RegisterInh(inhServers[0], arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_FALSE);

            hr = ArbTestUtil.RegisterInh(inhServers[0], arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_FALSE);
        }

        Console.WriteLine("Confirmed CANNOT Hit Original Server AFTER Migration  - Return S_FALSE");

        for (int i=1;i<2;i++)
        {
            hr = ArbTestUtil.RegisterInh(inhServers[1], arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.RegisterInh(inhServers[1], arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);
        }

        Console.WriteLine("Register Another Session in NEXT Server");

        for (int i=0;i<nSession;i++)
        {   
            Console.WriteLine("Reporting Result using ARB FRONT DOOR");
            ArbitrationReportResultRequest reportReq = new ArbitrationReportResultRequest();
            reportReq.flags = 0x0180;
            reportReq.titleId=ArbTestUtil.TITLE_ID;
            reportReq.sessionId=arrSession[i];
            reportReq.sessionNonce=sessionNonce;

            byte[] bundle1 = new byte[16];
            byte[] bundle2 = new byte[16];
            rand.NextBytes(bundle1);
            rand.NextBytes(bundle2);

            reportReq.statsBundle = new StatsBundle();
            reportReq.statsBundle.bundle = bundle1;
            
            reportReq.tournamentBundle = new TournamentBundle();
            reportReq.tournamentBundle.bundle = bundle2;

            hr = ArbTestUtil.ReportResult(arrXboxes[i*2], arrUser[i*2], 7.0F, reportReq);
            Assert.AreEqual(hr, HResult.S_OK);
            
            hr = ArbTestUtil.ReportResult(arrXboxes[i*2 + 1], arrUser[i*2 + 1], 7.0F, reportReq);
            Assert.AreEqual(hr, HResult.S_OK);
        }
    }

    [TestCase]
    public void FDMigration_AfterConfig_NextServer_Accept_Session()
    {
        // Do Migration
        // Create Sessions by using FD
        // Verify it is on next Server

        int nSession = 2;
        Random rand = new Random();
        
        ulong [] arrSession = null;
        ulong [] arrXboxes  = null;
        ulong [] arrUser    = null;
        uint hr;        

        ulong sessionNonce = 0xaaaabbbbccccdddd;
        GenerateSessionData(out arrSession, out arrXboxes, out arrUser, nSession);

        string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);

        DoMigrationInterfaceBucket(inhServers);   


        for (int i=0;i<nSession;i++)
        {
            Console.WriteLine("Registering new session using FD");
            hr = ArbTestUtil.Register(arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.Register(arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);
        }

        for (int i=0;i<nSession;i++)
        {   
            Console.WriteLine("Reporting Result using ARB INH");
            ArbitrationReportResultRequest reportReq = new ArbitrationReportResultRequest();
            reportReq.flags = 0x0180;
            reportReq.titleId=ArbTestUtil.TITLE_ID;
            reportReq.sessionId=arrSession[i];
            reportReq.sessionNonce=sessionNonce;

            byte[] bundle1 = new byte[16];
            byte[] bundle2 = new byte[16];
            rand.NextBytes(bundle1);
            rand.NextBytes(bundle2);

            reportReq.statsBundle = new StatsBundle();
            reportReq.statsBundle.bundle = bundle1;
            
            reportReq.tournamentBundle = new TournamentBundle();
            reportReq.tournamentBundle.bundle = bundle2;

            //now let's verify that it is in our new server
            hr = ArbTestUtil.ReportResultInh(inhServers[1], arrXboxes[i*2], arrUser[i*2], 7.0F, reportReq);
            Assert.AreEqual(hr, HResult.S_OK);
            
            hr = ArbTestUtil.ReportResultInh(inhServers[1], arrXboxes[i*2 + 1], arrUser[i*2 + 1], 7.0F, reportReq);
            Assert.AreEqual(hr, HResult.S_OK);

        }
    }

    [TestCase]
    public void FDMigration_Black_Box_Testing_using_ARB_FD()
    {
        /*
            1. Create a some Session
            2. Do Migration
            3. Keep on Creating Session
            4. Call Report Results on all Session
            5. Expect no errors
            6. Verify Migration Completes
        */   

        int nSession = 500;
        Random rand = new Random();
        
        ulong [] arrSession = null;
        ulong [] arrXboxes  = null;
        ulong [] arrUser    = null;
        uint hr;        

        ulong sessionNonce = 0xaaaabbbbccccdddd;
        GenerateSessionData(out arrSession, out arrXboxes, out arrUser, nSession);
    
        string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);
        ResetDataBaseToPointTo1Server(inhServers); 
        
        for (int i=0;i<250;i++)
        {
            Console.WriteLine("Registering new session using FD");
            hr = ArbTestUtil.Register(arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.Register(arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);
        }

        DoMigrationInterfaceBucket(inhServers);   

        for (int i=250;i<nSession;i++)
        {
            Console.WriteLine("After Migration, Registering new session using FD");
            hr = ArbTestUtil.Register(arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.Register(arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);
        }

        for (int i=0;i<nSession;i++)
        {   
            Console.WriteLine("Reporting Result using ARB FRONT DOOR");
            ArbitrationReportResultRequest reportReq = new ArbitrationReportResultRequest();
            reportReq.flags = 0x0180;
            reportReq.titleId=ArbTestUtil.TITLE_ID;
            reportReq.sessionId=arrSession[i];
            reportReq.sessionNonce=sessionNonce;

            byte[] bundle1 = new byte[16];
            byte[] bundle2 = new byte[16];
            rand.NextBytes(bundle1);
            rand.NextBytes(bundle2);

            reportReq.statsBundle = new StatsBundle();
            reportReq.statsBundle.bundle = bundle1;
            
            reportReq.tournamentBundle = new TournamentBundle();
            reportReq.tournamentBundle.bundle = bundle2;

            hr = ArbTestUtil.ReportResult(arrXboxes[i*2], arrUser[i*2], 7.0F, reportReq);
            Assert.AreEqual(hr, HResult.S_OK);
            
            hr = ArbTestUtil.ReportResult(arrXboxes[i*2 + 1], arrUser[i*2 + 1], 7.0F, reportReq);
            Assert.AreEqual(hr, HResult.S_OK);
        }


        //wait until migration is complete
        bool bMigrationFinishDetected = false;

        while (!bMigrationFinishDetected)
        {

            using (SqlClient cxn = new SqlClient(Interface.npdb))
            {              
                string szCommand = String.Format("SELECT     COUNT(*) AS Expr1 " +
                                                 "FROM         t_interface_buckets "+
                                                 "WHERE     (vc_interface LIKE 'xarbinh') AND (vc_environment = '{0}') AND (vc_server <> vc_next_server) ", Config.Environment);

                cxn.Command.CommandText = szCommand;
                
                object o = cxn.ExecuteScalar();
                if ((int)o == 0)
                {
                    bMigrationFinishDetected = true;
                }
                else
                {
                    System.Threading.Thread.Sleep(5 * 1000);
                }

                cxn.Close();
            }

            Console.WriteLine("===== Waiting For Session TimeOut / Migration To Completes");
        }
    }    


    [TestCase]
    public void InhMigration_Migration_Detected_Migration_End()
    {
        /*
            1. Create 1000 session on Server A
            2. Do Migration Immediately
            3. Wait for 1 minute to ensure settings is picked up
            4. Call report result for all of them
            5. Ensure Migration completes
        */

        Random rand = new Random();
        int nSession = 10;
        ulong [] arrSession = new ulong[nSession];
        ulong [] arrXboxes  = new ulong[nSession*2];
        ulong [] arrUser    = new ulong[nSession*2];
        uint hr;
        

        ulong sessionNonce = 0xaaaabbbbccccdddd;

        for (int i=0;i<nSession;i++)
        {
            arrSession[i] = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrXboxes [i*2]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrUser   [i*2]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrXboxes [i*2+1]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
            arrUser   [i*2+1]  = (((ulong)rand.Next()) << 32) + (ulong)rand.Next();
        }

        string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);

        ResetDataBaseToPointTo1Server(inhServers);      

        //hit the first server before migration
        for (int i=0;i<nSession;i++)
        {
            hr = ArbTestUtil.RegisterInh(inhServers[0], arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.RegisterInh(inhServers[0], arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);
        }

        DoMigrationInterfaceBucket(inhServers);

        
        //Report result so migration can complete
        for (int i=0;i<nSession;i++)
        {         
             Console.WriteLine("Reporting Result using ARB FRONT DOOR");
            ArbitrationReportResultRequest reportReq = new ArbitrationReportResultRequest();
            reportReq.flags = 0x0180;
            reportReq.titleId=ArbTestUtil.TITLE_ID;
            reportReq.sessionId=arrSession[i];
            reportReq.sessionNonce=sessionNonce;

            byte[] bundle1 = new byte[16];
            byte[] bundle2 = new byte[16];
            rand.NextBytes(bundle1);
            rand.NextBytes(bundle2);

            reportReq.statsBundle = new StatsBundle();
            reportReq.statsBundle.bundle = bundle1;
            
            reportReq.tournamentBundle = new TournamentBundle();
            reportReq.tournamentBundle.bundle = bundle2;

            hr = ArbTestUtil.ReportResult(arrXboxes[i*2], arrUser[i*2], 7.0F, reportReq);

            hr = ArbTestUtil.ReportResult(arrXboxes[i*2 + 1], arrUser[i*2 + 1], 7.0F, reportReq);
        }

        //wait until migration is complete
        bool bMigrationFinishDetected = false;

        while (!bMigrationFinishDetected)
        {

            using (SqlClient cxn = new SqlClient(Interface.npdb))
            {              
                string szCommand = String.Format("SELECT     COUNT(*) AS Expr1 " +
                                                 "FROM         t_interface_buckets "+
                                                 "WHERE     (vc_interface LIKE 'xarbinh') AND (vc_environment = '{0}') AND (vc_server <> vc_next_server) ", Config.Environment);

                cxn.Command.CommandText = szCommand;
                
                object o = cxn.ExecuteScalar();
                if ((int)o == 0)
                {
                    bMigrationFinishDetected = true;
                }
                else
                {
                    System.Threading.Thread.Sleep(5 * 1000);
                }

                cxn.Close();
            }

            Console.WriteLine("===== Waiting For Migration To Completes");
        }

        return ;
        
    }

    
    [TestCase]
    public void InhMigration_SessionTimeOut_Completes_Migration()
    {
        /*  
            Create some session
            Do migration
            Waiting until migration completes event
        */

        int nSession = 1000;
        Random rand = new Random();
        
        ulong [] arrSession = null;
        ulong [] arrXboxes  = null;
        ulong [] arrUser    = null;
        uint hr;        

        ulong sessionNonce = 0xaaaabbbbccccdddd;
        GenerateSessionData(out arrSession, out arrXboxes, out arrUser, nSession);
        string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);
        ResetDataBaseToPointTo1Server(inhServers);
        for (int i=0;i<nSession;i++)
        {
            Console.WriteLine("Registering new session using FD");
            hr = ArbTestUtil.Register(arrXboxes[i*2], arrUser[i], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);

            hr = ArbTestUtil.Register(arrXboxes[(i*2)+1], arrUser[(i*2)+1], 7.0F, 1, arrSession[i], sessionNonce);
            Assert.AreEqual(hr, HResult.S_OK);
        }

        DoMigrationInterfaceBucket(inhServers);   

        //wait until migration is complete
        bool bMigrationFinishDetected = false;

        while (!bMigrationFinishDetected)
        {

            using (SqlClient cxn = new SqlClient(Interface.npdb))
            {              
                string szCommand = String.Format("SELECT     COUNT(*) AS Expr1 " +
                                                 "FROM         t_interface_buckets "+
                                                 "WHERE     (vc_interface LIKE 'xarbinh') AND (vc_environment = '{0}') AND (vc_server <> vc_next_server) ", Config.Environment);

                cxn.Command.CommandText = szCommand;
                
                object o = cxn.ExecuteScalar();
                if ((int)o == 0)
                {
                    bMigrationFinishDetected = true;
                }
                else
                {
                    System.Threading.Thread.Sleep(5 * 1000);
                }

                cxn.Close();
            }

            Console.WriteLine("===== Waiting For Migration To Complete");
        }
    }


                
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbMgmt.cs ===
using System;
using System.Text;
using System.Security.Cryptography;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;        

namespace xonline.server.arbitration.inh
{
    public class XArbMgmt
    {
        static XArbMgmt()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XArbMgmt.OnControlRequest);
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch(args.Command.ToLower())
            {
                case "help":
                    XomControlConnection.SendMessage(
                        "Arbitration Server help\r\n" +
                        "  ReloadTitleParameters -- To reload all title related constants from UODB.\r\n" +
                        "  PerformTrustSummation -- To sum all user ratings and store back into UODB.\r\n" +
                        "  FlushBundles -- Flushes the queued bundles to front doors.\r\n" +
                        "  FlushTrustUpdates -- Flushes the user trust updates to UODB.\r\n" +
                        "  ListBuckets -- Dumps a list of buckets and their related info\r\n" +
                        "  listonebucket bucketID -- Dumps the specified bucket and its related info\r\n" +
                        "  testwaituntilemptyeventqueue -- use only for testing\r\n" +
                        "  resetmigrationstateforonebucket bucketID -- (Warning)Reset Internal Migration State To NotPlanned\r\n\r\n"
                        , args.RequestId);
                    args.Handled = true;
                    break;
                case "reloadtitleparameters":
                    XomControlConnection.SendMessage(ProcessReloadTitleParameters(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "performtrustsummation":
                    XomControlConnection.SendMessage(ProcessPerformTrustSummation(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "flushbundles":
                    XomControlConnection.SendMessage(ProcessFlushBundles(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "flushtrustupdates":
                    XomControlConnection.SendMessage(ProcessFlushTrustUpdates(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "listbuckets":    
                    XomControlConnection.SendMessage(ProcessListBuckets(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "listonebucket":    
                    XomControlConnection.SendMessage(ProcessListBucket(args), args.RequestId);
                    args.Handled = true;
                    break;
                case "resetmigrationstateforonebucket":    
                    XomControlConnection.SendMessage(ProcessResetMigrationForBucket(args), args.RequestId);
                    args.Handled = true;
                    break;
                    
                case "testwaituntilemptyeventqueue":
                    XomControlConnection.SendMessage(ProcessTestWaitUntilEmptyEventQueue(args), args.RequestId);
                    args.Handled = true;
                    break;
            
            }
            
            
        }
        
        // the only purpose of this function is to ensure instantiation of the class 
        public static void Init() 
        {
        }

        public static string ProcessReloadTitleParameters(ControlRequestEventArgs args)
        {
            TitleParameterManager.ReloadTitleParameters(null);
            return "Title parameters have been reloaded!\r\n" ;
        }

        public static string ProcessPerformTrustSummation(ControlRequestEventArgs args)
        {
            TrustSummationManager.TrustSummation(true);
            return "Trust Summation has been performed!\r\n" ;
        }

        public static string ProcessFlushBundles(ControlRequestEventArgs args)
        {
            BundleSubmitter.FlushBundles();
            return "Queued bundles have been flushed to front doors!\r\n" ;
        }

        public static string ProcessFlushTrustUpdates(ControlRequestEventArgs args)
        {
            TrustRatingUpdater.FlushTrustRatings();
            return "All queued trust updates have been flushed to UODB!\r\n" ;
        }

        public static string ProcessListBuckets(ControlRequestEventArgs args)
        {
            try
            {
                StringBuilder bldr = new StringBuilder();
                bldr.Append("Bucket\tSessions\tMigration\tCurrent\r\n");
                bldr.Append("------\t--------\t---------\t-------\r\n");
                
                for (int i = 0; i < SessionManager.SessionBucketCount.Length; i++)
                {
                    IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, (uint)i);
                    if (SessionManager.IsIpMine(bucket.CurrentServer.IPAddress) || SessionManager.IsIpMine(bucket.NextServer.IPAddress))
                    {
                        bldr.Append(GetBucketInfoForBucketID((uint)i));
                    }
                }
                
                return bldr.ToString();
            }
            catch (Exception e)
            {
                return FormatErrorMsg(e);
            }
        }   

        private static string GetBucketInfoForBucketID(uint nBucketID)
        {
            IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, nBucketID);

            if (bucket != null)
            {
                return String.Format("{0}\t{1}\t\t{2}\t\t{3}\r\n", nBucketID , SessionManager.SessionBucketCount[nBucketID], SessionManager.m_arrSessionBucketMigrationFlag[nBucketID].ToString(), SessionManager.IsIpMine(bucket.CurrentServer.IPAddress));
            }
            else
            {
                throw new Exception("Bucket Not Found For Bucket ID " + nBucketID);
            }
        }

        public static string ProcessListBucket(ControlRequestEventArgs args)
        {
            try 
            {
                StringBuilder bldr = new StringBuilder();
                bldr.Append("Bucket\tSessions\tMigration\tCurrent\r\n");
                bldr.Append("------\t--------\t---------\t-------\r\n");
                
                if (args.CommandArgs.Length != 1)
                {
                    throw new Exception("Please input the bucket ID");    
                }
                
                uint nBucket = uint.Parse(args.CommandArgs[0]);
                if (nBucket >= Config.GetBucketCount(Interface.xarbInh))
                {
                    throw new Exception("nBucket >= Config.GetBucketCount(Interface.xarbInh)");
                }

                bldr.Append(GetBucketInfoForBucketID(nBucket));

                return bldr.ToString();
            }
            catch (Exception e)
            {
                return FormatErrorMsg(e);
            }
        }   

        public static string ProcessResetMigrationForBucket(ControlRequestEventArgs args)
        {
            try 
            {
                if (args.CommandArgs.Length != 1)
                {
                    throw new Exception("Please input the bucket ID");    
                }
                
                uint nBucket = uint.Parse(args.CommandArgs[0]);
                if (nBucket >= Config.GetBucketCount(Interface.xarbInh))
                {
                    throw new Exception("nBucket >= Config.GetBucketCount(Interface.xarbInh)");
                }
                
                lock (typeof(SessionManager))
                {
                    SessionManager.m_arrSessionBucketMigrationFlag[nBucket] = SessionManager.MigrationState.NotPlanned;
                }

                return ProcessListBucket(args);
            }
            catch (Exception e)
            {
                return FormatErrorMsg(e);
            }
        }

        //After test calls refreshconfigcache, it wants to know that events reach sessionmanager
        public static string ProcessTestWaitUntilEmptyEventQueue(ControlRequestEventArgs args)
        {
            try 
            {
                while (InterfaceBucketChangeIntercept.QueueCount != 0)
                {
                    System.Threading.Thread.Sleep(100);
                }
            }
            catch (Exception e)
            {
                return FormatErrorMsg(e);
            }

            return "Done";
        }  

        private static string FormatErrorMsg(Exception e)
        {
            return "Error :\r\n" + e.Message;
        }
        
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\test\dvt\ArbSessionTest.cs ===
using System;
using System.IO;
using System.Net;
using System.Diagnostics;
using System.Threading;

using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.arbitration.inh;

namespace xonline.server.arbitration.test.unit
{

[TestGroup, DVT]
public class ArbSessionTest : TestNode
{
    [TestCase]
    public void TestNormal()
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        Xbox xbox1 = new Xbox(user1);
        Xbox xbox2 = new Xbox(user2);
        Bundle sbundle = new Bundle();
        Bundle tbundle = new Bundle();
        Session session = new Session(xbox1,xbox2,true,sbundle,tbundle,2.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,1000);
        session.Register(xbox2,1000);
        session.TimeExtend(xbox1,50);
        session.TimeExtend(xbox2,40);
        session.ReportResult(xbox1, false, sbundle, tbundle);
        session.ReportResult(xbox2, false, sbundle, tbundle);

        Console.WriteLine("[{0}] Test Normal took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }

    //[TestCase]
    // can't do this, as the necessary timing setting can't be overriden (yet)
    public void TestMinorityQuorum()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        User user3 = new User(2.0F);
        User user4 = new User(-3.0F);
        Xbox xbox1 = new Xbox(user1);
        Xbox xbox2 = new Xbox(user2);
        Xbox xbox3 = new Xbox(user3);
        Xbox xbox4 = new Xbox(user4);
        Bundle bundle = new Bundle();
        Session session = new Session(xbox1,xbox2,xbox3,xbox4,true,bundle,null,0.0F,4.0F,0.0F,0.0F,0.0F,2.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,1);
        session.Register(xbox2,1);
        session.Register(xbox3,1);
        session.Register(xbox4,1);
        session.ReportResult(xbox3, false, bundle, null);
        session.ReportResult(xbox4, false, bundle, null);
    
        Console.WriteLine("[{0}] Test Minority quorum took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }

    //[TestCase]
    // can't do this, as the necessary timing setting can't be overriden (yet)
    public void TestProblematicMinorityQuorum()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        User user3 = new User(2.0F);
        User user4 = new User(-3.0F);
        Xbox xbox1 = new Xbox(user1);
        Xbox xbox2 = new Xbox(user2);
        Xbox xbox3 = new Xbox(user3);
        Xbox xbox4 = new Xbox(user4);
        Bundle bundle = new Bundle();
        Session session = new Session(xbox1,xbox2,xbox3,xbox4,false,null,null,0.0F,0.0F,0.0F,0.0F,4.0F,1.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,1);
        session.Register(xbox2,1);
        session.Register(xbox3,1);
        session.Register(xbox4,1);
        session.ReportResult(xbox2, false, bundle, null);
        session.ReportResult(xbox3, true, null, null);
        session.ReportResult(xbox4, false, bundle, null);
    
        Console.WriteLine("[{0}] Test Problematic Minority quorum took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }

    //[TestCase]
    // can't do this, as the necessary timing setting can't be overriden (yet)
    public void TestFailedReport()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        User user3 = new User(2.0F);
        User user4 = new User(-3.0F);
        Xbox xbox1 = new Xbox(user1);
        Xbox xbox2 = new Xbox(user2);
        Xbox xbox3 = new Xbox(user3);
        Xbox xbox4 = new Xbox(user4);
        Bundle bundle = new Bundle();
        Session session = new Session(xbox1,xbox2,xbox3,xbox4,false,null,bundle,0.0F,0.0F,4.0F,0.0F,0.0F,3.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,1);
        session.Register(xbox2,1);
        session.Register(xbox3,1);
        session.Register(xbox4,1);
        session.ReportResult(xbox2, false, null, bundle);
    
        Console.WriteLine("[{0}] Test Failed took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }
        
    [TestCase]
    public void TestOneXboxTwoUsers()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        Xbox xbox1 = new Xbox(user1,user2);
        Bundle sbundle = new Bundle();
        Bundle tbundle = new Bundle();
        Session session = new Session(xbox1,true,sbundle,tbundle,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,1000);
        session.ReportResult(xbox1, false, sbundle, tbundle);

        Console.WriteLine("[{0}] Test One Xbox Two User took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }
        
    [TestCase]
    public void TestNoBundles()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        User user3 = new User(2.0F);
        User user4 = new User(-3.0F);
        Xbox xbox1 = new Xbox(user1);
        Xbox xbox2 = new Xbox(user2);
        Xbox xbox3 = new Xbox(user3);
        Xbox xbox4 = new Xbox(user4);
        Session session = new Session(xbox1,xbox2,xbox3,xbox4,false,null,null,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,1);
        session.Register(xbox2,1);
        session.Register(xbox3,1);
        session.Register(xbox4,1);
        session.ReportResult(xbox1, false, null, null);
        session.ReportResult(xbox2, false, null, null);
        session.ReportResult(xbox3, false, null, null);
    
        Console.WriteLine("[{0}] Test No Bundles Submitted took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }
        
    [TestCase]
    public void TestUdpUsed()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        User user3 = new User(2.0F);
        User user4 = new User(-3.0F);
        Xbox xbox1 = new Xbox(user1,user2);
        Xbox xbox2 = new Xbox(user3,user4);
        Bundle bundle = new Bundle();
        Session session = new Session(xbox1,xbox2,true,null,bundle,0.0F,0.0F,0.0F,0.0F,4.0F,0.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,100);
        session.Register(xbox2,100);
        session.ReportResult(xbox1, false, null, bundle);
        session.ReportResult(xbox2, true, null, bundle);
    
        Console.WriteLine("[{0}] Test UDP used took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }
    
    [TestCase]
    public void TestTwoBundles()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        User user1 = new User(7.0F);
        User user2 = new User(-7.0F);
        User user3 = new User(2.0F);
        User user4 = new User(-3.0F);
        Xbox xbox1 = new Xbox(user1);
        Xbox xbox2 = new Xbox(user2);
        Xbox xbox3 = new Xbox(user3);
        Xbox xbox4 = new Xbox(user4);
        Bundle bundle1 = new Bundle();
        Bundle bundle2 = new Bundle();
        Session session = new Session(xbox1,xbox2,xbox3,xbox4,true,bundle1,null,0.0F,0.0F,0.0F,4.0F,0.0F,0.0F,0.0F,0.0F,0.0F);
        session.Register(xbox1,100);
        session.Register(xbox2,100);
        session.TimeExtend(xbox1,50);
        session.TimeExtend(xbox2,40);
        session.Register(xbox3,100);
        session.Register(xbox4,100);
        session.ReportResult(xbox1, false, bundle1, null);
        session.ReportResult(xbox2, false, bundle2, null);
        session.ReportResult(xbox3, false, bundle1, null);
        session.ReportResult(xbox4, false, bundle2, null);
    
        Console.WriteLine("[{0}] Test Two bundles took {1}ms", session.Result(), timeElapsed.MillisecondsElapsed);
    }

    [TestCase]
    public void TestLoop()    
    {
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

        int ct = 1000;
        int i;
        User[] users = new User[ct*4];
        Xbox[] xboxs = new Xbox[ct*4];
        Session[] sessions = new Session[ct];
        Bundle[] bundles = new Bundle[ct];
        
        for (i=0; i<users.Length; ++i)
        {
            users[i] = new User((float)(2.0 * i));
            xboxs[i] = new Xbox(users[i]);
        }
        for (i=0; i<ct; ++i)
        {
            bundles[i] = new Bundle();
            sessions[i] = new Session(xboxs[4*i],xboxs[4*i+1],xboxs[4*i+2],xboxs[4*i+3],true,bundles[i],null,4.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F,0.0F);
        }
        for (i=0; i<xboxs.Length; ++i)
        {
            sessions[i/4].Register(xboxs[i],100);
        }
        for (i=0; i<xboxs.Length; ++i)
        {
            sessions[i/4].ReportResult(xboxs[i], false, bundles[i/4], null);
        }
    
        Console.WriteLine("[{0}] Test Loop took {1}ms", sessions[0].Result(), timeElapsed.MillisecondsElapsed);
    }

    static xonline.server.arbitration.inh.HTTPAuthData _authData = null;
    static Random _rand = new Random();
    static Session _session = null;
    
    private const float tournamentAmplification = 3.0F;

    private const ushort SESSION_IS_TOURNAMEMT = 0x0001;
    private const ushort SESSION_CAN_EXTEND_TIME = 0x0002;
    private const ushort SESSION_USES_SESSION_HOST = 0x0004;
    private const ushort SESSION_FOR_TEAMS = 0x0008;
    private const ushort SESSION_IS_FFA = 0x0010;
    private const ushort SESSION_IS_PUBLISHER_TOURNAMENT = 0x0020;

    private const ushort SESSION_I_VOLUNTARILY_QUIT = 0x8000;
    private const ushort SESSION_I_WAS_HOST = 0x4000;
    private const ushort SESSION_LOST_CONNECTIVITY = 0x2000;
    private const ushort SESSION_LOST_CONNECTIVITY_SUBMITTED = 0x1000;
    private const ushort SESSION_TYPE_1_SUSPICIOUS_INFO_SUBMITTED = 0x0800;
    private const ushort SESSION_TYPE_2_SUSPICIOUS_INFO_SUBMITTED = 0x0400;
    private const ushort SESSION_TYPE_3_SUSPICIOUS_INFO_SUBMITTED = 0x0200;
    private const ushort SESSION_STATS_BUNDLE_SUBMITTED = 0x0100;
    private const ushort SESSION_TOURNAMENT_BUNDLE_SUBMITTED = 0x0080;

    public class User
    {
        public User(float t)
        {
            userID = (((ulong)_rand.Next()) << 32) + (ulong)_rand.Next();
            trust = t;
        }

        public ulong userID;
        public float trust;
    }
    
    public class Xbox
    {
        public Xbox(User u)
        {
            xboxID = (((ulong)_rand.Next()) << 32) + (ulong)_rand.Next();
            users = new User[1];
            users[0] = u;
        }

        public Xbox(User u1, User u2)
        {
            xboxID = (((ulong)_rand.Next()) << 32) + (ulong)_rand.Next();
            users = new User[2];
            users[0] = u1;
            users[1] = u2;
        }

        public Xbox(User u1, User u2, User u3, User u4)
        {
            xboxID = (((ulong)_rand.Next()) << 32) + (ulong)_rand.Next();
            users = new User[4];
            users[0] = u1;
            users[1] = u2;
            users[2] = u3;
            users[3] = u4;
        }

        public xonline.server.arbitration.inh.XUIDAndTrust[] XUIDs()
        {
            int i;
            xonline.server.arbitration.inh.XUIDAndTrust[] xuids = new xonline.server.arbitration.inh.XUIDAndTrust[users.Length];

            for (i=0; i<users.Length; ++i)
            {
                xuids[i] = new xonline.server.arbitration.inh.XUIDAndTrust(users[i].userID, 0xFFFF6700, users[i].trust);
            }

            return xuids;
        }
        
        public User[] users;
        public ulong xboxID;
    }
    
    public class Bundle
    {
        public const int BUNDLE_SIZE = 2048;
        
        public Bundle()
        {
            bundle = new byte[BUNDLE_SIZE];
            _rand.NextBytes(bundle);
        }

        public byte[] bundle;
    }
    
    public class Session
    {
        private void SetupSession(bool paramExpectBundle, Bundle stats, Bundle tournament, float C1, float C2, float C3, float C4, float C5, float C6, float C7, float C8, float C9)
        {
            titleID = (uint)_rand.Next();
            sessionID = new byte[8];
            sessionNonce = new byte[8];
            _rand.NextBytes(sessionID);
            _rand.NextBytes(sessionNonce);
            expectBundle = paramExpectBundle;
            bundleSubmitted = false;
            statsBundle = stats;
            tournamentBundle = tournament;
            targetC1 = (tournament != null) ? tournamentAmplification * C1 : C1;
            targetC2 = (tournament != null) ? tournamentAmplification * C2 : C2;
            targetC3 = (tournament != null) ? tournamentAmplification * C3 : C3;
            targetC4 = (tournament != null) ? tournamentAmplification * C4 : C4;
            targetC5 = (tournament != null) ? tournamentAmplification * C5 : C5;
            targetC6 = (tournament != null) ? tournamentAmplification * C6 : C6;
            targetC7 = (tournament != null) ? tournamentAmplification * C7 : C7;
            targetC8 = (tournament != null) ? tournamentAmplification * C8 : C8;
            targetC9 = (tournament != null) ? tournamentAmplification * C9 : C9;
            registerFlags = SESSION_CAN_EXTEND_TIME;
            if (tournament != null)
            {
                registerFlags |= SESSION_IS_TOURNAMEMT;
            }
            _session = this;
        }
        
        public Session(Xbox x, bool paramExpectBundle, Bundle stats, Bundle tournament, float C1, float C2, float C3, float C4, float C5, float C6, float C7, float C8, float C9)
        {
            SetupSession(paramExpectBundle, stats, tournament, C1, C2, C3, C4, C5, C6, C7, C8, C9);
            xboxes = new Xbox[1];
            xboxes[0] = x;
        }

        public Session(Xbox x1, Xbox x2, bool paramExpectBundle, Bundle stats, Bundle tournament, float C1, float C2, float C3, float C4, float C5, float C6, float C7, float C8, float C9)
        {
            SetupSession(paramExpectBundle, stats, tournament, C1, C2, C3, C4, C5, C6, C7, C8, C9);
            xboxes = new Xbox[2];
            xboxes[0] = x1;
            xboxes[1] = x2;
        }

        public Session(Xbox x1, Xbox x2, Xbox x3, Xbox x4, bool paramExpectBundle, Bundle stats, Bundle tournament, float C1, float C2, float C3, float C4, float C5, float C6, float C7, float C8, float C9)
        {
            SetupSession(paramExpectBundle, stats, tournament, C1, C2, C3, C4, C5, C6, C7, C8, C9);
            xboxes = new Xbox[4];
            xboxes[0] = x1;
            xboxes[1] = x2;
            xboxes[2] = x3;
            xboxes[3] = x4;
        }

        public uint titleID;
        public byte[] sessionID;
        public byte[] sessionNonce;
        public Xbox[] xboxes;
        public Bundle statsBundle;
        public Bundle tournamentBundle;
        public float targetC1;
        public float targetC2;
        public float targetC3;
        public float targetC4;
        public float targetC5;
        public float targetC6;
        public float targetC7;
        public float targetC8;
        public float targetC9;
        public bool expectBundle;
        public bool bundleSubmitted;
        public ushort registerFlags;
        
        public string Result()
        {
            int sleepTime = 3000;
            
            while ( (expectBundle && !bundleSubmitted) ||
                    targetC1 != 0.0F ||
                    targetC2 != 0.0F ||
                    targetC3 != 0.0F ||
                    targetC4 != 0.0F ||
                    targetC5 != 0.0F ||
                    targetC6 != 0.0F ||
                    targetC7 != 0.0F ||
                    targetC8 != 0.0F ||
                    targetC9 != 0.0F )
            {
                if (sleepTime <= 0)
                {
                    Console.WriteLine("Session failed: {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10}",expectBundle,bundleSubmitted,targetC1,targetC2,targetC3,targetC4,targetC5,targetC6,targetC7,targetC8,targetC9);
                    return "Failed";
                }
                sleepTime -= 100;
                Thread.Sleep(100);
            }

            return "Pass";
        }
        
        public void Register(Xbox x, int seconds)
        {
            Session saveSession = _session;
            _session = this;

            try
            {
                MemoryStream writerStream = new MemoryStream(200);
                BinaryWriter writer = new BinaryWriter(writerStream);
                    
                writer.Write(titleID);
                writer.Write(sessionID);
                writer.Write(sessionNonce);
                writer.Write((ushort)seconds);

                MemoryStream readerStream = new MemoryStream(writerStream.ToArray());
                BinaryReader reader = new BinaryReader(readerStream);
                
                ArbitratedSession s = SessionManager.FindOrCreateSession(reader.ReadBytes(20));
                
                _authData = new xonline.server.arbitration.inh.HTTPAuthData((ushort)3, (uint)0x44444444, (ulong)0x5555555555555555, x.xboxID, x.XUIDs(), titleID, (uint)XOService.Arbitration, 0);

                byte[] response = s.Register(registerFlags, reader);
            }
            finally
            {
                _session = saveSession;
            }
        }

        public void TimeExtend(Xbox x, int seconds)
        {
            Session saveSession = _session;
            _session = this;

            try
            {
                MemoryStream writerStream = new MemoryStream(200);
                BinaryWriter writer = new BinaryWriter(writerStream);

                ushort timeExtendFlags = (ushort)0x0000;
                writer.Write(titleID);
                writer.Write(sessionID);
                writer.Write(sessionNonce);
                writer.Write((ushort)seconds);

                MemoryStream readerStream = new MemoryStream(writerStream.ToArray());
                BinaryReader reader = new BinaryReader(readerStream);
                    
                ArbitratedSession s = SessionManager.FindSession(reader.ReadBytes(20));

                _authData = new xonline.server.arbitration.inh.HTTPAuthData((ushort)3, (uint)0x44444444, (ulong)0x5555555555555555, x.xboxID, x.XUIDs(), titleID, (uint)XOService.Arbitration, 0);

                s.TimeExtend(timeExtendFlags, reader);
            }
            finally
            {
                _session = saveSession;
            }
        }


        public void ReportResult(Xbox x, bool inUDP, Bundle stats, Bundle tournament)
        {
            Session saveSession = _session;
            _session = this;

            try
            {
                MemoryStream writerStream = new MemoryStream(200);
                BinaryWriter writer = new BinaryWriter(writerStream);

                ushort reportFlags = (ushort)0x0000;
                if (stats != null)
                {
                    reportFlags |= SESSION_STATS_BUNDLE_SUBMITTED;
                }
                if (tournament != null)
                {
                    reportFlags |= SESSION_TOURNAMENT_BUNDLE_SUBMITTED;
                }
                writer.Write(titleID);
                writer.Write(sessionID);
                writer.Write(sessionNonce);
                if (stats != null)
                {
                    writer.Write((uint)stats.bundle.Length);
                    writer.Write(stats.bundle);
                }
                if (tournament != null)
                {
                    writer.Write((uint)tournament.bundle.Length);
                    writer.Write(tournament.bundle);
                }

                MemoryStream readerStream = new MemoryStream(writerStream.ToArray());
                BinaryReader reader = new BinaryReader(readerStream);
                    
                ArbitratedSession s = SessionManager.FindSession(reader.ReadBytes(20));

                _authData = new xonline.server.arbitration.inh.HTTPAuthData((ushort)3, (uint)0x44444444, (ulong)0x5555555555555555, x.xboxID, x.XUIDs(), titleID, (uint)XOService.Arbitration, 0);

                if (inUDP)
                {
                    reportFlags = ArbitratedSession.SetReportInUDP( reportFlags );
                }
                    
                s.ReportResult(reportFlags, reader);
            }
            finally
            {
                _session = saveSession;
            }
        }
    }
    
    public static string GetHTTPAuthData()
    {
        return _authData.GetBase64EncodedString();
    }

    public static TitleParameters Lookup( uint titleID )
    {
        return new TitleParameters(1.0F, 0.25F, tournamentAmplification, tournamentAmplification, 120, 10F);
    }

    public static void UpdateTrust(uint TitleID, ulong PUID, float C1, float C2, float C3, float C4, float C5, float C6, float C7, float C8, float C9, int batchCount)
    {
        Debug.Assert( _session.titleID == TitleID );
        Debug.Assert( batchCount == 1 );
        _session.targetC1 -= C1;
        _session.targetC2 -= C2;
        _session.targetC3 -= C3;
        _session.targetC4 -= C4;
        _session.targetC5 -= C5;
        _session.targetC6 -= C6;
        _session.targetC7 -= C7;
        _session.targetC8 -= C8;
        _session.targetC9 -= C9;
     }

    public static void Submit( byte[] statsBundle, byte[] tournamentBundle, xonline.server.arbitration.inh.BundledAuthData bundledAuthData, TeamTickets teamTickets )
    {
        _session.bundleSubmitted = true;
        Debug.Assert(_session.expectBundle == true);
        Debug.Assert( ByteArray.EqualOrBothNull(_session.statsBundle.bundle, statsBundle) );
        Debug.Assert( ByteArray.EqualOrBothNull(_session.tournamentBundle.bundle, tournamentBundle) );
    }

}

public class XomPerformanceCounterCategory
{
}

public struct PerformanceCounter
{
    public void Increment()
    {
        RawValue++;
    }

    public void Decrement()
    {
        RawValue--;
    }

    public void IncrementBy(long diff)
    {
        RawValue += diff;
    }

    public long RawValue;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbNet.cs ===
using System;
using System.IO;
using System.Net;
using System.Threading;
using System.Collections;
using System.Web;
using System.Security.Principal;

using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.utilities;
                                        
using xonline.common.config;
                                           
namespace xonline.server.arbitration.inh
{
    public class BundleSubmitter
    {
        private class SubmitInfo : IPrioritizedTask
        {
            public SubmitInfo(uint titleID, uint service, byte[] bundle, string url, BundledAuthData bundledAuthData)
            {
                _service = service;
                _bundle = bundle;
                _url = url;
                _bundledAuthData = bundledAuthData;
                _submissionTryCount = 0;
                _nextSubmissionTime = DateTime.MinValue;
                _submissionTime = DateTime.Now;
                _titleID = titleID;
                object o = _avgSubmitTime[ServiceAndTitle];
                if (o == null)
                {
                    _expectedSubmitTime = 0;
                }
                else
                {
                    _expectedSubmitTime = (long)o;
                }
            }

            public TimeSpan Delay
            {
                get
                {
                    if (_nextSubmissionTime == DateTime.MinValue)
                    {
                        return TimeSpan.Zero;
                    }
                    else
                    {
                        return _nextSubmissionTime - DateTime.Now;
                    }
                }
            }

            // 
            public int CompareTo(object obj)
            {
                SubmitInfo s = (SubmitInfo)obj;
                
                if (_nextSubmissionTime == DateTime.MinValue)
                {
                    if (s._nextSubmissionTime != DateTime.MinValue)
                    {
                        // Immediate task is higher priority than scheduled task
                        return 1;
                    }
                    // both tasks are immediate tasks, compare _expectedSubmitTime
                    // smaller _expectedSubmitTime is higher priority
                    else if (_expectedSubmitTime < s._expectedSubmitTime)
                    {
                        return 1;
                    }
                    else if (_expectedSubmitTime > s._expectedSubmitTime)
                    {
                        return -1;
                    }
                }
                else
                {
                    if (s._nextSubmissionTime == DateTime.MinValue)
                    {
                        // Immediate task is higher priority than scheduled task
                        return -1;
                    }
                    // both tasks are scheduled tasks, compare _nextSubmissionTime
                    // smaller _nextSubmissionTime is higher priority
                    else if (_nextSubmissionTime < s._nextSubmissionTime)
                    {
                        return 1;
                    }
                    else if (_nextSubmissionTime > s._nextSubmissionTime)
                    {
                        return -1;
                    }
                }
                return 0;
            }

            public ulong ServiceAndTitle
            {
                get { return (((ulong)_service) << 32) + _titleID; }
            }
            
            public uint _submissionTryCount;
            public DateTime _nextSubmissionTime;
            public readonly long _expectedSubmitTime;
            public readonly uint _titleID;
            public readonly DateTime _submissionTime;
            public readonly uint _service;
            public readonly byte[] _bundle;
            public readonly string _url;
            public readonly BundledAuthData _bundledAuthData;
        }

        private static Hashtable _avgSubmitTime;
        private static DateTime LastGarbageCollectionTime;
        private static PrioritizedThreadPool _threadPool;

        private static int BundleRetryPeriodInSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_BundleRetryPeriodInSeconds); }
        }    
        
        private static int MaxBundleRetrySeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_MaxBundleRetrySeconds); }
        }    
        
        private static int NumberFlushBundleThreads
        {
            get { return Config.GetIntSetting(Setting.xarb_NumberFlushBundleThreads); }
        }    
        
        private static int GarbageCollectionIntervalInSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_GarbageCollectionIntervalInSeconds); }
        }    
        
        private static long MemoryUsageLowWaterMark
        {
            get { return Config.GetIntSetting(Setting.xarb_MemoryUsageLowWaterMark); }
        }    
        
        private static long MemoryUsageHighWaterMark
        {
            get { return Config.GetIntSetting(Setting.xarb_MemoryUsageHighWaterMark); }
        }    
        

        static BundleSubmitter()
        {
            try
            {
                LastGarbageCollectionTime = DateTime.Now;

                _threadPool = new PrioritizedThreadPool(NumberFlushBundleThreads, ThreadPriority.BelowNormal, 100000, new HandleTask(SubmitBundle));
                _avgSubmitTime = new Hashtable(100);
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.ARBITRATION_CONFIGURATION_ERROR_5, "Error initializing BundleSubmitter", e );
            }
        }
        
        private static bool OverMemoryLimitCheck()
        {
            long totalMemoryUsed = GC.GetTotalMemory(false);
            if (totalMemoryUsed > MemoryUsageLowWaterMark)
            {
                // Perform garbage collection if we haven't done so in a while and we are over low memory mark
                bool collectGarbage = false;
                lock(typeof(BundleSubmitter))
                {
                    if (DateTime.Now > LastGarbageCollectionTime + new TimeSpan(0,0,GarbageCollectionIntervalInSeconds))
                    {
                        LastGarbageCollectionTime = DateTime.Now;
                        collectGarbage = true;
                    }
                }

                if (collectGarbage)
                {
                    GC.Collect(GC.MaxGeneration);
                }

                // Probability of returning true is 1 at HighWaterMark, and 0 at LowWaterMark
                Random r = new Random();
                if (r.NextDouble() < (((double)(totalMemoryUsed - MemoryUsageLowWaterMark)) / (MemoryUsageHighWaterMark - MemoryUsageLowWaterMark)))
                {
                  Xom.NtEvent(XEvent.Id.ARBITRATION_CODE_3, "Throwing away random queued bundle due to memory pressure! " + totalMemoryUsed + " bytes in use." + (collectGarbage ? (" Generation " + GC.MaxGeneration + " garbage collected.") : ""));
                    return true;
                }
            }
            return false;
        }

        public static void Submit( uint titleID, byte[] statsBundle, string statsURL, byte[] tournamentBundle, string tournamentURL, BundledAuthData bundledAuthData, TeamTickets teamTickets )
        {
            
            if (teamTickets != null)
            {
                // Append team tickets at the end of the post data
                MemoryStream postMemStream = new MemoryStream();
                BinaryWriter writer = new BinaryWriter(postMemStream);
                
                teamTickets.WriteStream(writer);
    
                postMemStream.Close();
                byte[] teamData = postMemStream.ToArray();
                byte[] buf;
                
                if (statsBundle != null)
                {
                    buf = new byte[statsBundle.Length + teamData.Length];
                    statsBundle.CopyTo(buf, 0);
                    teamData.CopyTo(buf, statsBundle.Length);
                    
                    statsBundle = buf;
                }
                        
                if (tournamentBundle != null)
                {
                    buf = new byte[tournamentBundle.Length + teamData.Length];
                    tournamentBundle.CopyTo(buf, 0);
                    teamData.CopyTo(buf, tournamentBundle.Length);
                    
                    tournamentBundle = buf;
                }
            }        
            
            if (statsBundle != null)
            {
                XArbitrationServerCounters.Counters.QueuedBundleCount.RawValue = 
                    _threadPool.SubmitTask( new SubmitInfo(titleID, (uint)XOService.Stats, statsBundle, statsURL, bundledAuthData) );
            }
            if (tournamentBundle != null)
            {
                XArbitrationServerCounters.Counters.QueuedBundleCount.RawValue = 
                    _threadPool.SubmitTask( new SubmitInfo(titleID, (uint)XOService.Query, tournamentBundle, tournamentURL, bundledAuthData) );
            }
        }

        private static void ReSubmit( SubmitInfo submitInfo )
        {
            if (OverMemoryLimitCheck())
            {
                // We need to throw this submission due to memory pressure!
                return;
            }
            
            if (submitInfo._nextSubmissionTime == DateTime.MinValue)
            {
                submitInfo._nextSubmissionTime = DateTime.Now + new TimeSpan(0,0,BundleRetryPeriodInSeconds);
            }
            else
            {
                // double the amount of time we spent waiting this time plus BundleRetryPeriodInSeconds
                submitInfo._nextSubmissionTime = DateTime.Now + new TimeSpan(0,0,BundleRetryPeriodInSeconds) + (DateTime.Now - submitInfo._nextSubmissionTime) + (DateTime.Now - submitInfo._nextSubmissionTime);
            }
            XArbitrationServerCounters.Counters.QueuedBundleCount.RawValue = _threadPool.SubmitTask( submitInfo );
        }

        public static void FlushBundles()
        {
            _threadPool.FlushAllTasks();
        }
        
        public static void SubmitBundle(IPrioritizedTask bundle)
        {
            XArbitrationServerCounters.Counters.QueuedBundleCount.RawValue = _threadPool.TaskCount;
            
            HResult hr;
            SubmitInfo submitInfo = (SubmitInfo)bundle;
            string url = submitInfo._url;
            
            if ((DateTime.Now - submitInfo._submissionTime) >= new TimeSpan(0,0,MaxBundleRetrySeconds))
            {
                Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_10,
                  "Abort submitting bundle for title: {0} to URL: {1} Tried {2} times and giving up. DateTime.Now {3} SubmitTime {4} MaxBundleRetrySeconds {5}",
                  (TitleId) submitInfo._titleID, submitInfo._url, submitInfo._submissionTryCount, DateTime.Now, submitInfo._submissionTime, MaxBundleRetrySeconds
                );

                return;
            }

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            try
            {
                if (url == null)
                {
                    if (submitInfo._service == (uint)XOService.Stats)
                    {
                        UriBuilder uri =  new UriBuilder(Config.GetVirtualInterface(VirtualInterface.xstatsfd_int).Url);
                        uri.Path = "/xstats/statpost.ashx";
                        
                        url = uri.ToString();
                    }
                    else
                    {
                        UriBuilder uri =  new UriBuilder(Config.GetVirtualInterface(VirtualInterface.xqry_int).Url);
                        uri.Path = "/xqry/select.ashx";
                        
                        url = uri.ToString();
                    }
                }
                hr = FrontDoorRequest( url, submitInfo._titleID, submitInfo._submissionTryCount == 0, submitInfo._service, submitInfo._bundle, submitInfo._bundledAuthData);
            }
            catch (Exception e)
            {
                hr = HResult.XONLINE_E_INTERNAL_ERROR;
                if (submitInfo._submissionTryCount == 0) // Only fire event on first failure for performance reasons
                {
                    Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_11, e, "Front door call for title:" + submitInfo._titleID.ToString("X") + " to " + url + " failed with internal problem, not retrying.");
                }
            }

            submitInfo._submissionTryCount++;
            
            object o = _avgSubmitTime[submitInfo.ServiceAndTitle];
            if (o == null)
            {
                _avgSubmitTime[submitInfo.ServiceAndTitle] = timeElapsed.MillisecondsElapsed;
            }
            else
            {
                _avgSubmitTime[submitInfo.ServiceAndTitle] = ((long)o + timeElapsed.MillisecondsElapsed) / 2;
            }
                
            switch (hr)
            {
                // These errors are transient, let's keep in queue and try again later
                case HResult.E_FAIL:
                case HResult.XONLINE_E_STAT_LEADERBOARD_READONLY:
                    ReSubmit( submitInfo );
                    break;
            }
            
            Xom.Log(XomAreaName.xarblog, "FDR|"
                + submitInfo._titleID.ToString("X") + "|"
                + url + "|"
                + submitInfo._submissionTryCount + "|"
                + submitInfo._bundle.Length + "|"
                + hr + "|"
                + timeElapsed.MillisecondsElapsed
                );
        }
                
        // Provides connection pooling and adds AuthData to HTTP Header
        // Implemented using System.Net.WebClient
        public static uint FrontDoorRequest( String Url, uint titleID, bool fireEventOnFailure, uint serviceId1, byte[] postData, BundledAuthData bundledAuthData  )
        {
            HResult hr = HResult.S_OK;
            
            WebClient myWebClient = new WebClient();
            myWebClient.Headers.Add(XHttpHdr.BUNDLEDAUTHDATA,bundledAuthData.GetBase64EncodedString());
            myWebClient.Headers.Add("Content-Type", "xon/"+serviceId1);
            myWebClient.Headers.Add("User-Agent", "Arbitration");
                
            try
            {
                myWebClient.UploadData(Url,"POST",postData);
            }
            catch (WebException e)
            {
                string xErr = null;

                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                }

                hr = (xErr == null) ? (HResult) HResult.E_FAIL : HResult.Parse(xErr);

                if (fireEventOnFailure)
                {
                    Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_12, e, "Front door call for title:" + titleID.ToString("X") + " to " + Url + " failed with hr = " + hr);
                }
            }

            return hr;
        }
    }
    
    
    public class ArbNetUtil
    {
        // simple helper provided here so it can easily be overridden in the 
        // xarb unit test
        //
        public static Uri GetCurrentUrl()
        {
            return HttpContext.Current.Request.Url;
        }
    }    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbDB.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Security.Principal;

using xonline.common.mgmt;
using xonline.common.service;
using Microsoft.Webstore.WstClient;
using xonline.common.config;
using xonline.common.sql.webstore;


namespace xonline.server.arbitration.inh
{
    public class TitleParameters
    {
        public TitleParameters(double paramBaseTrust, double paramMinorityQuorum, double paramUserTournamentAmplification, double paramPublisherTournamentAmplification, uint paramBaseSessionTime, double paramFermiK)
        {
            BaseTrust = paramBaseTrust;
            MinorityQuorum = paramMinorityQuorum;
            UserTournamentAmplification = paramUserTournamentAmplification;
            PublisherTournamentAmplification = paramPublisherTournamentAmplification;
            BaseSessionTime = paramBaseSessionTime;
            FermiK = paramFermiK;
        }

        public readonly double BaseTrust; // Base trust rewarded per Xbox
        public readonly double MinorityQuorum;
        public readonly double UserTournamentAmplification;
        public readonly double PublisherTournamentAmplification;
        public readonly uint BaseSessionTime;
        public readonly double FermiK; // Constant in Fermi function
    }

    public class TitleParameterManager
    {
        private static Hashtable _parameters = null;
        private static Timer _timer;
        private static bool _initialLoadComplete = false;
        private static int _loadingInProgress = 0;

        private static int TitleParameterReloadPeriodInSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_TitleParameterReloadPeriodInSeconds); }
        }

        static TitleParameterManager()
        {
            try
            {
                // Activate the trust summation manager
                TrustSummationManager.Init();
                DBHelper.Init();


                _timer = new System.Threading.Timer(new TimerCallback(ReloadTitleParameters), null, 0, TitleParameterReloadPeriodInSeconds * 1000);
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.ARBITRATION_CONFIGURATION_ERROR_1, "Error initializing TitleParameterManager", e );
            }
        }

        public static void ReloadTitleParameters(object o)
        {
            if (Interlocked.CompareExchange(ref _loadingInProgress,1,0) == 0)
            {
                try
                {
                    _parameters = DBHelper.GetTitleParameters();
                    _initialLoadComplete = true;
                    _timer.Change(TitleParameterReloadPeriodInSeconds * 1000, TitleParameterReloadPeriodInSeconds * 1000);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_3, e, "DBHelper.GetTitleParameters failed");
                }
                finally
                {
                    _loadingInProgress = 0;
                }
            }
        }

        public static TitleParameters Lookup( uint titleID )
        {
            // Wait (up to 10 seconds) for initial loading to complete
            Timer timer;
            int i;
            for (i=0; i<10; ++i)
            {
                if (_initialLoadComplete)
                {
                    break;
                }

                if (_loadingInProgress == 0)
                {
                    timer = new System.Threading.Timer(new TimerCallback(ReloadTitleParameters), null, 0, Timeout.Infinite);
                }

                Thread.Sleep(1000);
            }

            if (!_initialLoadComplete || _parameters == null)
            {
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_SERVICE_UNAVAILABLE, XEvent.Id.ARBITRATION_INTERNAL_FATAL_ERROR, "TitleParameters still not loaded after 10 seconds");
            }

            // Lookup parameters in hash table and return
            TitleParameters result = (TitleParameters)_parameters[titleID];
            if (result == null)
            {
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_SERVICE_UNAVAILABLE, XEvent.Id.ARBITRATION_INTERNAL_FATAL_ERROR_1, "TitleParameters does not exist for title: "+titleID.ToString("X"));
            }

            return result;
        }
    }

    public class TitleTrustSummation
    {
        public TitleTrustSummation(uint titleID)
        {
            TitleID = titleID;
            TotalUsers = 0;
            S1 = 0;
            S2 = 0;
            S3 = 0;
            S4 = 0;
            S5 = 0;
            S6 = 0;
            S7 = 0;
            S8 = 0;
            S9 = 0;
            TotalSessions = 0;
            TotalSessionDisconnects = 0;
            TotalCompetitions = 0;
            TotalCompetitionNoShows = 0;
            SessionBase = 0;
            SessionXboxCount = 0;
            SessionSeconds = 0;
            SessionFreeForAll = 0;
        }

        public readonly uint TitleID;
        public uint TotalUsers;
        public double S1;
        public double S2;
        public double S3;
        public double S4;
        public double S5;
        public double S6;
        public double S7;
        public double S8;
        public double S9;
        public ulong TotalSessions;
        public ulong TotalSessionDisconnects;
        public ulong TotalCompetitions;
        public ulong TotalCompetitionNoShows;
        public ulong SessionBase;
        public ulong SessionXboxCount;
        public ulong SessionSeconds;
        public ulong SessionFreeForAll;
    }

    public class TrustSummationManager
    {
        private static Timer _timer;

        private static int TrustSummationPeriodInSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_TrustSummationPeriodInSeconds); }
        }

        private static int TrustSummationExecutionTimeInSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_TrustSummationExecutionTimeInSeconds); }
        }

        private static int TrustSummationRetryInSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_TrustSummationRetryInSeconds); }
        }


        static TrustSummationManager()
        {
            try
            {
                _timer = new System.Threading.Timer(new TimerCallback(TrustSummation), null, 1000, TrustSummationPeriodInSeconds * 1000);
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.ARBITRATION_CONFIGURATION_ERROR_2, "Error initializing TitleParameterManager", e );
            }
        }

        public static void TrustSummation(object o)
        {
            int nextSummation = TrustSummationRetryInSeconds;

            try
            {
                // Check if we grabbed the lock to do the summation, if not, the stored proc will tell us how long to wait
                nextSummation = DBHelper.RequestTrustSummation((o == null) ? TrustSummationPeriodInSeconds : 0, TrustSummationExecutionTimeInSeconds);
                if (nextSummation == 0)
                {
                    // We have the right to perform the summation, start working on it...
                    DBHelper.PerformTrustSummation();

                    nextSummation = TrustSummationPeriodInSeconds;
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_4, e, "TrustSummationManager.TrustSummation failed");

                // If anything goes wrong in the process, let's try again pretty soon
                nextSummation = TrustSummationRetryInSeconds;
            }
            finally
            {
                _timer.Change(nextSummation * 1000, TrustSummationPeriodInSeconds * 1000);
            }
        }

        // the only purpose of this function is to ensure instantiation of the class
        public static void Init()
        {
        }
    }

    public class UpdateInfo
    {
        public UpdateInfo(uint paramTitleID, ulong paramPUID, float paramC1, float paramC2, float paramC3, float paramC4, float paramC5, float paramC6, float paramC7, float paramC8, float paramC9, int paramC10, int paramC11, int paramC12, int paramC13, int paramC14, int paramC15, int paramC16)
        {
            titleID = paramTitleID;
            PUID = paramPUID;
            C1 = paramC1;
            C2 = paramC2;
            C3 = paramC3;
            C4 = paramC4;
            C5 = paramC5;
            C6 = paramC6;
            C7 = paramC7;
            C8 = paramC8;
            C9 = paramC9;
            C10 = paramC10;
            C11 = paramC11;
            C12 = paramC12;
            C13 = paramC13;
            C14 = paramC14;
            C15 = paramC15;
            C16 = paramC16;
            when = DateTime.Now;
        }

        public void Add( UpdateInfo delta )
        {
            C1 += delta.C1;
            C2 += delta.C2;
            C3 += delta.C3;
            C4 += delta.C4;
            C5 += delta.C5;
            C6 += delta.C6;
            C7 += delta.C7;
            C8 += delta.C8;
            C9 += delta.C9;
            C10 += delta.C10;
            C11 += delta.C11;
            C12 += delta.C12;
            C13 += delta.C13;
            C14 += delta.C14;
            C15 += delta.C15;
            C16 += delta.C16;
            if (delta.when > when)
            {
                when = delta.when;
            }
        }

        public int batchCount
        {
            get { return C10; }
        }

        public readonly uint titleID;
        public readonly ulong PUID;
        public float C1;
        public float C2;
        public float C3;
        public float C4;
        public float C5;
        public float C6;
        public float C7;
        public float C8;
        public float C9;
        public int C10;
        public int C11;
        public int C12;
        public int C13;
        public int C14;
        public int C15;
        public int C16;
        public DateTime when;
    }

    //
    // The tricky thing about this updater is that we batch updates trust changes together
    // and only flush them out to UODB when the user is inactive on that title over TrustIdleSecondsBeforeFlush
    //
    public class TrustRatingUpdater
    {
        internal struct TitleIDAndPUID
        {
            public TitleIDAndPUID(uint paramTitleID, ulong paramPUID)
            {
                titleID = paramTitleID;
                PUID = paramPUID;
            }

            public override int GetHashCode()
            {
                ulong val = ((PUID * 1718205583) + titleID);
                return ((int)(val)) ^ ((int)(val >> 32));
            }

            public readonly uint titleID;
            public readonly ulong PUID;
        }

        private static Queue _queue = null;
        private static bool _terminateThreads = false;
        private static bool _flushAllTrustDuringNextFlush = false;

        private static int TrustIdleSecondsBeforeFlush
        {
            get { return Config.GetIntSetting(Setting.xarb_TrustIdleSecondsBeforeFlush); }
        }

        private static int TrustFlushPeriodInSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_TrustFlushPeriodInSeconds); }
        }

        private static int MaxDelayedTrustUpdates
        {
            get { return Config.GetIntSetting(Setting.xarb_MaxDelayedTrustUpdates); }
        }

        private static int NumberFlushTrustRatingThreads
        {
            get { return Config.GetIntSetting(Setting.xarb_NumberFlushTrustRatingThreads); }
        }

        private static XboxLiveThread[] rgThreads;

        static TrustRatingUpdater()
        {
            try
            {
                _queue = new Queue();

                rgThreads = new XboxLiveThread[ NumberFlushTrustRatingThreads ];

                for( int i = 0; i < NumberFlushTrustRatingThreads; i++ )
                {
                    rgThreads[i] = new XboxLiveThread( new ThreadStart( FlushTrustRatingThreadMethod ) );
                    rgThreads[i].Priority = ThreadPriority.BelowNormal;
                    rgThreads[i].Start();
                }
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.ARBITRATION_CONFIGURATION_ERROR_3, "Error initializing TrustRatingUpdater", e );
            }
        }

        ~TrustRatingUpdater()
        {
            // Flush everything out
            _flushAllTrustDuringNextFlush = true;
            _terminateThreads = true;
            FlushTrustRatingMethod(false);
        }

        public static void FlushTrustRatings()
        {
            _flushAllTrustDuringNextFlush = true;
            FlushTrustRatingMethod(false);
            _flushAllTrustDuringNextFlush = false;
        }

        static void FlushTrustRatingThreadMethod()
        {
            FlushTrustRatingMethod( true );
        }

        static void FlushTrustRatingMethod(bool loop)
        {
            do
            {
                try
                {
                    if (loop)
                    {
                        if (_terminateThreads)
                        {
                            return;
                        }
                        Thread.Sleep(TrustFlushPeriodInSeconds * 1000);
                    }

                    Queue oldQueue;
                    lock(typeof(TrustRatingUpdater))
                    {
                        // swap the queue
                        oldQueue = _queue;
                        _queue = new Queue();
                        XArbitrationServerCounters.Counters.QueuedTrustUpdateCount.RawValue = _queue.Count;
                    }

                    // Now lets play with the old queue outside the lock
                    UpdateInfo updateInfo;
                    UpdateInfo existingUpdateInfo;
                    TitleIDAndPUID titleIDAndPUID;
                    Hashtable table = new Hashtable(oldQueue.Count);

                    // Walk the queue and create a hashtable of merged entries
                    while (oldQueue.Count > 0)
                    {
                        updateInfo = (UpdateInfo)(oldQueue.Dequeue());
                        titleIDAndPUID = new TitleIDAndPUID(updateInfo.titleID, updateInfo.PUID);
                        existingUpdateInfo = (UpdateInfo)table[titleIDAndPUID];
                        if (existingUpdateInfo == null)
                        {
                            table.Add(titleIDAndPUID, updateInfo);
                        }
                        else
                        {
                            existingUpdateInfo.Add(updateInfo);
                        }
                    }

                    // Walk the hashtable and submit idle entries to DB
                    // Put the active entries back in queue
                    DateTime idleIfModifiedBefore = DateTime.Now.AddSeconds(-TrustIdleSecondsBeforeFlush);
                    foreach (object o in table.Values)
                    {
                        updateInfo = (UpdateInfo)o;
                        if (_flushAllTrustDuringNextFlush || updateInfo.batchCount >= MaxDelayedTrustUpdates || updateInfo.when <= idleIfModifiedBefore)
                        {
                            // Idle entry, send to DB
                            try
                            {
                                DBHelper.UpdateUserTrust(updateInfo);
                            }
                            catch (Exception e)
                            {
                                // DB operation failed, log event
                                // We diliberately don't retry and put the submission back into the queue
                                Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_5, e, "DBHelper.UpdateUserTrust failed");
                            }
                        }
                        else
                        {
                            // Put it back in queue
                            UpdateTrust(updateInfo);
                        }
                    }
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.ARBITRATION_CODE_2, e, "FlushTrustRatingMethod loop threw exception:");
                }
            } while (loop);
        }

        public static void UpdateTrust(uint TitleID, ulong PUID, float C1, float C2, float C3, float C4, float C5, float C6, float C7, float C8, float C9, int C10, int C11, int C12, int C13, int C14, int C15, int C16)
        {
            UpdateTrust( new UpdateInfo(TitleID, PUID, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16) );
        }

        internal static void UpdateTrust(UpdateInfo updateInfo)
        {
            lock(typeof(TrustRatingUpdater))
            {
                _queue.Enqueue( updateInfo );
                XArbitrationServerCounters.Counters.QueuedTrustUpdateCount.RawValue = _queue.Count;
            }
        }
    }

    public class DBHelper
    {
        private static string UODBDatabase;
        private static int TrustSummationTimeoutSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_TrustSummationTimeoutSeconds); }
        }


        private static WindowsIdentity _windowsIdentity;

        static DBHelper()
        {
            try
            {
                _windowsIdentity = WindowsIdentity.GetCurrent();

                UODBDatabase = ConfigUtil.UodbWebstoreApp;
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.ARBITRATION_CONFIGURATION_ERROR_4, "Error initializing DBHelper", e );
            }
        }

        // the only purpose of this function is to ensure instantiation of the class
        public static void Init()
        {
        }

        public static Hashtable GetTitleParameters()
        {
            Hashtable parameters = new Hashtable(32);

            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader dataset = null;
            WindowsImpersonationContext ctx = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    ctx = _windowsIdentity.Impersonate();

                    // Open a connection
                    conn = new WstConnection(UODBDatabase);
                    conn.Open();

                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                    // Create a command to call the stored procedure
                    cmd = conn.CreateCommand();
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "dbo.p_xarb_get_title_trust_constants";

                    // Execute stored procedure
                    dataset = cmd.ExecuteReader();

                    while (dataset.Read())
                    {
                        TitleParameters titleParameters = new TitleParameters(dataset.GetDouble(1), dataset.GetDouble(2), dataset.GetDouble(3), dataset.GetDouble(4), (uint)dataset.GetInt32(5), dataset.GetDouble(6));

                        uint titleID = (uint)dataset.GetInt32(0);

                        Xom.Log(XomAreaName.xarblog, "LTP|"
                                    + titleID.ToString("X") + "|"
                                    + titleParameters.BaseTrust + "|"
                                    + titleParameters.MinorityQuorum + "|"
                                    + titleParameters.UserTournamentAmplification + "|"
                                    + titleParameters.PublisherTournamentAmplification + "|"
                                    + titleParameters.BaseSessionTime + "|"
                                    + titleParameters.FermiK + "|"
                                    + timeElapsed.MillisecondsElapsed
                                    );

                        parameters.Add(titleID, titleParameters);
                    }

                    dataset.Close();
                }
                finally
                {
                    if (ctx != null)
                    {
                        ctx.Undo();
                    }
                }
            }
            catch( Exception e )
            {
                Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_6, e, "UODB p_xarb_get_title_trust_constants call failed");
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }

                if (dataset != null)
                {
                    dataset.Close();
                    dataset = null;
                }
            }

            return parameters;
        }

        public static void UpdateUserTrust(UpdateInfo updateInfo)
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader dataset = null;
            SqlParameter    ret     = null;
            WindowsImpersonationContext ctx = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    ctx = _windowsIdentity.Impersonate();

                    // Open a connection
                    conn = new WstConnection(UODBDatabase);
                    conn.Open();

                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                    // Create a command to call the stored procedure
                    cmd = conn.CreateCommand();
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "dbo.p_xarb_update_user_trust";

                    cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                    // Data is partitioned by user puid
                    cmd.PartitionType = WstPartitionType.Logical;
                    cmd.Partition = WSClient.GetHashPartition(updateInfo.PUID, UODBDatabase);

                    // Set the stored procedure parameters
                    ret = new SqlParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@user_puid", SqlDbType.BigInt).Value = (long)updateInfo.PUID;
                    cmd.Parameters.Add("@title_id", SqlDbType.Int).Value = (int)updateInfo.titleID;
                    cmd.Parameters.Add("@C1_change", SqlDbType.Real).Value = updateInfo.C1;
                    cmd.Parameters.Add("@C2_change", SqlDbType.Real).Value = updateInfo.C2;
                    cmd.Parameters.Add("@C3_change", SqlDbType.Real).Value = updateInfo.C3;
                    cmd.Parameters.Add("@C4_change", SqlDbType.Real).Value = updateInfo.C4;
                    cmd.Parameters.Add("@C5_change", SqlDbType.Real).Value = updateInfo.C5;
                    cmd.Parameters.Add("@C6_change", SqlDbType.Real).Value = updateInfo.C6;
                    cmd.Parameters.Add("@C7_change", SqlDbType.Real).Value = updateInfo.C7;
                    cmd.Parameters.Add("@C8_change", SqlDbType.Real).Value = updateInfo.C8;
                    cmd.Parameters.Add("@C9_change", SqlDbType.Real).Value = updateInfo.C9;
                    cmd.Parameters.Add("@C10_change", SqlDbType.Int).Value = updateInfo.C10;
                    cmd.Parameters.Add("@C11_change", SqlDbType.Int).Value = updateInfo.C11;
                    cmd.Parameters.Add("@C12_change", SqlDbType.Int).Value = updateInfo.C12;
                    cmd.Parameters.Add("@C13_change", SqlDbType.Int).Value = updateInfo.C13;
                    cmd.Parameters.Add("@C14_change", SqlDbType.Int).Value = updateInfo.C14;
                    cmd.Parameters.Add("@C15_change", SqlDbType.Int).Value = updateInfo.C15;
                    cmd.Parameters.Add("@C16_change", SqlDbType.Int).Value = updateInfo.C16;
                    cmd.Parameters.Add("@Hash_Bucket", SqlDbType.Int).Value = (int)cmd.Partition;

                    // Execute stored procedure
                    dataset = cmd.ExecuteReader();
                    dataset.Close();
                    dataset = null;

                    HResult hr = (uint)((int)ret.Value);

                    Xom.Log(XomAreaName.xarblog, "UUT|"
                                + updateInfo.PUID.ToString("X") + "|"
                                + updateInfo.titleID.ToString("X") + "|"
                                + updateInfo.batchCount + "|"
                                + hr + "|"
                                + timeElapsed.MillisecondsElapsed
                                );

                    if (hr != HResult.S_OK)
                    {
                        Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_7, "UODB p_xarb_update_user_trust, hr = " + hr);
                    }
                }
                finally
                {
                    if (ctx != null)
                    {
                        ctx.Undo();
                    }
                }
            }
            catch( Exception e )
            {
                Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_8, e, "UODB p_xarb_update_user_trust call failed");
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }

                if (dataset != null)
                {
                    dataset.Close();
                    dataset = null;
                }
            }
        }

        public static int RequestTrustSummation(int TrustSummationPeriodInSeconds, int TrustSummationExecutionTimeInSeconds)
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader dataset = null;
            WindowsImpersonationContext ctx = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    ctx = _windowsIdentity.Impersonate();

                    SqlParameter ret = null;
                    int nextSummation;

                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                    // Open a connection
                    conn = new WstConnection(UODBDatabase);
                    conn.Open();

                    // Create a command to call the stored procedure
                    cmd = conn.CreateCommand();
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "dbo.p_xarb_request_trust_update";
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.Partition = 0;

                    // Set the stored procedure parameters
                    ret = new SqlParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);
                    cmd.Parameters.Add("@i_update_period", SqlDbType.Int).Value = TrustSummationPeriodInSeconds;
                    cmd.Parameters.Add("@i_exec_time", SqlDbType.Int).Value = TrustSummationExecutionTimeInSeconds;

                    // Execute stored procedure
                    dataset = cmd.ExecuteReader();

                    nextSummation = ((int)ret.Value);

                    dataset.Close();
                    dataset = null;

                    Xom.Log(XomAreaName.xarblog, "RTU|"
                                + TrustSummationPeriodInSeconds + "|"
                                + TrustSummationExecutionTimeInSeconds + "|"
                                + nextSummation + "|"
                                + timeElapsed.MillisecondsElapsed
                                );

                    return nextSummation;
                }
                finally
                {
                    if (ctx != null)
                    {
                        ctx.Undo();
                    }
                }
            }
            catch( Exception e )
            {
                throw e;
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }

                if (dataset != null)
                {
                    dataset.Close();
                    dataset = null;
                }
            }
        }

        public static void PerformTrustSummation()
        {
            Hashtable titleSummations = new Hashtable(32);

            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader dataset = null;
            HResult hr;
            int PhysicalPartitions;
            int i;
            uint titleID;
            object o;
            TitleTrustSummation titleTrustSummation;
            WindowsImpersonationContext ctx = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    ctx = _windowsIdentity.Impersonate();

                    // Open a connection
                    conn = new WstConnection(UODBDatabase);
                    conn.Open();
                    PhysicalPartitions = conn.SqlPartitions.Count;

                    for (i = 0; i < PhysicalPartitions; ++i)
                    {
                        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                        // Create a command to call the stored procedure
                        cmd = conn.CreateCommand();
                        cmd.CommandTimeout = TrustSummationTimeoutSeconds;
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.CommandText = "dbo.p_xarb_get_trust_tally";

                        cmd.PartitionType = WstPartitionType.Physical;
                        cmd.Partition = i;

                        // Execute stored procedure
                        dataset = cmd.ExecuteReader();

                        while (dataset.Read())
                        {
                            titleID = (uint)dataset.GetInt32(0);
                            o = titleSummations[titleID];
                            if (o == null)
                            {
                                titleTrustSummation = new TitleTrustSummation(titleID);
                                titleSummations.Add(titleID, titleTrustSummation);
                            }
                            else
                            {
                                titleTrustSummation = (TitleTrustSummation)o;
                            }

                            titleTrustSummation.TotalUsers += (uint)dataset.GetInt32(1);
                            titleTrustSummation.S1 += dataset.GetDouble(2);
                            titleTrustSummation.S2 += dataset.GetDouble(3);
                            titleTrustSummation.S3 += dataset.GetDouble(4);
                            titleTrustSummation.S4 += dataset.GetDouble(5);
                            titleTrustSummation.S5 += dataset.GetDouble(6);
                            titleTrustSummation.S6 += dataset.GetDouble(7);
                            titleTrustSummation.S7 += dataset.GetDouble(8);
                            titleTrustSummation.S8 += dataset.GetDouble(9);
                            titleTrustSummation.S9 += dataset.GetDouble(10);
                            titleTrustSummation.TotalSessions += (ulong)dataset.GetInt64(11);
                            titleTrustSummation.TotalSessionDisconnects += (ulong)dataset.GetInt64(12);
                            titleTrustSummation.TotalCompetitions += (ulong)dataset.GetInt64(13);
                            titleTrustSummation.TotalCompetitionNoShows += (ulong)dataset.GetInt64(14);
                            titleTrustSummation.SessionBase += (ulong)dataset.GetInt64(15);
                            titleTrustSummation.SessionXboxCount += (ulong)dataset.GetInt64(16);
                            titleTrustSummation.SessionSeconds += (ulong)dataset.GetInt64(17);
                            titleTrustSummation.SessionFreeForAll += (ulong)dataset.GetInt64(18);

                            Xom.Log(XomAreaName.xarblog, "GTT|"
                                        + titleID.ToString("X") + "|"
                                        + titleTrustSummation.TotalUsers + "|"
                                        + titleTrustSummation.S1 + "|"
                                        + titleTrustSummation.S2 + "|"
                                        + titleTrustSummation.S3 + "|"
                                        + titleTrustSummation.S4 + "|"
                                        + titleTrustSummation.S5 + "|"
                                        + titleTrustSummation.S6 + "|"
                                        + titleTrustSummation.S7 + "|"
                                        + titleTrustSummation.S8 + "|"
                                        + titleTrustSummation.S9 + "|"
                                        + titleTrustSummation.TotalSessions + "|"
                                        + titleTrustSummation.TotalSessionDisconnects + "|"
                                        + titleTrustSummation.TotalCompetitions + "|"
                                        + titleTrustSummation.TotalCompetitionNoShows + "|"
                                        + titleTrustSummation.SessionBase + "|"
                                        + titleTrustSummation.SessionXboxCount + "|"
                                        + titleTrustSummation.SessionSeconds + "|"
                                        + titleTrustSummation.SessionFreeForAll + "|"
                                        + timeElapsed.MillisecondsElapsed
                                        );
                        }

                        dataset.Close();
                        dataset = null;
                    }

                    // Now write the summation back into the DB
                    SqlParameter ret = null;

                    IDictionaryEnumerator enumerator = titleSummations.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        titleTrustSummation = (TitleTrustSummation)enumerator.Value;

                        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                        // Create a command to call the stored procedure
                        cmd = conn.CreateCommand();
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.CommandText = "dbo.p_xarb_update_trust_weights";
                        cmd.PartitionType = WstPartitionType.Physical;

                        // Set the stored procedure parameters
                        ret = new SqlParameter();
                        ret.Direction = ParameterDirection.ReturnValue;
                        cmd.Parameters.Add(ret);

                        cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleTrustSummation.TitleID;
                        cmd.Parameters.Add("@i_TotalUsers", SqlDbType.Int).Value = (int)titleTrustSummation.TotalUsers;
                        cmd.Parameters.Add("@f_S1", SqlDbType.Float).Value = titleTrustSummation.S1;
                        cmd.Parameters.Add("@f_S2", SqlDbType.Float).Value = titleTrustSummation.S2;
                        cmd.Parameters.Add("@f_S3", SqlDbType.Float).Value = titleTrustSummation.S3;
                        cmd.Parameters.Add("@f_S4", SqlDbType.Float).Value = titleTrustSummation.S4;
                        cmd.Parameters.Add("@f_S5", SqlDbType.Float).Value = titleTrustSummation.S5;
                        cmd.Parameters.Add("@f_S6", SqlDbType.Float).Value = titleTrustSummation.S6;
                        cmd.Parameters.Add("@f_S7", SqlDbType.Float).Value = titleTrustSummation.S7;
                        cmd.Parameters.Add("@f_S8", SqlDbType.Float).Value = titleTrustSummation.S8;
                        cmd.Parameters.Add("@f_S9", SqlDbType.Float).Value = titleTrustSummation.S9;
                        cmd.Parameters.Add("@bi_TotalSessions", SqlDbType.BigInt).Value = (long)titleTrustSummation.TotalSessions;
                        cmd.Parameters.Add("@bi_TotalSessionDisconnects", SqlDbType.BigInt).Value = (long)titleTrustSummation.TotalSessionDisconnects;
                        cmd.Parameters.Add("@bi_TotalCompetitions", SqlDbType.BigInt).Value = (long)titleTrustSummation.TotalCompetitions;
                        cmd.Parameters.Add("@bi_TotalCompetitionNoShows", SqlDbType.BigInt).Value = (long)titleTrustSummation.TotalCompetitionNoShows;
                        cmd.Parameters.Add("@bi_SessionBase", SqlDbType.BigInt).Value = (long)titleTrustSummation.SessionBase;
                        cmd.Parameters.Add("@bi_SessionXboxCount", SqlDbType.BigInt).Value = (long)titleTrustSummation.SessionXboxCount;
                        cmd.Parameters.Add("@bi_SessionSeconds", SqlDbType.BigInt).Value = (long)titleTrustSummation.SessionSeconds;
                        cmd.Parameters.Add("@bi_SessionFreeForAll", SqlDbType.BigInt).Value = (long)titleTrustSummation.SessionFreeForAll;

                        // Execute stored procedure on all physical partitions
                        for (i = PhysicalPartitions - 1; i >= 0; --i)
                        {
                            cmd.Partition = i;
                            dataset = cmd.ExecuteReader();
                            dataset.Close();
                            dataset = null;
                        }
                        hr = (uint)((int)ret.Value);

                        Xom.Log(XomAreaName.xarblog, "UTW|"
                                    + titleTrustSummation.TitleID.ToString("X") + "|"
                                    + titleTrustSummation.TotalUsers + "|"
                                    + titleTrustSummation.S1 + "|"
                                    + titleTrustSummation.S2 + "|"
                                    + titleTrustSummation.S3 + "|"
                                    + titleTrustSummation.S4 + "|"
                                    + titleTrustSummation.S5 + "|"
                                    + titleTrustSummation.S6 + "|"
                                    + titleTrustSummation.S7 + "|"
                                    + titleTrustSummation.S8 + "|"
                                    + titleTrustSummation.S9 + "|"
                                    + titleTrustSummation.TotalSessions + "|"
                                    + titleTrustSummation.TotalSessionDisconnects + "|"
                                    + titleTrustSummation.TotalCompetitions + "|"
                                    + titleTrustSummation.TotalCompetitionNoShows + "|"
                                    + titleTrustSummation.SessionBase + "|"
                                    + titleTrustSummation.SessionXboxCount + "|"
                                    + titleTrustSummation.SessionSeconds + "|"
                                    + titleTrustSummation.SessionFreeForAll + "|"
                                    + hr + "|"
                                    + timeElapsed.MillisecondsElapsed
                                    );

                        if (hr != HResult.S_OK)
                        {
                            Xom.NtEvent(XEvent.Id.ARBITRATION_COMM_9, "UODB p_xarb_update_trust_weights returned hr = " + hr + " for title: " + (TitleId) titleTrustSummation.TitleID);
                        }
                    }
                }
                finally
                {
                    if (ctx != null)
                    {
                        ctx.Undo();
                    }
                }
            }
            catch( Exception e )
            {
                throw e;
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }

                if (dataset != null)
                {
                    dataset.Close();
                    dataset = null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\test\dvt\FakeXArbDB.cs ===
using System;

using xonline.common.service;
using xonline.server.arbitration.test.unit;

namespace xonline.server.arbitration.inh
{
    public class TitleParameters
    {
        public TitleParameters(double paramBaseTrust, double paramMinorityQuorum, double paramUserTournamentAmplification, double paramPublisherTournamentAmplification, uint paramBaseSessionTime, double paramFermiK)
        {
            BaseTrust = paramBaseTrust;
            MinorityQuorum = paramMinorityQuorum;
            UserTournamentAmplification = paramUserTournamentAmplification;
            PublisherTournamentAmplification = paramPublisherTournamentAmplification;
            BaseSessionTime = paramBaseSessionTime;
            FermiK = paramFermiK;
        }
        
        public readonly double BaseTrust; // Base trust rewarded per Xbox
        public readonly double MinorityQuorum;
        public readonly double UserTournamentAmplification;
        public readonly double PublisherTournamentAmplification;
        public readonly uint BaseSessionTime;
        public readonly double FermiK; // Constant in Fermi function
    }
    
    public class TitleParameterManager
    {
        public static TitleParameters Lookup( uint titleID )
        {
            return ArbSessionTest.Lookup(titleID);
        }
    }

    //
    // The tricky thing about this updater is that we batch updates trust changes together
    // and only flush them out to UODB when the user is inactive on that title over TrustIdleSecondsBeforeFlush
    //
    public class TrustRatingUpdater
    {
        public static void UpdateTrust(uint TitleID, ulong PUID, float C1, float C2, float C3, float C4, float C5, float C6, float C7, float C8, float C9, int C10, int C11, int C12, int C13, int C14, int C15, int C16)
        {
            ArbSessionTest.UpdateTrust(TitleID, PUID, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\test\dvt\arbTestUtil.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.protocol;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.stfutil;


public class ArbTestUtil
{
    public const uint TITLE_ID = 1234;

    public static uint Register(ulong xboxId, ulong userId, float trust, ulong teamId, ulong sessionId, ulong sessionNonce)
    {
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, trust);
        uint hr;
        
        byte[] postData = GetRegisterPostData(xboxId, users, teamId, 0x000b, sessionId, sessionNonce);
        
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 
        
        hr = FrontDoorRequest( Config.GetVirtualInterface(VirtualInterface.xarb_int).Url, "/xarb/Register.ashx", xboxId, users, postData, out respData );
        
        Console.WriteLine("Register took {0}ms and returned {1}", timeElapsed.MillisecondsElapsed, hr.ToString("x"));
        Console.WriteLine("Register input: "+ByteConvert.ToString(postData));
        Console.WriteLine("Register output: "+ByteConvert.ToString(respData));
        Console.WriteLine("");
        
        return hr;
    }


    public static uint RegisterInh(string server, ulong xboxId, ulong userId, float trust, ulong teamId, ulong sessionId, ulong sessionNonce)
    {
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, trust);
        uint hr;
        
        byte[] postData = GetRegisterPostData(xboxId, users, teamId, 0x000b, sessionId, sessionNonce);
        
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 
        
        hr = InhRequest( server, "/xarbInh/Register.ashx", xboxId, users, postData, out respData );
        
        Console.WriteLine("Register took {0}ms and returned {1}", timeElapsed.MillisecondsElapsed, hr.ToString("x"));
        Console.WriteLine("Register input: "+ByteConvert.ToString(postData));
        Console.WriteLine("Register output: "+ByteConvert.ToString(respData));
        Console.WriteLine("");
        
        return hr;
    }
    
    public static byte[] GetRegisterPostData(ulong xboxId, XUIDAndTrust[] users, ulong teamId, ushort flags, ulong sessionId, ulong sessionNonce)
    {
        MemoryStream postStream = new MemoryStream(200);
        BinaryWriter writer = new BinaryWriter(postStream);
        
        writer.Write((ushort)1);
        writer.Write(flags);
        writer.Write(TITLE_ID);
        writer.Write(sessionId);
        writer.Write(sessionNonce);
        writer.Write((ushort)400);
        
        if (teamId != 0)
        {
            TeamTicket[] teamTicket = new TeamTicket[1];
            teamTicket[0] = new TeamTicket(users[0].qwUserID, teamId);
            teamTicket[0].SignTicket(new HTTPAuthData((ushort)3, (uint)0x44444444, (ulong)0x5555555555555555, xboxId, users, TITLE_ID, (uint)XOService.Arbitration, 0));
            TeamTickets teamTickets = new TeamTickets(teamTicket);
            teamTickets.WriteStream(writer);
        }
        
                    
        return postStream.ToArray();
    }
    

    
    public static uint TimeExtend(ulong xboxId, ulong userId, float trust, ulong sessionId, ulong sessionNonce)
    {
        uint hr; 
        
        byte[] postData = GetTimeExtendPostData(sessionId, sessionNonce);
        
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, trust);

        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 

        hr = FrontDoorRequest( Config.GetVirtualInterface(VirtualInterface.xarb_int).Url, "/xarb/TimeExtend.ashx", xboxId, users, postData, out respData);

        Console.WriteLine("TimeExtend took {0}ms", timeElapsed.MillisecondsElapsed);
        Console.WriteLine("TimeExtend input: "+ByteConvert.ToString(postData));
        Console.WriteLine("TimeExtend output: "+ByteConvert.ToString(respData));
        Console.WriteLine("");
        
        return hr;
    }
    
    public static uint TimeExtendInh(string server, ulong xboxId, ulong userId, float trust, ulong sessionId, ulong sessionNonce)
    {
        uint hr; 
        
        byte[] postData = GetTimeExtendPostData(sessionId, sessionNonce);
        
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, trust);

        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 

        hr = InhRequest(server, "/xarbInh/TimeExtend.ashx", xboxId, users, postData, out respData);

        Console.WriteLine("TimeExtend took {0}ms", timeElapsed.MillisecondsElapsed);
        Console.WriteLine("TimeExtend input: "+ByteConvert.ToString(postData));
        Console.WriteLine("TimeExtend output: "+ByteConvert.ToString(respData));
        Console.WriteLine("");
        
        return hr;
    }
    
    public static byte[] GetTimeExtendPostData(ulong sessionId, ulong sessionNonce)
    {
        MemoryStream postStream = new MemoryStream(200);
        BinaryWriter writer = new BinaryWriter(postStream);
        
        writer.Write((ushort)1);
        writer.Write((ushort)0x0000);
        writer.Write(TITLE_ID);
        writer.Write(sessionId);
        writer.Write(sessionNonce);
        writer.Write((ushort)800);
        
        return postStream.ToArray();        
    }



    public static uint ReportResult(ulong xboxId, ulong userId, float trust, ArbitrationReportResultRequest req)
    {
        uint hr; 
        
        byte[] postData = req.GetBytes();
        
        
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, trust);

        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 

        hr = FrontDoorRequest( Config.GetVirtualInterface(VirtualInterface.xarb_int).Url, "/xarb/ReportResult.ashx", xboxId, users, postData, out respData);

        Console.WriteLine("ReportResult took {0}ms", timeElapsed.MillisecondsElapsed);
        Console.WriteLine("ReportResult input: "+ByteConvert.ToString(postData));
        Console.WriteLine("ReportResult output: "+ByteConvert.ToString(respData));
        Console.WriteLine("");
        
        return hr;
    }


    public static uint ReportResultInh(string server, ulong xboxId, ulong userId, float trust, ArbitrationReportResultRequest req)
    {
        uint hr; 
        
        byte[] postData = req.GetBytes();
        
        
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, trust);

        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 

        hr = InhRequest(server, "/xarbinh/ReportResult.ashx", xboxId, users, postData, out respData);

        Console.WriteLine("ReportResult took {0}ms", timeElapsed.MillisecondsElapsed);
        Console.WriteLine("ReportResult input: "+ByteConvert.ToString(postData));
        Console.WriteLine("ReportResult output: "+ByteConvert.ToString(respData));
        Console.WriteLine("");
        
        return hr;
    }


    public static uint DebugResult(ulong xboxId, ulong userId, float trust, ArbitrationDebugResultRequest req)
    {
        byte[] postData = req.GetBytes();
        uint hr;
            
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, -7.0F);

        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 

        hr = FrontDoorRequest(Config.GetVirtualInterface(VirtualInterface.xarb_int).Url, "/xarb/DebugResult.ashx", xboxId, users, postData, out respData);

        ArbitrationDebugResultResponse response = new ArbitrationDebugResultResponse();

        Console.WriteLine("DebugResult took {0}ms", timeElapsed.MillisecondsElapsed);
        Console.WriteLine("DebugResult input:" + req.ToString(4));
        if (hr == HResult.S_OK && respData != null)
        {
            response.ReadBytes(respData);
            Console.WriteLine("DebugResult output:" + response.ToString(4));
        }
        Console.WriteLine("");
        
        return hr;
    }        
        
    public static uint DebugResultInh(string server, ulong xboxId, ulong userId, float trust, ArbitrationDebugResultRequest req)
    {
        byte[] postData = req.GetBytes();
        uint hr;
            
        XUIDAndTrust[] users = new XUIDAndTrust[1];
        users[0] = new XUIDAndTrust(userId, 0, -7.0F);

        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        byte[] respData; 

        hr = FrontDoorRequest(Config.GetInterface(server, Interface.xarbInh).Url, "/xarbinh/DebugResult.ashx", xboxId, users, postData, out respData);

        ArbitrationDebugResultResponse response = new ArbitrationDebugResultResponse();

        Console.WriteLine("DebugResult took {0}ms", timeElapsed.MillisecondsElapsed);
        Console.WriteLine("DebugResult input:" + req.ToString(4));
        if (hr == HResult.S_OK && respData != null)
        {
            response.ReadBytes(respData);
            Console.WriteLine("DebugRes ultoutput:" + response.ToString(4));
        }
        Console.WriteLine("");
        
        return hr;
    }        

    public static uint InhRequest(string szServer, string path, ulong xboxID, XUIDAndTrust[] users, byte[] postData, out byte[] respData) 
    {
        IInterfaceInfo info = Config.GetInterface(szServer, Interface.xarbInh);
       
        XrlRequest req = new XrlRequest();
        req.TargetInterface= Interface.xarbInh;
        req.TargetUrl = info.Url;
        req.Path = path;
        req.PostData = postData;

        
        req.AuthData = new HTTPAuthData((ushort)3, (uint)0x44444444, (ulong)0x5555555555555555, xboxID, users, TITLE_ID, (uint)XOService.Arbitration, 0).GetBase64EncodedString();
            
        uint hr = req.Send();
        
        respData = req.ResponseData;
        
        return hr;
    
    }

    
    public static uint FrontDoorRequest( Uri url, String path, ulong xboxID, XUIDAndTrust[] users, byte[] postData, out byte[] respData)
    {
        CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
        slot.AddService(ServerTestFramework.LiveService.XOService.Arbitration);
        slot.titleId = TITLE_ID;
        slot.machinePuid = xboxID;
        slot.userPuid0 = users.Length <= 0 ? 0 : users[0].qwUserID;
        slot.userPuid1 = users.Length <= 1 ? 0 : users[1].qwUserID;
        slot.userPuid2 = users.Length <= 2 ? 0 : users[2].qwUserID;
        slot.userPuid3 = users.Length <= 3 ? 0 : users[3].qwUserID;
        
        
        
        
        uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Arbitration, false, path, postData, out respData);
        return hr;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\FuncWSPurchaseGamertag.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Billing.WebService2;
using ServerTestFramework.LiveService.Billing;
using XeXbos;


namespace XeXbos.Functional
{
    [TestGroup, Owner("styoo"), Description("PurchaseGamertag Web Service test"), TestFrequency("Regression"), EnvRequirement("")]
    public class WSPurchaseGamertag : TestNode
    {
        static Guid offerId = XbosWS.EMSOfferInfo.OfferIdToOfferingGuid(Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange));
        static Guid paidOfferId = XbosWS.EMSOfferInfo.OfferIdToOfferingGuid(Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange));
        
        [TestCase, TestCasePriority(1)]
        public class P_Mainline : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                byte[] ownerPassportToken; 

                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.Gamertag = UodbWS.GetGamertag(user.UserPuid);
                user.PassportUserPuid =  PassportUtilities.GetPuidFromSessionToken(ownerPassportToken);

                int numChanges = UodbWS.GetGamerTagChanges(user.UserPuid).Length;


                RandomEx rnd = new RandomEx();
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", newGamerTag);
                string token = "";
                
                uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, newGamerTag, token);
                Global.RO.Info("PurchaseGamertag returned {0}", hr);

                if (hr != HResult.S_OK) 
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertag returned {0}", hr) );

                // validate t_users table
                string returnedGamertag = UodbWS.GetGamertag(user.UserPuid);
                if(returnedGamertag != newGamerTag)
                    throw new UnexpectedTestResultException(String.Format("returned gamertag is {0}", returnedGamertag) );


                // validate that the gamertag changed
                VerifyResponse(user.UserPuid, user.Gamertag, newGamerTag, numChanges);

                // verify the gamertag is updated on the UPS side
                ValueCheck.Test("Gamertag in UPS", true, UpsUtilities.XeUpsGetProfile_VeirfyGamertag(user.PassportUserPuid, newGamerTag));

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(1)]
        public class P_FreeOffer_WM7User_First_NoBalance_FromXbox : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                byte[] ownerPassportToken; 

                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.Gamertag = UodbWS.GetGamertag(user.UserPuid);
                user.PassportUserPuid =  PassportUtilities.GetPuidFromSessionToken(ownerPassportToken);

                XRLXeOfferPurchaseGamertag request = new XRLXeOfferPurchaseGamertag();
                XRLXeOfferPurchaseGamertagResponse response = new XRLXeOfferPurchaseGamertagResponse();

                RandomEx rnd = new RandomEx();
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
            
                request.UserPuid = user.UserPuid;
                request.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points;
                request.Gamertag = newGamerTag;
                request.OfferID = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);
                request.Slot.titleId = XOn.XENON_DASH_TITLE_ID;

                int numChanges = UodbWS.GetGamerTagChanges(user.UserPuid).Length;

                Global.RO.Info("Changing user 0x" + user.UserPuid.ToString("X") + " gamertag from " + user.Gamertag + " to " + newGamerTag);
                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeOfferPurchaseGamertag failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseGamertag returned XErr=0x{0:x}", request.XErr));

                // validate t_users table
                string returnedGamertag = UodbWS.GetGamertag(user.UserPuid);
                if(returnedGamertag != newGamerTag)
                    throw new UnexpectedTestResultException(String.Format("returned gamertag is {0}", returnedGamertag) );

                // validate that the gamertag changed
                VerifyResponse(user.UserPuid, user.Gamertag, newGamerTag, numChanges);

                // verify the gamertag is updated on the UPS side
                ValueCheck.Test("Gamertag in UPS", true, UpsUtilities.XeUpsGetProfile_VeirfyGamertag(user.PassportUserPuid, newGamerTag));

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(1)]
        public class P_FreeOffer_WM7User_First_Balance : TestBase
        {
            protected override void Execute()
            {
                byte[] ownerPassportToken;
            
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                // Migrate 
                UacsCommon.MigrateWM7UserGeneral( ownerPassportToken) ;


                // Purchase Points
                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.CountryId = 103;
                user.MachinePuid = UacsCommon.RandomXenonMachineUid();

                XbosOffer.RewardUSUser1600Points(user);

                // Purchase Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                RandomEx rnd = new RandomEx();
                string gamertag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                Global.RO.Info("PurchaseGamertag returned {0}", hr);

                if (hr != HResult.S_OK) 
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertag returned {0}", hr) );

                // Check PointsBalance after
                uint points_balance_after = user.GetPointsBalance();
                if (points_balance_after != 1600) 
                    throw new UnexpectedTestResultException(String.Format("points_balance_after is not 500 but {0}", points_balance_after) );

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(1)]
        public class P_FreeOffer_WM7User_First_Balance_FromXbox : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                byte[] ownerPassportToken; 

                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.Gamertag = UodbWS.GetGamertag(user.UserPuid);
                user.PassportUserPuid =  PassportUtilities.GetPuidFromSessionToken(ownerPassportToken);

                // Migrate 
                UacsCommon.MigrateWM7UserGeneral( ownerPassportToken) ;


                // Purchase Points
                user.CountryId = 103;
                user.MachinePuid = UacsCommon.RandomXenonMachineUid();

                XbosOffer.RewardUSUser1600Points(user);

                // Purchase Gamertag
                XRLXeOfferPurchaseGamertag request = new XRLXeOfferPurchaseGamertag();
                XRLXeOfferPurchaseGamertagResponse response = new XRLXeOfferPurchaseGamertagResponse();

                RandomEx rnd = new RandomEx();
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
            
                request.UserPuid = user.UserPuid;
                request.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points;
                request.Gamertag = newGamerTag;
                request.Slot.titleId = XOn.XENON_DASH_TITLE_ID;
                request.OfferID = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);

                int numChanges = UodbWS.GetGamerTagChanges(user.UserPuid).Length;

                Global.RO.Info("Changing user 0x" + user.UserPuid.ToString("X") + " gamertag from " + user.Gamertag + " to " + newGamerTag);
                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeOfferPurchaseGamertag failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseGamertag returned XErr=0x{0:x}", request.XErr));

                // validate t_users table
                string returnedGamertag = UodbWS.GetGamertag(user.UserPuid);
                if(returnedGamertag != newGamerTag)
                    throw new UnexpectedTestResultException(String.Format("returned gamertag is {0}", returnedGamertag) );

                // validate that the gamertag changed
                VerifyResponse(user.UserPuid, user.Gamertag, newGamerTag, numChanges);

                // verify the gamertag is updated on the UPS side
                ValueCheck.Test("Gamertag in UPS", true, UpsUtilities.XeUpsGetProfile_VeirfyGamertag(user.PassportUserPuid, newGamerTag));

                // Check PointsBalance after
                uint points_balance_after = user.GetPointsBalance();
                if (points_balance_after != 1600) 
                    throw new UnexpectedTestResultException(String.Format("points_balance_after is not 500 but {0}", points_balance_after) );

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(1)]
        public class P_PaidOffer_WM7UserUsed_Second_Balance : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                byte[] ownerPassportToken; 

                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.Gamertag = UodbWS.GetGamertag(user.UserPuid);
                user.PassportUserPuid =  PassportUtilities.GetPuidFromSessionToken(ownerPassportToken);

                // Use free gamertag changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);


                // Migrate 
                UacsCommon.MigrateWM7UserGeneral( ownerPassportToken) ;


                // Purchase Points
                user.CountryId = 103;
                user.MachinePuid = UacsCommon.RandomXenonMachineUid();

                XbosOffer.RewardUSUser1600Points(user);


                // Purchase Paid Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange);


                RandomEx rnd = new RandomEx();
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", newGamerTag);
                string token = "";
                
                uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, paidOfferId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, newGamerTag, token);
                Global.RO.Info("PurchaseGamertag returned {0}", hr);

                if (hr != HResult.S_OK) 
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertag failed") );

                // validate t_users table
                string returnedGamertag = UodbWS.GetGamertag(user.UserPuid);
                if(returnedGamertag != newGamerTag)
                    throw new UnexpectedTestResultException(String.Format("returned gamertag is {0}", returnedGamertag) );

                // validate that the gamertag changed
                VerifyResponse(user.UserPuid, user.Gamertag, newGamerTag, 1);

                // verify the gamertag is updated on the UPS side
                ValueCheck.Test("Gamertag in UPS", true, UpsUtilities.XeUpsGetProfile_VeirfyGamertag(user.PassportUserPuid, newGamerTag));

                // Check PointsBalance after
                uint points_balance_after = user.GetPointsBalance();
                if (points_balance_after != 800) 
                    throw new UnexpectedTestResultException(String.Format("points_balance_after is not 200 but {0}", points_balance_after) );

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(1)]
        public class P_PaidOffer_WM7User_Second_Balance_FromXbox : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                byte[] ownerPassportToken; 

                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.Gamertag = UodbWS.GetGamertag(user.UserPuid);
                user.PassportUserPuid =  PassportUtilities.GetPuidFromSessionToken(ownerPassportToken);


                // Use free gamertag changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);


                // Migrate 
                UacsCommon.MigrateWM7UserGeneral( ownerPassportToken) ;


                // Purchase Points
                user.CountryId = 103;
                user.MachinePuid = UacsCommon.RandomXenonMachineUid();

                XbosOffer.RewardUSUser1600Points(user);


                XRLXeOfferPurchaseGamertag request = new XRLXeOfferPurchaseGamertag();
                XRLXeOfferPurchaseGamertagResponse response = new XRLXeOfferPurchaseGamertagResponse();

                RandomEx rnd = new RandomEx();
                string oldGamerTag = UodbWS.GetGamertag(user.UserPuid);
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
            
                request.UserPuid = user.UserPuid;
                request.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points;
                request.Gamertag = newGamerTag;
                request.Slot.titleId = XOn.XENON_DASH_TITLE_ID;

                int numChanges = UodbWS.GetGamerTagChanges(user.UserPuid).Length;

                Global.RO.Info("Changing user 0x" + user.UserPuid.ToString("X") + " gamertag from " + oldGamerTag + " to " + newGamerTag);
                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeOfferPurchaseGamertag failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseGamertag returned XErr=0x{0:x}", request.XErr));

                // validate t_users table
                string returnedGamertag = UodbWS.GetGamertag(user.UserPuid);
                if(returnedGamertag != newGamerTag)
                    throw new UnexpectedTestResultException(String.Format("returned gamertag is {0}", returnedGamertag) );

                // validate that the gamertag changed
                VerifyResponse(user.UserPuid, oldGamerTag, newGamerTag, numChanges);

                // verify the gamertag is updated on the UPS side
                ValueCheck.Test("Gamertag in UPS", true, UpsUtilities.XeUpsGetProfile_VeirfyGamertag(user.PassportUserPuid, newGamerTag));

                // Check PointsBalance after
                uint points_balance_after = user.GetPointsBalance();
                if (points_balance_after != 800) 
                    throw new UnexpectedTestResultException(String.Format("points_balance_after is not 200 but {0}", points_balance_after) );

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        


        [TestCase, TestCasePriority(2)]
        public class N_PaidOffer_WM7User_Fisrt_NoBalance : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Purchase Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange);


                RandomEx rnd = new RandomEx();
                string gamertag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, paidOfferId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                Global.RO.Info("PurchaseGamertag returned {0}", hr);

                if (hr == HResult.S_OK) 
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertag should fail") );

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        



        [TestCase, TestCasePriority(2)]
        public class N_PaidOffer_WM7User_Second_NoBalance : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Use free gamertag changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);


                // Purchase Paid Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange);


                RandomEx rnd = new RandomEx();
                string gamertag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, paidOfferId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                Global.RO.Info("PurchaseGamertag returned {0}", hr);

                if (hr == HResult.S_OK) 
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertag should fail") );

                // Make sure flag is reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == true)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag shouldn't be set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        


        [TestCase, TestCasePriority(2)]
        public class N_FreeOffer_WM7User_Second_NoBalance : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Use free gamertag changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);

                // Purchase Gamertag
                RandomEx rnd = new RandomEx();
                string gamertag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                

                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Info("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_USER_FREE_GAMERTAG_CHANGE_NOT_ELIGIBLE_ERROR
                    if(ee.ToString().Contains("801540A4"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x801540A4 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x801540A4");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        


        [TestCase, TestCasePriority(2)]
        public class N_FreeOffer_WM7User_Second_Balance : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                byte[] ownerPassportToken; 

                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Use free gamertag changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);

                // Migrate 
                UacsCommon.MigrateWM7UserGeneral( ownerPassportToken) ;


                // Purchase Points
                user.CountryId = 103;
                user.MachinePuid = UacsCommon.RandomXenonMachineUid();

                XbosOffer.RewardUSUser1600Points(user);



                // Purchase Gamertag
                RandomEx rnd = new RandomEx();
                string gamertag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Info("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_USER_FREE_GAMERTAG_CHANGE_NOT_ELIGIBLE_ERROR
                    if(ee.ToString().Contains("801540A4"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x801540A4 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x801540A4");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        


        [TestCase, TestCasePriority(2)]
        public class N_FreeOffer_NonWM7User : TestBase
        {
            protected override void Execute()
            {
                // Create non WM7 user
                XeUser user = new XeUser(false);
                ulong xuid = user.Create();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);


                // Purchase Gamertag
                RandomEx rnd = new RandomEx();
                string gamertag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Info("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_USER_FREE_GAMERTAG_CHANGE_NOT_ELIGIBLE_ERROR
                    if(ee.ToString().Contains("801540A4"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x801540A4 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x801540A4");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        


        [TestCase, TestCasePriority(2)]
        public class N_SameGamertag : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Purchase Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);

                RandomEx rnd = new RandomEx();
                string gamertag = UodbWS.GetUserProperty(xuid, "vc_gamertag") ;
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Error("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_NAME_TAKEN
                    if(ee.ToString().Contains("80154000"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x80154000 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x80154000");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                // Make sure flag is not reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == false)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag is not set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(2)]
        public class N_Gamertag_Already_Taken : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);


                XeUser user = new XeUser();
                user.UserPuid = xuid;


                // Purchase Gamertag
                string sqlCmd = String.Format("SELECT top 1 vc_gamertag FROM t_users");

                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);

                RandomEx rnd = new RandomEx();
                string gamertag = (string)UodbWS.ExecuteSQLScalar(sqlCmd, null);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Error("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_NAME_TAKEN
                    if(ee.ToString().Contains("80154000"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x80154000 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x80154000");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                // Make sure flag is not reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == false)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag is not set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        


        [TestCase, TestCasePriority(2)]
        public class N_Gamertag_Banned : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Purchase Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);

                RandomEx rnd = new RandomEx();
                string gamertag = "fuck";
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Error("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_NAME_TAKEN
                    if(ee.ToString().Contains("80154000"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x80154000 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x80154000");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertag should throw Exception") );
                }

                // Make sure flag is not reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == false)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag is not set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(2)]
        public class N_Gamertag_Null: TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Check PointsBalance before
                uint points_balance_before = user.GetPointsBalance();
                if (points_balance_before != 0) 
                    throw new UnexpectedTestResultException(String.Format("points_balance_before is not zero but {0}", points_balance_before) );

                // Purchase Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);

                RandomEx rnd = new RandomEx();
                string gamertag = null;
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Error("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_NAME_TAKEN
                    if(ee.ToString().Contains("80154000"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x80154000 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x80154000");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                // Make sure flag is not reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == false)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag is not set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(2)]
        public class N_Gamertag_Empty: TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;

                // Check PointsBalance before
                uint points_balance_before = user.GetPointsBalance();
                if (points_balance_before != 0) 
                    throw new UnexpectedTestResultException(String.Format("points_balance_before is not zero but {0}", points_balance_before) );

                // Purchase Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);

                RandomEx rnd = new RandomEx();
                string gamertag = "";
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Error("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_NAME_TAKEN
                    if(ee.ToString().Contains("80154000"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x80154000 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x80154000");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                // Make sure flag is not reset
                bool bFlag = UacsCommon.IsFreeGamerEligibleFlagSet(xuid);
                if(bFlag == false)
                    throw new UnexpectedTestResultException(String.Format("FreeGamerEligibleFlag is not set") );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(2)]
        public class N_Invalid_Xuid: TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = 0x1234;
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);


                XeUser user = new XeUser();
                user.UserPuid = xuid;


                // Purchase Gamertag
                //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);

                RandomEx rnd = new RandomEx();
                string gamertag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", gamertag);
                string token = "";
                
                bool bException = false;
                try
                {
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);
                    Global.RO.Error("PurchaseGamertag returned {0}", hr);
                }
                catch (Exception ee)
                {
                    bException = true;
                    Global.RO.Info("PurchaseGamertag threw exception: " + ee.ToString());
                    // XONLINE_E_ACCOUNTS_INVALID_USER
                    if(ee.ToString().Contains("80154002"))
                    {
                        Global.RO.Info("PurchaseGamertag got exception with 0x80154002 as expected");
                    }
                    else
                    {
                        Global.RO.Warn("PurchaseGamertag got exception but error code is not 0x80154002");
                    }
                }


                if(bException == false)
                {
                    throw new UnexpectedTestResultException(String.Format("PurchaseGamertagshould throw Exception") );
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }        

        [TestCase, TestCasePriority(2)]
        public class N_AA_Mismatch : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                byte[] ownerPassportToken; 

                ulong xuid = UacsCommon.CreateMobileAccountGeneral(out ownerPassportToken);
                ulong machinePuid = UacsCommon.CreateWM7MachineUid();

                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, machinePuid, UacsCommon.WM_TitleId);

                XeUser user = new XeUser();
                user.UserPuid = xuid;
                user.Gamertag = UodbWS.GetGamertag(user.UserPuid);
                user.PassportUserPuid =  PassportUtilities.GetPuidFromSessionToken(ownerPassportToken);


                RandomEx rnd = new RandomEx();
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
                Global.RO.Info("New gamertag will be {0}", newGamerTag);
                string token = "";
                
                // GenerateGamertag
                ResultCode = TEST_RESULTS.FAILED;
                try{
                    uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid+1, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, newGamerTag, token);
                    Global.RO.Info("PurchaseGamertag returned {0}", hr);
                }
                catch(Exception e){
                    Global.RO.Info("PurchaseGamertag got exception {0}", e.ToString());
                    ResultCode = TEST_RESULTS.PASSED;
                }

                if(ResultCode == TEST_RESULTS.FAILED)
                {
                    throw new UnexpectedTestResultException(String.Format("AA_Mismatch should fail") );
                }



                ResultCode = TEST_RESULTS.PASSED;
            }
        }        


        public static void VerifyResponse(ulong userPuid, string oldGamertag, string newGamertag, int numChanges)
        {
            GamerTagChange[] changes = UodbWS.GetGamerTagChanges(userPuid);

            ValueCheck.Test("Gamertag change history records", 1, changes.Length - numChanges);
            ValueCheck.Test("Old gamertag value recorded", oldGamertag, changes[0].OldGamerTag);
            ValueCheck.Test("New gamertag value recorded", newGamertag, changes[0].NewGamerTag);
            ValueCheck.Test("WasPurchased value recorder", true, changes[0].WasPurchased);
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\test\dvt\FakeXArbNet.cs ===
using System;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;
using xonline.common.diagnostics;
using xonline.server.arbitration.test.unit;

namespace xonline.server.arbitration.inh
{
    public class BundleSubmitter
    {
        public static void Submit( uint titleID, byte[] statsBundle, string statsURL, byte[] tournamentBundle, string tournamentURL, BundledAuthData bundledAuthData, TeamTickets teamTickets )
        {
            ArbSessionTest.Submit(statsBundle, tournamentBundle, bundledAuthData, teamTickets);
        }
        
    }
    
    public class ArbNetUtil
    {
        public static Uri GetCurrentUrl()
        {
            string[] inhServers = Config.GetServerListByInterface(Interface.xarbInh);
            Assert.IsTrue(inhServers.Length > 0);
            
            IInterfaceInfo ifaceInfo = Config.GetInterface(inhServers[0], Interface.xarbInh);
            return ifaceInfo.Url;
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\inh\XArbSession.cs ===
using System;
using System.IO;
using System.Text;
using System.Web;
using System.Threading;
using System.Collections;
using System.Diagnostics;
using System.Net;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

using xonline.common.config;


[assembly: XomAreaDefinition(XomAreaName.xarblog)]

namespace xonline.server.arbitration.inh
{

    public class SessionManager
    {
        public enum MigrationState
        {
            NotPlanned = 0,
            Planned    = 1,
            Started    = 2,
            Completed  = 3
        }

        private const int InitialConcurrentSessions = 1000;


        static Hashtable Sessions = new Hashtable(InitialConcurrentSessions);
        public static ulong[] SessionBucketCount;
        public static MigrationState [] m_arrSessionBucketMigrationFlag; //0 = Not Planned, 1 = Planned, 2 = Started, 3 = Completed
        public static IPHostEntry m_ipCurrentHost;

        static SessionManager()
        {
            SessionBucketCount = new ulong[Config.GetBucketCount(Interface.xarbInh)];
            m_arrSessionBucketMigrationFlag = new MigrationState[SessionBucketCount.Length];
            for (int i = 0; i < SessionBucketCount.Length; i++)
            {
                SessionBucketCount[i] = 0;
                m_arrSessionBucketMigrationFlag[i] = MigrationState.NotPlanned;
            }

            string szHost   = Dns.GetHostName();
            m_ipCurrentHost = Dns.GetHostEntry(szHost);
        }

        public static void VerifyAndSetIsInMigration(BucketInfo bucketNew, BucketInfo bucketOld, uint bucketId )
        {
            lock (typeof(SessionManager))
            {
                if (IsIpMine(bucketNew.m_ipCurrentHost))
                {
                    if (bucketNew.m_szCurrentServerName != bucketNew.m_szNextServerName)
                    {
                        if (m_arrSessionBucketMigrationFlag[bucketId] == MigrationState.NotPlanned)
                        {
                            m_arrSessionBucketMigrationFlag[bucketId] = MigrationState.Planned; // migration planned detected
                            Xom.NtEvent(XEvent.Id.ARBITRATION_INFO_1, "Migration Planned but not started yet BucketID {0} From {1} to {2} - At {3}", bucketId, bucketNew.m_szCurrentServerName, bucketNew.m_szNextServerName, bucketNew.m_NextServerStartTime);

                            CheckAndStartMigrationForBucket(bucketId, bucketNew); //check if we can start now using the new bucket
                        }
                    }
                }

                if (IsIpMine(bucketOld.m_ipCurrentHost))
                {
                    if (bucketNew.m_szCurrentServerName == bucketNew.m_szNextServerName)
                    {
                        if (m_arrSessionBucketMigrationFlag[bucketId] == MigrationState.Completed)
                        {
                            m_arrSessionBucketMigrationFlag[bucketId] = MigrationState.NotPlanned; //reset it back to initial state
                        }
                    }
                }
            }
        }

        /*
            This function has to be light weight in order not to delay startup. SgInfo is not fully initialized yet.
            We initialize migration state to planned so that on the first request to this bucket,
            we will correct our migration state to either started/completed/or leave it to planned if it is still in the future
        */
        public static void RecordMigrationPlannedOnStartup(IBucketServer bucketServer, uint bucketId)
        {
            lock (typeof(SessionManager))
            {
                if (IsIpMine(bucketServer.CurrentServer.IPAddress))
                {
                    if (bucketServer.CurrentServerName != bucketServer.NextServerName)
                    {
                        m_arrSessionBucketMigrationFlag[bucketId] = MigrationState.Planned;
                    }
                }
            }
        }

        public static bool IsIpMine(IPAddress ip)
        {
            if (m_ipCurrentHost != null)
            {
                foreach (IPAddress myip in m_ipCurrentHost.AddressList)
                {
                    if (myip.Equals(ip))
                        return true;
                }
            }

            return false;
        }

        public static ArbitratedSession FindOrCreateSession(byte[] TitleIDSessionIDAndNonce)
        {
            lock (typeof(SessionManager))
            {
                ArbitratedSession s = FindSession(TitleIDSessionIDAndNonce);

                if (s == null)
                {
                    // make sure the session belongs on this server..
                    ulong sessionId = BitConverter.ToUInt64(TitleIDSessionIDAndNonce, 4);
                    uint bucketId   = Config.GetBucketNum(Interface.xarbInh, sessionId);
                    IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, bucketId);
                    Uri requestUrl = ArbNetUtil.GetCurrentUrl();

                    if (CheckAndStartMigrationForBucket(bucketId))
                    {
                        return null; //migration has started
                    }

                    if (bucket.CurrentServerName == bucket.NextServerName &&
                        bucket.CurrentServer.IPAddressString != requestUrl.Host)
                    {
                        /*
                            2 possibilities:

                            1) Migration is complete BUT the session does not belong to me
                               This must mean the FD does not have the config setting changed yet. Keep on acting like we are in migration

                            2) Migration just started, current server have not detected the settings yet even after waiting for arb_migration_wait_window (This is a failure case)
                                - Extremely edge case (should indicate a problem with config refresh)
                        */

                        return null;
                    }


                    s = new ArbitratedSession(TitleIDSessionIDAndNonce);
                    Sessions.Add(new ByteArray(TitleIDSessionIDAndNonce), s);
                    XArbitrationServerCounters.Counters.ActiveSessions.RawValue = Sessions.Count;

                    SessionBucketCount[bucketId]++;
                    XArbitrationBucketCounters.Current(bucketId.ToString()).ActiveSessions.RawValue = (long)SessionBucketCount[bucketId];

                }

                return s;
            }
        }

        private static void CompleteMigrationForBucket(uint bucketID)
        {
            lock (typeof(SessionManager))
            {
                Debug.Assert(SessionBucketCount[bucketID] == 0);
                Debug.Assert(m_arrSessionBucketMigrationFlag[bucketID] != MigrationState.NotPlanned);

                m_arrSessionBucketMigrationFlag[bucketID] = MigrationState.Completed;

                Config.CompleteTitleMigration(Interface.xarbInh, 0, bucketID);
                Xom.NtEvent(XEvent.Id.ARBITRATION_INFO_2, "Migration Completed: Bucket {0}", bucketID);
            }
        }

        private static bool CheckAndStartMigrationForBucket(uint bucketId)
        {
            return CheckAndStartMigrationForBucket(bucketId, null);
        }

        //returns true if and only if migration started
        private static bool CheckAndStartMigrationForBucket(uint bucketId, BucketInfo bucket)
        {
            bool bMigrationStarted = false;

            switch (m_arrSessionBucketMigrationFlag[bucketId])
            {
                case MigrationState.Started:
                    bMigrationStarted = true;
                    break;

                case MigrationState.NotPlanned:
                    bMigrationStarted = false;
                    break;

                case MigrationState.Completed:
                    bMigrationStarted = true; //although it is complete, it was started
                    break;

                case MigrationState.Planned:
                    DateTime dtNextServerStart = DateTime.Now;
                    string   szServerFrom      = null;
                    string   szServerTo        = null;

                    if (null == bucket)
                    {
                        IBucketServer bucketFromConfig = Config.GetBucketServer(Interface.xarbInh, bucketId);
                        dtNextServerStart = bucketFromConfig.NextServerStart;
                        szServerFrom      = bucketFromConfig.CurrentServerName;
                        szServerTo        = bucketFromConfig.NextServerName;
                    }
                    else
                    {
                        dtNextServerStart = bucket.m_NextServerStartTime;
                        szServerFrom      = bucket.m_szCurrentServerName;
                        szServerTo        = bucket.m_szNextServerName;
                    }

                    if (dtNextServerStart.AddMinutes(MigrationWaitWindowMinutes) < DateTime.UtcNow)
                    {
                        m_arrSessionBucketMigrationFlag[bucketId] = MigrationState.Started;
                        bMigrationStarted = true;
                        Xom.NtEvent(XEvent.Id.ARBITRATION_INFO_3, "Migration Started BucketID {0} From {1} to {2} - Session Remaining {3}", bucketId, szServerFrom, szServerTo, SessionBucketCount[bucketId]);

                        if (SessionBucketCount[bucketId] == 0)
                        {
                            CompleteMigrationForBucket(bucketId); //can't rely on delete Session being called
                        }
                     }
                     else
                     {
                        bMigrationStarted =  false; //is not in migration window yet
                     }
                     break;

                 default:
                    bMigrationStarted = false;
                    break;
            }

            return bMigrationStarted;
        }

        public static ArbitratedSession FindSession(byte[] TitleIDSessionIDAndNonce)
        {
            lock (typeof(SessionManager))
            {
                ulong sessionId  = BitConverter.ToUInt64(TitleIDSessionIDAndNonce, 4);
                uint  bucketId   = Config.GetBucketNum(Interface.xarbInh, sessionId);
                CheckAndStartMigrationForBucket(bucketId);

                return (ArbitratedSession)Sessions[new ByteArray(TitleIDSessionIDAndNonce)];
            }
        }

        public static void DeleteSession(byte[] TitleIDSessionIDAndNonce)
        {
            lock (typeof(SessionManager))
            {
                ArbitratedSession session = FindSession(TitleIDSessionIDAndNonce);
                if (session != null)
                {
                    session.DecrementCounters();
                    Sessions.Remove(new ByteArray(TitleIDSessionIDAndNonce));
                    XArbitrationServerCounters.Counters.ActiveSessions.RawValue = Sessions.Count;

                    ulong sessionId = BitConverter.ToUInt64(TitleIDSessionIDAndNonce, 4);
                    uint bucketId = Config.GetBucketNum(Interface.xarbInh, sessionId);

                    SessionBucketCount[bucketId]--;

                    if (m_arrSessionBucketMigrationFlag[bucketId] == MigrationState.Started)
                    {
                        if (SessionBucketCount[bucketId] == 0)
                        {
                            CompleteMigrationForBucket(bucketId);
                        }
                    }
                    else
                    {
                        CheckAndStartMigrationForBucket(bucketId);
                    }

                    XArbitrationBucketCounters.Current(bucketId.ToString()).ActiveSessions.RawValue = (long)SessionBucketCount[bucketId];
                }
            }
        }

        private static int MigrationWaitWindowMinutes
        {
            get { return Config.GetIntSetting(Setting.xarb_MigrationWaitWindowMinutes); }
        }

    }

    public class ArbitratedSession
    {
        public enum SessionOutcome { Undetermined, Successful, Minority, Failed, Problematic, UDPReport }

        static ArbitratedSession()
        {
            try
            {
                if (EnableDebugResult)
                {
                  Xom.NtEvent( XEvent.Id.ARBITRATION_CONFIGURATION_ERROR_6,
                        "EnableDebugResult is true! This is only allowed in TestNet. This should NEVER happen in production!" );
                }
            }

            catch (Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.ARBITRATION_CONFIGURATION_ERROR_7, "Error initializing ArbitratedSession", e );
            }
        }

        private static int MaxSessionSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_MaxSessionSeconds); }
        }
        private static int SessionTimeoutExtensionSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_SessionTimeoutExtensionSeconds); }
        }
        private static int TrailingReportRetriesWaitSeconds
        {
            get { return Config.GetIntSetting(Setting.xarb_TrailingReportRetriesWaitSeconds); }
        }
        private static int MaxStatsBundleSize
        {
            get { return Config.GetIntSetting(Setting.xarb_MaxStatsBundleSize); }
        }
        private static int MaxTournamentBundleSize
        {
            get { return Config.GetIntSetting(Setting.xarb_MaxTournamentBundleSize); }
        }
        private static bool VerboseLogging
        {
            get { return Config.GetBoolSetting(Setting.xarb_VerboseLogging); }
        }
        private static bool EnableDebugResult
        {
            get { return Config.GetBoolSetting(Setting.xarb_EnableDebugResult); }
        }

        private const int DefaultNumberOfXboxesInSession = 16;

        private const int XONLINE_MAX_LOGON_USERS = 4;
        private const double MajorityQuorum = 0.5;

        private const ushort SESSION_IS_TOURNAMEMT = 0x0001;
        private const ushort SESSION_CAN_EXTEND_TIME = 0x0002;
        private const ushort SESSION_USES_SESSION_HOST = 0x0004;
        private const ushort SESSION_FOR_TEAMS = 0x0008;
        private const ushort SESSION_IS_FFA = 0x0010;
        private const ushort SESSION_IS_PUBLISHER_TOURNAMENT = 0x0020;

        // Flags for reporting
        private const ushort SESSION_I_VOLUNTARILY_QUIT = 0x8000;
        private const ushort SESSION_I_WAS_HOST = 0x4000;
        private const ushort SESSION_LOST_CONNECTIVITY = 0x2000;
        private const ushort SESSION_LOST_CONNECTIVITY_SUBMITTED = 0x1000;
        private const ushort SESSION_TYPE_1_SUSPICIOUS_INFO_SUBMITTED = 0x0800;
        private const ushort SESSION_TYPE_2_SUSPICIOUS_INFO_SUBMITTED = 0x0400;
        private const ushort SESSION_TYPE_3_SUSPICIOUS_INFO_SUBMITTED = 0x0200;
        private const ushort SESSION_STATS_BUNDLE_SUBMITTED = 0x0100;
        private const ushort SESSION_TOURNAMENT_BUNDLE_SUBMITTED = 0x0080;

        // This is a private flag used within the server. The client doesn't actually set this bit.
        private const ushort SESSION_REPORT_IN_UDP = 0x0001;

        public static bool IsTournament( ushort flags )
        {
            return ((flags & SESSION_IS_TOURNAMEMT) != 0);
        }

        public static bool CanExtendTime( ushort flags )
        {
            return ((flags & SESSION_CAN_EXTEND_TIME) != 0);
        }

        public static bool UsesSessionHost( ushort flags )
        {
            return ((flags & SESSION_USES_SESSION_HOST) != 0);
        }

        public static bool ForTeams( ushort flags )
        {
            return ((flags & SESSION_FOR_TEAMS) != 0);
        }

        public static bool IsFFA( ushort flags )
        {
            return ((flags & SESSION_IS_FFA) != 0);
        }

        public static bool IsPublisherTournament( ushort flags )
        {
            return ((flags & SESSION_IS_PUBLISHER_TOURNAMENT) != 0);
        }

        public static ushort RegisterFlags( ushort flags )
        {
            return (ushort)(flags & (SESSION_IS_TOURNAMEMT | SESSION_CAN_EXTEND_TIME | SESSION_USES_SESSION_HOST | SESSION_FOR_TEAMS | SESSION_IS_FFA | SESSION_IS_PUBLISHER_TOURNAMENT));
        }

        public static ushort TimeExtendFlags( ushort flags )
        {
            return (ushort)(flags & 0);
        }

        public static bool IVoluntarilyQuit( ushort flags )
        {
            return ((flags & SESSION_I_VOLUNTARILY_QUIT) != 0);
        }

        public static bool IWasHost( ushort flags )
        {
            return ((flags & SESSION_I_WAS_HOST) != 0);
        }

        public static bool LostConnectivitySubmitted( ushort flags )
        {
            return ((flags & SESSION_LOST_CONNECTIVITY_SUBMITTED) != 0);
        }

        public static bool Type1SuspiciousInfoSubmitted( ushort flags )
        {
            return ((flags & SESSION_TYPE_1_SUSPICIOUS_INFO_SUBMITTED) != 0);
        }

        public static bool Type2SuspiciousInfoSubmitted( ushort flags )
        {
            return ((flags & SESSION_TYPE_2_SUSPICIOUS_INFO_SUBMITTED) != 0);
        }

        public static bool Type3SuspiciousInfoSubmitted( ushort flags )
        {
            return ((flags & SESSION_TYPE_3_SUSPICIOUS_INFO_SUBMITTED) != 0);
        }

        public static bool StatsBundleSubmitted( ushort flags )
        {
            return ((flags & SESSION_STATS_BUNDLE_SUBMITTED) != 0);
        }

        public static bool TournamentBundleSubmitted( ushort flags )
        {
            return ((flags & SESSION_TOURNAMENT_BUNDLE_SUBMITTED) != 0);
        }

        public static bool ReportInUDP( ushort flags )
        {
            return ((flags & SESSION_REPORT_IN_UDP) != 0);
        }

        public static ushort SetReportInUDP( ushort flags )
        {
            return (ushort)(flags | SESSION_REPORT_IN_UDP);
        }

        public static ushort ReportFlags( ushort flags )
        {
            return (ushort)(flags & (ushort)(SESSION_I_VOLUNTARILY_QUIT | SESSION_I_WAS_HOST | SESSION_LOST_CONNECTIVITY | SESSION_LOST_CONNECTIVITY_SUBMITTED | SESSION_TYPE_1_SUSPICIOUS_INFO_SUBMITTED | SESSION_TYPE_2_SUSPICIOUS_INFO_SUBMITTED | SESSION_TYPE_3_SUSPICIOUS_INFO_SUBMITTED | SESSION_STATS_BUNDLE_SUBMITTED | SESSION_TOURNAMENT_BUNDLE_SUBMITTED | SESSION_REPORT_IN_UDP));
        }

        public static double Fermi( double x, double k )
        {
            return 1 / (1 + Math.Exp( (-x) / k ));
        }

        public struct AuthData
        {
            public AuthData(uint TitleID, TitleParameters titleParameters)
            {
                if( AuthToggle.On )
                {
                    SGInfo.VerifyServiceId(XOService.Arbitration);

                    SGInfo sg = SGInfo.Current;

                    if (sg.TitleId != TitleID)
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_HACKER_ALERT, "Title ID mismatch, should be: " + TitleID.ToString("X") + "\r\n" );
                    }

                    xboxID = sg.MachineId;
                    XUIDAndTrust[] sgUsers = sg.LogonUsers;

                    int ct = 0;
                    int i;
                    for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
                    {
                        if (sgUsers[i].qwUserID != 0 && !sgUsers[i].IsGuest())
                        {
                            ct++;
                        }
                    }

                    // Now we know the number of users on box, allocate array of ID and compute trust
                    // Xbox Trust is computed by average trust of all users present on box
                    users = new XUIDAndTrust[ct];
                    ct = 0;
                    trust = 0.0;
                    for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
                    {
                        if (sgUsers[i].qwUserID != 0 && !sgUsers[i].IsGuest())
                        {
                            users[ct] = sgUsers[i];
                            trust += titleParameters.BaseTrust + Fermi( (double)users[ct].userTrust, titleParameters.FermiK );
                            ct++;
                        }
                    }
                    trust /= ct;

                }
                else
                {
                    throw new XRLException(HResult.XONLINE_E_ARBITRATION_SERVICE_UNAVAILABLE, XEvent.Id.ARBITRATION_INTERNAL_FATAL_ERROR_2, "AuthToggle must be on in ini file!\r\n" );
                }
            }

            public readonly ulong xboxID;
            public XUIDAndTrust[] users;
            public readonly double trust;
        }

        public class Bundle
        {
            public Bundle(int paramIndex, double trust, byte[] paramStats, byte[] paramTournament)
            {
                index = paramIndex;
                count = 1;
                totalTrust = trust;
                stats = paramStats;
                tournament = paramTournament;
            }

            public bool BundleMatch(double trust, byte[] paramStats, byte[] paramTournament)
            {
                if (ByteArray.EqualOrBothNull(paramStats,stats) && ByteArray.EqualOrBothNull(paramTournament,tournament))
                {
                    count++;
                    totalTrust += trust;
                    return true;
                }
                return false;
            }

            public readonly int index;
            public uint count;
            public double totalTrust;
            public byte[] stats;
            public byte[] tournament;
        }


        public class XboxInfo
        {
            public XboxInfo(AuthData authData)
            {
                xboxID = authData.xboxID;
                users = authData.users;
                trust = authData.trust;
                hr = HResult.S_OK;
                timeExtendCount = 0;
                reportCount = 0;
                bundle = null;
            }

            public byte timeExtendCount;
            public byte reportCount;
            public ushort reportFlags;
            public HResult hr;
            public readonly ulong xboxID;
            public XUIDAndTrust[] users;
            public readonly double trust;
            public byte normalizedTrust;
            public Bundle bundle;
            public ulong[] diconnectedXboxes;
        }

        private uint _titleID;
        private ulong _sessionID;
        private ulong _sessionNonce;
        private TitleParameters _titleParameters;
        private ushort _flags;
        private ushort _maxSessionSeconds;
        private DateTime _startTime;
        private DateTime _timeoutTime;
        private double _sessionSeconds;
        private Timer _timer;

        // Counters used to keep track of what we incremented into performance counters
        private uint _xboxCount;
        private uint _userCount;

        // Sorted array of all PUIDs in this session
        private ulong[] _xboxPUIDs;
        private ulong[] _userPUIDs;

        // The Xboxes that actually registered (XboxInfo)
        private ArrayList _xboxes; // Type XboxInfo

        private BundledAuthData _bundledAuthData;

        // The Team Tickets for everybody that registered (TeamTicket)
        private ArrayList _teamTicketList; // Type TeamTicket
        private TeamTickets _teamTickets;

        private double _totalTrust;
        private uint _reportCount;
        private bool _arbitrated;

        // Arbitrated result
        private SessionOutcome _result;
        private SessionOutcome _nonProblematicResult;
        private float _trustModificationScale;

        // The different bundles submitted so far for this session
        private ArrayList _bundles; // Type Bundle
        private Bundle _submittedBundle;

        // AlternateDestination: For TestNet only
        private string _alternateStatsDestination = null;
        private string _alternateQueryDestination = null;

        public void SetAlternateStatsDestination(string alternateStatsDestination)
        {
            _alternateStatsDestination = alternateStatsDestination;
        }

        public void SetAlternateQueryDestination(string alternateQueryDestination)
        {
            _alternateQueryDestination = alternateQueryDestination;
        }

        // Suspicious info submitted by game title
        public struct SuspiciousInfo
        {
            public SuspiciousInfo( string paramMessage )
            {
                int i;
                char[] messageChars = paramMessage.ToCharArray();
                for (i=0; i<messageChars.Length; ++i)
                {
                    if (messageChars[i].Equals('|'))
                    {
                        messageChars[i] = '?';
                    }
                    else
                    {
                        if (!char.IsLetterOrDigit(messageChars[i]) &&
                            !char.IsPunctuation(messageChars[i]) &&
                            !char.IsSeparator(messageChars[i]) &&
                            !messageChars[i].Equals(' '))
                        {
                            messageChars[i] = '?';
                        }
                    }
                }
                message = new string(messageChars);
                xboxes = null;
                users = null;
            }

            public readonly string message;
            public ulong[] xboxes;
            public ulong[] users;
        }

        // 3 types of suspicious info
        private ArrayList[] _suspiciousInfo;

        public ArbitratedSession(byte[] TitleIDSessionIDAndNonce)
        {
            BinaryReader reader = new BinaryReader(new MemoryStream(TitleIDSessionIDAndNonce));
            _titleID = reader.ReadUInt32();
            _sessionID = reader.ReadUInt64();
            _sessionNonce = reader.ReadUInt64();
            _startTime = DateTime.Now;
            _sessionSeconds = 0.0;
            _timer = null;
            _xboxes = null;
            _teamTickets = null;
            _bundledAuthData = null;
            _submittedBundle = null;
            _arbitrated = false;
            _xboxCount = 0;
            _userCount = 0;
            _xboxPUIDs = null;
            _userPUIDs = null;

            _titleParameters = TitleParameterManager.Lookup(_titleID);
            _timeoutTime = DateTime.Now.AddSeconds(_maxSessionSeconds + SessionTimeoutExtensionSeconds);
            _timer = new System.Threading.Timer(new TimerCallback(SessionTimedOut), this, (_maxSessionSeconds + SessionTimeoutExtensionSeconds) * 1000, Timeout.Infinite);
        }

        public void DecrementCounters()
        {
            XArbitrationServerCounters.Counters.ActiveXboxes.IncrementBy(-_xboxCount);
            _xboxCount = 0;

            XArbitrationServerCounters.Counters.ActiveUsers.IncrementBy(-_userCount);
            _userCount = 0;
        }

        public byte[] Register(ushort flags, BinaryReader reader)
        {
            HResult         hr = HResult.E_FAIL;
            AuthData        authData = new AuthData(_titleID, _titleParameters);
            MemoryStream    responseMemStream = new MemoryStream(256);

            try
            {
                lock (this)
                {
                    int i,j;

                    if (_reportCount > 0)
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_REGISTRATION_TOO_LATE, XEvent.Id.ARBITRATION_HACKER_ALERT_1, "Session can't be registered after somebody has submitted results\r\n" );
                    }

                    if (_xboxes == null)
                    {
                        // First person to register, let's create the session
                        if (flags != RegisterFlags(flags))
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS, XEvent.Id.ARBITRATION_HACKER_ALERT_2, "Invalid register flags submitted:"+flags.ToString("X")+"\r\n" );
                        }

                        if (IsPublisherTournament(flags) && !IsTournament(flags))
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS, XEvent.Id.ARBITRATION_HACKER_ALERT_3, "IsTournament and IsPublisherTournament flags inconsistent\r\n" );
                        }

                        _flags = flags;
                        _maxSessionSeconds = reader.ReadUInt16();

                        if (_maxSessionSeconds > MaxSessionSeconds)
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_9, "MaxSessionSeconds specified > MaxSessionSeconds allowed: "+_maxSessionSeconds+">"+MaxSessionSeconds+"\r\n" );
                        }

                        _xboxes = new ArrayList(DefaultNumberOfXboxesInSession);
                        _bundles = new ArrayList(1);
                        if (ForTeams(_flags))
                        {
                            _teamTicketList = new ArrayList(DefaultNumberOfXboxesInSession);
                        }

                        _suspiciousInfo = new ArrayList[3];

                        _timeoutTime = DateTime.Now.AddSeconds(_maxSessionSeconds + SessionTimeoutExtensionSeconds);
                        _timer.Change((_maxSessionSeconds + SessionTimeoutExtensionSeconds) * 1000, Timeout.Infinite);
                    }
                    else
                    {
                        // For remaining participants, let's just verify the session data matches first one.
                        if (flags != _flags)
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_REGISTRATION_FLAGS_MISMATCH, XEvent.Id.ARBITRATION_HACKER_ALERT_4, "Registration flags mismatch: "+flags.ToString("X")+"!="+_flags.ToString("X")+"\r\n" );
                        }
                        ushort sessionTime = reader.ReadUInt16();
                        if (sessionTime != _maxSessionSeconds)
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_REGISTRATION_SESSION_TIME_MISMATCH, XEvent.Id.ARBITRATION_HACKER_ALERT_5, "Registration session seconds mismatch: " + sessionTime + ", expected: " + _maxSessionSeconds + "\r\n" );
                        }

                        _timeoutTime = DateTime.Now.AddSeconds(_maxSessionSeconds + SessionTimeoutExtensionSeconds);
                        _timer.Change((_maxSessionSeconds + SessionTimeoutExtensionSeconds) * 1000, Timeout.Infinite);
                    }

                    // Read team tickets if present
                    if (ForTeams(_flags))
                    {
                        TeamTickets teamTickets = new TeamTickets(reader);
                        for (i=0; i<teamTickets.teamTickets.Length; ++i)
                        {
                            TeamTicket t = teamTickets.teamTickets[i];
                            for (j=0; j<authData.users.Length; ++j)
                            {
                                if (t.userID == authData.users[j].qwUserID)
                                {
                                    break;
                                }
                            }
                            if (j == authData.users.Length)
                            {
                                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_TEAMTICKET, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_10, "Team ticket for user that is not logged on is present: " + t.userID.ToString("X") + "\r\n");
                            }
                            t.VerifyTicket();
                            t.ClearSignature();
                            _teamTicketList.Add(t);
                        }
                    }

                    // There should be no data left
                    if (reader.Read() != -1)
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_11, "Extra bytes at the end of Register request\r\n");
                    }

                    int xboxIndex = FindXbox(authData.xboxID);

                    if (xboxIndex == -1)
                    {
                        if (_xboxes.Count >= 255)
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_TOO_MANY_XBOXES_IN_SESSION, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_12, "Too many Xboxes have Registered for this session\r\n");
                        }

                        XboxInfo xboxInfo = new XboxInfo(authData);

                        xboxInfo.normalizedTrust = (byte) ((xboxInfo.trust - _titleParameters.BaseTrust) * 256);

                        _xboxes.Add(xboxInfo);
                        _totalTrust += authData.trust;

                        ++_xboxCount;
                        XArbitrationServerCounters.Counters.ActiveXboxes.Increment();

                        _userCount += (uint)xboxInfo.users.Length;
                        XArbitrationServerCounters.Counters.ActiveUsers.IncrementBy(xboxInfo.users.Length);
                    }

                    // Compute minimal trust so far
                    byte minSoFar = 255;
                    for (i=0; i<_xboxes.Count; ++i)
                    {
                        if (((XboxInfo)_xboxes[i]).normalizedTrust < minSoFar)
                        {
                            minSoFar = ((XboxInfo)_xboxes[i]).normalizedTrust;
                        }
                    }

                    BinaryWriter writer = new BinaryWriter(responseMemStream);

                    writer.Write((ushort)_xboxes.Count);
                    for (i=0; i<_xboxes.Count; ++i)
                    {
                        XboxInfo xboxInfo = ((XboxInfo)_xboxes[i]);

                        writer.Write(xboxInfo.xboxID);
                        writer.Write((byte) (xboxInfo.normalizedTrust - minSoFar) );
                        writer.Write((byte) (xboxInfo.users.Length) );
                        for (j=0; j<xboxInfo.users.Length; ++j)
                        {
                            writer.Write(xboxInfo.users[j].qwUserID);
                            writer.Write(xboxInfo.users[j].dwUserFlags);
                        }
                    }

                    responseMemStream.Close();

                    hr = HResult.S_OK;
                }
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.xarblog, "REG|"
                    + hr + "|"
                    + _titleID.ToString("X") + "|"
                    + _sessionID.ToString("X") + "|"
                    + _sessionNonce.ToString("X") + "|"
                    + _flags.ToString("X") + "|"
                    + (ulong)((DateTime.Now - _startTime).TotalSeconds) + "|"
                    + _maxSessionSeconds + "|"
                    + ((_xboxes == null) ? "0" : _xboxes.Count.ToString()) + "|"
                    + (_teamTicketList == null ? "0" : _teamTicketList.Count.ToString())
                    );
            }

            return responseMemStream.ToArray();
        }

        public void TimeExtend(ushort flags, BinaryReader reader)
        {
            HResult         hr = HResult.E_FAIL;
            AuthData        authData = new AuthData(_titleID, _titleParameters);
            int             xboxIndex = 0;
            ushort          MaxSessionSecondsFromNow = 0;

            try
            {
                lock (this)
                {
                    xboxIndex = FindXbox(authData.xboxID);

                    if (xboxIndex == -1)
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_NEED_TO_REGISTER_FIRST, XEvent.Id.ARBITRATION_HACKER_ALERT_6, "TimeExtend called without registration\r\n" );
                    }
                    else
                    {
                        ((XboxInfo)_xboxes[xboxIndex]).timeExtendCount++;
                    }

                    if (flags != TimeExtendFlags(flags))
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS, XEvent.Id.ARBITRATION_HACKER_ALERT_7, "Invalid time extend flags submitted:"+flags.ToString("X")+"\r\n" );
                    }

                    MaxSessionSecondsFromNow = reader.ReadUInt16();

                    if (MaxSessionSecondsFromNow > MaxSessionSeconds)
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_13, "MaxSessionSecondsFromNow specified > MaxSessionSeconds allowed: "+MaxSessionSecondsFromNow+">"+MaxSessionSeconds+"\r\n" );
                    }

                    if (CanExtendTime(_flags) && _submittedBundle == null)
                    {
                        _timeoutTime = DateTime.Now.AddSeconds(MaxSessionSecondsFromNow + SessionTimeoutExtensionSeconds);
                        _timer.Change((MaxSessionSecondsFromNow + SessionTimeoutExtensionSeconds) * 1000, Timeout.Infinite);
                    }
                    else
                    {
                        if (!CanExtendTime(_flags))
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_TIME_EXTENSION_NOT_ALLOWED, XEvent.Id.ARBITRATION_HACKER_ALERT_8, "Session can't be time extended\r\n" );
                        }
                        else // _submittedBundle != null
                        {
                            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_ARBITRATION_TIME_EXTENSION_NOT_ALLOWED, "Session can't be time extended after majority quorum bundle submission\r\n" );
                        }
                    }

                    // There should be no data left
                    if (reader.Read() != -1)
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_14, "Extra bytes at the end of TimeExtend request\r\n");
                    }
                }

                hr = HResult.S_OK;
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.xarblog, "TMX|"
                    + hr + "|"
                    + _titleID.ToString("X") + "|"
                    + _sessionID.ToString("X") + "|"
                    + _sessionNonce.ToString("X") + "|"
                    + flags.ToString("X") + "|"
                    + (ulong)((DateTime.Now - _startTime).TotalSeconds) + "|"
                    + ((_xboxes == null) ? "-1" : ((XboxInfo)_xboxes[xboxIndex]).timeExtendCount.ToString()) + "|"
                    + MaxSessionSecondsFromNow
                    );
            }
        }

        public HResult ReportResult(ushort flags, BinaryReader reader)
        {
            HResult     hr = HResult.S_OK;
            AuthData    authData = new AuthData(_titleID, _titleParameters);
            XboxInfo    xbox = null;
            byte[]      statsBundle = null;
            byte[]      tournamentBundle = null;

            lock (this)
            {
                try
                {
                    int i;

                    int xboxIndex = FindXbox(authData.xboxID);

                    if (xboxIndex == -1)
                    {
                        throw new XRLException(HResult.XONLINE_E_ARBITRATION_NEED_TO_REGISTER_FIRST, XEvent.Id.ARBITRATION_HACKER_ALERT_10, "ReportResult called without registration\r\n" );
                    }
                    else
                    {
                        xbox = (XboxInfo)_xboxes[xboxIndex];
                        xbox.reportCount++;
                    }

                    if (xbox.reportCount > 1)
                    {
                        // We already got your report, ignore duplicates
                        // Return error code if you were not reporting in UDP
                        return ReportInUDP(flags) ? (HResult) xbox.hr : (HResult) HResult.XONLINE_E_ARBITRATION_REPORT_ALREADY_CALLED;
                    }

                    try
                    {
                        if ((_xboxes.Count == 1 && xbox.users.Length < 2))
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_1_XBOX_1_USER_SESSION_NOT_ALLOWED, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_15, "ReportResult called with only one Xbox registered and one user on the Xbox\r\n" );
                        }

                        if (flags != ReportFlags(flags))
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS, XEvent.Id.ARBITRATION_HACKER_ALERT_11, "Invalid report flags submitted:"+flags.ToString("X")+"\r\n" );
                        }

                        if (TournamentBundleSubmitted(flags) != IsTournament(_flags))
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_INCONSISTENT_COMPETITION_STATUS, XEvent.Id.ARBITRATION_HACKER_ALERT_12, "Submitting tournament info for non tournament\r\n" );
                        }

                        if (_sessionSeconds == 0.0)
                        {
                            _sessionSeconds = (DateTime.Now - _startTime).TotalSeconds;
                        }

                        xbox.reportFlags = flags;

                        if (LostConnectivitySubmitted(flags))
                        {
                            BuildSortedPUIDList();
                            if (!ReadPUIDListAndVerify( reader, xbox.xboxID, _xboxPUIDs, "Reported lost connectivity with Xbox:", ref xbox.diconnectedXboxes ))
                            {
                                hr = HResult.XONLINE_S_ARBITRATION_INVALID_XBOX_SPECIFIED;
                            }
                        }

                        if (IVoluntarilyQuit(flags))
                        {
                            // total trust does not include people that voluntarily quit
                            _totalTrust -= (double)(xbox.trust);

                            if (StatsBundleSubmitted(flags) || TournamentBundleSubmitted(flags))
                            {
                                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS, XEvent.Id.ARBITRATION_HACKER_ALERT_13, "Bundle submission for quitted session\r\n" );
                            }
                        }

                        // Check Type 1 suspicious info
                        if (Type1SuspiciousInfoSubmitted(flags))
                        {
                            SuspiciousInfo suspiciousInfo = ReadSuspiciousInfo( reader, ref hr );

                            if (_suspiciousInfo[0] == null)
                            {
                                _suspiciousInfo[0] = new ArrayList(1);
                            }
                            _suspiciousInfo[0].Add( suspiciousInfo );
                        }

                        // Check Type 2 suspicious info
                        if (Type2SuspiciousInfoSubmitted(flags))
                        {
                            SuspiciousInfo suspiciousInfo = ReadSuspiciousInfo( reader, ref hr );

                            if (_suspiciousInfo[1] == null)
                            {
                                _suspiciousInfo[1] = new ArrayList(1);
                            }
                            _suspiciousInfo[1].Add( suspiciousInfo );
                        }

                        // Check Type 3 suspicious info
                        if (Type3SuspiciousInfoSubmitted(flags))
                        {
                            SuspiciousInfo suspiciousInfo = ReadSuspiciousInfo( reader, ref hr );

                            if (_suspiciousInfo[2] == null)
                            {
                                _suspiciousInfo[2] = new ArrayList(1);
                            }
                            _suspiciousInfo[2].Add( suspiciousInfo );
                        }

                        if (StatsBundleSubmitted(flags))
                        {
                            int statsBundleSize = reader.ReadInt32();
                            if (statsBundleSize > MaxStatsBundleSize)
                            {
                                throw new XRLException(HResult.XONLINE_E_ARBITRATION_REPORT_TOO_LARGE, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_16, "statsBundleSize specified > MaxStatsBundleSize allowed: "+statsBundleSize+">"+MaxStatsBundleSize+"\r\n" );
                            }
                            statsBundle = reader.ReadBytes(statsBundleSize);
                        }

                        if (TournamentBundleSubmitted(flags))
                        {
                            int tournamentBundleSize = reader.ReadInt32();
                            if (tournamentBundleSize > MaxTournamentBundleSize)
                            {
                                throw new XRLException(HResult.XONLINE_E_ARBITRATION_REPORT_TOO_LARGE, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_17, "tournamentBundleSize specified > MaxTournamentBundleSize allowed: "+tournamentBundleSize+">"+MaxTournamentBundleSize+"\r\n" );
                            }
                            tournamentBundle = reader.ReadBytes(tournamentBundleSize);
                        }

                        // There should be no data left
                        if (reader.Read() != -1)
                        {
                            throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_BAD_REQUEST_FROM_CLIENT_18, "Extra bytes at the end of ReportResult request\r\n");
                        }

                        if (statsBundle != null || tournamentBundle != null)
                        {
                            for (i=0; i<_bundles.Count; ++i)
                            {
                                if (((Bundle)_bundles[i]).BundleMatch(xbox.trust, statsBundle, tournamentBundle))
                                {
                                    xbox.bundle = (Bundle)_bundles[i];
                                    break;
                                }
                            }
                            if (i == _bundles.Count)
                            {
                                xbox.bundle = new Bundle(_bundles.Count, xbox.trust, statsBundle, tournamentBundle);
                                _bundles.Add(xbox.bundle);
                            }

                            // submit bundle if majority quorum formed
                            if (xbox.bundle.totalTrust > _totalTrust * MajorityQuorum)
                            {
                                SubmitBundle( xbox.bundle );
                            }
                        }
                    }
                    catch (XRLException e)
                    {
                        // Remember the HResult so that subsequent UDP requests get the same hr value back.
                        xbox.hr = e.HResult;
                        throw;
                    }

                    if (hr == HResult.S_OK && _bundles.Count > 1)
                    {
                        hr = HResult.XONLINE_S_ARBITRATION_DIFFERENT_RESULTS_DETECTED;
                    }

                    _reportCount++;
                }
                catch (XRLException e)
                {
                    hr = e.HResult;
                    throw;
                }
                finally
                {
                    Xom.Log(XomAreaName.xarblog, "REP|"
                        + hr + "|"
                        + _titleID.ToString("X") + "|"
                        + _sessionID.ToString("X") + "|"
                        + _sessionNonce.ToString("X") + "|"
                        + flags.ToString("X") + "|"
                        + (ulong)((DateTime.Now - _startTime).TotalSeconds) + "|"
                        + ((xbox == null) ? "-1" : xbox.reportCount.ToString()) + "|"
                        + (xbox.diconnectedXboxes == null ? "0" : xbox.diconnectedXboxes.Length.ToString()) + "|"
                        + (statsBundle == null ? "0" : statsBundle.Length.ToString()) + "|"
                        + (tournamentBundle == null ? "0" : tournamentBundle.Length.ToString()) + "|"
                        + _reportCount + "|"
                        + ((_bundles == null) ? "-1" : _bundles.Count.ToString()) + "|"
                        + (_submittedBundle == null ? "0" : "1")
                        );
                }

                // Check if every xbox has reported
                if (_reportCount == _xboxes.Count)
                {
                    // Everybody has reported, perform FinalSessionArbitration
                    _timeoutTime = DateTime.Now.AddSeconds(TrailingReportRetriesWaitSeconds);
                    _timer.Change(TrailingReportRetriesWaitSeconds * 1000, Timeout.Infinite);
                    FinalSessionArbitration();
                }

                // Remember the HResult so that subsequent UDP requests get the same hr value back.
                xbox.hr = hr;
            }

            return hr;
        }

        public ArbitrationDebugResultResponse DebugResult(ArbitrationDebugResultRequest request)
        {
            if (!EnableDebugResult)
            {
                throw new XRLException(HResult.XONLINE_E_ARBITRATION_INVALID_REQUEST, XEvent.Id.ARBITRATION_HACKER_ALERT_14, "EnableDebug called when EnableDebugResult is off\r\n" );
            }

            ArbitrationDebugResultResponse response = new ArbitrationDebugResultResponse();

            lock (this)
            {
                int i,j,k,l;

                response.titleID = _titleID;
                response.sessionID = _sessionID;
                response.sessionNonce = _sessionNonce;
                response.titleParameters = new ArbitrationTitleParameters();
                response.titleParameters.BaseTrust = _titleParameters.BaseTrust;
                response.titleParameters.MinorityQuorum = _titleParameters.MinorityQuorum;
                response.titleParameters.UserTournamentAmplification = _titleParameters.UserTournamentAmplification;
                response.titleParameters.PublisherTournamentAmplification = _titleParameters.PublisherTournamentAmplification;
                response.titleParameters.BaseSessionTime = _titleParameters.BaseSessionTime;
                response.titleParameters.FermiK = _titleParameters.FermiK;
                response.flags = _flags;
                response.maxSessionSeconds = _maxSessionSeconds;
                response.secondsLeftTillTimeout = (ushort)((DateTime.Now >= _timeoutTime) ? 0 : (_timeoutTime - DateTime.Now).TotalSeconds);
                response.startTime = _startTime;
                response.sessionSeconds = _sessionSeconds;

                response.xboxCount = _xboxes.Count;
                response.xboxes = new ArbitrationXboxInfo[response.xboxCount];
                for (i=0; i<response.xboxCount; ++i)
                {
                    response.xboxes[i] = new ArbitrationXboxInfo();
                    response.xboxes[i].timeExtendCount = ((XboxInfo)_xboxes[i]).timeExtendCount;
                    response.xboxes[i].reportCount = ((XboxInfo)_xboxes[i]).reportCount;
                    response.xboxes[i].reportFlags = ((XboxInfo)_xboxes[i]).reportFlags;
                    response.xboxes[i].xboxID = ((XboxInfo)_xboxes[i]).xboxID;

                    response.xboxes[i].userCount = ((XboxInfo)_xboxes[i]).users.Length;
                    response.xboxes[i].users = new ArbitrationXUIDAndTrust[response.xboxes[i].userCount];
                    for (j=0; j<response.xboxes[i].userCount; ++j)
                    {
                        response.xboxes[i].users[j] = new ArbitrationXUIDAndTrust();
                        response.xboxes[i].users[j].qwUserID = ((XboxInfo)_xboxes[i]).users[j].qwUserID;
                        response.xboxes[i].users[j].dwUserFlags = ((XboxInfo)_xboxes[i]).users[j].dwUserFlags;
                        response.xboxes[i].users[j].userTrust = ((XboxInfo)_xboxes[i]).users[j].userTrust;
                    }

                    response.xboxes[i].trust = ((XboxInfo)_xboxes[i]).trust;
                    response.xboxes[i].normalizedTrust = ((XboxInfo)_xboxes[i]).normalizedTrust;
                    response.xboxes[i].bundleIndex = ((XboxInfo)_xboxes[i]).bundle == null ? -1 : ((XboxInfo)_xboxes[i]).bundle.index;

                    response.xboxes[i].diconnectedXboxCount = ((XboxInfo)_xboxes[i]).diconnectedXboxes == null ? 0 : ((XboxInfo)_xboxes[i]).diconnectedXboxes.Length;
                    response.xboxes[i].diconnectedXboxes = new ulong[response.xboxes[i].diconnectedXboxCount];
                    for (j=0; j<response.xboxes[i].diconnectedXboxCount; ++j)
                    {
                        response.xboxes[i].diconnectedXboxes[j] = ((XboxInfo)_xboxes[i]).diconnectedXboxes[j];
                    }
                }

                response.teamTicketCount = _teamTicketList == null ? 0 : _teamTicketList.Count;

                response.totalTrust = _totalTrust;
                response.reportCount = _reportCount;
                response.arbitrated = _arbitrated;

                response.result = (int)_result;
                response.nonProblematicResult = (int)_nonProblematicResult;
                response.trustModificationScale = _trustModificationScale;

                response.bundleCount = _bundles == null ? 0 : _bundles.Count;
                response.bundles = new ArbitrationBundle[response.bundleCount];
                for (i=0; i<response.bundleCount; ++i)
                {
                    response.bundles[i] = new ArbitrationBundle();
                    response.bundles[i].index = ((Bundle)_bundles[i]).index;
                    response.bundles[i].count = ((Bundle)_bundles[i]).count;
                    response.bundles[i].totalTrust = ((Bundle)_bundles[i]).totalTrust;
                }
                response.submittedBundleIndex = _submittedBundle == null ? -1 : _submittedBundle.index;

                response.suspiciousInfoCount = (_suspiciousInfo[0] == null ? 0 : _suspiciousInfo[0].Count) +
                                               (_suspiciousInfo[1] == null ? 0 : _suspiciousInfo[1].Count) +
                                               (_suspiciousInfo[2] == null ? 0 : _suspiciousInfo[2].Count);
                response.suspiciousInfo = new ArbitrationSuspiciousInfo[response.suspiciousInfoCount];
                for (k=i=0; i<3; ++i)
                {
                    for (j=0; j<(_suspiciousInfo[i] == null ? 0 : _suspiciousInfo[i].Count); ++j)
                    {
                        response.suspiciousInfo[k] = new ArbitrationSuspiciousInfo();
                        response.suspiciousInfo[k].type = i+1;
                        response.suspiciousInfo[k].message = ((SuspiciousInfo)((_suspiciousInfo[i])[j])).message;
                        response.suspiciousInfo[k].xboxCount = ((SuspiciousInfo)((_suspiciousInfo[i])[j])).xboxes == null ? 0 : ((SuspiciousInfo)((_suspiciousInfo[i])[j])).xboxes.Length;
                        response.suspiciousInfo[k].xboxes = new ulong[response.suspiciousInfo[k].xboxCount];
                        for (l=0; l<response.suspiciousInfo[k].xboxCount; ++l)
                        {
                            response.suspiciousInfo[k].xboxes[l] = ((SuspiciousInfo)((_suspiciousInfo[i])[j])).xboxes[l];
                        }
                        response.suspiciousInfo[k].userCount = ((SuspiciousInfo)((_suspiciousInfo[i])[j])).users == null ? 0 : ((SuspiciousInfo)((_suspiciousInfo[i])[j])).users.Length;
                        response.suspiciousInfo[k].users = new ulong[response.suspiciousInfo[k].userCount];
                        for (l=0; l<response.suspiciousInfo[k].userCount; ++l)
                        {
                            response.suspiciousInfo[k].users[l] = ((SuspiciousInfo)((_suspiciousInfo[i])[j])).users[l];
                        }
                        k++;
                    }
                }
            }

            return response;
        }

        private static void SessionTimedOut(object o)
        {
            ArbitratedSession s = (ArbitratedSession)o;

            try
            {
                MemoryStream titleIDSessionIDAndNonceMemStream = new MemoryStream(20);
                BinaryWriter writer = new BinaryWriter(titleIDSessionIDAndNonceMemStream);

                writer.Write(s._titleID);
                writer.Write(s._sessionID);
                writer.Write(s._sessionNonce);

                SessionManager.DeleteSession(titleIDSessionIDAndNonceMemStream.ToArray());

                s.FinalSessionArbitration();
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.ARBITRATION_CODE_5, e, "SessionTimedOut failed");
            }
            finally
            {
                s._timer.Dispose();
                s._timer = null;
            }
        }

        // This is called when session finally times out or everybody reports and trust factors are updated
        private void FinalSessionArbitration()
        {
            lock (this)
            {
                try
                {
                    int i,j,k;
                    XboxInfo xbox;
                    _result = SessionOutcome.Failed;
                    bool firstUser;

                    // Return if we already arbitrated this session
                    if (_arbitrated)
                    {
                        return;
                    }

                    double bestBundleTrust = 0.0;
                    bool[] suspiciousActivity = new bool[_suspiciousInfo.Length];

                    // Do nothing if only 0 or 1 xbox involved in session
                    // or if no bundles were submitted
                    if (_xboxes.Count > 1 && _bundles.Count > 0)
                    {
                        // Find bundle with highest trust
                        Bundle bestBundle = null;
                        for (i=0; i<_bundles.Count; ++i)
                        {
                            if (((Bundle)_bundles[i]).totalTrust > bestBundleTrust)
                            {
                                bestBundle = (Bundle)_bundles[i];
                                bestBundleTrust = bestBundle.totalTrust;
                            }
                        }

                        Debug.Assert(bestBundle != null);

                        if (bestBundleTrust > _totalTrust * MajorityQuorum)
                        {
                            _result = SessionOutcome.Successful;
                        }
                        else if (bestBundleTrust > _totalTrust * _titleParameters.MinorityQuorum || bestBundle.count >= _xboxes.Count - 1)
                        {
                            // We have minority percentage or only one Xbox doesn't agree with this bundle
                            _result = SessionOutcome.Minority;
                        }

                        Debug.Assert(_submittedBundle == null || _result == SessionOutcome.Successful);

                        // Remember what the state was before checking for problematic results
                        _nonProblematicResult = _result;

                        // Check for problematic issues
                        if (_bundles.Count > 1)
                        {
                            _result = SessionOutcome.Problematic;
                        }

                        // Check if anybody lost connectivity to some other Xbox
                        // that still reported results at the end of the session
                        for (i=0; i<_xboxes.Count; ++i)
                        {
                            xbox = ((XboxInfo)_xboxes[i]);
                            if (LostConnectivitySubmitted(xbox.reportFlags))
                            {
                                for (j=0; j<xbox.diconnectedXboxes.Length; ++j)
                                {
                                    k = FindXbox(xbox.diconnectedXboxes[j]);
                                    if (k != -1 && ((XboxInfo)_xboxes[k]).reportCount > 0)
                                    {
                                        _result = SessionOutcome.Problematic;
                                        break;
                                    }
                                }
                            }
                        }

                        // Check if anybody reported in UDP
                        for (i=0; i<_xboxes.Count; ++i)
                        {
                            if (ReportInUDP(((XboxInfo)_xboxes[i]).reportFlags))
                            {
                                _result = SessionOutcome.UDPReport;
                                break;
                            }
                        }

                        for (i=0; i<suspiciousActivity.Length; ++i)
                        {
                            suspiciousActivity[i] = (_suspiciousInfo[i] != null && _suspiciousInfo[i].Count > 0);
                        }

                        // Now submit the bundle, but we only do so if it a majority bundle
                        // or if it is a non-problematic minority bundle
                        if (_nonProblematicResult == SessionOutcome.Successful || _result == SessionOutcome.Minority)
                        {
                            SubmitBundle( bestBundle );
                        }

                        // Now update the trust of all participating users
                        _trustModificationScale = (float) ( 1.0 + Math.Log( Math.Max( 1.0, _sessionSeconds / _titleParameters.BaseSessionTime ) ) );

                        if (IsTournament(_flags))
                        {
                            if (IsPublisherTournament(_flags))
                            {
                                _trustModificationScale *= (float)_titleParameters.PublisherTournamentAmplification;
                            }
                            else
                            {
                                _trustModificationScale *= (float)_titleParameters.UserTournamentAmplification;
                            }
                        }

                        firstUser = true;
                        for (i=0; i<_xboxes.Count; ++i)
                        {
                            xbox = (XboxInfo)_xboxes[i];
                            for (j=0; j<xbox.users.Length; ++j)
                            {
                                TrustRatingUpdater.UpdateTrust(_titleID, xbox.users[j].qwUserID,
                                    _result == SessionOutcome.Successful ? _trustModificationScale : 0.0F,
                                    _result == SessionOutcome.Minority ? _trustModificationScale : 0.0F,
                                    _result == SessionOutcome.Failed ? _trustModificationScale : 0.0F,
                                    _result == SessionOutcome.Problematic ? _trustModificationScale : 0.0F,
                                    _result == SessionOutcome.UDPReport ? _trustModificationScale : 0.0F,
                                    xbox.reportCount == 0 ? _trustModificationScale : 0.0F,
                                    suspiciousActivity[0] ? _trustModificationScale : 0.0F,
                                    suspiciousActivity[1] ? _trustModificationScale : 0.0F,
                                    suspiciousActivity[2] ? _trustModificationScale : 0.0F,
                                    1,
                                    xbox.reportCount == 0 ? 1 : 0,
                                    IsTournament(_flags) ? 1 : 0,
                                    firstUser ? 1 : 0,
                                    firstUser ? _xboxes.Count : 0,
                                    firstUser ? (int)_sessionSeconds : 0,
                                    firstUser ? (IsFFA(_flags) ? 1 : 0) : 0
                                    );

                                firstUser = false;
                            }
                        }
                    }

                    // Increment the perfcounters
                    switch (_result)
                    {
                        case SessionOutcome.Successful:
                            XArbitrationServerCounters.Counters.NormalSessionsPerSecond.Increment();
                            XArbitrationServerCounters.Counters.NormalSessionTotal.Increment();
                            break;
                        case SessionOutcome.Minority:
                            XArbitrationServerCounters.Counters.MinoritySessionsPerSecond.Increment();
                            XArbitrationServerCounters.Counters.MinoritySessionTotal.Increment();
                            break;
                        case SessionOutcome.Failed:
                            XArbitrationServerCounters.Counters.FailedSessionsPerSecond.Increment();
                            XArbitrationServerCounters.Counters.FailedSessionTotal.Increment();
                            break;
                        case SessionOutcome.Problematic:
                            XArbitrationServerCounters.Counters.ProblematicSessionsPerSecond.Increment();
                            XArbitrationServerCounters.Counters.ProblematicSessionTotal.Increment();
                            break;
                        case SessionOutcome.UDPReport:
                            XArbitrationServerCounters.Counters.UDPReportSessionsPerSecond.Increment();
                            XArbitrationServerCounters.Counters.UDPReportSessionTotal.Increment();
                            break;
                    }

                    // Log a log line about the session
                    Xom.Log(XomAreaName.xarblog, "ARB|"
                        + _titleID.ToString("X") + "|"
                        + _sessionID.ToString("X") + "|"
                        + _sessionNonce.ToString("X") + "|"
                        + _flags.ToString("X") + "|"
                        + (ulong)((DateTime.Now - _startTime).TotalSeconds) + "|"
                        + _maxSessionSeconds + "|"
                        + _xboxes.Count + "|"
                        + (_teamTicketList == null ? "0" : _teamTicketList.Count.ToString()) + "|"
                        + _reportCount + "|"
                        + _bundles.Count + "|"
                        + (_suspiciousInfo[0] == null ? "0" : _suspiciousInfo[0].Count.ToString()) + "|"
                        + (_suspiciousInfo[1] == null ? "0" : _suspiciousInfo[1].Count.ToString()) + "|"
                        + (_suspiciousInfo[2] == null ? "0" : _suspiciousInfo[2].Count.ToString()) + "|"
                        + bestBundleTrust + "/" + _totalTrust + "|"
                        + _result
                        );

                    // Extended logging needed in extreme cases
                    if (VerboseLogging ||
                        _result == SessionOutcome.Failed ||
                        _result == SessionOutcome.Problematic ||
                        _result == SessionOutcome.UDPReport ||
                        suspiciousActivity[0] ||
                        suspiciousActivity[1] ||
                        suspiciousActivity[2])
                    {
                        Xom.Log(XomAreaName.xarblog, "VL0|"
                            + _titleID.ToString("X") + "|"
                            + _sessionID.ToString("X") + "|"
                            + _sessionNonce.ToString("X") + "|"
                            + _flags.ToString("X") + "|"
                            + (ulong)((DateTime.Now - _startTime).TotalSeconds) + "|"
                            + _maxSessionSeconds + "|"
                            + _xboxes.Count + "|"
                            + (_teamTicketList == null ? "0" : _teamTicketList.Count.ToString()) + "|"
                            + _reportCount + "|"
                            + _bundles.Count + "|"
                            + (_suspiciousInfo[0] == null ? "0" : _suspiciousInfo[0].Count.ToString()) + "|"
                            + (_suspiciousInfo[1] == null ? "0" : _suspiciousInfo[1].Count.ToString()) + "|"
                            + (_suspiciousInfo[2] == null ? "0" : _suspiciousInfo[2].Count.ToString()) + "|"
                            + bestBundleTrust + "/" + _totalTrust + "|"
                            + (_submittedBundle == null ? "NA" : _submittedBundle.index.ToString()) + "|"
                            + _result
                            );

                        for (i=0; i<_xboxes.Count; ++i)
                        {
                            xbox = (XboxInfo)_xboxes[i];
                            Xom.Log(XomAreaName.xarblog, "VL1|"
                                + _titleID.ToString("X") + "|"
                                + _sessionID.ToString("X") + "|"
                                + _sessionNonce.ToString("X") + "|"
                                + xbox.xboxID.ToString("X") + "|"
                                + xbox.timeExtendCount + "|"
                                + xbox.reportCount + "|"
                                + xbox.reportFlags.ToString("X") + "|"
                                + xbox.trust + "|"
                                + (xbox.bundle == null ? "-1" : xbox.bundle.index.ToString()) + "|"
                                + (xbox.users.Length<=0 ? "0|0" : (xbox.users[0].qwUserID.ToString("X") + "|" + xbox.users[0].userTrust)) + "|"
                                + (xbox.users.Length<=1 ? "0|0" : (xbox.users[1].qwUserID.ToString("X") + "|" + xbox.users[1].userTrust)) + "|"
                                + (xbox.users.Length<=2 ? "0|0" : (xbox.users[2].qwUserID.ToString("X") + "|" + xbox.users[2].userTrust)) + "|"
                                + (xbox.users.Length<=3 ? "0|0" : (xbox.users[3].qwUserID.ToString("X") + "|" + xbox.users[3].userTrust))
                                );

                            if (xbox.diconnectedXboxes != null)
                            {
                                for (j=0; j<xbox.diconnectedXboxes.Length; ++j)
                                {
                                    Xom.Log(XomAreaName.xarblog, "VL2|"
                                        + _titleID.ToString("X") + "|"
                                        + _sessionID.ToString("X") + "|"
                                        + _sessionNonce.ToString("X") + "|"
                                        + xbox.xboxID.ToString("X") + "|"
                                        + xbox.diconnectedXboxes[j].ToString("X") + "|"
                                        );
                                }
                            }
                        }

                        for (i=0; i<_bundles.Count; ++i)
                        {
                            Bundle bundle = (Bundle)_bundles[i];
                            Xom.Log(XomAreaName.xarblog, "VL3|"
                                + _titleID.ToString("X") + "|"
                                + _sessionID.ToString("X") + "|"
                                + _sessionNonce.ToString("X") + "|"
                                + bundle.index + "|"
                                + bundle.count + "|"
                                + bundle.totalTrust + "|"
                                + (bundle.stats == null ? "0" : bundle.stats.Length.ToString()) + "|"
                                + (bundle.tournament == null ? "0" : bundle.tournament.Length.ToString()) + "|"
                                + (bundle.stats == null ? "0" : ByteConvert.ToString(bundle.stats)) + "|"
                                + (bundle.tournament == null ? "0" : ByteConvert.ToString(bundle.tournament))
                                );
                        }

                        for (i=0; i<_suspiciousInfo.Length; ++i)
                        {
                            if (_suspiciousInfo[i] != null && _suspiciousInfo[i].Count > 0)
                            {
                                for (j=0; j<_suspiciousInfo[i].Count; ++j)
                                {
                                    SuspiciousInfo suspiciousInfo = (SuspiciousInfo)_suspiciousInfo[i][j];
                                    Xom.Log(XomAreaName.xarblog, "VL4|"
                                        + _titleID.ToString("X") + "|"
                                        + _sessionID.ToString("X") + "|"
                                        + _sessionNonce.ToString("X") + "|"
                                        + i + "|"
                                        + j + "|"
                                        + suspiciousInfo.message
                                        );

                                    if (suspiciousInfo.xboxes != null)
                                    {
                                        for (k=0; k<suspiciousInfo.xboxes.Length; ++k)
                                        {
                                            Xom.Log(XomAreaName.xarblog, "VL5|"
                                                + _titleID.ToString("X") + "|"
                                                + _sessionID.ToString("X") + "|"
                                                + _sessionNonce.ToString("X") + "|"
                                                + i + "|"
                                                + j + "|"
                                                + suspiciousInfo.xboxes[k].ToString("X")
                                                );
                                        }
                                    }

                                    if (suspiciousInfo.users != null)
                                    {
                                        for (k=0; k<suspiciousInfo.users.Length; ++k)
                                        {
                                            Xom.Log(XomAreaName.xarblog, "VL6|"
                                                + _titleID.ToString("X") + "|"
                                                + _sessionID.ToString("X") + "|"
                                                + _sessionNonce.ToString("X") + "|"
                                                + i + "|"
                                                + j + "|"
                                                + suspiciousInfo.users[k].ToString("X")
                                                );
                                        }
                                    }
                                }
                            }
                        }

                    }

                    // TODO Need to add more checks for modified code and fire events for OPS to ban
                }
                catch (Exception e)
                {
                  Xom.NtEvent(XEvent.Id.ARBITRATION_CODE_6, e, "FinalSessionArbitration failed");
                }
                
                _arbitrated = true;
            }
        }

        private void SubmitBundle( Bundle bundle )
        {
            try
            {
                // Make sure we either have 2 Xboxes or 2 users on one Xbox
                if (_submittedBundle == null && (_xboxes.Count >= 2 || ((XboxInfo)_xboxes[0]).users.Length >= 2))
                {
                    if (_bundledAuthData == null)
                    {
                        int i,j;
                        ArrayList users = new ArrayList(2 * _xboxes.Count);

                        for (i=0; i<_xboxes.Count; ++i)
                        {
                            XboxInfo xbox = (XboxInfo)_xboxes[i];
                            for (j=0; j<xbox.users.Length; ++j)
                            {
                                users.Add(xbox.users[j]);
                            }
                        }

                        _bundledAuthData = new BundledAuthData( _titleID, (XUIDAndTrust[]) users.ToArray(typeof(XUIDAndTrust)) );
                    }

                    if (ForTeams(_flags) && _teamTickets == null)
                    {
                        _teamTickets = new TeamTickets((TeamTicket[]) _teamTicketList.ToArray(typeof(TeamTicket)));
                    }

                    _submittedBundle = bundle;

                    BundleSubmitter.Submit( _titleID, bundle.stats, _alternateStatsDestination, bundle.tournament, _alternateQueryDestination, _bundledAuthData, _teamTickets );
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.ARBITRATION_CODE_7, e, "SubmitBundle failed");
            }
        }

        private SuspiciousInfo ReadSuspiciousInfo( BinaryReader reader, ref HResult hr )
        {
            int length = reader.ReadByte();
            ASCIIEncoding ascii = new ASCIIEncoding();
            SuspiciousInfo suspiciousInfo = new SuspiciousInfo( ascii.GetString( reader.ReadBytes(length) ) );

            BuildSortedPUIDList();

            // Suspicion targeted at these Xboxes
            if (!ReadPUIDListAndVerify( reader, 0, _xboxPUIDs, "Reported SuspiciousInfo about Xbox:", ref suspiciousInfo.xboxes ))
            {
                hr = HResult.XONLINE_S_ARBITRATION_INVALID_XBOX_SPECIFIED;
            }

            // Suspicion targeted at these Users
            if (!ReadPUIDListAndVerify( reader, 0, _userPUIDs, "Reported SuspiciousInfo about User:", ref suspiciousInfo.users ))
            {
                hr = HResult.XONLINE_S_ARBITRATION_INVALID_USER_SPECIFIED;
            }

            return suspiciousInfo;
        }

        private void BuildSortedPUIDList()
        {
            int i,j,k;

            if (_xboxPUIDs == null)
            {
                Debug.Assert( _xboxCount == _xboxes.Count );
                _xboxPUIDs = new ulong[_xboxes.Count];
                for (i=0; i<_xboxes.Count; ++i)
                {
                    _xboxPUIDs[i] = ((XboxInfo)_xboxes[i]).xboxID;
                }
                Array.Sort(_xboxPUIDs);
            }

            if (_userPUIDs == null)
            {
                k = 0;
                _userPUIDs = new ulong[_userCount];
                for (i=0; i<_xboxes.Count; ++i)
                {
                    for (j=0; j<((XboxInfo)_xboxes[i]).users.Length; ++j)
                    {
                        _userPUIDs[k++] = ((XboxInfo)_xboxes[i]).users[j].qwUserID;
                    }
                }
                Debug.Assert( _userCount == k );
                Array.Sort(_userPUIDs);
            }
        }

        private bool ReadPUIDListAndVerify( BinaryReader reader, ulong invalidPUID, ulong[] validPUIDs, string message, ref ulong[] result )
        {
            int i,j,k;
            bool success = true;

            j = 0;
            k = reader.ReadByte();
            result = new ulong[k];
            for (i=0; i<k; ++i)
            {
                ulong puid = reader.ReadUInt64();
                if (puid == invalidPUID || puid == 0)
                {
                    success = false;
                    Xom.NtEvent(XEvent.Id.ARBITRATION_HACK_34, message + (Puid) puid + " invalid.");
                }
                else if (Array.BinarySearch(validPUIDs,puid) < 0)
                {
                    success = false;
                    Xom.NtEvent(XEvent.Id.ARBITRATION_HACK_35, message + (Puid) puid + " which is not in session.");
                }
                else
                {
                    result[j++] = puid;
                }
            }

            // Build a new array if needed
            if (j != k)
            {
                ulong[] newArray = new ulong[j];
                Array.Copy(result, newArray, j);
                result = newArray;
            }

            if (j >= 2)
            {
                // Sort the array
                Array.Sort(result);

                // Check for duplicates and compact if found
                k = 0;
                for (i=1; i<j; ++i)
                {
                    if (result[k] == result[i])
                    {
                        success = false;
                        Xom.NtEvent(XEvent.Id.ARBITRATION_HACK_36, message + result[i].ToString("X") + " duplicated.");
                    }
                    else
                    {
                        result[++k] = result[i];
                    }
                }
                k++;

                if (j != k)
                {
                    ulong[] newArray = new ulong[k];
                    Array.Copy(result, newArray, k);
                    result = newArray;
                }
            }

            return success;
        }

        private int FindXbox( ulong xboxID )
        {
            int i;
            for (i=0; i<_xboxes.Count; ++i)
            {
                if (((XboxInfo)_xboxes[i]).xboxID == xboxID)
                {
                    return i;
                }
            }
            return -1;
        }
    }

 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\FuncWSGamertagEnumerate.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Billing.WebService2;
using XeXbos;



namespace XeXbos.Functional
{
    [TestGroup, Owner("styoo"), Description("GamertagEnumerate Web Service test"), TestFrequency("Regression"), EnvRequirement("")] 
    public class WSGamertagEnumerate : TestNode
    {
        static Guid freeGamertagChangeOfferId = XbosWS.EMSOfferInfo.OfferIdToOfferingGuid(Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange));
        static Guid chargedGamertagChangeOfferId = XbosWS.EMSOfferInfo.OfferIdToOfferingGuid(Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange));
        
        
        [TestCase, TestCasePriority(1)]
        public class P_Mainline : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, UacsCommon.WM_TitleId);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != freeGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("FreeGamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_DASH_TITLE_ID : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != freeGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("FreeGamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_Enumerate_TWICE : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != freeGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("FreeGamerTagChangeOffer should be returned");
                }

                // One more time
                resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != freeGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("FreeGamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_WM7User_Second : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Use Free changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != chargedGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("Charged GamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_WM7User_Second_After_Purchase_FromXbox: TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Use Free changes from xbox
                XRLXeOfferPurchaseGamertag request = new XRLXeOfferPurchaseGamertag();
                XRLXeOfferPurchaseGamertagResponse response = new XRLXeOfferPurchaseGamertagResponse();

                RandomEx rnd = new RandomEx();
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
            
                request.UserPuid = xuid;
                request.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points;
                request.Gamertag = newGamerTag;
                request.OfferID = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);
                request.Slot.titleId = XOn.XENON_DASH_TITLE_ID;

                Global.RO.Info("Changing user 0x" + xuid.ToString("X") + " to " + newGamerTag);
                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeOfferPurchaseGamertag failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseGamertag returned XErr=0x{0:x}", request.XErr));

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != chargedGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("Charged GamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_WM7User_First_FromXbox : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Enumerate GamertagChange offer from Xbox
                XRLXeContentEnumerate2 request = new XRLXeContentEnumerate2();
                XRLXeContentEnumerateResponse2 response = new XRLXeContentEnumerateResponse2();

                request.UserPuid = xuid;
                request.GameRating = 0xff;
                request.TierRequired = 0;
                request.OfferType = (uint)OfferingTypeEnum.GamertagChange;
                request.TitleID = XOn.XENON_DASH_TITLE_ID;

                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeContentEnumerate2 failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeContentEnumerate2 returned XErr=0x{0:x}", request.XErr));

                Global.RO.Info("response.OffersReturned : {0} ", response.OffersReturned);
                Global.RO.Info("response.OffersTotal : {0} ", response.OffersTotal);
                if(response. OffersReturned< 1)
                    throw new UnexpectedTestResultException(String.Format("No offers were returned."));

                Global.RO.Info("\t0x{0}  -  {1}", response.Offers[0].OfferID.ToString("D"), response.Offers[0].OfferName);

                if(response.Offers[0].OfferID != Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange))
                    throw new UnexpectedTestResultException(String.Format("FreeGamerTagChangeOffer should be returned"));

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_WM7User_Second_FromXbox : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Use Free changes from xbox
                XRLXeOfferPurchaseGamertag request = new XRLXeOfferPurchaseGamertag();
                XRLXeOfferPurchaseGamertagResponse response = new XRLXeOfferPurchaseGamertagResponse();

                RandomEx rnd = new RandomEx();
                string newGamerTag = rnd.GenerateRandomString("XEN", 15);
            
                request.UserPuid = xuid;
                request.PaymentType = (uint)ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Points;
                request.Gamertag = newGamerTag;
                request.OfferID = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);
                request.Slot.titleId = XOn.XENON_DASH_TITLE_ID;

                Global.RO.Info("Changing user 0x" + xuid.ToString("X") + " to " + newGamerTag);
                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeOfferPurchaseGamertag failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseGamertag returned XErr=0x{0:x}", request.XErr));


                // Enumerate GamertagChange offer from Xbox
                XRLXeContentEnumerate2 enumRequest = new XRLXeContentEnumerate2();
                XRLXeContentEnumerateResponse2 enumResponse = new XRLXeContentEnumerateResponse2();

                enumRequest.UserPuid = xuid;
                enumRequest.GameRating = 0xff;
                enumRequest.TierRequired = 0;
                enumRequest.OfferType = (uint)OfferingTypeEnum.GamertagChange;
                enumRequest.TitleID = XOn.XENON_DASH_TITLE_ID;

                if (!enumRequest.Execute(out enumResponse))
                    throw new UnexpectedTestResultException("XRLXeContentEnumerate2 failed: " + enumRequest.GetDumpString());
                if (enumRequest.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeContentEnumerate2 returned XErr=0x{0:x}", enumRequest.XErr));

                Global.RO.Info("enumResponse.OffersReturned : {0} ", enumResponse.OffersReturned);
                Global.RO.Info("enumResponse.OffersTotal : {0} ", enumResponse.OffersTotal);
                if(enumResponse. OffersReturned< 1)
                    throw new UnexpectedTestResultException(String.Format("No offers were returned."));

                Global.RO.Info("\t0x{0}  -  {1}", enumResponse.Offers[0].OfferID.ToString("D"), enumResponse.Offers[0].OfferName);

                if(enumResponse.Offers[0].OfferID != Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange))
                    throw new UnexpectedTestResultException(String.Format("Charged GamerTagChangeOffer should be returned"));

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }       



        [TestCase, TestCasePriority(1)]
        public class P_WM7User_Second_FromXbox_After_Purchase_FromWM7 : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Use Free changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);

                // Enumerate GamertagChange offer from Xbox
                XRLXeContentEnumerate2 request = new XRLXeContentEnumerate2();
                XRLXeContentEnumerateResponse2 response = new XRLXeContentEnumerateResponse2();

                request.UserPuid = xuid;
                request.GameRating = 0xff;
                request.TierRequired = 0;
                request.OfferType = (uint)OfferingTypeEnum.GamertagChange;
                request.TitleID = XOn.XENON_DASH_TITLE_ID;

                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeContentEnumerate2 failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeContentEnumerate2 returned XErr=0x{0:x}", request.XErr));

                Global.RO.Info("response.OffersReturned : {0} ", response.OffersReturned);
                Global.RO.Info("response.OffersTotal : {0} ", response.OffersTotal);
                if(response. OffersReturned< 1)
                    throw new UnexpectedTestResultException(String.Format("No offers were returned."));

                Global.RO.Info("\t0x{0}  -  {1}", response.Offers[0].OfferID.ToString("D"), response.Offers[0].OfferName);

                if(response.Offers[0].OfferID != Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange))
                    throw new UnexpectedTestResultException(String.Format("Charged GamerTagChangeOffer should be returned"));

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_NonWM7User : TestBase
        {
            protected override void Execute()
            {
                // Create non WM7 user
                XeUser user = new XeUser(false);
                ulong xuid = user.Create();

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, UacsCommon.WM_TitleId);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if(resp.offersTotal == 0 && resp.offersReturned == 0)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                    return;
                }

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != chargedGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("Charged GamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }   

        [TestCase, TestCasePriority(1)]
        public class P_NonWM7User_FromXbox : TestBase
        {
            protected override void Execute()
            {
                // Create non WM7 user
                XeUser user = new XeUser(false);
                ulong xuid = user.Create();

                // Enumerate GamertagChange offer from Xbox
                XRLXeContentEnumerate2 request = new XRLXeContentEnumerate2();
                XRLXeContentEnumerateResponse2 response = new XRLXeContentEnumerateResponse2();

                request.UserPuid = xuid;
                request.GameRating = 0xff;
                request.TierRequired = 0;
                request.OfferType = (uint)OfferingTypeEnum.GamertagChange;
                request.TitleID = XOn.XENON_DASH_TITLE_ID;

                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeContentEnumerate2 failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeContentEnumerate2 returned XErr=0x{0:x}", request.XErr));

                Global.RO.Info("response.OffersReturned : {0} ", response.OffersReturned);
                Global.RO.Info("response.OffersTotal : {0} ", response.OffersTotal);
                if(response. OffersReturned< 1)
                    throw new UnexpectedTestResultException(String.Format("No offers were returned."));

                Global.RO.Info("\t0x{0}  -  {1}", response.Offers[0].OfferID.ToString("D"), response.Offers[0].OfferName);

                if(response.Offers[0].OfferID != Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange))
                    throw new UnexpectedTestResultException(String.Format("Charged GamerTagChangeOffer should be returned"));

                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }   


        [TestCase, TestCasePriority(2)]
        public class N_Invalid_Xuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, 0x1234, 0, UacsCommon.WM_TitleId);
                
                try{
                    GamertagEnumerateResult resp  = Provider.GamertagEnumerate(0x1234, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.All, UacsCommon.WM_TitleId);
                }
                catch
                {
                    Global.RO.Info("GamertagEnumerate got exception");
                
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }       
        
        [TestCase, TestCasePriority(3), Ignore]
        public class P_CreditCard : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.CreditCard, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != freeGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("FreeGamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       
        
        [TestCase, TestCasePriority(1)]
        public class P_Points : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != freeGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("FreeGamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       


        
        [TestCase, TestCasePriority(2)]
        public class P_Token : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Token, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != freeGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("FreeGamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(3), Ignore]
        public class P_Second_CreditCard : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Use Free changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.CreditCard, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != chargedGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("Charged GamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

        [TestCase, TestCasePriority(1)]
        public class P_Second_Points : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Use Free changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != chargedGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("Charged GamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       


        [TestCase, TestCasePriority(2)]
        public class P_Second_Token : TestBase
        {
            protected override void Execute()
            {
                // Create WM7 user
                ulong xuid = UacsCommon.CreateMobileAccountGeneral();

                // Use Free changes
                XbosOffer.PurchaseFreeGamerTagGeneral(xuid);

                // Gamertag Enumeration
                ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper(0, xuid, 0, UacsCommon.WM_TitleId);
                
                GamertagEnumerateResult resp  = Provider.GamertagEnumerate(xuid, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Token, XOn.XENON_DASH_TITLE_ID);

                Global.RO.Info("{0} total content records", resp.offersTotal);
                Global.RO.Info("{0} content records returned", resp.offersReturned);

                if (resp.offersReturned != 1 || resp.offersTotal != 1)
                    throw new UnexpectedTestResultException("resp.offersReturned and resp.offersTotal should be  1.");

                for (int i = 0; i < resp.offersReturned; i++)
                {
                    Global.RO.Info("\t0x{0}  -  {1}", resp.infos[i].offerID.ToString("D"), resp.infos[i].offerName);
                    if (resp.infos[i].offerID != chargedGamertagChangeOfferId)
                        throw new UnexpectedTestResultException("Charged GamerTagChangeOffer should be returned");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }       

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\arbitration\test\dvt\FakeSGInfo.cs ===
using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Net.Sockets;
using System.Collections.Specialized;
using System.Threading;
using System.Diagnostics;
using System.Collections;
using System.Reflection;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.server.arbitration.test.unit;

[assembly: XomAreaDefinition(XomAreaName.cfgtrace)]

namespace xonline.server.arbitration.inh
{
        
    public struct XUIDAndTrust : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK      = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED    = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK    = 0x0000FF00;

        public ulong    qwUserID;
        public uint     dwUserFlags;
        public float    userTrust;

        public XUIDAndTrust(ulong userID, uint userFlags, float paramUserTrust)
        {
            qwUserID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }
        
        public int CompareTo(object obj)
        {
            return qwUserID.CompareTo(((XUIDAndTrust) obj).qwUserID);
        }

        public uint GuestNumber()
        {
            return dwUserFlags & XONLINE_USER_GUEST_MASK;
        }

        public bool IsGuest()
        {
            return (GuestNumber() != 0);
        }

        public byte UserCountry()
        {
            return (byte)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8);
        }

        public bool CanPurchase()
        {
            return ((dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED)) == 0);
        }

    }

    public class BundledAuthData
    {
        public const string HTTP_HEADER_BUNDLED_AUTH_DATA = "BundledAuthData";
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION = 1;

        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers)
        {
            titleID = paramTitleID;
            users = paramUsers;
        }

        public BundledAuthData(string base64EncodedString)
        {
            BinaryReader reader = new BinaryReader(new MemoryStream(Convert.FromBase64String(base64EncodedString)));
            ushort wBundledAuthDataVersion;

            wBundledAuthDataVersion = reader.ReadUInt16();
            if(wBundledAuthDataVersion != HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION) 
            {
                throw new ExceptionWithEventId(XEvent.Id.ARBITRATION_HACK_37, "BundledAuthData: Auth data version (" 
                    + wBundledAuthDataVersion + ") is incorrect!");
            }            
            users = new XUIDAndTrust[reader.ReadUInt16()];
            titleID = reader.ReadUInt32();
            for (int i=0; i<users.Length; ++i)
            {
                users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
            }
        }

        public string GetBase64EncodedString()
        {
            MemoryStream memStream = new MemoryStream(users.Length * 16 + 8);

            BinaryWriter writer = new BinaryWriter(memStream);

            writer.Write(HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION);
            writer.Write((ushort)users.Length);
            writer.Write(titleID);
            for (int i=0; i<users.Length; ++i)
            {
                writer.Write(users[i].qwUserID);
                writer.Write(users[i].dwUserFlags);
                writer.Write(users[i].userTrust);
            }
            
            return Convert.ToBase64String(memStream.ToArray());
        }
            
        public readonly uint     titleID;
        public XUIDAndTrust[]   users;
        
    }

    public class HTTPAuthData : SGInfo
    {
        public const string HTTP_HEADER_AUTH_DATA = "HTTPAuthData";
        public const ushort HTTP_HEADER_AUTH_DATA_VERSION = 2;

        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2) : base(port, ip, requestId)
        {
            wAuthDataSize    = 0;
            wMajorVersion    = 0;
            wMinorVersion    = 0;
            wBuildNumber     = 0;
            wQFENumber       = 0;
            dwTitleID        = titleID;
            dwTitleVersion   = 0;
            dwTitleRegion    = 0;
            qwXboxID         = 0;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            xUsers[0] = new XUIDAndTrust(userID, 0, 0.0F);
            for( int i = 1; i < XONLINE_MAX_LOGON_USERS; i++ )
            {   
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }
            
            // services
            dwNumServices = XONLINE_MAX_NUMBER_SERVICE;    
            dwServiceIds = new uint[XONLINE_MAX_NUMBER_SERVICE];
            dwServiceIds[0] = serviceId1;
            dwServiceIds[1] = serviceId2;
            for( int i = 2; i < XONLINE_MAX_NUMBER_SERVICE; i++ ) 
            {
                dwServiceIds[i] = 0;
            }
        }       
        
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2) : base(port, ip, requestId)
        {
            wAuthDataSize    = 0;
            wMajorVersion    = 0;
            wMinorVersion    = 0;
            wBuildNumber     = 0;
            wQFENumber       = 0;
            dwTitleID        = titleID;
            dwTitleVersion   = 0;
            dwTitleRegion    = 0;
            qwXboxID         = xboxID;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {   
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
            }
            
            // services
            dwNumServices = XONLINE_MAX_NUMBER_SERVICE;    
            dwServiceIds = new uint[XONLINE_MAX_NUMBER_SERVICE];
            dwServiceIds[0] = serviceId1;
            dwServiceIds[1] = serviceId2;
            for( int i = 2; i < XONLINE_MAX_NUMBER_SERVICE; i++ ) 
            {
                dwServiceIds[i] = 0;
            }
        }        

        public string GetBase64EncodedString()
        {
            return ConstructBase64String();
        }
    }

    //
    //  AuthToggle: Wraps the guts of turning on/off SG auth checking by config file.
    // 
    public class AuthToggle
    {
        private static bool mGotSetting = false;

        // static toggle saying whether to ignore auth data from SG
        // default to TRUE
        //     
        private static bool mVerifyAuthData = true;

        // static constructor to get config settings for XBOS.
        private static void GetAuthToggle()
        {
            string r = Config.GetSetting(Setting.sginfo_verifyAuth);
            if(r != null)
            {
                r = r.ToUpper();
                if( r == "FALSE" || r == "NO" || r == "OFF" )
                {
                  Xom.NtEvent( XEvent.Id.ARBITRATION_CONFIG_9,
                        "SG AUTH DATA VERIFICATION HAS BEEN TURNED OFF. This should NEVER happen in production." );

                    mVerifyAuthData = false;
                }
            }
            mGotSetting = true;
        }

        public static bool On 
        {
            get 
            { 
                if(mGotSetting == false) 
                {
                    GetAuthToggle(); 
                }
                return (mVerifyAuthData == true);
            }
        }

        public static bool Off 
        {
            get 
            { 
                if(mGotSetting == false) 
                {
                    GetAuthToggle(); 
                }
                return (mVerifyAuthData == false);
            }
        }
    
    }

    
    public class SGInfo 
    {        
        private struct sgMessageHeader 
        {
            public ushort _wType;
            public ushort _cbEnt;
        }
        protected const ushort SGMSG_TYPE_AUTHDATA2       = 0x4783;  // CAuthData2 in the payload

        protected const int XONLINE_MAX_LOGON_USERS       = 4;
        protected const int XONLINE_MAX_NUMBER_SERVICE    = 12;
        protected const ushort XONLINE_AUTHDATA_VERSION   = 0x02 ;

        //  the following fields are in the SG Info structure. (XKERB_AD_XBOX)
        //
        
        protected ushort    wAuthDataVersion;         
        protected ushort    wAuthDataSize;        // Size of this struct in bytes
        
        // XBOX_LIBRARY_VERSION     clientVersion;
        protected ushort    wMajorVersion;
        protected ushort    wMinorVersion;
        protected ushort    wBuildNumber;
        protected ushort    wQFENumber;
        //    
    
        protected uint      dwTitleID;
        protected uint      dwTitleVersion;
        protected uint      dwTitleRegion;
        protected ulong     qwXboxID;
        
        // The high 16 bits of dwUserFlags should come from the UODB User Table.
        protected XUIDAndTrust[]   xUsers;
       
        protected uint     dwNumServices;

        //DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE];
        protected uint[]   dwServiceIds;        
        //
    
        // the rest of the spidata structure (CSgMsgSpiData)

        protected ushort  _ipportI;                   // IP port of the client on the Internet
        protected uint    _ipaI;                      // IP address of the client on the Internet
        protected byte[]  _sgaddr;                    // SGADDR of the client
        protected ushort  _wVersionKeyEx;             // KeyEx version of the client
        protected ushort  _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        protected ulong   _liNonce;                   // A random nonce associated with this session
        protected ulong   _liTimeInit;                // FILETIME marking session initiation
        protected uint    _fCs;                       // TRUE if SG is providing connection services
        
        public static SGInfo Current
        {
            get 
            {
                return new SGInfo();
            }
        }
                             
        // This is a special constructor for HTTPAuthData construction
        public SGInfo(ushort port, uint ip, ulong requestId)
        {
            wAuthDataVersion = XONLINE_AUTHDATA_VERSION;
            _ipportI = port;
            _ipaI = ip;
            _liNonce = requestId;

            _sgaddr          = null;
            _wVersionKeyEx   = 0;
            _wFlagsKeyEx     = 0;
            _liTimeInit      = (ulong)DateTime.Now.Ticks;
            _fCs             = 0;
        }

        
        /// <summary>
        /// The default constructor will create a new SGInfo with all the current information from
        /// the security gateway.
        /// </summary>       
        public SGInfo()
        {              
            byte[] httpBytes = Convert.FromBase64String(ArbSessionTest.GetHTTPAuthData());
            BinaryReader sgInfo = new BinaryReader(new MemoryStream(httpBytes));

            ushort version = sgInfo.ReadUInt16();
            if (version != HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION)
            {
                throw new ExceptionWithEventId(XEvent.Id.ARBITRATION_HACK_38, "SGInfo: HTTP AuthData has bad version: " + version.ToString() );
            }
            
            _ipportI         = sgInfo.ReadUInt16();
            _ipaI            = sgInfo.ReadUInt32();
            _sgaddr          = null;
            _wVersionKeyEx   = 0;
            _wFlagsKeyEx     = 0;
            _liNonce         = sgInfo.ReadUInt64();
            _liTimeInit      = (ulong)DateTime.Now.Ticks;
            _fCs             = 0;

            ReadSgInfo(sgInfo, true);
        }
        
        private void ReadSgInfo(BinaryReader reader, bool onlyAuthData)
        {
            sgMessageHeader authHdr;

            // if we're getting more than authdata then get ready to read the spy.
            if (!onlyAuthData)
            {
                _ipportI         = reader.ReadUInt16();
                _ipaI            = reader.ReadUInt32();
                _sgaddr          = reader.ReadBytes(20);
                _wVersionKeyEx   = reader.ReadUInt16();
                _wFlagsKeyEx     = reader.ReadUInt16();
                _liNonce         = reader.ReadUInt64();
                _liTimeInit      = reader.ReadUInt64();
                _fCs             = reader.ReadUInt32();

                // read the spi header.
                authHdr._wType   = reader.ReadUInt16();
                authHdr._cbEnt   = reader.ReadUInt16();
            }            
            else
            {
                // set the default to the original auth data.
                authHdr._wType = SGMSG_TYPE_AUTHDATA2;
            }

            wAuthDataVersion = reader.ReadUInt16();
            if(wAuthDataVersion != XONLINE_AUTHDATA_VERSION) 
            {
                throw new ExceptionWithEventId(XEvent.Id.ARBITRATION_HACK_39, "SGInfo: Auth data from SG version (" 
                    + wAuthDataVersion + ") is incorrect!");
            }            

            wAuthDataSize    = reader.ReadUInt16();
            wMajorVersion    = reader.ReadUInt16();
            wMinorVersion    = reader.ReadUInt16();
            wBuildNumber     = reader.ReadUInt16();
            wQFENumber       = reader.ReadUInt16();
            dwTitleID        = reader.ReadUInt32();
            dwTitleVersion   = reader.ReadUInt32();
            dwTitleRegion    = reader.ReadUInt32();
            qwXboxID         = reader.ReadUInt64();

            // read users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {   
                // TODO change 0.0F with real userTrust in new auth data
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
            }
    
            // read services
            dwNumServices = reader.ReadUInt32();    
            dwServiceIds = new uint[XONLINE_MAX_NUMBER_SERVICE];
            for( int i = 0; i < XONLINE_MAX_NUMBER_SERVICE; i++ ) 
            {
                dwServiceIds[i]  = reader.ReadUInt32();
            }

            //  read additional auth data information for later auth data structures.
            if ( authHdr._wType  == SGMSG_TYPE_AUTHDATA2 )
            {
                // read user truct factors.
                for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
                {   
                    // set the user trust factor.
                    xUsers[i].userTrust = reader.ReadSingle();
                }                
            }

        }

        
        public override string ToString()
        {
            try
            {
                int i;
                bool b = false;
                StringBuilder bldr = new StringBuilder();


                bldr.Append("Current SGInfo:\r\n");
                bldr.Append("  TitleId:    0x" + TitleId.ToString("X") + "\r\n");
                bldr.Append("  TitleVer:   ");
                bldr.Append(dwTitleVersion.ToString("X"));
                bldr.Append("\r\n  TitleRgn:   ");
                bldr.Append(dwTitleRegion.ToString("X"));
                
                bldr.Append("\r\n  XboxLibVer: ");
                bldr.Append(wMajorVersion);
                bldr.Append(".");
                bldr.Append(wMinorVersion);
                bldr.Append(".");
                bldr.Append(wBuildNumber);
                bldr.Append(".");
                bldr.Append(wQFENumber);     
                
                bldr.Append("\r\n  MachineId: 0x" + MachineId.ToString("X") + "\r\n");
                bldr.Append("  ClientIP:  " + ClientIP.ToString() + "\r\n");
                for (i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers[i].qwUserID != 0)
                    {
                        bldr.Append("  U" + i.ToString() + ": 0x" + xUsers[i].qwUserID.ToString("X") + " (" + xUsers[i].dwUserFlags.ToString("X") + "," + xUsers[i].userTrust.ToString() + ")\r\n");
                        b = true;
                    }
                    
                }
                
                if (b == false)
                {
                    bldr.Append("  no users present.\r\n");
                }
                    
                b = false;
                for (i = 0; i < XONLINE_MAX_NUMBER_SERVICE; i++)
                {
                    if (dwServiceIds[i] != 0)
                    {
                        bldr.Append("  SVC" + i.ToString() + ": 0x" + dwServiceIds[i].ToString("X") + "\r\n");
                        b = true;
                    }
                }
                
                if (b == false)
                {
                    bldr.Append("  no services present (!!!! WTF ???  mcourage sucks)\r\n");
                }
                
                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToString(): " + e.ToString();
            }
        }

        // public accessors and helper methods
        public uint TitleId 
        {
            get { return dwTitleID; }
        }

        public uint TitleVersion
        {
            get { return dwTitleVersion; }
        }

        public ulong MachineId
        {
            get { return qwXboxID; }
        }

        public IPAddress ClientIP
        {
            get { return new IPAddress(_ipaI); }
        }

        public ulong TimeSessionStarted
        {
            get { return _liTimeInit; }
        }

        public XUIDAndTrust[] LogonUsers
        {
            get { return xUsers; }
        }
       
        public ulong Nonce
        {
            get { return _liNonce; }
        }

        public bool IsUserPresent(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return true;
                }
            }

            return false;
        }

        public bool CanUserPurchase(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId) 
                {
                    if(xUsers[i].CanPurchase())
                    {
                        return true;
                    }                     
                }
            }
            
            // user not found, or can't purchase
            return false;
        }

        public byte GetUserCountry(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return (xUsers[i].UserCountry());
                }
            }

            // user not found
            return 0;             
        }

        public float GetUserTrust(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return (xUsers[i].userTrust);
                }
            }

            // user not found
            return Single.NaN;             
        }

        public bool IsServicePresent(XOService serviceId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_NUMBER_SERVICE; i++ ) 
            {
                if(dwServiceIds[i] == (uint)serviceId) 
                {
                    return true;
                }
            }

            // service not found
            return false;             
        }

        public byte[] SignWithKey( byte[] data, int offset, int count )
        {
            return null;
        }

        //
        // Set of public functions to perform verification on users, machines, and titles.
        //  All of these functions will throw exceptions if data doesn't match.
        //

        
        public static void VerifyMachineId(ulong machineId)
        {
            if (AuthToggle.Off)
                return;
            
            SGInfo sg = SGInfo.Current;
            
            if( sg.MachineId != machineId ) 
            {
                throw new ExceptionWithEventId( XEvent.Id.ARBITRATION_HACK_40, "SGInfo.Verify: Machine " + machineId.ToString("X") + " cannot be verfied "
                    + "(SG says " + sg.MachineId.ToString("X") + ")");
            }
        }
    
        public static void VerifyServiceId(XOService serviceId)
        {
            if (AuthToggle.Off)
                return;
            
            SGInfo sg = SGInfo.Current;            
            
            if( !sg.IsServicePresent(serviceId) ) 
            {
                throw new ExceptionWithEventId( XEvent.Id.ARBITRATION_HACK_41, "SGInfo.Verify: Machine " + sg.MachineId.ToString("X") + 
                    " is not supposed to have access to this service ("+ (int)serviceId + ")");
            }        
        }
        
        public static void VerifyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;
            
            SGInfo sg = SGInfo.Current;            
            
            if( titleId != sg.TitleId )
            {
                throw new ExceptionWithEventId( XEvent.Id.ARBITRATION_HACK_42, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                    + ") cannot be verfied [" + "machine " + sg.MachineId.ToString("X") + "]");
            }
        }
        
        public static void VerifyTitleVersion(uint titleVersion)
        {
            if (AuthToggle.Off)
                return;
            
            SGInfo sg = SGInfo.Current;            
            
            if( titleVersion != sg.TitleVersion )
            {
                throw new ExceptionWithEventId( XEvent.Id.ARBITRATION_HACK_43, "SGInfo.Verify: Title Version *" + titleVersion.ToString("x") + "* (SG says " + sg.TitleVersion.ToString("x")
                    + ") cannot be verfied [" + "machine " + sg.MachineId + "]");
            }
        }
        
        public static void VerifyUserId(ulong passportId)
        {
            if (AuthToggle.Off)
                return;
            
            SGInfo sg = SGInfo.Current;            
            
            if( !sg.IsUserPresent(passportId) ) 
            {
                throw new ExceptionWithEventId( XEvent.Id.ARBITRATION_HACK_44, "SGInfo.Verify: *User " + passportId.ToString("X") + "* cannot be verified ["
                    + "machine " + sg.MachineId.ToString("X") + "; title " + sg.TitleId.ToString("X") + "]");
            }
        }

        public static void VerifyUserCountryId(ulong passportId, byte countryId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if ( countryId != sg.GetUserCountry(passportId) )
            {
                throw new ExceptionWithEventId( XEvent.Id.ARBITRATION_HACK_45,
                    "SGInfo.Verify: User country (" + passportId.ToString("x") +
                    ";" + countryId + ") cannot be verified [countryId " + 
                    sg.GetUserCountry(passportId) + "]");
            }
        }
    
        public static string ToStr()
        {
            try
            {
                return Current != null ? Current.ToString() : "(sgauth=off)";
            }
            catch(Exception e)
            {
                return "Error from SGInfo.ToString(). Exception:\n"+e.ToString();
            }
        }
    
        public static byte[] GetAuthData()
        {
            if (AuthToggle.Off)
            {
                return new byte[132];
            }

            SGInfo sg = SGInfo.Current;

            return sg.ConstructAuthData();
        }

        public byte[] ConstructAuthData()
        {
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            w.Write(wAuthDataVersion);
            w.Write(wAuthDataSize);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(qwXboxID);
            for (int i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }
            w.Write(dwNumServices);
            for (int i=0; i < dwServiceIds.Length; i++)
            {
                w.Write(dwServiceIds[i]);
            }
            for (int i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }
            
            return m.ToArray();
        }
        
        public static string ToBase64String()
        {
            if (AuthToggle.Off)
            {
                return "Auth Data is turned off!";
            }

            SGInfo sg = SGInfo.Current;

            return sg.ConstructBase64String();
        }

        public string ConstructBase64String()
        {
            MemoryStream m = new MemoryStream(200);
            BinaryWriter w = new BinaryWriter(m);
            w.Write(HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION);
            w.Write(_ipportI);
            w.Write(_ipaI);
            w.Write(_liNonce);
            w.Write(ConstructAuthData());

            return Convert.ToBase64String(m.ToArray());
        }
                
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\FuncXeGetRevocationList.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

using XOn = xonline.common.service.XOn;
using HResult = xonline.common.service.HResult;

namespace xCrypto.Functional
{
    /// <summary>
    ///     Functional test cases for the XeContentRefreshLicense API.
    /// </summary>
    [TestGroup, Owner("BenRan"), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class XeGetRevocationList : TestNode
    {
        public static Random rnd = new Random();
        private Digest[] baseDigestSet;

        public class DigestsMgr
        {
            private NpdbUtility npdb = new NpdbUtility();
            private List<Digest> _digests = new List<Digest>();

            public Digest[] Digests
            {
                get
                {
                    return _digests.ToArray();
                }
            }

            public int BlacklistedDigestsCount
            {
                get
                {
                    int count = 0;
                    foreach (Digest digest in _digests)
                    {
                        if (digest.ti_is_blacklisted == 1)
                        {
                            count++;
                        }
                    }

                    if (count > xonline.common.service.XOn.REVOCATION_LIST_MAX_ENTRIES)
                    {
                        Global.RO.Warn("BlacklistedDigestsCount found " + count + " entries blacklisted.");
                        Global.RO.Warn("REVOCATION_LIST_MAX_ENTRIES == " + XOn.REVOCATION_LIST_MAX_ENTRIES);
                    }
                    return count;
                }
            }

            public DigestsMgr()
            {
                npdb.ConnectToServer();
            }

            ~DigestsMgr()
            {
                npdb.Close();
            }

            /// <summary>
            /// Refresh the list of digests from NPDB
            /// </summary>
            public void RefreshDigests()
            {
		_digests.Clear();

                foreach (Digest digest in npdb.GetDigests())
                {
                    if (!ValidateDigest(digest))
                    {
                        throw new UnexpectedTestResultException("Invalid digest entry found");
                    }
                    _digests.Add(digest);
                }
            }

            public void AddDigestEntry(byte[] digest, bool isBlackListed)
            {
                Digest d = new Digest();
                d.bin_digests = digest;
                d.dt_Change_datetime = DateTime.UtcNow;
                d.ti_is_blacklisted = isBlackListed == true ? (short)1 : (short)0;
                d.ti_revocation_delivery_type = REVOCATION_DELIVERY_TYPE.GETREVOCATIONLIST;
                d.vc_revocation_reason = "GetRevocationFuncTests";

                if (!ValidateDigest(d.bin_digests, d.ti_is_blacklisted))
                {
                    throw new UnexpectedTestResultException("Attempting to add invalid digest entry.");
                }

                // Blacklist the digest
                npdb.BlacklistDigest(d.bin_digests, isBlackListed, d.ti_revocation_delivery_type, d.vc_revocation_reason);

                // And add it to our internal list
                _digests.Add(d);
            }

            public void AddTestDigests(int numEntries, bool isBlackListed)
            {
                Global.RO.Info("Creating " + (isBlackListed ? "" : "non-") + "blacklisted digests...");
                for (int i = 0; i < numEntries; i++)
                {
                    byte[] digest = new byte[20];
                    rnd.NextBytes(digest);
                    AddDigestEntry(digest, isBlackListed);
                }
                Global.RO.Info("Done.");
            }

            /// <summary>
            /// Delete all digests in this manager from NPDB
            /// </summary>
            public void DeleteDigests()
            {
                if (_digests != null)
                {
                    foreach (Digest digest in _digests)
                    {
                        npdb.DeleteDigest(digest.bin_digests);
                    }
                    _digests.Clear();
                }
            }

            private bool ValidateDigest(Digest digest)
            {
                return (ValidateDigest(digest.bin_digests, digest.ti_is_blacklisted));
            }

            private bool ValidateDigest(byte[] digest, short isBlackListed)
            {
                bool valid = true;
                valid &= digest.Length == 20;
                valid &= isBlackListed == 0 || isBlackListed == 1;
                return (valid);
            }

            public void UnblacklistDigest(byte[] digest)
            {
                npdb.BlacklistDigest(digest, false);
            }

            public void UnblacklistDigests()
            {
                Global.RO.Info("Unblacklisting all digests...");
                if (_digests != null)
                {
                    foreach (Digest digest in _digests)
                    {
                        UnblacklistDigest(digest.bin_digests);
                    }
                }
                Global.RO.Info("Done.");
            }
        }

        public static class GetRevocationListHelper
        {
            /// <summary>
            /// Refresh the Xbox FDs to cause them to reload the revocation list
            /// </summary>
            public static void RefreshFrontDoors()
            {
                Global.XEnv.ExecuteXmgmtCommand(Interface.xbos_billing_offering, "e :xbos digestload");
            }

            /// <summary>
            /// Generate a random nonce value to be used in the revocation list request.
            /// </summary>
            /// <returns>A valid random nonce</returns>
            public static byte[] GenerateRandomNonce()
            {
                byte[] clientNonce = new byte[xonline.common.service.XOn.REVOCATION_LIST_CLIENT_NONCE_SIZE];
                rnd.NextBytes(clientNonce);
                return clientNonce;
            }

            /// <summary>
            /// Request the revocation list from the server with the default settings.
            /// </summary>
            /// <returns>A response containing a list of blacklisted digests</returns>
            public static XeGetRevocationListRequest GetRevocationList()
            {
                return GetRevocationList(GenerateRandomNonce());
            }

            /// <summary>
            /// Request the revocation list from the server with a provided
            /// XeGetRevocationListRequest.
            /// </summary>
            /// <returns>A response containing a list of blacklisted digests</returns>
            public static XeGetRevocationListRequest GetRevocationList(XeGetRevocationListRequest revListReq)
            {
                return GetRevocationList(GenerateRandomNonce(), revListReq);
            }

            /// <summary>
            /// Request the revocation list from the server with the provided nonce
            /// </summary>
            /// <param name="nonce"></param>
            /// <returns>A response containing a list of blacklisted digests</returns>
            public static XeGetRevocationListRequest GetRevocationList(byte[] nonce)
            {
                XeGetRevocationListRequest revListReq = new XeGetRevocationListRequest();
                return GetRevocationList(nonce, revListReq);
            }

            /// <summary>
            /// Request the revocation list from the server with the provided 
            /// nonce and XeGetRevocationListRequest.
            /// </summary>
            /// <param name="Nonce"></param>
            /// <param name="revListReq"></param>
            /// <returns>A response containing a list of blacklisted digests</returns>
            public static XeGetRevocationListRequest GetRevocationList(byte[] Nonce, XeGetRevocationListRequest revListReq)
            {
                revListReq.clientNonce = (byte[])Nonce.Clone();
                if (!revListReq.Execute())
                {
                    throw new UnexpectedTestResultException("XeGetRevocationListRequest failed: " + revListReq.GetDumpString());
                }

                return revListReq;
            }

            /// <summary>
            /// Generate a string of error data containing information about the
            /// digest list and revocation list reply.
            /// </summary>
            /// <param name="reply"></param>
            /// <param name="digestsMgr"></param>
            /// <returns>A string of data indicating the system state</returns>
            public static string GenerateErrorData(XeGetRevocationListReply reply, DigestsMgr digestsMgr)
            {
                return GenerateErrorData(reply, digestsMgr, false);
            }

            /// <summary>
            /// Generate a string of error data containing information about the
            /// digest list and revocation list reply.
            /// </summary>
            /// <param name="reply"></param>
            /// <param name="digestsMgr"></param>
            /// <param name="verbose">
            /// Indicates whether detailed information about the contents of the
            /// lists should be included
            /// </param>
            /// <returns>A string of data indicating the system state</returns>
            public static string GenerateErrorData(XeGetRevocationListReply reply, DigestsMgr digestsMgr, Boolean verbose)
            {
                System.Text.StringBuilder errorMsg = new System.Text.StringBuilder();

                if (reply != null)
                {
                    errorMsg.AppendFormat("XeGetRevocationListReply.numListEntries = {0}.", reply.numListEntries);
                    errorMsg.AppendLine();

                    if (verbose)
                    {
                        foreach (RevocationListEntry entry in reply.entries)
                        {
                            errorMsg.AppendFormat("0x{0}; ", Hexer.tohex(entry.digest));
                        }
                        errorMsg.AppendLine();
                    }
                }

                if (digestsMgr != null)
                {
                    errorMsg.AppendFormat("DigestMgr - Digests.Length = {0}, BlacklistedDigestCount = {1}.", digestsMgr.Digests.Length, digestsMgr.BlacklistedDigestsCount);
                    errorMsg.AppendLine();

                    if (verbose)
                    {
                        foreach (Digest digest in digestsMgr.Digests)
                        {
                            errorMsg.AppendFormat("0x{0}; ", Hexer.tohex(digest.bin_digests));
                        }
                        errorMsg.AppendLine();
                    }
                }

                return errorMsg.ToString();
            }

            /// <summary>
            /// Validates that a given revocation list response matches the
            /// expected results given what is stored in the Digests Manager
            /// </summary>
            /// <param name="revListResp">The response to validate</param>
            /// <param name="digestsMgr">The digest manager to validate against</param>
            public static void ValidateRevocationList(XeGetRevocationListReply revListResp, DigestsMgr digestsMgr)
            {
                ValidateRevocationList(revListResp, digestsMgr, false, false);
            }

            /// <summary>
            /// Validates that a given revocation list response matches the
            /// expected results given what is stored in the Digests Manager
            /// </summary>
            /// <param name="revListResp">The response to validate</param>
            /// <param name="digestsMgr">The digest manager to validate against</param>
            /// <param name="allowReplySubset">
            /// If true, the number of items in the response is not expected to 
            /// be the same as the number of items in the local cache
            /// </param>
            public static void ValidateRevocationList(XeGetRevocationListReply revListResp, DigestsMgr digestsMgr, Boolean allowReplySubset)
            {
                ValidateRevocationList(revListResp, digestsMgr, allowReplySubset, false);
            }

            /// <summary>
            /// Validates that a given revocation list response matches the
            /// expected results given what is stored in the Digests Manager
            /// </summary>
            /// <param name="revListResp">The response to validate</param>
            /// <param name="digestsMgr">The digest manager to validate against</param>
            /// <param name="allowReplySubset">
            /// If true, the number of items in the response is not expected to 
            /// be the same as the number of items in the local cache
            /// </param>
            /// <param name="verbose">
            /// If true, verbose error data is generated on failure
            /// </param>
            public static void ValidateRevocationList(XeGetRevocationListReply revListResp, DigestsMgr digestsMgr, Boolean allowReplySubset, Boolean verbose)
            {
                // If we expect a full response from the server, then the response
                // count should be the same as the number of blacklisted digests
                // we have stored locally
                if (!allowReplySubset && revListResp.numListEntries != digestsMgr.BlacklistedDigestsCount)
                {
                    string errorMsg = "GetRevocationList did not return expected digest count.\n";
                    errorMsg += GenerateErrorData(revListResp, digestsMgr, verbose);
                    throw new UnexpectedTestResultException("ValidateRevocationList failed: " + errorMsg);
                }

                // If we're only expected a subset (i.e. if we're above the max
                // response length), then the response list size should be less
                // then the number of blacklisted digests we have uploaded.
                if (allowReplySubset && revListResp.numListEntries > digestsMgr.BlacklistedDigestsCount)
                {
                    string errorMsg = "GetRevocationList returned more results than expected.";
                    errorMsg += GenerateErrorData(revListResp, digestsMgr, verbose);
                    throw new UnexpectedTestResultException("ValidateRevocationList failed: " + errorMsg);
                }

                // Every single digest that comes back in the response should be
                // blacklisted so we need to ensure that they match the expected
                // results that we're maintaining locally.
                // We don't need to check that every expected digests is present
                // because assuming allowReplySubset is false, we already check 
                // that there are the same number of blacklisted digests in the 
                // response as expected, and we check that every digest returned
                // in the response is expected to be there.
                foreach (RevocationListEntry replyEntry in revListResp.entries)
                {
                    bool found = false;
                    foreach (Digest digest in digestsMgr.Digests)
                    {
                        if (ArrayEx.Equals(digest.bin_digests, replyEntry.digest))
                        {
                            // If this digest is marked as not blacklisted, it
                            // should not be part of the result set
                            if (digest.ti_is_blacklisted == 0)
                            {
                                throw new UnexpectedTestResultException(String.Format(
                                    "Unblacklisted digests found in response: 0x{0}",
                                    Hexer.tohex(digest.bin_digests)));
                            }
                            found = true;
                            break;
                        }
                    }

                    if (!found)
                    {
                        throw new UnexpectedTestResultException(String.Format(
                            "Unexpected digest found in response: 0x{0}\n{1}",
                            Hexer.tohex(replyEntry.digest),
                            GenerateErrorData(revListResp, digestsMgr, true)));
                    }
                }
            }
        }

        static public void DbgClearServerBlacklist(DigestsMgr digestsMgr)
        {
            XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();

            foreach (RevocationListEntry entry in revListReq.Response.entries)
            {
                digestsMgr.UnblacklistDigest(entry.digest);
                System.Threading.Thread.Sleep(200);
            }
            GetRevocationListHelper.RefreshFrontDoors();
            System.Threading.Thread.Sleep(200);

            digestsMgr.RefreshDigests();
            digestsMgr.DeleteDigests();
        }

        static public void SafeRemoveAllDigests(DigestsMgr digestsMgr)
        {
            digestsMgr.UnblacklistDigests();
            GetRevocationListHelper.RefreshFrontDoors();
            digestsMgr.DeleteDigests();
        }

        public override void PreRun()
        {
            Global.RO.Info("Backing up existing Blacklist...");
            using(NpdbUtility npdb = new NpdbUtility())
            {
                npdb.ConnectToServer();
                // Get the current blacklist from the server
                baseDigestSet = npdb.GetDigests();

                // Delete them all from the database
                foreach (Digest d in baseDigestSet)
                {
                    npdb.DeleteDigest(d.bin_digests);
                }

                // Force a refresh of the front doors
                GetRevocationListHelper.RefreshFrontDoors();
            }
        }

        public override void PostRun()
        {
            Global.RO.Info("Restoring existing Blacklist...");
            using (NpdbUtility npdb = new NpdbUtility())
            {
                npdb.ConnectToServer();
                // Add all the digests back into the database
                // NOTE: They will have different times, but whateva.
                foreach (Digest digest in baseDigestSet)
                {
                    npdb.BlacklistDigest(digest.bin_digests, digest.ti_is_blacklisted == 1, digest.ti_revocation_delivery_type, digest.vc_revocation_reason);
                }

                // And refresh the front doors again
                GetRevocationListHelper.RefreshFrontDoors();
            }
        }

        [TestCase, TestCasePriority(1)]
        class P_Mainline_25_Blacklisted_25_Nonblacklisted : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, true);
                digestsMgr.AddTestDigests(25, false);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_0_Digests : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Verify there are no digests in the database
                digestsMgr.RefreshDigests();
                if (digestsMgr.Digests.Length != 0)
                {
                    SafeRemoveAllDigests(digestsMgr);
                    digestsMgr.RefreshDigests();
                }

                // Execute GetRevocationList and validate the response
                XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();
                GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_25_Blacklisted_0_Nonblacklisted : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, true);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_0_Blacklisted_25_Nonblacklisted : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, false);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_400_Blacklisted_0_Nonblacklisted : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(400, true);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_400_Blacklisted_100_Nonblacklisted : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(400, true);
                digestsMgr.AddTestDigests(100, false);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_500_Blacklisted_0_Nonblacklisted : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(500, true);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList();
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr, true);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_MinNonce : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, true);
                digestsMgr.AddTestDigests(25, false);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    byte[] clientNonce = new byte[xonline.common.service.XOn.REVOCATION_LIST_CLIENT_NONCE_SIZE];
                    for (int i = 0; i < clientNonce.Length; i++)
                    {
                        clientNonce[i] = 0x00;
                    }
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList(clientNonce);
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        [TestCase, TestCasePriority(3)]
        class P_MaxNonce : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, true);
                digestsMgr.AddTestDigests(25, false);
                GetRevocationListHelper.RefreshFrontDoors();

                try
                {
                    // Execute GetRevocationList and validate the response
                    byte[] clientNonce = new byte[xonline.common.service.XOn.REVOCATION_LIST_CLIENT_NONCE_SIZE];
                    for (int i = 0; i < clientNonce.Length; i++)
                    {
                        clientNonce[i] = 0xFF;
                    }
                    XeGetRevocationListRequest revListReq = GetRevocationListHelper.GetRevocationList(clientNonce);
                    GetRevocationListHelper.ValidateRevocationList(revListReq.Response, digestsMgr);
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        private class XeGetRevocationListRequest_N_PayloadEmpty : XeGetRevocationListRequest
        {
            public override void WriteStream(BinaryWriter binaryWriter)
            {
                // Intentionally write out nothing
            }
        }

        [TestCase, TestCasePriority(3)]
        class N_PayloadEmpty : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, true);
                digestsMgr.AddTestDigests(25, false);
                GetRevocationListHelper.RefreshFrontDoors();

                XeGetRevocationListRequest_N_PayloadEmpty revListReqEmpty =
                    new XeGetRevocationListRequest_N_PayloadEmpty();
                try
                {
                    // Execute GetRevocationList and validate the error
                    GetRevocationListHelper.GetRevocationList(revListReqEmpty);
                }
                catch
                {
                    if (revListReqEmpty.XErr != HResult.XONLINE_E_END_OF_STREAM)
                    {
                        throw;
                    }
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        private class XeGetRevocationListRequest_N_PayloadTooSmall : XeGetRevocationListRequest
        {
            public override void WriteStream(BinaryWriter binaryWriter)
            {
                // Intentionally write out too little
                byte[] trashData = new byte[10];
                rnd.NextBytes(trashData);
                binaryWriter.Write(trashData);
            }
        }

        [TestCase, TestCasePriority(3)]
        class N_PayloadTooSmall : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, true);
                digestsMgr.AddTestDigests(25, false);
                GetRevocationListHelper.RefreshFrontDoors();

                XeGetRevocationListRequest_N_PayloadTooSmall revListReqTooSmall =
                    new XeGetRevocationListRequest_N_PayloadTooSmall();
                try
                {
                    // Execute GetRevocationList and validate the error
                    GetRevocationListHelper.GetRevocationList(revListReqTooSmall);
                }
                catch
                {
                    if (revListReqTooSmall.XErr != HResult.XONLINE_E_END_OF_STREAM)
                    {                        
                        throw;
                    }
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }

        private class XeGetRevocationListRequest_N_PayloadTooLarge : XeGetRevocationListRequest
        {
            public override void WriteStream(BinaryWriter binaryWriter)
            {
                binaryWriter.Write(clientNonce);
                // Intentionally write out too much
                byte[] trashData = new byte[20];
                rnd.NextBytes(trashData);
                binaryWriter.Write(trashData);
            }
        }

        [TestCase, TestCasePriority(3)]
        class N_PayloadTooLarge : TestNode
        {
            public override void Run()
            {
                DigestsMgr digestsMgr = new DigestsMgr();

                // Add blacklisted test data
                digestsMgr.AddTestDigests(25, true);
                digestsMgr.AddTestDigests(25, false);
                GetRevocationListHelper.RefreshFrontDoors();

                XeGetRevocationListRequest_N_PayloadTooLarge revListReqTooLarge =
                    new XeGetRevocationListRequest_N_PayloadTooLarge();
                try
                {
                    // Execute GetRevocationList and validate the error
                    GetRevocationListHelper.GetRevocationList(revListReqTooLarge);
                }
                catch
                {
                    if (revListReqTooLarge.XErr != HResult.XONLINE_E_ORANGE_INVALID_REQUEST)
                    {
                        throw;
                    }
                }
                finally
                {
                    // Let the server see them all as unblacklisted then remove entries from NPDB
                    SafeRemoveAllDigests(digestsMgr);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\FuncXeContentRefreshLicense.cs ===
using System;
using System.IO;
using System.Diagnostics;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.config;
using XOn = xonline.common.service.XOn;

namespace xCrypto.Functional
{
    /// <summary>
    ///     Functional test cases for the XeContentRefreshLicense API.
    /// </summary>
    
    // Test Suite turned off pending the rewrite of the suite so that it is scoped correctly to the existing functionality.  See bug 135070
    
    //[TestGroup, Owner("BenRan"), TestFrequency("Regression"), EnvRequirement("Billing")]
    public class XeContentRefreshLicense : TestNode
    {
        private const uint _defaultTitle = 0x2D5A7D4A;
        private static bool nCipherEnabled = false;
        //public const ulong ConsoleId =0x56d0d03070000f0;
        public static string CONSOLE_ID = "XE.024195370001";
        public const uint TITLE_ID = 0x584107D8;  // JOUST
        //public const ulong OFFER_ID = 0x584107D800000001; // JOUST DOWNLOAD, Price is 400 points, license bit 1
        public const ulong OFFER_ID = 0xFFFE07D1000000B1; // JOUST DOWNLOAD, Price is 400 points, license bit 1
        public const ulong OFFER_ID_TRIAL = 0x584107D800000000; // JOUST free trial with unrestricted license. license bit 0
        //public const byte[] CONTENT_ID = { 0x17, 0x4A, 0x13, 0x38, 0xC5, 0xFA, 0x52, 0xE1, 0x51, 0x59, 0xF1, 0x3A, 0x2A, 0xE3, 0x99, 0x4A, 0xEA, 0x7D, 0x4E, 0x71 };
        //public static readonly byte[] CONTENT_ID = new byte[] { 0x49, 0xA4, 0x30, 0x28, 0xF0, 0xD5, 0x6A, 0x4B, 0xC7, 0x55, 0xC1, 0x4B, 0x36, 0x3E, 0x42, 0xB8, 0xC8, 0x44, 0xFC, 0x11 }; // the correct content id
        public static byte[] CONTENT_ID = new byte[20];
        public static byte[] CONTENT_ID_UPDATE = new byte[20];


        [TestGroupSetup]
        public void Setup()
        {
            //
            // Check the database to see if the ncipher or testkey is enabled.
            //
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            Global.RO.Fatal("Detecting Ncipher state.");
            string testKey = @"SELECT vc_value FROM t_environment_type_setting_overrides 
                                    WHERE vc_setting = 'xcrypto_useTestKey'";

            string nCipherKey = @"SELECT vc_value FROM t_environment_type_setting_overrides 
                                    WHERE vc_setting = 'xcrypto_useNCipher'";

            int result = Convert.ToInt32(npdb.ExecuteScalar(testKey));
            if (result == 1)
            {
                Global.RO.Fatal("TestKey is Enabled for this environment.");
                nCipherEnabled = false;
            }
            result = Convert.ToInt32(npdb.ExecuteScalar(nCipherKey));
            if (result == 1)
            {
                Global.RO.Fatal("nCipherKey is Enabled for this environment.");
                nCipherEnabled = true;
            }

            // 
            // Gather the content data from UODB rather than hardcoding it.
            //
            Global.RO.Fatal("Detecting ContentId for OfferId[0x584107D800000001]");
            UodbTable contentDetailsTable = new UodbTable("t_offer_content_details");
            contentDetailsTable.SetConstraint("bi_offer_id", 0x584107D800000001);
            UodbWS.ExecuteSQLSelect(contentDetailsTable);
            CONTENT_ID = (byte[])contentDetailsTable.GetProperty("b_content_id");
            Global.RO.Fatal(contentDetailsTable.ToString());

            Global.RO.Fatal("Detecting ContentId for OfferId[0x584107D800000000]");
            UodbTable contentUpdateDetailsTable = new UodbTable("t_offer_content_details");
            contentUpdateDetailsTable.SetConstraint("bi_offer_id", 0x584107D800000000);
            UodbWS.ExecuteSQLSelect(contentUpdateDetailsTable);
            CONTENT_ID_UPDATE = (byte[])contentUpdateDetailsTable.GetProperty("b_content_id");
            Global.RO.Fatal(contentUpdateDetailsTable.ToString());


        }

        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        ////////////////////////////////////////////////////////////////////////////
        // supporting functions

        public static void Createtitle(uint titleId)
        {
            XbosTitle title = new XbosTitle(titleId);
            title.RatingId = 1;
            title.Create();
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id)
        {
            CreateContentOffer(titleid, offerid, content_id, DateTime.UtcNow.AddYears(-1), DateTime.UtcNow.AddYears(1));
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, int paymentType)
        {
            string content_xrl = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";
            CreateContentOffer(titleid, offerid, content_id, content_xrl, (int)OfferPolicies.PerMachineRights, 0,
                DateTime.UtcNow.AddYears(-1), DateTime.UtcNow.AddYears(1), 0, paymentType, true);
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, DateTime startDate, DateTime endDate)
        {
            CreateContentOffer(titleid, offerid, content_id, startDate, endDate, true);
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, DateTime startDate, DateTime endDate, bool cacheFlush)
        {
            string content_xrl = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";
            CreateContentOffer(titleid, offerid, content_id, content_xrl, (int)OfferPolicies.PerMachineRights, 0, startDate, endDate, 0, (int)PaymentTypeEnum.Points, cacheFlush);
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, string content_xrl, int policyflags, int licensebits)
        {
            CreateContentOffer(titleid, offerid, content_id, content_xrl, policyflags, licensebits, 0);
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, string content_xrl, int policyflags, int licensebits, int priceWhole)
        {
            CreateContentOffer(titleid, offerid, content_id, content_xrl, policyflags, licensebits, DateTime.UtcNow.AddYears(-1), DateTime.UtcNow.AddYears(1), priceWhole);
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, string content_xrl, int policyflags, int licensebits, DateTime endDate)
        {
            CreateContentOffer(titleid, offerid, content_id, content_xrl, policyflags, licensebits, DateTime.UtcNow.AddYears(-1), endDate, 0);
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, string content_xrl,
            int policyflags, int licensebits, DateTime startDate, DateTime endDate, int priceWhole)
        {
            CreateContentOffer(titleid, offerid, content_id, content_xrl, policyflags, licensebits, startDate, endDate, priceWhole, (int)PaymentTypeEnum.Points, true);
        }

        public static void CreateContentOffer(uint titleid, ulong offerid, byte[] content_id, string content_xrl,
            int policyflags, int licensebits, DateTime startDate, DateTime endDate, int priceWhole, int paymentType, bool cacheFlush)
        {
            XbosOffer offer = new XbosOffer(titleid, offerid);
            offer.TierRequired = (int)TierEnum.All;
            offer.PolicyFlags = policyflags;
            offer.LicenseBits = licensebits;
            offer.RegionStartDate = startDate;
            offer.RegionEndDate = endDate;
            offer.OfferStartDate = startDate;
            offer.OfferEndDate = endDate;
            // OfferRegions is a bit different. By default only the element of the OfferRegions array is used.
            ((XbosOffer.OfferRegion)offer.OfferRegions[0]).PaymentType = paymentType;
            ((XbosOffer.OfferRegion)offer.OfferRegions[0]).PriceWhole = priceWhole;

            // create this offer with a content
            offer.CreateWithContent(content_id, content_xrl);

            if (cacheFlush)
            {
                // the offers are cached by Offer.CreateInstance(), have to flush them
                Global.XEnv.ExecuteXmgmtCommand(Interface.xbos_billing_offering, "e :xbos CacheFlush");
            }
        }

        /////////////////////////////////////////////////////////////////////////////////
        // Positive cases

        public static void CheckLicenseBody(ContentLicenseBody expect, ContentLicenseBody body)
        {
            ValueCheck.Test("Body SizeOfHeaders", expect.SizeOfHeaders, body.SizeOfHeaders);
            ValueCheck.Test("Body content id", expect.ContentId, body.ContentId);
            ValueCheck.Test("Body number filled licensees", expect.GetUsedLicenseeCount(), body.GetUsedLicenseeCount());
            int count = expect.GetUsedLicenseeCount();
            ContentLicensee lee = null;
            for (int i = 0; i < count; i++)
            {
                bool found = false;
                lee = expect.licensees[i];
                for (int j = 0; j < count; j++)
                {
                    if (lee.Compare(body.licensees[j]))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                    throw new UnexpectedTestResultException(string.Format("CheckLicenseBody failed (Licensees - {0}): index {1} in expect license body.", count, i));
            }
        }

        public static void CheckPositive(XeUser user, ContentLicense expectLicense, ContentLicense license, bool valueCheck)
        {
            XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
            XRLXeContentRefreshLicenseResponse response = new XRLXeContentRefreshLicenseResponse();

            request.UserId = user.UserPuid;
            request.MachineId = user.MachinePuid;
            request.License = license.ToArray();

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeContentRefreshLicense execute failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentRefreshLicense returned XErr=0x{0:x}", request.XErr));

            //license = new ContentLicense();
            license.ReadBytes(response.License);

            if (valueCheck)
            {
                // This used to be an issue, and you had to compile the tests based on which way you wanted to run 
                // them. Updated the setup to read the db to see which key is currently enabled.
                if (nCipherEnabled)
                {
                    ValueCheck.IsTrue(SignatureUtil.VerifySignatureDrmNCipher(license.body.ToArray(), license.signature.signature), "Verify signature failed.");
                }
                else
                {
                    ValueCheck.Test("Signature type", expectLicense.signature.signatureType, license.signature.signatureType);
                }

                CheckLicenseBody(expectLicense.body, license.body);
            }
        }

        [TestCase, TestCasePriority(1)]
        class P_Mainline : TestBase
        {
            override protected void Execute()
            {
                XeUser user = XbosUser.XenonSilverUser();
                user.AddPoints_500();
                XbosOffer.OfferPurchase(OFFER_ID, user);

                ContentLicense license = new ContentLicense();
                license.signature.signatureType = ContentLicense.RevertByteOrder(ContentLicense.LicenseTypeLive);   // make the live signature type
                //license.body.ContentId = new byte[] { 0x49, 0xA4, 0x30, 0x28, 0xF0, 0xD5, 0x6A, 0x4B, 0xC7, 0x55, 0xC1, 0x4B, 0x36, 0x3E, 0x42, 0xB8, 0xC8, 0x44, 0xFC, 0x11 }; // the correct content id
                license.body.ContentId = CONTENT_ID;// new byte[] { 0xD0, 0xF1, 0xF6, 0xD2, 0x57, 0x69, 0x8C, 0x69, 0x40, 0x21, 0xB8, 0x08, 0xB0, 0x96, 0xAD, 0x87, 0xC1, 0xCC, 0xF2, 0x34 };

                XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                XRLXeContentRefreshLicenseResponse response = new XRLXeContentRefreshLicenseResponse();

                request.UserId = user.UserPuid;
                request.MachineId = user.MachinePuid;
                request.License = license.ToArray();

                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeContentRefreshLicense execute failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeContentRefreshLicense returned XErr=0x{0:x}", request.XErr));

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This testcase may fail if the real private key is being used on testnet. 
        /// Bug 47651
        /// Restricted  and non restricted offers for same content. Call twice: invalid license -> valid license -> refresh again
        /// Also verify user license overwritten and unrestricted license overwritten. And P_Invalid_UserPuid
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_SignatureInvalid_SilverUser : TestBase
        {
            override protected void Execute()
            {
                XeUser user = XbosUser.XenonSilverUser();
                user.AddPoints_500();
                //user.MachinePuid = 0xFA00000000000000;
                XbosOffer.OfferPurchase(OFFER_ID, user);

                ContentLicense license = new ContentLicense();
                license.signature.signatureType = ContentLicense.RevertByteOrder(ContentLicense.LicenseTypeLive);   // make the live signature type
                license.body.ContentId = CONTENT_ID; // new byte[] { 0x49, 0xA4, 0x30, 0x28, 0xF0, 0xD5, 0x6A, 0x4B, 0xC7, 0x55, 0xC1, 0x4B, 0x36, 0x3E, 0x42, 0xB8, 0xC8, 0x44, 0xFC, 0x11 }; // the correct content id

                ulong consoleId = XbosOffer.ConvertConsoleIdFromDecimalStringToUInt64(CONSOLE_ID);
                // licensee table order: unrestricted, user id, console id
                ContentLicense expectLicense = new ContentLicense(true);
                expectLicense.body.ContentId = (byte[])license.body.ContentId.Clone();
                expectLicense.body.licensees[0].licenseeId = ContentLicense.RevertByteOrder(ContentLicense.UnrestrictedLicensee);// license bit is 0 for free game
                expectLicense.body.licensees[1].licenseeId = ContentLicense.RevertByteOrder(user.UserPuid);
                expectLicense.body.licensees[1].licenseBits = ContentLicense.RevertByteOrder((uint)1);  // license bit is 1 for full game
                expectLicense.body.licensees[1].licenseFlags = ContentLicense.RevertByteOrder((uint)ContentLicense.LicenseFlagRequireOnline);
                expectLicense.body.licensees[2].licenseeId = ContentLicense.RevertByteOrder(consoleId);
                expectLicense.body.licensees[2].licenseBits = ContentLicense.RevertByteOrder((uint)1);  // license bit is 1 for full game

                //call it the first time
                CheckPositive(user, expectLicense, license, true);
                Global.RO.Info("The first check done.");
                // call it the second time with the new license, everything should keep the same
                CheckPositive(user, expectLicense, license, true);
                Global.RO.Info("The second check done.");

                // call it the third time with an invalid user puid, everything should keep the same
                user.UserPuid = 0xbad1d;
                CheckPositive(user, expectLicense, license, true);
                Global.RO.Info("The third check done.");
                user.UserPuid = 0;
                CheckPositive(user, expectLicense, license, true);
                Global.RO.Info("The fourth check done.");

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Gold user. Initial signature type = 0. Free trial to full game.
        /// Also verify unrestricted license only.
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_LicenseBlank_GoldUser : TestBase
        {
            override protected void Execute()
            {
                XeUser user = XbosUser.XenonGoldUser();
                user.MachinePuid = user.MachinePuid;
                user.AddPoints_500();

                // first the trial game
                XbosOffer.OfferPurchase(OFFER_ID_TRIAL, user);
                ContentLicense license = new ContentLicense();  // signature type = 0
                license.body.ContentId = CONTENT_ID; // new byte[] { 0x49, 0xA4, 0x30, 0x28, 0xF0, 0xD5, 0x6A, 0x4B, 0xC7, 0x55, 0xC1, 0x4B, 0x36, 0x3E, 0x42, 0xB8, 0xC8, 0x44, 0xFC, 0x11 }; // the correct content id

                ulong consoleId = XbosOffer.ConvertConsoleIdFromDecimalStringToUInt64(CONSOLE_ID);
                // licensee table order: unrestricted, user id, console id
                ContentLicense expectLicense = new ContentLicense(true);
                expectLicense.body.ContentId = (byte[])license.body.ContentId.Clone();
                expectLicense.body.licensees[0].licenseeId = ContentLicense.RevertByteOrder(ContentLicense.UnrestrictedLicensee);

                CheckPositive(user, expectLicense, license, true);
                // unrestricted license overwritten
                CheckPositive(user, expectLicense, license, true);

                // then purchase the full game
                XbosOffer.OfferPurchase(OFFER_ID, user);

                // licensee table order: unrestricted, user id, console id
                expectLicense.body.licensees[1].licenseeId = ContentLicense.RevertByteOrder(user.UserPuid);
                expectLicense.body.licensees[1].licenseBits = ContentLicense.RevertByteOrder((uint)1);  // license bit is 1 for full game
                expectLicense.body.licensees[1].licenseFlags = ContentLicense.RevertByteOrder((uint)ContentLicense.LicenseFlagRequireOnline);
                expectLicense.body.licensees[2].licenseeId = ContentLicense.RevertByteOrder(consoleId);
                expectLicense.body.licensees[2].licenseBits = ContentLicense.RevertByteOrder((uint)1);  // license bit is 1 for full game

                CheckPositive(user, expectLicense, license, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Unrestricted license with a cost
        /// Also verify invalid user puid.
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_UnrestrictedLicense_Cost : TestBase
        {
            override protected void Execute()
            {
                uint TITLE_ID = _defaultTitle;
                UInt32 licenseBitsOfferA = 3;
                ulong OFFER_IDA = ((ulong)TITLE_ID << 32) + 1;
                string CONTENT_XRL1 = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";
                byte[] content_id = new byte[20];
                Random r = new Random((int)DateTime.UtcNow.Ticks);
                r.NextBytes(content_id);
                Createtitle(TITLE_ID);
                CreateContentOffer(TITLE_ID, OFFER_IDA, content_id, CONTENT_XRL1,
                    (int)(OfferPolicies.Unrestricted), (int)licenseBitsOfferA, 10); // price is 10 for a unrestricted license. price should be ignored.

                XeUser user = XbosUser.XenonGoldUser();
                user.AddPoints_500();
                user.MachinePuid = user.MachinePuid;
                XbosOffer.OfferPurchase(OFFER_IDA, user);

                ContentLicense license = new ContentLicense();
                license.signature.signatureType = ContentLicense.RevertByteOrder(ContentLicense.LicenseTypeLive);   // make the live signature type
                license.body.ContentId = content_id;

                // licensee table order: unrestricted, user id, console id
                ContentLicense expectLicense = new ContentLicense(true);
                expectLicense.body.ContentId = (byte[])license.body.ContentId.Clone();
                expectLicense.body.licensees[0].licenseeId = ContentLicense.RevertByteOrder(ContentLicense.UnrestrictedLicensee);
                expectLicense.body.licensees[0].licenseBits = ContentLicense.RevertByteOrder((uint)licenseBitsOfferA);

                //call it the first time
                CheckPositive(user, expectLicense, license, true);
                // call it the second time with the new license, everything should keep the same
                CheckPositive(user, expectLicense, license, true);

                // call it the third time with an invalid user puid, everything should keep the same
                user.UserPuid = 0;
                CheckPositive(user, expectLicense, license, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Offers: 2 unrestricted offers, 2 per-machine offers, 2 per-user offers, 2 per-machine/per-user offers
        /// Stages: 1 - 1 unrestricted, 1 per-machine, 1 per-user, 1 per-machine/user
        ///         2 - 1 unrestricted, 1 per-machine, 1 per-user, 1 per-machine/user
        /// Users: 7 gold users, 7 silver users
        /// Consoles: 3 
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_Licensee_MoreThan16 : TestBase
        {
            private int NewBit(int index)
            {
                int ret = 1;
                for (int i = 0; i < index; i++)
                {
                    ret = 2 * ret;
                }
                return ret;
            }

            override protected void Execute()
            {
                string consoleId1 = "XE.024195370001";  // retail console id
                string consoleId2 = "XE.026883848760";  // retail console id
                string consoleId3 = "XE.024194364980";  // retail console id
                ulong machineId1 = XbosUser.DefaultMachinePuid;
                ulong machineId2 = machineId1 + 1;
                ulong machineId3 = machineId1 + 2;
                // prepare 3 consoles
                XbosWS.AddConsoleId(machineId1, consoleId1);
                XbosWS.AddConsoleId(machineId2, consoleId2);
                XbosWS.AddConsoleId(machineId3, consoleId3);
                ulong console1 = XbosOffer.ConvertConsoleIdFromDecimalStringToUInt64(consoleId1);
                ulong console2 = XbosOffer.ConvertConsoleIdFromDecimalStringToUInt64(consoleId2);
                ulong console3 = XbosOffer.ConvertConsoleIdFromDecimalStringToUInt64(consoleId3);

                // 12 users
                /*
                XeUser userS1 = XbosUser.XenonSilverUser(machineId1);
                XeUser userG1 = XbosUser.XenonSilverUser(machineId1);
                XeUser userS2 = XbosUser.XenonSilverUser(machineId2);
                XeUser userG2 = XbosUser.XenonSilverUser(machineId2);
                XeUser userS3 = XbosUser.XenonSilverUser(machineId3);
                XeUser userG3 = XbosUser.XenonSilverUser(machineId3);
                XeUser userS4 = XbosUser.XenonSilverUser(machineId1);
                XeUser userG4 = XbosUser.XenonSilverUser(machineId1);
                XeUser userS5 = XbosUser.XenonSilverUser(machineId2);
                XeUser userG5 = XbosUser.XenonSilverUser(machineId2);
                XeUser userS6 = XbosUser.XenonSilverUser(machineId3);
                XeUser userG6 = XbosUser.XenonSilverUser(machineId3);
                XeUser userS7 = XbosUser.XenonSilverUser(machineId2);
                XeUser userG7 = XbosUser.XenonSilverUser(machineId3);
                */
                XeUser userS1 = XbosUser.XenonSilverUser(machineId1);
                userS1.AddPoints_500();
                XeUser userG1 = XbosUser.XenonGoldUser(machineId1);
                userG1.AddPoints_500();
                XeUser userS2 = XbosUser.XenonSilverUser(machineId2);
                userS2.AddPoints_500();
                XeUser userG2 = XbosUser.XenonGoldUser(machineId2);
                userG2.AddPoints_500();
                XeUser userS3 = XbosUser.XenonSilverUser(machineId3);
                userS3.AddPoints_500();
                XeUser userG3 = XbosUser.XenonGoldUser(machineId3);
                userG3.AddPoints_500();
                XeUser userS4 = XbosUser.XenonSilverUser(machineId1);
                userS4.AddPoints_500();
                XeUser userG4 = XbosUser.XenonGoldUser(machineId1);
                userG4.AddPoints_500();
                XeUser userS5 = XbosUser.XenonSilverUser(machineId2);
                userS5.AddPoints_500();
                XeUser userG5 = XbosUser.XenonGoldUser(machineId2);
                userG5.AddPoints_500();
                XeUser userS6 = XbosUser.XenonSilverUser(machineId3);
                userS6.AddPoints_500();
                XeUser userG6 = XbosUser.XenonGoldUser(machineId3);
                userG6.AddPoints_500();
                XeUser userS7 = XbosUser.XenonSilverUser(machineId2);
                userS7.AddPoints_500();
                XeUser userG7 = XbosUser.XenonGoldUser(machineId3);
                userG7.AddPoints_500();

                // 14 offers
                uint TITLE_ID = _defaultTitle;
                //UInt32 licenseBitsOfferA = 1;
                ulong OFFER_IDA = ((ulong)TITLE_ID << 32) + 1;
                string CONTENT_XRL1 = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";
                byte[] content_id = new byte[20];
                Random r = new Random((int)DateTime.UtcNow.Ticks);
                r.NextBytes(content_id);
                Createtitle(TITLE_ID);

                int i = 0; int count;
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.Unrestricted), NewBit(i));
                }
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.PerMachineRights), NewBit(i), 5);
                }
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.PerUserRights), NewBit(i), 10);
                }
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.PerMachineRights | OfferPolicies.PerUserRights), NewBit(i), 15);
                }

                // start to check license
                ulong offerId; XeUser user;
                ContentLicense license = new ContentLicense(true);
                license.body.ContentId = content_id;
                ContentLicense expectLicense = new ContentLicense(true);
                expectLicense.body.ContentId = content_id;

                offerId = OFFER_IDA + 3; user = userS1;
                //ContentOfferLoader.GrantContentLicense(user.UserPuid, user.MachinePuid, offerId);
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console1
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, silver, console1", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 3, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 2; user = userG1;
                //ContentOfferLoader.GrantContentLicense(user.UserPuid, user.MachinePuid, offerId);
                XbosOffer.OfferPurchase(offerId, user);   // user, console1
                Global.RO.Info("Offer - 0x{0:X} per-user, user - 0x{1:X}, gold, console1", offerId, user.UserPuid);
                CheckPositive(userG1, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 4, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 3; user = userS2;
                //ContentOfferLoader.GrantContentLicense(user.UserPuid, user.MachinePuid, offerId);
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console2
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, silver, console2", offerId, user.UserPuid);
                CheckPositive(userS2, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 6, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 3; user = userG2;
                //ContentOfferLoader.GrantContentLicense(user.UserPuid, user.MachinePuid, offerId);
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console2
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, gold, console2", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 7, license.body.GetUsedLicenseeCount());

                // second pass
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.Unrestricted), NewBit(i));
                }
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.PerMachineRights), NewBit(i), 5);
                }
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.PerUserRights), NewBit(i), 10);
                }
                count = i;
                for (; i < count + 1; i++)
                {
                    CreateContentOffer(TITLE_ID, OFFER_IDA + (ulong)i, content_id, CONTENT_XRL1, (int)(OfferPolicies.PerMachineRights | OfferPolicies.PerUserRights), NewBit(i), 15);
                }

                offerId = OFFER_IDA + 6; user = userS3;
                XbosOffer.OfferPurchase(offerId, user);   // user, console3
                Global.RO.Info("Offer - 0x{0:X} per-user, user - 0x{1:X}, silver, console3", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 8, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 7; user = userG3;
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console3
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, gold, console3", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 10, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 1; user = userS4;
                XbosOffer.OfferPurchase(offerId, user);   // machine, console1
                Global.RO.Info("Offer - 0x{0:X} per-machine, user - 0x{1:X}, silver, console1", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 10, license.body.GetUsedLicenseeCount());


                offerId = OFFER_IDA + 7; user = userG4;
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console1
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, gold, console1", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 11, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 6; user = userS5;
                XbosOffer.OfferPurchase(offerId, user);   // user, console2
                Global.RO.Info("Offer - 0x{0:X} per-user, user - 0x{1:X}, silver, console2", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 12, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 2; user = userG5;
                XbosOffer.OfferPurchase(offerId, user);   // user, console2
                Global.RO.Info("Offer - 0x{0:X} per-user, user - 0x{1:X}, gold, console2", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 13, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 7; user = userS6;
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console3
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, silver, console3", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 14, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 6; user = userG6;
                XbosOffer.OfferPurchase(offerId, user);   // user, console3
                Global.RO.Info("Offer - 0x{0:X} per-user, user - 0x{1:X}, gold, console3", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 15, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 3; user = userS7;
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console2
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, silver, console2", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 16, license.body.GetUsedLicenseeCount());

                offerId = OFFER_IDA + 7; user = userG7;
                XbosOffer.OfferPurchase(offerId, user);   // user|machine, console3
                Global.RO.Info("Offer - 0x{0:X} per-user|machine, user - 0x{1:X}, gold, console3", offerId, user.UserPuid);
                CheckPositive(user, expectLicense, license, false);
                ValueCheck.Test("Number of non-empty licensees", 16, license.body.GetUsedLicenseeCount());
                // make sure the last licensee is the userG7
                ValueCheck.Test("Last licensee", ContentLicense.RevertByteOrder(user.UserPuid), license.body.licensees[15].licenseeId);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(2)]
        class P_MachineLicense_Only : TestBase
        {
            override protected void Execute()
            {
                uint TITLE_ID = _defaultTitle;
                UInt32 licenseBitsOfferA = 3;
                ulong OFFER_IDA = ((ulong)TITLE_ID << 32) + 1;
                string CONTENT_XRL1 = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";
                byte[] content_id = new byte[20];
                Random r = new Random((int)DateTime.UtcNow.Ticks);
                r.NextBytes(content_id);
                Createtitle(TITLE_ID);
                CreateContentOffer(TITLE_ID, OFFER_IDA, content_id, CONTENT_XRL1,
                    (int)(OfferPolicies.PerMachineRights), (int)licenseBitsOfferA);

                XeUser user = XbosUser.XenonGoldUser();
                user.MachinePuid = user.MachinePuid;
                user.AddPoints_500();
                XbosOffer.OfferPurchase(OFFER_IDA, user);

                ContentLicense license = new ContentLicense();
                license.signature.signatureType = ContentLicense.RevertByteOrder(ContentLicense.LicenseTypeLive);   // make the live signature type
                license.body.ContentId = content_id;

                ulong consoleId = XbosOffer.ConvertConsoleIdFromDecimalStringToUInt64(CONSOLE_ID);
                // licensee table order: unrestricted, user id, console id
                ContentLicense expectLicense = new ContentLicense(true);
                expectLicense.body.ContentId = (byte[])license.body.ContentId.Clone();
                expectLicense.body.licensees[0].licenseeId = ContentLicense.RevertByteOrder(consoleId);
                expectLicense.body.licensees[0].licenseBits = ContentLicense.RevertByteOrder((uint)licenseBitsOfferA);

                //call it the first time
                CheckPositive(user, expectLicense, license, true);
                // call it the second time with the new license, everything should keep the same
                CheckPositive(user, expectLicense, license, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Verify user license only.
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_UserLicense_Only : TestBase
        {
            override protected void Execute()
            {
                uint TITLE_ID = _defaultTitle;
                UInt32 licenseBitsOfferA = 3;
                ulong OFFER_IDA = ((ulong)TITLE_ID << 32) + 1;
                string CONTENT_XRL1 = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";
                byte[] content_id = new byte[20];
                Random r = new Random((int)DateTime.UtcNow.Ticks);
                r.NextBytes(content_id);
                Createtitle(TITLE_ID);
                CreateContentOffer(TITLE_ID, OFFER_IDA, content_id, CONTENT_XRL1,
                    (int)(OfferPolicies.PerUserRights), (int)licenseBitsOfferA, 80);

                XeUser user = XbosUser.XenonGoldUser();
                user.MachinePuid = user.MachinePuid;
                user.AddPoints_500();
                XbosOffer.OfferPurchase(OFFER_IDA, user);

                ContentLicense license = new ContentLicense();
                license.signature.signatureType = ContentLicense.RevertByteOrder(ContentLicense.LicenseTypeLive);   // make the live signature type
                license.body.ContentId = content_id;

                // licensee table order: unrestricted, user id, console id
                ContentLicense expectLicense = new ContentLicense(true);
                expectLicense.body.ContentId = (byte[])license.body.ContentId.Clone();
                expectLicense.body.licensees[0].licenseeId = ContentLicense.RevertByteOrder(user.UserPuid);
                expectLicense.body.licensees[0].licenseBits = ContentLicense.RevertByteOrder((uint)licenseBitsOfferA);
                expectLicense.body.licensees[0].licenseFlags = ContentLicense.RevertByteOrder((uint)ContentLicense.LicenseFlagRequireOnline);

                //call it the first time
                CheckPositive(user, expectLicense, license, true);
                // call it the second time with the new license, everything should keep the same
                CheckPositive(user, expectLicense, license, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 47059	Machine license gets over-written on redownload
        /// Also verify zero cost offers
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_MachineLicense_Update : TestBase
        {
            private const uint TITLE_ID = _defaultTitle;
            public const UInt32 licenseBitsOfferA = 3;
            public const UInt32 licenseBitsOfferB = 4;
            private const ulong OFFER_IDA = ((ulong)TITLE_ID << 32) + 1;
            private const ulong OFFER_IDB = ((ulong)TITLE_ID << 32) + 2;
            private const string CONTENT_XRL1 = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";

            byte[] content_id = new byte[20];

            public P_MachineLicense_Update()
            {
                Random r = new Random((int)DateTime.UtcNow.Ticks);
                r.NextBytes(content_id);
            }

            public static XeUser GetUserPurchase(ulong offerid)
            {
                XeUser user = XbosUser.XenonGoldUser();
                user.MachinePuid = user.MachinePuid;
                XbosOffer.RewardUSUser1600Points(user);
                XbosOffer.OfferPurchase(offerid, user);
                return user;
            }

            override protected void Execute()
            {
                Createtitle(TITLE_ID);
                CreateContentOffer(TITLE_ID, OFFER_IDA, content_id, CONTENT_XRL1,
                    (int)(OfferPolicies.PerMachineRights | OfferPolicies.PerUserRights), (int)licenseBitsOfferA, 50);
                CreateContentOffer(TITLE_ID, OFFER_IDB, content_id, CONTENT_XRL1,
                    (int)(OfferPolicies.PerMachineRights | OfferPolicies.PerUserRights), (int)licenseBitsOfferB, 60);

                XeUser userA = GetUserPurchase(OFFER_IDA);
                XeUser userB = GetUserPurchase(OFFER_IDB);

                ContentLicense license = new ContentLicense();
                license.body.ContentId = content_id;    // should be unique and not in database

                XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                XRLXeContentRefreshLicenseResponse response = new XRLXeContentRefreshLicenseResponse();

                request.UserId = userA.UserPuid;
                request.MachineId = userA.MachinePuid;
                XbosWS.AddConsoleId(userA.MachinePuid, CONSOLE_ID);
                request.License = license.ToArray();

                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeContentRefreshLicense execute failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException("XRLXeContentRefreshLicense returned an unexpected value: " + request.XErr);

                // get for User B  know 
                request.UserId = userB.UserPuid;
                request.License = response.License;
                // debug
                license = new ContentLicense();
                license.ReadBytes(response.License);

                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeContentRefreshLicense execute failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException("XRLXeContentRefreshLicense returned an unexpected value: " + request.XErr);

                license = new ContentLicense();
                license.ReadBytes(response.License);

                ulong luA = ContentLicense.RevertByteOrder(userA.UserPuid);
                ulong luB = ContentLicense.RevertByteOrder(userB.UserPuid);
                ulong ConsoleId = ContentLicense.RevertByteOrder(XbosOffer.ConvertConsoleIdFromDecimalStringToUInt64(CONSOLE_ID));

                ContentLicensee[] Licensee = license.body.licensees;
                //for( int i=0;i<Licensee.Length;i++)
                {
                    if (Licensee[0].licenseeId != luA || Licensee[0].licenseBits != ContentLicense.RevertByteOrder(licenseBitsOfferA))
                        throw new Exception("licenseBits for User A is wrong");
                    if (Licensee[2].licenseeId != luB || Licensee[2].licenseBits != ContentLicense.RevertByteOrder(licenseBitsOfferB))
                        throw new Exception("licenseBits for User B is wrong");
                    if (Licensee[1].licenseeId != ConsoleId || Licensee[1].licenseBits != ContentLicense.RevertByteOrder(licenseBitsOfferA | licenseBitsOfferB))
                        throw new Exception("licenseBits for Machine is wrong");
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Restricted  and non restricted offers for same contant
        /// insert a contant into dbo.t_title_update_packages
        /// </summary>
        [TestCase, TestCasePriority(2)]
        class P_Title_Update : TestBase
        {
            private const uint TITLE_ID = _defaultTitle;
            public byte[] CONTENT_ID;
            public const string contidstring = "0x174A1338C5FA52E15159F13B2AE3994AEA704E71";

            public static void PopulateUpdateData()
            {
                // insert the needed rows into the database
                string sql = "if not exists (select 1 from t_titles where i_title_id = 0x" + TITLE_ID.ToString("X") + " ) " +
                    "insert into t_titles (i_title_id, ti_console_type_id) values (0x" + TITLE_ID.ToString("X") + ", 0)";
                UodbWS.ExecuteSQLNonQuery(sql, null);

                sql = "if not exists (select 1 from t_title_versions where i_title_id = 0x" + TITLE_ID.ToString("X") + ") " +
                    "insert into t_title_versions (i_title_id, i_base_version, i_update_version, i_beta_version) values (0x" + TITLE_ID.ToString("X") + ", 1, 3, 3)";
                UodbWS.ExecuteSQLNonQuery(sql, null);

                sql = "if not exists (select 1 from t_title_update_packages where i_title_id = 0x" + TITLE_ID.ToString("X") + ") " +
                    "insert into t_title_update_packages (i_title_id, i_title_base_version, i_title_update_version, vb_update_sym_key, vb_public_key, i_install_size, i_package_size, b_content_id) " +
                    "values (0x" + TITLE_ID.ToString("X") + ", 1, 3, 0x133552AB07244F0467B99D58EDB15103, " +
                    "0x525341310801000000080000FF00000001000100B1BFA6F086E96F1906E835DDDD4A753B7BD73408CA11C1B8088D36E7B55F478606332E04F6AF1C3B9CEE29F496CB82D5A0977E237C5B506B3D68238116CB9C91F2F39EE034FC5FC6D93CAF156AEEC5416B620B0F26855D3EC60F0AE089D59BB1BC35057BB1691DBA2F6FF572, " +
                    "435, 277551, " + contidstring + ")";
                UodbWS.ExecuteSQLNonQuery(sql, null);

                sql = "if not exists (select 1 from t_title_update_locations where i_title_id = 0x" + TITLE_ID.ToString("X") + ") " +
                    "insert into t_title_update_locations (i_title_id, i_title_base_version, i_title_update_version, i_location_rank, vc_XRL) values (0x" + TITLE_ID.ToString("X") + ", 1, 3, 0, '10.198.102.86:3074/content/" + TITLE_ID.ToString("X") + "/functionaltesting1.xcp') ";
                UodbWS.ExecuteSQLNonQuery(sql, null);
            }

            public P_Title_Update()
            {
                CONTENT_ID = CONTENT_ID_UPDATE; // new byte[] { 0x17, 0x4A, 0x13, 0x38, 0xC5, 0xFA, 0x52, 0xE1, 0x51, 0x59, 0xF1, 0x3B, 0x2A, 0xE3, 0x99, 0x4A, 0xEA, 0x70, 0x4E, 0x71 };
            }

            override protected void Execute()
            {
                Createtitle(TITLE_ID);
                PopulateUpdateData();

                ContentLicense license = new ContentLicense();
                license.body.ContentId = CONTENT_ID;    // should be unique and not in database

                XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                XRLXeContentRefreshLicenseResponse response = new XRLXeContentRefreshLicenseResponse();

                XeUser user = XbosUser.XenonGoldUser();

                request.UserId = user.UserPuid;
                request.MachineId = user.MachinePuid;
                XbosWS.AddConsoleId(user.MachinePuid);
                request.License = license.ToArray();

                if (!request.Execute(out response))
                    throw new UnexpectedTestResultException("XRLXeContentRefreshLicense execute failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeContentRefreshLicense returned XErr=0x{0:x}", request.XErr));

                license = new ContentLicense();
                license.ReadBytes(response.License);

                ContentLicensee[] Licensee = license.body.licensees;

                bool found = false;
                for (int i = 0; i < Licensee.Length; i++)
                {
                    if (Licensee[i].licenseeId == ContentLicense.UnrestrictedLicensee)
                    {
                        found = true;
                    }
                }

                if (!found)
                    throw new Exception("License info for autoupdate title not set");

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /////////////////////////////////////////////////////////////////////////////////
        // Negative cases
        //

        public static void CheckNegative(XRLXeContentRefreshLicense request, uint hresult)
        {
            ContentLicense license = new ContentLicense();
            license.body.ContentId = CONTENT_ID;
            CheckNegative(request, hresult, license);
        }

        public static void CheckNegative(XRLXeContentRefreshLicense request, uint hresult, ContentLicense license)
        {
            CheckNegative(request, hresult, license, true, true);
        }

        public static void CheckNegative(XRLXeContentRefreshLicense request, uint hresult, ContentLicense license, bool setUser, bool setMachine)
        {
            XeUser user = XbosUser.XenonGoldUser();
            ContentOfferLoader.GrantContentLicense(user.UserPuid, user.MachinePuid, OFFER_ID);

            XRLXeContentRefreshLicenseResponse response = new XRLXeContentRefreshLicenseResponse();

            if (setUser)
                request.UserId = user.UserPuid;
            if (setMachine)
                request.MachineId = user.MachinePuid;
            XbosWS.AddConsoleId(user.MachinePuid);  // make sure the machine id is in UODB
            request.License = license.ToArray();

            if (request.Execute(out response))
                throw new UnexpectedTestResultException("Expect XRLXeContentRefreshLicense to fail.");
            if (request.XErr != hresult)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentRefreshLicense returned XErr=0x{0:x}", request.XErr));
        }

        [TestCase, TestCasePriority(2)]
        class N_Invalid_ConsoleId : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
            }
        }

        [TestCase, TestCasePriority(2)]
        class N_Invalid_MachinePuid : TestBase
        {
            override protected void Execute()
            {
                ContentLicense license = new ContentLicense();
                license.body.ContentId = CONTENT_ID;
                XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                request.MachineId = 0;  // invalid machine id

                CheckNegative(request, HResult.XONLINE_E_MACHINE_ID_NOT_FOUND, license, true, false);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(2)]
        class N_Invalid_ContentId : TestBase
        {
            override protected void Execute()
            {
                XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                ContentLicense license = new ContentLicense();
                Random r = new Random((int)DateTime.UtcNow.Ticks);
                byte[] content_id = new byte[20];
                r.NextBytes(content_id);
                license.body.ContentId = content_id;    // should be unique and not in database

                CheckNegative(request, HResult.XONLINE_E_CONTENT_NOT_FOUND, license);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_InvalidAuth_UserPuid : TestBase
        {
            protected override void Execute()
            {
                XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                request.ManualPopulateSlot();
                request.Slot.userPuid0 = 0; // should be invalid
                CheckNegative(request, HResult.XONLINE_E_SERVER_ERROR);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(2)]
        public class N_InvalidAuth_MachinePuid : TestBase
        {
            protected override void Execute()
            {
                XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
                request.ManualPopulateSlot();
                request.Slot.machinePuid = 0; // should be invalid
                CheckNegative(request, HResult.XONLINE_E_SERVER_ERROR);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        private class XRLXeRequest_N_PayloadEmpty : XRLXeContentRefreshLicense
        {
            public override void WriteStream(BinaryWriter binaryWriter)
            {
                // Intentionally write out nothing
            }
        }

        [TestCase, TestCasePriority(3)]
        public class N_Payload_Empty : TestBase
        {
            protected override void Execute()
            {
                XRLXeRequest_N_PayloadEmpty request = new XRLXeRequest_N_PayloadEmpty();
                CheckNegative(request, HResult.XONLINE_E_END_OF_STREAM);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        private class XRLXeRequest_N_PayloadInvalid : XRLXeContentRefreshLicense
        {
            public static Random rnd = new Random();
            public override void WriteStream(BinaryWriter binaryWriter)
            {
                // Intentionally write out invalid bytes
                byte[] trashData = new byte[100];
                rnd.NextBytes(trashData);
                binaryWriter.Write(trashData);
            }
        }

        [TestCase, TestCasePriority(3)]
        public class N_Payload_InvalidArg : TestBase
        {
            protected override void Execute()
            {
                XRLXeRequest_N_PayloadInvalid request = new XRLXeRequest_N_PayloadInvalid();
                CheckNegative(request, HResult.E_INVALIDARG);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        private class XRLXeRequest_N_PayloadTooSmall : XRLXeContentRefreshLicense
        {
            public override void WriteStream(BinaryWriter binaryWriter)
            {
                // Intentionally write out too little
                binaryWriter.Write(this.UserId);
                binaryWriter.Write(this.MachineId);
                binaryWriter.Write(ContentLicense.LiveSignatureLen);
                binaryWriter.Write(ContentLicense.ReservedLen);
                binaryWriter.Write(ContentLicense.UnrestrictedLicensee);
                binaryWriter.Write(ContentLicense.LicenseFlagRequireOnline);
                binaryWriter.Write(ContentLicense.LicenseTypeLive);
                binaryWriter.Write((UInt16)100);
                byte[] trashData = new byte[100];
                binaryWriter.Write(trashData);
            }
        }

        [TestCase, TestCasePriority(3)]
        public class N_Payload_TooSmall : TestBase
        {
            protected override void Execute()
            {
                XRLXeRequest_N_PayloadTooSmall request = new XRLXeRequest_N_PayloadTooSmall();
                CheckNegative(request, HResult.XONLINE_E_END_OF_STREAM);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /*
        private class XRLXeRequest_N_PayloadTooLarge : XRLXeContentRefreshLicense
        {
            public override void WriteStream(BinaryWriter binaryWriter)
            {
                binaryWriter.Write(this.UserId);
                binaryWriter.Write(this.MachineId);
                binaryWriter.Write(ContentLicense.LiveSignatureLen);
                binaryWriter.Write(ContentLicense.ReservedLen);
                binaryWriter.Write(ContentLicense.UnrestrictedLicensee);
                binaryWriter.Write(ContentLicense.LicenseFlagRequireOnline);
                binaryWriter.Write(ContentLicense.LicenseTypeLive);
                binaryWriter.Write((UInt16)XOn.XONLINE_CONTENT_LICENSE_MAX_LEN);
                byte[] trashData = new byte[(UInt16)XOn.XONLINE_CONTENT_LICENSE_MAX_LEN + 200];
                binaryWriter.Write(trashData);
            }
        }
        
        [TestCase, TestCasePriority(3)]
        public class N_Payload_TooLarge : TestBase
        {
            protected override void Execute()
            {
                XRLXeRequest_N_PayloadTooLarge request = new XRLXeRequest_N_PayloadTooLarge();
                CheckNegative(request, HResult.XONLINE_E_OVERFLOW);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xexbosgamertag_none_12.4.56.0_none_8a9980ae0da90232
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xexbosgamertag
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.manifest
XP_MANIFEST_PATH=manifests\msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.cat
XP_CATALOG_PATH=manifests\msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.cat
XP_PAYLOAD_PATH=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xexbosgamertag,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\xbox\LiveFoundation\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\Gamertag\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xexbosgamertag_none_12.4.56.0_none_8a9980ae0da90232
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xexbosgamertag
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.manifest
XP_MANIFEST_PATH=manifests\msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.cat
XP_CATALOG_PATH=manifests\msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18.cat
XP_PAYLOAD_PATH=msil_xexbosgamertag_no-public-key_12.4.56.0_x-ww_3442fd18
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xexbosgamertag,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\xbox\LiveFoundation\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xbostestv2-lf_none_12.4.56.0_none_0694532490c7f6e8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbostestv2-lf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.manifest
XP_MANIFEST_PATH=manifests\msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.cat
XP_CATALOG_PATH=manifests\msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.cat
XP_PAYLOAD_PATH=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbostestv2-lf,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\xbox\LiveFoundation\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\pso\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\xbox\LiveFoundation\MainClass.cs ===
using System;
using System.Runtime.InteropServices;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;

[assembly: RootNode(typeof(XbosTestV2.XbosTestV2))]

namespace XbosTestV2
{
    /// <summary>
    ///    <TestSuite>Billing and Offering Server - Live Foundation portion</TestSuite>
    ///    <Tester>Luke Lenhart</Tester>
    ///    <Developer>Gary Thompson</Developer>
    ///    <PM>Jerry Hook</PM>
    ///  </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(3), TestFrequency("Daily")]
    public class XbosTestV2: TestNode
    {
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\xbox\LiveFoundation\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xbostestv2-lf_none_12.4.56.0_none_0694532490c7f6e8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbostestv2-lf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.manifest
XP_MANIFEST_PATH=manifests\msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.cat
XP_CATALOG_PATH=manifests\msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e.cat
XP_PAYLOAD_PATH=msil_xbostestv2-lf_no-public-key_12.4.56.0_x-ww_adb05d2e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbostestv2-lf,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\pso\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__pso_4_none_12.4.56.0_none_edbd43f8a4a78eca
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_pso_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.manifest
XP_MANIFEST_PATH=manifests\x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.cat
XP_CATALOG_PATH=manifests\x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.cat
XP_PAYLOAD_PATH=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_pso_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\offering\test\xbox\LiveFoundation\FuncAutoUpdateReferral.cs ===
using System;
using System.Globalization;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.sql.webstore; //used by the direct sproc tests only
using xonline.common.config; //used by the direct sproc tests only
using Microsoft.Webstore.WstClient; //used by the direct sproc tests only

namespace XbosTestV2.Functional
{
    /// <summary>
    /// Functional tests for the AutoUpdateReferral API.
    /// </summary>
    /// <remarks>
    ///   <Description> Auto-updates are patches to titles, we provide an API to request the location(s) of a referral based on a title ID. </Description>
    /// </remarks>
    [TestGroup, TestCasePriority(1)]
    public class AutoUpdateReferral: TestNode
    {
        // -- test constants

        public static uint BaseTitleId=(uint)0x524D0000;
        public static byte[] SymKey=Hexer.unhex("0x133552AB07244F0467B99D58EDB15103");
        public static byte[] PublicKey=Hexer.unhex("0x525341310801000000080000FF00000001000100B1BFA6F086E96F1906E835DDDD4A753B7BD73408CA11C1B8088D36E7B55F478606332E04F6AF1C3B9CEE29F496CB82D5A0977E237C5B506B3D68238116CB9C91F2F39EE034FC5FC6D93CAF156AEEC5416B620B0F26855D3EC60F0AE089D59BB1BC35057BB1691DBA2F6FF572");
        public static byte[] ContentId=Hexer.unhex("0x0123456789ABCDEF0123456789ABCDEF01234567");
        public static uint m_titleId=0x588D2DAA;
        public const uint BetaTitleId=0xFFFFBE7A;
        public const uint UpdateDataTitleId=0xFFFF2FAC; //such a fake and unworthy feature
        public static int[] ConsoleTypes=new int[] {0, 2, 4 };
        public static int[] ConsoleTypes2=new int[] { -1 };
        public static uint PackageSize=277551;
        public static uint InstallSizeBase=100;
        public const uint InstallSize0=1000;
        public const uint InstallSize1=1001;
        public const uint InstallSize2=1002;

        public const string MachineXeNone="XE.777700000020";
        public const string MachineXe0="XE.777700000008";
        public const string MachineXe1="XE.777700000019";
        public const string MachineXeFlash0="XE.777700000031";
        public const string MachineXeFlash1="XE.777700000042";
        public const string MachineXbNone="SN.777700000020";
        public const string MachineXb0="SN.777700000008";
        public const string MachinePcNone="PC.777700000020";
        public const string MachinePc0="PC.777700000008";

        public const string MachineXeConflicted="XE.777710000009";

        public const string MachineXeSystem0="XE.773910000004"; //in a group
        public const string MachineXeSystem1="XE.773910000015"; //not in a group
        public const string MachinePcSystem0="PC.773910000004"; //in a group
        public const string MachinePcSystem1="PC.773910000015"; //not in a group

        //ctor
        public AutoUpdateReferral()
        {
            //force _Setup to be the first in the list
            AddChild(new _Setup(), true, false);
        }

        // -- test data

        [Description("Sets up all test data needed for autoupdate tests.")]
        public class _Setup: TestNode
        {
            [TestCase]
            public void Mainline()
            {
                PopulateUpdateData(m_titleId, ConsoleTypes);
            }

            [TestCase]
            public void Negative()
            {
                PopulateUpdateData(m_titleId + 1, ConsoleTypes2);   // for one negative test, N_Installsize_Zero
            }

            [TestCase]
            public void BetaGroups()
            {
                //mainline machines
                MachineEditor machineXe0=MachineEditor.CreateOrUseExistingName(MachineXe0); //in group 0
                MachineEditor machineXe1=MachineEditor.CreateOrUseExistingName(MachineXe1); //in group 1
                MachineEditor machineNone=MachineEditor.CreateOrUseExistingName(MachineXeNone); //not in a group
                MachineEditor machineXeFlash0=MachineEditor.CreateOrUseExistingName(MachineXeFlash0); //in flash group 0
                MachineEditor machineXeFlash1=MachineEditor.CreateOrUseExistingName(MachineXeFlash1); //in flash group 1

                MachineEditor machinePc0=MachineEditor.CreateOrUseExistingName(MachinePc0); //in group 0
                MachineEditor machinePcNone=MachineEditor.CreateOrUseExistingName(MachinePcNone); //not in a group

                MachineEditor machineXb0=MachineEditor.CreateOrUseExistingName(MachineXb0); //in group 0
                MachineEditor machineXbNone=MachineEditor.CreateOrUseExistingName(MachineXbNone); //not in a group

                //unusual machines
                //MachineEditor machineXeConflicted=MachineEditor.CreateOrUseExistingName(MachineXeConflicted); //machine in 2 different groups, which has a conflict for one version //We added a unique key constraint for the 2010 March XSR, so not propping this for now.

                //normal beta groups
                BetaGroupEditor bge0=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("FFFFBE7A-0000-7E57-0000-000000000000"));
                bge0.Name="Xbos Test Title Beta Group 0";
                bge0.RemoveAllMachines();
                bge0.AddMachine(machineXe0.Id);
                bge0.AddMachine(machinePc0.Id);
                bge0.AddMachine(machineXb0.Id);

                BetaGroupEditor bge1=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("FFFFBE7A-0000-7E57-0000-000000000001"));
                bge1.Name="Xbos Test Title Beta Group 1";
                bge1.RemoveAllMachines();
                bge1.AddMachine(machineXe1.Id);

                //beta groups with overlaps and/or conflicts
                /*BetaGroupEditor bgeC0=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("FFFFBE7A-0000-7E57-0000-0000000000C0"));  //We added a unique key constraint for the 2010 March XSR, so not propping this for now
                bgeC0.Name="Xbos Test Title Beta Group Conflict 0";
                bgeC0.RemoveAllMachines();
                bgeC0.AddMachine(machineXeConflicted.Id);

                BetaGroupEditor bgeC1=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("FFFFBE7A-0000-7E57-0000-0000000000C1"));  //We added a unique key constraint for the 2010 March XSR, so not propping this for now
                bgeC1.Name="Xbos Test Title Beta Group Conflict 1";
                bgeC1.RemoveAllMachines();
                bgeC1.AddMachine(machineXeConflicted.Id);*/

                BetaGroupEditor bgeF0=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("FFFFBE7A-0000-7E57-0000-0000000000F0"));
                bgeF0.Name="Xbos Test Flash Beta Group 0";
                bgeF0.RemoveAllMachines();
                bgeF0.AddMachine(machineXeFlash0.Id);

                BetaGroupEditor bgeF1=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("FFFFBE7A-0000-7E57-0000-0000000000F1"));
                bgeF1.Name="Xbos Test Flash Beta Group 1";
                bgeF1.RemoveAllMachines();
                bgeF1.AddMachine(machineXeFlash1.Id);

                //create and clear out the title
                TitleEditor te=TitleEditor.CreateOrUseExistingId(BetaTitleId);
                te.RemoveAllVersions();
                te.RemoveAllUpdatePackages();
                te.RemoveAllUpdateLocations();

                //version 10 does not update normal users, but has different updates for beta groups 0 and 1
                te.AddVersion(10, 10,  0, new System.Guid("00000000-0000-0000-0000-000000000000"));
                te.AddVersion(10, 10,  2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                te.AddVersion(10, 10,  4, new System.Guid("00000000-0000-0000-0000-000000000000"));
                te.AddVersion(10, 110, 0, bge0.Id);
                te.AddVersion(10, 110, 2, bge0.Id);
                te.AddVersion(10, 110, 4, bge0.Id);
                te.AddVersion(10, 210, 2, bge1.Id);

                te.AddUpdatePackage(10, 110, 0, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                te.AddUpdatePackage(10, 110, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                te.AddUpdatePackage(10, 110, 4, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                te.AddUpdatePackage(10, 210, 2, SymKey, PublicKey, InstallSize1, PackageSize, ContentId);

                te.AddUpdateLocation(10, 110, 0, 1, "10-110-xb.xcp");
                te.AddUpdateLocation(10, 110, 2, 1, "10-110-xe.xcp");
                te.AddUpdateLocation(10, 110, 4, 1, "10-110-pc.xcp");
                te.AddUpdateLocation(10, 210, 2, 1, "10-210-xe.xcp");

                //Version 11 does not exist for normal users, doesn't exist at all on pc, and only has an update for beta group 0
                te.AddVersion(11, 111, 0, bge0.Id);
                te.AddVersion(11, 111, 2, bge0.Id);

                te.AddUpdatePackage(11, 111, 0, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                te.AddUpdatePackage(11, 111, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);

                te.AddUpdateLocation(11, 111, 0, 1, "11-111-xb.xcp");
                te.AddUpdateLocation(11, 111, 2, 1, "11-111-xe.xcp");

                //Version 12 only exists for xbox360, and does not update normal users and has an expired update for group 0 and a future update for group 1
                te.AddVersion(12, 12,  2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                te.AddVersion(12, 112, 2, bge0.Id, System.DateTime.UtcNow-new System.TimeSpan(10,0,0,0), System.DateTime.UtcNow-new System.TimeSpan(0,0,10,0)); //beta group in the past
                te.AddVersion(12, 112, 2, bge1.Id, System.DateTime.UtcNow+new System.TimeSpan(20,0,0,0), System.DateTime.UtcNow+new System.TimeSpan(100,0,0,0)); //beta group in the future

                te.AddUpdatePackage(12, 112, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);

                te.AddUpdateLocation(12, 112, 2, 1, "12-112-xe.xcp");

                //Version 13 only exists for xbox360, and updates for normal users but not for beta group 0
                te.AddVersion(13, 113, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                te.AddVersion(13, 13, 2, bge0.Id);

                te.AddUpdatePackage(13, 113, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);

                te.AddUpdateLocation(13, 113, 2, 1, "13-113-xe.xcp");

                //Version 14 uses a machine in 2 groups, but is ok for this version
                te.AddVersion(14, 14, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                //te.AddVersion(14, 114, 2, bgeC0.Id); //We added a unique key constraint for the 2010 March XSR, so not propping this for now

                te.AddUpdatePackage(14, 114, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);

                te.AddUpdateLocation(14, 114, 2, 1, "14-114-xe.xcp");

                //Version 15 uses a machine in 2 groups with the same base version, but has a conflict on which to upgrade to
                te.AddVersion(15, 15, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                //te.AddVersion(15, 115, 2, bgeC0.Id); //We added a unique key constraint for the 2010 March XSR, so not propping this for now
                //te.AddVersion(15, 215, 2, bgeC1.Id); //We added a unique key constraint for the 2010 March XSR, so not propping this for now

                te.AddUpdatePackage(15, 115, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                te.AddUpdatePackage(15, 215, 2, SymKey, PublicKey, InstallSize1, PackageSize, ContentId);

                te.AddUpdateLocation(15, 115, 2, 1, "15-115-xe.xcp");
                te.AddUpdateLocation(15, 215, 2, 1, "15-215-xe.xcp");

                //Version 16 uses a machine in 2 groups with the same base version, but both update to the same version, so there is no conflict
                te.AddVersion(16, 16, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                //te.AddVersion(16, 116, 2, bgeC0.Id); //We added a unique key constraint for the 2010 March XSR, so not propping this for now
                //te.AddVersion(16, 116, 2, bgeC1.Id); //We added a unique key constraint for the 2010 March XSR, so not propping this for now

                te.AddUpdatePackage(16, 116, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);

                te.AddUpdateLocation(16, 116, 2, 1, "16-116-xe.xcp");

                //Version 17 held group 0 on version 17 until yesterday, and updates everyone to 18 now
                te.AddVersion(17, 18, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                te.AddVersion(17, 17, 2, bge0.Id, System.DateTime.UtcNow-new System.TimeSpan(5,0,0,0), System.DateTime.UtcNow-new System.TimeSpan(1,0,0,0)); //beta group in the past

                te.AddUpdatePackage(17, 18, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);

                te.AddUpdateLocation(17, 18, 2, 1, "17-18-xe.xcp");

                //Flash version 250 goes to 251 for flash group 0 and 252 for flash group 1
                TitleEditor flashTitle=TitleEditor.CreateOrUseExistingId(0xfffe07d1);
                flashTitle.AddVersion(250, 250, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                flashTitle.AddVersion(250, 251, 2, bgeF0.Id);
                flashTitle.AddVersion(250, 252, 2, bgeF1.Id);

                flashTitle.AddUpdatePackage(250, 251, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                flashTitle.AddUpdatePackage(250, 252, 2, SymKey, PublicKey, InstallSize1, PackageSize, ContentId);

                flashTitle.AddUpdateLocation(250, 251, 2, 1, "250-251-xeflash.xcp");
                flashTitle.AddUpdateLocation(250, 252, 2, 1, "250-252-xeflash.xcp");
            }

            [TestCase]
            public void MachineUpdateData()
            {
                //a beta group and some machines
                MachineEditor machineXeSystem0=MachineEditor.CreateOrUseExistingName(MachineXeSystem0); //in group
                MachineEditor machinePcSystem0=MachineEditor.CreateOrUseExistingName(MachinePcSystem0); //in group
                MachineEditor machineXeSystem1=MachineEditor.CreateOrUseExistingName(MachineXeSystem1); //not in group
                MachineEditor machinePcSystem1=MachineEditor.CreateOrUseExistingName(MachinePcSystem1); //not in group

                BetaGroupEditor bge0=BetaGroupEditor.CreateOrUseExistingId(new System.Guid("FFFFBE7A-0000-7E57-0000-2FAC00000000"));
                bge0.Name="Xbos Test Beta Group MachineData";
                bge0.RemoveAllMachines();
                bge0.AddMachine(machineXeSystem0.Id);
                bge0.AddMachine(machinePcSystem0.Id);

                //a plain old title update
                TitleEditor te=TitleEditor.CreateOrUseExistingId(UpdateDataTitleId);
                te.RemoveAllVersions();
                te.RemoveAllUpdatePackages();
                te.RemoveAllUpdateLocations();
                te.AddVersion(100, 200, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                te.AddVersion(100, 200, 4, new System.Guid("00000000-0000-0000-0000-000000000000"));

                te.AddUpdatePackage(100, 200, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                te.AddUpdatePackage(100, 200, 4, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);

                te.AddUpdateLocation(100, 200, 2, 1, "100-200-xe.xcp");
                te.AddUpdateLocation(100, 200, 4, 1, "100-200-pc.xcp");

                //a system update for xbox360
                TitleEditor teSysXbox360=TitleEditor.CreateOrUseExistingId(0xfffe07d1);
                teSysXbox360.AddVersion(240, 241, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));
                teSysXbox360.AddVersion(240, 242, 2, bge0.Id);
                teSysXbox360.AddVersion(246, 246, 2, new System.Guid("00000000-0000-0000-0000-000000000000"));

                teSysXbox360.AddUpdatePackage(240, 241, 2, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                teSysXbox360.AddUpdatePackage(240, 242, 2, SymKey, PublicKey, InstallSize1, PackageSize, ContentId);

                teSysXbox360.AddUpdateLocation(240, 241, 2, 1, "240-241-xeflash.xcp");
                teSysXbox360.AddUpdateLocation(240, 242, 2, 1, "240-242-xeflash.xcp");

                //system update for pc
                TitleEditor teSysPc=TitleEditor.CreateOrUseExistingId(0x585207D1);
                teSysPc.AddVersion(240, 243, 4, new System.Guid("00000000-0000-0000-0000-000000000000"));
                teSysPc.AddVersion(240, 244, 4, bge0.Id);
                teSysPc.AddVersion(246, 246, 4, new System.Guid("00000000-0000-0000-0000-000000000000"));

                teSysPc.AddUpdatePackage(240, 243, 4, SymKey, PublicKey, InstallSize0, PackageSize, ContentId);
                teSysPc.AddUpdatePackage(240, 244, 4, SymKey, PublicKey, InstallSize1, PackageSize, ContentId);

                teSysPc.AddUpdateLocation(240, 243, 4, 1, "240-243-pcflash.xcp");
                teSysPc.AddUpdateLocation(240, 244, 4, 1, "240-244-pcflash.xcp");

                //245 is left unpopulated, it is not a valid base
            }

            [TestCase]
            public void FlushXbosCaches()
            {
                string result;
                if (!ManagementConsole.ExecuteOnAll("xbos", "e :xbos cacheflush", out result))
                {
                    Global.RO.Warn("e :xbos cacheflush failed: "+result);
                }
            }
        }

        public static void PopulateUpdateData(uint titleId, int[] consoleTypes)
        {
            // insert the needed rows into the database
            int consoleTypeTitle = 2;
            string sql = "if not exists (select 1 from t_titles where i_title_id = 0x" + titleId.ToString("X") + " ) " +
                  "insert into t_titles (i_title_id, ti_console_type_id) values (0x" + titleId.ToString("X") + ", " + consoleTypeTitle + ")";

            // all physical partitions
            UodbWS.ExecuteSQLNonQuery(sql, null);

            foreach (int consoleType in consoleTypes)
            {
                int consoleTypeId = consoleType;
                int installMul = (consoleTypeId + 1);
                if (consoleTypeId == -1)
                {
                    installMul = 0;
                    consoleTypeId = 0;
                }

                sql = "if not exists (select 1 from t_title_versions where i_title_id = 0x" + titleId.ToString("X") + " and ti_console_type_id =" + consoleTypeId + ") " +
                      "insert into t_title_versions (i_title_id, i_base_version, i_update_version, i_beta_version, ti_console_type_id) values (0x" +
                      titleId.ToString("X") + ", 1, 3, 3, " + consoleTypeId + ")";
                UodbWS.ExecuteSQLNonQuery(sql, null);

                sql = "if not exists (select 1 from t_title_update_packages where i_title_id = 0x" + titleId.ToString("X") + " and ti_console_type_id =" + consoleTypeId + ") " +
                      "insert into t_title_update_packages (i_title_id, i_title_base_version, i_title_update_version, vb_update_sym_key, vb_public_key, i_install_size, i_package_size, b_content_id, ti_console_type_id) " +
                      "values (0x" + titleId.ToString("X") + ", 1, 3, 0x" + Hexer.tohex(SymKey) + ", 0x" +
                      Hexer.tohex(PublicKey) + ", " + InstallSizeBase * installMul + ", " + PackageSize + ", 0x" + Hexer.tohex(ContentId) + ", " + consoleTypeId + ")";
                UodbWS.ExecuteSQLNonQuery(sql, null);

                sql = "if not exists (select 1 from t_title_update_locations where i_title_id = 0x" + titleId.ToString("X") + " and ti_console_type_id =" + consoleTypeId + ") " +
                      "insert into t_title_update_locations (i_title_id, i_title_base_version, i_title_update_version, i_location_rank, vc_XRL, ti_console_type_id) values (0x" +
                      titleId.ToString("X") + ", 1, 3, 0, '" + (consoleTypeId + 1) + "_" + titleId.ToString("X") + "/functionaltesting1.xcp', " + consoleTypeId + ")";
                UodbWS.ExecuteSQLNonQuery(sql, null);
            }
        }

        // -- test case common helpers

        public class MultiPlatform: AutoUpdateReferralTest
        {
            public MultiPlatform(string name, uint expected_XErr, uint titleId, int consoleTypeId): base(name, expected_XErr)
            {
                this.TitleId = titleId;
                this.ConsoleTypeId = consoleTypeId;
            }

            protected override void Init()
            {
                base.Init();

                expectRequest.Head = new XRLAutoUpdateReferralHead();
                expectRequest.Head.Flags = 0;   // always 0
                expectRequest.Head.Locations = 1;
                expectRequest.Head.PackageSize = PackageSize;
                expectRequest.Head.InstallSize = InstallSizeBase * ((uint)ConsoleTypeId + 1);
                expectRequest.Head.TitleVersion = 3;
                expectRequest.Head.SymKey = SymKey;
                expectRequest.Head.PubKey = PublicKey;

                expectRequest.Locs = new XRLAutoUpdateReferralLocation[] { new XRLAutoUpdateReferralLocation() };
                expectRequest.Locs[0].Rank = 0;
                expectRequest.Locs[0].Xrl = (ConsoleTypeId + 1) + "_" + TitleId.ToString("X") + "/functionaltesting1.xcp";
            }
        }

        public class AutoUpdateReferralTest: TestBase
        {
            public uint Expected_XErr = 0;   // if > 0, negative test cases and need to verify the exception thrown is correct
            public XRLAutoUpdateReferral request = null;
            public XRLAutoUpdateReferral expectRequest = null;
            public uint TitleId = 0;
            public int ConsoleTypeId = 0;

            public AutoUpdateReferralTest(string name, uint expected_XErr)
            {
                this.Name = name;
                this.Expected_XErr = expected_XErr;
            }

            protected virtual void Init()
            {
                request = new XRLAutoUpdateReferral();
                request.TitleId = this.TitleId;
                request.dwBaseVersion = 1;
                if (ConsoleTypeId == 0)  // xbox1
                    request.MachineId = XOn.XboxId.XboxMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong()); 
                else if (ConsoleTypeId == 2) // xbos 360
                    request.MachineId = XOn.XboxId.XenonMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong()); 
                else if (ConsoleTypeId == 4) // PC
                    request.MachineId = XOn.XboxId.PcMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong()); 
                else if (ConsoleTypeId == 3) // Marketplace only
                    request.MachineId = 3;

                expectRequest = new XRLAutoUpdateReferral();
            }

            protected override void Execute()
            {
                Init();

                bool ret = request.Execute();
                if (Expected_XErr != 0)
                {
                    if (ret)
                        throw new UnexpectedTestResultException("XRLAutoUpdateReferral should have failed.");
                    if (request.XErr != Expected_XErr)
                        throw new UnexpectedTestResultException(String.Format("XRLAutoUpdateReferral returned unexpected error XErr=0x{0:X}, expected XErr=0x{1:X}", request.XErr, Expected_XErr));
                }
                else
                {
                    if (!ret)
                        throw new UnexpectedTestResultException("XRLAutoUpdateReferral failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK)
                        throw new UnexpectedTestResultException(String.Format("XRLAutoUpdateReferral returned XErr=0x{0:x}", request.XErr));

                    PrintResponse(request);
                    VerifyResponse(request, expectRequest);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        public static void VerifyResponse(XRLAutoUpdateReferral request, XRLAutoUpdateReferral expectRequest)
        {
            XRLAutoUpdateReferralHead head = expectRequest.Head;

            ValueCheck.Test("Flags:          ", head.Flags, request.Head.Flags);
            ValueCheck.Test("Locations:      ", head.Locations, request.Head.Locations);
            ValueCheck.Test("PackageSize:    ", head.PackageSize, request.Head.PackageSize);
            ValueCheck.Test("InstallSize:    ", head.InstallSize, request.Head.InstallSize);
            ValueCheck.Test("TitleVersion:   ", head.TitleVersion, request.Head.TitleVersion);
            ValueCheck.Test("SymKey: ", head.SymKey, request.Head.SymKey);

            // adding zeros to the end of the pub key since the one we use is not 284 bytes
            int count = head.PubKey.GetLength(0);
            string zeros = new string('0', (284 - count) * 2);
            byte[] updatePubKey = Hexer.unhex(Hexer.tohex(head.PubKey) + zeros);
            ValueCheck.Test("PubKey: ", updatePubKey, request.Head.PubKey);

            ValueCheck.Test("Expected Num of Locations", expectRequest.Head.Locations, expectRequest.Locs.GetLength(0));
            ValueCheck.Test("Num of Locations", request.Head.Locations, request.Locs.GetLength(0));
            for (int i = 0; i < request.Locs.GetLength(0); i++)
            {
                ValueCheck.Test("\tRank:", expectRequest.Locs[i].Rank, request.Locs[i].Rank);
                // because the nonce at the end of the Xrl, change the check a bit
                string sXrl = request.Locs[i].Xrl.Substring(0, request.Locs[i].Xrl.IndexOf('?'));
                ValueCheck.Test("\tXrl:", expectRequest.Locs[i].Xrl, sXrl);
            }
        }

        public static void PrintResponse(XRLAutoUpdateReferral request)
        {
            XRLAutoUpdateReferralHead head = request.Head;
            Global.RO.Info("XRLAutoUpdateReferralHead:");
            Global.RO.Info("Flags:          " + head.Flags);
            Global.RO.Info("Locations:      " + head.Locations);
            Global.RO.Info("PackageSize:    " + head.PackageSize);
            Global.RO.Info("InstallSize:    " + head.InstallSize);
            Global.RO.Info("TitleVersion:   " + head.TitleVersion);
            Global.RO.Info("SymKey: " + ContentOfferLoader.ByteString(head.SymKey));
            Global.RO.Info("PubKey: " + ContentOfferLoader.ByteString(head.PubKey));

            for (int i = 0; i < request.Locs.GetLength(0); i++)
            {
                Global.RO.Info("--- Location #{0}", i);
                Global.RO.Info("\tRank:    {0}", request.Locs[i].Rank);
                Global.RO.Info("\tXrlLen:  {0}", request.Locs[i].XrlLen);
                Global.RO.Info("\tXrl:     {0}", request.Locs[i].Xrl);
            }
        }

        public static void VerifyBetaResponse(XRLAutoUpdateReferral xrl, uint updateVersion, string xrlLocation, uint installSize)
        {
            ValueCheck.Test("Locations in response", 1, xrl.Locs.Length);
            if (!xrl.Locs[0].Xrl.Contains(xrlLocation)) //the returned value has a random nonce parameter on the end, so do substring match
            {
                throw new UnexpectedTestResultException("Expected location 0 to be "+xrlLocation+" but it was "+xrl.Locs[0].Xrl);
            }

            ValueCheck.Test("Package Size", PackageSize, xrl.Head.PackageSize);
            ValueCheck.Test("Install Size", installSize, xrl.Head.InstallSize);
            ValueCheck.Test("Update Version", updateVersion, xrl.Head.TitleVersion);
            ValueCheck.Test("Symmetric Key", SymKey, xrl.Head.SymKey);

            //public key may be padded with 0's
            byte []expectedPublicKey=new byte[284];
            System.Array.Copy(PublicKey, expectedPublicKey, PublicKey.Length);
            ValueCheck.Test("Public Key", expectedPublicKey, xrl.Head.PubKey);
        }

        public static XRLAutoUpdateReferral CreateTitleRequest(uint titleId, uint titleVersion, ulong machinePuid)
        {
            XRLAutoUpdateReferral xrl=new XRLAutoUpdateReferral();
            xrl.TitleId=titleId;
            xrl.dwBaseVersion=(uint)titleVersion;
            xrl.MachineId=machinePuid;

            return xrl;
        }

        /// <summary>
        ///     Provides wrappers for testing p_auotupd_referal.
        /// </summary>
        class AutoupdReferalHelper
        {
            private const uint TITLE_ID = 0xDEADBEEF;
            private const uint BASE_VERSION = 100;
            private const uint UPDATE_VERSION = 101;
            private const uint BETA_VERSION = 102;
            private const int CONSOLE_TYPE = 2;
            private static string MACHINE_ID = "XE.133712345678";

            private ulong _machineId = 0;
            private Guid _machineGroupId;
            private Guid _updateGroupId;
            private bool _useEmptyGuid;
            private bool _shouldFindUpdate;

            public AutoupdReferalHelper(Guid machineGroupId, Guid updateGroupId, bool useEmptyGuid)
            {
                _machineGroupId = machineGroupId;
                _updateGroupId = updateGroupId;
                _useEmptyGuid = useEmptyGuid;
                _shouldFindUpdate = _machineGroupId == _updateGroupId || _useEmptyGuid;
            }

            public void RunTest()
            {
                SetupTables();
                RunSproc();
            }

            private void SetupTables()
            {
                // Create beta group we will use for the title and the machine.
                BetaGroupEditor.NukeGroup(_machineGroupId);
                BetaGroupEditor.NukeGroup(_updateGroupId);
                BetaGroupEditor machineGroup = BetaGroupEditor.CreateOrUseExistingId(_machineGroupId);
                BetaGroupEditor updateGroup = BetaGroupEditor.CreateOrUseExistingId(_updateGroupId);
                BetaGroupEditor noUpgradeGroup = BetaGroupEditor.CreateOrUseExistingId(Guid.Empty);

                // Define a title in t_titles
                TitleEditor title = TitleEditor.CreateOrUseExistingId(TITLE_ID);
                title.RemoveAllVersions();
                title.RemoveAllUpdatePackages();

                // Define the version upgrade mapping in t_title_versions
                title.AddVersion(BASE_VERSION, UPDATE_VERSION, CONSOLE_TYPE, updateGroup.Id);
                if (_useEmptyGuid)
                {
                    title.AddVersion(BASE_VERSION, BASE_VERSION, CONSOLE_TYPE, noUpgradeGroup.Id);
                }

                // Define the package data in t_title_update_packages
                title.AddUpdatePackage(BASE_VERSION, UPDATE_VERSION, CONSOLE_TYPE);
                if (_useEmptyGuid)
                {
                    title.AddUpdatePackage(BASE_VERSION, BASE_VERSION, CONSOLE_TYPE);
                }

                // Define the title location in t_title_update_locations
                title.AddUpdateLocation(BASE_VERSION, UPDATE_VERSION, CONSOLE_TYPE, 1, "foofoo");
                title.AddUpdateLocation(BASE_VERSION, BASE_VERSION, CONSOLE_TYPE, 1, "barbar");

                // Create a machine and add it to the group
                MachineEditor machine = MachineEditor.CreateOrUseExistingName(MACHINE_ID);
                machineGroup.AddMachine(machine.Id);
                _machineId = machine.Id;
            }

            private void RunSproc()
            {
                // Call p_autoupd_referral
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_autoupd_referral";
                    ws.SetHashVal(_machineId);

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);                            // result
                    ws.AddParameter(ParamType.INPUT, "@bi_machine_puid", _machineId);           // @bi_machine_puid
                    ws.AddParameter(ParamType.INPUT, "@i_title_id", TITLE_ID);                  // @i_title_id
                    ws.AddParameter(ParamType.INPUT, "@ti_console_type_id", CONSOLE_TYPE);      // @ti_console_type_id
                    ws.AddParameter(ParamType.INPUT, "@i_title_base_version", BASE_VERSION);    // @i_title_version
                    ws.AddParameter(ParamType.OUTPUT, "@i_package_size", 0);                    // @i_package_size
                    ws.AddParameter(ParamType.OUTPUT, "@i_install_size", 0);                    // @i_install_size
                    ws.AddParameter(ParamType.OUTPUT, "@i_title_version", 0);                   // @i_title_version
                    ws.AddParameter(ParamType.OUTPUT, "@vb_sym_key", (byte[])null, 1024);       // @vb_sym_key
                    ws.AddParameter(ParamType.OUTPUT, "@vb_public_key", (byte[])null, 1024);    // @vb_public_key

                    using (WstDataReader rs = ws.Execute())
                    {
                        // Validate the rowsets
                        while (rs.Read())
                        {
                            int rank = rs.GetInt32(0);
                            string xrl = rs.GetString(1);
                            Console.WriteLine("Xrl {0} is {1}", rank, xrl);
                        }
                        rs.Close();

                        // Validate the outparams
                        PrintTestOutUIntParam(ws, "@RETVAL", 0);
                        if (_shouldFindUpdate)
                        {
                            PrintTestOutUIntParam(ws, "@i_title_version", _machineGroupId == _updateGroupId ? UPDATE_VERSION : BASE_VERSION);
                        }
                        else
                        {
                            PrintTestOutUIntParam(ws, "@i_title_version", 0);
                        }
                    }
                }
            }

            private void PrintTestOutUIntParam(WSClient ws, string param, uint expected)
            {
                uint val = (uint)ws.GetIntParameter(param);
                Console.WriteLine("{0} = {1}", param, val);
                if (val != expected)
                {
                    throw new UnexpectedTestResultException(String.Format("{0} should be {1} but is {2}", param, expected, val));
                }
            }
        };

        // -- test cases

        //Simple Positive tests
        [TestGroup]
        public class Mainline: TestNode
        {
            public Mainline()
            {
                //add generaned positive cases for different platforms
                AddChild(new MultiPlatform("P_Xbox1", 0, m_titleId, 0), true, false);
                AddChild(new MultiPlatform("P_Xbox360", 0, m_titleId, 2), true, false);
                AddChild(new MultiPlatform("P_PC", 0, m_titleId, 4), true, false);
            }

            /// <summary>
            ///   AutoUpdateReferral: mainline case
            /// </summary>
            /// <remarks>
            ///   <Description> Attempt to pull an auto-update referral location for the base title ID. </Description>
            /// </remarks>
            [TestCase]
            class P_Mainline: TestBase
            {
                override protected void Execute()
                {
                    XRLAutoUpdateReferral request = new XRLAutoUpdateReferral();
                    request.dwBaseVersion = 1;
                    request.TitleId = m_titleId;
                    request.MachineId = XOn.XboxId.XboxMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong());

                    if (request.Execute())
                    {
                        foreach (XRLAutoUpdateReferralLocation loc in request.Locs)
                        {
                            Console.WriteLine(loc.Xrl);
                        }
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                }
            }
        };

        //Simple negative tests
        [TestGroup]
        public class Negative: TestNode
        {
            public Negative()
            {
                //add several generated negative tests
                AddChild(new MultiPlatform("N_Bad_MachinePuid", HResult.XONLINE_E_SERVER_ERROR, m_titleId, 3), true, false);
                AddChild(new MultiPlatform("N_Installsize_Zero", HResult.XONLINE_E_INTERNAL_ERROR, m_titleId + 1, -1), true, false);
            }

            /// <summary>
            ///   AutoUpdateReferral: no updates available
            /// </summary>
            /// <remarks>
            ///   <Description> Test updates for a title version that has no updates. </Description>
            ///     <Verify>
            ///       Return code from request is S_OK.
            ///       Number of returned referral locations is 0.
            ///     </Verify>
            /// </remarks>
            [TestCase]
            class N_No_Updates_Available_Xbox1: TestBase
            {
                override protected void Execute()
                {
                    XRLAutoUpdateReferral request = new XRLAutoUpdateReferral();

                    request.TitleId = BaseTitleId;
                    request.dwBaseVersion = (uint)6;
                    request.MachineId = XOn.XboxId.XboxMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong());
                    request.Execute();
                    if (request.XErr == HResult.S_OK && request.Head.Locations == 0)
                    {
                        throw new UnexpectedTestResultException(request.GetDumpString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            /// <summary>
            ///        AutoUpdateReferral: non existent title
            /// </summary>
            /// <remarks>
            ///   <Description>
            ///      Test updates for an invalid title (non-existent).
            ///   </Description>
            ///     <Verify>
            ///       Return code from request is S_OK.
            ///       Number of returned referral locations is 0.
            ///     </Verify>
            /// </remarks>
            [TestCase]
            class N_Bad_Title: TestBase
            {
                override protected void Execute()
                {
                    XRLAutoUpdateReferral request = new XRLAutoUpdateReferral();
                    request.TitleId = BaseTitleId - 1;
                    request.dwBaseVersion = (uint)0;
                    request.MachineId = XOn.XboxId.XboxMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong());
                    request.Execute();
                    if (request.XErr == HResult.S_OK && request.Head.Locations == 0)
                    {
                        request.Dump();
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        };

        //Test matrix for beta groups, which allow for targetted title and flash updates
        [TestGroup]
        public class BetaGroups: TestNode
        {
            [TestCase, Description("Version 10 does not update normal users, but has different updates for beta groups 0 and 1")]
            [CompoundCase("Xbox360 NoGroup", MachineXeNone, HResult.XONLINE_E_INVALID_REQUEST, 10, "",              (uint)0)]
            [CompoundCase("Xbox360 Group0",  MachineXe0,    (uint)0,                           110, "10-110-xe.xcp", InstallSize0)]
            [CompoundCase("Xbox360 Group1",  MachineXe1,    (uint)0,                           210, "10-210-xe.xcp", InstallSize1)]
            [CompoundCase("Xbox1 NoGroup",   MachineXbNone, HResult.XONLINE_E_INVALID_REQUEST, 10, "",              (uint)0)]
            [CompoundCase("Xbox1 Group0",    MachineXb0,    (uint)0,                           110, "10-110-xb.xcp", InstallSize0)]
            [CompoundCase("PC NoGroup",      MachinePcNone, HResult.XONLINE_E_INVALID_REQUEST, 10, "",              (uint)0)]
            [CompoundCase("PC Group0",       MachinePc0,    (uint)0,                           110, "10-110-pc.xcp", InstallSize0)]
            public class TitleVersion10: TestNode
            {
                public override void Run()
                {
                    string consoleId=(string)MyValues[0];
                    uint expectError=(uint)MyValues[1];
                    uint expectVersion=(uint)(int)MyValues[2];
                    string expectLocation=(string)MyValues[3];
                    uint expectInstallSize=(uint)MyValues[4];

                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 10, MachineEditor.FromName(consoleId).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", expectError, xrl.XErr);
                    if (expectError==0)
                    {
                        VerifyBetaResponse(xrl, expectVersion, expectLocation, expectInstallSize);
                        Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                    }
                }
            };

            [TestCase, Description("Version 11 does not exist for normal users, doesn't exist at all on pc, and only has an update for beta group 0")]
            [CompoundCase("Xbox360 NoGroup", MachineXeNone, HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("Xbox360 Group0",  MachineXe0,    (uint)0,                           "11-111-xe.xcp")]
            [CompoundCase("Xbox360 Group1",  MachineXe1,    HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("Xbox1 NoGroup",   MachineXbNone, HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("Xbox1 Group0",    MachineXb0,    (uint)0,                           "11-111-xb.xcp")]
            [CompoundCase("PC NoGroup",      MachinePcNone, HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("PC Group0",       MachinePc0,    HResult.XONLINE_E_INVALID_REQUEST, "")]
            public class TitleVersion11: TestNode
            {
                public override void Run()
                {
                    string consoleId=(string)MyValues[0];
                    uint expectError=(uint)MyValues[1];
                    string expectLocation=(string)MyValues[2];

                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 11, MachineEditor.FromName(consoleId).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", expectError, xrl.XErr);
                    if (expectError==0)
                    {
                        VerifyBetaResponse(xrl, 111, expectLocation, InstallSize0);
                        Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                    }
                }
            };

            [TestCase, Description("Version 12 only exists for xbox360, and does not update normal users and has an expired update for group 0 and a future update for group 1")]
            [CompoundCase("Xbox360 NoGroup", MachineXeNone)]
            [CompoundCase("Xbox360 Group0",  MachineXe0)]
            [CompoundCase("Xbox360 Group1",  MachineXe1)]
            [CompoundCase("Xbox1 NoGroup",   MachineXbNone)]
            [CompoundCase("Xbox1 Group0",    MachineXb0)]
            [CompoundCase("PC NoGroup",      MachinePcNone)]
            [CompoundCase("PC Group0",       MachinePc0)]
            public class TitleVersion12: TestNode
            {
                public override void Run()
                {
                    string consoleId=(string)MyValues[0];

                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 12, MachineEditor.FromName(consoleId).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", HResult.XONLINE_E_INVALID_REQUEST, xrl.XErr);
                }
            };

            [TestCase, Description("Version 13 only exists for xbox360, and updates for normal users but not for beta group 0")]
            [CompoundCase("Xbox360 NoGroup", MachineXeNone, (uint)0,                           "13-113-xe.xcp")]
            [CompoundCase("Xbox360 Group0",  MachineXe0,    HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("Xbox360 Group1",  MachineXe1,    (uint)0,                           "13-113-xe.xcp")]
            [CompoundCase("Xbox1 NoGroup",   MachineXbNone, HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("Xbox1 Group0",    MachineXb0,    HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("PC NoGroup",      MachinePcNone, HResult.XONLINE_E_INVALID_REQUEST, "")]
            [CompoundCase("PC Group0",       MachinePc0,    HResult.XONLINE_E_INVALID_REQUEST, "")]
            public class TitleVersion13: TestNode
            {
                public override void Run()
                {
                    string consoleId=(string)MyValues[0];
                    uint expectError=(uint)MyValues[1];
                    string expectLocation=(string)MyValues[2];

                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 13, MachineEditor.FromName(consoleId).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", expectError, xrl.XErr);
                    if (expectError==0)
                    {
                        VerifyBetaResponse(xrl, 113, expectLocation, InstallSize0);
                        Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                    }
                }
            };

            [TestCase, Description("Version 14 uses a machine in 2 groups, but is ok for this version"), Ignore("We added a unique key constraint for the 2010 March XSR, so this test isn't possible until we remove that later.")]
            public class TitleVersion14: TestNode
            {
                public override void Run()
                {
                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 14, MachineEditor.FromName(MachineXeConflicted).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", (uint)0, xrl.XErr);
                    VerifyBetaResponse(xrl, 114, "14-114-xe.xcp", InstallSize0);
                    Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                }
            };

            [TestCase, Description("Version 15 uses a machine in 2 groups with the same base version, but has a conflict on which to upgrade to"), Ignore("We added a unique key constraint for the 2010 March XSR, so this test isn't possible until we remove that later.")]
            public class TitleVersion15: TestNode
            {
                public override void Run()
                {
                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 15, MachineEditor.FromName(MachineXeConflicted).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    if (xrl.XErr==0)
                    {
                        Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                    }
                    ValueCheck.Test("Response XErr", HResult.XONLINE_E_INVALID_REQUEST, xrl.XErr);
                }
            };

            [TestCase, Description("Version 16 uses a machine in 2 groups with the same base version, but both update to the same version, so there is no conflict"), Ignore("We added a unique key constraint for the 2010 March XSR, so this test isn't possible until we remove that later.")]
            public class TitleVersion16: TestNode
            {
                public override void Run()
                {
                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 16, MachineEditor.FromName(MachineXeConflicted).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", (uint)0, xrl.XErr);
                    VerifyBetaResponse(xrl, 116, "16-116-xe.xcp", InstallSize0);
                    Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                }
            };

            [TestCase, Description("Version 17 held group 0 on version 17 until yesterday, and updates everyone to 18 now")]
            [CompoundCase("NoGroup", MachineXeNone)]
            [CompoundCase("Group0",  MachineXe0)]
            [CompoundCase("Group1",  MachineXe1)]
            public class TitleVersion17: TestNode
            {
                public override void Run()
                {
                    string consoleId=(string)MyValues[0];

                    XRLAutoUpdateReferral xrl=CreateTitleRequest(BetaTitleId, 17, MachineEditor.FromName(consoleId).Id);
                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", 0, xrl.XErr);
                    VerifyBetaResponse(xrl, 18, "17-18-xe.xcp", InstallSize0);
                    Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                }
            };

            [TestCase, Description("Flash version 250 goes to 251 for flash group 0 and 252 for flash group 1")]
            [CompoundCase("TitleVersion1 Xbox360 NoGroup",       MachineXbNone,   1,   HResult.XONLINE_E_INVALID_REQUEST, 0,   "",                    (uint)0)]
            [CompoundCase("TitleVersion1 Xbox360 FlashGroup0",   MachineXeFlash0, 1,   (uint)0,                           251, "250-251-xeflash.xcp", InstallSize0)]
            [CompoundCase("TitleVersion1 Xbox360 FlashGroup1",   MachineXeFlash1, 1,   (uint)0,                           252, "250-252-xeflash.xcp", InstallSize1)]
            [CompoundCase("TitleVersion250 Xbox360 NoGroup",     MachineXbNone,   250, HResult.XONLINE_E_INVALID_REQUEST, 0,   "",                    (uint)0)]
            [CompoundCase("TitleVersion250 Xbox360 FlashGroup0", MachineXeFlash0, 250, (uint)0,                           251, "250-251-xeflash.xcp", InstallSize0)]
            [CompoundCase("TitleVersion250 Xbox360 FlashGroup1", MachineXeFlash1, 250, (uint)0,                           252, "250-252-xeflash.xcp", InstallSize1)]
            public class FlashVersion250: TestNode
            {
                public override void Run()
                {
                    string consoleId=(string)MyValues[0];
                    uint sgInfoTitleVersion=(uint)(int)MyValues[1];
                    uint expectError=(uint)MyValues[2];
                    uint expectUpdateVersion=(uint)(int)MyValues[3];
                    string expectLocation=(string)MyValues[4];
                    uint expectInstallSize=(uint)MyValues[5];

                    XRLAutoUpdateReferral xrl=new XRLAutoUpdateReferral();
                    //set parameters
                    xrl.TitleId=0xfffe07d1;
                    xrl.dwBaseVersion=(uint)1888; //this is IGNORED for flash updates, and instead the client version from sginfo is used
                    xrl.MachineId=MachineEditor.FromName(consoleId).Id;

                    //set sginfo
                    xrl.ManualPopulateSlot();
                    xrl.Slot.machinePuid=xrl.MachineId;
                    xrl.Slot.wMajorVersion=0;
                    xrl.Slot.wMinorVersion=0;
                    xrl.Slot.wBuildNumber=0;
                    xrl.Slot.wQFENumber=250;
                    xrl.Slot.titleId=xrl.TitleId;
                    xrl.Slot.titleVersion=250;

                    xrl.Execute();

                    Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                    ValueCheck.Test("Response XErr", expectError, xrl.XErr);
                    if (expectError==0)
                    {
                        VerifyBetaResponse(xrl, expectUpdateVersion, expectLocation, expectInstallSize);
                        Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                    }
                }
            };
        };

        [TestGroup, Description("Tests for the t_machines update version columns being updated.")]
        public class MachineUpdateData: TestNode
        {
            [TestCase, Description("Flash updates should cause the update requested columns to be updated.")]
            [CompoundCase("Xbox360 Normal", (int)241, (uint)0xfffe07d1, MachineXeSystem1)]
            [CompoundCase("Xbox360 Beta",   (int)242, (uint)0xfffe07d1, MachineXeSystem0)]
            [CompoundCase("PC Normal",      (int)243, (uint)0x585207D1, MachinePcSystem1)]
            [CompoundCase("PC Beta",        (int)244, (uint)0x585207D1, MachinePcSystem0)]
            public void ValidFlash(TestNode self)
            {
                int expectedUpdateToVersion=(int)self.MyValues[0];
                uint title=(uint)self.MyValues[1];
                string consoleId=(string)self.MyValues[2];

                MachineEditor mach=MachineEditor.FromName(consoleId);

                //set parameters
                XRLAutoUpdateReferral xrl=new XRLAutoUpdateReferral();
                xrl.TitleId=title;
                xrl.dwBaseVersion=(uint)240; //this is IGNORED for flash updates, and instead the client version from sginfo is used.  still client will normally set it
                xrl.MachineId=mach.Id;

                //set sginfo
                xrl.ManualPopulateSlot();
                xrl.Slot.machinePuid=xrl.MachineId;
                xrl.Slot.wMajorVersion=0;
                xrl.Slot.wMinorVersion=0;
                xrl.Slot.wBuildNumber=0;
                xrl.Slot.wQFENumber=240;
                xrl.Slot.titleId=xrl.TitleId;
                xrl.Slot.titleVersion=240;

                xrl.Execute();

                //verify response code
                Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                ValueCheck.Test("Response XErr", 0, xrl.XErr);
                if (xrl.XErr==0)
                {
                    Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                }

                //verify db entry
                ValueCheck.Test("t_machines update version", "00.00.00000."+expectedUpdateToVersion, mach.ClientFlashUpdateVersion);
                ValueCheck.Test("t_machines update version changed date", System.DateTime.UtcNow, mach.ClientFlashUpdateVersionChangedDate, new System.TimeSpan(0, 5, 0));
            }

            [TestCase, Description("Title updates should NOT cause the update requested columns to be updated.")]
            [CompoundCase("Xbox360", MachineType.Xbox360)]
            [CompoundCase("PC",      MachineType.PC)]
            public void ValidTitle(TestNode self)
            {
                MachineType mtype=(MachineType)self.MyValues[0];
                MachineEditor mach=MachineEditor.CreateNew(mtype);

                string initialVersion=mach.ClientFlashUpdateVersion;
                System.DateTime? initialDate=mach.ClientFlashUpdateVersionChangedDate;

                //set parameters
                XRLAutoUpdateReferral xrl=new XRLAutoUpdateReferral();
                xrl.TitleId=UpdateDataTitleId;
                xrl.dwBaseVersion=(uint)100;
                xrl.MachineId=mach.Id;

                //set sginfo
                xrl.ManualPopulateSlot();
                xrl.Slot.machinePuid=xrl.MachineId;
                xrl.Slot.wMajorVersion=0;
                xrl.Slot.wMinorVersion=0;
                xrl.Slot.wBuildNumber=0;
                xrl.Slot.wQFENumber=246;
                xrl.Slot.titleId=xrl.TitleId;
                xrl.Slot.titleVersion=100;

                xrl.Execute();

                //verify response code
                Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                ValueCheck.Test("Response XErr", 0, xrl.XErr);
                if (xrl.XErr==0)
                {
                    Global.RO.Debug("Got Location: "+xrl.Locs[0].Xrl);
                }

                //verify db entry
                ValueCheck.Test("t_machines update version", initialVersion, mach.ClientFlashUpdateVersion);
                ValueCheck.Test("t_machines update version changed date", initialDate, mach.ClientFlashUpdateVersionChangedDate);
            }

            [TestCase, Description("Failed requests for flash should not cause anything to change.")]
            public void InvalidFlash()
            {
                MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);

                string initialVersion=mach.ClientFlashUpdateVersion;
                System.DateTime? initialDate=mach.ClientFlashUpdateVersionChangedDate;

                //set parameters
                XRLAutoUpdateReferral xrl=new XRLAutoUpdateReferral();
                xrl.TitleId=0xfffe07d1;
                xrl.dwBaseVersion=(uint)100;
                xrl.MachineId=mach.Id;

                //set sginfo
                xrl.ManualPopulateSlot();
                xrl.Slot.machinePuid=xrl.MachineId;
                xrl.Slot.wMajorVersion=0;
                xrl.Slot.wMinorVersion=0;
                xrl.Slot.wBuildNumber=0;
                xrl.Slot.wQFENumber=245;
                xrl.Slot.titleId=xrl.TitleId;
                xrl.Slot.titleVersion=255;

                xrl.Execute();

                //verify response code
                Global.RO.Debug("Got XErr: 0x{0:X}", xrl.XErr);
                ValueCheck.Test("Response XErr", HResult.XONLINE_E_INVALID_REQUEST, xrl.XErr);

                //verify db entry
                ValueCheck.Test("t_machines update version", initialVersion, mach.ClientFlashUpdateVersion);
                ValueCheck.Test("t_machines update version changed date", initialDate, mach.ClientFlashUpdateVersionChangedDate);
            }
        };

        //direct test of the sprocs
        [TestGroup]
        public class SprocTests: TestNode
        {
            private const string GroupMember = "DEADBEEF-CAFE-BABE-BADD-000000000001";
            private const string GroupNonMember = "DEADBEEF-CAFE-BABE-BADD-000000000002";

            [TestCase, Description("Tests just p_autoupd_referal.")]
            [CompoundCase("Xbox360 Machine in Group", GroupMember, GroupMember, false)]
            [CompoundCase("Xbox360 Machine not in Group Default", GroupMember, GroupNonMember, true)]
            [CompoundCase("Xbox360 Machine not in Group no Default", GroupMember, GroupNonMember, false)]
            class Autoupd_Sproc : TestNode
            {
                public override void Run()
                {
                    Guid g1 = new Guid((string)MyValues[0]);
                    Guid g2 = new Guid((string)MyValues[1]);
                    bool empty = (bool)MyValues[2];

                    AutoupdReferalHelper helper = new AutoupdReferalHelper(g1, g2, empty);
                    helper.RunTest();
                }
            }
        };
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\pso\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__pso_4_none_12.4.56.0_none_edbd43f8a4a78eca
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_pso_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.manifest
XP_MANIFEST_PATH=manifests\x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.cat
XP_CATALOG_PATH=manifests\x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8.cat
XP_PAYLOAD_PATH=x86__pso_4_no-public-key_12.4.56.0_x-ww_d94b1db8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_pso_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\billing\useraccount\fd\GetUserAuthorization.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.geofence;
using xonline.common.mgmt;
using xonline.common.musicnet;
using xonline.common.offer;
using xonline.common.passport;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.user;
using xonline.common.utilities;

namespace xonline.server.billing.useraccount.fd
{
    public partial class UserAccount
    {
        [XmlRootAttribute(ElementName="GetUserAuthorizationInfo")]
        public class GetUserAuthorizationInfo
        {
            public ErrorInfo           ErrorInfo;

            public AccountInfo         AccountInfo;

            [XmlArrayItem(ElementName="Subscription")]
            public SubscriptionInfo[]  SubscriptionInfo;

            public SessionInfo         SessionInfo;
        }

        [WebMethod]
        public GetUserAuthorizationInfo GetUserAuthorization(
            int  serviceType,
            uint titleId
        )
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            string ipAddress;

            User u = null;
            ErrorInfo errorInfo = null;
            GetUserAuthorizationInfo response = null;

            CallSource.Check(VirtualInterface.xuacs, VirtualInterface.xuacs_int);

            try
            {
                GetUserAuthorizationCounters.Current.ExecPerSecond.Increment();
                GetUserAuthorizationCounters.Current.ExecTotal.Increment();

                ClientTypeEnum clientType = GetClientType();
                
                response = new GetUserAuthorizationInfo();
                errorInfo = response.ErrorInfo = new ErrorInfo();
                errorInfo.HResult = HResult.S_OK;

                // validate the user and retrieve details from UODB
                Authenticate(clientType, serviceType, errorInfo, out u, out ipAddress);

                // and if they have any errors then we are pretty  much  done
                if (HResult.Failed(errorInfo.HResult)) {
                    Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "GetUserAuthorization: " + (null == u ? "" : "user " + (Puid) u.Puid + ", ") + 
                        errorInfo.Message);
                    goto Cleanup;
                }

                // if the user still doesn't have a MusicNet account and the origin on the request is not an Xbox 360, create it now
                if ((ServiceTypeEnum) serviceType == ServiceTypeEnum.Zune
                && clientType != ClientTypeEnum.Xenon)
                {
                    if (!u.HasMusicnetAccount)
                    {
                        try
                        {
                            MusicnetClient.CreateMusicnetAccount(u);
                        }
                        catch (Exception e)
                        {
                            HResult hr = BillingProviderException.ToHResult(e, HResult.XONLINE_E_WCMUSIC_MUSICNET_ERROR);
                            string msg = "GetUserAuthorization: call to MusicnetClient.CreateMusicnetAccount failed for user = " + (Puid) u.Puid + " ";

                            Xom.Trace(XomAreaName.xuacs, LogLevel.L_ERROR, msg + e);
                            Xom.NtEvent( XEvent.Id.BILLING_USERACCOUNT_MUSICNET_FAILURE, e, msg);

                            errorInfo.HResult = hr;
                            goto Cleanup;
                        }
                    }
                }

                // use some common helper functions to fill in the user  info
                response.AccountInfo = GetAccountInfo(u, (ServiceTypeEnum) serviceType, clientType, titleId, ref errorInfo);
                response.SubscriptionInfo = GetSubscriptionInfo(u, (ServiceTypeEnum) serviceType, clientType, titleId, ref errorInfo);
                response.SessionInfo = GetSessionInfo(u, (ServiceTypeEnum) serviceType, clientType, ipAddress);

                errorInfo.HResult = HResult.S_OK;

                // try to update the last login time for Zune
                try
                {
                    u.UpdateClientActivity((ServiceTypeEnum) serviceType, clientType);
                }
                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.xuacs, LogLevel.L_ERROR, "GetUserAuthorization: failed to update client activity\r\n" + e.ToString());
                }

    Cleanup:
                if (errorInfo == null || HResult.Failed(errorInfo.HResult))
                {
                    GetUserAuthorizationCounters.Current.ExecFailedPerSecond.Increment();
                    GetUserAuthorizationCounters.Current.ExecFailedTotal.Increment();
                }

                return response;
            }
            catch (Exception e)
            {
                GetUserAuthorizationCounters.Current.ExecFailedPerSecond.Increment();
                GetUserAuthorizationCounters.Current.ExecFailedTotal.Increment();

                FrontEndApp.LogException(e);

                throw;
            }
            finally
            {
                string szLog = string.Join("|", new string []
                {
                    "GetUserAuthorization",
                    u == null ? "" : u.PassportPuid.ToString("x"),
                    u == null ? "" : u.Puid.ToString("x"),
                    errorInfo == null ? "" : ((HResult) errorInfo.HResult).ToString(),
                    (response == null || response.AccountInfo == null) ? "" : response.AccountInfo.PointsBalance.ToString("d"),
                    (response == null || response.SubscriptionInfo == null) ? "" : response.SubscriptionInfo[0].OfferId.ToString("x"),
                    (response == null || response.SubscriptionInfo == null) ? "" : response.SubscriptionInfo[0].Status,
                    (response == null || response.SessionInfo == null || response.SessionInfo.GeoCountryCode == null) ? "" : response.SessionInfo.GeoCountryCode
                });

                Xom.Log(XomAreaName.log, szLog);

                GetUserAuthorizationCounters.Current.ExecTime.IncrementBy(timeElapsed.TimeElapsed);
                GetUserAuthorizationCounters.Current.ExecTimeBase.Increment();
            }
        }

        protected static Dictionary<string, int> _nameToClientTypeMapping;
        protected static Dictionary<int, int> _platformToClientTypeMapping;

        private static void InitClientTypeMapping()
        {
            try {
                Config.MultiSettingChange += new MultiSettingChangeEventHandler(OnClientTypeChange);
                LoadNameToClientTypeMapping(Config.GetMultiSetting(MultiSetting.xuacs_nameToClientTypeMapping));
                LoadPlatformToClientTypeMapping(Config.GetMultiSetting(MultiSetting.xuacs_platformToClientTypeMapping));
            }

            // static constructors don't run in an application thread.
            // feapp will never see it. so we log the event ourselves.

            catch (Exception e) {
                Xom.NtEvent(XEvent.Id.XUACS_CLIENT_TYPE_CONFIG_ERROR, "Error loading client type mapping\r\n" + e.ToString());
                throw;
            }
        }

        public static void OnClientTypeChange(object sender, MultiSettingChangeEventArgs e)
        {
            if (e.MultiSetting == MultiSetting.xuacs_nameToClientTypeMapping)
                LoadNameToClientTypeMapping(e.ValueNew);
            else if (e.MultiSetting ==  MultiSetting.xuacs_platformToClientTypeMapping) {
                LoadPlatformToClientTypeMapping(e.ValueNew);
            }
        }

        private static void LoadNameToClientTypeMapping(string[] clientTypeSettings)
        {
            Dictionary<string, int> nameToClientTypeMapping  = new Dictionary<string, int>();

            foreach (string clientTypeSetting in clientTypeSettings)
            {
                string[] s = clientTypeSetting.Split(',');

                // there must be two element.  the name and a client type

                if ((s == null) || (s.Length != 2) || string.IsNullOrEmpty(s[0]) || string.IsNullOrEmpty(s[1])) {
                    throw new XRLException(
                        HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR, XEvent.Id.XUACS_CLIENT_TYPE_CONFIG_ERROR,
                        "Invalid format for setting {0}, '{1}'", MultiSetting.xuacs_nameToClientTypeMapping, clientTypeSetting
                    );
                }

                int clientType;

                try {
                    clientType = Int32.Parse(s[1]);
                }
                catch (Exception e) {
                    throw new XRLException(
                        HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR, XEvent.Id.XUACS_CLIENT_TYPE_CONFIG_ERROR,
                        e, "Invalid value for setting {0}, '{1}'", MultiSetting.xuacs_nameToClientTypeMapping, clientTypeSetting
                    );
                }

                try {
                    nameToClientTypeMapping.Add(s[0].ToLower(), clientType);
                }
                catch (Exception e) {
                    throw new XRLException(
                        HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR, XEvent.Id.XUACS_CLIENT_TYPE_CONFIG_ERROR,
                        e, "Duplicate definition for setting {0}, {1}", MultiSetting.xuacs_nameToClientTypeMapping, clientTypeSetting
                    );
                }
            }

            _nameToClientTypeMapping = nameToClientTypeMapping;
        }


        private static void LoadPlatformToClientTypeMapping(string[] clientTypeSettings)
        {
            Dictionary<int, int> platformToClientTypeMapping  = new Dictionary<int, int>();

            foreach (string clientTypeSetting in clientTypeSettings)
            {
                string[] s = clientTypeSetting.Split(',');

                // there must be two element.  the name and a client type

                if ((s == null) || (s.Length != 2) || string.IsNullOrEmpty(s[0]) || string.IsNullOrEmpty(s[1])) {
                    throw new XRLException(
                        HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR, XEvent.Id.XUACS_CLIENT_TYPE_CONFIG_ERROR,
                        "Invalid format for setting {0}, '{1}'", MultiSetting.xuacs_platformToClientTypeMapping, clientTypeSetting
                    );
                }

                int platformType;
                int clientType;

                try {
                    platformType = Int32.Parse(s[0]);
                    clientType   = Int32.Parse(s[1]);
                }
                catch (Exception e) {
                    throw new XRLException(
                        HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR, XEvent.Id.XUACS_CLIENT_TYPE_CONFIG_ERROR,
                        e, "Invalid value for setting {0}, '{1}'", MultiSetting.xuacs_platformToClientTypeMapping, clientTypeSetting
                    );
                }

                try {
                    platformToClientTypeMapping.Add(platformType, clientType);
                }
                catch (Exception e) {
                    throw new XRLException(
                        HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR, XEvent.Id.XUACS_CLIENT_TYPE_CONFIG_ERROR,
                        e, "Duplicate definition for setting {0}, {1}", MultiSetting.xuacs_platformToClientTypeMapping, clientTypeSetting
                    );
                }
            }

            _platformToClientTypeMapping = platformToClientTypeMapping;
        }

        private ClientTypeEnum GetClientType()
        {
            if (_nameToClientTypeMapping == null) LoadNameToClientTypeMapping(Config.GetMultiSetting(MultiSetting.xuacs_nameToClientTypeMapping));
            if (_platformToClientTypeMapping == null) LoadPlatformToClientTypeMapping(Config.GetMultiSetting(MultiSetting.xuacs_platformToClientTypeMapping));

            int clientTypeValue;
            string clientTypeName;

            if (!SGInfo.IsActiveAuth() && SGInfo.IsFromLiveCache())
            {
                string externalPlatformHeader = GetHeader(XHttpHdr.XPLT_I);
                if (!string.IsNullOrEmpty(externalPlatformHeader))
                {
                    byte externalPlatformType = byte.Parse(externalPlatformHeader);

                    if (_platformToClientTypeMapping.TryGetValue(externalPlatformType, out clientTypeValue))
                    {
                        return (ClientTypeEnum) clientTypeValue;
                    }
                }
            }

            // if they have a client type header, then use it otherwise
            // see if they have auth info and  get  the  platform  type

            if ((clientTypeName = GetHeader("X-ClientType")) == null)
            {
                byte platformType = SGInfo.IsActiveAuth() ? AAInfo.Current.PlatformType : SGInfo.Current.GetPlatformType();

                if (_platformToClientTypeMapping.TryGetValue(platformType, out clientTypeValue))
                {
                    return (ClientTypeEnum) clientTypeValue;
                }

                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_MISSING, XEvent.Id.XUACS_CLIENT_TYPE_MISSING, "Client type is missing");
            }

            // we have a clientType from the header, now we need to parse it to
            // get the client name from the string (which may contain a version)

            int index = clientTypeName.IndexOf('/');
            string clientVersion = index == -1 ? string.Empty : clientTypeName.Substring(index + 1);
            clientTypeName = index == -1 ? clientTypeName : clientTypeName.Substring(0, index);

            // find the client string in the dictionary and
            // translate into the client  type  enumeration

            if (! _nameToClientTypeMapping.TryGetValue(clientTypeName.ToLower(), out clientTypeValue))
            {
                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_CLIENT_TYPE_INVALID, XEvent.Id.XUACS_CLIENT_TYPE_INVALID, "Client type {0} is invalid", clientTypeName);
            }

            return (ClientTypeEnum) clientTypeValue;
        }


        private string GetHeader(string header)
        {
            HttpContext context = HttpContext.Current;
            if (context == null) return null;

            HttpRequest request = context.Request;
            if (request == null) return null;

            return request.Headers[header];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\fd\CatalogInfoHealthBlock.cs ===
//
// CatalogInfoHealthBlock.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections.Specialized;

using xonline.common.fse;
using xonline.common.health;

namespace xonline.server.catalog.fd
{

    public class CatalogInfoHealthBlock : IHealthBlock
    {
        public CatalogInfoHealthBlock()
        {
            // leave this empty
        }

        public ResourceTypeEnum ResourceType 
        { 
            get { return ResourceTypeEnum.Local; } 
        }

        public void DoCheck(
            HealthBlockManager  blockManager, 
            NameValueCollection blockParams,
            HealthReport        report
        )
        {
            try
            {
                string[] methodName = blockParams.GetValues("MethodName");
                string[] names      = blockParams.GetValues("Names");
                string[] values     = blockParams.GetValues("Values");

                if (methodName == null || methodName.Length != 1)
                    throw new Exception("Healthcheck configuration error.  Must specify exactly one 'MethodName' parameter");
                else if (names == null || names.Length == 0)
                    throw new Exception("Healthcheck configuration error. No 'Names' parameters specified");
                else if (values == null || values.Length == 0)
                    throw new Exception("Healthcheck configuration error. No 'Values' parameters specified");
                else if (names.Length != values.Length) {
                    throw new Exception("Healthcheck configuration error. Number of 'Names' and 'Values' must match");
                }

                FseRequest request = new FseRequest(methodName[0], names, values);
                FseResponse response = Catalog.FseService.Execute(request);

                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\fd\CatalogFTS.cs ===
// CatalogSFTS.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.catalogutil;
using xonline.common.config;
using xonline.common.fse;
using xonline.common.installer;
using xonline.common.mgmt;
//using xonline.common.protocol;
using xonline.common.service;
using xonline.server.mgmt.soap;


[assembly: XomIisInstallerAttribute(Interface.catalog)]
[assembly: XomIisInstallerAttribute(Interface.catalog_int)]

namespace xonline.server.catalog.fd
{
    /// <summary>
    /// This class implements all of the catalogFTS web methods.  
    /// </summary>
    /// 
    [WebService(Namespace = "urn:schemas-xbox-com:catalog-data")]
    public class CatalogFTS
    {
        private static FseService _service;

        static CatalogFTS() {
            _service = new FseService("CatalogFTS", "npdb", new CatalogResultHandler(), new CatalogPageHandler());
        }

        public static void Load() {
            _service.Load();
        }

        public static void Flush()
        {
            _service.Flush(null, null, null, false); 
        }

        [WebMethod]
        public XmlNode Query(
            string methodName, string[] Names, string[] Values
        ) {
            try
            {
                try {
                    return CatalogHelper.Query(_service, methodName, Names, Values);
                }

                catch (Exception e) {
                    throw new CatalogException(e);
                }
            }

            catch (Exception e)
            {
                SoapFrontEndApp.LogException(e);
                throw;
            }
        }


        [WebMethod]
        public XmlNode Execute(
            string methodName, string[] Names, string[] Values, int PageSize, int PageNum
        ) {
            return Query(methodName, Names, Values);
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\fd\Catalog.cs ===
//
// CatalogService.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections.Specialized;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.catalogutil;
using xonline.common.config;
using xonline.common.fse;
using xonline.common.feapp;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.server.mgmt.soap;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.catalog)]

[assembly: XomIisInstallerAttribute(Interface.catalog)]
[assembly: XomIisInstallerAttribute(Interface.catalog_int)]
[assembly: ConfigAttribute(Component.catalog)]

namespace xonline.server.catalog.fd
{

    public class CatalogFeApp : SoapFrontEndApp
    {
        public override void Application_Start(object sender, EventArgs eventArgs)
        {
            base.Application_Start(sender, eventArgs);
            EventBuilder.ShowSGInfo = false;

            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest2);

            XBanc.Init();
        }

        public override void Application_End(object sender, EventArgs eventArgs)
        {
            // Custom end code

            base.Application_End(sender, eventArgs);
        }

        // added just to initialize AAInfo
        public override void Application_PostAuthenticateRequest(object sender, EventArgs eventArgs)
        {
            base.Application_PostAuthenticateRequest(sender, eventArgs);

            // Init the Context cache, so errors/events can use the base AAInfo object
            AAInfo aa = AAInfoInternetTier.Current; 
        }

        public override void Application_BeginRequest(object sender, EventArgs eventArgs)
        {
            base.Application_BeginRequest(sender, eventArgs);
            FrontEndCompression.Compress(HttpContext.Current);

            // this section as added for Story 22569 - Add additional flag to bypass XBANC (for testing purposes)
            HttpContext ctx = HttpContext.Current;
            HttpRequest request = ctx != null ? ctx.Request : null;

            if (request != null)
            {
                RequestHeaderBehaviorInjectionMgr.AddBehaviorInjections(request.Headers);
            }
        }

        public override void Application_EndRequest(object sender, EventArgs eventArgs)
        {
            RequestHeaderBehaviorInjectionMgr.ClearBehaviorInjections();
            base.Application_EndRequest(sender, eventArgs);
        }

        public void OnControlRequest2(object sender, ControlRequestEventArgs args)
        {
            try 
            {
                switch(args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(
                            "Catalog help:\r\n" +
                            "  flush [methodName] -- flushes catalog results cache\r\n" +
                            "  reload             -- reloads catalog methods and parameters\r\n" +
                            "\r\n",
                            args.RequestId
                        );

                        args.Handled = true;
                        break;

                    case "reload":
                        Catalog.Load();

                        XomControlConnection.SendMessage(
                            "Catalog methods and parameters have been reloaded\r\n", args.RequestId
                        );

                        CatalogFTS.Load();
                        XomControlConnection.SendMessage(
                            "CatalogFTS methods and parameters have been reloaded\r\n", args.RequestId
                        );

                        args.Handled = true;
                        break;

                    case "flush":
                        if ((args.CommandArgs == null) || (args.CommandArgs.Length == 0))
                            Catalog.Flush(null);
                        else if ((args.CommandArgs != null) && (args.CommandArgs.Length == 1))
                            Catalog.Flush(args.CommandArgs[0]);
                        else
                        {
                            XomControlConnection.SendMessage(
                                "Invalid arguments,  must specify 0 or 1 methodNames\r\n", args.RequestId
                            );

                            args.Handled = true;
                            break;
                        }

                        XomControlConnection.SendMessage(
                            "Catalog results cache has been flushed\r\n", args.RequestId
                        );

                        if ((args.CommandArgs == null) || (args.CommandArgs.Length == 0))
                        {
                            CatalogFTS.Flush();

                            XomControlConnection.SendMessage(
                                "CatalogFTS results cache has been flushed\r\n", args.RequestId
                            );
                        }

                        args.Handled = true;
                        break;
                }
            } catch (Exception e) {
                HResult hr = XRLException.ToHResult(e, HResult.XONLINE_E_CATALOG_ERROR);
                XomControlConnection.SendMessage(
                    string.Format("Error: {0}, hr = {1}\r\n\r\n", e.ToString(), hr),
                    args.RequestId
                );
            }
        }        
    }

    public class CatalogException : ExceptionWithEventId, ExceptionWithHResult
    {
        public CatalogException(Exception innerException) : base(
            XEvent.Id.CATALOG_QUERY_ERROR, innerException.Message, innerException
        ) {
            HResult = XRLException.ToHResult(innerException, (uint) xonline.common.service.HResult.XONLINE_E_CATALOG_ERROR);
        }

        public new HResult HResult
        {
            get { return (uint) (int) base.HResult; }
            set { base.HResult = (int) (uint) value; }
        }
    }

    /// <summary>
    /// This class implements all of the catalog web methods.  
    /// </summary>
    /// 
    [WebService(Namespace = "urn:schemas-xbox-com:catalog-data")]
    public class Catalog
    {
        private static  FseService          _service;
        private static  CatalogDelegates    _cd;


        static Catalog()
        {
            _service = new FseService("Catalog", "npdb", new CatalogResultHandler(), new CatalogPageHandler());
            _cd = new CatalogDelegates();
            
            // Add application specific delegates
            _service.AddParamDelegate("EditorialPrivilege", new FseParamDelegate(_cd.EditorialPrivilegeDelegate));
            _service.AddParamDelegate("Bookmark", new FseParamDelegate(_cd.AdjustBookmarkDelegate));
            _service.AddParamDelegate("VisibilityLevel", new FseParamDelegate(_cd.AdjustVisibilityLevelDelegate));        
        }

        internal static FseService FseService {
            get { return _service; }
        }

        public static void Load()
        {
            _service.Load();
        }

        public static void Flush(string methodName)
        {
            _service.Flush(methodName, null, null, false); 
        }

        [WebMethod]
        public XmlNode Execute(
            string methodName, string[] Names, string[] Values, int PageSize, int PageNum
        ) {
            return Query(methodName, Names, Values);
        }

        [WebMethod]
        public XmlNode Query(
            string methodName, string[] Names, string[] Values
        ) {
            try 
            {
                try {
                    return CatalogHelper.Query(_service, methodName, Names, Values);
                }

                catch (Exception e) {
                    throw new CatalogException(e);
                }
            }

            catch (Exception e)
            {
                SoapFrontEndApp.LogException(e);
                throw;
            }
        }

        [WebMethod]
        public string TestConnection(string inputMessage)
        {
            try
            {
                return inputMessage;
            }
            catch (Exception e)
            {
                SoapFrontEndApp.LogException(e);
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\CatalogTestGlobal.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Timers;
using System.Data.SqlClient;
using System.Data;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Net;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;
using Thread = System.Threading.Thread;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.sql.sqlclient;
using xonline.common.config;

using Catalog;
using Catalog.TestCaseXmlParser;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;
using DetailView = Catalog.DetailView;

using live.common;
using live.common.next;
using live.client;
using live.protocol.next;
using live.server.next;
using WebRequestBase = live.protocol.next.WebRequestBase;
using FilterBase = live.common.next.FilterBase;

[assembly: RootNode(typeof(CatalogTests.CatalogQueryTestSuite))]

namespace CatalogTests
{
    public class CatalogQueryTestSuite : TestNode
    {
        public const string FeCatalogDBXbox = "FeCatalogDBXbox";
        public const string FeCatalogDBZune = "FeCatalogDBZune";
        private static string feCatalogDBXboxConnectionString = null;
        public CatalogQueryTestSuite()
            : base()
        {
            live.common.Config.SetConfig(new STFConfig());
        }


        public static string FECatalogDBXboxConnectionString {
         get {
                if(feCatalogDBXboxConnectionString == null)
                    feCatalogDBXboxConnectionString = ConfigUtil.FECatalogDBXboxConnectionString;
                return feCatalogDBXboxConnectionString;
            }
        }
    }



    public class EditorialVisibility
    {


        static MediaVisibilities[] VisibilityMedia = {            
            
               new MediaVisibilities("00020013-0002-0001-0113-000000000099",1,1),
               new MediaVisibilities("00020013-0002-0001-0113-000000000100",2,1),
               new MediaVisibilities("00020013-0002-0001-0113-000000000101",3,1),
               new MediaVisibilities("00020013-0002-0001-0113-000000000102",4,1),
               new MediaVisibilities("00020013-0002-0001-0113-000000000103",5,1),
           

               new MediaVisibilities("00020013-0002-0001-0113-000000000104",1,2),
               new MediaVisibilities("00020013-0002-0001-0113-000000000105",2,2),
               new MediaVisibilities("00020013-0002-0001-0113-000000000106",3,2),
               new MediaVisibilities("00020013-0002-0001-0113-000000000107",4,2),
               new MediaVisibilities("00020013-0002-0001-0113-000000000108",5,2),
           


               new MediaVisibilities("00020013-0002-0001-0113-000000000109",1,3),
               new MediaVisibilities("00020013-0002-0001-0113-000000000110",2,3),
               new MediaVisibilities("00020013-0002-0001-0113-000000000111",3,3),
               new MediaVisibilities("00020013-0002-0001-0113-000000000112",4,3),
               new MediaVisibilities("00020013-0002-0001-0113-000000000113",5,3),
           

               new MediaVisibilities("00020013-0002-0001-0113-000000000114",1,4),
               new MediaVisibilities("00020013-0002-0001-0113-000000000115",2,4),
               new MediaVisibilities("00020013-0002-0001-0113-000000000116",3,4),
               new MediaVisibilities("00020013-0002-0001-0113-000000000117",4,4),
               new MediaVisibilities("00020013-0002-0001-0113-000000000118",5,4),
           

               new MediaVisibilities("00020013-0002-0001-0113-000000000119",1,5),
               new MediaVisibilities("00020013-0002-0001-0113-000000000120",2,5),
               new MediaVisibilities("00020013-0002-0001-0113-000000000121",3,5),
               new MediaVisibilities("00020013-0002-0001-0113-000000000122",4,5),
               new MediaVisibilities( "00020013-0002-0001-0113-000000000123",5,5)
            
            };

        public class MediaVisibilities
        {
            public Guid MediaId;
            public int mVisibility;
            public int oVisibility;
            public MediaVisibilities(string mId, int mVisibility, int oVisibility)
            {
                MediaId = new Guid(mId);
                this.mVisibility = mVisibility;
                this.oVisibility = oVisibility;
            }
            public override string ToString()
            {
                return MediaId.ToString() + ": " + mVisibility.ToString() + ", " + oVisibility.ToString();

            }

            public bool IsEqual(Guid mId, int mV, int oV)
            {
                if (MediaId == mId)
                    if (mVisibility == mV)
                        if (oVisibility == oV) return true;
                return false;

            }
        }

        public static void UpdateOfferExpireDate(string interfaceName)
        {
            using (SqlConnection c = new SqlConnection(ConfigUtil.FECatalogDBXboxConnectionString))
            {

                c.Open();

                using (SqlCommand cmd = c.CreateCommand())
                {

                    cmd.CommandText = @"update OfferInstance set startDateTime =  cast( '01/01/2008' as datetime) + DATEDIFF(""dd"",'01/01/2008',GETDATE())+40  where offerid = '00020013-0000-0004-0113-000000100096'";

                    cmd.CommandType = System.Data.CommandType.Text;

                    Global.RO.Info("Executing: " + cmd.CommandText);


                    Global.RO.Info("Number of rows affected: " + cmd.ExecuteNonQuery());

                    c.Close();

                }
            }            
        }

        public static void VerifyVisibility(string interfaceName)
        {

            Guid[] mediaIds;
            ArrayList list = new ArrayList();

            foreach (MediaVisibilities mv in VisibilityMedia)
            {
                list.Add(mv.MediaId);
            }

            mediaIds = (Guid[])list.ToArray(typeof(Guid));

                using (SqlConnection c = new SqlConnection(ConfigUtil.FECatalogDBXboxConnectionString))
                {

                    c.Open();



                    using (SqlCommand cmd = c.CreateCommand())
                    {

                        cmd.CommandText = @"select m.mediaId, m.visibilityStatusId as mvisibility,oip.visibilityStatusId as ovisibility
from media m inner join offer o on o.mediaId = m.mediaId
inner join medialocale ml on ml.mediaId = m.mediaId
inner join offerInstance oi on oi.offerId = o.offerId
inner join offerInstanceProviderTerm oip on oip.offerInstanceId = oi.offerInstanceId " +
                        " where oi.countrycode = 'US' and ml.lcid = 1033 and m.mediaId in" + BuildMediaIdString(mediaIds);

                        cmd.CommandType = System.Data.CommandType.Text;

                        Global.RO.Info("Executing: " + cmd.CommandText);

                        SqlDataReader reader = null;
                        try
                        {
                            reader = cmd.ExecuteReader();
                            DataTable t = GetDataTable(reader, cmd);

                            if (t.Rows.Count != VisibilityMedia.Length) Global.RO.Error("The number of records in db does not match: expect " +
                                    VisibilityMedia.Length + " Got " + t.Rows.Count);
                            foreach (DataRow row in t.Rows)
                            {
                                bool unexpect = true;

                                Guid mId = (Guid)row["mediaID"];
                                int mvi = (int)row["mvisibility"];
                                int ovi = (int)row["ovisibility"];

                                foreach (MediaVisibilities mv in VisibilityMedia)
                                {

                                    if (mv.IsEqual(mId, mvi, ovi))
                                    {
                                        Global.RO.Success("   Got:" + mId + ": " + mvi + ", " + ovi + " ok");
                                        unexpect = false;
                                        break;
                                    }
                                }
                                if (unexpect) Global.RO.Warn("   Got:" + mId + ": " + mvi + ", " + ovi + " unexpected");

                            }

                        }
                        catch
                        {
                            if (reader != null && !reader.IsClosed) reader.Close();
                            throw;
                        }

                        c.Close();
                    }

                }
        }
        public static string BuildMediaIdString(Guid[] mediaIds)
        {

            string mediaIdsStr = "(";

            int i;

            for (i = 0; i < mediaIds.Length - 1; i++)
            {

                mediaIdsStr += "'" + mediaIds[i].ToString() + "', ";

            }

            mediaIdsStr += "'" + mediaIds[i].ToString() + "')";

            return mediaIdsStr;

        }

        static public DataTable GetDataTable(SqlDataReader reader, SqlCommand scmnd)
        {
            DataTable dt = new DataTable();

            // for each column in the reader, add it to the datatable.. 
            for (int i = 0; i < reader.FieldCount; i++)
            {
                dt.Columns.Add(new DataColumn(reader.GetName(i), reader.GetFieldType(i)));
            }

            // for each record, add the record to data table... 
            while (reader.Read())
            {
                object[] arr = new object[reader.FieldCount];
                reader.GetValues(arr);
                dt.Rows.Add(arr);
            }
            reader.Close();
            return dt;
        }
    }

    public class EditorialTestBase : QueryTestBase
    {
        static string clientIP = null;
        static int siteId = -1;

        public static string UpdateMediaReduceTitle(string interfaceName, bool restore)
        {

            //string interfaceName = store == StoreTypeEnum.Zune ? fecatalogdbzune : fecatalogdbxbox;
            string added = "[" + DateTime.Now.ToLongTimeString().Trim() + "]";
            string newTitle = "Movie 98" + added;

            using (SqlConnection c = new SqlConnection(CatalogQueryTestSuite.FECatalogDBXboxConnectionString))
                {

                    c.Open();

                    using (SqlCommand cmd = c.CreateCommand())
                    {
                        if (!restore)
                            cmd.CommandText = "update mediaLocale set reducedTitle= reducedTitle+ '" + added + "' where mediaid ='00020013-0002-0001-0113-000000000098'";
                        else
                            cmd.CommandText = "update mediaLocale set reducedTitle= Left(reducedTitle, CHARINDEX('[', reducedTitle)-1) " + " where mediaid ='00020013-0002-0001-0113-000000000098'";
                        
                        cmd.CommandType = System.Data.CommandType.Text;

                        Global.RO.Info("Executing: " + cmd.CommandText);



                        Global.RO.Info("Number of rows affected: " + cmd.ExecuteNonQuery());

                        c.Close();

                    }
                }


            return newTitle;
        }

        public EditorialTestBase()
        {
        }

        public EditorialTestBase(TestCaseInfo testInfo)
            : base(testInfo)
        {
            siteId = -1;
            try
            {
                clientIP = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName()).AddressList[1].ToString();
            }
            catch {
                clientIP = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName()).AddressList[0].ToString();
            }
        }



        public static void EditorialClientIPUpdate()
        {

            string settingValue = clientIP + ", 255.255.255.255";
            Global.RO.Info("Add Editorial Client: " + clientIP);
            Global.XEnv.OverrideSetting("ALL", "ALL", "catalog_editorial_ips1", settingValue, siteId);
            //Global.XEnv.DeleteOverrideSetting(string component, string server, string _setting, int siteId)

            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog configcacherefresh");
            Global.RO.Info("Wait 60 seconds");
            Thread.Sleep(6000);

        }


        public static void EditorialClientIPClear()
        {

            string settingValue = clientIP + ", 255.255.255.255";
            Global.RO.Info("Clear Editorial Client: " + clientIP);
            Global.XEnv.DeleteOverrideSetting("ALL", "ALL", "catalog_editorial_ips1", siteId);
            //DeleteOverrideSetting(string component, string server, string _setting, int siteId)

            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog configcacherefresh");
            Global.RO.Info("Wait 60 seconds");
            Thread.Sleep(6000);
        }


        protected override void Init()
        {
            base.Init();
            QueryFilter = new FindVideosFilter();
            MethodName = QueryRequestBase.QueryMethod.FindVideos;

        }


        protected override void InnerExecute()
        {
            string newTitle = null;

            try
            {
                EditorialClientIPUpdate();
                for (int i = 0; i < 2; i++)
                {
                    if (i == 1) newTitle = UpdateMediaReduceTitle("fecatalogdbxbox", false);
                    if (string.IsNullOrEmpty(CustomQuery))
                    {
                        List<StringPair> filterList = QueryFilter.BuildNameValuePairs(TestInfo.InputValues);
                        req = new GenericQueryRequest(MethodName, filterList);
                    }
                    else
                    {
                        req = new GenericQueryRequest(CustomQuery);
                    }

                    Global.RO.Info("Query String: " + req.GetRelativeUrl() + req.ToQueryString());
                    CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, (GenericQueryRequest)req);

                    Global.RO.Success("Response is: \n" + resp.Response);
                    Global.RO.Info("");

                    doc = new XmlDocument();
                    doc.LoadXml(resp.Response);

                }
            }
            finally
            {
                EditorialClientIPClear();
                UpdateMediaReduceTitle("fecatalogdbxbox", true);
            }

            if (!doc.InnerText.Contains(newTitle)) throw new UnexpectedTestResultException("Verification failed.");
            else Global.RO.Success("Verification Success!");

        }
    }


    public class SerializeIndentityCallTestBase : ConfigChangeTestBase {

        bool failedFirstQuery;
        
        static WebRequestBase webReq;

        public SerializeIndentityCallTestBase()
        {
        }

        public SerializeIndentityCallTestBase(TestCaseInfo testInfo, bool failed):base(testInfo)  {
            failedFirstQuery = failed;

            //Run a couple xmgmt commands just for code coverage.
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog help");
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog flush findgames");

            Uri xblobUri = new Uri("http://" + Global.XEnv.GetVirtualInterface("catalog").ToString());
            string machineName = xblobUri.Host;
            //Catalog health check is of the form: http://wirosasxblob:11220/catalog/health.ashx
            WebRequest request = WebRequest.Create(string.Format("http://{0}:11220/catalog/health.ashx", machineName));
            HttpWebResponse response = (HttpWebResponse)request.GetResponse();

            Global.RO.Info(string.Format("Health Check response: {0}", response.StatusDescription));
            
        }

        public long ReadCounter(string instanceName)
        {
            string categoryName = "";
            string counterName = "";
            string machineName = "";
            //string categoryHelp = "";
            //string counterHelp = "";
            PerformanceCounterCategory pcc;

            // Copy the supplied arguments into the local variables.
            try
            {
                categoryName = "XBL Fse:Execute";
                counterName = "Execute total";
                //instanceName = "catalog_findvideos_cachehit";//"catalog_findvideos_cachemiss"
                Uri xblobUri = new Uri("http://" + Global.XEnv.GetVirtualInterface("fecatalogdbxbox").ToString());
                machineName = xblobUri.Host;
                //categoryHelp = "";
                //counterHelp = "";

                pcc = new PerformanceCounterCategory(categoryName, machineName);

                PerformanceCounter[] lst = pcc.GetCounters(instanceName);
                foreach (PerformanceCounter c in lst)
                {
                    if (c.CounterName == counterName)
                        return c.RawValue;
                }
            }
            catch 
            {
                throw new UnexpectedTestResultException("can not read counter");
            }
            return -1;
        }
      
        void QueryThread(object fail){
            ZuneClient client = new ZuneClient();

            if ((bool)fail)
            { 
                //make the call failed at database query
                VIPUpdate("1.2.3.4", 1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog configcacherefresh");

            }
            try
            {
                Global.RO.Info("Query at " + DateTime.Now.ToLongTimeString() + "\r\nQuery String: " + webReq.GetRelativeUrl() + webReq.ToQueryString());
                CatalogResponse resp = live.server.next.Catalog.SendRequest(client, (GenericQueryRequest)webReq);

                Global.RO.Success("Response is: \n" + resp.Response);
                Global.RO.Info("");

                if ((bool)fail) {
                    Global.RO.Error("Should failed but success!");
                    VIPUpdate(VIP, 1);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog configcacherefresh");
                }
            }
            catch {
                if ((bool)fail)
                {
                    Global.RO.Success("Expected failure happened at " + DateTime.Now.ToLongTimeString());
                    //VIPUpdate(VIP, 1);
                    //Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog configcacherefresh");
                }
                else
                    Global.RO.Error("Should success but failed!");
            }



       }

         protected override void InnerExecute()
        {
            bool testSuccess = true;
            long total, cachehit, cachemiss, newtotal, newcachehit, newcachemiss; 

            //if (webReq == null)
            {
                if (string.IsNullOrEmpty(CustomQuery))
                {
                    ArrayList lst = new ArrayList();
                    Guid id = Guid.NewGuid();
                    lst.Add(id.ToString());
                    TestInfo.InputValues["MediaIds"] = lst;

                    List<StringPair> filterList = QueryFilter.BuildNameValuePairs(TestInfo.InputValues);
                    webReq = new GenericQueryRequest(MethodName, filterList);
                }
                else
                {
                    webReq = new GenericQueryRequest(CustomQuery);
                }
            }

            if (failedFirstQuery)
            {
                Global.RO.Info("Expect failed on 1st query");
            }
            else
            {
                Global.RO.Info("Expect success on 1st query");
            }
             total = ReadCounter("catalog_findgames");
             cachehit = ReadCounter("catalog_findgames_cachehit");
             cachemiss = ReadCounter("catalog_findgames_cachemiss");


            //make 1st query
            Thread firstThread = ThreadMaker.CreateThread(QueryThread, failedFirstQuery);
            //make 2nd query
            Thread secondThread = ThreadMaker.CreateThread(QueryThread, false);
            //make 3rd query
            //Thread thirdThread = ThreadMaker.CreateThread(QueryThread, false);

            firstThread.Start();
            if (failedFirstQuery)
            {
                Thread.Sleep(2000);
                VIPUpdate(VIP, 1);
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog configcacherefresh");
                Thread.Sleep(1000);
            }
           
            secondThread.Start();
            //thirdThread.Start();

            firstThread.Join();
            secondThread.Join();
            //thirdThread.Join();




            newtotal = ReadCounter("catalog_findgames");
            newcachehit = ReadCounter("catalog_findgames_cachehit");
            newcachemiss = ReadCounter("catalog_findgames_cachemiss");

            Global.RO.Info("   total=" +    total + "    cachehit=" +    cachehit + "    cachemiss= " +    cachemiss);               
            Global.RO.Info("newtotal="+newtotal+" newcachehit="+newcachehit+" newcachemiss= "+newcachemiss);   
             if(total+2 != newtotal) {
                 testSuccess = false;
            }

            if (!failedFirstQuery && !(cachehit == newcachehit -1 
                && cachemiss == newcachemiss-1)) {
                    testSuccess = false;
            }

            if (failedFirstQuery && !(cachehit == newcachehit 
                && cachemiss == newcachemiss - 1))
            {
                    testSuccess = false;
            }

            if (!testSuccess)
            {
                ResultCode = TEST_RESULTS.FAILED;
                throw new UnexpectedTestResultException("");
            }
            else {
                Global.RO.Success("Verification Success!");            
            }
        }
    }


    public enum FETCH_ORDER { Ascending, Decending, Random};

    public class ConfigChangeTestBase : EditorialTestBase
    {
        public string VIP = null;
        bool querybeforeChange;

        public ConfigChangeTestBase()
        {
        }

        public ConfigChangeTestBase(TestCaseInfo testInfo, bool doQuery )
            : base(testInfo)
        {
            VIP = Global.XEnv.GetVirtualInterface("fecatalogdbxbox").Address.ToString();
            querybeforeChange = doQuery;
        }


        public ConfigChangeTestBase(TestCaseInfo testInfo)
            : base(testInfo)
        {
            VIP = Global.XEnv.GetVirtualInterface("fecatalogdbxbox").Address.ToString();
        }

        public static void VIPUpdate(string ipstr, int seconds)
        {
            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(xonline.common.config.Config.GetSingleInterface(Interface.npdb).SqlConnectionString);   

                connection.Open();


                SqlCommand sqlCmd = connection.CreateCommand();

                sqlCmd.CommandText =     
                             
"update dbo.t_site_virtual_interface_ips set vc_ip = '"+ipstr+@"' from  dbo.t_site_virtual_interface_ips t join t_environments e on
t.vc_environment = e.vc_environment where e.b_current = 1 and t.vc_virtual_interface = 'fecatalogdbxbox'";
 

                int rowsAffected = sqlCmd.ExecuteNonQuery();
                if (rowsAffected <1)
                {
                    throw new Exception("Update VIP: rowsAffected != 1; rowsAffected == " + rowsAffected);
                }

                Global.RO.Info("change fecatalogdbxbox VIP to  " + ipstr+ " at "+ DateTime.Now.ToLongTimeString());
                Global.RO.Info("Sleep "+ seconds + " seconds, wait for fd to pick up the changes ");

                Thread.Sleep(seconds*1000);
            }
            catch
            {
                if (connection != null) connection.Close();
                throw new Exception("can not connect to npdb");
                
            }                        
            
        }


        protected override void Init()
        {
            base.Init();
            QueryFilter = new FindGamesFilter();
            MethodName = QueryRequestBase.QueryMethod.FindGames;
        }


        protected override void InnerExecute()
        {
            bool success = true ;            

            try
            {
                //EditorialClientIPUpdate();
                
                for (int i = 0; i < 3; i++)
                {
                    try
                    {
                        //Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog flush");

                        if (i == 0) { 
                            Global.RO.Info("Orignal VIP is: "+ VIP);
                            if (!querybeforeChange) continue;
                            Global.RO.Info("Do query before make VIP change.");
                        }

                        if (i == 1)
                        {
                            VIPUpdate("1.2.3.4",180);
                        }
                        if (i == 2)
                        {
                            Global.RO.Info("Restore VIP to its original value");
                            VIPUpdate(VIP, 180);
                        }

                        if (string.IsNullOrEmpty(CustomQuery))
                        {
                            ArrayList lst = new ArrayList();
                            Guid id = Guid.NewGuid();
                            lst.Add(id.ToString());
                            TestInfo.InputValues["MediaIds"] = lst;

                            List<StringPair> filterList = QueryFilter.BuildNameValuePairs(TestInfo.InputValues);
                            req = new GenericQueryRequest(MethodName, filterList);
                        }
                        else
                        {
                            req = new GenericQueryRequest(CustomQuery);
                        }

                        Global.RO.Info("Query at "+ DateTime.Now.ToLongTimeString()+"\r\nQuery String: " + req.GetRelativeUrl() + req.ToQueryString());
                        CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, (GenericQueryRequest)req);

                        Global.RO.Success("Response is: \n" + resp.Response);
                        Global.RO.Info("");

 
                        if (i == 1)
                        {
                            success = false;
                            Global.RO.Error("Expected query failed, but success");
                            throw new UnexpectedTestResultException();
                        }
                    }
                    catch
                    {
                        if (i == 1 && success) Global.RO.Success("1st Query failed, it is expected.");
                        else
                        {
                            success = false;
                            throw new UnexpectedTestResultException("query should success but failed");
                        }
                    }
                }
            }
            finally
            {
                //EditorialClientIPClear();
                if (success)
                    Global.RO.Success("Verification Success!");
                else
                {
                    //string curVIP = Global.XEnv.GetVirtualInterface("fecatalogdbxbox").Address.ToString();
                    //Global.RO.Warn("Current VIP is:" + curVIP);
                    Global.RO.Info("The test is done, restore VIP back.");
                    VIPUpdate(VIP,1);
                    
                    ResultCode = TEST_RESULTS.FAILED;
                    throw new UnexpectedTestResultException("");
                    
                }
            }                                   
        }
    }



    // for DownloadHistory and PurchaseHistory stress
    public class HistoryStressTestBase : CatalogStressTestBase
    {
        protected live.common.XblUser User = null;

        protected override void InnerExecute()
        {
            base.InnerExecute();

            // send the request
	    Global.RO.Info("Query String: " + req.GetRelativeUrl() + req.ToQueryString());
            
            BillingWebResponse resp = new BillingWebResponse();
            live.server.Billing.SendRequest(WebClient, User, live.common.XOService.WebBilling, req, resp);
            Global.RO.Success("Response is: \n" + resp.Response);
            Global.RO.Info("");
        }
    }

    public abstract class QueryStressMaxAgeTestBase : CatalogStressTestBase
    {
        protected override void InnerExecute()
        {
            base.InnerExecute();

            // custom query
            if (!string.IsNullOrEmpty(CustomQuery))
            {
                req = new GenericQueryRequest(CustomQuery);
            }

            // send the request
            Global.RO.Info("Query String: " + req.GetRelativeUrl() + req.ToQueryString());
            //CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, (GenericQueryRequest)req);
            HttpWebRequest request;
            HttpWebResponse response;
            string url = "http://10.193.109.94"+req.GetRelativeUrl() + req.ToQueryString();
            request = (HttpWebRequest)WebRequest.Create(url);

            try
            {
                response = (HttpWebResponse)request.GetResponse();
               
                string cacheControl = response.Headers["Cache-Control"];

                
                if (cacheControl.StartsWith("private")) Global.RO.Error(url + ", " + cacheControl);
                char[] s = { '=' };
                string []splits = cacheControl.Split(s);

                int expire = int.Parse(splits[1]);

                if (expire <= 0 || expire > 3600) Global.RO.Error(url + ", " + cacheControl);

                Global.RO.Success("expire= " + expire + ", " + cacheControl);

            }
            catch (WebException we)
            {
                Console.Out.WriteLine(we.Message + ", " + url);
            }

            /*Global.RO.Success("Response is: \n" + PrintNumItems(resp.Response));*/
        }
    }

    // for all Catalog query APIs stress, such as FindXyz and FindXyzOffers
    public abstract class QueryStressTestBase : CatalogStressTestBase
    {
        protected override void InnerExecute()
        {
            base.InnerExecute();

            // custom query
            if (!string.IsNullOrEmpty(CustomQuery))
            {
                req = new GenericQueryRequest(CustomQuery);
            }

            // send the request
            Global.RO.Info("Query String: " + req.GetRelativeUrl() + req.ToQueryString());
            CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, (GenericQueryRequest)req);

            Global.RO.Success("Response is: \n" + PrintNumItems(resp.Response));
        }
    }


    public abstract class SubmissionStressTestBase : CatalogStressTestBase
    {
        protected override void InnerExecute()
        {
            base.InnerExecute();

            if (!string.IsNullOrEmpty(CustomQuery))
            {
                req = new GenericQueryRequest(CustomQuery);
            }

            // send the request
            Global.RO.Info("Query String: " + req.GetRelativeUrl() + req.ToQueryString());
            CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, (GenericQueryRequest)req);

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(resp.Response);

            Global.RO.Success("Response is: " + doc.LastChild.FirstChild.InnerText);
        }
    }

    public abstract class CatalogStressTestBase : TestNode
    {
        protected uint Expected_XErr = 0;   // if > 0, negative test cases and need to verify the exception thrown is correct
        protected string CustomQuery = null;
        protected string MethodName = QueryRequestBase.QueryMethod.FindMedia;  // default is FindMedia

        [ThreadStatic]
        private static ZuneClient _webClient;
        [ThreadStatic]
        private static Xbox360Client _xenonClient;

        protected WebRequestBase req = null;
        //protected FilterBase QueryFilter = null;

        protected ZuneClient WebClient
        {
            get
            {
                if (_webClient == null)
                    _webClient = new ZuneClient();
                return _webClient;
            }
        }

        protected Xbox360Client XenonClient
        {
            get
            {
                if (_xenonClient == null)
                    _xenonClient = new Xbox360Client();
                return _xenonClient;
            }
        }

        public CatalogStressTestBase()
        {
            Setup();
        }

        protected string PrintNumItems(string response)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(response);
            XmlNode total = doc.LastChild.FirstChild;
            string totalItems = total.InnerText;
            string numItems = total.NextSibling.InnerText;
            return ("live:totalItems - " + totalItems + "\nlive:numItems - " + numItems);
        }

        protected virtual void Setup()
        {
        }

        protected virtual void Init()
        {
        }

        protected virtual void InnerExecute()
        {
        }

        public override void Run()
        {
            string error = null;

            Init();
            try
            {
                InnerExecute();
            }
            catch (XrlRequestException xrlEx)
            {
                error = xrlEx.RespData;
                //Global.RO.Warn("URL: " + xrlEx.Url);
                Global.RO.Warn("Error message: " + error + ", XrlException: " + xrlEx.ToString());
            }

            // should succeed
            if (Expected_XErr == 0)
            {
                if (!string.IsNullOrEmpty(error))
                {
                    throw new UnexpectedTestResultException("Should succeed, but get error: " + error);
                }

                // no verify
            }
            // should fail
            else
            {
                if (string.IsNullOrEmpty(error) || !error.Contains(Expected_XErr.ToString("X")))
                {
                    throw new UnexpectedTestResultException("Expecting error: " + Expected_XErr.ToString("X") + ", but get: " + error);
                }
            }
        }
    }

    public abstract class CatalogTestBaseGroup : TestNode
    {
        protected static string TestCaseFilePath;
        protected static string InjectionFilePath;

        static CatalogTestBaseGroup()
        {
            string xmlFile = @"suites/CatalogQueryTests.xml";
            XmlDocument xmlDoc = new XmlDocument();
            if (!File.Exists(xmlFile))
            {
                throw new Exception("File Not Found: " + xmlFile);
            }
            xmlDoc.Load(xmlFile);
            XmlNode nd = xmlDoc.DocumentElement;
            XmlNode pathNd = nd.SelectSingleNode("//InjectionFilePath");
            if (pathNd != null)
                InjectionFilePath = pathNd.InnerText;
            else
                Global.RO.Warn("Cannot InjectionFilePath in catalog query config data");

            pathNd = nd.SelectSingleNode("//TestCaseFilePath");
            if (pathNd != null)
                TestCaseFilePath = pathNd.InnerText;
            else
                Global.RO.Warn("Cannot TestCaseFilePath in catalog query config data");

            // set CatVerify xml file path
            CatVerify.InjectionFilePath = InjectionFilePath;
        }

        private static MediaOfferTableManager _dynManager = null;

        public static MediaOfferTableManager DynManager
        {
            get
            {
                if (_dynManager == null)
                {
                    _dynManager = new MediaOfferTableManager();
                    string msg;
                    _dynManager.LoadFiles(InjectionFilePath, out msg);
                    if(!string.IsNullOrEmpty(msg))
                        Global.RO.Warn(msg);
                }
                return _dynManager;
            }
        }
    }

    public abstract class QueryTestBase : TestBase
    {
        protected TestCaseInfo TestInfo = null;
        protected uint Expected_XErr = 0;   // if > 0, negative test cases and need to verify the exception thrown is correct
        protected string CustomQuery = null;
        protected string MethodName = QueryRequestBase.QueryMethod.FindMedia;  // default is FindMedia

        protected ZuneClient WebClient = new ZuneClient();
        protected WebRequestBase req = null;
        protected FilterBase QueryFilter = null;
        protected XmlDocument doc = null;
        protected bool bypassXbanc = false;

        public QueryTestBase()
        {
        }

        public QueryTestBase(TestCaseInfo testInfo)
        {
            this.Name = testInfo.Name;
            this.TestInfo = testInfo;
            this.Expected_XErr = this.TestInfo.ErrorCode;
            if (TestInfo.InputValues["CustomQuery"] != null)
            {
                this.CustomQuery = ((ArrayList)TestInfo.InputValues["CustomQuery"])[0].ToString();
            }
            TestInfo.InputValues.Remove("CustomQuery");

            if (TestInfo.InputValues["BypassXbanc"] != null)
            {
                this.bypassXbanc = (((ArrayList)TestInfo.InputValues["BypassXbanc"])[0].ToString() == "1");
                Global.RO.Warn("Test: " + TestInfo.Name + " and bypassXbanc: " + this.bypassXbanc + " and BypassXbanc: " + ((ArrayList)TestInfo.InputValues["BypassXbanc"])[0].ToString());
            }
            TestInfo.InputValues.Remove("BypassXbanc");
        }

        protected virtual void Init()
        {
        }

        protected virtual void Verify()
        {
        }

        protected override void Execute()
        {
            string error = null;
            uint xErr = live.common.HResult.S_OK;

            Init();
            try
            {
                InnerExecute();
            }
            catch (XrlRequestException xrlEx)
            {
                error = xrlEx.RespData;
                xErr = xrlEx.XErr;
                //Global.RO.Warn("URL: " + xrlEx.Url);
                Global.RO.Warn("Error message: " + error + "\n XErr: 0x" + xErr.ToString("X") + "\n XrlRequestException: " + xrlEx.ToString());
            }

            // should succeed
            if (Expected_XErr == 0)
            {
                if (!string.IsNullOrEmpty(error))
                {
                    throw new UnexpectedTestResultException("Should succeed, but get error: " + error);
                }

                // only verify when success
                if (!TestInfo.SkipVerify)
                    Verify();
            }
            // should fail
            else
            {
                // after bug 115210 is fixed, DownloadHistory should be OK with the xErr check
                if (string.IsNullOrEmpty(error) || Expected_XErr != xErr || !error.Contains("<HResult>0x" + Expected_XErr.ToString("X") + "</HResult>"))
                {
                    throw new UnexpectedTestResultException("Expecting error: 0x" + Expected_XErr.ToString("X") + ", but get error: " + error + " and XErr = 0x" + xErr.ToString("X"));
                }
            }

            ResultCode = TEST_RESULTS.PASSED;
        }

        protected virtual void InnerExecute()
        {
            if (string.IsNullOrEmpty(CustomQuery))
            {
                List<StringPair> filterList = QueryFilter.BuildNameValuePairs(TestInfo.InputValues);
                req = new GenericQueryRequest(MethodName, filterList);
            }
            else
            {
                req = new GenericQueryRequest(CustomQuery);
            }
            
            Global.RO.Info("Query String: " + req.GetRelativeUrl() + req.ToQueryString());

            if (MethodName.Contains("Podcast")) WebRequestBase.RequestType = WebRequestBase.WebRequestType.Get;
            else WebRequestBase.RequestType = WebRequestBase.WebRequestType.Post;

            // bypass Xbanc if needed
            if (bypassXbanc)
                req.BehaviorInjection.AddXbancMiss(true);

            CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, (GenericQueryRequest)req);

            Global.RO.Success("Response is: \n" + resp.Response);
            Global.RO.Info("");

            doc = new XmlDocument();
            doc.LoadXml(resp.Response);
        }


        public void PrintInfo(string info)
        {
            char[] delimiterChars = { '\r', '\n' };

            string[] words = info.Split(delimiterChars);

            foreach (string s in words)
            {
                if (s != null)
                {
                    if (s.StartsWith("[INF]")) Global.RO.Info(s);
                    if (s.StartsWith("[WRN]")) Global.RO.Warn(s);
                    if (s.StartsWith("[ERR]")) Global.RO.Error(s);
                }
            }
        }

        /*QueryTestBase.ComplexObjectFromDB<CatVerify.Image>.GetObjects();*/

        public class GetComplexObject
        {
            public static ArrayList PreviewImages(Guid mId, int lcid)
            {
                string sqlString = @"select  mi.mediaInstanceId, mi.isAcquirable,  ii.imageFormatId, ii.imageSizeId, ii.fileUrl, ii.fileSize FROM MediaInstance mi INNER JOIN PreviewMediaInstance pmi ON pmi.previewMediaInstanceId = mi.mediaInstanceId 
                        INNER JOIN ImageInstance ii ON ii.imageMediaInstanceId = mi.mediaInstanceId 
                        INNER JOIN locale l on l.countryCode = pmi.countryCode
                        WHERE mi.IsPreview != 0 AND l.lcid = " + lcid + " and  mi.mediaId = '" + mId + "'";
                return ComplexObjectFromDB<CatVerify.Image>.GetObject(sqlString, mId, lcid);
            }
        }


        public class ComplexObjectFromDB<T> where T : CatVerify.Image, new()
        {

            public static ArrayList GetObject(string sql, Guid mediaId, int lcid)
            {
                try
                {
                    ArrayList lst = new ArrayList();
                    using (SqlClient client = new SqlClient(CatalogQueryTestSuite.FeCatalogDBXbox, true))
                    {
                        using (SqlDataReader reader = client.Execute(sql))
                        {
                            // should always return exact one row
                            T o;
                            while (reader.Read())
                            {
                                o = new T();
                                o.ReadfromDb(reader);
                                lst.Add(o);
                            }
                            reader.Close();
                            return lst;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Failed to load media and mediainstance from DB. Sql = " + sql + "\nError message: " + e.Message);
                    throw;
                }
            }
        }



    }

    /// <summary>
    /// Base class used by all of the Catalog Cache Integration Tests
    /// </summary>
    public abstract class CacheTestBase : TestBase
    {      

        // WebClient used to access LiveLib
        protected live.client.WebClient  _webClient;
        // RequestFilter created for the current test case
        protected QueryRequestBase _request;
        // Direct access to XBanc
        protected xonline.common.service.XBanc _xb;
        protected Timer _expiryTimer;

        protected Boolean _expired = false;
        protected static readonly uint CACHE_DUR = 2; //sec
        protected static readonly uint MILLISECONDS = 1000; // msec in 1 sec
        protected static readonly String CACHE_ATTRIB_NAME = "CacheTest";

        protected TestCaseInfo _testInfo;

        // Used when loading the test data, this is a set of all the possible parameters
        private static String[] inputParameterNames =
        {   
            "Bookmark",         "CategoryIds",  "CategorySystemId", "CollectionId",
            "ConcernId",        "ConcernText",  "ContributorLimit", "DetailView",
            "ExternalId",       "ImageFormats", "ImageSizes",       "ImageTypeIds",
            "LegalLocale",      "Locale",       "MediaId",          "MediaIds",
            "MediaRelationshipTypes",           "MediaTypes",       "MediaUrls",
            "OfferFilterLevel", "OfferIds",     "OrderBy",          "OrderDirection",               
            "PageNum",          "PageSize",     "PodcastType",      "PodcastUrl",
            "RatingIds",        "Relations",    "Store",            "TitleFilters",
            "UserTypes",        "VideoFilter",  "VisibilityLevel",  "MethodName",  
            "OfferTargetMediaTypes"
        };
        public static String[] InputParameterNames
        {
            get { return inputParameterNames; }
        }

        private String _testName;
        protected String TestName
        {
            get
            {
                if (_testName == null)
                {
                    _testName = this.GetType().Name;
                }
                return _testName;
            }
        }

        private String _methodName;
        protected String MethodName
        {
            get
            {
                if (_methodName == null)
                {
                    ArrayList param = _testInfo.InputValues["MethodName"] as ArrayList;
                    _methodName = param[0].ToString();
                }
                return _methodName;
            }
        }



        public int PageSize {
            get{

                ArrayList paramValues = (ArrayList)_testInfo.InputValues["PageSize"];
                return Convert.ToInt32(paramValues[0]);
            }

            set{

                ArrayList paramValues = new ArrayList();
                paramValues.Add(value.ToString());
                _testInfo.InputValues["PageSize"] = paramValues;
            }

        }

        public int PageNum
        {
            get
            {

                ArrayList paramValues = (ArrayList)_testInfo.InputValues["PageNum"];
                return Convert.ToInt32(paramValues[0]);
            }

            set{

                ArrayList paramValues = new ArrayList();
                paramValues.Add(value.ToString());
                _testInfo.InputValues["PageNum"] = paramValues;
            }
        }

        int _cachePageSize = -1;
        public int CahePageSize {
            get {
                if(_cachePageSize <0) 
                    using (SqlClient client = new SqlClient("npdb"))
                    {
                     
                            client.Command.CommandText =
                            String.Format("select i_cache_page_size  from t_fse_methods where vc_method_name='{0}'", this.MethodName);

                            SqlDataReader reader = client.Command.ExecuteReader();
                            while (reader.Read())
                            {
                                _cachePageSize = reader.GetInt32(0);

                            }
                            reader.Close();
                            Global.RO.Info("Original pageing value: i_cache_page_size: {0} ", _cachePageSize);
                            
                    }
                    return _cachePageSize;    
            }    
        }

        private byte[][] _keys;
        protected byte[][] Keys
        {
            get
            {
                if (_keys == null)
                {


                    int userPageSize = PageSize;
                    int userPageNum = PageNum;
                    int _cachePageBase = 1;

                    int firstItem = userPageSize * (userPageNum - _cachePageBase);
                    int lastItem = firstItem + userPageSize - 1;

                    int firstPage = firstItem / CahePageSize;
                    int lastPage = lastItem / CahePageSize;
                    int numPages = lastPage - firstPage + 1;  

                    _keys = new byte[numPages][];

                    PageSize = _cachePageSize;

                    for (int i = 0; i < _keys.Length; i++)
                    {
                        PageNum = firstPage + i;
                        _keys[i] = GetKey();
                    }

                    PageSize = userPageSize;
                    PageNum = userPageNum;
                    return _keys;
                }
                return _keys;
            }
            
        }


         private byte[] GetKey()
        {
                byte[] _key;

                MemoryStream memoryStream = new MemoryStream();
                ASCIIEncoding encoding = new ASCIIEncoding();

                BinaryWriter binaryWriter = new BinaryWriter(memoryStream, encoding);

                // create key starting with api name (which  is  used
                // as a prefix for all FSE  cache  entries  in  XBanc)

                byte[] _prefix = ASCIIEncoding.ASCII.GetBytes("Catalog");
                binaryWriter.Write(_prefix);

                // if they supplied a method name,  then add that too

                if (!string.IsNullOrEmpty(this.MethodName))
                {
                    binaryWriter.Write(ASCIIEncoding.ASCII.GetBytes(":" + MethodName));
                }

                // if they provided parameter values, then  construct
                // a key using those values as a seed to a SHA1  hash

                //if (paramVals != null)
                // {
                bool exactMatch = true;
                string separator = "?";
                SHA1 sha1 = new SHA1Managed();
                StringBuilder stringBuilder = new StringBuilder();


                //for (int i = 0; i < paramVals.Length; i++)
                Dictionary<String, FseParam> parameters = Method.GetMethod(this.MethodName).Parameters;

                foreach (String paramName in parameters.Keys)
                {
                    ArrayList paramValues = null;
                    FseParam param = parameters[paramName];

                    // Check to see if we defined the default value
                    if (_testInfo.InputValues.ContainsKey(paramName) && _testInfo.InputValues[paramName] != null)
                    {
                        // If so use it
                        paramValues = (ArrayList)_testInfo.InputValues[paramName];
                    }
                    else
                    {
                        // If not, grab the default value from the method defenition
                        paramValues = new ArrayList();
                        if(paramName.Equals("VisibilityLevel"))
                            paramValues.Add("2");
                        else
                            paramValues.Add(param.Default);
                    }


                    // skip parameters not configured as key values

                    if (param.IsKeyed)
                    {
                        // adjacent hashed  keys  are  concatenated.
                        // write it out when we see a nonhashed key

                        if (param.IsHashed)
                        {
                            // if they don't want  an  exact  match
                            // then break on the first  hashed  key

                            if (!exactMatch)
                            {
                                break;
                            }

                            if (stringBuilder.Length == 0)
                                binaryWriter.Write(ASCIIEncoding.ASCII.GetBytes(separator));
                            else
                            {
                                stringBuilder.Append("&");
                            }

                            stringBuilder.AppendFormat("{0}=", param.Name);

                            for (int j = 0; j < paramValues.Count; j++)
                            {
                                if (j > 0) stringBuilder.Append(",");
                                stringBuilder.Append((string)paramValues[j]);
                            }
                        }

                        // key is not hashed. flush any hashed keys
                        // and then write this key out  right  away

                        else
                        {
                            if (stringBuilder.Length > 0)
                            {
                                binaryWriter.Write(sha1.ComputeHash(
                                    UnicodeEncoding.Unicode.GetBytes(stringBuilder.ToString())
                                ));

                                stringBuilder.Length = 0;
                            }
                           

                            binaryWriter.Write(ASCIIEncoding.ASCII.GetBytes(                                
                                string.Format("{0}{1}=", separator, param.Name)
                            ));

                            // we must use unicode if the value is a string,  but dates and
                            // scalars are compact as ASCII without any loss of information

                            if (param.Type == typeof(String))
                                binaryWriter.Write(UnicodeEncoding.Unicode.GetBytes((((string)paramValues[0]).ToCharArray(0, ((string)paramValues[0]).Length))));
                            else {
                                binaryWriter.Write(ASCIIEncoding.ASCII.GetBytes((((string)paramValues[0]).ToCharArray(0, ((string)paramValues[0]).Length))));
                            }

                        }

                        separator = "&";
                    }
                }

                if (stringBuilder.Length > 0)
                {
                    binaryWriter.Write(sha1.ComputeHash(
                        UnicodeEncoding.Unicode.GetBytes(stringBuilder.ToString())
                    ));
                }

                _key = memoryStream.ToArray();

                string s = "";
                string bins = "";
                for (int i = 0; i < _key.Length; i++) { 
                    if(_key[i] >=32 && _key[i]<126)
                        s += (char)_key[i];
                    else s += "~" + _key[i].ToString("x") ;
                    
                    
                }
                Global.RO.Info("_key in string format is: {0} ", s);
                Global.RO.Info("_key in number format is: {0} ", bins);

                return _key;

        }


        public CacheTestBase(TestCaseInfo testCase)
        {
            this.Name = TestName + "_" + testCase.Name;
            this._testInfo = testCase;

            // Create the clients to access the catalog server and the XBanc
            live.common.Config.SetConfig(new STFConfig());
            _webClient = new live.client.WebClient();
            _xb = new xonline.common.service.XBanc();

            // Create the timer that is used to track expiry times
            // Defaults to 5 seconds and can be changed if required
            _expiryTimer = new Timer(CACHE_DUR * MILLISECONDS);
            _expiryTimer.AutoReset = false;
            _expiryTimer.Elapsed += new ElapsedEventHandler(expiryTimer_Elapsed);
        }

        void expiryTimer_Elapsed(object sender, ElapsedEventArgs e)
        {
            _expired = true;
        }

        protected void WaitForExpire()
        {
            _expired = false;

            _expiryTimer.Start();

            while (!_expired)
            {
                Thread.Sleep(250);
            }

            _expiryTimer.Stop();
        }

        protected override void Execute()
        {
            this.ResultCode = TEST_RESULTS.PASSED;
            _request = CreateRequestFilter(_testInfo);

            try
            {
                InnerExecute();                
            }
            catch
            {
                this.ResultCode = TEST_RESULTS.FAILED;
                throw;
            }
        }

        protected abstract void InnerExecute();

        protected void ResetKey()
        {
            this._keys = null;
        }

        /// <summary>
        /// Convert a byte[] into it's XmlDocument representiation
        /// </summary>
        /// <param name="value">The XML Content</param>
        /// <returns>An XmlDocument that represents the byte[]</returns>
        protected XmlDocument GetXML(byte[] value)
        {
            UnicodeEncoding encoding = new UnicodeEncoding();
            StringReader stringReader = new StringReader(encoding.GetString(value));
            XmlTextReader textReader = new XmlTextReader(stringReader);

            XmlDocument document = new XmlDocument();
            document.Load(textReader);

            return document;
        }

        /// <summary>
        /// A convenience method for retrieving the byte[] of an XmlNode
        /// </summary>
        /// <param name="node">The node to convert to bytes</param>
        /// <returns>A byte[] representation or the XML</returns>
        protected static byte[] GetBytes(XmlNode node)
        {
            UnicodeEncoding encoding = new UnicodeEncoding();
            return encoding.GetBytes(node.OuterXml);
        }

        /// <summary>
        /// Adds a cache attribute to the data in the cache so when we query it we
        /// will know where it came from
        /// </summary>
        protected void AddCacheAttribute()
        {
            AddCacheAttribute(CACHE_DUR);
        }

        /// <summary>
        /// Adds a cache attribute to the data in the cache so when we query it we
        /// will know where it came from
        /// </summary>
        /// <param name="cacheDuration">
        /// Since we are directly setting the cache, we need to provide a new value 
        /// for the cache duration
        /// </param>
        protected void AddCacheAttribute(uint cacheDuration)
        {
            Byte[] cachedData;

            if (_xb.Query(this.Keys[0], out cachedData) == 0)
            {
                for (int i = 0; i < cachedData.Length-3; i++) {
                    cachedData[i] = cachedData[i + 3];
                }


                // create key starting with api name (which  is  used
                // as a prefix for all FSE  cache  entries  in  XBanc)

                byte[] _prefix = ASCIIEncoding.ASCII.GetBytes("Catalog");
   

                XmlDocument doc = GetXML(cachedData);
                XmlAttribute cacheAttribute = doc.CreateAttribute(CACHE_ATTRIB_NAME);
                cacheAttribute.Value = "True";

                doc.DocumentElement.Attributes.Append(cacheAttribute);

                _xb.SetData(this.Keys[0], GetBytes(doc), cacheDuration, 0);

                // Set the interval on the expiry timer
                _expiryTimer.Interval = cacheDuration * MILLISECONDS;
            }
            else
            {
                throw new Exception("Unable to find test data in cache");
            }
        }

        protected bool CheckCacheAttribute(XmlDocument doc)
        {
            return doc.DocumentElement.Attributes[CACHE_ATTRIB_NAME] != null;
        }

        /// <summary>
        /// Creates an appropriate Requst filter to be used with the Catalog Query API
        /// populated with the appropriate test data from the give test case
        /// </summary>
        /// <param name="testCase">The test case to generate a request filter for</param>
        /// <returns>A Requst of the appropriate type for the given query</returns>
        protected QueryRequestBase CreateRequestFilter(TestCaseInfo testCase)
        {
            FilterBase filter = null;
            QueryRequestBase request = null;
            String methodName = this.MethodName.ToLowerInvariant();

            switch (methodName)
            {
                case "findmedia":
                    filter = new FindMediaFilter();
                    break;
                case "findmediaoffers":
                    filter = new FindMediaOffersFilter();
                    break;
                case "findgames":
                    filter = new FindGamesFilter();
                    break;
                case "findgameoffers":
                    filter = new FindGameOffersFilter();
                    break;
                case "findvideos":
                    filter = new FindVideosFilter();
                    break;
                case "findvideooffers":
                    filter = new FindVideoOffersFilter();
                    break;
                default:
                    return null;
            }

            filter.BuildFilter(testCase.InputValues);

            switch (methodName)
            {
                case "findmedia":
                    request = new FindMediaRequest((FindMediaFilter)filter);
                    break;
                case "findmediaoffers":
                    request = new FindMediaOffersRequest((FindMediaOffersFilter)filter);
                    break;
                case "findgames":
                    request = new FindGamesRequest((FindGamesFilter)filter);
                    break;
                case "findgameoffers":
                    request = new FindGameOffersRequest((FindGameOffersFilter)filter);
                    break;
                case "findvideos":
                    request = new FindVideosRequest((FindVideosFilter)filter);
                    break;
                case "findvideooffers":
                    request = new FindVideoOffersRequest((FindVideoOffersFilter)filter);
                    break;
                default:
                    return null;
            }

            return request;
        }

        /// <summary>
        /// Performs a database query with the current request filter
        /// </summary>
        /// <returns>The Xml document response from the server</returns>
        protected XmlDocument Query()
        {
            return Query(_request);
        }


        protected  XmlDocument Query(string CustomQuery)
        {
            XmlDocument doc = new XmlDocument();
            CatalogResponse response=null;

            try
            {

                WebRequestBase request = new GenericQueryRequest(CustomQuery);

                // send the request
                Global.RO.Info("Query String: " + request.GetRelativeUrl() + request.ToQueryString());
                response = live.server.next.Catalog.SendRequest(_webClient, (GenericQueryRequest)request);

                doc = new XmlDocument();
                doc.LoadXml(response.Response);
            }
            catch (XmlException e)
            {
                // Usually if we can't load the response it's because there was another error
                // in the catalog (missing parameter, etc.)  Rethrow it with the message.
                throw new ArgumentException(response.Response, e);
            }
            return doc;
        }


        protected XmlDocument Query(QueryRequestBase request)
        {
            CatalogResponse response = live.server.next.Catalog.SendRequest(_webClient, request);
            XmlDocument doc = new XmlDocument();

            try
            {
                doc.LoadXml(response.Response);
            }
            catch (XmlException e)
            {
                // Usually if we can't load the response it's because there was another error
                // in the catalog (missing parameter, etc.)  Rethrow it with the message.
                throw new ArgumentException(response.Response, e);
            }

            return doc;
        }

        /*
        public static void RecycleAppPool(string machine, string appPoolName)
        {
            string path = "IIS://" + machine + "/W3SVC/AppPools/" + appPoolName;

            DirectoryEntry w3svc = new DirectoryEntry(path);
            w3svc.Invoke("Recycle", null);
        }
        */
        protected void ReloadCatalogConfig()
        {
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog reload");
        }
    }

    #region XBanc Cache Integreation Helper Classes
    /// <summary>
    /// A very simple encapsulation of an FSE Method.  Method parameters are automatically retrieved from 
    /// npdb when they are requested and cached for later use.  Methods are retrieved through the use of the 
    /// GetMethod() method.
    /// </summary>
    /// 

    [Flags]
    internal enum FseParamFlags : uint
    {
        Keyed = 0x00000001,  // used to generate cache key
        Hashed = 0x00000002,  // include in cache key but hash
        Internal = 0x00000004,  // cannot be supplied by user
        Array = 0x00000008,  // is an array param
        Webstore = 0x00000010,  // is a webstore hash param

        Deprecated = 0x80000000,
        All = Keyed | Hashed | Internal | Array | Webstore | Deprecated
    };


    public class FseParam
    {
        private string _name;
        private uint _flags;
        private string _default;
        private Type _type;

        internal FseParam(
            string name,
            string defaultValue,
            uint flags,
            Type type
        )
        {
            this._name = name;
            this._flags = flags;
            this._default = defaultValue;
            this._type = type;
        }

        internal string Name
        {
            get { return _name; }
        }

        internal string Default
        {
            get { return _default; }
        }
        internal bool IsHashed
        {
            get { return (_flags & (uint)FseParamFlags.Hashed) != 0; }
        }

        internal bool IsKeyed
        {
            get { return (_flags & (uint)FseParamFlags.Keyed) != 0; }
        }

        internal bool IsInternal
        {
            get { return (_flags & (uint)FseParamFlags.Internal) != 0; }
        }

        internal Type Type
        {
            get { return _type; }
        }

    }
    public class Method
    {
        private String _methodName;
        public String MethodName
        {
            get { return _methodName; }
        }


        private Dictionary<String, FseParam> _parameters;
        public Dictionary<String, FseParam> Parameters
        {
            get { return _parameters; }
        }

        /// <summary>
        /// Internal cache of all methods retrieved
        /// </summary>
        private static Dictionary<String, Method> methods = new Dictionary<string, Method>(StringComparer.InvariantCultureIgnoreCase);

        /// <summary>
        /// Retrieves the method information for a given method name.  If the method has not been used
        /// yet, the parameter info will automatically be retrieved from NPDB.
        /// </summary>
        /// <param name="methodName">The name of the method to retrieve</param>
        /// <returns>An instance of the Method class corresponding to the given method name</returns>
        public static Method GetMethod(String methodName)
        {
            if (!methods.ContainsKey(methodName))
            {
                methods.Add(methodName, new Method(methodName));
            }

            return methods[methodName];
        }

        private Method(String methodName)
        {
            _methodName = methodName;
            _parameters = new Dictionary<string, FseParam>();

            using (SqlClient cmd = new SqlClient("npdb"))
            {
                cmd.StoredProc = "p_fse_get_parameters";
                cmd.AddParameter("@vc_api_name", "catalog");
                cmd.AddParameter("@vc_method_name", methodName);

                using (SqlDataReader reader = cmd.Execute())
                {
                    while (reader.Read())
                    {
                        String name = reader.GetString(reader.GetOrdinal("vc_parameter_name"));
                        String defValue = reader.GetString(reader.GetOrdinal("vc_default_value"));
                        uint  flags = (uint) reader.GetInt32(reader.GetOrdinal("i_flags"));
                        string typeName = reader.GetString(reader.GetOrdinal("vc_parameter_type_name"));
                        _parameters.Add(name, new FseParam(name, defValue, flags, Type.GetType("System." + typeName)));
                    }
                }
            }
        }

        private Method(String methodName, Dictionary<string, FseParam> parameters)
        {
            _methodName = methodName;
            _parameters = parameters;
        }
    }

    /// <summary>
    /// Simulates the Catalog Bookmarking functionality
    /// </summary>
    public static class Bookmark
    {
        private static int _minutesThreshold;
        private static int _minutesFloor;

        private static int _hoursThreshold;
        private static int _hoursFloor;

        private static int _daysThreshold;
        private static int _daysFloor;

        /// <summary>
        /// Loads the bookmark threshold values from the database.
        /// </summary>
        static Bookmark()
        {
            Global.RO.Info("Loading Bookmarking Settings from NPDB");

            _minutesThreshold = GetSetting("MinutesThreshold");
            _minutesFloor = GetSetting("MinutesFloor");

            _hoursThreshold = GetSetting("HoursThreshold");
            _hoursFloor = GetSetting("HoursFloor");

            _daysThreshold = GetSetting("DaysThreshold");
            _daysFloor = GetSetting("DaysFloor");
        }

        private static int GetSetting(string setting)
        {
            return Int32.Parse(xonline.common.config.Config.GetSetting("fse_bookmark" + setting));
        }

        public static DateTime Adjust(DateTime bookmark)
        {
            bool daysAdjust = false;
            bool hoursAdjust = false;
            DateTime now = DateTime.UtcNow;
            DateTime input = bookmark;
            // We have to do this because having idendical times screws up the calculations 
            // because by the time it gets to the server 'now' is actually a few seconds later

            try
            {
                // we always get rid of the seconds and milliseconds
                bookmark = bookmark.AddSeconds(-bookmark.Second);
                bookmark = bookmark.AddMilliseconds(-bookmark.Millisecond);

                //
                if (Math.Abs((bookmark - now).TotalMinutes) >= _minutesThreshold)
                {
                    if (Math.Abs((bookmark - now).TotalHours) >= _hoursThreshold)
                    {
                        hoursAdjust = true;

                        if (Math.Abs((bookmark - now).TotalDays) >= _daysThreshold)
                        {
                            daysAdjust = true;
                        }
                    }

                    if (bookmark.Minute < _minutesFloor) bookmark = bookmark.AddHours(-1);
                    bookmark = bookmark.AddMinutes(_minutesFloor - bookmark.Minute);
                }

                if (hoursAdjust)
                {
                    if (bookmark.Hour < _hoursFloor) bookmark = bookmark.AddDays(-1);
                    bookmark = bookmark.AddHours(_hoursFloor - bookmark.Hour);
                }

                if (daysAdjust)
                {
                    if ((int)bookmark.DayOfWeek < _daysFloor) bookmark = bookmark.AddDays(-7);
                    bookmark = bookmark.AddDays(_daysFloor - (int)bookmark.DayOfWeek);
                }
            }
            catch (ArgumentOutOfRangeException aoore)
            {
                throw new Exception("Invalid value for parameter 'Bookmark'", aoore);
            }

            Global.RO.Info(String.Format("Bookmark Adjustment Input: {0} --- Now: {1} --- Output: {2}", input.ToString(), now.ToString(), bookmark.ToString()));
            return bookmark;
        }
    }

    public class XBancCacheException : Exception
    {
        private TestCaseInfo _testCase;
        public TestCaseInfo TestCase
        {
            get { return _testCase; }
        }

        public XBancCacheException(String message, TestCaseInfo testCase)
            : this(message, testCase, null)
        { }

        public XBancCacheException(String message, TestCaseInfo testCase, Exception innerException)
            : base(message, innerException)
        {
            this._testCase = testCase;
        }
    }
    #endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncBookmarking.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using Catalog.TestCaseXmlParser;
using live.common.next;
using live.protocol.next;
using System.Xml;
using xonline.common.config;
using System.Collections;
using Catalog.Verifier;
using Catalog;

namespace CatalogTests
{
    [TestGroup]
    class FuncBookmarking : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FuncBookmarkingTestCases.xml";

        public FuncBookmarking()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            // This filter just has all of the available parameters, this way we can use a custom
            // query string for the queries but still use the DynamicManager to generate the expected
            // return results.
            FuncBookmarkFilter queryFilter = new FuncBookmarkFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            /*foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncBookmarkTestBase(testInfo));
            }*/
        }

        /// <summary>
        /// This is a filter class which just contains all of the possible parameters that can be
        /// used by the various FSE methods without requiring any special code to handle the distinct
        /// methods being called.
        /// </summary>
        public class FuncBookmarkFilter : FilterBase
        {
            /// <summary>
            /// Required.
            /// </summary>
            [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
            public String Locale;

            /// <summary>
            /// Required.
            /// </summary>
            [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
            public String LegalLocale;

            /// <summary>
            /// Required.
            /// </summary>
            [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
            public Int32 Store;

            /// <summary>
            /// Required.
            /// </summary>
            [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
            public Int32 PageSize;

            /// <summary>
            /// Required.
            /// </summary>
            [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
            public Int32 PageNum;

            /// <summary>
            /// Required.
            /// </summary>
            [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
            public Int32 DetailView;

            /// <summary>
            /// Required.
            /// </summary>
            [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
            public Int32 OfferFilterLevel;

            /// <summary>
            /// Optional.
            /// Up to 256 MediaIds may be specified.
            /// </summary>
            [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
            public List<Guid> MediaIds;

            /// <summary>
            /// Optional.
            /// Up to 64 RatingIds may be specified.
            /// </summary>
            [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
            public List<Int32> RatingIds;

            /// <summary>
            /// Optional.
            /// Up to 64 UserTypes may be specified.
            /// </summary>
            [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
            public List<Int32> UserTypes;

            /// <summary>
            /// Required.
            /// Up to 64 MediaTypes may be specified.
            /// </summary>
            [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
            public List<Int32> MediaTypes;

            /// <summary>
            /// Optional.
            /// Up to 64 CategoryIds may be specified.
            /// </summary>
            [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
            public List<Int32> CategoryIds;

            /// <summary>
            /// Optional.
            /// </summary>
            [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
            public Int32 OrderBy = -1;

            /// <summary>
            /// Optional.
            /// </summary>
            [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
            public Int32 OrderDirection = -1;

            /// <summary>
            /// Optional.
            /// </summary>
            [WebRequestParam("Bookmark", WebRequestParamType.NameValuePair, Requirement.Optional, "1/1/0001 12:00:00 AM")]
            public DateTime Bookmark;
        }

        public class FuncBookmarkTestBase : QueryTestBase
        {
            public FuncBookmarkTestBase(TestCaseInfo testInfo)
                : base(testInfo)
            {
                if (testInfo.InputValues["MethodName"] != null)
                {
                    MethodName = ((ArrayList)testInfo.InputValues["MethodName"])[0].ToString();
                }
                testInfo.InputValues.Remove("MethodName");
            }

            protected override void Init()
            {
                base.Init();
            }

            // Nother is returned so we really just want to insure that the 
            // error code is 0.
            protected override void Verify()
            {
                base.Verify();

                Media[] ms;
                Message msg;
                int totalItems;

                // using the DynamicOutput
                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, false);
                    Global.RO.Info(msg.info);
                    MediaObject[] mos = (MediaObject[])msArray.ToArray(typeof(MediaObject));
                    ms = new Media[mos.Length];
                    for (int i = 0; i < mos.Length; i++)
                    {
                        ms[i] = new Media(mos[i]);
                        // add TotalOfferCount to the outputTbl. The OutputTbl from MediaObject is always null
                        ms[i].outputTbl = new Hashtable();
                        ms[i].outputTbl["totaloffercount"] = mos[i].TotalOfferCount;
                    }
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMedia(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }

                bool success = CatVerify.FindMedia(doc, totalItems, ms, this.TestInfo, out msg);
                Global.RO.Info(msg.info);
                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncCacheBookmarking.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using Catalog.TestCaseXmlParser;
using System.IO;
using System.Collections;
using System.Xml;
using Thread = System.Threading.Thread;
using System.Data.SqlClient;

namespace CatalogTests
{
    [TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("Catalog")]

    public class FuncCacheBookmarking : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "CacheIntegrationTestCases.xml";

        public FuncCacheBookmarking()
        {
            string testCaseFile = Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(CacheTestBase.InputParameterNames);

            // Add all the test cases for each test type.  
            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                TestNode node = new P_Bookmark_Now(testInfo);
                node.TaggingData.AddTagValue("Frequency", "Full");
                node.TaggingData.AddTagValue("Requirement", "Manual");
                node.TaggingData.AddTagValue("Owner", "wirosas");
                node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                AddChild(node);
                //now user can not pass bookmark as parameter so comment out the pass now testcase. 
                //AddChild(new P_Bookmark_Null(testInfo));
            }
        }
    }

    public abstract class CacheBookmarkTestBase : CacheTestBase
    {
        protected DateTime _inputTime = DateTime.MinValue;
        protected virtual DateTime InputTime { get { return _inputTime; } }

        /// <summary>
        /// Based on the Input time provided by the test case, the expected value is calclated.
        /// This is a simplified version of actual FseBookmark code.
        /// </summary>
        private DateTime _expectedTime = DateTime.MinValue;
        protected virtual DateTime ExpectedTime
        {
            get
            {
                if (_expectedTime == DateTime.MinValue && InputTime != DateTime.MinValue)
                {
                    _expectedTime = Bookmark.Adjust(InputTime);
                }

                return _expectedTime;
            }
        }

        public CacheBookmarkTestBase(TestCaseInfo testInfo) : base(testInfo) { }

        private void Init()
        {
            // We want to reset these each time the test is run so that we don't cause problems 
            // if the test are run once and then run later without restarting STF
            _inputTime = DateTime.MinValue;
            _expectedTime = DateTime.MinValue;
        }

        protected override void InnerExecute()
        {

            Init();

            int cacheDuration = 14400; //default cache duration
            int cacheType = -2147483644; //i_flags; default value is for rolling cache.

            Global.RO.Info("Query NPDB for cache duration");

            StringBuilder query_cache_duration = new StringBuilder();
            query_cache_duration.AppendLine("SELECT i_cache_duration FROM t_fse_methods");
            query_cache_duration.AppendLine("WHERE vc_api_name = 'Catalog'");
            query_cache_duration.AppendLine("AND vc_environment = 'ALL'");
            query_cache_duration.AppendLine(string.Format("AND vc_method_name = '{0}'", this._testInfo.Name));

            StringBuilder query_cache_type = new StringBuilder();
            query_cache_type.AppendLine("SELECT i_flags FROM t_fse_parameters");
            query_cache_type.AppendLine("WHERE vc_api_name = 'Catalog'");
            query_cache_type.AppendLine("AND vc_environment = 'ALL'");
            query_cache_type.AppendLine("AND vc_parameter_name = 'Bookmark'");
            query_cache_type.AppendLine(string.Format("AND vc_method_name = '{0}'", this._testInfo.Name));

            string NPDBConnectionString = xonline.common.config.Config.GetSingleInterface(xonline.common.config.Interface.npdb).SqlConnectionString;
            SqlConnection sqlConnection = new SqlConnection(NPDBConnectionString);
            SqlCommand command = new SqlCommand(query_cache_duration.ToString(), sqlConnection);
            try
            {
                sqlConnection.Open();

                //query for cache duration
                command.CommandType = System.Data.CommandType.Text;
                SqlDataReader reader = command.ExecuteReader();

                reader.Read();
                if (reader.HasRows)
                    cacheDuration = Convert.ToInt32(reader[0]);
                reader.Close();

                //query for cache type
                command = new SqlCommand(query_cache_type.ToString(), sqlConnection);
                reader = command.ExecuteReader();

                reader.Read();
                if (reader.HasRows)
                    cacheType = Convert.ToInt32(reader[0]);
                reader.Close();

                sqlConnection.Close();
            }
            catch (Exception e)
            {
                Global.RO.Warn("Failed to query npdb for cache settings");
                sqlConnection.Close();
                Global.RO.Warn(e.Message);
            }

            String inputTimeStr;
            DateTime adjustBookmark = DateTime.UtcNow;

            /*if (InputTime == DateTime.MinValue) {
                inputTimeStr = "null";
            }
            else*/
                inputTimeStr = InputTime.ToString();

             Global.RO.Info("fluah catalog cache");
             Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog flush");
             Thread.Sleep(3000);
           
            //String expectTimeStr = ExpectedTime.ToString();

            Global.RO.Info("Setting the input time to " + inputTimeStr);
            ArrayList bookmark = new ArrayList();
            bookmark.Add(inputTimeStr);

            _testInfo.InputValues["Bookmark"] = bookmark;

     
            _request = CreateRequestFilter(_testInfo);
            XmlDocument doc;

            // We need to recreate the request filter
            Global.RO.Info("Querying the database");

            Global.RO.Info("Query String: " + _request.GetRelativeUrl() + _request.ToQueryString());
            if (InputTime == DateTime.MinValue)
            {
                Global.RO.Info("Pass Bookmark null");
                StringBuilder stringBuilder = new StringBuilder();
                String CustomQuery = _request.ToQueryString();
                CustomQuery = CustomQuery.Remove(0, 1);
                //CustomQuery.Replace("1/1/0001 12:00:00 AM", "null");
                doc = Query(CustomQuery);

                bookmark = new ArrayList();
                bookmark.Add(DateTime.UtcNow.ToString());
                _testInfo.InputValues["Bookmark"] = bookmark;
            }
            else
            {
                doc = Query(); 
                
                if (cacheType == 4) //aligned cache
                    adjustBookmark = Bookmark.Adjust(InputTime);

                Global.RO.Info("Checking cache using expected time of " + adjustBookmark);
            }
            
            
            //bookmark.Clear();
            //bookmark.Add(expectTimeStr);
           
            // Flush the key so that it gets regenerated each time the test is run.  Without this, 
            // running the test and waiting a few minutes and running again will cause wierd problems.
            this.ResetKey();

            // We need to rebuild the request again
            //_request = CreateRequestFilter(testCase);

            Byte[] cachedData;
            uint expirationSeconds;
            DateTime cacheExpiration;
            // The generated key uses the expected time
            if (_xb.Query(this.Keys[0], out cachedData, out expirationSeconds ) != 0)
            {
                throw new XBancCacheException("Data not found in cache ", _testInfo);
            }
            else
            {
                DateTime now = DateTime.UtcNow;
                Global.RO.Success("Data found in cache");
                cacheExpiration = now.AddSeconds(expirationSeconds);
                Global.RO.Info("Cache expired at " + cacheExpiration);

                if (cacheExpiration > adjustBookmark.AddSeconds(cacheDuration + 30) || cacheExpiration < adjustBookmark.AddSeconds(cacheDuration - 30))
                {
                    Global.RO.Error("cacheExpiration does not match expectedExpiration");
                    throw new UnexpectedTestResultException("Verification failed.");
                }
            }
        }
    }

    #region Positive Test Cases
    public class P_Bookmark_Now : CacheBookmarkTestBase
    {
        public P_Bookmark_Now(TestCaseInfo testInfo) : base(testInfo) { }

        protected override DateTime InputTime
        {
            get
            {
                return DateTime.UtcNow;
            }
        }
    }


    public class P_Bookmark_Null : CacheBookmarkTestBase
    {
        public P_Bookmark_Null(TestCaseInfo testInfo) : base(testInfo) { }
        
    }
    public class P_Bookmark_1HrOld : CacheBookmarkTestBase
    {
        public P_Bookmark_1HrOld(TestCaseInfo testInfo) : base(testInfo) { }

        protected override DateTime InputTime
        {
            get
            {
                if (_inputTime == DateTime.MinValue)
                {
                    _inputTime = DateTime.UtcNow.AddHours(-2);
                }

                return _inputTime;
            }
        }
    }

    public class P_Bookmark_24HrsOld : CacheBookmarkTestBase
    {
        public P_Bookmark_24HrsOld(TestCaseInfo testInfo) : base(testInfo) { }

        protected override DateTime InputTime
        {
            get
            {
                if (_inputTime == DateTime.MinValue)
                {
                    _inputTime = DateTime.UtcNow.AddDays(-2);
                }

                return _inputTime;
            }
        }
    }

    public class P_Bookmark_OneWeekOld : CacheBookmarkTestBase
    {
        public P_Bookmark_OneWeekOld(TestCaseInfo testInfo) : base(testInfo) { }

        protected override DateTime InputTime
        {
            get
            {
                if (_inputTime == DateTime.MinValue)
                {
                    _inputTime = DateTime.UtcNow.AddDays(-8);
                }

                return _inputTime;
            }
        }
    }
    #endregion

    #region Negative Test Cases
    public class N_Bookmark_MaxTime : CacheBookmarkTestBase
    {
        public N_Bookmark_MaxTime(TestCaseInfo testInfo) : base(testInfo) { }

        protected override DateTime InputTime
        {
            get
            {
                return DateTime.MaxValue;
            }
        }
    }
        
    public class N_Bookmark_Future_LessThan1Hr : CacheBookmarkTestBase
    {
        public N_Bookmark_Future_LessThan1Hr(TestCaseInfo testInfo) : base(testInfo) { }

        protected override DateTime InputTime
        {
            get
            {
                if (_inputTime == DateTime.MinValue)
                {
                    _inputTime = DateTime.UtcNow.AddMinutes(45);
                }

                return _inputTime;
            }
        }
    }

    public class N_Bookmark_Future_MoreThan1Hr : CacheBookmarkTestBase
    {
        public N_Bookmark_Future_MoreThan1Hr(TestCaseInfo testInfo) : base(testInfo) { }

        protected override DateTime InputTime
        {
            get
            {
                if (_inputTime == DateTime.MinValue)
                {
                    _inputTime = DateTime.UtcNow.AddDays(5);
                }

                return _inputTime;
            }
        }
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncFindFeaturedPodcasts.cs ===
using System;
using System.Collections;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;

using live.client;
using live.common.next;
using live.protocol.next;
using live.server;

namespace CatalogTests
{
    [TestGroup]
    public class FuncFindFeaturedPodcasts : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindFeaturedPodcastsTestCases.xml";

        public FuncFindFeaturedPodcasts()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindFeaturedPodcastsFilter queryFilter = new FindFeaturedPodcastsFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            //LSG4943
            /*
            foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncFindFeaturedPodcastsTestBase(testInfo));
            }*/
        }

        public class FuncFindFeaturedPodcastsTestBase : QueryTestBase
        {
            public FuncFindFeaturedPodcastsTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindFeaturedPodcastsFilter();
                MethodName = QueryRequestBase.QueryMethod.FindFeaturedPodcasts;
            }

            protected override void Verify()
            {
                base.Verify();

                Media[] ms;
                Message msg;
                int totalItems;
                ArrayList list;
                
                // using the DynamicOutput
                if (TestInfo.InputValues["MediaTypes"] == null)
                {
                    list = new ArrayList();
                    list.Add("13");
                    TestInfo.InputValues.Add("MediaTypes", list);
                }


                if (TestInfo.InputValues["OrderBy"] == null)
                {
                    list = new ArrayList();
                    list.Add("10");
                    TestInfo.InputValues["OrderBy"] = list;
                }

                if (TestInfo.InputValues["OrderDirection"] == null)
                {
                    list = new ArrayList();
                    list.Add("1");
                    TestInfo.InputValues["OrderDirection"] = list;
                }

                if (TestInfo.InputValues["StartDate"] == null)
                {
                    list = new ArrayList();
                    list.Add(DateTime.Today.ToString());
                    TestInfo.InputValues.Add("StartDate", list);
                }

                if (TestInfo.InputValues["EndDate"] == null)
                {
                    list = new ArrayList();
                    list.Add(DateTime.Today.ToString());
                    TestInfo.InputValues.Add("EndDate", list);
                }

                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, false);
                    Global.RO.Info(msg.info);
                   
                    MediaObject[] mos;
                    if (msArray != null)
                    {
                        mos = (MediaObject[])msArray.ToArray(typeof(MediaObject));
                        ms = new Media[mos.Length];
                        for (int i = 0; i < mos.Length; i++)
                        {
                            ms[i] = new Media(mos[i]);
                            // add TotalOfferCount to the outputTbl. The OutputTbl from MediaObject is always null
                            ms[i].outputTbl = new Hashtable();
                            ms[i].outputTbl["totaloffercount"] = mos[i].TotalOfferCount;
                        }
                    }
                    else ms = null;
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMedia(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }
                
                bool success = CatVerify.FindPodcasts(doc, totalItems, ms, this.TestInfo, out msg);
                Global.RO.Info(msg.info);
                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncDownloadHistory.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Text;
using System.Xml;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.protocol;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;

using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;

using live.client;
using live.common;
using live.common.next;
using live.protocol.next;
using live.server.next;

using XeXbos;
using EMS = Microsoft.Ems.Common.Catalog;

namespace CatalogTests
{
    public class CatMedia : EMS.Media
    {
        public int DetailView = 1;
        public int VisibilityStatus = 3;

        public CatMedia()
            : base()
        {
        }

        public CatMedia(SqlDataReader reader)
        {
            this.Id = reader.GetGuid(reader.GetOrdinal("mediaId"));
            this.MediaTypeId = reader.GetInt32(reader.GetOrdinal("mediaTypeId"));
            this.ProviderId = reader.GetInt32(reader.GetOrdinal("providerId"));
            if (!reader.IsDBNull(reader.GetOrdinal("originalReleaseDate")))
                this.OriginalReleaseDate = reader.GetDateTime(reader.GetOrdinal("originalReleaseDate"));
            this.DisplayOriginalReleaseDate = reader.IsDBNull(reader.GetOrdinal("displayOriginalReleaseDate")) ?
                string.Empty : reader.GetString(reader.GetOrdinal("displayOriginalReleaseDate"));
            if (!reader.IsDBNull(reader.GetOrdinal("visibilityDate")))
                this.VisibilityDate = reader.GetDateTime(reader.GetOrdinal("visibilityDate"));
            this.VisibilityStatus = reader.GetInt32(reader.GetOrdinal("visibilityStatusId"));
            this.GeoCheckPolicy = reader.GetByte(reader.GetOrdinal("geoCheckPolicy")) == 1 ? true : false;

            // media locale
            EMS.MediaLocale locale = new EMS.MediaLocale();
            //locale.Lcid = reader.GetInt32(reader.GetOrdinal("lcid"));
            locale.Title = reader.IsDBNull(reader.GetOrdinal("title")) ? string.Empty : reader.GetString(reader.GetOrdinal("title"));
            locale.TitleSort = reader.IsDBNull(reader.GetOrdinal("titleSort")) ? string.Empty : reader.GetString(reader.GetOrdinal("titleSort"));
            locale.ReducedTitle = reader.IsDBNull(reader.GetOrdinal("reducedTitle"))? string.Empty : reader.GetString(reader.GetOrdinal("reducedTitle"));
            locale.Description = reader.IsDBNull(reader.GetOrdinal("description")) ? string.Empty : reader.GetString(reader.GetOrdinal("description"));
            locale.ReducedDescription = reader.IsDBNull(reader.GetOrdinal("reducedDescription")) ? string.Empty : reader.GetString(reader.GetOrdinal("reducedDescription"));

            this.Locales = new Microsoft.Ems.Common.Catalog.MediaLocale[] { locale };
        }

        public CatMedia(Guid id, int mediaTypeId, DateTime originalReleaseDate, DateTime visibilityDate, int visibilityStatusId)
            : base()
        {
            this.Id = id;
            this.MediaTypeId = mediaTypeId;
            this.OriginalReleaseDate = originalReleaseDate;
            this.VisibilityDate = visibilityDate;
            this.VisibilityStatusId = visibilityStatusId;
        }

        public override void Serialize(Microsoft.Ems.Common.Catalog.Serialization context)
        {
            //base.Serialize(context);
            context.SerializeStartElement("live-media");
            context.SerializeElement("live-mediaType", MediaTypeId);

            if (this.DetailView > 1)
            {
                if (!string.IsNullOrEmpty(this.Locales[0].ReducedTitle))
                    context.SerializeElement("live-reducedTitle", this.Locales[0].ReducedTitle);
                if (!string.IsNullOrEmpty(this.Locales[0].ReducedDescription))
                    context.SerializeElement("live-reducedDescription", this.Locales[0].ReducedDescription);

                DateTime tempDate = (DateTime)VisibilityDate;
                string temp = tempDate.ToString("s") + ((tempDate.Millisecond == 0) ? "" : ("." + tempDate.Millisecond.ToString("000"))) + 'Z';
                context.SerializeElement("live-availabilityDate", temp);

                if (OriginalReleaseDate != null)
                {
                    tempDate = (DateTime)OriginalReleaseDate;
                    temp = tempDate.ToString("s") + ((tempDate.Millisecond == 0) ? "" : ("." + tempDate.Millisecond.ToString("000"))) + 'Z';
                    context.SerializeElement("live-releaseDate", temp);
                }
            }

            context.SerializeEndElement();
        }
    }

    public class CatMediaInstance : EMS.MediaInstance
    {
        private CatMedia _media;
        public CatMedia Media
        {
            get
            {
                return this._media;
            }
            set
            {
                this._media = value;
            }
        }

        public int ActionValue = 2;
        public DateTime ActionDate = DateTime.MinValue;
        public int ActionCount = 0;

        public int DetailView = 1;

        public CatMediaInstance()
            : base()
        {
        }

        public CatMediaInstance(Guid id, bool isAcquirable, bool isAdSupported, bool isPreview, int actionValue, DateTime actionDate, int actionCount)
            : base(id, isAcquirable, isAdSupported, isPreview)
        {
            this.ActionValue = actionValue;
            this.ActionDate = actionDate;
            this.ActionCount = actionCount;
        }

        public CatMediaInstance(SqlDataReader reader)
        {
            this.Media = new CatMedia(reader);

            this.Id = reader.GetGuid(reader.GetOrdinal("mediaInstanceId"));
            this.IsAcquirable = (reader.GetByte(reader.GetOrdinal("isAcquirable")) == 1);
            this.IsAdSupported = (reader.GetByte(reader.GetOrdinal("isAdSupported")) == 1);
            this.IsPreview = (reader.GetByte(reader.GetOrdinal("isPreview")) == 1);
        }

        public void ActionSerialize(Microsoft.Ems.Common.Catalog.Serialization context)
        {
            context.SerializeStartElement("live-action");
            context.SerializeElement("live-actionValue", ActionValue);
            context.SerializeElement("live-actionDate", ActionDate.ToString("s") + 'Z');
            context.SerializeElement("live-actionCount", ActionCount);
            context.SerializeEndElement();
        }

        public override void Serialize(Microsoft.Ems.Common.Catalog.Serialization context)
        {
            //base.Serialize(context);
            context.SerializeStartElement("live-mediaInstance");
            
            context.SerializeElement("live-instanceId", "urn:uuid:" + Id.ToString().ToUpper());
            context.SerializeElement("live-mediaId", "urn:uuid:" + Media.Id.ToString().ToUpper());
            context.SerializeElement("live-isAcquirable", IsAcquirable);
            context.SerializeElement("live-isAdSupported", IsAdSupported);

            // the live-actions node
            context.SerializeStartElement("live-actions");
            ActionSerialize(context);
            context.SerializeEndElement();

            context.SerializeEndElement();
        }

        public void DownloadHistoryEntrySerialize(Microsoft.Ems.Common.Catalog.Serialization context)
        {
            context.SerializeStartElement("entry");
            
            if (!string.IsNullOrEmpty(Media.Locales[0].ReducedTitle))
                context.SerializeElement("title", Media.Locales[0].ReducedTitle);
            context.SerializeElement("id", "tag:www.live.com/marketplace/downloadhistory/" + Media.Id.ToString().ToUpper() + '/' + Id.ToString().ToUpper() + '/' + ActionValue);
            context.SerializeElement("updated", DateTime.UtcNow);
            context.SerializeElement("content", "media content");
            
            Media.Serialize(context);

            if (this.DetailView > 1)
            {
                context.SerializeStartElement("live-mediaInstances");
                this.Serialize(context);
                context.SerializeEndElement();
            }
            context.SerializeEndElement();
        }
    }

    public enum UsageDataAttributes : uint
    {
        USAGE_ATTRIBUTE_PLAYCOUNT = 1,
        USAGE_ATTRIBUTE_DOWNLOADCOUNT = 2,
        USAGE_ATTRIBUTE_PURCHASECOUNT = 3,
        USAGE_ATTRIBUTE_RATING = 4,
        USAGE_ATTRIBUTE_STREAMCOUNT = 5,
        USAGE_ATTRIBUTE_SENDCOUNT = 6,
        USAGE_ATTRIBUTE_COMMENTCOUNT = 7,
        USAGE_ATTRIBUTE_SKIPCOUNT = 8,
        USAGE_ATTRIBUTE_AD_PLAYCOUNT = 9
    }

    public enum UsageDataSources : uint
    {
        USAGE_SOURCE_XBOX = 1,
        USAGE_SOURCE_ZUNE = 2
    }

    public static class UsageStoreHelper
    {
        public static UsageStoreResponse IssueRequest(string xml)
        {
            UsageStoreRequest request = new UsageStoreRequest();
            UsageStoreResponse response = new UsageStoreResponse();
            XRLObject2 responseObject = response as XRLObject2;
            request.XML = xml;
            request.XMLSize = (uint)xml.Length;
            XRLUtil.PostXrlRequest(VirtualInterface.xstatsfd_int, request.GetXRL(), null, request, ref responseObject);
            if (response.hr != ServerTestFramework.LiveService.HResult.S_OK)
            {
                throw new ServerTestFramework.HResultException(response.hr);
            }

            return response;
        }

        public static void GetXml(ulong userId, string[] mediaId, int[] mediaType, int[] value)
        {
            if (mediaId.Length != mediaType.Length || mediaId.Length != value.Length)
                throw new Exception("Array sizes must be the same.");

            string AdId = null;
            string ProviderId = null;
            int AttributeId = (int)UsageDataAttributes.USAGE_ATTRIBUTE_DOWNLOADCOUNT;
            int Source = (int)UsageDataSources.USAGE_SOURCE_ZUNE;

            for (int i = 0; i < mediaId.Length; i++)
            {
                StringBuilder xml = new StringBuilder();
                xml.Append("<UsageStore xmlns=\"http://www.xboxlive.com/usage\">");
                xml.Append(string.Format("<User Id=\"{0}\">", String.Format("{0:x}", userId)));

                    xml.Append(string.Format("<Media Id=\"{0}\"{1}{2} Type=\"{3}\">", mediaId[i], AdId == null ? "" : string.Format(" AdId=\"{0}\"", AdId), ProviderId == null ? "" : string.Format(" ProviderId=\"{0}\"", ProviderId), mediaType[i]));
                    xml.Append(string.Format("<Attribute Id=\"{0}\" Date=\"{1}\" Value=\"{2}\" Source=\"{3}\"/>", AttributeId, DateTime.UtcNow, value[i], Source));
                    xml.Append("</Media>");

                xml.Append("</User>");
                xml.Append("</UsageStore>");

                if (i != 0)
                    System.Threading.Thread.Sleep(1000);   // wait 1 second between each request

                IssueRequest(xml.ToString());
            }
        }
    }

    [TestGroup]
    public class FuncDownloadHistory : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "DownloadHistoryTestCase.xml";

        public FuncDownloadHistory()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            DownloadHistoryFilter queryFilter = new DownloadHistoryFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            //LSG 4943
            /*foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncDownloadHistoryTestBase(testInfo));
            }*/
        }

        public class FuncDownloadHistoryTestBase : QueryTestBase
        {
            // add usage data for music (mediaType, 25, Track)
            //static string[] mediaIds = new string[] { "23020000-0100-11DB-89CA-0019B92A3933", "23020000-0100-11DB-89CA-0019B92A3933", "2B520200-0100-11DB-89CA-0019B92A3933" };
            //static string[] mediaInstanceIds = new string[] { "23020000-0900-11DB-89CA-0019B92A3933", "23020000-0B00-11DB-89CA-0019B92A3933", "2B520200-0B00-11DB-89CA-0019B92A3933" };
            static string[] mediaInstanceIds = new string[] { "41000000-0D00-11DB-89CA-0019B92A3933", "41000000-0F00-11DB-89CA-0019B92A3933", "41000000-1000-11DB-89CA-0019B92A3933" };
            static int[] mediaTypes = new int[] { 25, 25, 25 };
            static int[] values = new int[] { 4, 2, 3 };

            // below are video media and mediainstance (mediatype, 2, 7, 14, 8 and 9, Movie, Viral Video, Image, TVEpisode and TVSeason ), but should work with DownloadHistory
            //static string[] vmediaIds = new string[] { "033F5AAD-97D9-44A0-A362-0535A73BFA9C", "033F5AAD-97D9-44A0-A362-0535A73BFA9C", "AFBB4A71-9156-42F6-9357-753FF1C7216B" };
            static string[] vmediaInstanceIds = new string[] { "2DDB726B-F2AB-422F-A1D7-EF94C1C5ABE9", "B7DE520B-3C28-4A21-B1CC-F06E776BA43F", "9586659E-C6C1-4598-A47E-048888851E45", 
                "67E873CA-0044-4DB3-908E-491B06A6B342", /*"4464A44B-5FE3-4F34-BA8C-A3A57A87E496", "CB649A86-05D6-46F0-8C59-6D44CABC6B66",*/ 
                /*peng "DEDF158E-BFA5-4B1E-B42D-1C13589C2EFD", "D509F90D-EA23-44D8-BA5A-1C136A211B0C", "42EE0E25-E946-403F-9253-1C158EEF82CD", 
                "4B2BE928-D9FD-4EF3-B414-1C19B83F6CA0", "2FD61B12-5B1E-474A-9D3B-1C278AC3E9EC", "A850979C-E9BA-4364-AC84-1C2932C13EF9", 
                "2F80C813-BF19-41FF-9E77-1C2937B3BAE6", peng"170C0A9F-5F86-45CE-B736-1C2B5A250EC1", "976DA372-8277-4D20-B5B1-1C4021FEF094"*/ };
            static int[] vmediaTypes = new int[] { 8, 8, 2, 7, /*8, 2,*/ /*14, 14, 14, 14, 14, 14, 14, /*14, 14*/};
            // VisibilityStatusId {3,3,3,1,1,1, all 3}
            static int[] vvalues = new int[] { 4, 2, 3, 7, /*8, 2,*/ /*14, 14, 14, 14, 14, 14, 14, /*14, 14*/ };

            private static Hashtable _videoMediaInstanceList = null;
            protected static Hashtable VideoMediaInstanceList
            {
                get
                {
                    if (_videoMediaInstanceList == null)
                    {
                        _videoMediaInstanceList = new Hashtable();
                        for (int i = 0; i < vmediaInstanceIds.Length; i++)
                        {
                            CatMediaInstance mi = GetMediaAndMediaInstanceFromDB(CatalogQueryTestSuite.FeCatalogDBXbox, vmediaInstanceIds[i]);
                            if (mi == null)
                            {
                                Global.RO.Warn("No record returned for mediainstanceid = " + vmediaInstanceIds[i]);
                                continue;
                                //throw new UnexpectedTestResultException("No record returned for mediainstanceid = " + vmediaInstanceIds[i]);
                            }
                            mi.ActionCount = vvalues[i];
                            _videoMediaInstanceList.Add(mi.Id, mi);
                        }
                    }
                    return _videoMediaInstanceList;
                }
            }

            private static Hashtable _musicMediaInstanceList = null;
            protected static Hashtable MusicMediaInstanceList
            {
                get
                {
                    if (_musicMediaInstanceList == null)
                    {
                        _musicMediaInstanceList = new Hashtable();
                        for (int i = 0; i < mediaInstanceIds.Length; i++)
                        {
                            CatMediaInstance mi = GetMediaAndMediaInstanceFromDB(CatalogQueryTestSuite.FeCatalogDBZune, mediaInstanceIds[i]);
                            if (mi == null)
                                throw new UnexpectedTestResultException("No record returned for mediainstanceid = " + mediaInstanceIds[i]);
                            mi.ActionCount = values[i];
                            _musicMediaInstanceList.Add(mi.Id, mi);
                        }
                    }
                    return _musicMediaInstanceList;
                }
            }

            private static CatMediaInstance GetMediaAndMediaInstanceFromDB(string iface, string mediaInstanceId)
            {
                CatMediaInstance mi =  null;
                string sql = "select m.mediaId, m.mediaTypeId, m.providerId, m.originalReleaseDate, m.displayOriginalReleaseDate, m.visibilityDate, m.visibilityStatusId, " + 
                    "m.geoCheckPolicy, ml.lcid, ml.title, ml.titleSort, ml.reducedTitle, ml.description, ml.reducedDescription, mi.mediaInstanceId, mi.isAcquirable, " + 
                    "mi.isAdSupported, mi.isPreview from mediainstance mi (nolock) inner join media m (nolock) on m.mediaid = mi.mediaid " + 
                    "inner join medialocale ml (nolock) on m.mediaid = ml.mediaid where mi.mediainstanceid = '" + mediaInstanceId + "' and ml.lcid = 1033";
                
                try
                {
                    using (SqlClient client = new SqlClient(iface, true))
                    {
                        using (SqlDataReader reader = client.Execute(sql))
                        {
                            // should always return exact one row
                            while (reader.Read())
                            {
                                mi = new CatMediaInstance(reader);
                            }

                            reader.Close();
                            return mi;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Failed to load media and mediainstance from DB. Sql = " + sql + "\nError message: " + e.Message);
                    throw;
                }
            }

            protected static Xbox360Client XenonClient = new Xbox360Client();
            private static live.common.XblUser _user = null;
            private static live.protocol.FakeAAInfo _fakeAAInfo = null;
            protected static live.common.XblUser User
            {
                get
                {
                    if (_user == null)
                    {
                        // create a user
                        _user = UserHelper.CreateUser(XenonClient, UserHelper.UserType.Silver, CountryId.US, PassportType.Real);

                        // music
                        UsageStoreHelper.GetXml(User.Puid, mediaInstanceIds, mediaTypes, values);

                        // video
                        UsageStoreHelper.GetXml(User.Puid, vmediaInstanceIds, vmediaTypes, vvalues);
                    }
                    return _user;
                }
            }

            protected static live.protocol.FakeAAInfo fakeAAInfo
            {
                get
                {
                    if (_fakeAAInfo == null)
                    {
                        // prepare the FakeAAInfo
                        _fakeAAInfo = new live.protocol.FakeAAInfo(User);
                    }
                    return _fakeAAInfo;
                }
            }

            public FuncDownloadHistoryTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();

                // prepare the web request
                QueryFilter = new DownloadHistoryFilter();
                if (string.IsNullOrEmpty(CustomQuery))
                {
                    req = new DownloadHistoryWebRequest(User.Puid, WebClient.MachinePuid, QueryFilter.BuildNameValuePairs(TestInfo.InputValues));
                    // fill the values for the filter
                    QueryFilter.BuildFilter(TestInfo.InputValues);
                }
                else
                {
                    req = new CustomWebRequest(BillingWebRequest.HISTORY_BASE_URL, BillingWebRequest.BillingOperation.Query, CustomQuery);
                }
            }

            protected override void InnerExecute()
            {
                Global.RO.Info("Query String: " + req.GetRelativeUrl() + req.ToQueryString());

                BillingWebResponse resp = new BillingWebResponse();
                req.BehaviorInjection.headers.Add(live.protocol.FakeAAInfo.HeaderKey, fakeAAInfo.ConvertoToBase64String());
                live.server.Billing.SendRequest(WebClient, User, live.common.XOService.WebBilling, req, resp);

                Global.RO.Success("Response is: \n" + resp.Response);
                Global.RO.Info("");

                doc = new XmlDocument();
                doc.LoadXml(resp.Response);
            }

            protected override void Verify()
            {
                base.Verify();
                string msg = "\r\n";
                string[] nodeList = new string[] { "atom:title", "atom:id", "live:media", "live:mediaInstances" };
                string[] ignoreList = new string[] { "live:actionDate" };

                // get the filter and assign correct values for optional fields
                DownloadHistoryFilter filter = (DownloadHistoryFilter)QueryFilter;
                if (filter.OrderBy == -1)
                    filter.OrderBy = 0;
                if (filter.OrderDirection == -1)
                    filter.OrderDirection = 1;

                List<CatMediaInstance> miGuids = new List<CatMediaInstance>();

                // check on Strore for EMS/Zune
                if (filter.Store == 1)   // xbox
                {
                    for (int i = 0; i < vmediaInstanceIds.Length; i++)
                    {
                        CatMediaInstance mi = (CatMediaInstance)VideoMediaInstanceList[new Guid(vmediaInstanceIds[i])];
                        miGuids.Add(mi);
                    }
                }
                else   // zune
                {
                    for (int i = 0; i < mediaInstanceIds.Length; i++)
                    {
                        miGuids.Add((CatMediaInstance)MusicMediaInstanceList[new Guid(mediaInstanceIds[i])]);
                    }
                }

                // check on orderDirection
                if (filter.OrderDirection == 2)   // descending
                {
                    miGuids.Reverse();
                }

                // check on mediaType
                int count = miGuids.Count;
                for (int i = 0; i < count; i++)
                {
                    if (miGuids.Count <= i)
                        break;
                    if (!filter.MediaTypes.Contains(miGuids[i].Media.MediaTypeId))
                    {
                        miGuids.Remove(miGuids[i]);
                        i--;
                    }
                }

                int totalItems = miGuids.Count;

                // check on pageNum and pageSize
                if (filter.PageNum < 1)
                {
                    miGuids = new List<CatMediaInstance>();
                }
                else if (filter.PageNum == 1)
                {
                    if (filter.PageSize < miGuids.Count)
                    {
                        miGuids.RemoveRange(filter.PageSize, miGuids.Count - filter.PageSize);
                    }
                }
                else
                {
                    int startIndex = (filter.PageNum - 1) * filter.PageSize;
                    if (startIndex >= miGuids.Count)
                        miGuids = new List<CatMediaInstance>();
                    else
                    {
                        int endIndex = ((startIndex + filter.PageSize) <= miGuids.Count) ? startIndex + filter.PageSize : miGuids.Count;
                        miGuids.RemoveRange(endIndex, miGuids.Count - endIndex);
                        miGuids.RemoveRange(0, startIndex);
                    }
                }

                // only check on visibilityStatusId if video data and need to check it after paging is done (paging is done in UODB)
                if (filter.Store == 1)
                {
                    count = miGuids.Count;
                    for (int i = 0; i < count; i++)
                    {
                        if (miGuids.Count <= i)
                            break;
                        if (miGuids[i].Media.VisibilityStatus <3 || miGuids[i].Media.VisibilityStatus > 4)
                        {
                            miGuids.Remove(miGuids[i]);
                            i--;
                        }
                    }
                }

                // get the expected xml output
                EMS.Serialization context = new Microsoft.Ems.Common.Catalog.Serialization();
                context.SerializeStartElement("feed");
                context.SerializeElement("live-totalItems", totalItems);
                context.SerializeElement("live-numItems", miGuids.Count);
                context.SerializeElement("title", "DownloadHistory");
                context.SerializeElement("updated", DateTime.UtcNow);
                foreach (CatMediaInstance mi in miGuids)
                {
                    mi.DetailView = filter.DetailView;
                    mi.Media.DetailView = filter.DetailView;
                    mi.DownloadHistoryEntrySerialize(context);
                }
                context.SerializeEndElement();
                string xmlExpect = context.ResultXml;
                xmlExpect = xmlExpect.Replace("<feed>", "<feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:live=\"http://www.live.com/marketplace\">");
                xmlExpect = xmlExpect.Replace("<live-", "<live:");
                xmlExpect = xmlExpect.Replace("</live-", "</live:");

                // get the xml
                XmlDocument miXml = new XmlDocument();
                miXml.LoadXml(xmlExpect);

                Global.RO.Success("Expected XML is: \n" + miXml.OuterXml);
                Global.RO.Info("");

                bool match = CatVerify.XmlDocCompare(miXml.LastChild, doc.LastChild, nodeList, ignoreList, ref msg);

                //bool match = CatVerify.XmlDocCompare(TestInfo.OutputXml.LastChild, doc.LastChild, nodeList, ignoreList, ref msg);
                //string[] ignoreList = new string[] { "title", "updated", "content", "live:actionDate" };
                //bool match = CatVerify.XmlNodeCompare(TestInfo.OutputXml.LastChild, doc.LastChild, ignoreList, ref msg);
                if (!match)
                {
                    throw new UnexpectedTestResultException(msg);
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncCacheIntegration.cs ===
using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Data.SqlClient;

using Catalog.TestCaseXmlParser;

using live.common.next;
using live.common;
using live.client;
using live.protocol.next;

using ServerTestFramework;
//using xonline.common.service;
using xonline.common.sql.sqlclient;
using System.ServiceProcess;
using System.Diagnostics;
using Thread = System.Threading.Thread;

namespace CatalogTests
{
    #region Positive Test Cases
    [TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("xblobonly")]
    public class FuncCacheIntegration_Positive : CatalogTestBaseGroup
    {        
        private static string TestCaseXmlFile = "CacheIntegrationTestCases.xml";

        public FuncCacheIntegration_Positive()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(CacheTestBase.InputParameterNames);

            // Add all the test cases for each test type.  
            foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                TestNode node = new P_Query_Not_Cached(testInfo);
                node.TaggingData.AddTagValue("Frequency", "Full");
                node.TaggingData.AddTagValue("Requirement", "Manual");
                node.TaggingData.AddTagValue("Owner", "wirosas");
                node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                AddChild(node);
            }
            /*foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                AddChild(new P_Query_Cached_Fresh(testInfo));
            }
            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                AddChild(new P_Query_Cached_Expired(testInfo));
            }
            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                AddChild(new P_Query_Uses_NPDB(testInfo));
            }*/
            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                TestNode node = new P_Query_No_Caching(testInfo);
                node.TaggingData.AddTagValue("Frequency", "Full");
                node.TaggingData.AddTagValue("Requirement", "Manual");
                node.TaggingData.AddTagValue("Owner", "wirosas");
                node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                AddChild(node);
            }
            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                TestNode node = new P_Catalog_Cache_Flush(testInfo);
                node.TaggingData.AddTagValue("Frequency", "Full");
                node.TaggingData.AddTagValue("Requirement", "Manual");
                node.TaggingData.AddTagValue("Owner", "wirosas");
                node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                AddChild(node);
            }
        }
    }

    public class P_Query_Not_Cached : CacheTestBase
    {
        public P_Query_Not_Cached(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            Byte[] cachedData;

            // Check if it's in the database
            if (_xb.Query(this.Keys[0], out cachedData) == 0)
            {
                Global.RO.Info("Key already exists in Database, removing data");
                // If so, remove it 
                _xb.Remove(this.Keys[0]);

                // Then confirm it's not there
                if (_xb.Query(this.Keys[0], out cachedData) == 0)
                {
                    throw new XBancCacheException("Unable to remove existing key from XBanc", _testInfo);
                }
            }

            Global.RO.Info("Queying the database");
            XmlDocument doc = Query();

            if (_xb.Query(this.Keys[0], out cachedData) != 0)
            {
                throw new XBancCacheException("Queried data was not added to cache", _testInfo);
            }
            else
            {
                Global.RO.Success("Data was added to cache");
            }
        }
    }

    public class P_Query_Cached_Fresh : CacheTestBase
    {
        public P_Query_Cached_Fresh(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            _xb.Remove(this.Keys[0]);

            Global.RO.Info("Caching data from database");
            // Caches the data
            Query();

            Global.RO.Info("Adding cache attribute to cached data");
            AddCacheAttribute();

            Global.RO.Info("Requerying data");
            XmlDocument doc = Query();

            if (!CheckCacheAttribute(doc))
            {
                throw new XBancCacheException(
                    String.Format("Unable to find {0} attribute.  Data not from cache", CACHE_ATTRIB_NAME),
                    _testInfo);
            }
            else
            {
                Global.RO.Success("Data successfully cached");
            }
        }
    }

    public class P_Query_Cached_Expired : CacheTestBase
    {
        public P_Query_Cached_Expired(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            Global.RO.Info("Caching data from database");
            Query();

            Global.RO.Info("Adding cache attribute to cached data");
            AddCacheAttribute();

            Global.RO.Info("Waiting for cache to expire");
            WaitForExpire();

            Global.RO.Info("Requerying data");
            XmlDocument doc = Query();

            // If it has the cach attribute
            if (CheckCacheAttribute(doc))
            {
                throw new XBancCacheException(
                    String.Format("Data still has {0} attribute.  Cache not expiring.", CACHE_ATTRIB_NAME),
                    _testInfo);
            }
            else
            {
                Global.RO.Success("Data correctly expired");
            }
        }
    }

    public class P_Query_Uses_NPDB : CacheTestBase
    {
        public P_Query_Uses_NPDB(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            // Remove it in case it's already in the cache
            _xb.Remove(this.Keys[0]);

            Byte[] cachedData;
            // Cache the data
            Global.RO.Info("Querying the database");
            Query();

            if (_xb.Query(this.Keys[0], out cachedData) != 0)
            {
                throw new XBancCacheException("Data already gone from cache", _testInfo);
            }

            Global.RO.Info("Waiting for the cache to expire");
            WaitForExpire();

            if (_xb.Query(this.Keys[0], out cachedData) == 0)
            {
                throw new XBancCacheException(
                    "Cached data should have expired.  Catalog not using NPDB cache duration values",
                    _testInfo);
            }
            else
            {
                Global.RO.Success("Data in cache correctly expired");
            }
        }
    }

    public class P_Query_No_Caching : CacheTestBase
    {
        public P_Query_No_Caching(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            Int32 oldCacheDur = 0;
            Byte[] cachedData;

            Global.RO.Info("Querying the database");
            Query();

            // If it's in the cache
            if (_xb.Query(this.Keys[0], out cachedData) == 0)
            {
                Global.RO.Success("Data is stored in cache");
            }

            Global.RO.Info("Remove the key");
            _xb.Remove(this.Keys[0]);

            try
            {
                 // Set the cache dur to 0
                Global.RO.Info("Set the cache duration for {0} to 0", this.MethodName);
                using (SqlClient client = new SqlClient("npdb"))
                {
                    client.Command.CommandText =
                        String.Format("select i_cache_duration from t_fse_methods where vc_method_name='{0}'", this.MethodName);

                    Int32 cacheDur = Convert.ToInt32(client.ExecuteScalar());

                    if (cacheDur != 0)
                    {
                        oldCacheDur = cacheDur;
                        client.Command.CommandText =
                            String.Format("update t_fse_methods set i_cache_duration=0 where vc_method_name='{0}'", this.MethodName);

                        client.ExecuteNonQuery();

                        ReloadCatalogConfig();
                    }
                }


                Global.RO.Info("wait 1 min ");
                Thread.Sleep(60000);
             

               try
               {
                   XmlDocument doc = Query();
               }
               catch {
                   XmlDocument doc = Query();
               }
                
                // If it's in the cache
                if (_xb.Query(this.Keys[0], out cachedData) == 0)
                {
                    throw new XBancCacheException("API with 0 cache dur still being cached", _testInfo);
                }
                else
                {
                    Global.RO.Success("Data not stored in cache");
                }
            }
            finally
            {
                Global.RO.Info("Restoring old cache duration");
                using (SqlClient client = new SqlClient("npdb"))
                {
                    client.Command.CommandText =
                        String.Format("update t_fse_methods set i_cache_duration={0} where vc_method_name='{1}'", oldCacheDur, this.MethodName);

                    client.ExecuteNonQuery();
                }

                ReloadCatalogConfig();
                Global.RO.Info("wait 1 min for reload configure data");
                Thread.Sleep(60000);
                
            }
        }
    }

    public class P_Catalog_Cache_Flush : CacheTestBase
    {
        public P_Catalog_Cache_Flush(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            Global.RO.Info("Storing data in cache");
            Query();

            byte[] cacheData;
            if (_xb.Query(this.Keys[0], out cacheData) != 0)
            {
                throw new UnexpectedTestResultException("Unable to find data in cache");
            }

            Global.RO.Info("Flushing Cache");
            Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog flush");

            if (_xb.Query(this.Keys[0], out cacheData) == 0)
            {
                throw new UnexpectedTestResultException("Data is still in cache after flush");
            }
        }
    }
    #endregion

    #region Negative Test Cases
    [TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("xblobonly")]
    class FuncCacheIntegration_Negative : CatalogTestBaseGroup
    {
        private static string CacheTestCasesFile = "CacheIntegrationTestCases.xml";
        private static string InvalidTestCasesFile = "CacheInvalidQueryTestCases.xml";

        public FuncCacheIntegration_Negative()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, CacheTestCasesFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(CacheTestBase.InputParameterNames);

            // Add all the test cases for each test type.  
            foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                TestNode node = new N_XBanc_CaseInsensitive(testInfo);
                node.TaggingData.AddTagValue("Frequency", "Full");
                node.TaggingData.AddTagValue("Requirement", "Manual");
                node.TaggingData.AddTagValue("Owner", "wirosas");
                node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                AddChild(node);
            }

            testCaseFile = Path.Combine(TestCaseFilePath, InvalidTestCasesFile);
            testCaseParser = new TestCaseParser(testCaseFile);
            testCaseInfos = testCaseParser.GetAllTestCases(CacheTestBase.InputParameterNames);

            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                TestNode node = new N_XBanc_InvalidQuery(testInfo);
                node.TaggingData.AddTagValue("Frequency", "Full");
                node.TaggingData.AddTagValue("Requirement", "Manual");
                node.TaggingData.AddTagValue("Owner", "wirosas");
                node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                AddChild(node);
            }
        }
    }

    public class N_XBanc_Offline : CacheTestBase
    {
        public N_XBanc_Offline(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            Global.RO.Info("Querying the database");
            XmlDocument doc = Query();

            // Turn off the XBanc
            Global.RO.Info("Turning off XBanc Service");

            ServiceController serviceController = new ServiceController("XBanc", "dbalma1");
            serviceController.Stop();

            try
            {
                Global.RO.Info("Requerying the database");
                XmlDocument doc_off = Query();

                if (doc.InnerXml != doc_off.InnerXml)
                {
                    throw new XBancCacheException(
                        "Query results are different when query is performed with no XBanc server available",
                        _testInfo);
                }
                else
                {
                    Global.RO.Success("Query results were identical");
                }
            }
            finally
            {
                // Restart the service when we're done.
                Global.RO.Info("Restarting XBanc Service");
                serviceController.Start();
            }
        }
    }

    public class N_XBanc_InvalidQuery : CacheTestBase
    {
        public N_XBanc_InvalidQuery(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            // Remove the key just in case it exists
            _xb.Remove(this.Keys[0]);

            // Query it once,  response doesn't matter
            try
            {
                Global.RO.Info("Querying database");
                Query();
            }
            catch (Exception e)
            {
                // We expect this or something like it 
                Global.RO.Info(e.Message + e.StackTrace);
            }

            byte[] cachedData;

            // 0 means successful query
            Global.RO.Info("Checking if response was cached");

            if (_xb.Query(this.Keys[0], out cachedData) == 0)
            {
                String response = Encoding.Unicode.GetString(cachedData);

                throw new XBancCacheException(
                    String.Format("Invalid query response was cached.\r\nResponse: " + response),
                    _testInfo
                );
            }
            else
            {
                Global.RO.Success("Invalid query was not cached");
            }
        }
    }

    public class N_XBanc_CaseInsensitive : CacheTestBase
    {
        public N_XBanc_CaseInsensitive(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {
            Global.RO.Info("Updating the request filter method name");
            _request.MethodName = _request.MethodName.ToUpper();

            Global.RO.Info("Querying the database");
            Query();

            Byte[] cachedData;
            if (_xb.Query(this.Keys[0], out cachedData) != 0)
            {
                throw new XBancCacheException("Unable to find data in cache under expected key", _testInfo);
            }
            else
            {
                Global.RO.Success("Data found in cache under case insensitive key");
            }
        }
    }
    #endregion

    /*
    public class P_Query_ : CacheTestBase
    {
        public P_Query_(TestCaseInfo testInfo)
            : base(testInfo)
        {
        }

        protected override void InnerExecute()
        {

        }
    }
     */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncFindMedia.cs ===
using System;
using System.Collections;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;

using live.client;
using live.common.next;
using live.protocol.next;
using live.server;

namespace CatalogTests
{
    [TestGroup]
    public class FuncFindMedia : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindMediaTestCases.xml";

        public FuncFindMedia()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindMediaFilter queryFilter = new FindMediaFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            //LSG 4943 
            /*foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncFindMediaTestBase(testInfo));
            }*/
        }

        public class FuncFindMediaTestBase : QueryTestBase
        {
            public FuncFindMediaTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindMediaFilter();
                MethodName = QueryRequestBase.QueryMethod.FindMedia;
            }

            protected override void Verify()
            {
                base.Verify();

                Media[] ms;
                Message msg;
                int totalItems;

                // using the DynamicOutput
                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, false);
                    Global.RO.Info(msg.info);
                    MediaObject[] mos = (MediaObject[])msArray.ToArray(typeof(MediaObject));
                    ms = new Media[mos.Length];
                    for (int i = 0; i < mos.Length; i++)
                    {
                        ms[i] = new Media(mos[i]);
                        // add TotalOfferCount to the outputTbl. The OutputTbl from MediaObject is always null
                        ms[i].outputTbl = new Hashtable();
                        ms[i].outputTbl["totaloffercount"] = mos[i].TotalOfferCount;
                    }
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMedia(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }

                bool success = CatVerify.FindMedia(doc, totalItems, ms, this.TestInfo, out msg);
                Global.RO.Info(msg.info);
                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncFindGames.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using live.client;
using live.common.next;
using live.protocol.next;
using live.server;
using System.Xml;
using System.Data.SqlClient;
using System.Threading;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;
using xonline.common.sql.sqlclient;


namespace CatalogTests
{
    [TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class FuncFindGames : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindGamesTestCases.xml";

        public FuncFindGames()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindGamesFilter queryFilter = new FindGamesFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                if (testInfo.Name.Contains("P_Games_DbCachePageing"))
                {
                    continue;
                }
                if (testInfo.Name.Contains("VIPChange_2Queries"))
                {
                    TestNode node = new ConfigChangeTestBase(testInfo, false);
                    node.TaggingData.AddTagValue("Frequency", "Full");
                    node.TaggingData.AddTagValue("Owner", "wirosas");
                    node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                    AddChild(node);
                    continue;
                }
                if (testInfo.Name.Contains("QueryBeforeChange"))
                {
                    TestNode node = new ConfigChangeTestBase(testInfo, true);
                    node.TaggingData.AddTagValue("Frequency", "Full");
                    node.TaggingData.AddTagValue("Owner", "wirosas");
                    node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                    AddChild(node);
                    TestCaseInfo newTest = new TestCaseInfo(testInfo);
                    newTest.Name = "P_SerializeIndentityCall";

                    SerializeIndentityCallTestBase test1 = new SerializeIndentityCallTestBase(newTest, false);
                    AddChild(test1);
                    test1.TaggingData.AddTagValue("Frequency", "Full");
                    test1.TaggingData.AddTagValue("Requirement", "Manual");
                    test1.TaggingData.AddTagValue("Owner", "wirosas");
                    test1.TaggingData.AddTagValue("Priority", newTest.Priority);

                    TestCaseInfo newTest1 = new TestCaseInfo(testInfo);
                    newTest1.Name = "P_SerializeIndentityCall_FirstQueryFailed";

                    SerializeIndentityCallTestBase test = new SerializeIndentityCallTestBase(newTest1, true);
                    AddChild(test);
                    test.TaggingData.AddTagValue("Frequency", "Full");
                    test.TaggingData.AddTagValue("Requirement", "Manual");
                    test.TaggingData.AddTagValue("Owner", "wirosas");
                    test.TaggingData.AddTagValue("Priority", newTest.Priority);

                    continue;
                }
                if (!testInfo.Name.Contains("Editorial"))
                {
                    TestNode node = new FuncFindGamesTestBase(testInfo);
                    node.TaggingData.AddTagValue("Frequency", "Full");
                    node.TaggingData.AddTagValue("Owner", "wirosas");
                    node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                    AddChild(node);                    
                }
                else
                {
                    if (testInfo.Name.Contains("ByPassCache"))
                    {
                        ArrayList list = new ArrayList();
                        TestNode node = new EditorialTestBase(testInfo);
                        node.TaggingData.AddTagValue("Frequency", "Full");
                        node.TaggingData.AddTagValue("Owner", "wirosas");
                        node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                        AddChild(node);
                    }
                    else
                    {
                        ArrayList list = new ArrayList();
                        TestNode node = new EditorialVisibilityTestBase(testInfo);
                        node.TaggingData.AddTagValue("Frequency", "Full");
                        node.TaggingData.AddTagValue("Owner", "wirosas");
                        node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                        AddChild(node);
                    }
                }
            }
        }

        public class FuncFindGamesTestBase : QueryTestBase
        {
            public FuncFindGamesTestBase(TestCaseInfo testInfo)
                : base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindGamesFilter();
                MethodName = QueryRequestBase.QueryMethod.FindGames;
            }

            protected override void Verify()
            {
                base.Verify();

                Media[] ms;
                Message msg;
                int totalItems;

                // using the DynamicOutput
                if (TestInfo.ExpectedItems == null)
                {
                    bool filteronOffer = true;
                    if (TestInfo.InputValues["OfferFilterLevel"] == null || ((string)((ArrayList)TestInfo.InputValues["OfferFilterLevel"])[0]).Equals("1"))
                        filteronOffer = false;

                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, false);
                    Global.RO.Info(msg.info);
                    msg.info = "";
                    MediaObject[] mos = (MediaObject[])msArray.ToArray(typeof(MediaObject));
                    ms = new Media[mos.Length];

                    for (int i = 0; i < mos.Length; i++)
                    {

                        if (mos[i] is GameContentClass)
                            //right now alway set filter on offer is false
                            ((GameContentClass)mos[i]).FilteronContentnstance(DynManager.OfferTable.DataObjectMainTable,
                            filteronOffer);
                        if (mos[i] is GameTitleClass)
                            //right now alway set filter on offer is false
                            ((GameTitleClass)mos[i]).FilteronContentnstance(DynManager.OfferTable.DataObjectMainTable,
                            filteronOffer);
                        ms[i] = new Media(mos[i]);
                        // add TotalOfferCount to the outputTbl. The OutputTbl from MediaObject is always null
                        if (ms[i].outputTbl == null)
                            ms[i].outputTbl = new Hashtable();
                        ms[i].outputTbl["media/totaloffercount"] = mos[i].TotalOfferCount;

                        ms[i].outputTbl.Add("previewImage", QueryTestBase.GetComplexObject.PreviewImages(mos[i].MediaId, CatVerify.GetLocaleId(TestInfo)));
                    }
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMedia(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }

                bool success = CatVerify.FindGame(doc, totalItems, ms, this.TestInfo, out msg);
                //Global.RO.Info(msg.info);
                PrintInfo(msg.info);

                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");
            }
        }

        public class EditorialVisibilityTestBase : FuncFindGamesTestBase
        {
            public EditorialVisibilityTestBase(TestCaseInfo testInfo)
                : base(testInfo)
            {

            }

            protected override void Verify()
            {

                if (!TestInfo.InputValues.ContainsKey("OfferEditorial"))
                    TestInfo.InputValues.Add("OfferEditorial", null);

                if (!TestInfo.InputValues.ContainsKey("MediaEditorial"))
                    TestInfo.InputValues.Add("MediaEditorial", null);


                //EditorialVisibility.VerifyVisibility("fecatalogdbxbox");

                base.Verify();
            }


            protected override void InnerExecute()
            {

                EditorialTestBase.EditorialClientIPUpdate();
                base.InnerExecute();
                EditorialTestBase.EditorialClientIPClear();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

FILETARGET:
    -md %_NT386TREE%\test\stftests\InputFiles\CatalogOfferXmlFiles
    -robocopy .\CatalogOfferXmlFiles %_NT386TREE%\test\stftests\InputFiles\CatalogOfferXmlFiles *.* /PURGE /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncFindPodcasts.cs ===
using System;
using System.Collections;
using System.Text;
using System.Xml;
using System.Web;


using ServerTestFramework;
using ServerTestFramework.LiveService;

using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;

using live.client;
using live.common.next;
using live.protocol.next;
using live.server;

namespace CatalogTests
{
    [TestGroup]
    public class FuncFindPodcasts : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindPodcastsTestCases.xml";

        public FuncFindPodcasts()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindPodcastsFilter queryFilter = new FindPodcastsFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            //LSG 4943
            /*foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncFindPodcastsTestBase(testInfo));
            }*/
        }

        public class FuncFindPodcastsTestBase : QueryTestBase
        {
            public FuncFindPodcastsTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindPodcastsFilter();
                MethodName = QueryRequestBase.QueryMethod.FindPodcasts;
            }

            protected override void Verify()
            {
                base.Verify();

                Media[] ms;
                Message msg;
                int totalItems;
                ArrayList encodedMediaUrls = null;

                // using the DynamicOutput
                if (TestInfo.InputValues["MediaTypes"] == null)
                {
                    ArrayList list = new ArrayList();
                    list.Add("13");
                    TestInfo.InputValues.Add("MediaTypes", list);
                }

                if (TestInfo.InputValues["MediaIds"] != null && ((ArrayList)TestInfo.InputValues["MediaIds"])[0].ToString().ToLower() == "null")
                {
                    TestInfo.InputValues["MediaIds"] = null;
                }

                if (TestInfo.InputValues["TitleFilters"] != null && ((ArrayList)TestInfo.InputValues["TitleFilters"])[0].ToString().ToLower() == "null")
                {
                    TestInfo.InputValues["TitleFilters"] = null;
                }

                if (TestInfo.InputValues["PodcastType"] != null && ((ArrayList)TestInfo.InputValues["PodcastType"])[0].ToString().ToLower() == "4")
                {
                    TestInfo.InputValues.Remove("PodcastType");
                }
                
                if (TestInfo.InputValues["MediaUrls"] != null )
                {
                    ArrayList urlList = new ArrayList();

                    encodedMediaUrls = (ArrayList)TestInfo.InputValues["MediaUrls"];
                    foreach (string str in encodedMediaUrls)
                    {
                        urlList.Add(HttpUtility.UrlDecode(str));
                    }
                    TestInfo.InputValues["MediaUrls"] = urlList;
                }

                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, false);
                    Global.RO.Info(msg.info);
                    MediaObject[] mos;

                    if (msArray != null)
                    {
                        mos = (MediaObject[])msArray.ToArray(typeof(MediaObject));
                        ms = new Media[mos.Length];
                        for (int i = 0; i < mos.Length; i++)
                        {
                            ms[i] = new Media(mos[i]);
                            // add TotalOfferCount to the outputTbl. The OutputTbl from MediaObject is always null
                            ms[i].outputTbl = new Hashtable();
                            ms[i].outputTbl["totaloffercount"] = mos[i].TotalOfferCount;
                        }
                    }
                    else ms = null;
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMedia(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }
                
           
                bool success = CatVerify.FindPodcasts(doc, totalItems, ms, this.TestInfo, out msg);
                Global.RO.Info(msg.info);

                if (encodedMediaUrls != null) {
                    TestInfo.InputValues["MediaUrls"] = encodedMediaUrls;
                }

                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncFindVideos.cs ===
using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Data.SqlClient;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;
using Thread = System.Threading.Thread;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;

using live.client;
using live.common.next;
using live.protocol.next;
using live.server;
using xonline.common.sql.sqlclient;

namespace CatalogTests
{
    //[TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class FuncFindVideos : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindVideosTestCases.xml";
        private static String testnames = "";
        
        private void AddNewTest(TestCaseInfo testInfo, int dbPageSize, int cachePageSize, int userPageSize, FETCH_ORDER fetchOrder) {
            if (testnames.IndexOf("DbPageSize_" + dbPageSize + "CachePageSize_" + cachePageSize + "userPageSize_" + userPageSize + "_" + fetchOrder)<0) {
                AddChild(new PagingTestBase(testInfo, dbPageSize, cachePageSize, userPageSize, fetchOrder));
            }
        }


        public FuncFindVideos(bool sliceDice)
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindVideosFilter queryFilter = new FindVideosFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());
            
           foreach (TestCaseInfo testInfo in testCaseInfos)
            {

                if (testInfo.Name.Contains("P_Movies_DbCachePageing"))
                {

                    int cachePageSize = 5;
                    int dbPageSize = 0;
                    int userPageSize = 0;
                    for (int i = 1; i < 4; i++)
                    {
                        dbPageSize = cachePageSize * i;
                        for (int j = -2; j <= 0; j++)
                        {
                            userPageSize = dbPageSize + j;
                          
                            AddNewTest(testInfo, dbPageSize, cachePageSize, userPageSize, FETCH_ORDER.Random);
                            AddNewTest(testInfo, dbPageSize, cachePageSize, userPageSize, FETCH_ORDER.Ascending);
                            AddNewTest(testInfo, dbPageSize, cachePageSize, userPageSize, FETCH_ORDER.Decending);
                        }
                    }


                    for (int i = 1; i < 4; i++)
                    {
                        dbPageSize = cachePageSize * i;
                        for (int j = -2; j <= 0; j++)
                        {
                            userPageSize = cachePageSize + j;
                            AddNewTest(testInfo, dbPageSize, cachePageSize, userPageSize, FETCH_ORDER.Random);
                            AddNewTest(testInfo, dbPageSize, cachePageSize, userPageSize, FETCH_ORDER.Ascending);
                            AddNewTest(testInfo, dbPageSize, cachePageSize, userPageSize, FETCH_ORDER.Decending);
                        }
                    }
                }
            }
        }

        public FuncFindVideos()
        {
            
            //UpdateMedia();
            EditorialVisibility.VerifyVisibility("fecatalogdbxbox");


            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindVideosFilter queryFilter = new FindVideosFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());
            // add all test cases from the Test Case xml file
            foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                if (testInfo.Name.Contains("VIPChange_2Queries"))
                {
                    AddChild(new ConfigChangeTestBase(testInfo, false));
                    continue;
                }

                if (testInfo.Name.Contains("P_Movies_DbCachePageing")) {
                    continue;
                }

                if (testInfo.Name.Contains("QueryBeforeChange"))
                {
                    AddChild(new ConfigChangeTestBase(testInfo, true));
                    TestCaseInfo newTest = new TestCaseInfo(testInfo);
                    newTest.Name = "P_SerializeIndentityCall";

                    SerializeIndentityCallTestBase test1 = new SerializeIndentityCallTestBase(newTest, false);
                    AddChild(test1);
                    test1.TaggingData.AddTagValue("Frequency", "Full");
                    test1.TaggingData.AddTagValue("Requirement", "Manual");
                    test1.TaggingData.AddTagValue("Owner", "pefan");

                    TestCaseInfo newTest1 = new TestCaseInfo(testInfo);
                    newTest1.Name = "P_SerializeIndentityCall_FirstQueryFailed";

                    SerializeIndentityCallTestBase test = new SerializeIndentityCallTestBase(newTest1, true);
                    AddChild(test);  
                    test.TaggingData.AddTagValue("Frequency", "Full");
                    test.TaggingData.AddTagValue("Requirement", "Manual");
                    test.TaggingData.AddTagValue("Owner", "pefan");

                    continue;
                }
                if (!testInfo.Name.Contains("Editorial"))
                    AddChild(new FuncFindVideosTestBase(testInfo));
                else
                {
                    if(testInfo.Name.Contains("ByPassCache")) {
                        ArrayList list = new ArrayList();
                        AddChild(new EditorialTestBase(testInfo));
                    }
                    else {
                        ArrayList list = new ArrayList();                    
                        AddChild(new EditorialVisibilityTestBase(testInfo));
                    }
                }
           }
           
           
        }

        public static string BuildMediaIdString(Guid[] mediaIds)
        {

            string mediaIdsStr = "(";

            int i;

            for (i = 0; i < mediaIds.Length - 1; i++)
            {

                mediaIdsStr += "'" + mediaIds[i].ToString() + "', ";

            }

            mediaIdsStr += "'" + mediaIds[i].ToString() + "')";

            return mediaIdsStr;

        }


        static void UpdateMedia()
        {
 
            Guid[] MediaVisibility1 ={           
               new Guid("00020013-0002-0001-0113-000000000119"),
               new Guid("00020013-0002-0001-0113-000000000114"),
               new Guid("00020013-0002-0001-0113-000000000109"),
               new Guid("00020013-0002-0001-0113-000000000104"),
               new Guid("00020013-0002-0001-0113-000000000099")
           };

            Guid[] MediaVisibility2 ={           
               new Guid("00020013-0002-0001-0113-000000000100"),
               new Guid("00020013-0002-0001-0113-000000000105"),
               new Guid("00020013-0002-0001-0113-000000000110"),
               new Guid("00020013-0002-0001-0113-000000000115"),
               new Guid("00020013-0002-0001-0113-000000000120")
           };


            Guid[] MediaVisibility3 ={           
               new Guid("00020013-0002-0001-0113-000000000101"),
               new Guid("00020013-0002-0001-0113-000000000106"),
               new Guid("00020013-0002-0001-0113-000000000111"),
               new Guid("00020013-0002-0001-0113-000000000116"),
               new Guid("00020013-0002-0001-0113-000000000121")
           };

            Guid[] MediaVisibility4 ={           
               new Guid("00020013-0002-0001-0113-000000000102"),
               new Guid("00020013-0002-0001-0113-000000000107"),
               new Guid("00020013-0002-0001-0113-000000000112"),
               new Guid("00020013-0002-0001-0113-000000000117"),
               new Guid("00020013-0002-0001-0113-000000000122")
           };

            Guid[] MediaVisibility5 ={           
               new Guid("00020013-0002-0001-0113-000000000103"),
               new Guid("00020013-0002-0001-0113-000000000108"),
               new Guid("00020013-0002-0001-0113-000000000113"),
               new Guid("00020013-0002-0001-0113-000000000118"),
               new Guid("00020013-0002-0001-0113-000000000123")
           };

            Guid[] OfferVisibility1 ={           
               new Guid("00020013-0000-0050-0113-000000100099"),
               new Guid("00020013-0000-0050-0113-000000100100"),
               new Guid("00020013-0000-0050-0113-000000100101"),
               new Guid("00020013-0000-0050-0113-000000100102"),
               new Guid("00020013-0000-0050-0113-000000100103")
           };

            Guid[] OfferVisibility2 ={           
               new Guid("00020013-0000-0050-0113-000000100104"),
               new Guid("00020013-0000-0050-0113-000000100105"),
               new Guid("00020013-0000-0050-0113-000000100106"),
               new Guid("00020013-0000-0050-0113-000000100107"),
               new Guid("00020013-0000-0050-0113-000000100108")
           };


            Guid[] OfferVisibility3 ={           
               new Guid("00020013-0000-0050-0113-000000100109"),
               new Guid("00020013-0000-0050-0113-000000100110"),
               new Guid("00020013-0000-0050-0113-000000100111"),
               new Guid("00020013-0000-0050-0113-000000100112"),
               new Guid("00020013-0000-0050-0113-000000100113")
           };

            Guid[] OfferVisibility4 ={           
               new Guid("00020013-0000-0050-0113-000000100114"),
               new Guid("00020013-0000-0050-0113-000000100115"),
               new Guid("00020013-0000-0050-0113-000000100116"),
               new Guid("00020013-0000-0050-0113-000000100117"),
               new Guid("00020013-0000-0050-0113-000000100118")
           };

            Guid[] OfferVisibility5 ={           
               new Guid("00020013-0000-0050-0113-000000100119"),
               new Guid("00020013-0000-0050-0113-000000100120"),
               new Guid("00020013-0000-0050-0113-000000100121"),
               new Guid("00020013-0000-0050-0113-000000100122"),
               new Guid("00020013-0000-0050-0113-000000100123")
           };

            UpdateMediaVisibilityStatusId("fecatalogdbxbox", MediaVisibility1, 1);
            UpdateMediaVisibilityStatusId("fecatalogdbxbox", MediaVisibility2, 2);
            UpdateMediaVisibilityStatusId("fecatalogdbxbox", MediaVisibility3, 3);
            UpdateMediaVisibilityStatusId("fecatalogdbxbox", MediaVisibility4, 4);
            UpdateMediaVisibilityStatusId("fecatalogdbxbox", MediaVisibility5, 5);

            UpdateOfferVisibilityStatusId("fecatalogdbxbox", OfferVisibility1, 1);
            UpdateOfferVisibilityStatusId("fecatalogdbxbox", OfferVisibility2, 2);
            UpdateOfferVisibilityStatusId("fecatalogdbxbox", OfferVisibility3, 3);
            UpdateOfferVisibilityStatusId("fecatalogdbxbox", OfferVisibility4, 4);
            UpdateOfferVisibilityStatusId("fecatalogdbxbox", OfferVisibility5, 5);
        }

        public static void UpdateMediaVisibilityStatusId(string interfaceName, Guid[] mediaId, int statusId)
        {               
                using (SqlConnection c = new SqlConnection(CatalogQueryTestSuite.FECatalogDBXboxConnectionString))
                {

                    c.Open();

                    using (SqlCommand cmd = c.CreateCommand())
                    {

                        cmd.CommandText = "update media set VisibilityStatusId=" + ((int)statusId).ToString() + " where mediaid in" + BuildMediaIdString(mediaId);

                        cmd.CommandType = System.Data.CommandType.Text;

                        Global.RO.Info("Executing: " + cmd.CommandText);

                        Global.RO.Info("Number of rows affected: " + cmd.ExecuteNonQuery());

                       
                        c.Close();
                    }
                }

        }



        public static void UpdateOfferVisibilityStatusId(string interfaceName, Guid[] providerTermId, int statusId)
        {

                              
                using (SqlConnection c = new SqlConnection(CatalogQueryTestSuite.FECatalogDBXboxConnectionString))
                {

                    c.Open();

                    using (SqlCommand cmd = c.CreateCommand())
                    {

                        cmd.CommandText = "update OfferInstanceProviderTerm set visibilityStatusId=" + ((int)statusId).ToString() + " where providerTermId in" + BuildMediaIdString(providerTermId);

                        cmd.CommandType = System.Data.CommandType.Text;

                        Global.RO.Info("Executing: " + cmd.CommandText);


                        Global.RO.Info("Number of rows affected: " + cmd.ExecuteNonQuery());

                        c.Close();

                    }

                }
        }

        public class EditorialVisibilityTestBase : FuncFindVideosTestBase
        {
            public EditorialVisibilityTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {

            }

            protected override void Verify()
            {

                if (!TestInfo.InputValues.ContainsKey("OfferEditorial"))
                    TestInfo.InputValues.Add("OfferEditorial", null);

                if (!TestInfo.InputValues.ContainsKey("MediaEditorial"))
                    TestInfo.InputValues.Add("MediaEditorial", null);


                //EditorialVisibility.VerifyVisibility("fecatalogdbxbox");

                base.Verify();
            }


           protected override void InnerExecute()
            {

                EditorialTestBase.EditorialClientIPUpdate();
                base.InnerExecute();
                EditorialTestBase.EditorialClientIPClear();
            }
        }


        public class PagingTestBase : FuncFindVideosTestBase
        {

            public int DbPageSize, CachePageSize, UserPageSize;
            FETCH_ORDER FetchOrder;
            int maxPageNumber;
            int totalItems;
            Catalog.Verifier.Message msg;
            Media[] ms;
            ArrayList mediaReducedTitles;

            static int oldDBPageSize= 500, oldCachePageSize=100;
            static bool retrievedPageSetting = false;
            ArrayList cachedEntries;

            public PagingTestBase(TestCaseInfo testInfo, int dbPageSize, int cachePageSize, int userPageSize, FETCH_ORDER fetchOrder)
                : base(testInfo)
            {
                this.DbPageSize = dbPageSize;
                this.CachePageSize = cachePageSize;
                this.UserPageSize = userPageSize;
                this.FetchOrder = fetchOrder;
                cachedEntries = new ArrayList();
                this.Name = "DbPageSize_" + dbPageSize + "CachePageSize_" + cachePageSize + "userPageSize_" + userPageSize + "_" + fetchOrder;
                maxPageNumber = 115/ userPageSize;
                testnames += this.Name + "|";
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindVideosFilter();
                MethodName = QueryRequestBase.QueryMethod.FindVideos;

                ArrayList lst = new ArrayList();
                lst.Add("250");
                TestInfo.InputValues["PageSize"] = lst;


                ArrayList lst1 = new ArrayList();
                lst1.Add("1");
                TestInfo.InputValues["PageNum"] = lst1;

                //get all items in one page
                // public ArrayList ReturnExpectedOutput(Hashtable TestCaseValues, out int totalItems, out Message msg, bool isOfferApi)
                ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, false);

                MediaObject[] mos;

                if (msArray != null)
                {
                    mos = (MediaObject[])msArray.ToArray(typeof(MediaObject));
                    ms = new Media[mos.Length];
                    mediaReducedTitles = new ArrayList();
                    mediaReducedTitles = new ArrayList();
                    for (int i = 0; i < mos.Length; i++)
                    {
                        //if (String.Equals(((ArrayList)TestInfo.InputValues["DetailView"])[0],"3"))
                        ((VideoObject)mos[i]).FilteronVideoInstance(DynManager.OfferTable.DataObjectMainTable,
                            TestInfo.InputValues["TitleFilters"] != null);
                        ms[i] = new Media(mos[i]);
                        mediaReducedTitles.Add(mos[i].XmlDocRoot.GetElementsByTagName("reducedTitle")[0].InnerText);
                    }
                }
                else {
                    Global.RO.Error("No any item returned from xml query");                 
                }

                Global.RO.Info("Restore the all reducedTitle"); 
   
                for (int i = 0; i < ms.Length; i++)
                    UpdateMediaReduceTitle( 0, i, i, true);
                //Clear Cache
                Global.RO.Info("Clear Cache");        
                Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog flush");

                UpdatePageSetting(true);
                
            }


            void UpdateAsBeingCached(int requestPageNo)
            {
                //get startEntry and endEntry in db which has being fetched.

                int startIndex, endIndex;

                
                //get items on user page, min value is 0
                startIndex = (requestPageNo-1) * UserPageSize;
                endIndex = startIndex + UserPageSize - 1;

                Global.RO.Info("Request page number: " + requestPageNo + " Indexs on same user page: " + startIndex + "-" + endIndex);
                //convert those to db page, start with 0
                int startDbPageNum = startIndex/DbPageSize;
                int endDbPageNum = endIndex /DbPageSize;
                //actually index on the same db page being fetach if never being cached               
                startIndex = startDbPageNum * DbPageSize;
                endIndex = startIndex + DbPageSize - 1;

                int lastIndex = endIndex < (totalItems - 1) ? endIndex : totalItems - 1;

                Global.RO.Info("Indexs on same db page: " + startIndex +"-" + endIndex);

                bool  notCacheDbPageBefore = false;
                for (int i = startIndex; i <= lastIndex; i++)
                {
                    if(cachedEntries.Contains(i)) continue;

                    notCacheDbPageBefore = true;
                    cachedEntries.Add(i);
                    // updat the title for that media                    
                }

                if (notCacheDbPageBefore)
                {
                    Global.RO.Info("Index on db page are new not being cached before:" + startIndex + "-" + lastIndex);
                    UpdateMediaReduceTitle( requestPageNo, startIndex, lastIndex, false);
                }
                
            }

            void RestoreChangedTitles()
            {
                //get startEntry and endEntry in db which has being fetched.

            }

            void Shutdonw() {
                UpdatePageSetting(false);
                Global.RO.Info("Restore all reduced title to its orignal");
                for (int i = 0; i < ms.Length; i++)
                    UpdateMediaReduceTitle(0, i, i, true);

            
            }
            protected override void InnerExecute()
            {
                int requestPageNo = 0;
                bool success = true;

                try
                {

                    for (int i = 0; i < maxPageNumber; i++)
                    {
                        switch (FetchOrder)
                        {
                            case FETCH_ORDER.Ascending:
                                requestPageNo = i;
                                break;

                            case FETCH_ORDER.Decending:
                                requestPageNo = maxPageNumber - i;
                                break;

                            case FETCH_ORDER.Random:
                                requestPageNo = live.common.RandomEx.GlobalRandGen.Next(0, maxPageNumber);
                                break;
                        }

                        if (requestPageNo == 0) continue;
                        ArrayList lst = new ArrayList();
                        lst.Add(requestPageNo.ToString());
                        TestInfo.InputValues["PageNum"] = lst;

                        ArrayList lst1 = new ArrayList();
                        lst1.Add(UserPageSize.ToString());
                        TestInfo.InputValues["PageSize"] = lst1;


                        List<StringPair> filterList = QueryFilter.BuildNameValuePairs(TestInfo.InputValues);
                        req = new GenericQueryRequest(MethodName, filterList);

                        Global.RO.Info("Query at " + DateTime.Now.ToLongTimeString() + "\r\nQuery String: " + req.GetRelativeUrl() + req.ToQueryString());

                        CatalogResponse resp = live.server.next.Catalog.SendRequest(WebClient, (GenericQueryRequest)req);

                        //Global.RO.Success("Response is: \n" + resp.Response);
                        Global.RO.Info("Response is received");

                        doc = new XmlDocument();
                        doc.LoadXml(resp.Response);

                        try
                        {
                            base.Verify();
 
                        }
                        catch (Exception e)
                        {
                            Global.RO.Success("Response is: \n" + resp.Response);
                            Global.RO.Info("");

                            Global.RO.Error("Verify failed on request PageNumber = " + requestPageNo + e.Message + "\r\n " + e.StackTrace);
                            Global.RO.Info(" contine with next page number ");
                            success = false;
                        }
                        finally
                        {
                            UpdateAsBeingCached(requestPageNo);
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Verify failed on request PageNumber = " + requestPageNo +  "\r\n " + e.Message + "\r\n " + e.StackTrace);
                    success = false;
                }
                finally {
                    Shutdonw();
                    if (success)
                        Global.RO.Success("Verification Success!");
                    else
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        throw new UnexpectedTestResultException("");

                    }                    
                
                }
            }


            public static string BuildGuidString(ArrayList ids)
            {
                string mediaIdsStr = "(";
                int i;
                for (i = 0; i < ids.Count -1; i++)
                {
                    mediaIdsStr += "'" + ids[i].ToString() + "', ";
                }
                mediaIdsStr += "'" + ids[i].ToString() + "')";
                return mediaIdsStr;
            }



            public  void UpdateMediaReduceTitle(int requestPageNum, int startIndex, int endIndex, bool restore)
            {

                //string interfaceName = store == StoreTypeEnum.Zune ? fecatalogdbzune : fecatalogdbxbox;
                
                string added="";

                if(!restore)
                    added = "[" + DateTime.Now.ToLongTimeString().Trim() + " P:" + requestPageNum + " S:" + startIndex + " E:" + endIndex;


                ArrayList mediaList = new ArrayList();
                for (int i = startIndex; i <= endIndex; i++)
                    mediaList.Add(this.ms[i].mediaId);

                if (mediaList.Count > 0)
                {

                    using (SqlConnection c = new SqlConnection(CatalogQueryTestSuite.FECatalogDBXboxConnectionString))
                    {

                        c.Open();

                        using (SqlCommand cmd = c.CreateCommand())
                        {
                            try
                            {
                                if (!restore)
                                    cmd.CommandText = "update mediaLocale set reducedTitle= reducedTitle+ '" + added + "' where lcid = 1033 and mediaId in" + BuildGuidString(mediaList);
                                else
                                    cmd.CommandText = "update mediaLocale set reducedTitle= '" + (string)mediaReducedTitles[startIndex] + "' where lcid = 1033 and mediaId in" + BuildGuidString(mediaList);

                                cmd.CommandType = System.Data.CommandType.Text;

                                if (!restore)
                                {
                                    Global.RO.Info("Executing: " + cmd.CommandText);

                                }

                                int numrows = cmd.ExecuteNonQuery();

                                if (!restore)
                                    Global.RO.Info("Number of rows affected: " + numrows);
                                c.Close();
                            }
                            catch (Exception e)
                            {
                                Global.RO.Error("UpdateMediaReduceTitle failed with " + e.Message);
                                c.Close();
                                throw e;
                            }
                        }
                    }
                }
            }


            void UpdatePageSetting(bool update)
            {
                int curCachPageSize;
                int curDbPageSize;
                try
                {

                    using (SqlClient client = new SqlClient("npdb"))
                    {
                        if (retrievedPageSetting == false)
                        {
                            //read old value before any test starting update thoese values

    
                            client.Command.CommandText =
                            String.Format("select i_cache_page_size, i_db_page_size  from t_fse_methods where vc_method_name='{0}'", this.MethodName);

                            SqlDataReader reader = client.Command.ExecuteReader();
                            while (reader.Read())
                            {
                                oldCachePageSize = reader.GetInt32(0);
                                oldDBPageSize = reader.GetInt32(1);
                            }
                            reader.Close();
                            Global.RO.Info("Original pageing value: i_cache_page_size: {0}  i_db_page_size:{1}", oldCachePageSize, oldDBPageSize);
                            retrievedPageSetting = true;
                        }
                    }

                    if (update)
                    {
                        curCachPageSize = CachePageSize;
                        curDbPageSize = DbPageSize;
                        Global.RO.Info("Set Paging Size for {0} to test paging size ", this.MethodName);
                    }
                    else
                    {
                        curDbPageSize = oldDBPageSize;
                        curCachPageSize = oldCachePageSize;
                        Global.RO.Info("Restore Paging Size for {0} to before test's value ", this.MethodName);

                    }

                    using (SqlClient client = new SqlClient("npdb"))
                    {
                        // update the value
                        client.Command.CommandText =
                        String.Format("update t_fse_methods set i_cache_page_size={0}, i_db_page_size  = {1}, i_max_page_size = {1} where vc_method_name='{2}'", curCachPageSize, curDbPageSize, this.MethodName);
                        Global.RO.Info(client.Command.CommandText);
                        client.ExecuteNonQuery();

                        Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.catalog, "e :catalog reload");
                        Global.RO.Info("wait 1 min for configure change");
                        Thread.Sleep(120000);
                    }
                }

                catch (Exception e)
                {
                    throw e;
                }
            }
        }


        public class FuncFindVideosTestBase : QueryTestBase
        {
            public FuncFindVideosTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindVideosFilter();
                MethodName = QueryRequestBase.QueryMethod.FindVideos;
            }


            protected override void Verify()
            {
                base.Verify();

                Media[] ms;
                Message msg;
                int totalItems;


                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, false);
                    //Global.RO.Info(msg.info);
                    MediaObject[] mos;

                    if (msArray != null)
                    {
                        mos = (MediaObject[])msArray.ToArray(typeof(MediaObject));
                        ms = new Media[mos.Length];
                        for (int i = 0; i < mos.Length; i++)
                        {
                           //if (String.Equals(((ArrayList)TestInfo.InputValues["DetailView"])[0],"3"))
                                ((VideoObject)mos[i]).FilteronVideoInstance(DynManager.OfferTable.DataObjectMainTable,
                                    TestInfo.InputValues["TitleFilters"] != null);
                            ms[i] = new Media(mos[i]);
                            
                            // add TotalOfferCount to the outputTbl. The OutputTbl from MediaObject is always null
                            //ms[i].outputTbl = new Hashtable();
                            if (!(((VideoObject)mos[i]).MediaType == 2 && ((VideoObject)mos[i]).VideoOfferCount == 0))
                            {
                                ms[i].outputTbl["media/seriesoffercount"] = ((VideoObject)mos[i]).TotalSeriesOffer;
                                ms[i].outputTbl["media/seasonoffercount"] = ((VideoObject)mos[i]).TotalSeasonOffers;
                                ms[i].outputTbl["media/videooffercount"] = ((VideoObject)mos[i]).VideoOfferCount;
                            }

                            ms[i].outputTbl.Add("previewImage", QueryTestBase.GetComplexObject.PreviewImages(mos[i].MediaId, CatVerify.GetLocaleId(TestInfo)));
                        }
                    }
                    else ms = null;
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMedia(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }                
           
                bool success = CatVerify.FindVideos(doc, totalItems, ms, this.TestInfo, out msg);
                
                if (!success)
                {
                    PrintInfo(msg.info);
                    throw new UnexpectedTestResultException("Verification failed.");
                }
            }
        }
    }

    //[TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("Catalog")]
    /* this group of test cases will change db_page_size in uodb and since max_page_size is affected by db_page_size, other users doing findvideo query might have page_size greater than 
     the db_page_size set by the tests and their queries would fail,  and running these tests take time. So sugguest to run them  on a xblob. */
    public class SlicingDicing : FuncFindVideos
    {
        public SlicingDicing():base(true)
        {
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncGameOffers.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using live.common;
using live.common.next;
using live.client;
using live.protocol.next;
using live.server;
using System.Xml;

namespace CatalogTests
{
    [TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class FuncFindGameOffers : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindGameOffersTestCases.xml";

        public FuncFindGameOffers()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindGameOffersFilter queryFilter = new FindGameOffersFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                TestNode node = new FuncFindGameOffersTestBase(testInfo);
                node.TaggingData.AddTagValue("Frequency", "Full");
                node.TaggingData.AddTagValue("Owner", "wirosas");
                node.TaggingData.AddTagValue("Priority", testInfo.Priority);
                AddChild(node);
            }
        }

        public class FuncFindGameOffersTestBase : QueryTestBase
        {
            public FuncFindGameOffersTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindGameOffersFilter();
                MethodName = QueryRequestBase.QueryMethod.FindGameOffers;
            }

            protected override void Execute()
            {
                base.Execute();

                // for any tests that do not bypass Xbanc, run the query twice to make sure the cache returns the same result
                Global.RO.Warn("The same request is called the second time to verify cache.");
                if (!bypassXbanc)
                    base.Execute();
            }

            protected override void Verify()
            {
                base.Verify();

                MediaOffer[] ms;
                Message msg;
                int totalItems;

                // using the DynamicOutput
                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, true);
                    //Global.RO.Info(msg.info);
                    OfferMediaObject[] mos = (OfferMediaObject[])msArray.ToArray(typeof(OfferMediaObject));
                    ms = new MediaOffer[mos.Length];
                    for (int i = 0; i < mos.Length; i++)
                    {
                        ms[i] = new MediaOffer(mos[i]);
                        mos[i].FilteronOfferInstance(DynManager.OfferTable.DataObjectMainTable);    
                    }
                    Global.RO.Info(msg.info);
                    msg.info = "";
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMediaOffers(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }

                if (!String.IsNullOrEmpty(TestInfo.OfferTestDataFile))
                {
                    // load the test data file
                    string testDataFile = System.IO.Path.Combine(InjectionFilePath, TestInfo.OfferTestDataFile);
                    XmlDocument testDataDoc = new XmlDocument();
                    testDataDoc.Load(testDataFile);

                    List<string> offerIds = new List<string>();
                    foreach (MediaOffer o in ms)
                    {
                        offerIds.Add(o.offerId.ToString());
                    }
                    List<uint> userTypes = new List<uint>();
                    foreach (string s in CatVerify.GetUserTypes(TestInfo))
                    {
                        userTypes.Add(Convert.ToUInt32(s));
                    }

                    // the expected Xml (loaded from test data offer file)
                    FeedResult testDataXml = new FeedResult();
                    testDataXml.LoadFromTestDataOfferFile(testDataDoc.DocumentElement, CatVerify.GetStore(TestInfo), CatVerify.GetLocaleId(TestInfo),
                        CatVerify.GetCountryCode(TestInfo), userTypes, offerIds, (uint)CatVerify.GetDetailView(TestInfo));
                    Global.RO.Warn("Expected xml:");
                    Global.RO.Info(testDataXml.GetDocument().OuterXml);

                    // the xml returned from catalog API call
                    CatalogResultHandler handler = new CatalogResultHandler();
                    FeedResult respXml = handler.Create(doc);

                    // compare the two xml, one is from the test data offer file and the other is from API response
                    bool ret = respXml.Equals(testDataXml, (uint)CatVerify.GetDetailView(TestInfo));
                    if (!ret)
                        throw new UnexpectedTestResultException("Verification failed.");
                    return;
                }

                bool success = CatVerify.FindGameOffers(doc, totalItems, ms, this.TestInfo, out msg);
                //Global.RO.Info(msg.info);
                PrintInfo(msg.info);
                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncFindVideoOffers.cs ===
using System;
using System.Collections;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;

using live.client;
using live.common.next;
using live.protocol.next;
using live.server;

namespace CatalogTests
{
    //[TestGroup, Owner("wirosas"), TestFrequency("Regression"), EnvRequirement("Catalog")]
    public class FuncFindVideoOffers : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindVideoOffersTestCases.xml";

        public FuncFindVideoOffers()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindVideoOffersFilter queryFilter = new FindVideoOffersFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                if (!testInfo.Name.Contains("Editorial"))
                    AddChild(new FuncFindVideoOffersTestBase(testInfo));
                else
                {                    
                     ArrayList list = new ArrayList();
                     AddChild(new EditorialVisibilityTestBase(testInfo));
                }
            }

            EditorialVisibility.UpdateOfferExpireDate("fecatalogdbxbox");
        }

        public class EditorialVisibilityTestBase : FuncFindVideoOffersTestBase
        {
            public EditorialVisibilityTestBase(TestCaseInfo testInfo)
                : base(testInfo)
            {

            }

            protected override void Verify()
            {

                if (!TestInfo.InputValues.ContainsKey("OfferEditorial"))
                    TestInfo.InputValues.Add("OfferEditorial", null);

                if (!TestInfo.InputValues.ContainsKey("MediaEditorial"))
                    TestInfo.InputValues.Add("MediaEditorial", null);


                //EditorialVisibility.VerifyVisibility("fecatalogdbxbox");

                base.Verify();
            }


            protected override void InnerExecute()
            {

                EditorialTestBase.EditorialClientIPUpdate();
                base.InnerExecute();
                EditorialTestBase.EditorialClientIPClear();
            }
        }

        public class FuncFindVideoOffersTestBase : QueryTestBase
        {
            public FuncFindVideoOffersTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            
            
            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindVideoOffersFilter();
                MethodName = QueryRequestBase.QueryMethod.FindVideoOffers;                
                
            }

            protected override void Verify()
            {
                base.Verify();

                MediaOffer[] ms;
                Message msg;
                int totalItems;

                // using the DynamicOutput
                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, true);
                    Global.RO.Info(msg.info);
                    msg.info = "";
                    OfferMediaObject[] mos = (OfferMediaObject[])msArray.ToArray(typeof(OfferMediaObject));
                    ms = new MediaOffer[mos.Length];
                    for (int i = 0; i < mos.Length; i++)
                    {
                        ms[i] = new MediaOffer(mos[i]);
                        mos[i].FilteronOfferInstance(DynManager.OfferTable.DataObjectMainTable);                        
                    }
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMediaOffers(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }

                bool success = CatVerify.FindVideoOffers(doc, totalItems, ms, this.TestInfo, out msg);
                PrintInfo(msg.info);
                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncMediaOffers.cs ===
using System;
using System.Collections;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using live.common;
using live.common.next;
using live.client;
using live.protocol.next;
using live.server;
using System.Xml;

namespace CatalogTests
{
    [TestGroup]
    public class FuncFindMediaOffers : CatalogTestBaseGroup
    {
        private static string TestCaseXmlFile = "FindMediaOffersTestCases.xml";

        public FuncFindMediaOffers()
        {
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, TestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            FindMediaOffersFilter queryFilter = new FindMediaOffersFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(queryFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            //LSG4943
            /*
            foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncFindMediaOffersTestBase(testInfo));
            }*/
        }

        public class FuncFindMediaOffersTestBase : QueryTestBase
        {
            public FuncFindMediaOffersTestBase(TestCaseInfo testInfo)
                :base(testInfo)
            {
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new FindMediaOffersFilter();
                MethodName = QueryRequestBase.QueryMethod.FindMediaOffers;
            }

            protected override void Verify()
            {
                base.Verify();

                MediaOffer[] ms;
                Message msg;
                int totalItems;

                // using the DynamicOutput
                if (TestInfo.ExpectedItems == null)
                {
                    ArrayList msArray = DynManager.ReturnExpectedOutput(TestInfo.InputValues, out totalItems, out msg, true);
                    Global.RO.Info(msg.info);
                    OfferMediaObject[] mos = (OfferMediaObject[])msArray.ToArray(typeof(OfferMediaObject));
                    ms = new MediaOffer[mos.Length];
                    for (int i = 0; i < mos.Length; i++)
                    {
                        ms[i] = new MediaOffer(mos[i]);
                        // add TotalOfferCount to the outputTbl. The OutputTbl from MediaObject is always null
                        ms[i].outputTbl = new Hashtable();
                        ms[i].outputTbl["totaloffercount"] = mos[i].MediaObj.TotalOfferCount;
                    }
                }
                // the expected outputs from test case xml files
                else
                {
                    ms = CatVerify.GetExpectedMediaOffers(TestInfo.ExpectedItems);
                    totalItems = (int)TestInfo.TotalCount;
                }

                bool success = CatVerify.FindMediaOffers(doc, totalItems, ms, this.TestInfo, out msg);
                Global.RO.Info(msg.info);
                if (!success)
                    throw new UnexpectedTestResultException("Verification failed.");
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\FuncPodcasting.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using Catalog.TestCaseXmlParser;
using live.common.next;
using live.protocol.next;
using System.Xml;
using xonline.common.config;
using xonline.common.sql.sqlclient;
using System.Collections;
using System.Data.SqlClient;
using xonline.common.service;

namespace CatalogTests
{
    [TestGroup]
    class FuncPodcasting : CatalogTestBaseGroup
    {
        private static readonly String SubmissionsDB = "SubmissionsDB";
        private static string ReportConcernTestCaseXmlFile = "ReportConcernTestCases.xml";
        private static string SubmitPodcastTestCaseXmlFile = "SubmitPodcastTestCases.xml";

        /* the setting changes are not needed since the ReportConcern and SubmitPodcast are not cached at all
        private String[] methodNames = new String[] { "ReportConcern", "SubmitPodcast" };
        private Int32[] cacheDurValues = new Int32[2];

        [TestGroupSetup]
        public void Setup()
        {
            using (SqlClient client = new SqlClient("npdb"))
            {
                client.Command.CommandText = "Select i_cache_duration from t_fse_methods where vc_method_name=@methodName";

                for (int i = 0; i < methodNames.Length; i++)
                {
                    client.ClearParameters();
                    client.AddParameter("@methodName", methodNames[i]);
                    cacheDurValues[i] = (Int32)client.ExecuteScalar();
                }

                UpdateCacheDurations(new Int32[] { 0, 0 });
            }
        }

        [TestGroupTearDown]
        public override void Cleanup()
        {
            UpdateCacheDurations(cacheDurValues);
        }

        private void UpdateCacheDurations(Int32[] cacheDurations)
        {
            using (SqlClient client = new SqlClient("npdb"))
            {
                client.Command.CommandText = "Update t_fse_methods set i_cache_duration=@cacheDur where vc_method_name=@methodName";

                for (int i = 0; i < methodNames.Length; i++)
                {
                    client.ClearParameters();

                    client.AddParameter("@cacheDur", cacheDurations[i]);
                    client.AddParameter("@methodName", methodNames[i]);

                    client.ExecuteNonQuery();
                }

                // Reload the setting values
                Global.XEnv.ExecuteXmgmtCommand(Interface.catalog, "e :catalog reload");
            }
        }
    */
        public FuncPodcasting()
        {
            // Add all Report Concern Test Cases
            string testCaseFile = System.IO.Path.Combine(TestCaseFilePath, ReportConcernTestCaseXmlFile);
            TestCaseParser testCaseParser = new TestCaseParser(testCaseFile);
            ReportConcernFilter reportFilter = new ReportConcernFilter();
            TestCaseInfo[] testCaseInfos = testCaseParser.GetAllTestCases(reportFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            //LSG4930
            /*foreach(TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncReportConcernTestBase(testInfo));
            }*/

            // Add all Submit Podcast Test Cases
            testCaseFile = System.IO.Path.Combine(TestCaseFilePath, SubmitPodcastTestCaseXmlFile);
            testCaseParser = new TestCaseParser(testCaseFile);
            SubmitPodcastFilter submitFilter = new SubmitPodcastFilter();
            testCaseInfos = testCaseParser.GetAllTestCases(submitFilter.GetInputParamNames());

            // add all test cases from the Test Case xml file
            //LSG4930
            /*foreach (TestCaseInfo testInfo in testCaseInfos)
            {
                Add(new FuncSubmitPodcastTestBase(testInfo));
            }*/
        }

        public class FuncReportConcernTestBase : QueryTestBase
        {
            private Guid mediaId;
            private String concernText;

            public FuncReportConcernTestBase(TestCaseInfo testInfo)
                : base(testInfo)
            {
                ArrayList mediaIdList = ((ArrayList)testInfo.InputValues["MediaId"]);
                ArrayList concernTextList = ((ArrayList)testInfo.InputValues["ConcernText"]);

                if (mediaIdList != null)
                {
                    String mid = mediaIdList[0].ToString();
                    try
                    {
                        mediaId = new Guid(mid);
                    }
                    catch(FormatException)
                    {
                        mediaId = Guid.Empty;
                        // This means that we are running a test with an invalid
                        // guid so we don't need to parse this
                    }

                }
                else
                {
                    mediaId = Guid.Empty;
                }

                if (concernTextList != null)
                {
                    concernText = concernTextList[0].ToString();

                    if (concernText.Length > 512)
                    {
                        // The max length accepted should be 512 so we're just going to truncate the string
                        concernText = concernText.Substring(0, 512);
                    }
                }
                else
                {
                    concernText = null;
                }
            }
                       

            protected override void Init()
            {
                base.Init();
                QueryFilter = new ReportConcernFilter();
                MethodName = QueryRequestBase.QueryMethod.ReportConcern;

                DeleteConcern();
            }

            // Nother is returned so we really just want to insure that the 
            // error code is 0.
            protected override void Verify()
            {
                base.Verify();

                try
                {
                    XmlNode sqlCode = doc.SelectSingleNode("/Results/SqlCode/text()");

                    if (sqlCode == null || sqlCode.Value != "0")
                    {
                        throw new UnexpectedTestResultException("SqlCode returned by query was not 0");
                    }
                    else
                    {
                        using (SqlClient client = new SqlClient(FuncPodcasting.SubmissionsDB))
                        {
                            client.Command.CommandText = "select * from MediaConcern where mediaId=@mid and concernText=@txt";
                            client.AddParameter("@mid", mediaId);
                            client.AddParameter("@txt", concernText);

                            // Since we previously deleted all the rows with this Media ID and text, if any 
                            // rows are returned we can assume that we added them.
                            SqlDataReader reader = client.Execute();

                            if (!reader.HasRows)
                            {
                                throw new UnexpectedTestResultException("Unable to find submitted concern in database");
                            }
                        }
                        Global.RO.Success("No error codes returned and data successfully added");
                    }
                }
                finally
                {
                    // Remove the test concern from the database
                    DeleteConcern();
                }
            }

            private void DeleteConcern()
            {
                if (mediaId != Guid.Empty && concernText != null)
                {
                    // Delete any existing data that matches the test data
                    using (SqlClient client = new SqlClient(FuncPodcasting.SubmissionsDB))
                    {
                        client.Command.CommandText = "delete from MediaConcern where mediaId=@mid and concernText=@txt";
                        client.AddParameter("@mid", mediaId);
                        client.AddParameter("@txt", concernText);

                        client.ExecuteNonQuery();
                    }
                }
            }
        }

        public class FuncSubmitPodcastTestBase : QueryTestBase
        {
            private readonly Int32 MAX_URL_LENGTH = 1024;
            private String podcastUrl = null;

            public FuncSubmitPodcastTestBase(TestCaseInfo testInfo)
                : base(testInfo)
            {
                ArrayList url = (ArrayList)testInfo.InputValues["PodcastUrl"];

                if (url != null)
                {
                    // Trim the length to the supposed max
                    podcastUrl = url[0].ToString();

                    if (podcastUrl.Length > MAX_URL_LENGTH)
                    {
                        podcastUrl = podcastUrl.Substring(0, MAX_URL_LENGTH);
                    }
                }
            }

            protected override void Init()
            {
                base.Init();
                QueryFilter = new SubmitPodcastFilter();
                MethodName = QueryRequestBase.QueryMethod.SubmitPodcast;

                DeletePodcast();
            }

            protected override void Verify()
            {
                base.Verify();

                try
                {
                    using(SqlClient client = new SqlClient(FuncPodcasting.SubmissionsDB))
                    {
                        client.Command.CommandText = "select * from PodcastPing where podcastUrl=@url";

                        client.AddParameter("@url", podcastUrl);

                        if (!client.Execute().HasRows)
                        {
                            throw new UnexpectedTestResultException("Unable to find inserted podcast url in database");
                        }
                    }
                }
                finally
                {
                    DeletePodcast();
                }
            }

            /// <summary>
            /// Deletes the podcast url from the database
            /// </summary>
            private void DeletePodcast()
            {
                if(podcastUrl != null)
                {
                    using (SqlClient client = new SqlClient(FuncPodcasting.SubmissionsDB))
                    {
                        client.Command.CommandText = "delete from podcastping where podcasturl=@url";

                        client.AddParameter("@url", podcastUrl);

                        client.ExecuteNonQuery();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\catalog\test\StressTestCases.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Data.SqlClient;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.protocol;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;

using Catalog.TestCaseXmlParser;
using Catalog;
using Catalog.Verifier;
using CatalogTests;
using Catalog.DynamicOutput;

using live.client;
using live.common;
using live.common.next;
using live.protocol.next;
using live.server.next;

using XeXbos;

namespace CatalogTests
{
    /*/// <summary>
    /// DownloadHistory stress test
    /// </summary>
    /// 
    [StressTest, Ignore]
    public class StressDownloadHistory : HistoryStressTestBase
    {
        public StressDownloadHistory()
        {
            Setup();
        }

        protected override void Setup()
        {
            base.Setup();

            // create a user
            User = UserHelper.CreateUser(XenonClient, UserHelper.UserType.Silver, CountryId.US);

            // add usage data
            string[] mediaInstanceIds = new string[] { "23020000-0900-11DB-89CA-0019B92A3933", "23020000-0B00-11DB-89CA-0019B92A3933", "2B520200-0B00-11DB-89CA-0019B92A3933" };

            int[] mediaTypes = new int[] { 25, 25, 25 };
            int[] values = new int[] { 4, 2, 3 };
            UsageStoreHelper.GetXml(User.Puid, mediaInstanceIds, mediaTypes, values);
        }

        protected override void Init()
        {
            base.Init();

            // prepare the web request
            if (string.IsNullOrEmpty(CustomQuery))
            {
                DownloadHistoryFilter filter = new DownloadHistoryFilter();
                filter.Locale = "en-US";   // US only 
                filter.LegalLocale = "en-US";
                filter.Store = 1;  // not used
                filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50 }, new uint[] { 70, 30 });
                filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 70, 30 });
                filter.DetailView = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 50, 50 });
                filter.MediaTypes = new List<int>();
                filter.MediaTypes.Add(25);  // Track
                filter.MediaTypes.Add(26);  // Album
                filter.MediaTypes.Add(27);  // AlbumDisc
                filter.MediaTypes.Add(29);  // Music
                filter.MediaTypes.Add(32);  // PlayList
                filter.Actions = new List<int>();
                filter.Actions.Add(2);  // download count
                filter.OrderBy = 0; // 0 - date
                filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 50, 50 });

                List<StringPair> filterList = filter.ToList();
                req = new DownloadHistoryWebRequest(User.Puid, WebClient.MachinePuid, filterList);
            }
            else
            {
                req = new CustomWebRequest(BillingWebRequest.HISTORY_BASE_URL, BillingWebRequest.BillingOperation.Query, CustomQuery);
            }
        }
    }*/

    /// <summary>
    /// FindCategories stress test
    /// </summary>
    [StressTest(Priority = 100)]
    public class StressFindCategories : QueryStressTestBase
    {
        private const string FeCatalogDBXbox = "FeCatalogDBXbox";
        private Hashtable CategoryIdList = null;


        public static List<T> GetList<T>(T[] values)
        {
            // Determine the size of the array we should use
            int count = values.Length;
            List<T> list = new List<T>();

            for (int i = 0; i <count; i++)
            {

                list.Add(values[i]);
            }
            return list;
        }



        private static readonly int[] CategorySystemId = {
            1000,    // Video
            //2000,    // Music
            //3000,    // Game
            //4000,    // Publishers
            5000,    // PodCast
            //6000,    // Developers
            7000,    // Networks
            8000,    // Studios
            //9000,    // Playlist
            //10000,  // Test
            //4000000,   // Music Labels
        };

        public StressFindCategories()
        {
            int count = 0;
            CategoryIdList = new Hashtable();
            for (int i = 0; i < CategorySystemId.Length; i++)
            {
                CategoryIdList.Add(CategorySystemId[i], GetCategroyIdsFromDB(CategorySystemId[i]));
                count += ((List<int>)CategoryIdList[CategorySystemId[i]]).Count;
            }
            Global.RO.Success("Load category ids from DB done! Total: " + count);
        }

#region CategoryList
        static int[] List7000 = new int[]{
         7001,
         7002,
         7003,
         7004,
         7005,
         7006,
         7007,
         7008,
         7009,
         7010,
         7011,
         7012,
         7013,
         7014,
         7015,
         7016,
         7017,
         7018,
         7019,
         7020,
         7021,
         7022,
         7023,
         7024,
         7025,
         7026,
         7027,
         7028,
         7029,
         7030
        };

        static int[] List8000 = new int[]{
         8001,
         8002,
         8003,
         8004,
         8005,
         8006,
         8007,
         8008,
         8009,
         8010,
         8011,
         8012,
         8013,
         8014,
         8015,
         8016,
         8017,
         8018,
         8019,
         8020,
         8021,
         8022,
         8023,
         8024,
         8025,
         8026,
         8027,
         8028,
         8029,
         8030,
         8031,
         8032,
         8033,
         8034,
         8035,
         8036,
         8037,
         8038,
         8039,
         8040,
         8041,
         8042,
         8043,
         8044,
         8045,
         8046,
         8047,
         8048,
         8049,
         8050,
         8051,
         8052,
         8053,
         8054,
         8055,
         8056,
         8057,
         8058,
         8059,
         8060,
         8061,
         8062,
         8063,
         8064,
         8065,
         8066,
         8067,
         8068,
         8069,
         8070
        };

        static int[] List5000 = new int[]{
                     5001,
         5002,
         5003,
         5004,
         5005,
         5006,
         5007,
         5008,
         5009,
         5010,
         5011,
         5012,
         5013,
         5014,
         5015,
         5100,
         5101,
         5102,
         5103,
         5104,
         5105,
         5106,
         5150,
         5151,
         5152,
         5153,
         5154,
         5155,
         5200,
         5201,
         5202,
         5203,
         5204,
         5205,
         5250,
         5251,
         5252,
         5253,
         5254,
         5255,
         5300,
         5301,
         5302,
         5303,
         5304,
         5305,
         5306,
         5350,
         5351,
         5352,
         5353,
         5354,
         5355,
         5356,
         5357,
         5400,
         5401,
         5402,
         5403,
         5404,
         5405,
         5406,
         5450,
         5451,
         5452,
         5453,
         5454,
         5500,
         5501,
         5502,
         5503,
         5504,
         5505,
         5506,
         5507,
         5508,
         5509,
         5510,
         5511,
         5512,
         5513,
         5514,
         5515,
         5550,
         5551,
         5552,
         5553,
         5554,
         5600,
         5601,
         5602,
         5603,
         5604,
         5605,
         5606,
         5650,
         5651,
         5652,
         5653,
         5654,
         5655,
         5656,
         5700,
         5701,
         5702,
         5703,
         5704,
         5705,
         5706,
         5707,
         5708,
         5709,
         5750,
         5751,
         5752,
         5753,
         5754,
         5756
        };

        static int[] List10000 = new int[]{
         10001,
         10002,
         10003,
         10004,
         10005,
         10101,
         10102,
         10103,
         10104,
         10105,
         10200,
         10201,
         10202,
         10203,
         10204,
         10205,
         10301,
         10302,
         10303,
         10304,
         10305,
         10401,
         10402,
         10403,
         10404,
         10405,
         10406,
         10407,
         10408,
         10409,
         10410,
         10411,
         10412,
         10413,
         10414,
         10415,
         10501,
         10502,
         10503,
         10504,
         10505
        };
        static int [] List1000 =  new int[]{
         1001,
         1002,
         1003,
         1004,
         1005,
         1006,
         1007,
         1008,
         1009,
         1010,
         1011,
         1012,
         1013,
         1101,
         1102,
         1103,
         1104,
         1105,
         1106,
         1107,
         1108,
         1109,
         1110,
         1111,
         1112,
         1113,
         1114,
         1115,
         1116,
         1121,
         1122,
         1123,
         1124,
         1125,
         1126,
         1127,
         1141,
         1142,
         1143,
         1144,
         1145,
         1146,
         1147,
         1161,
         1163,
         1164,
         1165,
         1166,
         1167,
         1168,
         1169,
         1170,
         1201,
         1202,
         1204,
         1205,
         1206,
         1207,
         1208,
         1209,
         1210,
         1211,
         1212,
         1213,
         1214,
         1215,
         1216,
         1217,
         1218,
         1219,
         1220,
         1221,
         1222,
         1223,
         1224,
         1225,
         1226,
         1227,
         1228,
         1229,
         1230,
         1231,
         1232,
         1233,
         1234,
         1235,
         1236,
         1237,
         1238,
         1239,
         1240,
         1241,
         1242,
         1243,
         1244,
         1245,
         1246,
         1247,
         1261,
         1262,
         1263,
         1264,
         1265,
         1266,
         1267,
         1268,
         1281,
         1282,
         1283,
         1284,
         1285,
         1286,
         1287,
         1288,
         1289,
         1290,
         1291,
         1292,
         1293,
         1294,
         1295,
         1301,
         1302,
         1303,
         1304,
         1305,
         1306,
         1307};
#endregion

        static List<int> CatList1000 =GetList<int>(List1000);
        static List<int> CatList7000=GetList<int>(List7000);
        static List<int> CatList8000=GetList<int>(List8000);
        static List<int> CatList5000=GetList<int>(List5000);
        //static List<int> CatList10000=GetList<int>(List10000);


        private static  List<int> GetCategroyIdsFromDB(int systemId) {
            switch (systemId) {
                case 1000: return CatList1000;

                case 5000:
                    return CatList5000;

                case 7000:
                    return CatList7000;


                case 8000:
                    return CatList8000;

                //case 10000:
                    //return CatList10000;

            }
            return null;
        }


        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindCategories;
            FindCategoriesFilter filter = new FindCategoriesFilter();
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US",  "fr-FR"}, new uint[] { 95, 5 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 1;  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50, 100 }, new uint[] { 90, 5, 5 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 95, 5 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 1, 5 }, new uint[] { 10, 90 });
            filter.OfferFilterLevel = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });
            filter.CategorySystemId = StressHelper.GetInputValue(CategorySystemId, new uint[] {80, 10, 5, 1 });
            int[] cateIdsForSystem = ((List<int>)CategoryIdList[filter.CategorySystemId]).ToArray();
            filter.CategoryIds = StressHelper.GetInputValue(cateIdsForSystem, new uint[] { 1, 2, 5 }, new uint[] { 80, 20, 1 }); // 0 - 64
            filter.OrderBy = StressHelper.GetInputValue(new int[] { 11, 12 }, new uint[] { 80, 20 });
            //     -- orderBy supports
            //    --  11 = categoryName
            //    --  12 = categoryId
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 99, 1 });

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }


    [StressTest(Priority = 100)]
    public class StressFindCategories_2700 : QueryStressTestBase
    {
        private const string FeCatalogDBXbox = "FeCatalogDBXbox";
        private Hashtable CategoryIdList = null;


        public static List<T> GetList<T>(T[] values)
        {
            // Determine the size of the array we should use
            int count = values.Length;
            List<T> list = new List<T>();

            for (int i = 0; i < count; i++)
            {

                list.Add(values[i]);
            }
            return list;
        }



        private static readonly int[] CategorySystemId = {
            1000,    // Video
            //2000,    // Music
            //3000,    // Game
            //4000,    // Publishers
            5000,    // PodCast
            //6000,    // Developers
            7000,    // Networks
            8000,    // Studios
            //9000,    // Playlist
            //10000,  // Test
            //4000000,   // Music Labels
        };

        public StressFindCategories_2700()
        {
            int count = 0;
            CategoryIdList = new Hashtable();
            for (int i = 0; i < CategorySystemId.Length; i++)
            {
                CategoryIdList.Add(CategorySystemId[i], GetCategroyIdsFromDB(CategorySystemId[i]));
                count += ((List<int>)CategoryIdList[CategorySystemId[i]]).Count;
            }
            Global.RO.Success("Load category ids from DB done! Total: " + count);
        }

        #region CategoryList
        static int[] List7000 = new int[]{
         7001,
         7002,
         7003,
         7004,
         7005,
         7006,
         7007,
         7008,
         7009,
         7010,
         7011,
         7012,
         7013,
         7014,
         7015,
         7016,
         7017,
         7018,
         7019,
         7020,
         7021,
         7022,
         7023,
         7024,
         7025,
         7026,
         7027,
         7028,
         7029,
         7030
        };

        static int[] List8000 = new int[]{
         8001,
         8002,
         8003,
         8004,
         8005,
         8006,
         8007,
         8008,
         8009,
         8010,
         8011,
         8012,
         8013,
         8014,
         8015,
         8016,
         8017,
         8018,
         8019,
         8020,
         8021,
         8022,
         8023,
         8024,
         8025,
         8026,
         8027,
         8028,
         8029,
         8030,
         8031,
         8032,
         8033,
         8034,
         8035,
         8036,
         8037,
         8038,
         8039,
         8040,
         8041,
         8042,
         8043,
         8044,
         8045,
         8046,
         8047,
         8048,
         8049,
         8050,
         8051,
         8052,
         8053,
         8054,
         8055,
         8056,
         8057,
         8058,
         8059,
         8060,
         8061,
         8062,
         8063,
         8064,
         8065,
         8066,
         8067,
         8068,
         8069,
         8070
        };

        static int[] List5000 = new int[]{
                     5001,
         5002,
         5003,
         5004,
         5005,
         5006,
         5007,
         5008,
         5009,
         5010,
         5011,
         5012,
         5013,
         5014,
         5015,
         5100,
         5101,
         5102,
         5103,
         5104,
         5105,
         5106,
         5150,
         5151,
         5152,
         5153,
         5154,
         5155,
         5200,
         5201,
         5202,
         5203,
         5204,
         5205,
         5250,
         5251,
         5252,
         5253,
         5254,
         5255,
         5300,
         5301,
         5302,
         5303,
         5304,
         5305,
         5306,
         5350,
         5351,
         5352,
         5353,
         5354,
         5355,
         5356,
         5357,
         5400,
         5401,
         5402,
         5403,
         5404,
         5405,
         5406,
         5450,
         5451,
         5452,
         5453,
         5454,
         5500,
         5501,
         5502,
         5503,
         5504,
         5505,
         5506,
         5507,
         5508,
         5509,
         5510,
         5511,
         5512,
         5513,
         5514,
         5515,
         5550,
         5551,
         5552,
         5553,
         5554,
         5600,
         5601,
         5602,
         5603,
         5604,
         5605,
         5606,
         5650,
         5651,
         5652,
         5653,
         5654,
         5655,
         5656,
         5700,
         5701,
         5702,
         5703,
         5704,
         5705,
         5706,
         5707,
         5708,
         5709,
         5750,
         5751,
         5752,
         5753,
         5754,
         5756
        };

        static int[] List10000 = new int[]{
         10001,
         10002,
         10003,
         10004,
         10005,
         10101,
         10102,
         10103,
         10104,
         10105,
         10200,
         10201,
         10202,
         10203,
         10204,
         10205,
         10301,
         10302,
         10303,
         10304,
         10305,
         10401,
         10402,
         10403,
         10404,
         10405,
         10406,
         10407,
         10408,
         10409,
         10410,
         10411,
         10412,
         10413,
         10414,
         10415,
         10501,
         10502,
         10503,
         10504,
         10505
        };
        static int[] List1000 = new int[]{
         1001,
         1002,
         1003,
         1004,
         1005,
         1006,
         1007,
         1008,
         1009,
         1010,
         1011,
         1012,
         1013,
         1101,
         1102,
         1103,
         1104,
         1105,
         1106,
         1107,
         1108,
         1109,
         1110,
         1111,
         1112,
         1113,
         1114,
         1115,
         1116,
         1121,
         1122,
         1123,
         1124,
         1125,
         1126,
         1127,
         1141,
         1142,
         1143,
         1144,
         1145,
         1146,
         1147,
         1161,
         1163,
         1164,
         1165,
         1166,
         1167,
         1168,
         1169,
         1170,
         1201,
         1202,
         1204,
         1205,
         1206,
         1207,
         1208,
         1209,
         1210,
         1211,
         1212,
         1213,
         1214,
         1215,
         1216,
         1217,
         1218,
         1219,
         1220,
         1221,
         1222,
         1223,
         1224,
         1225,
         1226,
         1227,
         1228,
         1229,
         1230,
         1231,
         1232,
         1233,
         1234,
         1235,
         1236,
         1237,
         1238,
         1239,
         1240,
         1241,
         1242,
         1243,
         1244,
         1245,
         1246,
         1247,
         1261,
         1262,
         1263,
         1264,
         1265,
         1266,
         1267,
         1268,
         1281,
         1282,
         1283,
         1284,
         1285,
         1286,
         1287,
         1288,
         1289,
         1290,
         1291,
         1292,
         1293,
         1294,
         1295,
         1301,
         1302,
         1303,
         1304,
         1305,
         1306,
         1307};
        #endregion

        static List<int> CatList1000 = GetList<int>(List1000);
        static List<int> CatList7000 = GetList<int>(List7000);
        static List<int> CatList8000 = GetList<int>(List8000);
        static List<int> CatList5000 = GetList<int>(List5000);
        //static List<int> CatList10000=GetList<int>(List10000);


        private static List<int> GetCategroyIdsFromDB(int systemId)
        {
            switch (systemId)
            {
                case 1000: return CatList1000;

                case 5000:
                    return CatList5000;

                case 7000:
                    return CatList7000;


                case 8000:
                    return CatList8000;

                //case 10000:
                //return CatList10000;

            }
            return null;
        }


        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindCategories;
            FindCategoriesFilter filter = new FindCategoriesFilter();
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "fr-FR" }, new uint[] { 5, 5 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = RandomEx.GlobalRandGen.Next(0, 255);  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50, 100 }, new uint[] { 5, 5, 5 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 5, 5 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 1, 5 }, new uint[] { 10, 10 });
            filter.OfferFilterLevel = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 10, 10 });
            filter.CategorySystemId = StressHelper.GetInputValue(CategorySystemId, new uint[] { 5, 5, 5, 5 });
            int[] cateIdsForSystem = ((List<int>)CategoryIdList[filter.CategorySystemId]).ToArray();
            filter.CategoryIds = StressHelper.GetInputValue(cateIdsForSystem, new uint[] { 1, 2, 5 }, new uint[] { 1, 1, 1 }); // 0 - 64
            filter.OrderBy = StressHelper.GetInputValue(new int[] { 11, 12 }, new uint[] { 20, 20 });
            //     -- orderBy supports
            //    --  11 = categoryName
            //    --  12 = categoryId
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 99, 1 });

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }
    /// <summary>
    /// FindCategories stress test
    /// </summary>
    [StressTest(Priority = 100)]
    public class StressFindCategoriesZune : QueryStressTestBase
    {
        private const string FeCatalogDBXbox = "FeCatalogDBXbox";
        private Hashtable CategoryIdList = null;


        public static List<T> GetList<T>(T[] values)
        {
            // Determine the size of the array we should use
            int count = values.Length;
            List<T> list = new List<T>();

            for (int i = 0; i < count; i++)
            {

                list.Add(values[i]);
            }
            return list;
        }



        private static readonly int[] CategorySystemId = {
            1000,    // Video
            //2000,    // Music
            //3000,    // Game
            //4000,    // Publishers
            5000,    // PodCast
            //6000,    // Developers
            7000,    // Networks
            8000,    // Studios
            //9000,    // Playlist
            //10000,  // Test
            //4000000,   // Music Labels
        };

        public StressFindCategoriesZune()
        {
            int count = 0;
            CategoryIdList = new Hashtable();
            for (int i = 0; i < CategorySystemId.Length; i++)
            {
                CategoryIdList.Add(CategorySystemId[i], GetCategroyIdsFromDB(CategorySystemId[i]));
                count += ((List<int>)CategoryIdList[CategorySystemId[i]]).Count;
            }
            Global.RO.Success("Load category ids from DB done! Total: " + count);
        }

        #region CategoryList
        static int[] List7000 = new int[]{
         7001,
         7002,
         7003,
         7004,
         7005,
         7006,
         7007,
         7008,
         7009,
         7010,
         7011,
         7012,
         7013,
         7014,
         7015,
         7016,
         7017,
         7018,
         7019,
         7020,
         7021,
         7022,
         7023,
         7024,
         7025,
         7026,
         7027,
         7028,
         7029,
         7030
        };

        static int[] List8000 = new int[]{
         8001,
         8002,
         8003,
         8004,
         8005,
         8006,
         8007,
         8008,
         8009,
         8010,
         8011,
         8012,
         8013,
         8014,
         8015,
         8016,
         8017,
         8018,
         8019,
         8020,
         8021,
         8022,
         8023,
         8024,
         8025,
         8026,
         8027,
         8028,
         8029,
         8030,
         8031,
         8032,
         8033,
         8034,
         8035,
         8036,
         8037,
         8038,
         8039,
         8040,
         8041,
         8042,
         8043,
         8044,
         8045,
         8046,
         8047,
         8048,
         8049,
         8050,
         8051,
         8052,
         8053,
         8054,
         8055,
         8056,
         8057,
         8058,
         8059,
         8060,
         8061,
         8062,
         8063,
         8064,
         8065,
         8066,
         8067,
         8068,
         8069,
         8070
        };

        static int[] List5000 = new int[]{
                     5001,
         5002,
         5003,
         5004,
         5005,
         5006,
         5007,
         5008,
         5009,
         5010,
         5011,
         5012,
         5013,
         5014,
         5015,
         5100,
         5101,
         5102,
         5103,
         5104,
         5105,
         5106,
         5150,
         5151,
         5152,
         5153,
         5154,
         5155,
         5200,
         5201,
         5202,
         5203,
         5204,
         5205,
         5250,
         5251,
         5252,
         5253,
         5254,
         5255,
         5300,
         5301,
         5302,
         5303,
         5304,
         5305,
         5306,
         5350,
         5351,
         5352,
         5353,
         5354,
         5355,
         5356,
         5357,
         5400,
         5401,
         5402,
         5403,
         5404,
         5405,
         5406,
         5450,
         5451,
         5452,
         5453,
         5454,
         5500,
         5501,
         5502,
         5503,
         5504,
         5505,
         5506,
         5507,
         5508,
         5509,
         5510,
         5511,
         5512,
         5513,
         5514,
         5515,
         5550,
         5551,
         5552,
         5553,
         5554,
         5600,
         5601,
         5602,
         5603,
         5604,
         5605,
         5606,
         5650,
         5651,
         5652,
         5653,
         5654,
         5655,
         5656,
         5700,
         5701,
         5702,
         5703,
         5704,
         5705,
         5706,
         5707,
         5708,
         5709,
         5750,
         5751,
         5752,
         5753,
         5754,
         5756
        };

        static int[] List10000 = new int[]{
         10001,
         10002,
         10003,
         10004,
         10005,
         10101,
         10102,
         10103,
         10104,
         10105,
         10200,
         10201,
         10202,
         10203,
         10204,
         10205,
         10301,
         10302,
         10303,
         10304,
         10305,
         10401,
         10402,
         10403,
         10404,
         10405,
         10406,
         10407,
         10408,
         10409,
         10410,
         10411,
         10412,
         10413,
         10414,
         10415,
         10501,
         10502,
         10503,
         10504,
         10505
        };
        static int[] List1000 = new int[]{
         1001,
         1002,
         1003,
         1004,
         1005,
         1006,
         1007,
         1008,
         1009,
         1010,
         1011,
         1012,
         1013,
         1101,
         1102,
         1103,
         1104,
         1105,
         1106,
         1107,
         1108,
         1109,
         1110,
         1111,
         1112,
         1113,
         1114,
         1115,
         1116,
         1121,
         1122,
         1123,
         1124,
         1125,
         1126,
         1127,
         1141,
         1142,
         1143,
         1144,
         1145,
         1146,
         1147,
         1161,
         1163,
         1164,
         1165,
         1166,
         1167,
         1168,
         1169,
         1170,
         1201,
         1202,
         1204,
         1205,
         1206,
         1207,
         1208,
         1209,
         1210,
         1211,
         1212,
         1213,
         1214,
         1215,
         1216,
         1217,
         1218,
         1219,
         1220,
         1221,
         1222,
         1223,
         1224,
         1225,
         1226,
         1227,
         1228,
         1229,
         1230,
         1231,
         1232,
         1233,
         1234,
         1235,
         1236,
         1237,
         1238,
         1239,
         1240,
         1241,
         1242,
         1243,
         1244,
         1245,
         1246,
         1247,
         1261,
         1262,
         1263,
         1264,
         1265,
         1266,
         1267,
         1268,
         1281,
         1282,
         1283,
         1284,
         1285,
         1286,
         1287,
         1288,
         1289,
         1290,
         1291,
         1292,
         1293,
         1294,
         1295,
         1301,
         1302,
         1303,
         1304,
         1305,
         1306,
         1307};
        #endregion

        static List<int> CatList1000 = GetList<int>(List1000);
        static List<int> CatList7000 = GetList<int>(List7000);
        static List<int> CatList8000 = GetList<int>(List8000);
        static List<int> CatList5000 = GetList<int>(List5000);
        //static List<int> CatList10000=GetList<int>(List10000);


        private static List<int> GetCategroyIdsFromDB(int systemId)
        {
            switch (systemId)
            {
                case 1000: return CatList1000;

                case 5000:
                    return CatList5000;

                case 7000:
                    return CatList7000;


                case 8000:
                    return CatList8000;

                //case 10000:
                //return CatList10000;

            }
            return null;
        }


        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindCategoriesZune;
            FindCategoriesZuneFilter filter = new FindCategoriesZuneFilter();
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US"}, new uint[] { 100 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 3;  
            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50, 100 }, new uint[] { 90, 5, 5 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 95, 5 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 3, 5 }, new uint[] { 10, 90 });
            filter.OfferFilterLevel = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });
            filter.CategorySystemId = 5000;
            int[] cateIdsForSystem = CatList5000.ToArray();
            filter.CategoryIds = StressHelper.GetInputValue(cateIdsForSystem, new uint[] { 1, 2, 5 }, new uint[] { 80, 20, 1 }); // 0 - 64
            filter.OrderBy = StressHelper.GetInputValue(new int[] { 11, 12 }, new uint[] { 80, 20 });
            //     -- orderBy supports
            //    --  11 = categoryName
            //    --  12 = categoryId
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 99, 1 });

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }


    /// <summary>
    /// FindContributors stress test
    /// </summary>
    [StressTest(Priority = 100)]
    public class StressFindContributors : QueryStressTestBase
    {
        private static readonly string[] MediaIds = {
        #region Contributor MediaIds
             "FB45AF19-ADF0-42CB-B1A9-FFF31254B1FD",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "0B069433-4FD5-4967-B6CB-FFF30EB6F610",
             "BEBB4966-C0C4-4F56-B6F0-FFEEE2CC1798",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "9AE74B63-7130-4E5F-ACA3-FF982615A4FF",
             "27D94908-FA01-42DE-BD44-FF9685AA0A38",
             "27D94908-FA01-42DE-BD44-FF9685AA0A38",
             "27D94908-FA01-42DE-BD44-FF9685AA0A38",
             "27D94908-FA01-42DE-BD44-FF9685AA0A38",
             "27D94908-FA01-42DE-BD44-FF9685AA0A38",
             "B994E2CE-0ED9-4CFF-9DBE-FF8CB470DB49",
             "176D95F6-EA22-4A38-98BD-FF73754B5FB4",
             "251C0AB0-EF0D-41D3-B817-FF4FBE0C9923",
             "251C0AB0-EF0D-41D3-B817-FF4FBE0C9923",
             "251C0AB0-EF0D-41D3-B817-FF4FBE0C9923",
             "251C0AB0-EF0D-41D3-B817-FF4FBE0C9923",
             "251C0AB0-EF0D-41D3-B817-FF4FBE0C9923",
             "251C0AB0-EF0D-41D3-B817-FF4FBE0C9923",
             "89099802-7D9B-4609-A76F-FF3C331C82A5",
             "89099802-7D9B-4609-A76F-FF3C331C82A5",
             "89099802-7D9B-4609-A76F-FF3C331C82A5",
             "89099802-7D9B-4609-A76F-FF3C331C82A5",
             "89099802-7D9B-4609-A76F-FF3C331C82A5",
             "89099802-7D9B-4609-A76F-FF3C331C82A5",
             "89099802-7D9B-4609-A76F-FF3C331C82A5",
             "883750AA-D6C4-4CEE-97EE-FF08626E1AD3",
             "B92A2689-F932-4E17-8FE6-FE9E6C51715B",
             "B92A2689-F932-4E17-8FE6-FE9E6C51715B",
             "B92A2689-F932-4E17-8FE6-FE9E6C51715B",
             "B92A2689-F932-4E17-8FE6-FE9E6C51715B",
             "B92A2689-F932-4E17-8FE6-FE9E6C51715B",
             "CC5622C8-AF80-461B-87CC-FE85967F9A44",
             "CC5622C8-AF80-461B-87CC-FE85967F9A44",
             "CC5622C8-AF80-461B-87CC-FE85967F9A44",
             "CC5622C8-AF80-461B-87CC-FE85967F9A44",
             "CC5622C8-AF80-461B-87CC-FE85967F9A44",
             "CC5622C8-AF80-461B-87CC-FE85967F9A44",
             "CC5622C8-AF80-461B-87CC-FE85967F9A44",
             "7781BC7A-C9C1-423D-B0C7-FE7E7118EED7",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "A6FDF6EA-546C-4C54-8B5C-FE632747EBFC",
             "E2122F47-2DC6-4C5D-A37F-FE4C29C6BEB5",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "2C1A5268-D634-497F-9FBB-FE36DFE67CD1",
             "818C0147-A92C-4638-B5C8-FE364DBDDC84",
             "818C0147-A92C-4638-B5C8-FE364DBDDC84",
             "818C0147-A92C-4638-B5C8-FE364DBDDC84",
             "818C0147-A92C-4638-B5C8-FE364DBDDC84",
             "818C0147-A92C-4638-B5C8-FE364DBDDC84",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "C1F37381-E5A1-468F-8D4C-FDE16AE2DA12",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "6D7CD252-8335-4514-BCB4-FDD77C7C0915",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "2730EFF8-5ADB-4804-97C9-FDD704FE0431",
             "4D6D1C30-E95E-472A-9C8B-FDBC737BA3AE",
             "4D6D1C30-E95E-472A-9C8B-FDBC737BA3AE",
             "4D6D1C30-E95E-472A-9C8B-FDBC737BA3AE",
             "4D6D1C30-E95E-472A-9C8B-FDBC737BA3AE",
             "4D6D1C30-E95E-472A-9C8B-FDBC737BA3AE",
             "4D6D1C30-E95E-472A-9C8B-FDBC737BA3AE",
             "4D6D1C30-E95E-472A-9C8B-FDBC737BA3AE",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "2E085CFE-714D-4348-A53E-FD71165D9DBF",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "DA4BBB2E-7B93-4DF3-B4A7-FD6CE2BB98EE",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "D99591B7-97BE-4573-ABA0-FD6711C952C9",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "F344DC09-041F-4514-894A-FD27BD7E7F76",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "2CEED8D7-913E-433A-A6C6-FD0EF4518009",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35",
             "F9344BD7-D198-4548-9623-FCFE0DEECA35"
            #endregion
        };

        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindContributors;
            FindContributorsFilter filter = new FindContributorsFilter();
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "fr-FR" }, new uint[] { 95, 5 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 1;  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50, 100 }, new uint[] { 90, 5, 5 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 ,3}, new uint[] { 80, 20, 10 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 80, 20 });
            filter.MediaIds = new List<Guid>(); // 0 - 256, The current usage of this API is to call it with a single Media Id.
            string mediaId = MediaIds[RandomEx.GlobalRandGen.Next(0, MediaIds.Length)];
            filter.MediaIds.Add(new Guid(mediaId));
            filter.ContributorLimit = StressHelper.GetInputValue(new int[] { 1, 2, 3, 5 }, new uint[] { 80, 20, 5, 5 });
            filter.OrderBy = StressHelper.GetInputValue(new int[] { 13, 14, 15}, new uint[] { 50, 50, 50 });    
            //     -- orderBy supports
            //    --  13 = Contributor.sortName
            //    --  14 = MediaContributor.character
            //    --  15 = MediaContributor.sortOrder
            //    --  16 = Role.sortOrder
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }

    [StressTest(Priority = 100)]
    public class StressFindFeaturedPodcasts : QueryStressTestBase
    {
        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindFeaturedPodcasts;
            FindFeaturedPodcastsFilter filter = new FindFeaturedPodcastsFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now

            filter.PageSize = StressHelper.GetInputValue(new int[] { 100, 50,10 }, new uint[] { 40, 40,20 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2, 3, 4, 5, 6, 7, 8,9,10,11, 12}, new uint[] { 100, 100,100,100,60,50,20,10,10,10,10,10 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 3, 5 }, new uint[] { 95, 5 });

            string[] collectionIds ={
#region CollectionIds
                        /*"1FCE7A76-92F2-42FD-B8A3-133A089C5111", 
                         "1FCE7A76-92F2-42FD-B8A3-133A089C5222",
                         "1fce7a76-92f2-42fd-b8a3-000000000001",
                         "1fce7a76-92f2-42fd-b8a3-000000000002",
                         "1fce7a76-92f2-42fd-b8a3-000000000003",
                         "1fce7a76-92f2-42fd-b8a3-000000000004",
                         "1fce7a76-92f2-42fd-b8a3-000000000005",
                         "1fce7a76-92f2-42fd-b8a3-000000000006",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5333",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5444",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5555",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5666",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5777",
                        "7D043E81-6DB5-47BA-A749-1E3B61071412",
                        "45F7A360-F15B-45B4-B1A6-2D12560B58A2",
                        "032E4757-C7CB-4D07-AC6E-727B039A7584",
                        "4FC886D4-872D-43E0-AD14-BC1B87A8C623",
                        "43F7C74E-C65C-4AF9-8FCD-BCAC0A310273",
                        "EFF94621-361C-4D24-A6F4-F876D069C862"*/

                        /*"1FCE7A76-92F2-42FD-B8A3-133A089C5111", 
                         "1FCE7A76-92F2-42FD-B8A3-133A089C5222",
                         "1fce7a76-92f2-42fd-b8a3-000000000001",
                         "1fce7a76-92f2-42fd-b8a3-000000000002",
                         "1fce7a76-92f2-42fd-b8a3-000000000003",
                         "1fce7a76-92f2-42fd-b8a3-000000000004",
                         "1fce7a76-92f2-42fd-b8a3-000000000005",
                         "1fce7a76-92f2-42fd-b8a3-000000000006",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5333",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5444",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5555",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5666",
                        "1FCE7A76-92F2-42FD-B8A3-133A089C5777",*/
                        "7D043E81-6DB5-47BA-A749-1E3B61071412",
                        "45F7A360-F15B-45B4-B1A6-2D12560B58A2",
                        "032E4757-C7CB-4D07-AC6E-727B039A7584",
                        "4FC886D4-872D-43E0-AD14-BC1B87A8C623",
                        "43F7C74E-C65C-4AF9-8FCD-BCAC0A310273",
                        "EFF94621-361C-4D24-A6F4-F876D069C862"
#endregion
            
            };
            //total 6 collection would be used by client
            filter.CollectionId = collectionIds[RandomEx.GlobalRandGen.Next(0, collectionIds.Length)];

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }

    // 1. categoryIds and title filter and podcasttype
    // 2. Findpodcast with URL 
    // 3. Findpodcast with lots of media Ids.
    [StressTest(Priority = 1000)]
    public class StressFindPodcasts_filter_categoryIds : QueryStressTestBase
    {
        const int PodCategoryBase = 10403;
        const int PodCategoryNum = 12;

        static int[] categoryIds = new int[]{
#region Podcast CategpryIds
5100,
5101,
5102,
5106,
5107,
5108,
5109,
5150,
5151,
5152,
5153,
5154,
5155,
5156,
5200,
5201,
5202,
5203,
5204,
5205,
5206,
5207,
5250,
5252,
5253,
5254,
5255,
5256,
5257,
5258,
5259,
5260,
5261,
5300,
5301,
5302,
5303,
5304,
5305,
5306,
5350,
5351,
5352,
5353,
5354,
5355,
5356,
5357,
5400,
5401,
5403,
5404,
5405,
5406,
5450,
5451,
5452,
5453,
5454,
5455,
5456,
5502,
5503,
5505,
5506,
5507,
5508,
5510,
5513,
5514,
5515,
5516,
5517,
5550,
5551,
5552,
5553,
5554,
5555,
5556,
5557,
5558,
5600,
5601,
5602,
5603,
5604,
5605,
5606,
5607,
5608,
5650,
5651,
5652,
5654,
5655,
5656,
5657,
5658,
5700,
5701,
5702,
5703,
5704,
5705,
5706,
5707,
5708,
5709,
5710,
5711,
5712,
5750,
5751,
5752,
5753,
5754,
5756,
5757
#endregion
        };

        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindPodcasts;
            FindPodcastsFilter filter = new FindPodcastsFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = filter.Locale;

            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50 }, new uint[] { 80, 20 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 80, 20 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 3, 5 }, new uint[] { 90, 10 });

            filter.PodcastType = StressHelper.GetInputValue(new int[] { 1, 2}, new uint[] { 90, 5 });

            //category

            uint[] catArraySize ={ 1, 2 };
            uint[] catArraySizeDistributions ={ 99, 1 };

            Int32[] CategoryIdsFilters = new Int32[3];

            /*CategoryIdsFilters[0] = PodCategoryBase + RandomEx.GlobalRandGen.Next(0, PodCategoryNum);
            CategoryIdsFilters[1] = PodCategoryBase + RandomEx.GlobalRandGen.Next(0, PodCategoryNum);
            CategoryIdsFilters[2] = PodCategoryBase + RandomEx.GlobalRandGen.Next(0, PodCategoryNum);

            filter.CategoryIds = StressHelper.GetInputValue<Int32>(CategoryIdsFilters, catArraySize, catArraySizeDistributions);
            */

            filter.CategoryIds = StressHelper.GetInputValue<Int32>(categoryIds, catArraySize, catArraySizeDistributions);
        
            String chars = "abcdefehijklmnopqrstuvwxyz";
            String titlePrefix = string.Format("{0}", chars[RandomEx.GlobalRandGen.Next(0, chars.Length)]);

            filter.TitleFilters = new List<string>();
            filter.TitleFilters.Add(titlePrefix);


            filter.OrderBy = StressHelper.GetInputValue(new int[] { 1, 2, 3, 4 }, new uint[] { 90, 1, 1, 1 });
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 95, 1 });


            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }

    [StressTest(Priority = 1000)]
    public class StressFindPodcasts_URL : QueryStressTestBase
    {
        static String[] MediaUrlsFilters ={
#region MediaUrl
               "www.xbox.com",
               "http://1 podcast C1.msn.com",     
               "www.test.xbox.com",   
               "http://igjhaedj title.msn.com",
                "http://feeds.feedburner.com/lalibertadfinanciera",
"http://bigupradio.audioblog.com/rss/bigupradio_reality_time.xml",
"http://therotokings.libsyn.com/rss",
"http://feeds.feedburner.com/mupodcast",
"http://www.z100.com/podcast/PhoneTaps.xml",
"http://feeds.feedburner.com/potter-cast",
"http://feeds.feedburner.com/HeartOfTheNightShow",
"http://feeds.feedburner.com/unleasheditunes",
"http://feeds.feedburner.com/poker-podcast",
"http://pilotslog.libsyn.com/rss",
"http://jvond.com/vidcast.xml",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=hbofamily",
"http://calyoga.com/podcast.xml",
"http://feeds.feedburner.com/vh1_bestof",
"http://feeds.feedburner.com/scottsigler",
"http://feeds.feedburner.com/PhilosophyPodcast",
"http://feeds.feedburner.com/KITKAST-WMV",
"http://feeds.feedburner.com/Japancastnet",
"http://iws.punahou.edu/user/lcouillard/index.xml",
"http://www.pbs.org/newshour/rss/podcast_poetry.xml",
"http://feeds.feedburner.com/ArtistalleyPodcast",
"http://feeds.feedburner.com/AnimeWorldOrder",
"http://atheistviewpoint.tv/podcast.xml",
"http://feeds.feedburner.com/rookiedesigner",
"http://feeds.feedburner.com/LoneStarGridiron",
"http://tsiyon.org/podcast/?feed=rss2",
"http://obama.senate.gov/podcast/index.xml",
"http://feeds.feedburner.com/TheFightworksPodcast",
"http://letsknit2gether.com/feed/desktop_rss.xml",
"http://feeds.feedburner.com/mobuzztv-uk-qt7",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=26",
"http://feeds.feedburner.com/wallstrip",
"http://coldcallingpodcast.com/coldcallingpodcast.rss",
"http://www.mondominishows.com/rss/pokernight.xml",
"http://dansmath.libsyn.com/rss",
"http://feeds.feedburner.com/sanga",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2864045",
"http://artagogo.libsyn.com/rss",
"http://www.slate.com/podcast/slatev.aspx",
"http://www.1up.com/flat/Podcasts/brokenpixels.xml",
"http://www.mondominishows.com/rss/zombiecollege.xml",
"http://feeds.feedburner.com/Motocast",
"http://feeds.almanac.com/radioreport",
"http://preschoolrockmoms.com/feed/",
"http://catavino.libsyn.com/rss",
"http://www.itsapurlman.com/category/podcasts/feed",
"http://www.aero-news.net/podcasts/rsspodcasttoday.xml",
"http://feeds.ziffdavis.com/ziffdavis/cgipodvideo",
"http://feeds.feedburner.com/Verge",
"http://feeds.feedburner.com/sidepodcast",
"http://heidiestrin.audioblog.com/rss/the_book_of_life.xml",
"http://crave.cnet.com/av/vcast/crave.xml",
"http://www.podshow.com/feeds/truckertom.xml",
"http://www.bostonbehindthescenes.com/rss",
"http://www.yogatoday.com/archive/index.xml",
"http://golf.onnetworks.com/videos/shows/785/podcast/hd",
"http://feeds.feedburner.com/FlickdMtvMovieNewsvideo",
"http://www.pbs.org/newshour/rss/podcast.xml",
"http://podcast.msnbc.com/audio/podcast/MSNBC-NN-NETCAST-M4V.xml",
"http://www.fhradio.org/RSS/rss.xml",
"http://feeds.feedburner.com/asiacast",
"http://feeds.feedburner.com/sop",
"http://www.citywest.org/podcast/podcast.xml",
"http://www.legaltalknetwork.com/RSS/LTN_feed.xml",
"http://www.dragonpage.com/podcastWC.xml",
"http://democracynow.org/podcast.xml",
"http://podcasting.isfullofcrap.com/podcast.rss",
"http://feeds.feedburner.com/CraftyChicaPodcast",
"http://podfeed.podcastjuice.jp/app/rss_convert.cgi?url=http://californiawine-clips.cocolog-nifty.com/blog/",
"http://weightlossradio.libsyn.com/rss",
"http://feeds.feedburner.com/ridertech",
"http://feeds.feedburner.com/EffectiveEdge",
"http://tuscany.podtravels.tv/feed",
"http://nopeainthepod.libsyn.com/rss",
"http://thehadokings.libsyn.com/rss",
"http://feeds.feedburner.com/animeroundtable",
"http://healthydiet.weblogstop.com/feed/",
"http://www.g4tv.com/attackoftheshow/podcasts/5/Attack_of_the_Show_Daily_Video_Podcast.xml",
"http://americanradioworks.publicradio.org/podcast.xml",
"http://feeds.feedburner.com/BigSeminarLiveCast",
"http://mba.tuck.dartmouth.edu/digital/rss/radiotuck.xml",
"http://feeds.feedburner.com/GrimesNotDead",
"http://www.mousetunes.com/xml/mousetunes.xml",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2557342",
"http://www.tikibartv.com/feeds/itunes",
"http://feeds.feedburner.com/serge",
"http://www.odeo.com/channel/104700/rss",
"http://www.shortcummingsaudio.com/rss",
"http://feeds.feedburner.com/Money-guycom",
"http://fantoo.com/podcast/podcast.xml",
"http://downloads.bbc.co.uk/podcasts/radio/newspod/rss.xml",
"http://feeds.feedburner.com/shralpsurfforiTunes",
"http://www.italyguides.it/us/roma/download_audioguide/podcast/podcast.xml",
"http://www.hbsp.libsyn.com/rss",
"http://www.smartbombradio.com/rss",
"http://inventa.co.uk/podcasts/petetong/index.xml",
"http://feeds.feedburner.com/environminute",
"http://www.happyhouseofhentai.com/rss",
"http://radio.nac-cna.ca/podcast/NACOcast/NACOcast.xml",
"http://feeds.feedburner.com/InLatteVeritas",
"http://feeds.feedburner.com/steveanddawn/podcast",
"http://www.thinkfuture.com/tfetc.xml",
"http://feeds.feedburner.com/mostlynews",
"http://feeds.feedburner.com/TopOfThePods",
"http://podcast.traditionalnaturopath.com/",
"http://feeds.feedburner.com/EnglishAsASecondLanguagePodcast",
"http://feeds.feedburner.com/travelgolf_this_week",
"http://www.schaeffersresearch.com/rss/podcast.xml",
"http://kol-stargazer.com/podcast/120mincast.xml",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2445552",
"http://www.blogtalkradio.com/feeds/AWTR",
"http://www.militaryspousetalkradio.com/feed.xml",
"http://feeds.feedburner.com/CloudyDayArt",
"http://www.thestreet.com/feeds/rss/m/index.xml",
"http://feeds.feedburner.com/PointySticks",
"http://www.nascarmedia.com/podcast/index.xml",
"http://www.manager-tools.com/wp-rss2.php?category_name=podcasts",
"http://feeds.feedburner.com/technosavvy/podcast",
"http://travelin10.libsyn.com/rss",
"http://feeds.feedburner.com/VariantFrequencies",
"http://www.musicnerve.com/podcasts/podcast.xml",
"http://www.sciam.com/podcast/sciam_podcast_r.xml",
"http://www.intelligenic.com/kidcast/rss.xml",
"http://feeds.feedburner.com/75Minutes",
"http://supertop10.podomatic.com/rss2.xml",
"http://kehinde.com/knittingstepbystep/?feed=rss2",
"http://feeds.ziffdavis.com/ziffdavis/dltvipodpspvideo",
"http://www.cesweb.org/podcasts/cespodcasts.xml",
"http://www.youaretheguest.com/pods/yatgrss.xml",
"http://feeds.feedburner.com/utnecast",
"http://salafy.podbean.com/feed",
"http://acappellau.libsyn.com/rss",
"http://www.cvmd.org/public_videopodcast.php",
"http://www.brewcrazy.com/podcast/BrewCrAzY-rss.xml",
"http://feeds.feedburner.com/LostAtEMinor",
"http://feeds.feedburner.com/artfilmtalk",
"http://podcast.ussoccer.com/",
"http://feeds.feedburner.com/VideoGameOutsiders",
"http://feeds.feedburner.com/mtv/mtvgames",
"http://www.ldsvoices.com/podcast.php",
"http://www.btpodshow.com/feeds/internationalsextherapist.xml",
"http://www.onthemedia.org/index.xml",
"http://fireflytalk.libsyn.com/rss",
"http://www.hometowntales.com/htvidcast.xml",
"http://www1.cuny.edu/forums/podcasts/?feed=rss2",
"http://feeds.feedburner.com/PodcastShuffleShow",
"http://www.netcaucus.org/audio.xml",
"http://www.kosteniuk.com/podcast/chessiscool.xml",
"http://feeds.feedburner.com/PodcastDeLaBolsaDeValores",
"http://www.sherdogvideos.com/radio/beatdown_podcast.rss",
"http://www.rhino.com/rhinocast.rss",
"http://forzafutbol.podbean.com/feed/",
"http://feeds.feedburner.com/achievementjunkieweekly",
"http://www.instantanatomy.net/rss.xml",
"http://radiofrance-podcast.net/podcast/rss_14864.xml",
"http://www.whmsoft.net/services/podcast.php",
"http://valuelineobserver.com/thevalueguys.xml",
"http://www.g4tv.com/g4originals/podcasts/25/G4tvcom_Originals.xml",
"http://leoville.tv/podcasts/twit.xml",
"http://feeds.feedburner.com/PodDiverRadio",
"http://feeds.feedburner.com/ThePeteAndReneeShow",
"http://asktaxmama.com/podcast/podcast.php",
"http://www.btpodshow.com/feeds/podfinderuk.xml",
"http://feeds.feedburner.com/switchpod/PgAm",
"http://feeds.feedburner.com/astronomycast",
"http://www.nasa.gov/rss/NASAcast_vodcast.rss",
"http://subnav.com/feed",
"http://feeds.feedburner.com/talkinboxing",
"http://andesmallwood.libsyn.com/rss",
"http://www.podcasternews.com/feeds/healthandwell.xml",
"http://theovernightscape.com/rss.xml",
"http://feeds.thisamericanlife.org/talpodcast",
"http://www.positivediscipline.com/podcast/pd.xml",
"http://innig.net/music/inthehands/feed/rss2/",
"http://martialarts.thepodcastnetwork.com/feed/",
"http://feeds.feedburner.com/AnimePulse",
"http://feeds.feedburner.com/GorillawireRadio",
"http://www.kiddlive.com/WarmUpShow/kidd_kraddick_warmup_show.xml",
"http://www.tektime.com.au/podcast/podcast.php",
"http://www.edukast.com/mrrshows/shows.xml",
"http://renaissancefestivalmusic.com/RenFestPodcast.rss",
"http://www.fox.com/foxcast/rss/familyguy.xml",
"http://feeds.feedburner.com/GoodnightBurbank",
"http://feeds.feedburner.com/KidsCableLearning",
"http://www.djsteveboy.com/audio/podrunner.xml",
"http://www.miporadio.com/rss.xml",
"http://clandestino.podbean.com/feed",
"http://feeds.feedburner.com/ArchitectureTalk",
"http://feeds.feedburner.com/WickedGoodPodcast",
"http://feeds.feedburner.com/boxing",
"http://feeds.feedburner.com/ConfessionsOfADjPodcast",
"http://feeds.feedburner.com/AskANinja",
"http://www.japanesepod101.com/feed.xml",
"http://feeds.feedburner.com/BootsHealthcarePodcastsSeries1",
"http://esfootwear.com/blog/tag/podcast/feed/podcast",
"http://geekbrief.podshow.com/feed.xml",
"http://www.amnesty.org/resources/ai_report_podcast_video.xml",
"http://abuddhistpodcast.libsyn.com/rss",
"http://slate.com/podcast/",
"http://feeds.feedburner.com/RegenerativeMedicineToday",
"http://feeds.feedburner.com/CentralBaptistChurch",
"http://drmonte.libsyn.com/rss",
"http://www.israelnationalradio.com/rss/INR-beat.xml",
"http://www.needleworkspictures.com/iwt/RSS_feed.xml",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/radio4/frontrowinterview/rss.xml",
"http://mixtapeshow.net/feed/",
"http://bigupradio.audioblog.com/rss/bigupradio_boom_shots.xml",
"http://www.npr.org/rss/podcast.php?id=1019",
"http://www.godcast.org/categories/hadavar/rss.xml",
"http://www.npr.org/rss/podcast.php?id=1090",
"http://feeds.feedburner.com/probodybuildingweekly",
"http://www.mrdeity.com/deityrss.xml",
"http://www.kcrw.com/podcast/show/ls",
"http://gmppodcast.com/wmmr/pns/",
"http://feeds.feedburner.com/Civilianismpodcast",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/radio4/fromourowncorrespondent/rss.xml",
"http://weeklyradioaddress.com/WRA_Podcasts.xml",
"http://feeds.feedburner.com/MtvVideoGamesSixShotPodcast",
"http://feeds.feedburner.com/catholicinsider",
"http://feeds.feedburner.com/SmartboardLessonsPodcast",
"http://www.architecture-radio.org/podcast.xml",
"http://www.mayoclinic.org/rss/medical-edge-video.xml",
"http://feeds.feedburner.com/Media30WithShellyPalmer",
"http://www.podworx.com/Podcasts/Podworx.XML",
"http://podcasts.thomasbrin.com/BrinRSS",
"http://feeds.feedburner.com/HPProgs",
"http://prwebpodcast.com/feed/Health: Self-Help",
"http://www.kexp.org/podcast_songoftheday.xml",
"http://www.enduranceradio.com/enduranceradio.rss",
"http://feedthepig.podomatic.com/rss2.xml",
"http://www.kfi640.com/podcast/BillHandel.xml",
"http://feeds.feedburner.com/KEEME",
"http://feeds.feedburner.com/R5CentralWP",
"http://feeds.feedburner.com/TheSailingChannel",
"http://diningonthevine.com/wp-rss2.php",
"http://feeds.feedburner.com/YogaPeeps",
"http://uncleshag.podomatic.com/rss2.xml",
"http://feeds.feedburner.com/realityradio",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/radio4/today/rss.xml",
"http://www.npr.org/rss/podcast.php?id=510002",
"http://homepage.mac.com/cheftony/podcast.xml",
"http://feeds.feedburner.com/EatingWell",
"http://feeds.feedburner.com/blogspot/RFYI",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=11",
"http://www.comedy4cast.com/rss2.xml",
"http://signal.serenityfirefly.com/podcast.xml",
"http://www.jchutchins.net/7thSonPodcast.xml",
"http://feeds.feedburner.com/marioajero",
"http://www.thenakedscientists.com/naked_scientists_podcast.xml",
"http://feeds.feedburner.com/TheBeautifulGame",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2942325",
"http://feeds.feedburner.com/galacticast-itunes",
"http://nubricks.libsyn.com/rss",
"http://feeds.feedburner.com/ecogeeks",
"http://booruch.libsyn.com/rss",
"http://vegasbound.podomatic.com/rss2.xml",
"http://feeds.feedburner.com/OneMinuteHowTo",
"http://feeds.feedburner.com/sportspod",
"http://www.pbs.org/cringely/nerdtv/rss/nerdtv-mp3.xml",
"http://www.hungrymag.com/wp-rss2.php?category_name=podcasts",
"http://www.totalpodcastrophe.com/feed/",
"http://feeds.feedburner.com/datingcast",
"http://feeds.feedburner.com/johnmerrow",
"http://zedcast.libsyn.com/rss",
"http://feeds.feedburner.com/sliceofscifi",
"http://www.or-live.com/podcasting/rwj_1305_mw_podcast.xml",
"http://feeds.feedburner.com/JazzfmcomTop100JazzCountdown",
"http://thetravelguide.podbean.com/feed/",
"http://feeds.feedburner.com/formerfattie",
"http://www.dubsession.com/dubsession/rss/dubsession.xml",
"http://frankiegravato.com/podcast/wp-rss2.php",
"http://www.1up.com/flat/Podcasts/podcasts.xml",
"http://feeds.wnyc.org/radiolab",
"http://www.mclaughlin.com/library/rss.asp",
"http://www.jazzstage.us/rss",
"http://feeds.feedburner.com/typepad/hotwire",
"http://www.geeknewscentral.com/podcast.xml",
"http://feeds.feedburner.com/cinecast",
"http://www.cellarrat.org/podcast.xml",
"http://www.sciencefriday.com/audio/scifriaudio.xml",
"http://feeds.feedburner.com/kickassmysticninjas/",
"http://feeds.feedburner.com/TvindyTime",
"http://www.coolashelltheatre.com/feed",
"http://scy.libsyn.com/rss",
"http://www.howlingearth.com/rss/howling-earth-mp3s.xml",
"http://drjosephm.podbean.com/feed/",
"http://www.violinist.com/media/rssa.xml",
"http://tsoya.libsyn.com/rss",
"http://www.britishairways.com/cms/global/rss/rss.xml",
"http://videogamejocks.libsyn.com/rss",
"http://www.youthradio.org/podcasts/bestof/index.xml",
"http://www.houndtv.com/feed",
"http://chronicle.com/multimedia/podcasts/che_interviews.xml",
"http://kenmunro.com/kenmunro.rss",
"http://www.sciencefriday.com/audio/scifriaudio.xml",
"http://rss.salemweb.net/oneplace/ministries/podcasting/243.xml",
"http://talkingadhd.com/rss/talking_rss.xml",
"http://israellycool.libsyn.com/rss",
"http://www.switchpod.com/users/mindme/feed.xml",
"http://feeds.feedburner.com/BeginningSeoPodcast",
"http://sho.com/site/downloads/rss/boxing.xml",
"http://www.npr.org/rss/podcast.php?id=510055",
"http://www.distortedview.com/show/index.xml",
"http://uconnpodcast.libsyn.com/rss",
"http://www.weeklydrop.com/weeklydrop.xml",
"http://capitalcaucus.com/rss",
"http://www.wcl.american.edu/podcast/index.rss2",
"http://www.griddlecakes.com/griddlecakes.xml",
"http://rss.salemweb.net/oneplace/ministries/podcasting/132.xml",
"http://feeds.feedburner.com/AmericanShakespeareCenterPodcastCentral",
"http://feeds.feedburner.com/inpitlane",
"http://www.thestreet.com/feeds/rss/audio/taskaudio/index.xml",
"http://www.podbazaar.com/rss/126100789566374033",
"http://jama.ama-assn.org/misc/jamapodcasts2006.rss",
"http://f1triviapodcast.libsyn.com/rss",
"http://www.joecartoon.com/files/joecartoon.xml",
"http://feeds.feedburner.com/mugglecast",
"http://feeds.feedburner.com/nfl",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=maxtourstories",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=10",
"http://podcast.nationalgeographic.com/world-music-spotlight/",
"http://www.podshow.com/feeds/reachingforlucidity.xml",
"http://thewordnerds.org/rss",
"http://feeds.feedburner.com/pediacast",
"http://tsbom.com/TheSmallBusinessOwnersManualPodcastRSSinfo.xml",
"http://bobthurman.blip.tv/rss",
"http://feeds.feedburner.com/TravelBusinessSuccess",
"http://feeds.feedburner.com/SturgeonsLaw",
"http://feeds.feedburner.com/journeyPodrss",
"http://golfpsychology.libsyn.com/rss",
"http://www.qdnow.com/money.xml",
"http://worldsurf.libsyn.com/rss",
"http://www.cnet.com/i/pod/cnet_buzz.xml",
"http://www.pbs.org/pov/rss/podcast.xml",
"http://www.cesweb.org/podcasts/cesvidcasts.xml",
"http://feeds.feedburner.com/The19thHoleGolfShow",
"http://feeds.feedburner.com/GeekDating101",
"http://outofthepast.libsyn.com/rss",
"http://www.anders.com/lectures/lars_brownworth/12_byzantine_rulers/rss.xml",
"http://www.mytotalmoneymakeover.com/media/audio/podcast/podcast.xml",
"http://feeds.feedburner.com/FiveHundyByMidnight",
"http://feeds.feedburner.com/sciq",
"http://feeds.feedburner.com/escapepod",
"http://www.48days.com/reality/podcast.xml",
"http://mathmojo.com/chronicles/feed/",
"http://www.bembridge.co.uk/podcast.rss",
"http://www.earthsky.org/rss/feed.php",
"http://www.diggersstory.com/Podcast/DNPfeed.xml",
"http://feeds.feedburner.com/Dudertown-DrupalClass",
"http://www.podcastpickle.com/feed/tip.xml",
"http://www.photoshopusertv.com/wp-rss2.php",
"http://www.starshipsofa.libsyn.com/rss",
"http://media.kcrw.com/podcast/show/de",
"http://www.aracnet.com/~eseligma/mm/MM_RSS_feed.xml",
"http://feeds.feedburner.com/blogspot/AsPB",
"http://enr.construction.com/people/multimedia/cast.xml",
"http://www.cbcradio3.com/podcast/",
"http://www.greatergoodradio.com/?feed=rss2",
"http://feeds.feedburner.com/LookingOutTheWindow",
"http://americanpublicmedia.publicradio.org/podcasts/xml/splendid_table/kitchen_questions.xml",
"http://pressuredrop.podomatic.com/rss2.xml",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2895009",
"http://sportsdoc.libsyn.com/rss",
"http://feeds.feedburner.com/practicalbusinesslessons",
"http://www.healthradionetwork.com/podcast/mind_and_muscle_fitness.xml",
"http://feeds.feedburner.com/ShobizNewsyNews",
"http://www.fieldposition.com/wp-rss2.php",
"http://feeds.feedburner.com/babylonpodcast/",
"http://www.wbur.org/listen/podcasts/onlyagame.xml",
"http://www.srichinmoy.tv/meditation-silence/podcast.xml",
"http://feeds.feedburner.com/wayofthemaster",
"http://feeds.feedburner.com/TravelcommonsPodcast",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2544457",
"http://feeds.feedburner.com/CostaRicaTalkRadio",
"http://justvocabulary.libsyn.com/rss",
"http://success.podomatic.com/rss2.xml",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=conchords",
"http://www.economist.com/media/rss/economist.xml",
"http://www.npr.org/rss/podcast.php?id=1025",
"http://feeds.feedburner.com/MarketingOnlinePodcast",
"http://www.studio360.org/index.xml",
"http://www.internet-based-business-mastery.com/feed/",
"http://www.screwattack.com/sidescrollers.xml",
"http://feeds.feedburner.com/FaceoffHockeyShow",
"http://feeds.feedburner.com/rambleredhead",
"http://webcast.berkeley.edu/rss/course-archive.php?seriesid=1906978397",
"http://podcast.nationalgeographic.com/dog-whisperer",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=badboys",
"http://www.cityam.com/podcasts/mp3.xml",
"http://www.facultypod.libsyn.com/rss",
"http://feeds.feedburner.com/AmateurTravelerPodcast",
"http://feeds.feedburner.com/WildhockeyfanPodcast",
"http://feeds.feedburner.com/SpeakingOfHistory",
"http://marriagevowworkbook.com/blog/category/podcasts/feed",
"http://www.g4tv.com/ninjawarrior/podcasts/27/Ninja_Warrior_Video_Podcast.xml",
"http://www.jasoncable.com/podcast.xml",
"http://www.baseballamerica.com/today/media/podcasts/podcast.xml",
"http://portofinoisland.realestatebuzzbox.com/rss/portofinoisland.xml",
"http://pepperstock.libsyn.com/rss",
"http://feeds.feedburner.com/tspodcast.xml",
"http://feeds.feedburner.com/etowns/obpx",
"http://podcast.thelightsoutshow.com/rss2.aspx",
"http://reelmonkey.libsyn.com/rss",
"http://feeds.feedburner.com/Bobbyshakes",
"http://www.ratemyrap.com/podcast/rss.xml",
"http://manicmommies.libsyn.com/rss",
"http://www.discovery.com/radio/xml/nationalgallery_podcasts.xml",
"http://www.colby.edu/news/feeds/1104483.xml",
"http://www.cbsnews.com/htdocs/mp3/podcast/podcast_entertainment.rss",
"http://gymnasttv.com/?feed=rss2",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2839445",
"http://www.wdwradio.com/xml/wdwradio.xml",
"http://feeds.feedburner.com/mercpod-tech",
"http://marketplace.publicradio.org/RSS/moneyclip_podcast.xml",
"http://feeds.feedburner.com/LTADRSS",
"http://feeds.feedburner.com/taylormarekpodcast",
"http://smartjustice.libsyn.com/rss",
"http://horoscope.libsyn.com/rss",
"http://insidethedancehall.mypodcast.com/rss.xml",
"http://themiddleeast.podomatic.com/rss2.xml",
"http://www.npr.org/rss/podcast.php?id=510170",
"http://www.podcomer.com/?feed=rss2",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=24",
"http://feeds.feedburner.com/ChooseTheLeft",
"http://www.bran.com.au/podcast/?feed=rss2",
"http://www.koreasociety.org/podcast/podcast.xml",
"http://feeds.feedburner.com/MinnesotaStories",
"http://www.netcastdaily.com/broadcast/podcast.php",
"http://bhp.libsyn.com/rss",
"http://ninakimberly.libsyn.com/rss",
"http://podcast.nationalgeographic.com/ng-video-shorts/",
"http://feeds.feedburner.com/podcast411a",
"http://feeds.feedburner.com/smbtrendwire/rtjZ",
"http://feeds.feedburner.com/DisneyCruiseLinePodcast",
"http://podcast.msnbc.com/audio/podcast/MSNBC-MTP.xml",
"http://feeds.feedburner.com/Photowalkthrough",
"http://www.dancarlin.com/dchh.xml",
"http://www.sciam.com/podcast/sciam_podcast_r_d.xml",
"http://feeds.feedburner.com/photohistory",
"http://cmc.ie/feeds/audio.xml",
"http://www.ilearnradio.org/rss/feed.xml",
"http://pointofinquiry.libsyn.com/rss",
"http://www.pbs.org/newshour/rss/podcast_vote2008.xml",
"http://podcasts.pardesusa.org/feed/",
"http://feeds.feedburner.com/pacificcoasthellway",
"http://ayearineurope.libsyn.com/rss",
"http://carleton-real.canadacast.ca/chem1000/burkdemos/chemdemosvodcastxml.xml",
"http://www.switchpod.com/users/msherrill/feed.xml",
"http://feeds.feedburner.com/EdinburghCast",
"http://feeds.feedburner.com/TalkTheatreInChicago",
"http://podcast.nejm.org/nejm_audio_summaries.xml",
"http://podcasts.nhl.com/feb07/draft2007.rss",
"http://www.indiana.edu/~icy/podcast/teachwithtech.xml",
"http://thewellspring.libsyn.com/rss",
"http://www.npr.org/rss/podcast.php?id=5",
"http://recordings.talkshoe.com/rss17507.xml",
"http://teachersteachingteachers.org/?feed=rss2",
"http://eclectic.libsyn.com/rss",
"http://www.pbs.org/washingtonweek/rss/podcast.xml",
"http://steverunner.com/podcast.rss",
"http://documan.podbean.com/feed/",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2870570",
"http://feeds.feedburner.com/Jdsblogcom",
"http://rabbijim.podbean.com/feed/",
"http://www.claynelsonlifebalance.com/podcast/cnlb.xml",
"http://feeds.roocast.com/roocast-australian-music-podcasts-main",
"http://feeds.feedburner.com/InternetHomeBusinessReview",
"http://www.ibm.com/services/us/igs/rss/ibm_bcs_podcast.xml?re=yahoo",
"http://www.cyemerus.com/podcast/feed.xml",
"http://speakingoffaith.publicradio.org/podcast/podcast.xml",
"http://feeds.feedburner.com/MECCAONE",
"http://www.audiopandemicshow.com/rss.xml",
"http://www.slate.com/podcast/",
"http://feeds.feedburner.com/blogspot/zccr",
"http://www.npr.org/rss/podcast.php?id=510101",
"http://www.shakespearehigh.com/pac/podcast/rss.xml",
"http://www.g4tv.com/cinematech/podcasts/8/Cinematech_Video_Podcast.xml",
"http://bouldercnp.jvond.com/vidcast.xml",
"http://audio.csinet.org/podcast.php?cat=CSIConstructionMinute",
"http://feeds.feedburner.com/AlachuaTempleLive",
"http://scripts.ign.com/rss/ign.podcasts.weekly.2.0.xml",
"http://rabbitbites.com/itunes/rbitunes.xml",
"http://feeds.feedburner.com/MTVNewsGreatest",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/radiopersian/roozehaftom/rss.xml",
"http://www.naxos.com/podcasts/naxospodcasts.xml",
"http://amberstar.libsyn.com/rss",
"http://feeds.feedburner.com/ChuckChatTechnorama",
"http://sc1.att.mindcomet.net/_assets/xml/itunes_xml_gen.php",
"http://www.intraspectus.com/learn/audio/podcast.xml",
"http://www.podmusiccountdown.com/index.xml",
"http://feeds.feedburner.com/crescentstation",
"http://themickeyroom.libsyn.com/rss",
"http://leoville.tv/podcasts/kfi.xml",
"http://rss.salemweb.net/oneplace/ministries/podcasting/135.xml",
"http://feeds.feedburner.com/HopeIsEmo",
"http://media.kcrw.com/podcast/show_itms/tt",
"http://www.g4tv.com/cheat/podcasts/7/Cheat_Video_Podcast.xml",
"http://feeds.feedburner.com/mtvnews/Raw/Video",
"http://www.newscientist.com/podcastfeed.ns",
"http://feeds.feedburner.com/LatinAmericanBriefingSeries-TheAudioPodcast",
"http://feeds.feedburner.com/vh1_bestweekever",
"http://www.mondominishows.com/rss/godanddevil.xml",
"http://feeds.feedburner.com/TheLivinLowCarbShow",
"http://coasterradio.libsyn.com/rss",
"http://revision3.com/diggnation/feed/quicktime-large/",
"http://podcast.prx.org/nature/rss.xml",
"http://feeds.feedburner.com/think/MTVJuviesPodcast",
"http://feeds.feedburner.com/WhatsHappeningInTokyo",
"http://feeds.feedburner.com/MedievalPodcast",
"http://feeds.feedburner.com/barnutspodcast",
"http://feeds.feedburner.com/TheUnharshedMellow",
"http://podcast.medianext.com/stations/kcbs/rss/?c=35",
"http://feeds.feedburner.com/nascar",
"http://www.businessweek.com/search/podcasts/cover_stories.rss",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/bbc2/newsnightvideopodcast/rss.xml",
"http://www.kcrw.org/podcast/show/gf",
"http://lenswork.com/podcast.xml",
"http://drmax.audioacrobat.com/rss/drmax-improvise-life.xml",
"http://www.fayewillow.nl/ifight/vodcast.xml",
"http://www.nyas.org/podcasts/nyasodeo.xml",
"http://www.mytakeonthat.com/?feed=rss2",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2689788",
"http://feeds.feedburner.com/planetxbox360podcast",
"http://www.npr.org/rss/podcast.php?id=1045",
"http://feeds.feedburner.com/my9janews",
"http://www.isallaboutmath.com/isallaboutmath.xml",
"http://blogspain.libsyn.com/rss",
"http://www.learnitalianpod.com/feed/",
"http://feeds.feedburner.com/TheRadioMomsPodcast",
"http://englishcaster.com/bobrob/wp-rss2.php",
"http://feeds.feedburner.com/VintageTooncast",
"http://feeds.feedburner.com/clipshow",
"http://bridalscene.libsyn.com/rss",
"http://feeds.feedburner.com/tuckertales",
"http://feeds.feedburner.com/securitynow",
"http://feeds.feedburner.com/Whiteroofradiocom",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/radio4/inbusiness/rss.xml",
"http://feeds.feedburner.com/golfforbeginners",
"http://jmwstaging.webjackmorton.com/podcast/five_things/five_things.xml",
"http://thejudopodcast.libsyn.com/rss",
"http://travelstories.thepodcastnetwork.com/feed",
"http://feeds.feedburner.com/IhsanPodcast",
"http://www.pirateweather.com/weather/podcast/90033",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/worldservice/documentaryarchive/rss.xml",
"http://www.eonline.com/static/feeds/podcasts/video/daily10/index.xml?rss_daily10",
"http://feeds.feedburner.com/GabberJawjohnAndWendy",
"http://feeds.feedburner.com/islamradionetwork",
"http://fairygodmotherpodcast.libsyn.com/rss",
"http://feeds.pseudopod.org/Pseudopod",
"http://radio.disney.go.com/podcasts/radio_disney_now.xml",
"http://www.oakfan.com/BDHVodcast.xml",
"http://www.irishmusicpodcast.com/xml/irishMusicPodcast.xml",
"http://gplanet.hipcast.com/rss/planit_podcast.xml",
"http://www.tuneinrealestate.net/listen/?feed=rss2",
"http://www.nbc5.com/podcast/topstory.rss",
"http://teetour.com/podcasts/GolfSmarter.xml",
"http://feeds.feedburner.com/podchef",
"http://www.360thepitch.com/fork/rssor.php",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/fivelive/thefootballphone-in606/rss.xml",
"http://broadband.wgbh.org/nova/rss/novasciencenow.xml",
"http://feeds.feedburner.com/thezashow",
"http://www.catfishshow.com/casts/dircaster.php",
"http://www.history.org/media/rssfeeds_cw.xml",
"http://podcasts.nhl.com/feb07/insider.rss",
"http://feeds.feedburner.com/savvysolocast",
"http://www.thefredcast.com/The_FredCast.xml",
"http://feeds.feedburner.com/dailyplanettv",
"http://feeds.ziffdavis.com/ziffdavis/dltvh264video",
"http://www.jvond.com/podcast.xml",
"http://feeds.feedburner.com/EclecticMix",
"http://frenchpodclass.com/rss",
"http://feeds.feedburner.com/EdTechTalk?q=feed",
"http://feeds.feedburner.com/sidepodcasttv",
"http://feeds.odmcast.com/ondigitalmedia",
"http://feeds.feedburner.com/IrishFireside",
"http://feeds.feedburner.com/EnglishTeachingInJapan",
"http://www.washingtonpost.com/wp-srv/mmedia/photo_podcast.xml",
"http://www.npr.org/rss/podcast.php?id=11",
"http://tunesentertainment.libsyn.com/rss",
"http://karate.thepodcastnetwork.com/feed/",
"http://feeds.feedburner.com/extrapoints",
"http://feeds.feedburner.com/TheFoodGeek",
"http://www.sesameworkshop.org/podcasts/pinky_dinky_doo/pinky_podcast/",
"http://feeds.feedburner.com/RhettandLinKast",
"http://www.saddoboxing.com/feed/rss2/",
"http://mathfactor.uark.edu/feed/",
"http://podcasts.ricksteves.com/ricksteves.xml",
"http://www.mondominishows.com/rss/harddrinkinlincoln.xml",
"http://feeds.feedburner.com/daveandjoel",
"http://www.edhorrell.com/talkaboutservice/rss.xml",
"http://www.nationalcomment.com/nationalcomment.xml",
"http://www.spotlight-online.de/podcast/rss.xml",
"http://fullcontacttmd.mypodcast.com/rss.xml",
"http://tamegoeswild.jellycast.com/podcast/feed/3",
"http://www.surfsessionreport.com/surfsessionreport.rss",
"http://feeds.feedburner.com/tDp/C2C",
"http://feeds.feedburner.com/RockstarEnergyMotorsports",
"http://heroescast.libsyn.com/rss",
"http://feeds.reuters.com/reuters/video/worldupdate/rss/mp4/",
"http://feeds.feedburner.com/steelers",
"http://feeds.feedburner.com/Swingercast",
"http://weightloss.podomatic.com/rss2.xml",
"http://www.npr.org/rss/podcast.php?id=1066",
"http://feeds.feedburner.com/AthlonsportsInsideRacingPodcast",
"http://www.sfmoma.org/rss/podcasts.xml",
"http://www.templeemanuelofbaltimore.org/audio/rss.xml",
"http://www.budgettravelonline.com/bt-srv/podcast/podcast.xml",
"http://linktv.org/cgi/database/mosaic_rss.xml",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2090484",
"http://feeds.feedburner.com/wam#",
"http://feeds.feedburner.com/PathwayToHappiness",
"http://www.podtech.net/?feed=rss2",
"http://www.animalwiseradio.com/AWRRSSFeed.xml",
"http://www.nature.com/nature/podcast/rss/nature.xml",
"http://feeds.feedburner.com/yankees",
"http://martyrobertsblog.com/WordPress/feed/",
"http://kevindevin.com/wp-rss2.php",
"http://feeds.feedburner.com/herroflomjapan",
"http://feeds.feedburner.com/quranweeklypodcast",
"http://www.breakawaycontent.com/clients/discovertasmania/feed",
"http://spencerreynolds.podomatic.com/rss2.xml",
"http://feeds.feedburner.com/bitterestpillaudio",
"http://www.washingtonpost.com/wp-srv/mmedia/plotkinpodcast.xml",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2544461",
"http://learninggerman.mschubertberlin.de/podblog/rss.php",
"http://www.stanford.edu/group/edcorner/uploads/podcast/EducatorsCorner.xml",
"http://feeds.feedburner.com/bionicgloves_golf",
"http://www.kenradio.com/rss.php",
"http://engineeringworks.tamu.edu/?feed=rss2",
"http://rss.conversationsnetwork.org/channel/siconversations.xml",
"http://nateanddi.com/rssfeed.xml",
"http://www.asaudilife.net/Podcasts/A_Saudi_Life/podcast.xml",
"http://coffeegeek.libsyn.com/rss",
"http://kcrw.com/podcast/show/at",
"http://rss.mac.com/dawnmonarch/iWeb/Site/Listen/rss.xml",
"http://feeds.feedburner.com/tennisworldradio",
"http://www.washingtonpost.com/wp-srv/mmedia/vipod.xml",
"http://fourthtimearound.libsyn.com/rss",
"http://www.ipodtraveller.net/dtd/iPod_Traveller_RSS_Feed.xml",
"http://www.catdrinkingsongs.com/mp3/CatLovers.rss",
"http://www.eslbusinessnews.com/eslbn.rss",
"http://feeds.feedburner.com/atsprofits",
"http://puckpodcast.hipcast.com/rss/puckpodcast.xml",
"http://feeds.feedburner.com/motivationtomove/bKoG",
"http://feeds.feedburner.com/osmutantespodcast",
"http://podictionary.libsyn.com/rss",
"http://jeffboggis.blogmatrix.com/index.xml",
"http://www.geocities.com/bocarandasteve/rss3",
"http://feeds.feedburner.com/educastsbybenwilkoff",
"http://www.anime-bliss.com/podcast/feed.xml",
"http://www.npr.org/rss/podcast.php?id=1032",
"http://feeds.feedburner.com/DesperateHusbands",
"http://www.gregroachonline.com/spiritofplace/rss.xml",
"http://www.indymogul.com/rss",
"http://hiptranquilchick.libsyn.com/rss",
"http://feeds.feedburner.com/EntrepreneursJourney",
"http://www.donateyourweight.com/show/better.xml",
"http://www.betweentheropes.com/category/the-show/feed",
"http://www.dancarlin.com/dchh.xml#",
"http://www.rjino.com/johnparrpodcast1.xml",
"http://itbb.libsyn.com/rss",
"http://www.christopherreddick.com/podcast.xml",
"http://www.doctorfloyd.com/blog/rss.xml",
"http://feeds.feedburner.com/DavidMaisterVideocast",
"http://www.mixbroadcast.com/podcasts/the_artois_tennis_podcast.xml",
"http://feeds.feedburner.com/TFTvideopodcast",
"http://dismay.blogmatrix.com/index.xml",
"http://www.meanderingmouse.com/rss.xml",
"http://dgold.info/radio/webcast/podcast/feed/",
"http://www.parentsjournal.com/podcast/TPJ.xml",
"http://ppscme.org/ndei/podcast/clinical_insights.xml",
"http://www.effectiveedge.ca/podcast/podcast.php",
"http://www.thehalfshow.libsyn.com/rss",
"http://www.tipsfromthetopfloor.com/wp-rss2.php",
"http://feeds.ziffdavis.com/ziffdavis/dltvpodcast",
"http://recordings.talkshoe.com/rss10.xml",
"http://www.coffeegeek.com/podcasts/cgpodcast.xml",
"http://www.bazmakaz.com/andycast/?feed=rss2",
"http://media.kcrw.com/podcast/show/at",
"http://travelnursingpc.travelnursing.libsynpro.com/rss",
"http://todayshealthyfamily.com/feed",
"http://www.compassionatecooks.com/podcast/podcasts.xml",
"http://www.onthewaytravel.net/otw_rss_feed.xml",
"http://feeds.feedburner.com/fitlife",
"http://griefcast.com/griefcast.rss_feed.xml",
"http://www.posingproductions.com/posingproductions_podcast.xml",
"http://www.npr.org/rss/podcast.php?id=9657621",
"http://www.g4tv.com/g4originals/podcasts/26/Freestyle_101_Video_Podcast.xml",
"http://violetblue.libsyn.com/rss",
"http://fitpod.libsyn.com/rss",
"http://www.cnn.com/services/podcasting/racing.report/rss.xml",
"http://www.podiobooks.com/bookfeed/14151/27/book.xml",
"http://feeds.feedburner.com/LoveMechanicsWithReneePiane",
"http://scripts.ign.com/rss/ign.podcasts.2.0.xml",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=28",
"http://www.pixelworkshop.com/illturnthiscararound/podcast/rss.xml",
"http://madmoneymachine.com/feed",
"http://feeds.feedburner.com/yogamazing",
"http://www.cyberears.com/podcasts/podcast_5060.xml",
"http://www.b-eye-network.com/xml/spotlights.php",
"http://podcast.chumcity.net/specialty/ft/2006/04/Fashion_Television_Weekly_Podcast.xml",
"http://podcast.theglm.org/show.xml",
"http://oneamericacommittee.com/podcast.xml",
"http://fitmindbody.audioblog.com/rss/creation_station.xml",
"http://www.washingtonpost.com/wp-srv/mmedia/tonypodcast.xml",
"http://feeds.feedburner.com/Wwwmathgradcom",
"http://www.qdnow.com/grammar.xml",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2733884",
"http://rss.time.com/web/time/rss/podcast/rss_bizpodcast.xml",
"http://podcast.nationalgeographic.com/wild-chronicles/",
"http://feeds.feedburner.com/CBSNewsOnLogoVideo",
"http://www.rowdy.com/podcast.xml",
"http://www.unityphx.org/message/unityphx.xml",
"http://dbsoundsystem.audioblog.com/rss/double_barrel_soundsystem.xml",
"http://bettergolfwithfitnessblog.libsyn.com/rss",
"http://www.g4tv.com/cinematechnocturnalemissions/podcasts/9/Cinematech_Nocturnal_Emissions_Video_Podcast.xml",
"http://www.skeksys.com/blog/tunesfeed.xml",
"http://bellobard.libsyn.com/rss",
"http://feeds.feedburner.com/TheCandidFrame",
"http://poweruser.tv/powerusertv.xml",
"http://business.podblaze.com/skin_business.xml",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=outofcharacter",
"http://www.mondominishows.com/rss/heavymetalguy.xml",
"http://www.teachersatrisk.com/?feed=rss2",
"http://leo.am/podcasts/itn",
"http://feeds.feedburner.com/americancliche",
"http://feeds.feedburner.com/AtomicSuburbia",
"http://feeds.feedburner.com/OrganicallySpeaking",
"http://www.animalsaloud.net/audio/PODCASTS/rss.xml",
"http://marketplace.publicradio.org/RSS/rss.xml",
"http://www.israelisms.com/rss",
"http://nhbnews.podomatic.com/rss2.xml",
"http://www.vinow.com/blog/?feed=rss2",
"http://djmeta4.podomatic.com/rss2.xml",
"http://gasradio.com/GasItUp/podcast.php",
"http://audiodharma.libsyn.com/rss",
"http://feeds.feedburner.com/romantic",
"http://sonic.libsyn.com/rss",
"http://daveslounge.libsyn.com/rss",
"http://feeds.feedburner.com/coverville",
"http://feeds.feedburner.com/PodsafeComedyCountdown",
"http://feeds.feedburner.com/marketingedge",
"http://radio538.nl/538/xml/rss/dancedepartment.jsp",
"http://www.foodguru.com/podcast/xml.xml",
"http://feeds.feedburner.com/soundsforsights",
"http://feeds.feedburner.com/lifeontap",
"http://www.accidentalcreative.com/ac-feed.xml",
"http://www.americantheatrewing.org/blog/DSC/atwrss.xml",
"http://www.mathaccordingtomike.com/Podcasts/math1200podcast.xml",
"http://feeds.feedburner.com/FrenchMaidTV",
"http://feeds.feedburner.com/ThatCatholicShow",
"http://www.norml.org/rss/normlnews_podcast.xml",
"http://feeds.feedburner.com/MBAPodcaster",
"http://feeds.feedburner.com/101usesforbabywipes",
"http://feeds.feedburner.com/maxoutradio",
"http://www.physiquetransformation.com/podcasts.xml",
"http://feeds.feedburner.com/jetsetshow",
"http://www.bc.edu/bc_org/avp/soe/cihe/cihe.xml",
"http://www.podshow.com/feeds/theultimate.xml",
"http://feeds.feedburner.com/twistedpickle",
"http://www.cbsnews.com/common/includes/podcast/podcast_chris_mavridis_1.rss",
"http://hearsomethingcountry.com/podcast/hearsomethingcountry02.xml",
"http://feeds.feedburner.com/BookVoyages",
"http://www.presentationministries.com/dbread/dbreadpodcast.asp",
"http://webjay.org/rss/playlist/chromegat/theafricansoundsproject",
"http://feeds.feedburner.com/ydndesignguide",
"http://feeds.feedburner.com/itap_videojournals",
"http://podcasts.engadget.com/rss.xml",
"http://feeds.feedburner.com/MeditationsForAmerica",
"http://feeds.feedburner.com/OnionNewsNetwork",
"http://www.weeklyanimereview.com/rss",
"http://astronomycast.com/podcast.xml",
"http://feeds.feedburner.com/sidepodcasttv/",
"http://chreestopher.libsyn.com/rss",
"http://www.newteacherhotline.com/shows/new-teacher-hotline/feed",
"http://feeds.feedburner.com/babble",
"http://www.theness.com/rss.xml",
"http://feeds.feedburner.com/speedofcreativity/main/edtech",
"http://feeds.cbsnews.com/podcast_60min_1",
"http://feeds.feedburner.com/Shellyspodcast",
"http://www.cybercountry.com/vodcast/CyberCountry-TheVideoPodcast.xml",
"http://feeds.feedburner.com/teenbizideas",
"http://feeds.feedburner.com/walks-of-a-lifetime",
"http://files.animetracker.com/Track-shun.xml",
"http://www.matthewholden.com.au/PodAsia/?feed=rss2",
"http://revision3.com/xlr8rtv/feed/wmv-large",
"http://cspodcast.libsyn.com/rss",
"http://www.aflmarketing.com/podcast/ideapeddling.xml",
"http://feeds.feedburner.com/JIMMPodcast",
"http://www.kpfa.org/podcast/pod.php?show=voicesofthemiddleeast",
"http://www.lovelongandprosper.com/podcast/?feed=rss2",
"http://streams.wgbh.org/online/clas/clas_performance.xml",
"http://www.wzen.org/podcast/podcast.php?com=1",
"http://edition.cnn.com/services/podcasting/all/rss.xml",
"http://feeds.feedburner.com/mtvnews/DailyHeadlines/Video",
"http://www.npr.org/templates/rss/podcast.php?id=510052",
"http://www.itod.tv/iTod.xml",
"http://feeds.newyorker.com/services/rss/feeds/fiction_podcast.xml",
"http://www.racehorseradio.net/rss/rhr_dmr.xml",
"http://www.woodsongs.com/podcast.xml",
"http://sportequip.hipcast.com/rss/the_tennis_podcast.xml",
"http://planetretcon.com/feed/feed.xml",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2786684",
"http://barelypodcasting.com/?feed=rss2",
"http://feeds.feedburner.com/DogCastRadio",
"http://www.gamespot.com/podcast/podcast.xml",
"http://slapcast.com/rss/johan0808/index.xml",
"http://feeds.feedburner.com/BoxingScoop?feed=rss2",
"http://www.sjeds.com/podcasts/spanish/countries/RSS_feed_maestra.xml",
"http://feeds.feedburner.com/sydcast",
"http://skepticality.libsyn.com/rss",
"http://www.npr.org/rss/podcast.php?id=510144",
"http://www.other-places.com/rss/index.xml",
"http://feeds.feedburner.com/MyHistoryCanBeatUpYourPolitics",
"http://feeds.pixelcorps.com/feeds/macbreakipod.xml",
"http://www.daviscup.com/shared/medialibrary/audio/mp3/daviscupradio.xml",
"http://leo.am/podcasts/leo",
"http://www.mediccast.com/podcasts/MedicCast.xml",
"http://www.hellthy.com/channels/hellthy-indierockpop-rss.xml",
"http://feeds.feedburner.com/GeekFuActionGrip",
"http://www.scubaradio.com/srpodcast.xml",
"http://www.secretpants.net/rss/secret.xml",
"http://www.discovery.com/radio/xml/dscfeatures.xml",
"http://feeds.feedburner.com/techarts",
"http://mbaworkinggirl.libsyn.com/rss",
"http://www.npr.org/rss/podcast.php?id=500001",
"http://www.pbs.org/wgbh/nova/rss/einstein-podcast.xml",
"http://www.g4tv.com/xplay/podcasts/6/XPlay_Daily_Video_Podcast.xml",
"http://www.ppimk.com/podcast/useful.xml",
"http://feeds.feedburner.com/TasteOfHow-to",
"http://feeds.feedburner.com/DuctTapeMarketingRadio",
"http://www.k9cast.com/podcast.xml",
"http://feeds.feedburner.com/JNewsLight",
"http://downloads.bbc.co.uk/rmhttp/downloadtrial/radio4/inourtime/rss.xml",
"http://broadband.wgbh.org/amex/rss/podcast_od.xml",
"http://godsamongstpoodles.com/GodsAmongstPoodles.xml",
"http://www.discovery.com/radio/xml/5takes_podcast.xml",
"http://feeds.feedburner.com/ThePoddogshow",
"http://patrickbsf.libsyn.com/rss",
"http://www.relationshiptalkpodcast.com/podcast.php",
"http://sports.espn.go.com/espnradio/podcast/feeds/itunes/podCast?id=2406595",
"http://www.pbs.org/wnet/religionandethics/rss/podcast.xml",
"http://thejazzsession.com/feed/",
"http://feeds.feedburner.com/BigLeagueBaseballReport",
"http://www.gcast.com/u/gunnar1073/main.xml",
"http://www.sixdegreestv.com/pod/podcast.xml",
"http://www.hbo.com/apps/podcasts/podcast.xml?a=addiction",
"http://www.chinesepod.com/podcast.php",
"http://feeds.feedburner.com/Delicious/jsh177/mp3jasonheath",
"http://markdaycomedy.blip.tv/?skin=rss",
"http://geekacres.libsyn.com/rss",
"http://feeds.feedburner.com/cultofuhf",
"http://www.harvest.org/podcast/feed.php/anb.xml",
"http://audioaddict.libsyn.com/rss",
"http://www.brickfilmspodcast.com/podcast.xml",
"http://www.gorillasoapbox.com/podcasts/Dr_Jenns_Den/dr_jenns_den.xml",
"http://pe.robocaster.com/rss-pe_com-sports-boxing-vitindex_html.xml",
"http://www.npr.org/rss/podcast.php?id=35",
"http://feeds.feedburner.com/FlowVideo",
"http://awborg.libsyn.com/rss",
"http://bigshow.libsyn.com/rss",
"http://www.hightimes.com/potcast/potcast.rss",
"http://www.englishteacherjohn.com/rss/rss.xml",
"http://joepodcaster.libsyn.com/rss/",
"http://www.wubbcast.com/rss",
"http://www.360thepitch.com/fork/rsskc.php",
"http://feeds.feedburner.com/JawboneRadio",
"http://feartheboot.libsyn.com/rss",
"http://www.pirateweather.com/weather/podcast/10001",
"http://winecast.net/wp-rss2.php",
"http://www.salesroundup.com/feed.xml",
"http://www.indymedia.ie/rssmediacast.xml",
"http://feeds.feedburner.com/bodybuildinglive",
"http://feeds.feedburner.com/kidswifeworklife",
"http://www.earthwalk-usa.podomatic.com/rss2.xml"
#endregion 
            };
        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindPodcasts;
            FindPodcastsFilter filter = new FindPodcastsFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = filter.Locale;

            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50 }, new uint[] { 90, 10 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 3, 5 }, new uint[] { 5, 95 });

            filter.PodcastType = StressHelper.GetInputValue(new int[] { 1, 2}, new uint[] { 90, 5});

            //filter.MediaUrls = 
            uint[] arraySize ={ 1, 2 };
            uint[] arraySizeDistributions ={ 99, 1};


            filter.MediaUrls = StressHelper.GetInputValue<string>(MediaUrlsFilters, arraySize, arraySizeDistributions);

            filter.OrderBy = StressHelper.GetInputValue(new int[] { 1, 2}, new uint[] { 90, 5 });
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 95, 5 });


            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }


    [StressTest(Priority = 1000)]
    public class StressFindPodcasts_MediaIds : QueryStressTestBase
    {
        //const string PodcastGroup = "1FCE7A76-92F2-42FD-BBB3-";
        const int PodcastNum = 1000;

        public static Guid[] MediaIds = StressHelper.CreateGuidArray(
           new String[] { 
        #region PodcastIds
            "81248D8A-B351-4BED-BD04-007D8E570037",
"EB4B5694-E357-4790-BE86-016F51B805EC",
"E7FFA962-E640-4C6F-8C80-0173A4D723E0",
"E29D6374-52F7-4DCE-AB8B-01D2ABD2A9FE",
"EC5E6321-A595-47AB-B3D8-01F0F9E3EB62",
"6C5EA843-2C50-45F7-B806-01F23B14ADEE",
"D9B298DB-2085-4F22-A144-0233CA426DE1",
"2E87D24F-2EC9-4F69-A662-02392D0A765D",
"EB3BD978-5BEC-4427-ADE2-029A57B6AD82",
"29B5D398-DCF8-4B68-8107-02BA8CB76139",
"A4E6F30D-1CC4-4B93-B918-03428E9AAAC1",
"9C3EC344-4878-438F-BD0B-034916A74F5B",
"B43C6FF8-1689-47D1-A8BB-034F035A3DD9",
"C69A32EA-E8BA-41DD-9DBA-0390A83694A2",
"191F6397-E797-4994-AED6-03D2DF2761F7",
"E88C5955-EB36-429E-BAD9-03F0ECF4A4B5",
"71928F55-3888-4826-A2DA-03F24B0C94FB",
"3E8D70A9-DF3A-4095-A703-0436DCE69AD9",
"3EF37863-65EA-4180-96A3-0454FBD98FD8",
"C3886813-56FC-4686-BC4B-048B6A3043DE",
"6656D634-0610-40BD-8C2A-048C7DBBFAA1",
"CE65FFCB-4444-43F9-A408-04BFA342E6F2",
"92F4E50F-285D-4BB7-9DE0-04D39E99046F",
"812D8CD2-C70F-430B-96AB-04E58147C8E1",
"1F14F7EF-2169-4FDE-B7E1-0509E570BEBF",
"E955940B-D4FB-49BE-AFFC-059D04051A64",
"225D1542-6294-4A05-B771-05FF1F88BF28",
"6DC7F354-3B28-485A-8178-0631EA21E7FD",
"EA895AA9-DE52-4453-AB94-06CCA828F818",
"49248BEF-A4FD-4C0B-9B3D-06E2004334E7",
"75E6AF7A-9313-4CD1-86C4-076C97C4A4E9",
"D0AC6947-5247-42FB-9C6F-07D5C4050473",
"983B23B4-CB34-4256-9E5E-07FEA017CA36",
"922FBFB1-2E61-4A4A-9244-0802BCC6F8EF",
"BBFCD08D-DD47-4928-A21E-08084DDF72C0",
"91C7FBD1-1EDC-45C3-9C7A-08129F662A4E",
"A2C7922E-AD4E-4274-A0E7-0817E7CC5F42",
"CB69744E-8817-44B8-8FD6-084B55B92C97",
"E5921C0C-B139-4570-ACA5-0890B6389306",
"C5B4277D-DB0B-438E-88FF-095608031228",
"A2D7B234-26C8-4394-ABF6-09780BFD0518",
"E20A8067-5398-4E5D-9475-09BB2D498B2F",
"3789B928-C016-4AEC-A097-09E029201FE7",
"E7F6E5DA-4045-4732-8E21-0A2D63031037",
"828EF4BD-916D-47E6-9853-0B5F8E9ADDC9",
"24B3A17E-6F2B-4CB5-A723-0B8FAF7EB427",
"C00284BB-44F2-4465-B434-0BB462C28FEB",
"4C6A9387-E147-487E-9392-0BCDC3F7F74F",
"CE52B992-323A-4E8A-A499-0BDA956602AC",
"7F4307CA-9EC6-4414-AF8E-0C94010ABFA5",
"95EAC701-98F0-426C-9D6C-0CEEDD3FA512",
"7BD6ADC7-1736-4F72-BA96-0D955B449A35",
"585FC1AB-1D92-40C2-AD6D-0DE04B50C8EF",
"CC11DD7F-382D-40D7-9EDC-0ECA1E908241",
"237E45BF-7DD0-42C6-89F0-0ECC42A37BA1",
"493E11BD-DD8D-4006-8D96-0EEF9B06840C",
"8BC7A69F-2C1F-43EF-8D6E-0F3928629E7A",
"2E4A6004-7F70-49B3-A33C-0F488E727576",
"97CD1B93-DA24-4300-B99A-0F7C8470B9AB",
"DB7E0F7A-B796-487E-8646-0F9F81C79F85",
"BB153540-01EE-4F7E-BFDF-0FAACEB270C2",
"8979F8F6-DB89-4476-9B0F-0FF257A0B360",
"BFBC95D1-8B56-4689-8F83-1021EF74E56C",
"71731C64-9539-4F8A-A890-104F87C96DB2",
"B1CB83CD-9702-4976-8A16-10D513C20FF7",
"24990FC5-31DB-4D6B-A716-10EF61AD6AE9",
"91A6F76B-2205-427E-A131-113FA5774313",
"3C66C7FA-FD67-4035-B6A3-1226BA40EF71",
"7BC3D44B-AF7C-4E92-8643-125138C0320C",
"E250A746-4BFE-40CF-B373-1252E0961D38",
"51A5CE15-A483-4D16-AD42-1270C7C77327",
"DBCF2237-34C1-46E4-942B-128D69BD7191",
"BE907631-2FDD-48B5-B81B-12F4B0FD689E",
"B6B047B9-CDC7-48A9-AEEC-13A683F43C81",
"77758B55-AE99-4EC6-A8CC-13B6A78350A6",
"05917293-158D-4AE5-8F0C-13E34D042DEE",
"C4E30B86-26D5-4BD9-AF0E-1498141D8094",
"DB0E499E-9E51-4B72-8802-151109DC9AC0",
"54622634-81CF-4244-B3A2-1593BC4204DF",
"DE10CA5A-A6C4-4068-8F80-15B3A309F5FB",
"3FBB9280-676F-4E85-80D8-1718A6383B3E",
"801F52F0-B218-48E0-AD52-171A5D512D82",
"6D046BB5-A61B-453F-ABA0-17799114345E",
"B15E5789-A9FB-4AF3-8EB6-178261104BA3",
"754E9C58-1BDF-4AE5-B067-17ABEFF0B878",
"A096B9DB-97FF-4242-A4F9-17DC73AC60AA",
"B27A5875-CC3E-465C-8622-181D82B0924A",
"5EDBC446-C241-4D1F-AF15-18A8AB357B96",
"E5B2E4E3-8EE3-4943-9A54-18C2E1EF2D67",
"27B78864-E875-4433-ABC1-18E7493B4E4F",
"F94D2225-BCA9-456F-8FA9-18F9C26751FE",
"921110F2-FF29-4DBE-9509-1A58BBCD8E46",
"60978263-2013-4E05-AB91-1A6B77B10C4E",
"B907A839-F922-46D0-B103-1CCA40F3081A",
"45684D3D-DC8C-43DF-9B6D-1CCF30060FBB",
"4E93F654-EE65-4963-8BE8-1D1202CBFB7B",
"1C7D3307-E729-4004-AAD2-1D432166ED17",
"C89DEA6E-E1C6-4424-B31B-1D561C7B7B32",
"144D9387-A905-4F5B-8602-1DC110B8D2F9",
"E24DADD7-B6C8-4169-90BA-1DC1A7A52D40",
"55C07B77-6BA9-4248-9D41-1DD073D41231",
"0495BF1E-4273-4C9B-9A09-1E18BF7D59DD",
"D14F3D11-DF57-4375-AB79-1E242110A38B",
"AC6CA101-7295-4DE1-BB8C-1E5E14381D18",
"EF5AA151-719E-4E80-8020-1E6CB4C2BB95",
"5F7AE3D2-4381-4A49-B823-1E7B6CF80CA9",
"451C02B2-6D8E-4495-B3A9-1E9D07B2E77B",
"3D84A280-9820-4F68-A2FA-1EBB5A6111C9",
"6B0C6762-E788-4304-B1D2-1F07E8395E87",
"932433EC-3A36-4ED0-B29A-1F2DAC25B047",
"BA2C07D0-3305-407D-B31D-1FFFCCF4A12F",
"0D825C6A-FC8A-445F-8C67-208F5A351139",
"D6F113D3-E4A8-4B72-84DC-20F0EE66AE81",
"195A9150-0FD9-4571-9879-21068747BDC0",
"41A96BE9-D33F-45B9-BDB2-215BE94D05A5",
"6029B1DD-9496-4044-BA95-21B9AAD72324",
"F78EC36E-1D51-48B8-A1E3-21DCA80A2E44",
"2CD9CE89-C943-4AAC-87B9-2205FA0F3672",
"A47730FD-D2D5-4604-A8A3-2233FE8FF709",
"6DE02E63-35EE-45B0-8163-2237E89F60EA",
"A28818F1-B7FF-4122-9CE5-2270C3630CCA",
"8E681D09-3D29-4507-99B4-227D60B5226E",
"E38EDF66-EA94-49D4-8F9C-22B6DAFCB39B",
"3AB7F3DB-3015-42C6-BE8E-231E259E30F4",
"52AD3B5C-9BBD-40C4-8CCE-2347020B61F2",
"BADE60C5-F62E-44D1-9AF6-23B261C6E8DB",
"48A79EE0-46D2-4F8F-B31F-23FB922848D4",
"7D12257A-3D7E-48AB-945E-2448F5DC3AA1",
"8E8BFE66-09D7-45DE-882D-245464D38581",
"22ED1E8F-0B76-4D8E-A580-2458BABF2884",
"948992A4-4905-4CA6-A3F6-249DA06C7043",
"1352C89A-579D-44A9-9BE3-24DBA397AFC0",
"843DC956-8D29-4D83-9F56-25722C969927",
"AEF24F12-43F6-4265-B155-25AEE66AD368",
"D28BBA11-290B-480C-A08B-25F5BA9C8189",
"26B8BCCB-5A89-4551-B97C-26116BE3A5FD",
"B630973F-870B-4755-99FF-26707A528DEF",
"F9D58F59-ABB2-4313-BE0B-276521706EFB",
"E11A04BB-4D97-498F-9869-2796B803ADA3",
"0F3CCA22-1915-4A8F-80EF-28068A551E67",
"CE0D2FD1-8B28-4D07-98BF-280E021EA636",
"EB8C840E-E51B-488D-8BEA-2960A233BAB4",
"BAF978BF-F0E6-4F96-8220-29C6424F89AE",
"3B5FA07B-C2E0-4E43-A814-2B1F1FF21198",
"CD979060-F614-4AB4-AC1A-2B41FD4C4357",
"E74CF131-0F1C-4183-A3F2-2B58978FEA99",
"BCC623E8-4268-4F08-A278-2BD5013FDC89",
"98C9681B-F5FE-4ED8-9B26-2BE68B49F4A2",
"2645A82E-7AB3-4D07-9667-2C0D9BF8D879",
"DDD22B2E-085E-4B52-B283-2C3B6113E90F",
"0EF115FE-9030-463D-9DBC-2C6F5BAA65BC",
"7218799B-34A1-4203-9A17-2CC28EE1B781",
"7445621C-3FE7-4EAC-BC95-2D39FC1FFB4C",
"59CE66AE-408E-4ADA-912B-2D3B4A854738",
"03BCB3CB-D25F-4AE1-8A10-2D9BE7B77956",
"22D4217E-59A4-4C4E-BAC7-2DE8ADCE2B6E",
"CA0CD4E7-6B1C-4D65-BE75-2DFD564D717E",
"437D1D51-9221-4F1F-9371-2E05463D37F9",
"6424FAD0-FC9C-4521-B9CA-2E0B3256E4B5",
"F2F0BBE9-27AF-4EC2-BF18-2FAAA2832B87",
"C59F2805-96E6-4F35-81D7-2FAEE42484B6",
"B05C8D2C-DB12-4CFA-B8AE-300BE93B9459",
"931784B5-61C4-49D4-B1A4-30DEDD961448",
"1A8750AA-4FDC-4951-B998-30EE5DCA62C1",
"203C1571-FEAA-4A50-B640-312BF97D9FF8",
"76E59DF5-3FD5-4B1A-9737-315120E1A8AE",
"F5EFD29E-C8A9-438A-BF1A-315659B9F4D1",
"AD8CE56B-2591-4A8D-9404-319D324F54AC",
"EB6FC794-5FFC-4DE5-961C-31A438A16F14",
"133B9985-59A5-4552-BBF4-31D9C345D52A",
"7EEEB60E-711D-4745-8B95-31ECBB2DEBD6",
"C0974623-7184-4062-A382-3204142BEE44",
"B946BCD4-C4F8-4AC1-BBE6-320CA9B47B74",
"B8F9C7DD-5018-4890-B6E7-320D3B01FC39",
"2E50564F-C5D5-4781-BCCB-32496357A5D4",
"1903E6B0-E297-4DAA-8E54-327BC7DB75B2",
"A0593BE0-AAA0-4620-BFD7-32D345687EFE",
"5F59CC3B-34A0-46AA-92D5-32D4085D76CE",
"49C2E619-514B-4B78-B66F-3363AB066F40",
"950F7034-07DC-487F-8699-337D325CFD0D",
"AB73042A-AF2C-467C-8625-33F4B94488DA",
"E94FE228-50B4-4A51-AA39-346724D66DA5",
"60EEAE00-32C7-4F13-A126-34CF6CCB2079",
"2E4C232C-42C8-4465-A6D1-34E760448876",
"EC7BD573-FADF-427E-86A9-3531BC17C41C",
"ECAA8D89-6811-43B3-AD67-3581E2AE068A",
"12C69DF5-D514-4093-8D11-358B6C12E632",
"8C34318D-DA51-472D-A147-359C5EDF775E",
"CF75D9AF-3D84-49AA-97C3-36D9144949D1",
"60A504BA-B4C0-4743-95CC-370C9648FE08",
"CB21297A-E599-4529-AF5D-375D16342774",
"C12931C3-9F60-415A-B1F1-375FD8BFAA9D",
"47892F80-4341-4824-8908-37E64CF6CA0D",
"865E6EE4-FB4F-4840-88A8-38897CF5220A",
"2CC3394C-E8C5-41A0-81A3-38AEBF018617",
"170FC5FB-96A0-4E82-A419-38F0ED3F25B6",
"63CEC98B-E257-495F-BC5B-39063403A157",
"1FC6AEB0-79C0-4B56-9781-395DE5A72C15",
"AD2ED93A-0AD7-418B-8FC5-397F69E794A3",
"916A8BEE-F633-403F-8E08-3981FE264551",
"FFAFBBCD-BC24-404D-A027-3A3A74C907D8",
"F40949BF-6FF4-4159-A63B-3AE50C0E4527",
"95FB45C1-858E-43A1-A21E-3B71D0CE4497",
"7E79905E-0B40-4EDD-99A7-3B8A14EAFD0A",
"1126505E-F6CC-4878-8F4E-3C6E6429066F",
"5537DBB7-5471-458F-A2F0-3C6F201C3C90",
"E136562F-53E9-415C-AB8D-3CA81E376B5A",
"E43264D2-8983-43EF-A657-3CCC4502B8DD",
"CD79F6C7-0845-429A-8BE2-3D3EE12CD544",
"6CAE5C83-4052-4BE5-85F7-3D8231E8BF8F",
"9D3A7069-DCBD-445C-B925-3DB5D6735DA0",
"43B1D59F-FA41-4422-B2F4-3E48C181EDB5",
"71FD7CE6-0FE1-40ED-97AF-3E50DF9ECBA3",
"13E5A244-F8B7-4E43-BE98-40677FC9D0B3",
"DAED677B-4CAE-423C-9560-40D07E0482C2",
"DE483EDE-144D-4C79-BE61-41C6718563C4",
"4DC3F4D7-D93C-4B72-AB5A-422A3BED7F2A",
"6AF27EF8-E400-4351-B02A-423921C7607A",
"4D6BC557-7BD6-44B3-BCAE-4286A59A809C",
"EF1841B4-37A2-4614-AEA2-42B9941A50C7",
"6CC6FA42-09AB-453C-BB4E-431F92F65223",
"BAA4CFBB-AED0-4905-BB30-4338C29E264B",
"2ACB246C-7952-454F-975A-43453713B17A",
"44D54D46-E32E-4374-B6C1-436470F4EE95",
"4C230166-3E6B-462A-845E-442396E797E7",
"A8D78100-D742-4313-BA62-44545DCFA914",
"1D93D0B5-26EE-4C3C-9DD6-4570432E8DAF",
"D01EDD8F-4644-4D05-A26E-45822D11387D",
"A0DD0176-7431-4DDF-85B9-458F4484E226",
"44E87A93-DC40-4237-85F3-45C15ED2A26B",
"BBD2384E-84A8-4164-B115-460438B18F07",
"B3F8C535-D9BB-4CF6-A5F7-460709F4F539",
"5FB93AC9-F5C2-4D76-9427-4629A45720F2",
"A1723BA3-4972-4500-9179-462B57A02D94",
"4B7B9189-D79D-4366-9AD4-4670563CA0D7",
"B74400C4-5842-4387-871F-467E7B877A5D",
"6516A35D-1561-4E7F-96AB-4687AF84B6F5",
"9DABAD87-9E69-49DD-B030-46E473FDCD99",
"EEBD1C23-FED9-4C55-A8B2-471593ADB0B9",
"310A0803-A361-4920-AE6F-4744F1BAB14F",
"80FB19CB-65E6-4708-8A7D-478021510BF6",
"E42F3D5C-59DD-4EBB-A701-478E89C9A01E",
"FC3ADEA4-DA7A-40DB-90A9-480708A455E5",
"BC926E3F-5634-4510-9A23-4892425316B0",
"1EDE062D-CF15-483D-95B3-48CFD6F37E52",
"73516921-BE3E-4A8D-BE4D-48D2444420A7",
"06F34B3D-87E5-4AB9-B7B8-48F36D8B5DE1",
"DE7996C8-8697-43FF-9D3D-491041A2BDF5",
"4071A171-D8E7-420D-8453-49773D02D5A1",
"F02E3753-0931-4669-8235-497F87D97E5C"
 #endregion 
            }
        );
        protected override void Init()
        {
            base.Init();


            MethodName = QueryRequestBase.QueryMethod.FindPodcasts;
            FindPodcastsFilter filter = new FindPodcastsFilter();
            filter.Locale = "en-US";
            filter.LegalLocale = filter.Locale;

            
            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50 }, new uint[] { 80, 20 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 3, 5 }, new uint[] { 90, 10 });

            filter.PodcastType = StressHelper.GetInputValue(new int[] { 1, 2}, new uint[] { 90, 5});

            uint[] arraySize ={ 1, 5};
            uint[] arraySizeDistributions ={ 90, 10 };

            //int idsSize = (int)StressHelper.GetInputValue(arraySize, arraySizeDistributions);

            /*filter.MediaIds = new List<Guid>();

            for (int i = 0; i < idsSize; i++)
            {
                filter.MediaIds.Add(StressHelper.CreateGuid(PodcastGroup, RandomEx.GlobalRandGen.Next(0, PodcastNum)));
            }*/

            filter.MediaIds = StressHelper.GetInputValue<Guid>(MediaIds, arraySize, arraySizeDistributions);

            filter.OrderBy = StressHelper.GetInputValue(new int[] { 1, 2, 3, 4 }, new uint[] { 90, 1, 1, 1 });
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });


            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }

    [StressTest(Priority = 1000)]
    public class StressFindVideos : QueryStressTestBase
    {
       static FindVideosFilter samples(int DetailView, int OfferFilterLevel, int MediaTypes, int ImageTypeIds, int ImageFormats,           
           int ImageSizes, int OrderBy, int OrderDirection, int [] categoryIds){
          FindVideosFilter f = new FindVideosFilter();
           f.DetailView=DetailView;
           f.OfferFilterLevel=OfferFilterLevel;
           
           f.MediaTypes=new List<Int32>();
           f.MediaTypes.Add(MediaTypes);
           
           f.ImageTypeIds = new List<Int32>();
           f.ImageTypeIds.Add(ImageTypeIds); ;
           
           f.ImageFormats = new List<Int32>();
           f.ImageFormats.Add(ImageFormats);

           f.ImageSizes = new List<Int32>();
           f.ImageSizes.Add(ImageSizes);
           f.OrderBy=OrderBy;
           f.OrderDirection=OrderDirection;

           if (categoryIds!=null) {
             f.CategoryIds = new List<Int32>();
               
             foreach( int id in  categoryIds)
                 f.CategoryIds.Add(id);
           }
           return f;
       }

        static FindVideosFilter samples(int DetailView, int OfferFilterLevel, int MediaTypes, int OrderBy, int OrderDirection)
        {
            FindVideosFilter f = new FindVideosFilter();
            f.DetailView = DetailView;
            f.OfferFilterLevel = OfferFilterLevel;

            f.MediaTypes = new List<Int32>();
            f.MediaTypes.Add(MediaTypes);
            
            f.OrderBy = OrderBy;
            f.OrderDirection = OrderDirection;

            return f;
        }
        static FindVideosFilter[] fitlers = inputGen();
        static FindVideosFilter[] inputGen(){
            FindVideosFilter[] filters = {                
            // Top Movies
            //DetailView=3,OfferFilterLevel=2,MediaTypes=2,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=4,OrderDirection=2
             samples(3, 2, 2, 12, 4, 1, 4, 2, null),
            //Movies New Arrivals
            //DetailView=3,OfferFilterLevel=2,MediaTypes=2,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 2, 12, 4, 1, 2, 2, null),
            //Movies Featured Trailers
            //DetailView=3,OfferFilterLevel=2,MediaTypes=32,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=1,OrderDirection=1,
             samples(3, 2, 32, 12, 4, 1, 1, 1, null),
            //Movies Clips
            //DetailView=3,OfferFilterLevel=2,MediaTypes=39,CategoryIds=1343,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2"
             samples(3, 2, 39,  12, 4, 1, 2, 2, new int[]{1343}),
            //All Movies
            //DetailView=3,OfferFilterLevel=2,MediaTypes=2,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=1,OrderDirection=1,
             samples(3, 2, 2, 12, 4, 1, 1, 1, null),
            //Top TV Episodes
            //DetailView=3,OfferFilterLevel=2,MediaTypes=8,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=4,OrderDirection=2
             samples(3, 2, 8, 12, 4, 1, 4, 2, null),
            //TV New Arrivals
            //DetailView=3,OfferFilterLevel=2,MediaTypes=8,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
            //TV Clips
             samples(3, 2, 8, 12, 4, 1, 2, 2, null),
            //DetailView=3,OfferFilterLevel=2,MediaTypes=39,CategoryIds=1344,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 39, 12, 4, 1, 2, 2, new int[]{1343}),
            //All TV Shows
            //DetailView=5,OfferFilterLevel=1,MediaTypes=10,OrderBy=1,OrderDirection=1,
             samples(3, 1, 10,1,1),
            //Music Videos
            //DetailView=3,OfferFilterLevel=2,MediaTypes=4,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 4, 12, 4, 1, 2, 2, null),

            //DetailView=3,OfferFilterLevel=2,MediaTypes=39,categoryIds=1343,categoryIds=1344,categoryIds=1345,categoryIds=1346,categoryIds=1347,categoryIds=1351,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 39, 12, 4, 1, 2, 2, new int[] {1343, 1344, 1345, 1346, 1347, 1351})};
                     
                return filters;
            }            

        protected override void Init()
        {
            FindVideosFilter[] filters = inputGen();
            base.Init();
            FindVideosFilter filter = fitlers[RandomEx.GlobalRandGen.Next(0, filters.Length)];
            
            MethodName = QueryRequestBase.QueryMethod.FindVideos;
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "fr-FR" }, new uint[] { 95, 5 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 1;  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 100, 50, 10 }, new uint[] { 50, 50, 50 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2, 3,4,5,6,7,8,9,10,11,12,13,14,15 }, new uint[] { 90, 80, 70,70,50,50,50,40,40,30,20,20,20,20,10});
            
            filter.UserTypes = new List<Int32>();
            filter.UserTypes.Add(2);


            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
            string s = ((live.protocol.next.GenericQueryRequest)(req)).CustomRequest;
            ((live.protocol.next.GenericQueryRequest)(req)).CustomRequest=s.Replace("&Names=VideoFilter&Values=0", "");
        }
    }

    [StressTest(Priority = 1000)]
    public class MaxAgeStressFindVideos : QueryStressMaxAgeTestBase
    {
        static FindVideosFilter samples(int DetailView, int OfferFilterLevel, int MediaTypes, int ImageTypeIds, int ImageFormats,
            int ImageSizes, int OrderBy, int OrderDirection, int[] categoryIds)
        {
            FindVideosFilter f = new FindVideosFilter();
            f.DetailView = DetailView;
            f.OfferFilterLevel = OfferFilterLevel;

            f.MediaTypes = new List<Int32>();
            f.MediaTypes.Add(MediaTypes);

            f.ImageTypeIds = new List<Int32>();
            f.ImageTypeIds.Add(ImageTypeIds); ;

            f.ImageFormats = new List<Int32>();
            f.ImageFormats.Add(ImageFormats);

            f.ImageSizes = new List<Int32>();
            f.ImageSizes.Add(ImageSizes);
            f.OrderBy = OrderBy;
            f.OrderDirection = OrderDirection;

            if (categoryIds != null)
            {
                f.CategoryIds = new List<Int32>();

                foreach (int id in categoryIds)
                    f.CategoryIds.Add(id);
            }
            return f;
        }

        static FindVideosFilter samples(int DetailView, int OfferFilterLevel, int MediaTypes, int OrderBy, int OrderDirection)
        {
            FindVideosFilter f = new FindVideosFilter();
            f.DetailView = DetailView;
            f.OfferFilterLevel = OfferFilterLevel;

            f.MediaTypes = new List<Int32>();
            f.MediaTypes.Add(MediaTypes);

            f.OrderBy = OrderBy;
            f.OrderDirection = OrderDirection;

            return f;
        }
        static FindVideosFilter[] fitlers = inputGen();
        static FindVideosFilter[] inputGen()
        {
            FindVideosFilter[] filters = {                
            // Top Movies
            //DetailView=3,OfferFilterLevel=2,MediaTypes=2,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=4,OrderDirection=2
             samples(3, 2, 2, 12, 4, 1, 4, 2, null),
            //Movies New Arrivals
            //DetailView=3,OfferFilterLevel=2,MediaTypes=2,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 2, 12, 4, 1, 2, 2, null),
            //Movies Featured Trailers
            //DetailView=3,OfferFilterLevel=2,MediaTypes=32,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=1,OrderDirection=1,
             samples(3, 2, 32, 12, 4, 1, 1, 1, null),
            //Movies Clips
            //DetailView=3,OfferFilterLevel=2,MediaTypes=39,CategoryIds=1343,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2"
             samples(3, 2, 39,  12, 4, 1, 2, 2, new int[]{1343}),
            //All Movies
            //DetailView=3,OfferFilterLevel=2,MediaTypes=2,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=1,OrderDirection=1,
             samples(3, 2, 2, 12, 4, 1, 1, 1, null),
            //Top TV Episodes
            //DetailView=3,OfferFilterLevel=2,MediaTypes=8,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=4,OrderDirection=2
             samples(3, 2, 8, 12, 4, 1, 4, 2, null),
            //TV New Arrivals
            //DetailView=3,OfferFilterLevel=2,MediaTypes=8,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
            //TV Clips
             samples(3, 2, 8, 12, 4, 1, 2, 2, null),
            //DetailView=3,OfferFilterLevel=2,MediaTypes=39,CategoryIds=1344,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 39, 12, 4, 1, 2, 2, new int[]{1343}),
            //All TV Shows
            //DetailView=5,OfferFilterLevel=1,MediaTypes=10,OrderBy=1,OrderDirection=1,
             samples(3, 1, 10,1,1),
            //Music Videos
            //DetailView=3,OfferFilterLevel=2,MediaTypes=4,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 4, 12, 4, 1, 2, 2, null),

            //DetailView=3,OfferFilterLevel=2,MediaTypes=39,categoryIds=1343,categoryIds=1344,categoryIds=1345,categoryIds=1346,categoryIds=1347,categoryIds=1351,ImageTypeIds=12,ImageFormats=4,ImageSizes=1,OrderBy=2,OrderDirection=2,
             samples(3, 2, 39, 12, 4, 1, 2, 2, new int[] {1343, 1344, 1345, 1346, 1347, 1351})};

            return filters;
        }

        protected override void Init()
        {
            FindVideosFilter[] filters = inputGen();
            base.Init();
            FindVideosFilter filter = fitlers[RandomEx.GlobalRandGen.Next(0, filters.Length)];

            MethodName = QueryRequestBase.QueryMethod.FindVideos;
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "fr-FR" }, new uint[] { 95, 5 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 1;  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 100, 50, 10 }, new uint[] { 50, 50, 50 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }, new uint[] { 90, 80, 70, 70, 50, 50, 50, 40, 40, 30, 20, 20, 20, 20, 10 });

            filter.UserTypes = new List<Int32>();
            filter.UserTypes.Add(2);


            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
            string s = ((live.protocol.next.GenericQueryRequest)(req)).CustomRequest;
            ((live.protocol.next.GenericQueryRequest)(req)).CustomRequest = s.Replace("&Names=VideoFilter&Values=0", "");
        }
    }

    [StressTest(Priority = 1000)]
    public class StressFindVideoOffers : QueryStressTestBase
    {
 #region MediaIds
        public static Guid[] TVEpisodeList = StressHelper.CreateGuidArray(            
        new string[] {
             "00010000-0002-0000-0000-000000000000",
             "00020000-0002-0000-0000-000000000000",
             "DE5CFB8A-0001-0000-0003-000000000000",
             "00010000-0002-0000-0000-000000000001",
             "00020000-0002-0000-0000-000000000001",
             "DE5CFB8A-0001-0000-0003-000000000001",
             "00020013-0008-0001-0113-000000000001",
             "00030003-0008-0001-0113-000000000001",
             "00010000-0002-0000-0000-000000000002",
             "00020000-0002-0000-0000-000000000002",
             "DE5CFB8A-0001-0000-0003-000000000002",
             "00020013-0008-0001-0113-000000000002",
             "00030003-0008-0001-0113-000000000002",
             "00010000-0002-0000-0000-000000000003",
             "00020000-0002-0000-0000-000000000003",
             "00020013-0008-0001-0113-000000000003",
             "00030003-0008-0001-0113-000000000003",
             "00010000-0002-0000-0000-000000000004",
             "00020000-0002-0000-0000-000000000004",
             "00020013-0008-0001-0113-000000000004",
             "00030003-0008-0001-0113-000000000004",
             "00010000-0002-0000-0000-000000000005",
             "00020000-0002-0000-0000-000000000005",
             "00020013-0008-0001-0113-000000000005",
             "00030003-0008-0001-0113-000000000005",
             "00010000-0002-0000-0000-000000000006",
             "00020000-0002-0000-0000-000000000006",
             "00020013-0008-0001-0113-000000000006",
             "00030003-0008-0001-0113-000000000006",
             "00010000-0002-0000-0000-000000000007",
             "00020000-0002-0000-0000-000000000007",
             "00020013-0008-0001-0113-000000000007",
             "00030003-0008-0001-0113-000000000007",
             "00020013-0008-0001-0113-000000000008",
             "00030003-0008-0001-0113-000000000008",
             "00020013-0008-0001-0113-000000000009",
             "00030003-0008-0001-0113-000000000009",
             "00020013-0008-0001-0113-000000000010",
             "00030003-0008-0001-0113-000000000010",
             "00020013-0008-0001-0113-000000000011",
             "00030003-0008-0001-0113-000000000011",
             "00020013-0008-0001-0113-000000000012",
             "00030003-0008-0001-0113-000000000012",
             "00020013-0008-0001-0113-000000000013",
             "00030003-0008-0001-0113-000000000013",
             "00020013-0008-0001-0113-000000000014",
             "00030003-0008-0001-0113-000000000014",
             "00020013-0008-0001-0113-000000000015",
             "00030003-0008-0001-0113-000000000015",
             "00020013-0008-0001-0113-000000000016",
             "00030003-0008-0001-0113-000000000016",
             "00020013-0008-0001-0113-000000000017",
             "00030003-0008-0001-0113-000000000017",
             "00020013-0008-0001-0113-000000000018",
             "00030003-0008-0001-0113-000000000018",
             "00020013-0008-0001-0113-000000000019",
             "00030003-0008-0001-0113-000000000019",
             "00020013-0008-0001-0113-000000000020",
             "00030003-0008-0001-0113-000000000020",
             "00010000-0002-0000-0000-000000000050",
             "00010000-0002-0000-0000-000000000100",
             "00020000-0002-0000-0000-000000000100",
             "00010000-0002-0000-0000-000000000101",
             "00020000-0002-0000-0000-000000000101",
             "00010000-0002-0000-0000-000000000102",
             "00020000-0002-0000-0000-000000000102",
             "00010000-0002-0000-0000-000000000103",
             "00020000-0002-0000-0000-000000000103",
             "00010000-0002-0000-0000-000000000104",
             "00020000-0002-0000-0000-000000000104",
             "00010000-0002-0000-0000-000000000105",
             "00020000-0002-0000-0000-000000000105",
             "00010000-0002-0000-0000-000000000106",
             "00010000-0002-0000-0000-000000000107",
             "00010000-0002-0000-0000-000000000108",
             "00010000-0002-0000-0000-000000000109",
             "00010000-0002-0000-0000-000000000110",
             "00010000-0002-0000-0000-000000000111",
             "00010000-0002-0000-0000-000000000112",
             "00010000-0002-0000-0000-000000000113",
             "00010000-0002-0000-0000-000000000114",
             "00010000-0002-0000-0000-000000000115",
             "00010000-0002-0000-0000-000000000116",
             "00010000-0002-0000-0000-000000000117",
             "00010000-0002-0000-0000-000000000118",
             "00010000-0002-0000-0000-000000000119",
             "00010000-0002-0000-0000-000000000120",
             "00010000-0002-0000-0000-000000000121",
             "00010000-0002-0000-0000-000000000122",
             "00010000-0002-0000-0000-000000000123",
             "00010000-0002-0000-0000-000000000124",
             "00010000-0002-0000-0000-000000000125",
             "00010000-0002-0000-0000-000000000126",
             "00010000-0002-0000-0000-000000000127",
             "00010000-0002-0000-0000-000000000128",
             "00010000-0002-0000-0000-000000000129",
             "00010000-0002-0000-0000-000000000130",
             "00010000-0002-0000-0000-000000000131",
             "00010000-0002-0000-0000-000000000132",
             "00010000-0002-0000-0000-000000000133",
             "00010000-0002-0000-0000-000000000134",
             "00010000-0002-0000-0000-000000000135",
             "00010000-0002-0000-0000-000000000136",
             "00010000-0002-0000-0000-000000000137",
             "00010000-0002-0000-0000-000000000138",
             "00010000-0002-0000-0000-000000000139",
             "00010000-0002-0000-0000-000000000140",
             "00010000-0002-0000-0000-000000000141",
             "00010000-0002-0000-0000-000000000142",
             "00010000-0002-0000-0000-000000000143",
             "00010000-0002-0000-0000-000000000144",
             "00010000-0002-0000-0000-000000000145",
             "00010000-0002-0000-0000-000000000146",
             "00010000-0002-0000-0000-000000000147",
             "00010000-0002-0000-0000-000000000148",
             "00010000-0002-0000-0000-000000000149",
             "00010000-0002-0000-0000-000000000150",
             "00010000-0002-0000-0000-000000000151",
             "00010000-0002-0000-0000-000000000152",
             "00010000-0002-0000-0000-000000000153",
             "00010000-0002-0000-0000-000000000154",
             "00010000-0002-0000-0000-000000000155",
             "00010000-0002-0000-0000-000000000156",
             "00010000-0002-0000-0000-000000000157",
             "00010000-0002-0000-0000-000000000158",
             "00010000-0002-0000-0000-000000000159",
             "00010000-0002-0000-0000-000000000160",
             "00010000-0002-0000-0000-000000000161",
             "00010000-0002-0000-0000-000000000162",
             "00010000-0002-0000-0000-000000000163",
             "00010000-0002-0000-0000-000000000164",
             "00010000-0002-0000-0000-000000000165",
             "00010000-0002-0000-0000-000000000166",
             "00010000-0002-0000-0000-000000000167",
             "00010000-0002-0000-0000-000000000168",
             "00010000-0002-0000-0000-000000000169",
             "00010000-0002-0000-0000-000000000170",
             "00010000-0002-0000-0000-000000000171",
             "00010000-0002-0000-0000-000000000172",
             "00010000-0002-0000-0000-000000000173",
             "00010000-0002-0000-0000-000000000174",
             "00010000-0002-0000-0000-000000000175",
             "00010000-0002-0000-0000-000000000176",
             "00010000-0002-0000-0000-000000000177",
             "00010000-0002-0000-0000-000000000178",
             "00010000-0002-0000-0000-000000000179",
             "00010000-0002-0000-0000-000000000180",
             "00010000-0002-0000-0000-000000000181",
             "00010000-0002-0000-0000-000000000182",
             "00010000-0002-0000-0000-000000000183",
             "00010000-0002-0000-0000-000000000184",
             "00010000-0002-0000-0000-000000000185",
             "00010000-0002-0000-0000-000000000186",
             "00010000-0002-0000-0000-000000000187",
             "00010000-0002-0000-0000-000000000188",
             "00010000-0002-0000-0000-000000000189",
             "00010000-0002-0000-0000-000000000190",
             "00010000-0002-0000-0000-000000000191",
             "00010000-0002-0000-0000-000000000192",
             "00010000-0002-0000-0000-000000000193",
             "00010000-0002-0000-0000-000000000194",
             "00010000-0002-0000-0000-000000000195",
             "00010000-0002-0000-0000-000000000196",
             "00010000-0002-0000-0000-000000000197",
             "00010000-0002-0000-0000-000000000198",
             "00010000-0002-0000-0000-000000000199",
             "00010000-0002-0000-0000-000000000200",
             "00010000-0002-0000-0000-000000000201",
             "00010000-0002-0000-0000-000000000202",
             "00010000-0002-0000-0000-000000000203",
             "00010000-0002-0000-0000-000000000204",
             "00010000-0002-0000-0000-000000000205",
             "00010000-0002-0000-0000-000000000206",
             "00010000-0002-0000-0000-000000000207",
             "00010000-0002-0000-0000-000000000208",
             "00010000-0002-0000-0000-000000000209",
             "00010000-0002-0000-0000-000000000210",
             "00010000-0002-0000-0000-000000000211",
             "00010000-0002-0000-0000-000000000212",
             "00010000-0002-0000-0000-000000000213",
             "00010000-0002-0000-0000-000000000214",
             "00010000-0002-0000-0000-000000000215",
             "00010000-0002-0000-0000-000000000216",
             "00010000-0002-0000-0000-000000000217",
             "00010000-0002-0000-0000-000000000218",
             "00010000-0002-0000-0000-000000000219",
             "00010000-0002-0000-0000-000000000220",
             "00010000-0002-0000-0000-000000000221",
             "00010000-0002-0000-0000-000000000222",
             "00010000-0002-0000-0000-000000000223",
             "00010000-0002-0000-0000-000000000224",
             "00010000-0002-0000-0000-000000000225",
             "00010000-0002-0000-0000-000000000226",
             "00010000-0002-0000-0000-000000000227",
             "00010000-0002-0000-0000-000000000228",
             "00010000-0002-0000-0000-000000000229",
             "00010000-0002-0000-0000-000000000230",
             "00010000-0002-0000-0000-000000000231",
             "00010000-0002-0000-0000-000000000232",
             "00010000-0002-0000-0000-000000000233"
             }
        );
        #endregion

#region MediaIds
        public static Guid[] MovieList = StressHelper.CreateGuidArray(            
        new string[] {
             "00020013-0002-0001-0113-000000000001",
             "00030003-0002-0001-0113-000000000001",
             "00020013-0002-0001-0113-000000000002",
             "00030003-0002-0001-0113-000000000002",
             "00020013-0002-0001-0113-000000000003",
             "00030003-0002-0001-0113-000000000003",
             "00020013-0002-0001-0113-000000000004",
             "00030003-0002-0001-0113-000000000004",
             "00020013-0002-0001-0113-000000000005",
             "00030003-0002-0001-0113-000000000005",
             "00020013-0002-0001-0113-000000000006",
             "00030003-0002-0001-0113-000000000006",
             "00020013-0002-0001-0113-000000000007",
             "00030003-0002-0001-0113-000000000007",
             "00020013-0002-0001-0113-000000000008",
             "00030003-0002-0001-0113-000000000008",
             "00020013-0002-0001-0113-000000000009",
             "00030003-0002-0001-0113-000000000009",
             "00020013-0002-0001-0113-000000000010",
             "00030003-0002-0001-0113-000000000010",
             "00020013-0002-0001-0113-000000000011",
             "00030003-0002-0001-0113-000000000011",
             "00020013-0002-0001-0113-000000000012",
             "00030003-0002-0001-0113-000000000012",
             "00020013-0002-0001-0113-000000000013",
             "00030003-0002-0001-0113-000000000013",
             "00020013-0002-0001-0113-000000000014",
             "00030003-0002-0001-0113-000000000014",
             "00020013-0002-0001-0113-000000000015",
             "00030003-0002-0001-0113-000000000015",
             "00020013-0002-0001-0113-000000000016",
             "00030003-0002-0001-0113-000000000016",
             "00020013-0002-0001-0113-000000000017",
             "00030003-0002-0001-0113-000000000017",
             "00020013-0002-0001-0113-000000000018",
             "00030003-0002-0001-0113-000000000018",
             "00020013-0002-0001-0113-000000000019",
             "00030003-0002-0001-0113-000000000019",
             "00020013-0002-0001-0113-000000000020",
             "00030003-0002-0001-0113-000000000020",
             "00020013-0002-0001-0113-000000000021",
             "00030003-0002-0001-0113-000000000021",
             "00020013-0002-0001-0113-000000000022",
             "00030003-0002-0001-0113-000000000022",
             "00020013-0002-0001-0113-000000000023",
             "00030003-0002-0001-0113-000000000023",
             "00020013-0002-0001-0113-000000000024",
             "00030003-0002-0001-0113-000000000024",
             "00020013-0002-0001-0113-000000000025",
             "00030003-0002-0001-0113-000000000025",
             "00020013-0002-0001-0113-000000000026",
             "00030003-0002-0001-0113-000000000026",
             "00020013-0002-0001-0113-000000000027",
             "00030003-0002-0001-0113-000000000027",
             "00020013-0002-0001-0113-000000000028",
             "00030003-0002-0001-0113-000000000028",
             "00020013-0002-0001-0113-000000000029",
             "00030003-0002-0001-0113-000000000029",
             "00020013-0002-0001-0113-000000000030",
             "00030003-0002-0001-0113-000000000030",
             "00020013-0002-0001-0113-000000000031",
             "00030003-0002-0001-0113-000000000031",
             "00020013-0002-0001-0113-000000000032",
             "00030003-0002-0001-0113-000000000032",
             "00020013-0002-0001-0113-000000000033",
             "00030003-0002-0001-0113-000000000033",
             "00020013-0002-0001-0113-000000000034",
             "00030003-0002-0001-0113-000000000034",
             "00020013-0002-0001-0113-000000000035",
             "00030003-0002-0001-0113-000000000035",
             "00020013-0002-0001-0113-000000000036",
             "00030003-0002-0001-0113-000000000036",
             "00020013-0002-0001-0113-000000000037",
             "00030003-0002-0001-0113-000000000037",
             "00020013-0002-0001-0113-000000000038",
             "00030003-0002-0001-0113-000000000038",
             "00020013-0002-0001-0113-000000000039",
             "00030003-0002-0001-0113-000000000039",
             "00020013-0002-0001-0113-000000000040",
             "00030003-0002-0001-0113-000000000040",
             "00020013-0002-0001-0113-000000000041",
             "00030003-0002-0001-0113-000000000041",
             "00020013-0002-0001-0113-000000000042",
             "00030003-0002-0001-0113-000000000042",
             "00020013-0002-0001-0113-000000000043",
             "00030003-0002-0001-0113-000000000043",
             "00020013-0002-0001-0113-000000000044",
             "00030003-0002-0001-0113-000000000044",
             "00020013-0002-0001-0113-000000000045",
             "00030003-0002-0001-0113-000000000045",
             "00020013-0002-0001-0113-000000000046",
             "00030003-0002-0001-0113-000000000046",
             "00020013-0002-0001-0113-000000000047",
             "00030003-0002-0001-0113-000000000047",
             "00020013-0002-0001-0113-000000000048",
             "00030003-0002-0001-0113-000000000048",
             "00020013-0002-0001-0113-000000000049",
             "00030003-0002-0001-0113-000000000049",
             "00020013-0002-0001-0113-000000000050",
             "00030003-0002-0001-0113-000000000050",
             "00020013-0002-0001-0113-000000000051",
             "00030003-0002-0001-0113-000000000051",
             "00020013-0002-0001-0113-000000000052",
             "00030003-0002-0001-0113-000000000052",
             "00020013-0002-0001-0113-000000000053",
             "00030003-0002-0001-0113-000000000053",
             "00020013-0002-0001-0113-000000000054",
             "00030003-0002-0001-0113-000000000054",
             "00020013-0002-0001-0113-000000000055",
             "00030003-0002-0001-0113-000000000055",
             "00020013-0002-0001-0113-000000000056",
             "00030003-0002-0001-0113-000000000056",
             "00020013-0002-0001-0113-000000000057",
             "00030003-0002-0001-0113-000000000057",
             "00020013-0002-0001-0113-000000000058",
             "00030003-0002-0001-0113-000000000058",
             "00020013-0002-0001-0113-000000000059",
             "00030003-0002-0001-0113-000000000059",
             "00020013-0002-0001-0113-000000000060",
             "00030003-0002-0001-0113-000000000060",
             "00020013-0002-0001-0113-000000000061",
             "00030003-0002-0001-0113-000000000061",
             "00020013-0002-0001-0113-000000000062",
             "00030003-0002-0001-0113-000000000062",
             "00020013-0002-0001-0113-000000000063",
             "00030003-0002-0001-0113-000000000063",
             "00020013-0002-0001-0113-000000000064",
             "00030003-0002-0001-0113-000000000064",
             "00020013-0002-0001-0113-000000000065",
             "00030003-0002-0001-0113-000000000065",
             "00020013-0002-0001-0113-000000000066",
             "00030003-0002-0001-0113-000000000066",
             "00020013-0002-0001-0113-000000000067",
             "00030003-0002-0001-0113-000000000067",
             "00020013-0002-0001-0113-000000000068",
             "00030003-0002-0001-0113-000000000068",
             "00020013-0002-0001-0113-000000000069",
             "00030003-0002-0001-0113-000000000069",
             "00020013-0002-0001-0113-000000000070",
             "00030003-0002-0001-0113-000000000070",
             "00020013-0002-0001-0113-000000000071",
             "00030003-0002-0001-0113-000000000071",
             "00020013-0002-0001-0113-000000000072",
             "00030003-0002-0001-0113-000000000072",
             "00020013-0002-0001-0113-000000000073",
             "00030003-0002-0001-0113-000000000073",
             "00020013-0002-0001-0113-000000000074",
             "00030003-0002-0001-0113-000000000074",
             "00020013-0002-0001-0113-000000000075",
             "00030003-0002-0001-0113-000000000075",
             "00020013-0002-0001-0113-000000000076",
             "00030003-0002-0001-0113-000000000076",
             "00020013-0002-0001-0113-000000000077",
             "00030003-0002-0001-0113-000000000077",
             "00020013-0002-0001-0113-000000000078",
             "00030003-0002-0001-0113-000000000078",
             "00020013-0002-0001-0113-000000000079",
             "00030003-0002-0001-0113-000000000079",
             "00020013-0002-0001-0113-000000000080",
             "00030003-0002-0001-0113-000000000080",
             "00020013-0002-0001-0113-000000000081",
             "00030003-0002-0001-0113-000000000081",
             "00020013-0002-0001-0113-000000000082",
             "00030003-0002-0001-0113-000000000082",
             "00020013-0002-0001-0113-000000000083",
             "00030003-0002-0001-0113-000000000083",
             "00020013-0002-0001-0113-000000000084",
             "00030003-0002-0001-0113-000000000084",
             "00020013-0002-0001-0113-000000000085",
             "00030003-0002-0001-0113-000000000085",
             "00020013-0002-0001-0113-000000000086",
             "00030003-0002-0001-0113-000000000086",
             "00020013-0002-0001-0113-000000000087",
             "00030003-0002-0001-0113-000000000087",
             "00020013-0002-0001-0113-000000000088",
             "00030003-0002-0001-0113-000000000088",
             "00020013-0002-0001-0113-000000000089",
             "00030003-0002-0001-0113-000000000089",
             "00020013-0002-0001-0113-000000000090",
             "00030003-0002-0001-0113-000000000090",
             "00020013-0002-0001-0113-000000000091",
             "00030003-0002-0001-0113-000000000091",
             "00020013-0002-0001-0113-000000000092",
             "00030003-0002-0001-0113-000000000092",
             "00020013-0002-0001-0113-000000000093",
             "00030003-0002-0001-0113-000000000093",
             "00020013-0002-0001-0113-000000000094",
             "00030003-0002-0001-0113-000000000094",
             "00020013-0002-0001-0113-000000000095",
             "00030003-0002-0001-0113-000000000095",
             "00020013-0002-0001-0113-000000000096",
             "00030003-0002-0001-0113-000000000096",
             "00020013-0002-0001-0113-000000000097",
             "00030003-0002-0001-0113-000000000097",
             "00020013-0002-0001-0113-000000000098",
             "00030003-0002-0001-0113-000000000098",
             "00020013-0002-0001-0113-000000000099",
             "00030003-0002-0001-0113-000000000099",
             "00020013-0002-0001-0113-000000000100",
             "00030003-0002-0001-0113-000000000100"  
             }
        );
#endregion

        protected override void Init()
        {
            base.Init();
            MethodName = QueryRequestBase.QueryMethod.FindVideoOffers;

            FindVideoOffersFilter filter = new FindVideoOffersFilter();
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "fr-FR" }, new uint[] { 99, 1 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 1;  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 100, 50 }, new uint[] { 90, 10 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 4, 5 }, new uint[] { 95, 5 });
            filter.MediaTypes = StressHelper.GetInputValue<Int32>(new int[] { 2, 8 }, new uint[] { 1 }, new uint[] { 10 });

            uint[] arraySize ={ 1, 5, 10 };
            uint[] arraySizeDistributions ={ 80, 10, 10 };

            Guid[] mediaIdsSelected;
            if (filter.MediaTypes[0] == 2)
                mediaIdsSelected = MovieList;
            else
                mediaIdsSelected = TVEpisodeList;

            filter.MediaIds = StressHelper.GetInputValue<Guid>(mediaIdsSelected, arraySize, arraySizeDistributions);

            filter.UserTypes = new List<Int32>();
            filter.UserTypes.Add(2);

            filter.OrderBy = StressHelper.GetInputValue(new int[] { 1, 1, 1, 1 }, new uint[] { 30, 20, 20, 30 });
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 90, 10 });


            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }


    [StressTest(Priority = 1000)]
    public class StressFindVideoOffers_2700 : QueryStressTestBase
    {
        #region MediaIds
        public static Guid[] TVEpisodeList = StressHelper.CreateGuidArray(
        new string[] {
             "00010000-0002-0000-0000-000000000000",
             "00020000-0002-0000-0000-000000000000",
             "DE5CFB8A-0001-0000-0003-000000000000",
             "00010000-0002-0000-0000-000000000001",
             "00020000-0002-0000-0000-000000000001",
             "DE5CFB8A-0001-0000-0003-000000000001",
             "00020013-0008-0001-0113-000000000001",
             "00030003-0008-0001-0113-000000000001",
             "00010000-0002-0000-0000-000000000002",
             "00020000-0002-0000-0000-000000000002",
             "DE5CFB8A-0001-0000-0003-000000000002",
             "00020013-0008-0001-0113-000000000002",
             "00030003-0008-0001-0113-000000000002",
             "00010000-0002-0000-0000-000000000003",
             "00020000-0002-0000-0000-000000000003",
             "00020013-0008-0001-0113-000000000003",
             "00030003-0008-0001-0113-000000000003",
             "00010000-0002-0000-0000-000000000004",
             "00020000-0002-0000-0000-000000000004",
             "00020013-0008-0001-0113-000000000004",
             "00030003-0008-0001-0113-000000000004",
             "00010000-0002-0000-0000-000000000005",
             "00020000-0002-0000-0000-000000000005",
             "00020013-0008-0001-0113-000000000005",
             "00030003-0008-0001-0113-000000000005",
             "00010000-0002-0000-0000-000000000006",
             "00020000-0002-0000-0000-000000000006",
             "00020013-0008-0001-0113-000000000006",
             "00030003-0008-0001-0113-000000000006",
             "00010000-0002-0000-0000-000000000007",
             "00020000-0002-0000-0000-000000000007",
             "00020013-0008-0001-0113-000000000007",
             "00030003-0008-0001-0113-000000000007",
             "00020013-0008-0001-0113-000000000008",
             "00030003-0008-0001-0113-000000000008",
             "00020013-0008-0001-0113-000000000009",
             "00030003-0008-0001-0113-000000000009",
             "00020013-0008-0001-0113-000000000010",
             "00030003-0008-0001-0113-000000000010",
             "00020013-0008-0001-0113-000000000011",
             "00030003-0008-0001-0113-000000000011",
             "00020013-0008-0001-0113-000000000012",
             "00030003-0008-0001-0113-000000000012",
             "00020013-0008-0001-0113-000000000013",
             "00030003-0008-0001-0113-000000000013",
             "00020013-0008-0001-0113-000000000014",
             "00030003-0008-0001-0113-000000000014",
             "00020013-0008-0001-0113-000000000015",
             "00030003-0008-0001-0113-000000000015",
             "00020013-0008-0001-0113-000000000016",
             "00030003-0008-0001-0113-000000000016",
             "00020013-0008-0001-0113-000000000017",
             "00030003-0008-0001-0113-000000000017",
             "00020013-0008-0001-0113-000000000018",
             "00030003-0008-0001-0113-000000000018",
             "00020013-0008-0001-0113-000000000019",
             "00030003-0008-0001-0113-000000000019",
             "00020013-0008-0001-0113-000000000020",
             "00030003-0008-0001-0113-000000000020",
             "00010000-0002-0000-0000-000000000050",
             "00010000-0002-0000-0000-000000000100",
             "00020000-0002-0000-0000-000000000100",
             "00010000-0002-0000-0000-000000000101",
             "00020000-0002-0000-0000-000000000101",
             "00010000-0002-0000-0000-000000000102",
             "00020000-0002-0000-0000-000000000102",
             "00010000-0002-0000-0000-000000000103",
             "00020000-0002-0000-0000-000000000103",
             "00010000-0002-0000-0000-000000000104",
             "00020000-0002-0000-0000-000000000104",
             "00010000-0002-0000-0000-000000000105",
             "00020000-0002-0000-0000-000000000105",
             "00010000-0002-0000-0000-000000000106",
             "00010000-0002-0000-0000-000000000107",
             "00010000-0002-0000-0000-000000000108",
             "00010000-0002-0000-0000-000000000109",
             "00010000-0002-0000-0000-000000000110",
             "00010000-0002-0000-0000-000000000111",
             "00010000-0002-0000-0000-000000000112",
             "00010000-0002-0000-0000-000000000113",
             "00010000-0002-0000-0000-000000000114",
             "00010000-0002-0000-0000-000000000115",
             "00010000-0002-0000-0000-000000000116",
             "00010000-0002-0000-0000-000000000117",
             "00010000-0002-0000-0000-000000000118",
             "00010000-0002-0000-0000-000000000119",
             "00010000-0002-0000-0000-000000000120",
             "00010000-0002-0000-0000-000000000121",
             "00010000-0002-0000-0000-000000000122",
             "00010000-0002-0000-0000-000000000123",
             "00010000-0002-0000-0000-000000000124",
             "00010000-0002-0000-0000-000000000125",
             "00010000-0002-0000-0000-000000000126",
             "00010000-0002-0000-0000-000000000127",
             "00010000-0002-0000-0000-000000000128",
             "00010000-0002-0000-0000-000000000129",
             "00010000-0002-0000-0000-000000000130",
             "00010000-0002-0000-0000-000000000131",
             "00010000-0002-0000-0000-000000000132",
             "00010000-0002-0000-0000-000000000133",
             "00010000-0002-0000-0000-000000000134",
             "00010000-0002-0000-0000-000000000135",
             "00010000-0002-0000-0000-000000000136",
             "00010000-0002-0000-0000-000000000137",
             "00010000-0002-0000-0000-000000000138",
             "00010000-0002-0000-0000-000000000139",
             "00010000-0002-0000-0000-000000000140",
             "00010000-0002-0000-0000-000000000141",
             "00010000-0002-0000-0000-000000000142",
             "00010000-0002-0000-0000-000000000143",
             "00010000-0002-0000-0000-000000000144",
             "00010000-0002-0000-0000-000000000145",
             "00010000-0002-0000-0000-000000000146",
             "00010000-0002-0000-0000-000000000147",
             "00010000-0002-0000-0000-000000000148",
             "00010000-0002-0000-0000-000000000149",
             "00010000-0002-0000-0000-000000000150",
             "00010000-0002-0000-0000-000000000151",
             "00010000-0002-0000-0000-000000000152",
             "00010000-0002-0000-0000-000000000153",
             "00010000-0002-0000-0000-000000000154",
             "00010000-0002-0000-0000-000000000155",
             "00010000-0002-0000-0000-000000000156",
             "00010000-0002-0000-0000-000000000157",
             "00010000-0002-0000-0000-000000000158",
             "00010000-0002-0000-0000-000000000159",
             "00010000-0002-0000-0000-000000000160",
             "00010000-0002-0000-0000-000000000161",
             "00010000-0002-0000-0000-000000000162",
             "00010000-0002-0000-0000-000000000163",
             "00010000-0002-0000-0000-000000000164",
             "00010000-0002-0000-0000-000000000165",
             "00010000-0002-0000-0000-000000000166",
             "00010000-0002-0000-0000-000000000167",
             "00010000-0002-0000-0000-000000000168",
             "00010000-0002-0000-0000-000000000169",
             "00010000-0002-0000-0000-000000000170",
             "00010000-0002-0000-0000-000000000171",
             "00010000-0002-0000-0000-000000000172",
             "00010000-0002-0000-0000-000000000173",
             "00010000-0002-0000-0000-000000000174",
             "00010000-0002-0000-0000-000000000175",
             "00010000-0002-0000-0000-000000000176",
             "00010000-0002-0000-0000-000000000177",
             "00010000-0002-0000-0000-000000000178",
             "00010000-0002-0000-0000-000000000179",
             "00010000-0002-0000-0000-000000000180",
             "00010000-0002-0000-0000-000000000181",
             "00010000-0002-0000-0000-000000000182",
             "00010000-0002-0000-0000-000000000183",
             "00010000-0002-0000-0000-000000000184",
             "00010000-0002-0000-0000-000000000185",
             "00010000-0002-0000-0000-000000000186",
             "00010000-0002-0000-0000-000000000187",
             "00010000-0002-0000-0000-000000000188",
             "00010000-0002-0000-0000-000000000189",
             "00010000-0002-0000-0000-000000000190",
             "00010000-0002-0000-0000-000000000191",
             "00010000-0002-0000-0000-000000000192",
             "00010000-0002-0000-0000-000000000193",
             "00010000-0002-0000-0000-000000000194",
             "00010000-0002-0000-0000-000000000195",
             "00010000-0002-0000-0000-000000000196",
             "00010000-0002-0000-0000-000000000197",
             "00010000-0002-0000-0000-000000000198",
             "00010000-0002-0000-0000-000000000199",
             "00010000-0002-0000-0000-000000000200",
             "00010000-0002-0000-0000-000000000201",
             "00010000-0002-0000-0000-000000000202",
             "00010000-0002-0000-0000-000000000203",
             "00010000-0002-0000-0000-000000000204",
             "00010000-0002-0000-0000-000000000205",
             "00010000-0002-0000-0000-000000000206",
             "00010000-0002-0000-0000-000000000207",
             "00010000-0002-0000-0000-000000000208",
             "00010000-0002-0000-0000-000000000209",
             "00010000-0002-0000-0000-000000000210",
             "00010000-0002-0000-0000-000000000211",
             "00010000-0002-0000-0000-000000000212",
             "00010000-0002-0000-0000-000000000213",
             "00010000-0002-0000-0000-000000000214",
             "00010000-0002-0000-0000-000000000215",
             "00010000-0002-0000-0000-000000000216",
             "00010000-0002-0000-0000-000000000217",
             "00010000-0002-0000-0000-000000000218",
             "00010000-0002-0000-0000-000000000219",
             "00010000-0002-0000-0000-000000000220",
             "00010000-0002-0000-0000-000000000221",
             "00010000-0002-0000-0000-000000000222",
             "00010000-0002-0000-0000-000000000223",
             "00010000-0002-0000-0000-000000000224",
             "00010000-0002-0000-0000-000000000225",
             "00010000-0002-0000-0000-000000000226",
             "00010000-0002-0000-0000-000000000227",
             "00010000-0002-0000-0000-000000000228",
             "00010000-0002-0000-0000-000000000229",
             "00010000-0002-0000-0000-000000000230",
             "00010000-0002-0000-0000-000000000231",
             "00010000-0002-0000-0000-000000000232",
             "00010000-0002-0000-0000-000000000233"
             }
        );
        #endregion

        #region MediaIds
        public static Guid[] MovieList = StressHelper.CreateGuidArray(
        new string[] {
             "00020013-0002-0001-0113-000000000001",
             "00030003-0002-0001-0113-000000000001",
             "00020013-0002-0001-0113-000000000002",
             "00030003-0002-0001-0113-000000000002",
             "00020013-0002-0001-0113-000000000003",
             "00030003-0002-0001-0113-000000000003",
             "00020013-0002-0001-0113-000000000004",
             "00030003-0002-0001-0113-000000000004",
             "00020013-0002-0001-0113-000000000005",
             "00030003-0002-0001-0113-000000000005",
             "00020013-0002-0001-0113-000000000006",
             "00030003-0002-0001-0113-000000000006",
             "00020013-0002-0001-0113-000000000007",
             "00030003-0002-0001-0113-000000000007",
             "00020013-0002-0001-0113-000000000008",
             "00030003-0002-0001-0113-000000000008",
             "00020013-0002-0001-0113-000000000009",
             "00030003-0002-0001-0113-000000000009",
             "00020013-0002-0001-0113-000000000010",
             "00030003-0002-0001-0113-000000000010",
             "00020013-0002-0001-0113-000000000011",
             "00030003-0002-0001-0113-000000000011",
             "00020013-0002-0001-0113-000000000012",
             "00030003-0002-0001-0113-000000000012",
             "00020013-0002-0001-0113-000000000013",
             "00030003-0002-0001-0113-000000000013",
             "00020013-0002-0001-0113-000000000014",
             "00030003-0002-0001-0113-000000000014",
             "00020013-0002-0001-0113-000000000015",
             "00030003-0002-0001-0113-000000000015",
             "00020013-0002-0001-0113-000000000016",
             "00030003-0002-0001-0113-000000000016",
             "00020013-0002-0001-0113-000000000017",
             "00030003-0002-0001-0113-000000000017",
             "00020013-0002-0001-0113-000000000018",
             "00030003-0002-0001-0113-000000000018",
             "00020013-0002-0001-0113-000000000019",
             "00030003-0002-0001-0113-000000000019",
             "00020013-0002-0001-0113-000000000020",
             "00030003-0002-0001-0113-000000000020",
             "00020013-0002-0001-0113-000000000021",
             "00030003-0002-0001-0113-000000000021",
             "00020013-0002-0001-0113-000000000022",
             "00030003-0002-0001-0113-000000000022",
             "00020013-0002-0001-0113-000000000023",
             "00030003-0002-0001-0113-000000000023",
             "00020013-0002-0001-0113-000000000024",
             "00030003-0002-0001-0113-000000000024",
             "00020013-0002-0001-0113-000000000025",
             "00030003-0002-0001-0113-000000000025",
             "00020013-0002-0001-0113-000000000026",
             "00030003-0002-0001-0113-000000000026",
             "00020013-0002-0001-0113-000000000027",
             "00030003-0002-0001-0113-000000000027",
             "00020013-0002-0001-0113-000000000028",
             "00030003-0002-0001-0113-000000000028",
             "00020013-0002-0001-0113-000000000029",
             "00030003-0002-0001-0113-000000000029",
             "00020013-0002-0001-0113-000000000030",
             "00030003-0002-0001-0113-000000000030",
             "00020013-0002-0001-0113-000000000031",
             "00030003-0002-0001-0113-000000000031",
             "00020013-0002-0001-0113-000000000032",
             "00030003-0002-0001-0113-000000000032",
             "00020013-0002-0001-0113-000000000033",
             "00030003-0002-0001-0113-000000000033",
             "00020013-0002-0001-0113-000000000034",
             "00030003-0002-0001-0113-000000000034",
             "00020013-0002-0001-0113-000000000035",
             "00030003-0002-0001-0113-000000000035",
             "00020013-0002-0001-0113-000000000036",
             "00030003-0002-0001-0113-000000000036",
             "00020013-0002-0001-0113-000000000037",
             "00030003-0002-0001-0113-000000000037",
             "00020013-0002-0001-0113-000000000038",
             "00030003-0002-0001-0113-000000000038",
             "00020013-0002-0001-0113-000000000039",
             "00030003-0002-0001-0113-000000000039",
             "00020013-0002-0001-0113-000000000040",
             "00030003-0002-0001-0113-000000000040",
             "00020013-0002-0001-0113-000000000041",
             "00030003-0002-0001-0113-000000000041",
             "00020013-0002-0001-0113-000000000042",
             "00030003-0002-0001-0113-000000000042",
             "00020013-0002-0001-0113-000000000043",
             "00030003-0002-0001-0113-000000000043",
             "00020013-0002-0001-0113-000000000044",
             "00030003-0002-0001-0113-000000000044",
             "00020013-0002-0001-0113-000000000045",
             "00030003-0002-0001-0113-000000000045",
             "00020013-0002-0001-0113-000000000046",
             "00030003-0002-0001-0113-000000000046",
             "00020013-0002-0001-0113-000000000047",
             "00030003-0002-0001-0113-000000000047",
             "00020013-0002-0001-0113-000000000048",
             "00030003-0002-0001-0113-000000000048",
             "00020013-0002-0001-0113-000000000049",
             "00030003-0002-0001-0113-000000000049",
             "00020013-0002-0001-0113-000000000050",
             "00030003-0002-0001-0113-000000000050",
             "00020013-0002-0001-0113-000000000051",
             "00030003-0002-0001-0113-000000000051",
             "00020013-0002-0001-0113-000000000052",
             "00030003-0002-0001-0113-000000000052",
             "00020013-0002-0001-0113-000000000053",
             "00030003-0002-0001-0113-000000000053",
             "00020013-0002-0001-0113-000000000054",
             "00030003-0002-0001-0113-000000000054",
             "00020013-0002-0001-0113-000000000055",
             "00030003-0002-0001-0113-000000000055",
             "00020013-0002-0001-0113-000000000056",
             "00030003-0002-0001-0113-000000000056",
             "00020013-0002-0001-0113-000000000057",
             "00030003-0002-0001-0113-000000000057",
             "00020013-0002-0001-0113-000000000058",
             "00030003-0002-0001-0113-000000000058",
             "00020013-0002-0001-0113-000000000059",
             "00030003-0002-0001-0113-000000000059",
             "00020013-0002-0001-0113-000000000060",
             "00030003-0002-0001-0113-000000000060",
             "00020013-0002-0001-0113-000000000061",
             "00030003-0002-0001-0113-000000000061",
             "00020013-0002-0001-0113-000000000062",
             "00030003-0002-0001-0113-000000000062",
             "00020013-0002-0001-0113-000000000063",
             "00030003-0002-0001-0113-000000000063",
             "00020013-0002-0001-0113-000000000064",
             "00030003-0002-0001-0113-000000000064",
             "00020013-0002-0001-0113-000000000065",
             "00030003-0002-0001-0113-000000000065",
             "00020013-0002-0001-0113-000000000066",
             "00030003-0002-0001-0113-000000000066",
             "00020013-0002-0001-0113-000000000067",
             "00030003-0002-0001-0113-000000000067",
             "00020013-0002-0001-0113-000000000068",
             "00030003-0002-0001-0113-000000000068",
             "00020013-0002-0001-0113-000000000069",
             "00030003-0002-0001-0113-000000000069",
             "00020013-0002-0001-0113-000000000070",
             "00030003-0002-0001-0113-000000000070",
             "00020013-0002-0001-0113-000000000071",
             "00030003-0002-0001-0113-000000000071",
             "00020013-0002-0001-0113-000000000072",
             "00030003-0002-0001-0113-000000000072",
             "00020013-0002-0001-0113-000000000073",
             "00030003-0002-0001-0113-000000000073",
             "00020013-0002-0001-0113-000000000074",
             "00030003-0002-0001-0113-000000000074",
             "00020013-0002-0001-0113-000000000075",
             "00030003-0002-0001-0113-000000000075",
             "00020013-0002-0001-0113-000000000076",
             "00030003-0002-0001-0113-000000000076",
             "00020013-0002-0001-0113-000000000077",
             "00030003-0002-0001-0113-000000000077",
             "00020013-0002-0001-0113-000000000078",
             "00030003-0002-0001-0113-000000000078",
             "00020013-0002-0001-0113-000000000079",
             "00030003-0002-0001-0113-000000000079",
             "00020013-0002-0001-0113-000000000080",
             "00030003-0002-0001-0113-000000000080",
             "00020013-0002-0001-0113-000000000081",
             "00030003-0002-0001-0113-000000000081",
             "00020013-0002-0001-0113-000000000082",
             "00030003-0002-0001-0113-000000000082",
             "00020013-0002-0001-0113-000000000083",
             "00030003-0002-0001-0113-000000000083",
             "00020013-0002-0001-0113-000000000084",
             "00030003-0002-0001-0113-000000000084",
             "00020013-0002-0001-0113-000000000085",
             "00030003-0002-0001-0113-000000000085",
             "00020013-0002-0001-0113-000000000086",
             "00030003-0002-0001-0113-000000000086",
             "00020013-0002-0001-0113-000000000087",
             "00030003-0002-0001-0113-000000000087",
             "00020013-0002-0001-0113-000000000088",
             "00030003-0002-0001-0113-000000000088",
             "00020013-0002-0001-0113-000000000089",
             "00030003-0002-0001-0113-000000000089",
             "00020013-0002-0001-0113-000000000090",
             "00030003-0002-0001-0113-000000000090",
             "00020013-0002-0001-0113-000000000091",
             "00030003-0002-0001-0113-000000000091",
             "00020013-0002-0001-0113-000000000092",
             "00030003-0002-0001-0113-000000000092",
             "00020013-0002-0001-0113-000000000093",
             "00030003-0002-0001-0113-000000000093",
             "00020013-0002-0001-0113-000000000094",
             "00030003-0002-0001-0113-000000000094",
             "00020013-0002-0001-0113-000000000095",
             "00030003-0002-0001-0113-000000000095",
             "00020013-0002-0001-0113-000000000096",
             "00030003-0002-0001-0113-000000000096",
             "00020013-0002-0001-0113-000000000097",
             "00030003-0002-0001-0113-000000000097",
             "00020013-0002-0001-0113-000000000098",
             "00030003-0002-0001-0113-000000000098",
             "00020013-0002-0001-0113-000000000099",
             "00030003-0002-0001-0113-000000000099",
             "00020013-0002-0001-0113-000000000100",
             "00030003-0002-0001-0113-000000000100"  
             }
        );
        #endregion

        protected override void Init()
        {
            base.Init();
            MethodName = QueryRequestBase.QueryMethod.FindVideoOffers;

            FindVideoOffersFilter filter = new FindVideoOffersFilter();
            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "fr-FR" }, new uint[] { 1, 1 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = RandomEx.GlobalRandGen.Next(0, 255);  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 100, 50 }, new uint[] { 10, 10 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 10, 10 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 4, 5 }, new uint[] { 5, 5 });
            filter.MediaTypes = StressHelper.GetInputValue<Int32>(new int[] { 2, 8 }, new uint[] { 1 }, new uint[] { 10 });

            uint[] arraySize ={ 1, 5, 10 };
            uint[] arraySizeDistributions ={ 1, 10, 10 };

            Guid[] mediaIdsSelected;
            if (filter.MediaTypes[0] == 2)
                mediaIdsSelected = MovieList;
            else
                mediaIdsSelected = TVEpisodeList;

            filter.MediaIds = StressHelper.GetInputValue<Guid>(mediaIdsSelected, arraySize, arraySizeDistributions);

            filter.UserTypes = new List<Int32>();
            filter.UserTypes.Add(2);

            filter.OrderBy = StressHelper.GetInputValue(new int[] { 1, 1, 1, 1 }, new uint[] { 30, 20, 20, 30 });
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 10, 10 });


            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }
    [StressTest(Priority = 100)]
    public class StressReportConcern : SubmissionStressTestBase
    {
        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.ReportConcern;
            ReportConcernFilter filter = new ReportConcernFilter();
            filter.MediaId = Guid.NewGuid();
            //filter.MediaId = StressHelper.GetInputValue(new Guid[] { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() }, new uint[] { 25, 25, 25, 25 });
            filter.ConcernText = StressHelper.GetRandomString(100, false);

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }

    /// <summary>
    /// User submitted podcasts do not occur very often but they are going to be
    /// relativly consistant so this is going to submit one podcast with an average 
    /// priority
    /// </summary>
    [StressTest(Priority = 100)]
    public class StressSubmitPodcast_User : SubmissionStressTestBase
    {
        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.SubmitPodcast;
            SubmitPodcastFilter filter = new SubmitPodcastFilter();

            filter.PodcastUrl = GetRandomUrl();

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }

        protected override void InnerExecute()
        {

                base.InnerExecute();
        }

        protected string GetRandomUrl()
        {
            //return String.Empty;
            return String.Format("http://www.{0}.com/{1}", StressHelper.GetRandomString(15, true), StressHelper.GetRandomString(15, true));
        }
    }

    /// <summary>
    /// Often, third parties will submit large number of podcasts at once.  So we
    /// simulate adding a bunch of podcasts in a row but set the priority very low
    /// </summary>
    [StressTest(Priority = 5)]
    public class StressSubmitPodcast_ThirdParty : SubmissionStressTestBase
    {
        public static readonly int SUBMIT_COUNT = 100;

        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.SubmitPodcast;
            SubmitPodcastFilter filter = new SubmitPodcastFilter();

            filter.PodcastUrl = GetRandomUrl();

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }

        /// <summary>
        /// We want to override Run so that the filter will be reinitialized 
        /// each time we do one submission.  
        /// </summary>
        /// <returns></returns>
        public override void Run()
        {
            int failCount = 0;

            for (int i = 0; i < SUBMIT_COUNT; i++)
            {
                try
                {
                    base.Run();
                }
                catch
                {
                    failCount++;
                }
            }

            if (failCount > 0)
            {
                throw new UnexpectedTestResultException(failCount + " Podcast Submissions Failed to execute out of " + SUBMIT_COUNT);
            }
        }

        protected string GetRandomUrl()
        {
            //return String.Empty;
            return String.Format("http://www.{0}.com/{1}", StressHelper.GetRandomString(15, true), StressHelper.GetRandomString(15, true));
        }
    }

    [StressTest(Priority = 100)]
    public class StressFindRelatedMedia : QueryStressTestBase
    {
        #region MediaIds
        public static Guid[] MediaIds = StressHelper.CreateGuidArray(
            new String[] { 
                "2344821A-0E86-42A9-B23A-84537D9107B4",
                "647F0204-C3B8-4EEF-B8A5-EF866337AE11",
                "DFC9A729-1921-4FB2-806D-3B04211C5BE4",
                "1CE6F20B-C59B-4056-BAF0-AA911ED3F597",
                "381CDAAD-2C85-4CA0-AB2C-7DA642CD81F6",
                "B98358FD-BA30-4895-BFC4-736B3A0A04AC",
                "00000000-0002-0000-0000-000000000050",
                "4EE9D2A6-193F-4B29-BAC3-BC68E717CD33",
                "AEAC1BFB-3EE4-4D54-9843-F096682DE9B7",
                "5E0B3946-8974-42D5-95F5-DAA43391F3F0",
                "E7FF1D7D-5291-4094-9A80-03C25745DCA8",
                "00000000-0002-0000-0000-000000000050",
                "3E343237-A727-4B37-B34F-0AAC0CCB983D",
                "00010001-000D-0000-0500-0000000000B6",
                "24DF3680-B30F-49F1-8591-F8C190A24E61",
                "881864B4-6000-4773-A8C6-41C5DB9344EA",
                "B1636FB8-39BD-408F-BEF7-0276823CCB51",
                "7EEEA4C1-44DE-451D-87EA-674D479E3CF5",
                "C6E7A183-A396-4713-9E68-56C392D01BF2",
                "88AFE32F-1E1E-4CE0-AE7A-FC464EB5DA9F",
                "CC964820-8111-4AA4-B4AD-FDFC6505863F",
                "DF0FCA45-6133-4356-8148-5AD05D804BF9",
                "634B4BDD-495E-442A-B355-14234EE033DE",
                "19A5A38E-5F01-4BED-A96F-D050D358CCDC",
                "082E9BBE-FF4B-4767-952B-0AF1777487AD",
                "D41994ED-2BF9-4026-B326-50BA5921538E",
                "554FF3F1-A37F-425F-8A8F-13365679ACC3",
                "9CB26366-8325-418A-8602-2165B957731E",
                "CA7346C6-8247-4F57-8222-7DEBD243ED8B",
                "9CB26366-8325-418A-8602-2165B957731E",
                "82C157D7-92E4-48D2-B3BA-3404D48B8E0F",
                "00010001-000D-0000-0500-000000000151",
                "AD64FCF0-7F98-4942-AE7B-30353291FEA2",
                "0D5DA403-7994-4790-81E9-7C8C947D6D1A",
                "1BD4EFE1-9235-4331-965F-9CB7D919BF6A",
                "1CE6F20B-C59B-4056-BAF0-AA911ED3F597",
                "51BC1E25-7439-402A-BA11-D4CD77C44A0F",
                "17D7967A-4E7F-4756-B1E2-BAE69F19FA08",
                "87F7BE83-46A1-41CD-9589-B90292A1F976",
                "E4284F54-5203-4B04-A65F-A480FE5BA421",
                "BB90C101-DD16-4F0F-B76D-1ADEE43580A5",
                "0F8300C8-893B-42B6-AB75-CF249607A400",
                "C2B17BED-CFA8-4056-BDF7-768C1BCF2F3B",
                "692ACD44-C0AE-45A3-8460-E0D974A23F5E",
                "7B38E841-FE50-4A0F-870F-B542B73A510B",
                "DE9646FB-9DC7-46FC-9AC5-EEB1AD9463EA",
                "FA085181-5956-4BD5-B4FE-92B85B0C5E41",
                "09631024-403C-4EE5-83C5-C6B01EE00DF0",
                "887E35F5-E122-4802-8395-F7219541B33D",
                "6A684033-4F28-4155-A91C-9D267B015FC3",
                "0139AB75-67C6-4100-8145-0B0E395FA0AE",
                "816DA56B-298B-49D4-9747-FB6C3293EEF4",
                "9ABFD7A4-344E-4680-9C00-3BCE6A98258B",
                "1CE6F20B-C59B-4056-BAF0-AA911ED3F597",
                "DE9646FB-9DC7-46FC-9AC5-EEB1AD9463EA",
                "00000000-0002-0000-0000-000000000050",
                "2DABC179-B12D-466B-A5B2-C641555434FE",
                "65DFEB40-E43D-4F74-9805-A756D0ED3861",
                "758ED278-CAE4-48A5-B4D7-7CF02FB580C1",
                "AC4CD9DA-A4FC-4B97-85DC-A716C05EA48F",
                "7F2F70C1-490F-4C3A-A9EE-37AEDD9127C8",
                "B4771E63-D8E3-4DEC-8C23-0317A8B4426A",
                "1B41B5E0-8B60-4EE3-B098-576362890D4D",
                "E44A10DD-45B5-4543-8F31-C207BC0C4715",
                "6CDD5244-DB2C-4CCF-966C-C45A3EFAFC78",
                "09983775-4623-43FF-AB90-5FAC9322ED9F",
                "E26B6EB2-8243-4FC1-88F8-0FB2F1E86D4B",
                "BFBA1AA8-962D-4DB5-9659-6D99B7B8391C",
                "A448B200-6221-4C75-9D65-59F7A53D124E",
                "DBBE7304-5CCD-4765-9E79-6369F0AD015A",
                "21BD083D-136F-4740-97C2-6B9705CE5CE0",
                "008BBAC4-DA51-4A0B-B6C4-B346AE38D447",
                "88790A44-65A5-4A2F-827A-E474C8821BE7",
                "C9CEEE13-FCD6-47DF-90B0-AF0BBB5FD8E7",
                "37A9DAA7-86D0-4B0D-A701-E216F2BCDC83",
                "85DBBEA5-E33F-4254-A7AB-D39F2CA01B81",
                "C0DEBF11-ECC9-4AC4-BF3E-D1687F33E6BA",
                "CC15CD97-A0E6-4182-AE51-75F55064F330",
                "B1636FB8-39BD-408F-BEF7-0276823CCB51",
                "48EDB60C-852C-4ECF-B266-14984516D3B0",
                "F1491E1E-B2AC-4549-9714-1FBEFDBD2620",
                "B1636FB8-39BD-408F-BEF7-0276823CCB51",
                "61C0A17E-9E7E-4488-9AC4-AE87B5C4C7CD",
                "2C60F99C-1957-45C6-994C-79CED0FC4FCA",
                "408662D5-D650-44B2-AF56-88A4628F74F0",
                "A656554C-9F56-4168-920A-30F8C58E7621",
                "420F8110-F5C3-485F-A548-CF0DF66A395F",
                "2A60B5BC-59A2-45E0-ADCC-CB912821C7DD",
                "54F5E20E-55CB-485E-B656-4023D68FB5BC",
                "16CE7869-A5F0-4720-9452-6E70833ADAD2",
                "00000000-0002-0000-0000-000000000050",
                "9A9570C7-569E-46D7-AA25-EDCA4D11B81E",
                "DAC0BD81-863F-4B9B-AC9A-BA5A5481F26A",
                "B02E7E15-A1C1-4104-B596-249EBCFD6A0B",
                "816DA56B-298B-49D4-9747-FB6C3293EEF4",
                "969A598F-4FBE-4DB0-9AF1-677CAE1FDA64",
                "8278C448-A929-4F06-ADC9-BB61BA83DC03",
                "16CE7869-A5F0-4720-9452-6E70833ADAD2",
                "3F704D36-C14F-48F5-8FD6-D8154E0A1AD5",
                "3128FA7B-3D4A-4CF7-94FC-82A3DE699E3C" }
            );
        #endregion //MediaIds

        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindRelatedMedia;
            FindRelatedMediaFilter filter = new FindRelatedMediaFilter();

            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "de-DE", "fr-FR", "en-GB" }, new uint[] { 85, 5, 5, 5 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 1;  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50 }, new uint[] { 80, 20 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 80, 20 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 50, 50 });
            filter.OfferFilterLevel = 1;// StressHelper.GetInputValue(new int[] { 1, 2, 3 }, new uint[] { 10, 10, 10 });

            filter.MediaIds = StressHelper.GetInputValue(MediaIds, new UInt32[] { 1, 2, 4, 7}, new UInt32[] { 30, 55, 10, 5 });
            filter.MediaRelationshipTypes = StressHelper.GetInputValue(new Int32[] { 2, 8, 9, 10, 11, 12, 13 }, new UInt32[] { 1, 3, 5, 7 }, new UInt32[] { 10, 10, 40, 40 });
            filter.MediaTypes = StressHelper.GetInputValue(new Int32[] { 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 24 }, new UInt32[] { 1, 2, 3, 5, 7, 11}, new UInt32[] { 5, 5, 10, 15, 25, 40 });

            filter.OrderBy = 17;// StressHelper.GetInputValue(new int[] { 13, 14, 15, 16 }, new uint[] { 20, 20, 20, 40 });
            //     -- orderBy supports
            //    --  13 = Contributor.sortName
            //    --  14 = MediaContributor.character
            //    --  15 = MediaContributor.sortOrder
            //    --  16 = Role.sortOrder
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 50, 50 });

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }

    [StressTest(Priority = 100)]
    public class StressFindImages : QueryStressTestBase
    {
        #region MediaIds
        public static Guid[] MedaiIds_100 = StressHelper.CreateGuidArray(
            new String[] {
                "A76C923F-E7B2-4E28-A358-0EB402DF9BDC",
                "1AA01CF5-A744-4189-93AC-0F59132C9F8A",
                "E1A5E943-0519-42AA-A12B-0FA6F27A259B",
                "E86151BF-EF6F-4BF9-A692-0FD56AD78064",
                "F53D37FC-0ACF-46CA-8745-1028CBEB9326",
                "C792FC19-EBF1-42AE-B822-10806F0CF9BD",
                "E11C2506-D99E-47CC-ACA0-10E96508FD21",
                "2C419DCA-F0CD-4D85-9FDA-10F7D733495F",
                "FFCFDAA9-73FE-4A13-ADAE-11A0385AA7F3",
                "8AD486C9-F2B2-4F90-B1ED-11D29BF59DF7",
                "6B94CDE4-ADF7-4430-8991-1225F56B6DA3",
                "93F01F9E-1600-42D0-85D8-127AF6697688",
                "60559542-D29C-465E-93F4-1282C3FCB740",
                "ECFF21CA-95C8-49AF-BAF4-1284DFB7D336",
                "5B90BD95-E7EB-4D1B-9DC3-13411B2CC2E3",
                "4B7338A0-3613-4B55-AA98-13F826F0F387",
                "CFA6A794-BEAC-48CC-86FB-144546018BD0",
                "7884F12B-8C05-4E82-8B56-14B36E76CB34",
                "6AC9CA0F-D15A-4C99-AE7C-153123AAC4FA",
                "C3D67B15-D220-4244-874C-1668BF908B98",
                "E19B01EA-036E-46A5-8938-17608CC831C2",
                "E118260D-696C-4174-8A58-17F974893FC6",
                "780EA78D-0673-4045-B637-18FF51EDF0ED",
                "3C797849-0A25-4CCE-90AB-1921B3BCB8A5",
                "E0751ADE-CE2B-4FED-A08D-19DFDA8AB51B",
                "1AC7675B-11F9-4DD3-93A1-1A75FA760844",
                "FC9AC492-4C09-4DA0-B090-1E1069D41504",
                "A3F8D899-94A8-4CEB-B5EE-1E1308075F7E",
                "85D30D94-E14B-405D-9440-1E1F36AD21DC",
                "F02A2940-75B9-40F3-9FC4-1E3A2706E819",
                "72077E4B-F275-4842-BA97-1E490FED8946",
                "80FF1002-B3A5-49C8-BA0D-1F841E3422AB",
                "390DBEEA-C375-4C74-AD4E-1FB9DABE964F",
                "79C2CBB0-BC26-45DF-86CF-21A2267D56D5",
                "B0D75083-FE71-47F5-996F-222992E014A9",
                "3A72D3D1-19F0-4E96-856B-2356109B6C3D",
                "645A9D61-8B33-4D16-ABC8-23E27EA077A1",
                "1F09808E-064A-4CF0-B512-240C46C67BA2",
                "D5E0067D-26B5-4273-88F3-24D34C598F3D",
                "DF4A44CD-8DD5-4292-B049-24DE0B430DED",
                "11B6A501-E19A-4000-8977-26FAE5260A47",
                "C70638C4-A476-4028-9FD9-27B18F7386AB",
                "E3A05A78-B52E-4A70-9824-287B4DA2DD09",
                "264B34DC-74A6-455C-B90A-293F121CB7AE",
                "14A653B1-C3D4-499C-A970-299519146CAF",
                "1449046F-6948-457E-8AC4-2A41D1654533",
                "155105C2-4C20-4F0D-896B-2BA07AD3F0A6",
                "863021A3-C6A8-41CF-9B35-2D0437018595",
                "44A72CC4-5AEF-4D63-946C-2D3FBB93CC4C",
                "0E255B5B-E4CB-44D2-B146-2D8FF517B32A",
                "416E646B-D7B9-42CB-A50A-2EDC327F122C",
                "2255D02B-41A7-4C8B-A275-2FAD1239627D",
                "8FB64C2C-7829-4D66-8F1F-314EC6132105",
                "77EF722B-150F-47E1-8CD1-317316491A1A",
                "7A5EE914-950E-4535-BD2A-31E271F53788",
                "86C10A2F-9E14-4497-9620-3207EEB1B02A",
                "5F820225-0CC4-4D7F-9CE7-337BE453E974",
                "6A3614A3-3334-4ED1-98FC-351D852D4238",
                "C2BCE327-4A79-45FB-9450-3525B47111EF",
                "FB2C9E15-AB24-41B8-AA8B-362DC9FCCBDD",
                "5D84FF6E-B161-4E8D-81C8-377E830D5F2C",
                "20670CCE-C9B1-4C83-9CCE-37820874D9AB",
                "50204B66-D464-4491-B277-37E1379A73F4",
                "BE8C7CC0-698D-44D3-A369-397057504FE1",
                "795A4B8F-0D72-421E-A458-39CD9DEB2470",
                "526A0E1A-0F49-4F46-BCE9-39D135EC4FFD",
                "DFC9A729-1921-4FB2-806D-3B04211C5BE4",
                "C4F64D2A-B5A8-4829-8027-3B47927A30AA",
                "0F8E3757-7ADD-4CF3-9F9E-3B77F77AE876",
                "74FEB42F-C26F-4547-9D40-3D36AC9FCA11",
                "527C356D-5803-4208-96D5-3D4417DE3F67",
                "A49A0CFC-531A-46DA-826E-3DAAAFE5DFC4",
                "0A9FBEEC-CA6F-42CD-BB30-3DCCF1E09345",
                "E71F1D93-8480-42EA-811D-3FB570523976",
                "FB443B7B-5679-490F-8CD1-3FFC2E851897",
                "F2B385F9-C76C-4D78-9911-409FB2330B8B",
                "A2FC53FB-1657-438C-9087-40B3B0DE9586",
                "9993DDBF-6460-4A71-86A1-4132859AECF2",
                "F417C4B5-1281-42F3-83DD-415A54248EB1",
                "0BFD4FBA-52B4-4727-8C74-43EA15768A45",
                "9D9973F6-0AB3-43D4-BFB8-454DDAA824C6",
                "EB33587B-DAFD-4CD0-AEDF-460ECF9187FD",
                "86B06778-CA8C-45D9-A2B1-469EEA03A14C",
                "EB8876A9-2CAA-4BE0-80A1-472E6D0C9F83",
                "9CBC1CD7-FDBA-4D61-AE37-4760D1292386",
                "C8630787-C40E-41BD-8906-4835DE7EA1F5",
                "E1C40E6B-B2BE-412D-9AEB-48B0163A377B",
                "57B608C3-4FFD-406E-8E31-48C28A34323F",
                "4E92E235-8583-42E2-BF47-48E3CDB5013C",
                "576C1BCB-C6B5-4DA8-8F0C-498F8DB78376",
                "0BEF7D5E-97AA-49E9-9B85-4A5052BB3F87",
                "CDFC32CB-20E3-4A03-96D9-4B63C571A3DE",
                "FB5DB63E-2689-44AD-9269-4BC1FB8A8F17",
                "100B3EE2-5BB6-45FC-BF25-4BD663FAB4C6",
                "51B547CF-08A5-40D4-BDA7-4C1E3D1AB00A",
                "DD2FDA41-6B41-480C-B704-4C5CEC08338F",
                "DEDB4413-97C4-4CA1-96A2-4C7241F0BE84",
                "FE29BA1C-6DC8-42D0-9CF1-4CF090ECBE87",
                "19D19F18-9A6B-475F-99DC-4D581287E802",
                "2CA8F437-06B0-44A9-A84C-4E01AB1AC0D5" 
            }
        );
        #endregion

        protected override void Init()
        {
            base.Init();

            MethodName = QueryRequestBase.QueryMethod.FindImages;
            FindImagesFilter filter = new FindImagesFilter();

            filter.Locale = StressHelper.GetInputValue(new string[] { "en-US", "de-DE", "fr-FR", "en-GB" }, new uint[] { 85, 5, 5, 5 });
            filter.LegalLocale = filter.Locale;  // make LegalLocale and Locale the same for now
            filter.Store = 1;  // xbox only for now
            filter.PageSize = StressHelper.GetInputValue(new int[] { 10, 50 }, new uint[] { 80, 20 });
            filter.PageNum = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 80, 20 });
            filter.DetailView = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 50, 50 });
            filter.OfferFilterLevel = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 50, 50 });

            filter.MediaIds = StressHelper.GetInputValue(MedaiIds_100, new UInt32[] { 2 }, new UInt32[] { 100 });
            filter.MediaTypes = StressHelper.GetInputValue(new Int32[] { 1, 18, 19, 20 }, new UInt32[] { 1, 2 }, new UInt32[] { 80, 20 });

            filter.ImageFormats = StressHelper.GetInputValue(new Int32[] { 1, 2, 3, 4 }, new UInt32[] { 1, 2, 4 }, new UInt32[] { 70, 20, 10 });
            filter.ImageSizes = StressHelper.GetInputValue(new Int32[] { 1, 2, 3, 4, 5, 6 }, new UInt32[] { 1, 2, 4 }, new UInt32[] { 70, 20, 10 });

            filter.OrderBy = StressHelper.GetInputValue(new int[] { 1, 2, 3}, new uint[] { 33, 33, 34 });
            filter.OrderDirection = StressHelper.GetInputValue(new int[] { 1, 2 }, new uint[] { 50, 50 });

            List<StringPair> filterList = filter.ToList();
            req = new GenericQueryRequest(MethodName, filterList);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\CatalogWatcher.cs ===
//
// CatalogWatcher.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// The parent component that creates and runs the producer and the publisher

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Web;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.catalogwatcherlog)]

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// This component creates the producer and consumer
    /// </summary>
    public class CatalogWatcher
    {
        private DocumentsQueue _producerQueue = null;   // The producer consumer queue
        private DocumentsQueue _publisherQueue = null;  // The publisher queue
        private AutoResetEvent _producerWorkerDoneEvent = new AutoResetEvent(false);    // Event to indicate that the producer worker is done
        private AutoResetEvent _processorWorkerDoneEvent = new AutoResetEvent(false);   // Event to indicate that the processor worker is done
        private AutoResetEvent _publisherWorkerDoneEvent = new AutoResetEvent(false);   // Event to indicate that the publisher worker is done
        private IWatcherDocumentProducer _producer = null;  // The document producer
        private IWatcherDocumentProcessor _processor = null;    // The document processor
        private IWatcherDocumentPublisher _publisher = null; // The Document publisher
        private DocumentStatus _statusUpdater = null;   // The component that updates the LSN in the database
        private string _instanceName = String.Empty;        // The name of this catalog watcher instance
        private string _producerQueueName = string.Empty;   // The name of the producer queue
        private string _publisherQueueName = string.Empty;  // The name of the publisher queue
        private volatile bool _shouldAbort = false; // volatile?

        /// <summary>
        /// Abort the catalogwatcher
        /// </summary>
        public void SetAbortFlag(bool shouldAbort)
        {
            _shouldAbort = shouldAbort;
        }

        /// <summary>
        /// Gets the documents from the producer and puts them in the queue
        /// This function gets a batch of documents from the producer and adds them one at a time to the queue
        /// Once its done or if there is an error it calls Shutdown() on the queue and signals the 'parent' thread
        /// </summary>
        private void ProducerWorker(object o)
        {
            int batchSize = _producer.GetMaxBatchSize();
            try
            {
                int i = 0;
                while (!_shouldAbort)
                {
                    bool bAddedDocToQueue = false;
                    int actualBatchSize = 0;

                    IEnumerable<IWatcherDocument> documents = _producer.GetNextBatchOfDocuments(batchSize);
                    foreach (IWatcherDocument document in documents)
                    {
                        actualBatchSize++;
                        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                        // Add the document to the queue
                        bAddedDocToQueue = _producerQueue.Enqueue(document);
                        long elapsed = timeElapsed.TimeElapsed;
                        QueueCounters.Counters[_producerQueueName].EnqueueWaitTime.RawValue = elapsed;
                        QueueCounters.Counters[_producerQueueName].AverageWaitTime.IncrementBy(elapsed);
                        QueueCounters.Counters[_producerQueueName].AverageWaitTimeBase.Increment();
                        if (!bAddedDocToQueue)
                        {
                            // adding to the queue failed! bail out
                            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Could not add to the queue.", _producer.InstanceName));
                            break;
                        }
                        i++;
                    }
                    if (!bAddedDocToQueue)
                    {
                        break;
                    }

                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Added {1} documents to the queue in current iteration", _producer.InstanceName, i));

                    // If we never got any documents back from 'GetNextBatchOfDocuments()', then we are done
                    // in a clean manner.
                    if (actualBatchSize == 0)
                    {
                        Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Finished producing documents", _producer.InstanceName));
                        break;
                    }
                }
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Added {1} total documents to the queue.", _producer.InstanceName, i));
                _producer.Report = new WorkerReport(false, "", 0, i);
            }
            catch (Exception e)
            {
                string errorStr = String.Format("{0}| Exception caught in the ProducerWorker: ", _producer.InstanceName);
                Xom.Log(XomAreaName.catalogwatcherlog, e, errorStr);
                Xom.NtEvent(XEvent.Id.CATALOG_WATCHER_PRODUCER_EXCEPTION, e, errorStr);
                _producer.Report = new WorkerReport(true, e.ToString(), Convert.ToUInt32(XEvent.Id.CATALOG_WATCHER_PRODUCER_EXCEPTION));
            }
            finally
            {
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Shutting down", _producer.InstanceName));
                // We are done. Let the publisher worker and the 'parent' catalogwatcher know about it.
                _producerQueue.Shutdown();
                _producerWorkerDoneEvent.Set();
            }
        }

        private void ProcessorWorker(object o)
        {
            try
            {
                int i = 0;

                while (!_shouldAbort)
                {
                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                    IWatcherDocument doc = _producerQueue.Dequeue();
                    long elapsed = timeElapsed.TimeElapsed;
                    QueueCounters.Counters[_producerQueueName].DequeueWaitTime.RawValue = elapsed;
                    QueueCounters.Counters[_producerQueueName].AverageWaitTime.IncrementBy(elapsed);
                    QueueCounters.Counters[_producerQueueName].AverageWaitTimeBase.Increment();

                    if (doc == null) // Are we done?
                    {
                        Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Finished processing all documents from queue", _processor.InstanceName));
                        break;
                    }

                    // Process the document - currently, doing nothing
                    _processor.ProcessDocument(doc);

                    // Add it to the publisher queue
                    timeElapsed = new XomRequestTimeElapsed();
                    bool bAddedDocToQueue = _publisherQueue.Enqueue(doc);
                    elapsed = timeElapsed.TimeElapsed;
                    QueueCounters.Counters[_publisherQueueName].EnqueueWaitTime.RawValue = elapsed;
                    QueueCounters.Counters[_publisherQueueName].AverageWaitTime.IncrementBy(elapsed);
                    QueueCounters.Counters[_publisherQueueName].AverageWaitTimeBase.Increment();
                    if (!bAddedDocToQueue)
                    {
                        // adding to the queue failed! bail out
                        Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Could not add to the queue.", _processor.InstanceName));
                        break;
                    }

                    i++;
                }

                _processor.Report = new WorkerReport(false, "", 0, i);
            }
            catch (Exception e)
            {
                string errorStr = String.Format("{0}| Exception caught in the ProcessorWorker", _processor.InstanceName);
                Xom.Log(XomAreaName.catalogwatcherlog, e, errorStr);
                Xom.NtEvent(XEvent.Id.CATALOG_WATCHER_PROCESSOR_EXCEPTION, e, errorStr);
                _processor.Report = new WorkerReport(true, e.ToString(), Convert.ToUInt32(XEvent.Id.CATALOG_WATCHER_PROCESSOR_EXCEPTION));
            }
            finally
            {
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Shutting down", _processor.InstanceName));
                // We are done. Let the producer worker and the 'parent' CatalogWatcher know about it.
                _producerQueue.Shutdown();
                _publisherQueue.Shutdown();
                _processorWorkerDoneEvent.Set();
            }
        }

        /// <summary>
        /// Removes the documents from the queue and publishes it to FAST
        /// This function removes one document at a time from the queue and publishes it to FAST
        /// After adding a batch of documents, it commits them to FAST and also calls the DocumentStatus to update the status of the processed document
        /// </summary>
        private void PublisherWorker(object o)
        {
            try
            {
                // max number of documents in one batch flushed to Publisher
                int maxDocumentsPerBatch = _publisher.GetMaxDocumentsPerBatch();
                int curNonFlushedDocCount = 0;
                int totalDocsProcessed = 0;
                bool commitStatusPerBatch = _publisher.CommitStatusPerBatch();
                bool commitStatusOnError = _publisher.CommitStatusOnError();
                while (!_shouldAbort)
                {
                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                    // Remove a document from queue
                    IWatcherDocument doc = _publisherQueue.Dequeue();
                    long elapsed = timeElapsed.TimeElapsed;
                    QueueCounters.Counters[_publisherQueueName].DequeueWaitTime.RawValue = elapsed;
                    QueueCounters.Counters[_publisherQueueName].AverageWaitTime.IncrementBy(elapsed);
                    QueueCounters.Counters[_publisherQueueName].AverageWaitTimeBase.Increment();
                    if (doc == null) // Are we done?
                    {
                        Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Finished publishing all documents from queue", _publisher.InstanceName));
                        break;
                    }
                    curNonFlushedDocCount++;
                    totalDocsProcessed++;
                    // Publish the document
                    _publisher.PublishDocument(doc);
                    // Add the document status updater
                    _statusUpdater.AddDocument(doc);
                    if (curNonFlushedDocCount == maxDocumentsPerBatch) // Have we processed a complete batch?
                    {
                        // Flush the documents to FAST
                        _publisher.FlushDocuments();

                        if (commitStatusPerBatch && (commitStatusOnError || !ErrorOccurred()))
                        {
                            // commit to the document status updater
                            _statusUpdater.Commit();
                        }

                        // reset our current document count
                        curNonFlushedDocCount = 0;
                    }
                }

                if (curNonFlushedDocCount != 0) // Any outstanding documents to be flushed
                {
                    _publisher.FlushDocuments();
                }

                // If we are not aborting ...
                // commit to the DocumentStatus updater if the operation was not aborted and the producer has added all the documents to the queue
                if (!_shouldAbort && (commitStatusOnError || !ErrorOccurred()))
                {
                    _publisher.Close(); // Finish any pending actions to the Publisher Destination
                    
                    _statusUpdater.CommitAllProcessedDocuments();
                }
                _publisher.Report = new WorkerReport(false, "", 0, totalDocsProcessed);
            }
            catch (Exception e)
            {
                string errorStr = String.Format("{0}| Exception caught in the PublisherWorker", _publisher.InstanceName);
                Xom.Log(XomAreaName.catalogwatcherlog, e, errorStr);
                Xom.NtEvent(XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION, e, errorStr);
                _publisher.Report = new WorkerReport(true, e.ToString(), Convert.ToUInt32(XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION));
            }
            finally
            {
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Shutting down", _publisher.InstanceName));
                // We are done. Let the producer worker and the 'parent' CatalogWatcher know about it.
                _publisherQueue.Shutdown();
                _publisherWorkerDoneEvent.Set();
            }
        }

        /// <summary>
        /// Producer, processor and publisher workers are on different threads
        /// Peek if any errors occurred in any
        /// </summary>
        private bool ErrorOccurred()
        {
            bool ret = false;
            
            if (_producer != null && _producer.Report != null && _producer.Report.HasErrors)
            {
                ret = true;
            }
            else if (_publisher != null && _publisher.Report != null && _publisher.Report.HasErrors)
            {
                ret = true;
            }
            else if (_processor != null && _processor.Report != null && _processor.Report.HasErrors)
            {
                ret = true;
            }

            return ret;
        }

        /// <summary>
        /// Launches producer and publisher workers on different threads and waits for their completion
        /// It also creates the shared producer-consumer queue
        /// </summary>
        public void Execute(ref Hashtable args)
        {
            int bucketId = 0;
            int numberOfBuckets = 0;
            string destinationName = String.Empty;
            string resourceName = String.Empty;
            WorkerReport watcherReport = null;
            try
            {
                // Input parameters validation
                object objBucketId = args["BucketId"];
                if (objBucketId == null || objBucketId.GetType() != typeof(int))
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER,
                        XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                        "BucketId missing or invalid. BucketId should be an integer.");
                }

                object objNumberOfBuckets = args["NumberOfBuckets"];
                if (objNumberOfBuckets == null || objNumberOfBuckets.GetType() != typeof(int))
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER,
                        XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                        "NumberOfBuckets missing or invalid. NumberOfBuckets should be a natural number.");
                }

                object objDestinationName = args["DestinationName"];
                if (objDestinationName == null || objDestinationName.GetType() != typeof(String))
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER,
                        XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                        "DestinationName missing or invalid. DestinationName should be of type string.");
                }

                object objResourceName = args["ResourceName"];
                if (objResourceName == null || objResourceName.GetType() != typeof(String))
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER,
                        XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                        "ResourceName missing or invalid. ResourceName should be of type string.");
                }

                bucketId = (int)objBucketId;
                numberOfBuckets = (int)objNumberOfBuckets;
                destinationName = (string)objDestinationName;
                resourceName = (string)objResourceName;

                _instanceName = String.Format("CatalogWatcher|Watcher|{0}|{1}|{2:D3}", resourceName, destinationName, bucketId);
                _producerQueueName = String.Format("Producer_{0:D3}", bucketId);
                _publisherQueueName = String.Format("Publisher_{0:D3}", bucketId);

                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Executing ...", _instanceName));

                // Create the producer
                using (_producer = DocumentProducerFactory.CreateProducer(resourceName, destinationName))
                {
                    // Initialize the producer with the bucket information
                    _producer.Init(bucketId, numberOfBuckets);
                    // Create the document processor
                    using (_processor = DocumentProcessorFactory.CreateProcessor(resourceName, destinationName))
                    {
                        _processor.Init(bucketId, numberOfBuckets);

                        // Create the ESP publisher
                        using (_publisher = DocumentPublisherFactory.CreatePublisher(resourceName, destinationName))
                        {
                            _publisher.Init(bucketId, numberOfBuckets);
                            // Create the document status updater
                            _statusUpdater = new DocumentStatus(bucketId, destinationName, resourceName);
                            // Create the shared producer-publisher queue
                            using (_producerQueue = new DocumentsQueue(_producer.GetMaxQueueLength()))
                            {
                                using (_publisherQueue = new DocumentsQueue(_producer.GetMaxQueueLength()))
                                {
                                    // Kick off the thread workers for the producer and the publisher
                                    ThreadPool.QueueUserWorkItem(new WaitCallback(ProducerWorker));
                                    ThreadPool.QueueUserWorkItem(new WaitCallback(ProcessorWorker));
                                    ThreadPool.QueueUserWorkItem(new WaitCallback(PublisherWorker));
                                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Created producer,processor & publisher workers.  Waiting for them to be done ...", _instanceName));
                                    // Wait for the producer to be done
                                    _producerWorkerDoneEvent.WaitOne();
                                    // Wait for the processor to be done
                                    _processorWorkerDoneEvent.WaitOne();
                                    // Wait for the publisher to be done
                                    _publisherWorkerDoneEvent.WaitOne();
                                    _producerWorkerDoneEvent.Close();
                                    _processorWorkerDoneEvent.Close();
                                    _publisherWorkerDoneEvent.Close();
                                    watcherReport = new WorkerReport(false, "", 0);
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                string errorStr = String.Format("{0}: Exception in CatalogWatcher", _instanceName);
                Xom.NtEvent(XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION, e, errorStr);
                Xom.Log(XomAreaName.catalogwatcherlog, e, errorStr);
                watcherReport = new WorkerReport(true, e.ToString(), Convert.ToUInt32(XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION), -1);
            }
            finally
            {
                if (_shouldAbort)
                {
                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Exiting - operation aborted!", _instanceName));
                }
                else
                {
                    if (watcherReport == null || !watcherReport.HasErrors)
                    {
                        if (_producer != null && _producer.Report != null && _producer.Report.HasErrors)
                        {
                            watcherReport = _producer.Report;
                        }
                        else if (_publisher != null && _publisher.Report != null && _publisher.Report.HasErrors)
                        {
                            watcherReport = _publisher.Report;
                        }
                        else if (_processor != null && _processor.Report != null && _processor.Report.HasErrors)
                        {
                            watcherReport = _processor.Report;
                        }
                    }
                    if (watcherReport != null && watcherReport.HasErrors)
                    {
                        WorkerReport.UpdateReport(_instanceName, bucketId, destinationName, resourceName, watcherReport.ErrorCode, watcherReport.ErrorString);
                    }
                    else // No errors!
                    {
                        if (_producer.Report.DocumentsProcessed == 0 && _processor.Report.DocumentsProcessed == 0 && _publisher.Report.DocumentsProcessed == 0)
                        {
                            // We did not process any documents; that means this watcher is done processing all documents!
                            WorkerReport.UpdateReport(_instanceName, bucketId, destinationName, resourceName, 1, "");
                        }
                        else
                        {
                            // We did some work
                            WorkerReport.UpdateReport(_instanceName, bucketId, destinationName, resourceName, 0, "");
                        }
                    }

                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Exiting cleanly", _instanceName));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\CatalogWatcherReport.cs ===
using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Web;

using xonline.common.sql.sqlclient;
using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.catalogwatcherlog)]

namespace xonline.server.catalogwatcher
{

    public class WorkerReport
    {
        public bool HasErrors { get; set; }
        public string ErrorString { get; set; }
        // If error then status code then < 0
        // If no error and work done then  0
        // If no work to be done then 1
        public uint ErrorCode { get; set; }
        public int DocumentsProcessed { get; set; }

        public WorkerReport()
        {
            HasErrors = false;
            ErrorString = null;
            ErrorCode = 0;
            DocumentsProcessed = 1;
        }
        
        public WorkerReport(bool bError, string e, uint code)
        {
            HasErrors = bError;
            ErrorString = e;
            ErrorCode = code;
            DocumentsProcessed = -1;
        }

        public WorkerReport(bool bError, string e, uint code, int docs)
        {
            HasErrors = bError;
            ErrorString = e;
            ErrorCode = code;
            DocumentsProcessed = docs;
        }
        public static void UpdateReport(string instanceName, int instanceId, string destinationName, string resourceName, uint status, string text)
        {
            try
            {
                using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
                {
                    sqlClient.StoredProc = "dbo.p_catalog_watcher_set_report";
                    sqlClient.AddParameter("@i_bucket_id", instanceId);
                    sqlClient.AddParameter("@vc_destination_name", destinationName);
                    sqlClient.AddParameter("@vc_resource_name", resourceName);
                    sqlClient.AddParameter("@i_status_code", status);
                    sqlClient.AddParameter("@vc_text", text);
                    sqlClient.AddParameter(ParameterDirection.ReturnValue, "@returnValue", 0);
                    string outputText = String.Empty;
                    sqlClient.AddParameter(ParameterDirection.Output, "@outputText", outputText, -1);

                    sqlClient.Execute();

                    // Check if update was success
                    int returnValue = (int)sqlClient.Command.Parameters["@returnValue"].Value;

                    if (returnValue != 1)
                    {
                        Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Could not update health status. Error Code:{1}. Error: ", instanceName, returnValue, outputText));
                    }
                }
            }
            catch (Exception)
            {                
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Could not update health status. ", instanceName));
                throw;
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\CatalogWatcherTracer.cs ===
// 
// CatalogWatcherTracer.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This class implements the tracing for a media through the watcher 

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Web;
using System.Net;
using System.IO;
using System.Xml;
using System.Xml.XPath;


using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;

namespace xonline.server.catalogwatcher
{
    public class CatalogWatcherTracer
    {
        private string _cronMachineName;
        private int _cronPort;
        private string _marketplaceFDName;
        private int _marketplaceFDPort;
        private Guid _mediaId;
        private DateTime _modifiedDateUTC = DateTime.MinValue;
        private uint _xmgmtRequestId;
        private StringBuilder _result;
        private int _curStepNum = 1;
        private bool _isInitialized = false;

        public CatalogWatcherTracer(uint reqId)
        {
            _xmgmtRequestId = reqId;
        }

        private void Init()
        {
            if (!_isInitialized)
            {
                _isInitialized = true;
                IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.cron_int);
                _cronMachineName = info.IPAddressString;
                _cronPort = info.Port;
                info = Config.GetVirtualInterface(VirtualInterface.marketplacecatalog);
                _marketplaceFDName = info.IPAddressString;
                // This is a last minute hack we need to put in.
                // In expanded environments, the VIP is configured to listen on port 80
                _marketplaceFDPort = Config.Environment.ToLower().Equals("xblob") ? info.Port : 80;
            }
        }

        private void SendToXmgmt(string msg)
        {
            SendToXmgmt(msg, true);
        }

        private void SendToXmgmt(string msg, bool appendNewLineAtEnd)
        {
            if (appendNewLineAtEnd)
            {
                msg += System.Environment.NewLine;
            }
            if (_xmgmtRequestId != uint.MaxValue)
            {
                XomControlConnection.SendMessage(msg, _xmgmtRequestId);
            }
            else
            {
                _result.Append(msg);
            }
        }

        private HResult RunCommand(Hashtable args, StringBuilder response)
        {
            UserCommandHandler userCommand = new UserCommandHandler();
            return userCommand.Command(args, response);
        }

        /// <summary>
        /// Refreshes the document by calling the 'RefreshProductMediaIds' command
        /// </summary>
        private void RefreshDocument()
        {            
            SendToXmgmt(String.Format("Step# {0}. Starting the Refresh at: {1} GMT ", _curStepNum++, DateTime.Now.ToUniversalTime()));
            Hashtable args = new Hashtable();
            args["op"] = "RefreshProductMediaIds";
            args["p1"] = _mediaId.ToString();
            StringBuilder response = new StringBuilder();
            if(RunCommand(args,response).IsFailure())
            {
                throw new Exception("Could not refresh the Media " + response);
            }
        }

        private byte[] GetMaxLSN()
        {
            return new byte[] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
        }

        /// <summary>
        /// Gets the latest LSN from the RawCatalog
        /// </summary>
        /// <param name="mediaPipelineStage"></param>
        /// <returns>a value indicating where the media has reached in the pipeline (0 = not in cdc, 1 = in cdc, 2 = in TODO table) </returns>
        private byte[] GetLatestLSN(out int mediaPipelineStage)
        {
            byte[] lsn = new byte[20];
            using (SqlClient client = new SqlClient("ContentIngestionCatalogDB", false))
            {
                client.Command.CommandTimeout = Config.GetIntSetting(Setting.catalogwatcher_commands_timeout_in_secs);
                client.StoredProc = "CatalogWatcherGetLSNForMedia";
                DataTable table = new DataTable();
                table.Columns.Add(new DataColumn("id", typeof(Guid)));
                table.Rows.Add(new Object[] { _mediaId});
                SqlParameter mediaIds = client.Command.Parameters.AddWithValue("@mediaIds", table);
                mediaIds.SqlDbType = SqlDbType.Structured;
                mediaIds.TypeName = "dbo.IDTable";
                client.AddParameter(ParameterDirection.Input, "@lsnBeforeUpdate", 0x0);
                client.AddParameter(ParameterDirection.Output, "@lsnAfterUpdate", lsn, lsn.Length);
                _modifiedDateUTC = DateTime.MinValue;
                client.AddParameter(ParameterDirection.Output, "@modifiedDate", _modifiedDateUTC);
                client.AddParameter(ParameterDirection.Output, "@mediaPipelineStage", 0);
                client.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                using (SqlDataReader r = client.Execute())
                {
                    // Check if the proc executed successfully
                    HResult hr = (uint)client.GetIntParameter("@hr");
                    if (hr.IsFailure())
                    {
                        throw new Exception("Could not get the latest lsn");
                    }
                    _modifiedDateUTC = Convert.IsDBNull(client.GetDateParameter("@modifiedDate")) ? DateTime.MaxValue : client.GetDateParameter("@modifiedDate");
                    lsn = Convert.IsDBNull(client.GetByteArrayParameter("@lsnAfterUpdate")) ? GetMaxLSN() : client.GetByteArrayParameter("@lsnAfterUpdate");
                    mediaPipelineStage = Convert.IsDBNull(client.GetIntParameter("@mediaPipelineStage")) ? 0 : client.GetIntParameter("@mediaPipelineStage");
                }
            }
            return lsn;
        }

        /// <summary>
        /// Is the given lsn processed by the watcher
        /// This calls the 'IsLsnProcessed' command and parses the response to figure out if the lsn has been processed or not
        /// </summary>
        /// <param name="lsn"></param>
        /// <returns></returns>
        private bool IsLsnProcessed(byte[] lsn)
        {
            Hashtable args = new Hashtable();
            args["op"] = "IsLSNProcessed";
            // The BitConverter.ToString() returns the binary values as 01-A1-24-90. So we need to remove those '-'
            args["p1"] = "0x" + BitConverter.ToString(lsn).Replace("-", "");
            StringBuilder response = new StringBuilder();
            if (RunCommand(args, response).IsFailure())
            {
                throw new Exception("IsLsnProcessed command failed: " + response);
            }
            bool isComplete = true;
            // TODO:: This is ugly but will work for now
            if (response.ToString().ToLower().Contains("not"))
            {
                isComplete = false;
            }
            return isComplete;
        }

        /// <summary>
        /// Determine whether the Media has been ingested into the FAST ESP.
        /// This function also figures out which stage the media is in (cdc, TODO, FAST ESP)
        /// </summary>
        /// <returns></returns>
        private bool IsMediaIngestedIntoFAST()
        {
            bool timedOut = false;
            DateTime startTime = DateTime.Now;
            SendToXmgmt(String.Format("Step# {0}. Checking if media is in cdc.Media. This may take a few minutes.",_curStepNum++));
            bool printInCDC = true;
            bool printInTODO = true;
            int mediaPipelineStage = 0;
            while (true)
            {
                byte[] lsn = GetLatestLSN(out mediaPipelineStage);
                // mediaPipeline = { 0 not in cdc, 1 = in cdc, 2 = in TODO }
                if(mediaPipelineStage != 0)
                {
                    if (mediaPipelineStage >= 1 && printInCDC)
                    {
                        printInCDC = false;
                        SendToXmgmt("          Media is in cdc.Media.");
                        SendToXmgmt(String.Format("Step# {0}. Checking if media is in CatalogWatcherToDoProduct table. This may take a few minutes.", _curStepNum++));
                    }
                    if (mediaPipelineStage == 2 && printInTODO)
                    {
                        printInTODO = false;
                        SendToXmgmt("          Media is in CatalogWatcherToDoProduct table");
                        SendToXmgmt(String.Format("Step# {0}. Checking if the CatalogWatcher has processed the Media. This may take a few minutes.", _curStepNum++));
                    }
                }
                if (mediaPipelineStage == 2 && IsLsnProcessed(lsn))
                {
                    break;
                }
                TimeSpan elapsed = DateTime.Now.Subtract(startTime);
                if (elapsed.Minutes > 10)
                {
                    timedOut = true;
                    break;
                }
                SendToXmgmt(".", false);
                Thread.Sleep(5000);
            }
            return !timedOut;
        }

        private Stream DownloadXml(string query)
        {
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(query);
            HttpWebResponse response = (HttpWebResponse)request.GetResponse();
            return response.GetResponseStream();
        }


        private bool DoesFDHaveLatestDocument()
        {
            string query = String.Format("http://{0}:{1}/MarketplaceCatalog/v1/product/en-US?tiers=2.3&offerfilter=1&products={2}", _marketplaceFDName, _marketplaceFDPort,  _mediaId);
            XmlNamespaceManager mngr = new XmlNamespaceManager(new NameTable());
            string liveNamespace = "http://www.live.com/marketplace";
            string atomNamespace = "http://www.w3.org/2005/Atom";
            mngr.AddNamespace("l", liveNamespace);
            mngr.AddNamespace("a", atomNamespace);
            bool timedOut = false;
            DateTime startTime = DateTime.Now;
            SendToXmgmt(String.Format("Step# {0}. Checking if MarketplaceCatalog FD [{1}:{2}] has the updated media. This may take a few minutes.",_curStepNum++, _marketplaceFDName, _marketplaceFDPort));
            while (true)
            {
                XPathDocument document = new XPathDocument(DownloadXml(query));
                XPathNavigator navigator = document.CreateNavigator();
                XPathNodeIterator iter = navigator.Select("/a:feed/a:entry", mngr);
                if (iter.MoveNext())
                {
                    XPathNavigator nav = iter.Current;
                    XPathNodeIterator iter2 = nav.Select("a:updated", mngr);
                    if (!iter2.MoveNext())
                    {
                        throw new Exception("Fatal Error: Document does not have a modified time node");
                    }
                    DateTime updatedTime = DateTime.Parse(iter2.Current.Value);
                    if (updatedTime.ToUniversalTime().CompareTo(_modifiedDateUTC) >= 0)
                    {
                        break;
                    }
                }
                TimeSpan elapsed = DateTime.Now.Subtract(startTime);
                if (elapsed.Minutes > 5)
                {
                    timedOut = true;
                    break;
                }
                SendToXmgmt(".", false);
                Thread.Sleep(2000);
            }
            return !timedOut;
        }


        /// <summary>
        /// Traces a document all the way through the Watcher pipeline
        /// </summary>
        /// <param name="paramNames"></param>
        /// <param name="paramValues"></param>
        /// <param name="result"></param>
        /// <returns></returns>
        public HResult Trace(List<string> paramNames, List<string> paramValues, StringBuilder result)
        {
            HResult hr = HResult.S_OK;
            Init();
            _result = result;
            if (paramValues.Count != 1)
            {
                hr = HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER;
                result.Append("Invalid parameter. The format of the command is: trace mediaId");
            }
            else
            {
                _mediaId = Guid.Empty;
                try
                {
                    _mediaId = new Guid(paramValues[0]);
                }
                catch (FormatException fe)
                {
                    result.Append("Parameter is not a valid Guid. ");
                    result.Append(fe);
                    hr = HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER;
                    return hr;
                }
                SendToXmgmt("This command traces a mediaId all the way through the Watcher Pipeline.");
                SendToXmgmt("This is a 5 step process ...");
                RefreshDocument();
                SendToXmgmt("          Successfully updated the media in RawCatalogDB");
                if (IsMediaIngestedIntoFAST())
                {
                    SendToXmgmt("          Catalog Watcher successfully pushed the media into FAST ESP. The modified date on the media is: "+_modifiedDateUTC);
                    if (DoesFDHaveLatestDocument())
                    {
                        SendToXmgmt("          The media was successfully returned by the MarketplaceCatalog FD");
                        SendToXmgmt("The trace command completed successfully.");
                    }
                    else
                    {
                        SendToXmgmt(System.Environment.NewLine + "Timed out!! Could not verify the status of the media in the Marketplace FD");
                    }
                }
                else
                {
                    SendToXmgmt(System.Environment.NewLine + "Timed out!! Could not verify the status of the media in the Catalog Watcher");
                }
                SendToXmgmt(String.Format("End Time: {0} GMT", DateTime.Now.ToUniversalTime()));

            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\CatalogWatcherInstaller.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.server.catalogwatcher
{
    // Installers for the performance counters
    [RunInstaller(true)]
    public class CatalogWatcherInstaller : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class CatalogWatcherPerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\Constant.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{
    public static class Constants
    {
        public static readonly string ZuneApp_ResourceName = "ZuneApp";
        public static readonly string ZuneApp_DestinationName = "ESP";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DetectorCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.installer;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.catalogwatcher
{
    [XomPerformanceCounterCategoryAttr("Catalog Watcher: Detector Perf Counters", "Counters for the Detector")]
    public class DetectorCounters : XomPerformanceCounterCategory
    {
        public static DetectorCounters Counters = new DetectorCounters();

        public DetectorCounters this[string instanceName]
        {
            get
            {
                return (DetectorCounters)GetInstance(instanceName);
            }
        }

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. execution time",
            "Average time taken by the Detector",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. execution time base",
            "Base for the average time taken by the Detector",
        PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Number of items detected",
            "Total number of items detected",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter DetectedIdsCount;



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentInterfaces.cs ===
// 
// Document.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Diagnostics;


namespace xonline.server.catalogwatcher
{    
    // This represents the document which is generated by the producer and published by the publisher
    public interface IWatcherDocument
    {
        // The unique Id that identifies the document
        string DocumentId { get;}
        // The actual document that gets generated and published
        Object Document { get;}        
    }    
    
    public interface ILSNDocument: IWatcherDocument
    {
        LSN LSN {get;}
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentBuilderFactory.cs ===
using System;

namespace xonline.server.catalogwatcher
{
    public class DocumentBuilderFactory
    {
        public static IDocumentBuilder CreateDocumentBuilder(string documentType)
        {
            switch(documentType)
            {
                case "Video":
                    return new VideoDocumentBuilder();
                default:
                    throw new InvalidOperationException(
                        String.Format("Incorrect document type provided to CreateDocumentBuilder(): {0}", 
                        documentType));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentProcessorNoop.cs ===
namespace xonline.server.catalogwatcher
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl;

    using xonline.common.config;
    using xonline.common.mgmt;
    using xonline.common.sql.sqlclient;

    public class DocumentProcessorNoop : IWatcherDocumentProcessor
    {
        private string _name = string.Empty;

        private readonly string c_resourceName;
        private readonly string c_destinationName;

        /// Returns the name of this publisher instance
        /// </summary>
        public String InstanceName
        {
            get { return _name; }
        }

        private WorkerReport _report = null;

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }

        public void Dispose()
        {
        }

        public DocumentProcessorNoop(string resourceName, string destinationName)
        {
            c_resourceName = resourceName;
            c_destinationName = destinationName;
        }

        public void Init(int bucketId, int numBuckets)
        {
            _name = String.Format("CatalogWatcher|Processor|{0}|{1}|{2:D3}", c_resourceName, c_destinationName, bucketId);
        }

        public void ProcessDocument(IWatcherDocument doc)
        {
            IDisposable dispDoc = doc as IDisposable; // avoid unused var warnings
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            // do nothing

            long elapsed = timeElapsed.TimeElapsed;
            ProcessorCounters.Counters[_name].ProcessedPerSecond.Increment();
            ProcessorCounters.Counters[_name].AverageProcessingTime.IncrementBy(elapsed);
            ProcessorCounters.Counters[_name].AverageProcessingTimeBase.Increment();

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentProcessorFactory.cs ===
// 
// DocumentProcessorFactory.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{

    public class DocumentProcessorFactory
    {
        public static IWatcherDocumentProcessor CreateProcessor(string resourceName, string destinationName)
        {
            IWatcherDocumentProcessor processor = null;

            switch (resourceName)
            {
                case "Media":
                    switch (destinationName)
                    {
                        case "ESP":
                            processor = new MediaDocumentProcessor(resourceName, destinationName);
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the ProcessorFactory " + destinationName);
                    }
                    break;
                case "Video":
                case "SpeechFull":
                case "Speech":
                case "ZuneApp":
                    switch (destinationName)
                    {
                        case "Azure":
                        case "ESP":
                            processor = new DocumentProcessorNoop(resourceName, destinationName);
                            break;                        
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the ProcessorFactory " + destinationName);
                    }
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_RESOURCE_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                        "Invalid resourceName passed to the ProcessorFactory " + resourceName);
            }
            return processor;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentProducerFactory.cs ===
// 
// Factory.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    public class DocumentProducerFactory
    {
        public static IWatcherDocumentProducer CreateProducer(string resourceName, string destinationName)
        {
            IWatcherDocumentProducer producer = null;

            switch (resourceName)
            {
                case "Media":
                    switch (destinationName)
                    {
                        case "ESP":
                            producer = new MediaDocumentProducer();
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the DetectorFactory " + destinationName);
                    }
                    break;
                case "Video":
                    switch (destinationName)
                    {
                        case "Azure":
                            producer = new VideoDocumentProducer();
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the DetectorFactory " + destinationName);
                    }
                    break;
                case "SpeechFull":
                case "Speech":
                    switch (destinationName)
                    {
                        case "Azure":
                            producer = new SpeechDocumentProducer(resourceName);
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the DetectorFactory " + destinationName);
                    }
                    break;
                case "ZuneApp":
                    switch (destinationName)
                    {
                        case "ESP":
                            producer = new ZuneAppDocumentProducer();
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the DetectorFactory " + destinationName);
                    }
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_RESOURCE_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                        "Invalid resourceName passed to the DetectorFactory " + resourceName);
            }
            return producer;
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentsQueue.cs ===
// 
// DocumentsQueue.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Diagnostics;

using xonline.common.sql.sqlclient;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{    

    /// <summary>
    /// Thread Safe Queue implementation for the documents
    /// 
    /// This class provides a thread safe, synchronized data structure to add and remove documents in a FIFO manner.
    /// 1 producer and 1 consumer (possibly on different threads) can add and remove documents resp. in a synchronized manner
    /// using this queue
    /// </summary>
    public class DocumentsQueue: IDisposable
    {
        private volatile Queue<IWatcherDocument> _queue = null;
        private int _maxLength = -1;
        private volatile bool _shutdown = false;
        private volatile AutoResetEvent _addToQueueEvent = null;
        private volatile AutoResetEvent _removeFromQEvent = null;

        /// <summary>
        /// Constructor for the queue
        /// </summary>
        /// <param name="maxLength">Max length of the queue</param>
        public DocumentsQueue(int maxLength)
        {
            if (maxLength < 1)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ZERO_QUEUE_SIZE, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION, "Queue size cannot be initialized to zero.");
            }
            _maxLength = maxLength;
            _queue = new Queue<IWatcherDocument>(_maxLength);
            _addToQueueEvent = new AutoResetEvent(false);
            _removeFromQEvent = new AutoResetEvent(false);
        }

        /// <summary>
        /// Max Length of the queue
        /// </summary>
        public int MaxLength
        {
            get { return _maxLength; }
        }

        /// <summary>
        /// The count of documents in the queue
        /// </summary>
        public int Count
        {
            get { return _queue.Count; }
        }

        /// <summary>
        /// Is the queue full?
        /// </summary>
        private bool IsFull()
        {
            lock (_queue)
            {
                Debug.Assert(_queue.Count <= _maxLength);
                return (_queue.Count >= _maxLength);
            }
        }


        /// <summary>
        /// Is the queue empty?
        /// </summary>
        private bool IsEmpty()
        {
            lock (_queue)
            {
                Debug.Assert(_queue.Count <= _maxLength);
                return (_queue.Count == 0);
            }
        }


        /// <summary>
        /// Adds a document to the queue. 
        /// If the queue is full, this call blocks till someone removes a document from the queue
        /// Once Shutdown has been called, this method will get unblocked (if blocked) and return false
        /// </summary>
        /// <param name="doc">The document to add</param>
        /// <returns>Returns true if document is added; false if the document is not added</returns>
        /// <exception>It also throws an exception if the document passed in is null. </exception>
        public bool Enqueue(IWatcherDocument doc)
        {
            bool bAddedToQueue = false;            
            if (IsFull() && !_shutdown)
            {
                _removeFromQEvent.WaitOne();
            }
            if (!_shutdown)
            {
                if (doc == null)
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_NULL_DOCUMENT_IN_QUEUE, XEvent.Id.CATALOG_WATCHER_PRODUCER_EXCEPTION, "Null IWatcherDocument passed to Enqueue");
                }
                lock (_queue)
                {
                    _queue.Enqueue(doc);
                    _addToQueueEvent.Set();
                    // Clear the pending 'remove' events
                    _removeFromQEvent.Reset();
                }                
                bAddedToQueue = true;
            }
            return bAddedToQueue;
        }

        /// <summary>
        /// If the queue is not empty, removes a document from the queue and returns that document
        /// If the queue is empty and Shutdown has not been called, this call blocks till a document is added to the queue
        /// If shutdown is called, this call will get unblocked (if blocked). Then it will keep removing the documents from 
        /// the queue till the queue is empty. When the queue finally becomes empty it will return null.
        /// </summary>
        /// <returns>The dequeued document (or null if nothing is left in the queue and Shutdown has been called) </returns>
        public IWatcherDocument Dequeue()
        {
            IWatcherDocument doc = null;
            if (IsEmpty() && !_shutdown)
            {
                _addToQueueEvent.WaitOne();
            }
            if (!IsEmpty())
            {
                lock (_queue)
                {
                    doc = _queue.Dequeue();
                    if (doc == null)
                    {
                        throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_NULL_DOCUMENT_IN_QUEUE, XEvent.Id.CATALOG_WATCHER_PRODUCER_EXCEPTION, "Dequeue is returning a null document. This should never happen.");
                    }
                    _removeFromQEvent.Set();
                    // Clear out any pending 'add' events
                    _addToQueueEvent.Reset();
                }                
            }
            if (doc == null)
            {
                if (!IsEmpty())
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_NULL_DOCUMENT_IN_QUEUE, XEvent.Id.CATALOG_WATCHER_PRODUCER_EXCEPTION, "Dequeue is returning a null document when queue is not empty. This should never happen.");
                }
            }
            return doc;
        }

        /// <summary>
        /// This shuts down the queue.
        /// See the Enqueue() and Dequeue() to see the effect of Shutdown on these operations
        /// </summary>
        public void Shutdown()
        {
            _shutdown = true;
            _addToQueueEvent.Set();
            _removeFromQEvent.Set();            
        }

        /// <summary>
        /// Cleans up the queue resources
        /// </summary>
        public void Dispose()
        {
            if (_addToQueueEvent != null)
            {
                _addToQueueEvent.Close();
                _addToQueueEvent = null;
            }
            if (_removeFromQEvent != null)
            {
                _removeFromQEvent.Close();
                _removeFromQEvent = null;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentStatus.cs ===
using System;
using System.Data;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;
using System.Configuration.Install;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.installer;

//[assembly: XomIisInstallerAttribute(Interface.cron_int)]

namespace xonline.server.catalogwatcher
{
    public class DocumentStatus
    {
        private ILSNDocument _lastLSNGroupedDocument = null;
        private ILSNDocument _lastUpdatedLSNGroupedDocument = null;
        private ILSNDocument _prevLSNDocument = null;

        private int _bucketId;
        private string _destinationName;
        private string _resourceName;
        private string _instanceName;

        /// <summary>
        /// Constructs class which updates the status of the document processing in the watcher status table
        /// </summary>
        /// <param name="bucketId">Bucket which corresponds to these updates</param>
        /// <param name="destinationName">Destination which is being updated</param>
        /// <param name="resourceName">Resource which is being updated</param>
        public DocumentStatus(int bucketId, string destinationName, string resourceName)
        {
            if (bucketId < 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_NEGATIVE_BUCKET, XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION,
                "Bucket identifier is negative");
            }
            
            if (destinationName == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION,
                "destination name is null");
            }

            if (resourceName == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_RESOURCE_NAME, XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION,
                "resource name is null");
            }

            _bucketId = bucketId;
            _destinationName = destinationName;
            _resourceName = resourceName;
            _instanceName = String.Format("CatalogWatcher|Publisher|{0}|{1}|{2:D3}", resourceName, destinationName, bucketId);
        }

        /// <summary>
        /// Adds document which will be marked completed
        /// </summary>
        /// <param name="doc">Document which will be marked as complete</param>
        public void AddDocument(IWatcherDocument document)
        {
            ILSNDocument curLSNDocument = document as ILSNDocument;
            if (curLSNDocument == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_NULL_DOCUMENT, XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION,
                "document being added to status is null");              
            }            
            if (curLSNDocument.LSN == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_UPDATE_LSN_FAILED, XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION,
                    "LSN value is null");
            }

            if (_prevLSNDocument != null && curLSNDocument.LSN.CompareTo(_prevLSNDocument.LSN) < 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_INCORRECT_LSN_ORDER, 
                    XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION,
                    String.Format("LSNs are not in the correct order, they should always be increasing in value. Previous LSN: [{0}] New LSN: [{1}]", _prevLSNDocument.LSN, curLSNDocument.LSN));
            }

            if (_prevLSNDocument != null && !_prevLSNDocument.LSN.Equals(curLSNDocument.LSN))
            {
                // This is a document from a different LSN
                _lastLSNGroupedDocument = _prevLSNDocument;
            }
            _prevLSNDocument = curLSNDocument;
        }

        /// <summary>
        /// Commit all known groups of the documents added to the status table
        /// </summary>
        public void Commit()
        {
            if (_lastUpdatedLSNGroupedDocument != _lastLSNGroupedDocument)
            {
                // Update LSN
                UpdateLsn(_lastLSNGroupedDocument.LSN);
                _lastUpdatedLSNGroupedDocument = _lastLSNGroupedDocument;
            }
        }

        /// <summary>
        /// Commits all groups of documents added to the status table, regardless of grouping
        /// </summary>
        public void CommitAllProcessedDocuments()
        {
            if (_prevLSNDocument != null)
            {
                // Force the last LSN to become committed
                UpdateLsn(_prevLSNDocument.LSN);
            }
        }

        /// <summary>
        /// Updates the LSN in the status table in the database
        /// </summary>
        /// <param name="lsn">LSN to update the status to</param>
        private void UpdateLsn(LSN lsn)
        {
            using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
            {
                sqlClient.StoredProc = "dbo.p_catalog_watcher_update_status";
                sqlClient.AddParameter("@i_bucket_id", _bucketId);
                sqlClient.AddParameter("@vc_destination_name", _destinationName);
                sqlClient.AddParameter("@vc_resource_name", _resourceName);
                sqlClient.AddParameter("@b_lsn_value", lsn.Lsn);
                sqlClient.AddParameter("@b_seq_value", lsn.Seq);
                sqlClient.AddParameter(ParameterDirection.ReturnValue, "@returnValue", 0);

                sqlClient.Execute();

                // Check if update was success
                int returnValue = (int)sqlClient.Command.Parameters["@returnValue"].Value;

                if (returnValue != 1)
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_UPDATE_LSN_FAILED, XEvent.Id.CATALOG_WATCHER_PUBLISHER_EXCEPTION,
                        "Could not update CatalogWatcherStatus, sql returned failure: " + returnValue);
                }
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Updated to LSN {1}", _instanceName, lsn));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\DocumentPublisherFactory.cs ===
// 
// Factory.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    public class DocumentPublisherFactory
    {
        public static IWatcherDocumentPublisher CreatePublisher(string resourceName, string destinationName)
        {
            IWatcherDocumentPublisher publisher = null;

            switch (resourceName)
            {
                case "Media":
                    switch (destinationName)
                    {
                        case "ESP":
                            publisher = new PublisherEsp();
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the PublisherFactory " + destinationName);
                    }
                    break;
                case "Video":
                case "SpeechFull":
                case "Speech":
                    switch (destinationName)
                    {
                        case "Azure":
                            publisher = new PublisherAzureStorage(resourceName);
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the PublisherFactory " + destinationName);
                    }
                    break;
                case "ZuneApp":
                    switch (destinationName)
                    {
                        case "ESP":
                            publisher = new ZuneAppPublisherEsp();
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                                "Invalid destination passed to the PublisherFactory " + destinationName);
                    }
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_INVALID_RESOURCE_NAME, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION,
                        "Invalid resourceName passed to the PublisherFactory " + resourceName);
            }
            return publisher;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\ExtractorCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.installer;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.catalogwatcher
{
    [XomPerformanceCounterCategoryAttr("Catalog Watcher: Extractor Perf Counters", "Counters for the Extractor")]
    public class ExtractorCounters : XomPerformanceCounterCategory
    {

        public static ExtractorCounters Counters = new ExtractorCounters();

        public ExtractorCounters this[string instanceName]
        {
            get
            {
                return (ExtractorCounters)GetInstance(instanceName);
            }
        }


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Extractor API requests/sec",
            "Catalog Watcher: Extractor requests per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsPerSecond;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Extractor API requests total",
            "Total Extractor requests made in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsTotal;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Extractor failures/sec",
            "Number of unsuccessful results returned per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsFailedPerSecond;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Extractor API total failures",
            "Total number unsuccessful results returned in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsFailedTotal;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. execution time",
            "Average time taken by the Extractor",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. execution time base",
            "Base for the average request execution time in the current AppDomain.",
        PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Average batch size (all time)",
            "The average batch size over all prior runs.",
        PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageBatchSize;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Average batch size (all time) base",
            "Base counter for average batch size over all time.",
        PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageBatchSizeBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\IDocumentBuilder.cs ===
using System;
using System.Data.SqlClient;
using System.IO;
using System.Collections.Generic;

using xonline.common.sql.sqlclient;


namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// Represents a document builder.
    /// </summary>
    public interface IDocumentBuilder : IDisposable
    {
        IWatcherDocument BuildDocument(SqlClient sqlClient, MediaIdLcid mediaIdLcid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\IWatcherDocumentProcessor.cs ===
// 
// IWatcherDocumentProcessor.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Diagnostics;

using xonline.common.sql.sqlclient;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// A component to generate batches of documents
    /// </summary>
    public interface IWatcherDocumentProcessor : IDisposable
    {
        /// <summary>
        /// Invoked to initialize the processor state.
        /// This will be called before any calls to ProcessDocument
        /// </summary>
        /// <param name="bucketId">
        /// Several instances of the document processor may exist. This value indicates the bucket id
        /// </param>
        /// <param name="numBuckets">
        /// Several instances of the document processor may exist. This value indicates the total number of instances
        /// </param>
        void Init(int bucketId, int numBuckets);

        /// <summary>
        /// Processes a document
        /// </summary>
        void ProcessDocument(IWatcherDocument doc);

        /// <summary>
        /// Returns the name of the processor instance
        /// </summary>
        String InstanceName { get; }

        /// <summary>
        /// Returns the error information
        /// </summary>
        WorkerReport Report { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\IWatcherDocumentProducer.cs ===
// 
// IWatcherDocumentProducer.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Diagnostics;

using xonline.common.sql.sqlclient;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// A component to generate batches of documents
    /// </summary>
    public interface IWatcherDocumentProducer : IDisposable
    {
        /// <summary>
        /// Invoked to initialize the generator state.
        /// This will be called before any calls to GetNextBatchOfDocuments
        /// </summary>
        /// <param name="instanceBucketId">
        /// Several instances of the document generator may exist. This value indicates which instance this is
        /// </param>
        /// <param name="totalNumberOfBuckets">
        /// Several instances of the document generator may exist. This value indicates the total number of instances
        /// </param>
        void Init(int instanceBucketId, int totalNumberOfBuckets);

        /// <summary>
        /// Generates at most maxNumberOfDocuments documents
        /// <Returns>A collection containing the generated documents in monotonically increasing LSN order. Returns an empty collection if its done.</Returns>
        IEnumerable<IWatcherDocument> GetNextBatchOfDocuments(int maxNumberOfDocuments);

        /// <summary>
        /// The max batch size of documents to pass to the GetNextBatchOfDocuments(count)       
        /// </summary>
        int GetMaxBatchSize();

        /// <summary>
        /// The max number of documents the queue can hold
        /// </summary>
        int GetMaxQueueLength();

        /// <summary>
        /// Returns the name of the producer instance
        /// </summary>
        String InstanceName { get; }

        /// <summary>
        /// Returns the error information
        /// </summary>
        WorkerReport Report { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\IWatcherDocumentPublisher.cs ===
// 
// IWatcherDocumentPublisher.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Diagnostics;

using xonline.common.sql.sqlclient;
using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// A component to generate batches of documents
    /// </summary>
    public interface IWatcherDocumentPublisher : IDisposable
    {
        /// <summary>
        /// Invoked to initialize the generator state.
        /// This will be called before any calls to PublishDocuments
        /// </summary>
        /// <param name="instanceBucketId">
        /// Several instances of the document generator may exist. This value indicates which instance this is
        /// </param>
        /// <param name="totalNumberOfBuckets">
        /// Several instances of the document generator may exist. This value indicates the total number of instances
        /// </param>
        void Init(int instanceBucketId, int totalNumberOfBuckets);

        /// <summary>
        /// The max documents per batch to pass to Publisher       
        /// </summary>
        int GetMaxDocumentsPerBatch();

        /// <summary>
        /// Publisher determines if Status is Tracked/Recorded only at end of Publishing       
        /// </summary>
        bool CommitStatusPerBatch();

        /// <summary>
        /// Publisher determines if Status is Tracked/Recorded if an Error occurred       
        /// </summary>
        bool CommitStatusOnError();

        /// <summary>
        /// Writes all Documents to the Publisher Destination
        /// </summary>
        void FlushDocuments();

        /// <summary>
        /// Close / Finish any pending actions to the Publisher Destination
        /// </summary>
        void Close();

        /// <summary>
        /// Publish one document to the Publisher Destination, or allow Publisher to cache docs for later call(s) to FlushDocuments
        /// </summary>
        void PublishDocument(IWatcherDocument doc);

        /// <summary>
        /// Returns the name of the publisher instance
        /// </summary>
        String InstanceName { get; }

        /// <summary>
        /// Returns the error information
        /// </summary>
        WorkerReport Report { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\ProcessorCounters.cs ===
namespace xonline.server.catalogwatcher
{
    using System.Diagnostics;
    using xonline.common.mgmt;

    [XomPerformanceCounterCategoryAttr("Catalog Watcher: Processor Perf Counters", "Counters for the Document Processor")]
    public class ProcessorCounters : XomPerformanceCounterCategory
    {
        public static ProcessorCounters Counters = new ProcessorCounters();

        public ProcessorCounters this[string instanceName]
        {
            get
            {
                return (ProcessorCounters)GetInstance(instanceName);
            }
        }

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Documents processed/sec",
            "Catalog Watcher: Documents processed per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ProcessedPerSecond;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. wait time",
            "Average wait time for the document to be processed",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageProcessingTime;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. wait time base",
            "Base for average wait time for the document to be processed",
            PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageProcessingTimeBase;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\LSN.cs ===
// 
// LSN.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Diagnostics;

using xonline.common.service;

namespace xonline.server.catalogwatcher
{    

    /// <summary>
    /// Logical Sequence Number
    /// Every record in the SQL Server transaction log is uniquely identified by a log sequence number (LSN). 
    /// LSNs are ordered such that if LSN2 is greater than LSN1, the change described by the log record referred to by LSN2 occurred after the change described by the log record LSN. 
    /// The LSN of a log record at which a significant event occurred can be useful for constructing correct restore sequences. Because LSNs are ordered, they can be compared for equality and inequality (that is, <, >, =, <=, >=). 
    /// For more details go to: http://msdn.microsoft.com/en-us/library/ms190411.aspx
    /// 
    /// </summary>
    public class LSN: IComparable
    {
        public byte[] Lsn { get; protected set;}
        public byte[] Seq { get; protected set;}
        public LSN(byte[] l, byte[] s)
        {
            Lsn = l;
            Seq = s;
        }

        // This is for test code only
        public LSN(string l)
        {
            Lsn = new byte[10] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            Seq = new byte[10] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            byte[] arr = BitConverter.GetBytes(Int64.Parse(l));
            int i = 0;
            for (; i < arr.Length && i < 10; i++)
            {
                Lsn[i] = arr[i];
            }
            for (; i < arr.Length && i < 20; i++)
            {
                Seq[i - 10] = arr[i];
            }
        }

        public override bool Equals(object o)
        {
            LSN l = o as LSN;
            if (l == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_NULL_LSN, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION, "The object passed in is not a valid LSN object");
            }
            return (Lsn.Equals(l.Lsn) && Seq.Equals(l.Seq));
        }

        public int CompareTo(object o)
        {   
            int retVal = 0;       
            LSN lsn = o as LSN;
            if (lsn == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_NULL_LSN, XEvent.Id.CATALOG_WATCHER_WATCHER_EXCEPTION, "The object passed in is not a valid LSN object");
            }
            for (int i = 0; i < Lsn.Length; i++)
            {
                if (Lsn[i] == lsn.Lsn[i])
                {
                    continue;
                }
                else
                {
                    retVal = (Lsn[i] - lsn.Lsn[i]);
                    break;
                }
            }
            if (retVal == 0)
            {
                for (int i = 0; i < Seq.Length; i++)
                {
                    if (Seq[i] == lsn.Seq[i])
                    {
                        continue;
                    }
                    else
                    {
                        retVal = (Seq[i] - lsn.Seq[i]);
                        break;
                    }
                }
            }
            return retVal;
        }

        public override string ToString()
        {
            return BitConverter.ToString(Lsn).Replace("-", "") + BitConverter.ToString(Seq).Replace("-", "");
        }

        public override int GetHashCode()
        {
            return Lsn.GetHashCode() + Seq.GetHashCode();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\PublisherAzureStorage.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Text;
using System.Xml;
using System.Xml.Schema;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.installer;

using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// This class is used to publish documents to Azure Storage.
    /// 
    /// The intended mode of operation is:
    ///     - construct and initialize an instance of this class
    ///     - repeat as necessary
    ///         - publish document by calling PublishDocument() repeatedly
    ///         - 'commit' the documents to Azure Storage by calling FlushDocuments()
    ///     - dispose
    /// 
    /// </summary>
    public class PublisherAzureStorage : IWatcherDocumentPublisher
    {
        private readonly string c_resourceName;
        private static readonly string c_destinationName = "Azure";

        private int _bucketId = -1;                         // this instances bucket id
        private int _numBuckets = -1;                       // total number of buckets

        private readonly string _blobContainer; // i.e. "movies-firstparty"; 
        private readonly string _blobFormatFull; // i.e. "CA1.ZuneVideo.{0}.full.Lakeview_v0_4.gz"; 
        private readonly string _blobFormatDelta; // i.e. "CA1.ZuneVideo.{0}.delta.Lakeview_v0_4.gz"; 
        private readonly string _blobFormatDatePart; // i.e. "yyyy-MM-dd.HH-mm-ss"; 
        //private readonly string _azureConnectionString = "DefaultEndpointsProtocol=https;AccountName=devemdstorage;AccountKey=QBkMqzLXREOMTKaRbtMVGXjpyXZCKACKX5SYy1vTJKfSyXW4RsHULOZsOu6PnmHoVeyFB13ltIizv+adzAUGwA=="; 
        private readonly string _azureConnectionString; // i.e. "UseDevelopmentStorage=true"; 
        private readonly string _azureFeedPrefix; // i.e. "<feed xmlns=\"http://www.w3.org/2005/Atom\" providerName=\"IEB\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\">";
        private readonly string _azureFeedSuffix; // i.e. "</feed>";
        private readonly int _azureMaxDocsPerBatch; // i.e. 1000;


        // protected and not private for unit testing
        protected Dictionary<String, IWatcherDocument> _pendingDocuments = null;

        private string _name = string.Empty;

        private DateTime _now;

        private bool _checkedIfFullOrDelta = false;
        private bool _isFullFeed = false;
        private bool _closedCleanly = false;

        private TextWriter _sw = null;
        private CloudBlob _blob = null;
 
        /// <summary>
        /// Returns the name of this publisher instance
        /// </summary>
        public String InstanceName
        {
            get { return _name; }
        }

        private WorkerReport _report = null;

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }

        public PublisherAzureStorage(string resourceName)
        {
            c_resourceName = resourceName;
            _now = DateTime.UtcNow;

            // Shared Config
            _blobFormatDatePart = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_date_part);

            // Resource Specific Config
            switch(resourceName)
            {
                case "SpeechFull":
                case "Speech":
                    _blobContainer = Config.GetSetting(Setting.catalogwatcher_azure_storage_container_speech);
                    _blobFormatFull = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_full_speech);
                    _blobFormatDelta = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_delta_speech);
                    _azureConnectionString = Config.GetSetting(Setting.catalogwatcher_azure_connection_string_speech);
                    _azureFeedPrefix = Config.GetSetting(Setting.catalogwatcher_azure_feed_prefix_speech);
                    _azureFeedSuffix = Config.GetSetting(Setting.catalogwatcher_azure_feed_suffix_speech);
                    _azureMaxDocsPerBatch = Config.GetIntSetting(Setting.catalogwatcher_azure_storage_max_documents_per_batch_speech);
                    break;
                case "Video":
                    _blobContainer = Config.GetSetting(Setting.catalogwatcher_azure_storage_container);
                    _blobFormatFull = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_full);
                    _blobFormatDelta = Config.GetSetting(Setting.catalogwatcher_azure_storage_blob_format_delta);
                    _azureConnectionString = Config.GetSetting(Setting.catalogwatcher_azure_connection_string);
                    _azureFeedPrefix = Config.GetSetting(Setting.catalogwatcher_azure_feed_prefix);
                    _azureFeedSuffix = Config.GetSetting(Setting.catalogwatcher_azure_feed_suffix);
                    _azureMaxDocsPerBatch = Config.GetIntSetting(Setting.catalogwatcher_azure_storage_max_documents_per_batch);
                    break;
                // Note: Factory handles default case    
            }
        }
        
        /// <summary>
        /// Uses the content distributor and collection name to initialize the Publisher
        /// </summary>
        public void Init(int bucketId, int numBuckets)
        {
            _name = String.Format("CatalogWatcher|Publisher|{0}|{1}|{2:D3}", c_resourceName, c_destinationName, bucketId); 
            _bucketId = bucketId;
            _numBuckets = numBuckets;

            if(_numBuckets > 1)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, "Error Initializing AzureStorage Publisher: only one " + c_resourceName + " Publisher is allowed.");
            }
                
            // Retrieve any additional information from NPDB, required to talk to AzureStorage
            
            // Store for holding documents that are being sent to AzureStorage, so that multiple Video docs can be send as one Feed-Doc. 
            _pendingDocuments = new Dictionary<string, IWatcherDocument>();

            // Set the WebProxy, if needed            
            string proxy = Config.GetSetting(Setting.billing_proxy);
            if (!string.IsNullOrEmpty(proxy))
            {
                WebRequest.DefaultWebProxy = new WebProxy(proxy, true);
            }
        }

        /// <summary>
        /// Gets the Azure Blob Name to publish
        /// </summary>
        private void CheckIfFullOrDelta(IWatcherDocument doc) 
        {
            // Resource Specific check
            switch(c_resourceName)
            {
                case "SpeechFull":
                    _isFullFeed = true; 
                    break;
                case "Speech":
                    _isFullFeed = false; 
                    break;
                case "Video":
                    {
                        // VideoDocument Feed-Type passed in the LSN.Seq number -- a design work-around -- 0=Full, 1=Delta
                        // All Video docs for Azure being processed contain a homogeneous Seq# value, by convention
                        ILSNDocument curLSNDocument = doc as ILSNDocument;
                        
                        if (curLSNDocument == null)
                        {
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PUBLISHER_NULL_DOCUMENT, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION,
                            "document being published to Azure is null");              
                        }            
                        if (curLSNDocument.LSN == null)
                        {
                            throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_NULL_LSN, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION,
                                "LSN value is null for document being published to Azure");
                        }
                        
                        byte[] seq = curLSNDocument.LSN.Seq;
                        
                        // VideoDocument Feed-Type passed in the LSN.Seq number -- a design work-around -- 0=Full, 1=Delta
                        if(seq != null && seq.Length == 10 && seq[9] == 0)
                        {
                            _isFullFeed = true;
                        }
                    }
                    break;
            }
        }
        
        /// <summary>
        /// Gets the Azure Blob Name Format String to publish
        /// </summary>
        private string GetBlobNameFormatString() 
        {
            string blobNameFormatString;
            if(_isFullFeed)
            {
                blobNameFormatString = (_blobFormatFull);
            }
            else
            {
                blobNameFormatString = (_blobFormatDelta);
            }

            return blobNameFormatString;
        }
        
        /// <summary>
        /// Gets the Azure Blob Name to publish
        /// </summary>
        private string GetBlobName() 
        {
            string blobName = String.Empty;

            string blobFormatString = GetBlobNameFormatString();

            blobName = String.Format(CultureInfo.InvariantCulture, blobFormatString, _now.ToString(_blobFormatDatePart));

            return blobName;
        }
        
        /// <summary>
        /// Flushes all of the documents currently in the AzureStorage queue. The number of documents processed since the documents were last flushed are logged.
        /// </summary>
        public void FlushDocuments() 
        {
            Xom.Trace( XomAreaName.catalogwatcherlog, LogLevel.L_INFO, String.Format("{0}|Flushing {1} documents.", _name, _pendingDocuments.Count));
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            if(_pendingDocuments.Count > 0)
            {
                if(_sw == null)
                {
                    _sw = GetTextWriter(GetBlobName());
                    _sw.Write(_azureFeedPrefix);
                }

                foreach (KeyValuePair<String, IWatcherDocument> kvp in _pendingDocuments)
                {
                    _sw.Write(kvp.Value.Document.ToString());
                }
            }

            Xom.Trace(XomAreaName.catalogwatcherlog, LogLevel.L_INFO, String.Format("{0}|Flushing documents completed after {1} seconds.", _name, timeElapsed.SecondsElapsed));

            // Reset:
            // - clear the list of pending documents
            _pendingDocuments.Clear();

            FlushDocumentsCounters(timeElapsed);
        }

        /// <summary>
        /// Calls the needed performance counters for when a flush documents event happens
        /// It has been broken out in this way and made protected so that one
        /// can easily subclass it and override for unit testing
        /// </summary>
        protected virtual void FlushDocumentsCounters(XomRequestTimeElapsed timeElapsed)
        {
            PublisherCounters.Counters[_name].AverageFlushDocumentsTime.IncrementBy(timeElapsed.TimeElapsed);
            PublisherCounters.Counters[_name].AverageFlushDocumentsTimeBase.Increment();
        }

        /// <summary>
        /// This method returns a new stream writer to write the document to
        /// It has been broken out in this way and made protected so that one
        /// can easily subclass it and override for unit testing
        /// The call is responsible for closing the TextWriter
        /// </summary>
        /// <param name="fileName">file name</param>
        /// <returns></returns>
        protected virtual TextWriter GetTextWriter(string fileName)
        {
            CloudStorageAccount account = CloudStorageAccount.Parse(_azureConnectionString);
            CloudBlobClient client = account.CreateCloudBlobClient();

            CloudBlobContainer container = client.GetContainerReference(_blobContainer);
            container.CreateIfNotExist();

            _blob = container.GetBlobReference(fileName);

            BlobStream blobStream = _blob.OpenWrite();
            GZipStream gz = new GZipStream(blobStream, CompressionMode.Compress);

            return new StreamWriter(gz);
        }

        /// <summary>
        /// Creates a document and publishes it to AzureStorage
        /// </summary>        
        /// <param name="doc">Contains the identifier and document data information.
        /// This identifier must be repeatable if the document needs to be overwritten at a future point in time with new information.
        /// The document data object must be converted into a string object for processing
        /// </param>
        public void PublishDocument(IWatcherDocument doc)
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            if (doc == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, "Document is null");
            }
            else if (doc.Document == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, "Document data is null");
            }
            else if(doc.DocumentId == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, "Document identifier is null");
            }

            if (doc.Document.ToString() == string.Empty)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, "Error submitting documents to AzureStorage: document being submitted is an empty string");
            }

            
            if (!_checkedIfFullOrDelta)
            {
                CheckIfFullOrDelta(doc);
                _checkedIfFullOrDelta = true;
            }
            
            // Currently, we are only publishing expected Document type, so verify that we can cast up (if needed) an do so. Otherwise
            // it must be an error

            // Resource Specific check
            switch(c_resourceName)
            {
                case "SpeechFull":
                case "Speech":
                    if( doc.GetType() != typeof(SpeechDocument))
                    {
                        throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, "Error submitting documents to AzureStorage: document being submitted is not an instance of type 'SpeechDocument'");
                    }
                    break;
                case "Video":
                    if( doc.GetType() != typeof(VideoDocument))
                    {
                        throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_AZURESTORAGE_PUBLISHER_ERROR, XEvent.Id.CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, "Error submitting documents to AzureStorage: document being submitted is not an instance of type 'VideoDocument'");
                    }
                    break;
            }

            PublishDocumentCounters(timeElapsed);

            // Add the document to the list of pending documents
            _pendingDocuments[doc.DocumentId] = doc;
        }

        /// <summary>
        /// This method simply calls the counters needed when a publish happens
        /// It has been broken out in this way and made protected so that one
        /// can easily subclass it and override for unit testing
        /// </summary>
        /// <param name="timeElapsed"></param>
        protected virtual void PublishDocumentCounters(XomRequestTimeElapsed timeElapsed)
        {
            PublisherCounters.Counters[_name].AveragePublishTime.IncrementBy(timeElapsed.TimeElapsed);
            PublisherCounters.Counters[_name].AveragePublishTimeBase.Increment();
            PublisherCounters.Counters[_name].NumberOfDocumentPerSecond.Increment();
            PublisherCounters.Counters[_name].NumberOfDocumentsPublished.Increment();
        }

        /// <summary>
        /// Cleans and disposes of member variables
        /// </summary>
        public void Dispose()
        {
            // Clean up any Azure objects, if needed
            if(_sw != null)
            {
                _sw.Dispose();
            }

            // Remove Blob if we didn't close cleanly
            if(_blob != null && !_closedCleanly)
            {
                _blob.DeleteIfExists();
            }
        }

        /// <summary>
        /// Get the Maximum Batch Size for the Publisher
        /// </summary>
        public int GetMaxDocumentsPerBatch()
        {
            return _azureMaxDocsPerBatch;
        }

        /// <summary>
        /// Get the Publisher setting for tracking status
        /// </summary>
        public bool CommitStatusPerBatch()
        {
            return false;
        }
       
       /// <summary>
       /// Get the Publisher setting for tracking status on error
       /// </summary>
       public bool CommitStatusOnError()
       {
           return false;
       }

       /// <summary>
       /// Close / Finish any pending actions to the Publisher Destination
       /// </summary>
       public void Close()
       {
           if(_sw != null)
           {
               _sw.Write(_azureFeedSuffix);
               _sw.Close();
               _closedCleanly = true;
           }
       }
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\PublisherEsp.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.installer;

using Com.FastSearch.Esp.Content;
using Com.FastSearch.Esp.Content.Errors;
using Com.FastSearch.Esp.Content.Util;
using Com.FastSearch.Esp.Content.Config;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// This class is used to publish documents to ESP.
    /// 
    /// The intended mode of operation is:
    ///     - construct and initialize an instance of this class
    ///     - repeat as necessary
    ///         - publish document by calling PublishDocument() repeatedly
    ///         - 'commit' the documents to ESP by calling FlushDocuments()
    ///     - dispose
    /// 
    /// Errors in documents are only checked for when the flush happens. ESP will no return
    /// the actual documents that gave the error. For this reason, we keep a dictionary called
    /// _pendingDocuments with each uncomitted document, keyed off of the document id. If we receive
    /// errors on a flush, for each error the document id is returned, the actual document retrieved
    /// from the pending list and relevant printed out.
    /// </summary>
    public class PublisherEsp : IWatcherDocumentPublisher
    {
        private static readonly string c_resourceName = "Media";
        private static readonly string c_destinationName = "ESP";

        private string _contentDistributor = null;
        private string _collectionName = null;
        private Boolean _performAndLogValidationOnError;

        private IContentFactory _contentFactory = null;
        private IDocumentFeeder _documentFeeder = null;
        private Dictionary<String, IWatcherDocument> _pendingDocuments = null;

        private string _name = string.Empty;

        private bool _waitForIndexing = false;

        private static readonly char[] DocumentIdComponentSeparators = new char[] { '_' };

        /// <summary>
        /// Returns the name of this publisher instance
        /// </summary>
        public String InstanceName
        {
            get { return _name; }
        }

        private WorkerReport _report = null;

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }


        /// <summary>
        /// Initializes the publisher using test hooks
        /// </summary>
        public PublisherEsp(String testOverrideContentDistributor, String testOverrideCollectionName)
        {
            Init(testOverrideContentDistributor, testOverrideCollectionName);
            _name = "Test_PublisherEsp";
        }
      
        /// <summary>
        /// Initializes the publisher from NPDB settings
        /// </summary>
        /// <param name="name">Name of the running watcher instance</param>
        public PublisherEsp()
        {            
        }

        /// <summary>
        /// Uses the content distributor and collection name to initialize the Publisher
        /// </summary>
        public void Init(int bucketId, int numBuckets)
        {
            _name = String.Format("CatalogWatcher|Publisher|{0}|{1}|{2:D3}", c_resourceName, c_destinationName, bucketId); 
            
            // Retrieve virtual interface information, construct connection string
            string[] ingestionIps = Config.GetMultiSetting(MultiSetting.fastEspMarketplaceIngestionIps);
            string collectionName = Config.GetSetting(Setting.catalogwatcher_fast_esp_collection_name);
            string ingestionPort = Config.GetSetting(Setting.catalogwatcher_fast_esp_ingestion_port);

            StringBuilder espContentDistributor = new StringBuilder();
            string noFirstComma = string.Empty;

            // Format of the content distributor is a comma seperated list of host:port values
            //      host1:port,host2:port,host3:port
            foreach (string ip in ingestionIps)
            {
                espContentDistributor.AppendFormat("{0}{1}:{2}", noFirstComma, ip, ingestionPort);
                noFirstComma = ",";
            }
            Init(espContentDistributor.ToString(), collectionName);
        }

        public void Init(string espContentDistributor, string collectionName)
        {
            _contentDistributor = espContentDistributor;
            _collectionName = collectionName;            
            try
            {
                _contentFactory = Factory.CreateContentFactory();
                _documentFeeder = Factory.CreateDocumentFeeder(_contentDistributor, _collectionName);
            }
            catch (FactoryException fe)
            {
                string errorStr = String.Format("ESP Publisher ({0}): Error creating IDocumentFeeder using ContentDistributor [{1}] and CollectionName [{2}]", _name, _contentDistributor, _collectionName);
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, errorStr, fe);
            }

            // Check the configuration to see if we need to wait for indexing to complete when doing
            // a flush. If this is not set, the flush merely waits for document processing to complete.
            _waitForIndexing = Config.GetBoolSetting(Setting.catalogwatcher_fast_wait_for_indexing);
            ISubsystem indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                if (_waitForIndexing == true)
                {
                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Set to wait for indexing on flush.", _name));
                    indexing.CompletedCallbackEnabled = _waitForIndexing;
                }
            }
            else
            {
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Supposed to wait for indexing on flush, but indexing subsystem not found.", _name));
            }

            // Store for holding documents that are being sent to ESP. Required for when errors
            // occur and we need to determine what was invalid with the xml.
            _pendingDocuments = new Dictionary<string, IWatcherDocument>();

            // Get the flag that determines if, on ESP encountering an error processing the document, 
            // this code should validate the documents xml wellformed-ness and report the errors. (The
            // error returned from ESP is vague when this happens, so allowing it here is helpful)
            _performAndLogValidationOnError = Config.GetBoolSetting(Setting.catalogwatcher_perform_and_log_validation_on_error);
        }

        /// <summary>
        /// Flushes all of the documents currently in the FAST ESP queue and checks for document errors and warnings. The warnings
        /// and errors are logged. The number of documents processed since the documents were last flushed are logged.
        /// </summary>
        public void FlushDocuments() 
        {
            Xom.Trace( XomAreaName.catalogwatcherlog, LogLevel.L_INFO, String.Format("{0}|Flushing {1} documents with 'wait for indexing' set to {2}.", _name, _pendingDocuments.Count, _waitForIndexing));
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            _documentFeeder.WaitForCompletion();
            Xom.Trace(XomAreaName.catalogwatcherlog, LogLevel.L_INFO, String.Format("{0}|Flushing documents completed after {1} seconds.", _name, timeElapsed.SecondsElapsed));

            //get status for submitted document
            IDocumentFeederStatus status = _documentFeeder.GetStatusReport();

            // If there are errors with submuitting the documents, log a row for each error
            // We also create a generic message for the event, indicating the number of errors
            StringBuilder message = new StringBuilder( _name );
            if (status.HasDocumentErrors())
            {
                message.Append( String.Format("|{0} errors in {1} documents submitted to FAST ESP", status.NumDocumentErrors, _pendingDocuments.Count ));
                foreach (Pair p in status.AllDocumentErrors)
                {
                    Xom.Log(XomAreaName.catalogwatcherlog, GetDocumentError(p));
                    PublisherCounters.Counters[_name].NumberOfDocumentErrors.Increment();
                }
            }

            // If there are warnings with submuitting the documents, log a row for each warning
            // We also create add to the generic message for the event, indicating the number of warnings
            if (status.HasDocumentWarnings())
            {
                message.Append( String.Format("|{0} warnings in {1} documents submitted to FAST ESP", status.NumDocumentWarnings, _pendingDocuments.Count ));
                foreach (Pair p in status.DocumentWarnings )
                {
                    Xom.Log(XomAreaName.catalogwatcherlog, GetDocumentWarning(p));
                    PublisherCounters.Counters[_name].NumberOfDocumentWarnings.Increment();
                }
            }

            // Reset:
            // - clear the list of pending documents
            _pendingDocuments.Clear();

            PublisherCounters.Counters[_name].AverageFlushDocumentsTime.IncrementBy(timeElapsed.TimeElapsed);
            PublisherCounters.Counters[_name].AverageFlushDocumentsTimeBase.Increment();

            // If there was either an error or a warning, raise an event. Errors are more critical
            // than warnings, so we check that first and raise the error event. Otherwise we raise 
            // the warning event.
            if ( status.HasDocumentErrors())
            {
                message.Append("Check the app/cron/catalogwatcher log for more information.");
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                                        XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                                        message.ToString());
            }
            else if ( status.HasDocumentWarnings())
            {
                message.Append("Check the app/cron/catalogwatcher log for more information.");
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING,
                                        XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING,
                                        message.ToString());
            }
        }

        /// <summary>
        /// Checks if the document being processed is too large to fit in our flat fields
        /// </summary>
        /// <param name="mediaDocument"></param>
        /// <param name="document"></param>
        /// <returns></returns>
        private bool IsDocumentOversized(MediaDocument mediaDocument, string field, string document)
        {
            int maxDocumentSize = Config.GetIntSetting(Setting.catalogwatcher_fast_esp_max_document_size);

            int numberOfBytes = Encoding.UTF8.GetByteCount(document);
            if (numberOfBytes > maxDocumentSize)
            {
                string msg = String.Format("For MediaId [{0}] and LCID [{1}], the document generated was [{2}] bytes when the max bytes that can be pushed is [{3}]",
                                                      mediaDocument.MediaIdLcid.MediaId,
                                                      mediaDocument.MediaIdLcid.Lcid,
                                                      numberOfBytes,
                                                      maxDocumentSize
                                                      );
                XRLException e = new XRLException(
                                        HResult.XONLINE_E_CATALOGWATCHER_DOCUMENT_TOO_LARGE,
                                        XEvent.Id.CATALOG_WATCHER_MEDIA_DOCUMENT_TOO_LARGE,
                                        msg
                                       );


                // Write to the event log
                Xom.NtEvent(XEvent.Id.CATALOG_WATCHER_MEDIA_DOCUMENT_TOO_LARGE, e, msg);
                // Write to the log
                Xom.Log(XomAreaName.catalogwatcherlog, msg);

                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Creates a document and publishes it to the FAST ESP service
        /// </summary>        
        /// <param name="doc">Contains the identifier and document data information.
        /// This identifier must be repeatable if the document needs to be overwritten at a future point in time with new information.
        /// The document data object must be converted into a string object for processing
        /// </param>
        public void PublishDocument(IWatcherDocument doc)
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            if (doc == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Document is null");
            }
            else if (doc.Document == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Document data is null");
            }
            else if(doc.DocumentId == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Document identifier is null");
            }

            if (doc.Document.ToString() == string.Empty)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Error submitting documents to FAST ESP: document being submitted is an empty string");
            }

            // Currently, we are only publishing MediaDocument, so verify that we can cast up an do so. Otherwise
            // it must be an error
            if( doc.GetType() != typeof(MediaDocument))
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, XEvent.Id.CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Error submitting documents to FAST ESP: document being submitted is not an instance of type 'MediaDocument'");
            }

            MediaDocument mediaDocument = (MediaDocument)doc;

            ArrayList documentFields = new ArrayList();           

            // This glob of data is the XML document
            if (  mediaDocument.Document != null )
            {
                documentFields.Add(new StringElement("data", mediaDocument.Document.ToString()));
            }
            
            IDictionaryEnumerator enumerator = mediaDocument.FlatFieldsXml.GetEnumerator();
            while (enumerator.MoveNext())
            {
                String valueString = (String)enumerator.Value;
                if (!String.IsNullOrEmpty(valueString))
                {
                    String keyString = (String)enumerator.Key;
                    if (IsDocumentOversized(mediaDocument, keyString, valueString))
                    {
                        return;
                    }
                    else
                    {
                        documentFields.Add(new StringElement(keyString, valueString));
                    }
                }
            }

            enumerator = mediaDocument.FlatFieldsString.GetEnumerator();
            while (enumerator.MoveNext())
            {
                String str = (String)enumerator.Value;
                if (!String.IsNullOrEmpty(str))
                {
                    documentFields.Add(new StringElement((String)enumerator.Key, str));
                }
            }

            enumerator = mediaDocument.FlatFieldsSingle.GetEnumerator();
            while (enumerator.MoveNext())
            {
                documentFields.Add(new FloatElement((String)enumerator.Key, (float)enumerator.Value));
            }

            enumerator = mediaDocument.FlatFieldsDateTime.GetEnumerator();
            while (enumerator.MoveNext())
            {
                documentFields.Add(new StringElement((String)enumerator.Key, ((DateTime)enumerator.Value).ToString("s")));
            }

            enumerator = mediaDocument.FlatFieldsInt32.GetEnumerator();
            while (enumerator.MoveNext())
            {
                String key = (String)enumerator.Key;
                Int32 value = (Int32)enumerator.Value;

                // Special case we should probably resolve at some point..
                // This is to not add unkown Avatar Body Types to the flat field
                if (key.ToLower() == "avatarbodytype") 
                {
                    if (value != 0)
                    {
                        documentFields.Add(new IntegerElement(key, value));
                    }
                }
                else
                {
                    documentFields.Add(new IntegerElement(key, value));
                }
            }        

            Document document = _contentFactory.CreateDocument(doc.DocumentId, documentFields );

            _documentFeeder.AddDocument(document);

            PublisherCounters.Counters[_name].AveragePublishTime.IncrementBy(timeElapsed.TimeElapsed);
            PublisherCounters.Counters[_name].AveragePublishTimeBase.Increment();
            PublisherCounters.Counters[_name].NumberOfDocumentPerSecond.Increment();
            PublisherCounters.Counters[_name].NumberOfDocumentsPublished.Increment();

            // Add the document to the list of pending documents
            _pendingDocuments[doc.DocumentId] = doc;
        }

        /// <summary>
        /// Cleans and disposes of member variables
        /// </summary>
        public void Dispose()
        {
            if (_documentFeeder != null)
            {
                _documentFeeder.Dispose();
            }
        }

        /// <summary>
        /// There are three parts to handling a document error:
        /// 
        /// 1. Print out various details of the failing document:
        ///     - product id and lcid
        ///     - document size
        ///     - ESP failure code and other supplied ESP info
        ///     
        /// 2. Print out the cron url that can be used to retrieve the xml produced from the catalog. 
        ///     The XOC would be asked to put this in a browser pointed to the cron VIP and then sent
        ///     the resultant XML back to the developer
        ///     
        /// 3. If enabled (via npdb setting), parse the xml using a validating reader and determine its
        ///     wellformed-ness, printing out any errors.
        ///     
        /// Note that due to firstly the potential document size and secondly the fact that the cron
        /// instance will repeatedly run and attempt to reprocess the same document, it is not prudent
        /// to spit the errant document text into the log file.
        /// </summary>
        /// <param name="operationPair">
        /// This is the information returned by ESP for a document which encountered an error during
        /// processing. The first piece if information is an internal ESP operation id, the second
        /// id a DocumentError object containing information about the document and the error(s).
        /// </param>
        private String GetDocumentError(Pair operationPair)
        {
            StringBuilder errorText = new StringBuilder();
            errorText.Append(String.Format("{0}|Publishing error:", _name));

            // Print out the relevant details of the failing document. Unfortunately, the id of
            // the document is a string and we do not have the independent components that make it
            // up (product id, lcid ...). So we can only write out the concatenated id
            long espOperationId = (long)operationPair.First;    
            errorText.Append( String.Format( "|ESP operation id={0}", espOperationId ));

            DocumentError documentError = operationPair.Second as DocumentError;
            if ( documentError == null )
            {
                errorText.Append( "|Error=No error information available" );
                return errorText.ToString();
            }

            errorText.Append( String.Format( "|Document id={0}", documentError.DocumentId ));
            errorText.Append(String.Format("|ESP error code={0}", documentError.ErrorCode));
            errorText.Append(String.Format("|ESP suggested action={0}", documentError.SuggestedAction));
            errorText.Append(String.Format("|ESP component={0}", documentError.Component));
            errorText.Append(String.Format("|ESP error description={0}", documentError.Description));
            errorText.Append(String.Format("|ESP error type={0}", documentError.Type));
            errorText.Append(documentError.ToString());


            IWatcherDocument errantDocument = _pendingDocuments[documentError.DocumentId];
            if ( errantDocument == null )
            {
                errorText.Append( "|Error=document is null" );
            }

            // Print out a url which is essentially a CRON command that can be executed by
            // XOC which will return to the browser, the xml produced by GetProduceDocument
            // To get the correct URL, we need to extract virtual interface information from
            // npdb.
            //
            // Note that we can only print out this url IF we are able to sensibly parse out
            // the product id and lcid from the document id
            //
            // TODO: because there will be some post-processing of the xml, the xml returned
            // by this URL should include the post processing work.
            if (!String.IsNullOrEmpty(documentError.DocumentId))
            {
                // document id format is expected to be 'guid_lcid_...'
                String[] idComponents = documentError.DocumentId.Split(DocumentIdComponentSeparators);
                if (idComponents.Length >= 2)
                {
                    String productId = idComponents[0];
                    String lcid = idComponents[1];
                    IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.cron_int);

                    errorText.Append("|Manual document url=http://");
                    errorText.Append(info.IPAddressString);
                    errorText.Append(":");
                    errorText.Append(info.Port);
                    errorText.Append("/cron/command.ashx?");
                    errorText.Append("assembly=CatalogWatcherPlugin.dll");
                    errorText.Append("&classname=xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper");
                    errorText.Append("&op=GetProductDocument");
                    errorText.Append("&p1=" + productId);
                    errorText.Append("&p2=" + lcid);
                }
            }

            errorText.Append(String.Format("|Document size={0} unicode chars", errantDocument.Document.ToString().Length));

            // If we could not find this document return
            if (errantDocument == null)
            {
                return errorText.ToString();
            }
            
            // Parse the XML. We only do this if the npdb flag 'catalogwatcher_log_xml_validation_on_error' is
            // set to true.
            if (_performAndLogValidationOnError == true)
            {
                ValidateAndLogDocumentErrors errorParser = new ValidateAndLogDocumentErrors();
                errorText.Append( errorParser.GetValidationErrors( errantDocument.Document.ToString() ));
            }

            return errorText.ToString();
        }

        /// <summary>
        /// For document warnings, we simply log as much information as we can from what is provided
        /// from ESP.
        /// </summary>
        /// <param name="operationPair">
        /// This is the information returned by ESP for a document which encountered a warning during
        /// processing. The first piece if information is an internal ESP operation id, the second
        /// id a DocumentWarning object containing information about the document and the warning(s).
        /// </param>
        private String GetDocumentWarning(Pair operationPair)
        {
            StringBuilder warningText = new StringBuilder();
            warningText.Append(String.Format("{0}|Publishing warning:", _name));

            // Print out the relevant details of the failing document. Unfortunately, the id of
            // the document is a string and we do not have the independent components that make it
            // up (product id, lcid ...). So we can only write out the concatenated id
            long espOperationId = (long)operationPair.First;
            warningText.Append(String.Format("|ESP operation id={0}", espOperationId));

            DocumentWarning documentWarning = operationPair.Second as DocumentWarning;
            if (documentWarning == null)
            {
                warningText.Append("|Warning=No warning information available");
                return warningText.ToString();
            }

            warningText.Append(String.Format("|Document id={0}", documentWarning.DocumentId));
            warningText.Append(String.Format("|ESP warning code={0}", documentWarning.WarningCode));
            warningText.Append(String.Format("|ESP component={0}", documentWarning.Component));
            warningText.Append(String.Format("|ESP warning description={0}", documentWarning.Description));

            IWatcherDocument errantDocument = _pendingDocuments[documentWarning.DocumentId];
            if (errantDocument == null)
            {
                warningText.Append("|Error=document is null");
            }
            else
            {
                warningText.Append(String.Format("|Document size={0} unicode chars", errantDocument.Document.ToString().Length));
            }

            return warningText.ToString();
        }

        /// <summary>
        /// Get the Maximum Documents per Batch to flush to Publisher
        /// </summary>
        public int GetMaxDocumentsPerBatch()
        {
            return Config.GetIntSetting(Setting.catalogwatcher_fast_esp_max_documents_per_batch);
        }
 
        /// <summary>
        /// Get the Publisher setting for tracking status
        /// </summary>
        public bool CommitStatusPerBatch()
        {
            return true;
        }

        /// <summary>
        /// Get the Publisher setting for tracking status on error
        /// </summary>
        public bool CommitStatusOnError()
        {
            return true;
        }

        /// <summary>
        /// Close / Finish any pending actions to the Publisher Destination
        /// </summary>
        public void Close(){}


        /// <summary>
        /// Inner class used to get a string containing all the validation errors that occur
        /// within a document.
        /// Not thread safe.
        /// </summary>
        class ValidateAndLogDocumentErrors
        {
            private StringBuilder _errors;

            public String GetValidationErrors( String document )
            {
                _errors = new StringBuilder();

                // Since ESP does not understand the structure of our documents, other than it being 'well formed',
                // we only need to find what about the document failed the 'well formed' test. 
                XmlReaderSettings settings = new XmlReaderSettings();
                settings.ConformanceLevel = ConformanceLevel.Document;
                settings.ValidationEventHandler += new ValidationEventHandler(ValidationCallBack);

                // Create the XmlReader object and parse it. Errors are handled by the callback function
                XmlReader reader = XmlReader.Create(new StringReader(document), settings);
                try
                {
                    while (reader.Read()) ;
                }
                catch (Exception e)
                {
                    _errors.Append("|");
                    _errors.Append(e.Message);
                }

                return _errors.ToString();
            }

            // Callback to handle errors - simply appends the errors to a string builder.
            private void ValidationCallBack(object sender, ValidationEventArgs e)
            {
                _errors.Append("|");
                _errors.Append(e.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\PublisherPerfCounters.cs ===
using System;
using System.Data;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;
using System.Configuration.Install;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.installer;

namespace xonline.server.catalogwatcher
{
    [XomPerformanceCounterCategoryAttr("Catalog Watcher: Publisher Perf Counters", "Counters for Publisher")]
    public class PublisherCounters : XomPerformanceCounterCategory
    {
        static public PublisherCounters Counters = new PublisherCounters();

        public PublisherCounters this[string instanceName]
        {
            get
            {
                return (PublisherCounters)GetInstance(instanceName);
            }
        }

        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Number of document published",
        "The number of documents which have been published.",
        PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumberOfDocumentsPublished;

        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Number of document errors",
        "The number of documents which have caused an error.",
        PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumberOfDocumentErrors;

        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Number of document warnings",
        "The number of documents which have caused a warning.",
        PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumberOfDocumentWarnings;

        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Number of documents published per second",
        "The number of documents published per second.",
        PerformanceCounterType.RateOfCountsPerSecond64)]
        public PerformanceCounter NumberOfDocumentPerSecond;
        
        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Avg. publish time",
        "Averge time it takes to publish a document.",
        PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AveragePublishTime;

        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Avg. publish time base",
        "Averge time it takes to publish a document base.",
        PerformanceCounterType.AverageBase)]
        public PerformanceCounter AveragePublishTimeBase;
      
        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Avg. Flush Documents time",
        "Averge time it takes to publish a document.",
        PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageFlushDocumentsTime;

        [XomPerformanceCounterAttr(
        "Catalog Watcher: Publisher: Avg. flush documents time base",
        "Averge time it takes to publish a document base.",
        PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageFlushDocumentsTimeBase;
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\QueueCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.installer;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.catalogwatcher
{
    [XomPerformanceCounterCategoryAttr("Catalog Watcher: Queue Perf Counters", "Counters for the Queue")]
    public class QueueCounters : XomPerformanceCounterCategory
    {
        public static QueueCounters Counters = new QueueCounters();

        public QueueCounters this[string instanceName]
        {
            get
            {
                return (QueueCounters)GetInstance(instanceName);
            }
        }


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Queue Operations: enqueue wait time",
            "Wait time to add an item in the queue",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EnqueueWaitTime;


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Queue Operations: dequeue wait time",
            "Wait time to remove an item from the queue",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter DequeueWaitTime;

        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. wait time",
            "Average wait time for the queue operations",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageWaitTime;


        [XomPerformanceCounterAttr(
            "Catalog Watcher: Avg. wait time base",
            "Base for average wait time for the queue operations",
        PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageWaitTimeBase;


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\UserCommandHandler.cs ===
// 
// UserCommandHandler.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// The component that handles user commands

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Web;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// Handles the user specified commands
    /// </summary>
    public class UserCommandHandler
    {
        private string _commandName = String.Empty;
        private StringBuilder _result = null;
        private Hashtable _args = null;

        private static string[] s_customCommands = { "trace" };
        private uint _xmgmtRequestId;

        public UserCommandHandler()
        {
            _xmgmtRequestId = uint.MaxValue;
        }

        //This constructor will be invoked by xmgt commands
        public UserCommandHandler(uint reqId)
        {
            _xmgmtRequestId = reqId;
        }


        /// <summary>
        /// Gets information about the specified command name from npdb
        /// </summary>
        /// <param name="commandInterface">The interface for the command</param>
        /// <param name="commandProcName">The name of the sproc for the command</param>
        /// <param name="commandHelp">The helptext associated with the command</param>
        /// <returns></returns>
        private HResult GetCommandInfo(out string commandInterface, out string commandProcName, out string commandHelp)
        {
            HResult hr = HResult.S_OK;
            commandInterface = String.Empty;
            commandProcName = String.Empty;
            commandHelp = String.Empty;
            // Get the command info from npdb
            using (SqlClient sqlClient = new SqlClient(Interface.npdb))
            {
                sqlClient.AddParameter("@vc_command_name", _commandName);
                sqlClient.StoredProc = "dbo.p_catalog_watcher_get_command_info";
                using (SqlDataReader r = sqlClient.Execute())
                {
                    if (r.Read())
                    {
                        commandInterface = r.GetSqlString(r.GetOrdinal("CommandInterface")).Value;
                        commandProcName = r.GetSqlString(r.GetOrdinal("CommandProcName")).Value;
                        commandHelp = r.GetSqlString(r.GetOrdinal("CommandHelp")).Value;
                    }
                    else
                    {
                        _result.Append(String.Format("Command failed. Command Name 'op': {0} is invalid. ", _commandName));
                        _result.Append(String.Format("Available commands: {0}{1}", System.Environment.NewLine,GetAvailableCommands()));
                        hr = HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER;
                    }
                }
            }
            return hr;
        }

        /// <summary>
        /// Gets the parameter name-values
        /// </summary>
        /// <param name="opParamNames">List of names of the parameters</param>
        /// <param name="opParamValues">List of values of the parameters</param>
        /// <returns></returns>
        private HResult GetParamNameValues(out List<string> opParamNames, out List<string> opParamValues)
        {
            HResult hr = HResult.S_OK;
            opParamNames = new List<string>();
            opParamValues = new List<string>();
            // Get the values of the params from the user input (args)
            for (int i = 0; ; i++)
            {
                string paramName = "p" + (i+1) ;                
                object paramObject = _args[paramName];
                if (paramObject == null)
                {
                    // we have all the params 
                    break;
                }
                else if (paramObject.GetType() != typeof(string))
                {
                    _result.Append(String.Format("The {0} passed in is of the type {1}. The parameter '{2}' passed in should be of type String", paramName, paramObject.GetType(), paramName));
                    hr = HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER;
                    break;
                }
                else
                {
                    opParamNames.Add(paramName);
                    opParamValues.Add((string)paramObject);
                }
            }
            return hr;
        }

        /// <summary>
        /// Constructs the input parameter xml to be passed to the stored proc
        /// </summary>
        /// <returns>The constructed xml</returns>
        private String GetParamXml(List<string> opParamNames, List<string> opParamValues)
        {
            StringBuilder arrXml = new StringBuilder(String.Empty);
            for (int i = 0; i < opParamNames.Count; i++)
            {                        
                if (!String.IsNullOrEmpty(opParamValues[i]))
                {
                    string[] arr = opParamValues[i].Split('.');                                
                    for (int j = 0; j < arr.Length; j++)
                    {
                        arrXml.Append(String.Format("<{0} b=\"{1}\" />", opParamNames[i], arr[j])); 
                    }
                }
            }
            return arrXml.ToString();
        }

        /// <summary>
        /// Queries for the available watcher commands
        /// </summary>
        /// <returns>Name and helptext for each watcher command</returns>
        private string GetAvailableCommands()
        {
            StringBuilder commandHelp = new StringBuilder("");

            using (SqlClient sqlClientHelp = new SqlClient(Interface.npdb))
            {
                sqlClientHelp.StoredProc = "dbo.p_catalog_watcher_get_commands";
                using (SqlDataReader readerHelp = sqlClientHelp.Execute())
                {
                    while (readerHelp.Read())
                    {
                        string name = readerHelp.GetSqlString(readerHelp.GetOrdinal("CommandName")).Value;
                        string helptext = readerHelp.GetSqlString(readerHelp.GetOrdinal("CommandHelp")).Value;
                        commandHelp.Append(String.Format("'{0}', {1}{2}", name, helptext, System.Environment.NewLine));
                    }
                }
            }

            return commandHelp.ToString();
        }

        private bool IsCustomCommand()
        {
            return (Array.Exists(s_customCommands, delegate(string str) { return str.Equals(_commandName, StringComparison.InvariantCultureIgnoreCase); }));
        }


        /// <summary>
        /// Gets the command name and interface and executes the command
        /// </summary>
        private HResult ExecuteCommand()
        {
            HResult hr = HResult.S_OK;
            string commandInterface = null;
            string commandProcName = null;
            string commandHelp = null;
            List<string> opParamNames = null;
            List<string> opParamValues = null;
            hr = GetParamNameValues(out opParamNames, out opParamValues);
            if (hr.IsSuccess())
            {
                if (IsCustomCommand())
                {
                    switch (_commandName.ToLower())
                    {
                        case "trace":
                            CatalogWatcherTracer tracer = new CatalogWatcherTracer(_xmgmtRequestId);
                            hr = tracer.Trace(opParamNames, opParamValues, _result);
                            break;
                        default:
                            hr = HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER;
                            _result.Append(String.Format("Command failed. Command Name: {0} is invalid. ", _commandName));
                            break;
                    }
                }
                else
                {
                    // Get the name of the interface and the name of the command sproc
                    hr = GetCommandInfo(out commandInterface, out commandProcName, out commandHelp);
                    if (hr.IsSuccess())
                    {
                        using (SqlClient client = new SqlClient(commandInterface, false))
                        {
                            client.Command.CommandTimeout = Config.GetIntSetting(Setting.catalogwatcher_commands_timeout_in_secs);
                            client.StoredProc = commandProcName;
                            String xml = GetParamXml(opParamNames, opParamValues);
                            client.AddParameter("@paramXml", xml);
                            client.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                            string outputText = String.Empty;
                            client.AddParameter(ParameterDirection.Output, "@outputText", outputText, -1);
                            using (SqlDataReader r = client.Execute())
                            {
                                // Check if the proc executed successfully
                                hr = (uint)client.GetIntParameter("@hr");
                                outputText = client.GetStringParameter("@outputText");
                                _result.Append(outputText + System.Environment.NewLine);
                                if (hr.IsSuccess())
                                {
                                    _result.Append("Operation Completed Successfully");
                                }
                                else
                                {
                                    if (hr == HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER)
                                    {
                                        _result.Append("Command failed because of a missing parameter." + System.Environment.NewLine);
                                        _result.Append(String.Format("'{0}': {1}", _commandName, commandHelp));
                                    }
                                    else if (hr == HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER)
                                    {
                                        _result.Append("Command failed because of an invalid parameter." + System.Environment.NewLine);
                                        _result.Append(String.Format("'{0}': {1}", _commandName, commandHelp));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return hr;
        }

        /// <summary>
        ///  Gets the user command and calls sub functions to execute the command 
        /// </summary>
        public HResult Command(Hashtable args, StringBuilder result)
        {
            HResult hr = HResult.S_OK;
            _result = result;
            try
            {
                if (args == null)
                {
                    hr = HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER;
                    result.Append("'args' parameter is null");
                }
                if (hr.IsSuccess())
                {
                    _args = args;
                    object opObject = _args["op"];
                    if (opObject == null)
                    {
                        result.Append("'op' parameter is missing. ");
                        hr = HResult.XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER;
                    }
                    else if (opObject.GetType() != typeof(string))
                    {
                        result.Append(String.Format("The 'op' passed in is of the type {0}. The 'op' passed in should be of type String", opObject.GetType()));
                        hr = HResult.XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER;
                    }
                    else
                    {
                        _commandName = (string)opObject;
                    }
                }
                if (hr.IsSuccess())
                {
                    hr = ExecuteCommand();
                }
                else
                {
                    result.Append(String.Format("Available commands: {0}{1}", System.Environment.NewLine, GetAvailableCommands()));
                }
            }
            catch (Exception e)
            {
                result.Append("Command failed with Exception: " + e);
                hr = HResult.XONLINE_E_CATALOGWATCHER_COMMAND_FAILURE;
            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\core\ZuneAppPublisherEsp.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.installer;

using Com.FastSearch.Esp.Content;
using Com.FastSearch.Esp.Content.Errors;
using Com.FastSearch.Esp.Content.Util;
using Com.FastSearch.Esp.Content.Config;

namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// This class is used to publish documents to ESP.
    /// 
    /// The intended mode of operation is:
    ///     - construct and initialize an instance of this class
    ///     - repeat as necessary
    ///         - publish document by calling PublishDocument() repeatedly
    ///         - 'commit' the documents to ESP by calling FlushDocuments()
    ///     - dispose
    /// 
    /// Errors in documents are only checked for when the flush happens. ESP will no return
    /// the actual documents that gave the error. For this reason, we keep a dictionary called
    /// _pendingDocuments with each uncomitted document, keyed off of the document id. If we receive
    /// errors on a flush, for each error the document id is returned, the actual document retrieved
    /// from the pending list and relevant printed out.
    /// </summary>
    public class ZuneAppPublisherEsp : IWatcherDocumentPublisher
    {
        private string _contentDistributor = null;
        private string _collectionName = null;
        private Boolean _performAndLogValidationOnError;

        private IContentFactory _contentFactory = null;
        private IDocumentFeeder _documentFeeder = null;
        private Dictionary<String, IWatcherDocument> _pendingDocuments = null;

        private string _name = string.Empty;

        private bool _waitForIndexing = false;

        private static readonly char[] DocumentIdComponentSeparators = new char[] { '_' };

        /// <summary>
        /// Returns the name of this publisher instance
        /// </summary>
        public String InstanceName
        {
            get { return _name; }
        }

        private WorkerReport _report = null;

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }


        /// <summary>
        /// Initializes the publisher using test hooks
        /// </summary>
        public ZuneAppPublisherEsp(String testOverrideContentDistributor, String testOverrideCollectionName)
        {
            Init(testOverrideContentDistributor, testOverrideCollectionName);
            _name = "Test_ZuneAppPublisherEsp";
        }
      
        /// <summary>
        /// Initializes the publisher from NPDB settings
        /// </summary>
        public ZuneAppPublisherEsp()
        {            
        }

        /// <summary>
        /// Uses the content distributor and collection name to initialize the Publisher
        /// </summary>
        public void Init(int bucketId, int numBuckets)
        {
            _name = String.Format("CatalogWatcher|Publisher|{0}|{1}|{2:D3}", Constants.ZuneApp_ResourceName, Constants.ZuneApp_DestinationName, bucketId); 

            // Retrieve virtual interface information, construct connection string
            string[] ingestionIps = Config.GetMultiSetting(MultiSetting.fastEspZuneAppIngestionIps);

            string collectionName = Config.GetSetting(Setting.zunedb_catalogwatcher_fast_esp_collection_name);
            string ingestionPort = Config.GetSetting(Setting.zunedb_catalogwatcher_fast_esp_ingestion_port);

            StringBuilder espContentDistributor = new StringBuilder();
            string noFirstComma = string.Empty;

            // Format of the content distributor is a comma seperated list of host:port values
            //      host1:port,host2:port,host3:port
            foreach (string ip in ingestionIps)
            {
                espContentDistributor.AppendFormat("{0}{1}:{2}", noFirstComma, ip, ingestionPort);
                noFirstComma = ",";
            }
            Init(espContentDistributor.ToString(), collectionName);
        }

        public void Init(string espContentDistributor, string collectionName)
        {
            _contentDistributor = espContentDistributor;
            _collectionName = collectionName;        
            try
            {
                _contentFactory = Factory.CreateContentFactory();
                _documentFeeder = Factory.CreateDocumentFeeder(_contentDistributor, _collectionName);
            }
            catch (FactoryException fe)
            {
                string errorStr = String.Format("ESP Publisher ({0}): Error creating IDocumentFeeder using ContentDistributor [{1}] and CollectionName [{2}]", _name, _contentDistributor, _collectionName);
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, 
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, errorStr, fe);
            }

            // Check the configuration to see if we need to wait for indexing to complete when doing
            // a flush. If this is not set, the flush merely waits for document processing to complete.
            _waitForIndexing = Config.GetBoolSetting(Setting.zunedb_catalogwatcher_fast_wait_for_indexing);
            ISubsystem indexing = _documentFeeder.GetSystemConfig().GetSubsystem("indexing");
            if (indexing != null)
            {
                if (_waitForIndexing == true)
                {
                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Set to wait for indexing on flush.", _name));
                    indexing.CompletedCallbackEnabled = _waitForIndexing;
                }
            }
            else
            {
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Supposed to wait for indexing on flush, but indexing subsystem not found.", _name));
            }

            // Store for holding documents that are being sent to ESP. Required for when errors
            // occur and we need to determine what was invalid with the xml.
            _pendingDocuments = new Dictionary<string, IWatcherDocument>();

            // Get the flag that determines if, on ESP encountering an error processing the document, 
            // this code should validate the documents xml wellformed-ness and report the errors. (The
            // error returned from ESP is vague when this happens, so allowing it here is helpful)
            _performAndLogValidationOnError = Config.GetBoolSetting(Setting.zunedb_catalogwatcher_perform_and_log_validation_on_error);
        }

        /// <summary>
        /// Flushes all of the documents currently in the FAST ESP queue and checks for document errors and warnings. The warnings
        /// and errors are logged. The number of documents processed since the documents were last flushed are logged.
        /// </summary>
        public void FlushDocuments()
        {
            Xom.Trace(XomAreaName.catalogwatcherlog, LogLevel.L_INFO, String.Format("{0}|Flushing {1} documents with 'wait for indexing' set to {2}.", _name, _pendingDocuments.Count, _waitForIndexing));
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            _documentFeeder.WaitForCompletion();
            Xom.Trace(XomAreaName.catalogwatcherlog, LogLevel.L_INFO, String.Format("{0}|Flushing documents completed after {1} seconds.", _name, timeElapsed.SecondsElapsed));

            //get status for submitted document
            IDocumentFeederStatus status = _documentFeeder.GetStatusReport();

            // If there are errors with submuitting the documents, log a row for each error
            // We also create a generic message for the event, indicating the number of errors
            StringBuilder message = new StringBuilder(_name);
            if (status.HasDocumentErrors())
            {
                message.Append(String.Format("|{0} errors in {1} documents submitted to FAST ESP", status.NumDocumentErrors, _pendingDocuments.Count));
                foreach (Pair p in status.AllDocumentErrors)
                {
                    Xom.Log(XomAreaName.catalogwatcherlog, GetDocumentError(p));
                    PublisherCounters.Counters[_name].NumberOfDocumentErrors.Increment();
                }
            }

            // If there are warnings with submuitting the documents, log a row for each warning
            // We also create add to the generic message for the event, indicating the number of warnings
            if (status.HasDocumentWarnings())
            {
                message.Append(String.Format("|{0} warnings in {1} documents submitted to FAST ESP", status.NumDocumentWarnings, _pendingDocuments.Count));
                foreach (Pair p in status.DocumentWarnings)
                {
                    Xom.Log(XomAreaName.catalogwatcherlog, GetDocumentWarning(p));
                    PublisherCounters.Counters[_name].NumberOfDocumentWarnings.Increment();
                }
            }

            // Reset:
            // - clear the list of pending documents
            _pendingDocuments.Clear();

            PublisherCounters.Counters[_name].AverageFlushDocumentsTime.IncrementBy(timeElapsed.TimeElapsed);
            PublisherCounters.Counters[_name].AverageFlushDocumentsTimeBase.Increment();

            // If there was either an error or a warning, raise an event. Errors are more critical
            // than warnings, so we check that first and raise the error event. Otherwise we raise 
            // the warning event.
            if (status.HasDocumentErrors())
            {
                message.Append("Check the app/cron/catalogwatcher log for more information.");
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                                        XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                                        message.ToString());
            }
            else if (status.HasDocumentWarnings())
            {
                message.Append("Check the app/cron/catalogwatcher log for more information.");
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING,
                                        XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING,
                                        message.ToString());
            }
        }

        /// <summary>
        /// Creates a document and publishes it to the FAST ESP service
        /// </summary>        
        /// <param name="doc">Contains the identifier and document data information.
        /// This identifier must be repeatable if the document needs to be overwritten at a future point in time with new information.
        /// The document data object must be converted into a string object for processing
        /// </param>
        public void PublishDocument(IWatcherDocument doc)
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            if (doc == null)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Document is null");
            }
            else if (doc.Document == null)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Document data is null");
            }
            else if (doc.DocumentId == null)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Document identifier is null");
            }

            if (doc.Document.ToString() == string.Empty)
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Error submitting documents to FAST ESP: document being submitted is an empty string");
            }

            // Currently, we are only publishing MediaDocument, so verify that we can cast up an do so. Otherwise
            // it must be an error
            if (doc.GetType() != typeof(ZuneAppDocument))
            {
                throw new XRLException(HResult.XONLINE_E_ZUNEDB_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR,
                    XEvent.Id.ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, "Error submitting documents to FAST ESP: document being submitted is not an instance of type 'ZuneAppDocument'");
            }

            AddZuneApplicationDocument((ZuneAppDocument)doc);

            PublisherCounters.Counters[_name].AveragePublishTime.IncrementBy(timeElapsed.TimeElapsed);
            PublisherCounters.Counters[_name].AveragePublishTimeBase.Increment();
            PublisherCounters.Counters[_name].NumberOfDocumentPerSecond.Increment();
            PublisherCounters.Counters[_name].NumberOfDocumentsPublished.Increment();

            // Add the document to the list of pending documents
            _pendingDocuments[doc.DocumentId] = doc;
        }

        private void AddZuneApplicationDocument(ZuneAppDocument doc)
        {
            ArrayList documentFields = new ArrayList();
            // This glob of data is the XML document
            documentFields.Add(new StringElement("data", doc.Document.ToString()));

            documentFields.Add(new StringElement("searchtitle", doc.Title));
            documentFields.Add(new StringElement("publisher", doc.Publisher));
            documentFields.Add(new StringElement("keywords", doc.AdditionalIndexableStrings));
            documentFields.Add(new StringElement("clienttype", string.Join(";", doc.ClientTypes)));
            documentFields.Add(new StringElement("storetype", string.Join(";", doc.Stores)));

            documentFields.Add(new IntegerElement("visible", doc.Visible ? 1 : 0));
            documentFields.Add(new IntegerElement("downloadcount", doc.DownloadCount));

            documentFields.Add(new DoubleElement("zunescore", doc.Score));

            documentFields.Add(new DateTimeElement("visibilitydate", doc.VisibilityDate));

            Document document = _contentFactory.CreateDocument(doc.DocumentId, documentFields);
            _documentFeeder.AddDocument(document);
        }

        /// <summary>
        /// Cleans and disposes of member variables
        /// </summary>
        public void Dispose()
        {
            if (_documentFeeder != null)
            {
                _documentFeeder.Dispose();
            }
        }

        /// <summary>
        /// There are three parts to handling a document error:
        /// 
        /// 1. Print out various details of the failing document:
        ///     - product id and lcid
        ///     - document size
        ///     - ESP failure code and other supplied ESP info
        ///     
        /// 2. Print out the cron url that can be used to retrieve the xml produced from the catalog. 
        ///     The XOC would be asked to put this in a browser pointed to the cron VIP and then sent
        ///     the resultant XML back to the developer
        ///     
        /// 3. If enabled (via npdb setting), parse the xml using a validating reader and determine its
        ///     wellformed-ness, printing out any errors.
        ///     
        /// Note that due to firstly the potential document size and secondly the fact that the cron
        /// instance will repeatedly run and attempt to reprocess the same document, it is not prudent
        /// to spit the errant document text into the log file.
        /// </summary>
        /// <param name="operationPair">
        /// This is the information returned by ESP for a document which encountered an error during
        /// processing. The first piece of information is an internal ESP operation id, the second
        /// is a DocumentError object containing information about the document and the error(s).
        /// </param>
        private String GetDocumentError(Pair operationPair)
        {
            StringBuilder errorText = new StringBuilder();
            errorText.Append(String.Format("{0}|Publishing error:", _name));

            // Print out the relevant details of the failing document. Unfortunately, the id of
            // the document is a string and we do not have the independent components that make it
            // up (product id, lcid ...). So we can only write out the concatenated id
            long espOperationId = (long)operationPair.First;    
            errorText.Append( String.Format( "|ESP operation id={0}", espOperationId ));

            DocumentError documentError = operationPair.Second as DocumentError;
            if ( documentError == null )
            {
                errorText.Append( "|Error=No error information available" );
                return errorText.ToString();
            }

            errorText.Append( String.Format( "|Document id={0}", documentError.DocumentId ));
            errorText.Append(String.Format("|ESP error code={0}", documentError.ErrorCode));
            errorText.Append(String.Format("|ESP suggested action={0}", documentError.SuggestedAction));
            errorText.Append(String.Format("|ESP component={0}", documentError.Component));
            errorText.Append(String.Format("|ESP error description={0}", documentError.Description));
            errorText.Append(String.Format("|ESP error type={0}", documentError.Type));
            errorText.Append(documentError.ToString());


            IWatcherDocument errantDocument = _pendingDocuments[documentError.DocumentId];
            if (errantDocument == null)
            {
                errorText.Append("|Error=document is null");
            }

            // Print out a url which is essentially a CRON command that can be executed by
            // XOC which will return to the browser, the xml produced by GetProduceDocument
            // To get the correct URL, we need to extract virtual interface information from
            // npdb.
            //
            // Note that we can only print out this url IF we are able to sensibly parse out
            // the product id and lcid from the document id
            //
            // TODO: because there will be some post-processing of the xml, the xml returned
            // by this URL should include the post processing work.
            if (!String.IsNullOrEmpty(documentError.DocumentId))
            {
                // document id format is expected to be 'guid_lcid_...'
                String[] idComponents = documentError.DocumentId.Split(DocumentIdComponentSeparators);
                if (idComponents.Length >= 2)
                {
                    String productId = idComponents[0];
                    String lcid = idComponents[1];
                    IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.cron_int);

                    errorText.Append("|Manual document url=http://");
                    errorText.Append(info.IPAddressString);
                    errorText.Append(":");
                    errorText.Append(info.Port);
                    errorText.Append("/cron/command.ashx?");
                    errorText.Append("assembly=CatalogWatcherPlugin.dll");
                    errorText.Append("&classname=xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper");
                    errorText.Append("&op=GetApplicationNamesByIds");
                    errorText.Append("&p1=" + productId);
                    errorText.Append("&p2=" + lcid);
                }
            }

            errorText.Append(String.Format("|Document size={0} unicode chars", errantDocument.Document.ToString().Length));

            // If we could not find this document return
            if (errantDocument == null)
            {
                return errorText.ToString();
            }
            
            // Parse the XML. We only do this if the npdb flag 'catalogwatcher_log_xml_validation_on_error' is
            // set to true.
            if (_performAndLogValidationOnError == true)
            {
                ValidateAndLogDocumentErrors errorParser = new ValidateAndLogDocumentErrors();
                errorText.Append( errorParser.GetValidationErrors( errantDocument.Document.ToString() ));
            }

            return errorText.ToString();
        }

        /// <summary>
        /// For document warnings, we simply log as much information as we can from what is provided
        /// from ESP.
        /// </summary>
        /// <param name="operationPair">
        /// This is the information returned by ESP for a document which encountered a warning during
        /// processing. The first piece if information is an internal ESP operation id, the second
        /// id a DocumentWarning object containing information about the document and the warning(s).
        /// </param>
        private String GetDocumentWarning(Pair operationPair)
        {
            StringBuilder warningText = new StringBuilder();
            warningText.Append(String.Format("{0}|Publishing warning:", _name));

            // Print out the relevant details of the failing document. Unfortunately, the id of
            // the document is a string and we do not have the independent components that make it
            // up (product id, lcid ...). So we can only write out the concatenated id
            long espOperationId = (long)operationPair.First;
            warningText.Append(String.Format("|ESP operation id={0}", espOperationId));

            DocumentWarning documentWarning = operationPair.Second as DocumentWarning;
            if (documentWarning == null)
            {
                warningText.Append("|Warning=No warning information available");
                return warningText.ToString();
            }

            warningText.Append(String.Format("|Document id={0}", documentWarning.DocumentId));
            warningText.Append(String.Format("|ESP warning code={0}", documentWarning.WarningCode));
            warningText.Append(String.Format("|ESP component={0}", documentWarning.Component));
            warningText.Append(String.Format("|ESP warning description={0}", documentWarning.Description));

            IWatcherDocument errantDocument = _pendingDocuments[documentWarning.DocumentId];
            if (errantDocument == null)
            {
                warningText.Append("|Error=document is null");
            }
            else
            {
                warningText.Append(String.Format("|Document size={0} unicode chars", errantDocument.Document.ToString().Length));
            }

            return warningText.ToString();
        }

        /// <summary>
        /// Get the Maximum Documents per Batch to flush to Publisher
        /// </summary>
        public int GetMaxDocumentsPerBatch()
        {
            return Config.GetIntSetting(Setting.zunedb_catalogwatcher_fast_esp_max_documents_per_batch);
        }

        /// <summary>
        /// Get the Publisher setting for tracking status
        /// </summary>
        public bool CommitStatusPerBatch()
        {
            return true;
        }

        /// <summary>
        /// Get the Publisher setting for tracking status on error
        /// </summary>
        public bool CommitStatusOnError()
        {
            return true;
        }

        /// <summary>
        /// Close / Finish any pending actions to the Publisher Destination
        /// </summary>
        public void Close() { }

 
        /// <summary>
        /// Inner class used to get a string containing all the validation errors that occur
        /// within a document.
        /// Not thread safe.
        /// </summary>
        class ValidateAndLogDocumentErrors
        {
            private StringBuilder _errors;

            public String GetValidationErrors( String document )
            {
                _errors = new StringBuilder();

                // Since ESP does not understand the structure of our documents, other than it being 'well formed',
                // we only need to find what about the document failed the 'well formed' test. 
                XmlReaderSettings settings = new XmlReaderSettings();
                settings.ConformanceLevel = ConformanceLevel.Document;
                settings.ValidationEventHandler += new ValidationEventHandler(ValidationCallBack);

                // Create the XmlReader object and parse it. Errors are handled by the callback function
                XmlReader reader = XmlReader.Create(new StringReader(document), settings);
                try
                {
                    while (reader.Read()) ;
                }
                catch (Exception e)
                {
                    _errors.Append("|");
                    _errors.Append(e.Message);
                }

                return _errors.ToString();
            }

            // Callback to handle errors - simply appends the errors to a string builder.
            private void ValidationCallBack(object sender, ValidationEventArgs e)
            {
                _errors.Append("|");
                _errors.Append(e.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Media\MediaDocumentProcessor.cs ===
namespace xonline.server.catalogwatcher
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Xsl;

    using xonline.common.config;
    using xonline.common.mgmt;
    using xonline.common.sql.sqlclient;

    public class MediaDocumentProcessor : IWatcherDocumentProcessor
    {
        private struct DocumentTransform
        {
            public string targetDetailLevel;
            public string sourceDetailLevel;
            public XslCompiledTransform transform;

            public DocumentTransform(string targetDetail, string srcDetail, XslCompiledTransform docTransform)
            {
                targetDetailLevel = targetDetail;
                sourceDetailLevel = srcDetail;
                transform = docTransform;
            }
        };

        private string _name = string.Empty;
        private List<DocumentTransform> _transforms = new List<DocumentTransform>();

        private readonly string c_resourceName;
        private readonly string c_destinationName;

        /// <summary>
        /// Returns the name of this publisher instance
        /// </summary>
        public String InstanceName
        {
            get { return _name; }
        }

        private WorkerReport _report = null;

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }

        public void Dispose()
        {
        }

        public MediaDocumentProcessor(string resourceName, string destinationName)
        {
            c_resourceName = resourceName;
            c_destinationName = destinationName;
        }

        public void Init(int bucketId, int numBuckets)
        {
            _name = String.Format("CatalogWatcher|Processor|{0}|{1}|{2:D3}", c_resourceName, c_destinationName, bucketId);

            //
            // Initialize the XSLTs by loading them from NPDB
            //
            using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
            {
                sqlClient.StoredProc = "dbo.p_catalog_watcher_get_detailviews";
                SqlDataReader reader = sqlClient.Execute();

                while (reader.Read())
                {
                    string targetDetailView = reader["vc_target_detailview"].ToString();
                    string sourceDetailView = reader["vc_source_detailview"].ToString();
                    int ordinal = reader.GetOrdinal("xml_transform");
                    SqlXml detailTransform = reader.GetSqlXml(ordinal);

                    XslCompiledTransform xslTransform = new XslCompiledTransform();
                    xslTransform.Load(detailTransform.CreateReader());

                    _transforms.Add(new DocumentTransform(targetDetailView, sourceDetailView, xslTransform));
                }

                reader.Close();
            }
        }

        public void ProcessDocument(IWatcherDocument doc)
        {
            MediaDocument mediaDoc = doc as MediaDocument;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            // Process each document via the transforms
            foreach (DocumentTransform docTransform in _transforms)
            {
                object sourceXml = mediaDoc.FlatFieldsXml[docTransform.sourceDetailLevel];

                // Handle an invalid source field name
                if (null == sourceXml)
                {
                    throw new ArgumentNullException("FlatFieldsXml", string.Format("Unable to find source field {0}", docTransform.sourceDetailLevel));
                }

                string sourceDoc = sourceXml.ToString();

                StringBuilder sbOutput = new StringBuilder();
                XPathDocument xmlDoc = new XPathDocument(new StringReader(sourceDoc));

                docTransform.transform.Transform(xmlDoc, XmlWriter.Create(sbOutput));

                mediaDoc.FlatFieldsXml[docTransform.targetDetailLevel] = sbOutput.ToString();
            }

            long elapsed = timeElapsed.TimeElapsed;
            ProcessorCounters.Counters[_name].ProcessedPerSecond.Increment();
            ProcessorCounters.Counters[_name].AverageProcessingTime.IncrementBy(elapsed);
            ProcessorCounters.Counters[_name].AverageProcessingTimeBase.Increment();

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Media\MediaIdLcid.cs ===
// 
// MediaIdLcid.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//

using System;
using System.Data;
using System.Collections.Generic;
using System.Collections;
using System.Threading;
using System.Diagnostics;


namespace xonline.server.catalogwatcher
{    

    public class MediaIdLcid
    {
        public LSN LSN { get; protected set;}
        public Guid MediaId { get; protected set;}
        public int Lcid {get;protected set;}

        public MediaIdLcid(LSN lsn, Guid mediaId, int lcid)
        {
            LSN = lsn;
            MediaId = mediaId;
            Lcid = lcid;
        }

        public object ID
        {
            get { return ToString(); }
        }

        public override string ToString()
        {
            return (MediaId + "_" + Lcid.ToString());       
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Media\MediaDocument.cs ===
// 
// CatalogWatcher.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;

namespace xonline.server.catalogwatcher
{    
    public class MediaDocument: ILSNDocument
    {
        private MediaIdLcid _mediaIdLcid = null; 
        private string _id = null;

        public MediaDocument(Guid mediaId, int lcid, LSN lsn, string virtualCollectionName)
        {
            _mediaIdLcid = new MediaIdLcid(lsn, mediaId, lcid);
            _id = _mediaIdLcid.MediaId.ToString() + "_" + _mediaIdLcid.Lcid.ToString();
            if (!String.IsNullOrEmpty(virtualCollectionName))
            {
                _id += "_" + virtualCollectionName;
            }

            FlatFieldsXml = new Hashtable();
            FlatFieldsDateTime = new Hashtable();
            FlatFieldsInt32 = new Hashtable();
            FlatFieldsString = new Hashtable();
            FlatFieldsSingle = new Hashtable();                
        }

        // Properties which can only be set via the constructur
        public LSN      LSN                             { get { return _mediaIdLcid.LSN; }}
        public string   DocumentId                      { get { return _id; }}
        public MediaIdLcid MediaIdLcid                  { get { return _mediaIdLcid; } }

        public Object   Document                        { get; set;}
        public Hashtable FlatFieldsXml                  { get; set;}
        public Hashtable FlatFieldsDateTime             { get; set;}
        public Hashtable FlatFieldsInt32                { get; set;}
        public Hashtable FlatFieldsString               { get; set;}
        public Hashtable FlatFieldsSingle               { get; set;}  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Speech\SpeechDocument.cs ===
using System;
using System.IO;
using System.Data.SqlClient;
using System.Xml;
using System.Collections.Generic;

namespace xonline.server.catalogwatcher
{
    public class SpeechDocument : ILSNDocument
    {
        private MediaIdLcid mediaIdLcid = null;
        private string document = String.Empty;
        public SpeechDocument(MediaIdLcid mediaIdLcid, string document)
        {
            this.mediaIdLcid = mediaIdLcid;
            this.document = document;
        }

        #region ILSNDocument Members

        public LSN LSN
        {
            get { return mediaIdLcid.LSN; }
        }

        #endregion

        #region IWatcherDocument Members

        public string DocumentId
        {
            get { return mediaIdLcid.ToString(); }
        }

        public object Document
        {
            get { return document; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Speech\SpeechDocumentProducer.cs ===
// 
// MediaDocumentProducer.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;
using xonline.common.utilities;
using xonline.common.service;
using System.IO;



namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// The producer for Speech documents
    /// </summary>
    /// <remarks>
    /// A 'watcher' can have multiple instances, where each watcher instantiates a separate instance of 
    /// a SpeechDocumentProducer. This allows for the load of document production to be distributed across
    /// both a set of CRON machines and (most importantly) a set of catalog replicas. Distribution occurs
    /// by sequentially numbering each instance, starting at zero. Each instance then uses this number to
    /// perform hashing on each document identifier to determine if it is responsible for processing that
    /// id.
    /// 
    /// Since different replicas may be out of sync (one replica may be behind in terms of not having the
    /// latest set of changes - potentially hours behind). Hence when the list of ids needing processing
    /// is retrieved, the corresponding document retrieval needs to come from the exact same replica. If
    /// the id list were retrieved from an uptodate replica but the document is retrieved from a replica
    /// that is behind, then the document pushed to Azure would consist of OLD data. This instance would then
    /// mark the LSN as having been completed and the new document information will never be pushed to Azure.
    /// By hitting the same replica, the ToDo table and document tables will be in sync - if the updated
    /// document info is not on the replica, the LSN would not exist in the ToDo table.
    /// 
    /// The SpeechDocumentProducer works in the following manner:
    /// 
    /// Firstly, Init() is called passing in this instances identifier called the bucketId as well as
    /// the total number of instances (numBuckets). The init method then retrieves the last LSN which
    /// it is guaranteed to have processed - this comes from npdb. It then connects to a replica and
    /// retrieves all mediaId, lcid tuples from the 'ToDo' table, storing them in a list called '_detectIds'.
    /// It also stores the connection to that replica which it will use when retrieving the documents,
    /// ensuring that ids and documents come from a single source.
    /// 
    /// The method GetNextBatchOfDocuments() is then called repeatedly, passing in the number of documents
    /// to be generated. Each time the method is called the 'next' set of documents is generated. The list
    /// '_detectedIds' is used as master list of all ids for which documents need to be produced. The
    /// instance variable '_overallPosition' is used to keep track of where in this list we have got on
    /// each iteration of the method being called.
    /// 
    /// The list '_detectedIds' is, in case of error, never initialised or reset to null - this provides
    /// a simple check that can be made each time the public methods are called to make sure that the
    /// class is in a good state.
    /// </remarks>
    public class SpeechDocumentProducer : IWatcherDocumentProducer
    {
        private readonly string c_resourceName;
        private static readonly string c_destinationName = "Azure";

        private List<MediaIdLcid> _detectedIds = null;      // The list of (MediaIds,lcids) tuples to generate documents for
        private int _overallPosition = 0;                   // maintain the position in the '_detectdIds' list.
        private int _bucketId = -1;                         // this instances bucket id
        private int _numBuckets = -1;                       // total number of buckets
        private string _instanceName = String.Empty;        // the name for this SpeechDocumentProducer instance - used for logging, exceptions
        private int _documentVersion = 0;                   // future-proof, in case we need more than 1 version of docs produced
 
        // Warning!!! Please read this
        // The connection used to get the list of media ids which have changed SHOULD BE REUSED to get the actual documents
        private SqlClient _sqlReplicaClient = null; // Connection to the Replica DB; this connection will be used by Detector and the Extractor 

        private WorkerReport _report = null;

        /// <summary>
        /// Returns the name of this producer instance
        /// </summary>
        public String InstanceName
        {
            get { return _instanceName; }
        }

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }

        public SpeechDocumentProducer(string resourceName)
        {
            c_resourceName = resourceName;
        }

        /// <summary>
        /// Initialize the Producer
        /// </summary>        
        public void Init(int bucketId, int numBuckets)
        {
            if (bucketId < 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_SPEECH_PRODUCER_ERROR,
                String.Format("SpeechDocumentProducer initialized with invalid parameter value for 'BucketId'. Value should be greater than or equal to zero. Value is {0}", bucketId));
            }
            if (numBuckets <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_SPEECH_PRODUCER_ERROR,
                String.Format("SpeechDocumentProducer initialized with invalid parameter value for 'Number of Buckets'. Value should be greater than zero. Value is {0}", numBuckets));
            }
            if (bucketId >= numBuckets)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_SPEECH_PRODUCER_ERROR,
                String.Format("SpeechDocumentProducer initialized with invalid parameter values. BucketId is not less than Number of Buckets. BucketId is {0}. Number of Buckets is {1}", bucketId, numBuckets));
            }
            _bucketId = bucketId;
            _numBuckets = numBuckets;
            _instanceName = String.Format("CatalogWatcher|Producer|{0}|{1}|{2:D3}", c_resourceName, c_destinationName, bucketId); 
            _documentVersion = Config.GetIntSetting(Setting.catalogwatcher_speech_extractor_version);
         
            // Create a connection to an FE replica and store it. All operations against the catalog must
            // happen against the same replica.
            _sqlReplicaClient = new SqlClient(VirtualInterface.fecatalogdbwatcher, true);       

            // Reset/zero certain counters
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.RawValue = 0;
            ExtractorCounters.Counters[_instanceName].CallsTotal.RawValue = 0;

            // Get the set of ids for which this watcher instance needs to produce documents.
            switch(c_resourceName)
            {
                case "Speech":
                    GetMediaLCIDsFromToDo();
                    break;
                case "SpeechFull":
                    GetMediaLCIDsAll();
                    break;
                // Note: Factory handles default case    
            }

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Initialized", _instanceName));
        }

        /// <summary>
        /// Get the Maximum Batch Size for the Extractor
        /// </summary>
        public int GetMaxBatchSize()
        {
            return Config.GetIntSetting(Setting.catalogwatcher_speech_extractor_batch_size);
        }

        /// <summary>
        /// This function reads the LSN value from the CatalogWatcherStatus table in the npdb
        /// </summary>
        private LSN GetLastProcessedLSN()
        {
            LSN retVal = null;
            // Open a connection to the front door
            using (SqlClient sqlClient = new SqlClient(Interface.npdb))
            {
                sqlClient.AddParameter("@i_bucket_id", _bucketId);
                sqlClient.AddParameter("@vc_destination_name", c_destinationName);
                sqlClient.AddParameter("@vc_resource_name", c_resourceName);
                sqlClient.StoredProc = "dbo.p_catalog_watcher_get_last_lsn";

                using (SqlDataReader r = sqlClient.Execute())
                {
                    if (r.Read())
                    {
                        byte[] lsn = r.GetSqlBinary(r.GetOrdinal("lsn")).Value;
                        byte[] seq = r.GetSqlBinary(r.GetOrdinal("seq")).Value;
                        retVal = new LSN(lsn, seq);
                    }
                }
            }
            return retVal;
        }

        /// <summary>
        /// Return all the mediaId, lcids from the the ToDo table using the passed in connection to the Replica
        /// </summary>
        private void GetMediaLCIDsFromToDo()
        {
            GetMediaLCIDsFromDB("dbo.CatalogWatcherToDoProductGet");
        }

        /// <summary>
        /// Return all the mediaId, lcids from the the ToDo table using the passed in connection to the Replica
        /// </summary>
        private void GetMediaLCIDsAll()
        {
            GetMediaLCIDsFromDB("dbo.SpeechGameWatcherToDoProductGetAll");
        }

        /// <summary>
        /// Return all the mediaId, lcids from the the ToDo table using the passed in connection to the Replica
        /// </summary>
        private void GetMediaLCIDsFromDB(string StoredSproc)
        {
            _detectedIds = new List<MediaIdLcid>();

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            LSN lastProcessedLSN = GetLastProcessedLSN();
            _sqlReplicaClient.ClearParameters();
            _sqlReplicaClient.StoredProc = StoredSproc;
            _sqlReplicaClient.AddParameter("@lsn", lastProcessedLSN.Lsn);
            _sqlReplicaClient.AddParameter("@seq", lastProcessedLSN.Seq);
            using (SqlDataReader r = _sqlReplicaClient.Execute())
            {
                while (r.Read())
                {
                    Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                    if (Math.Abs(mediaId.GetHashCode()) % _numBuckets == _bucketId)
                    {
                        int lcid = r.GetInt32(r.GetOrdinal("lcid"));
                        byte[] lsn = r.GetSqlBinary(r.GetOrdinal("lsn")).Value;
                        Debug.Assert(lsn.Length == 10);
                        byte[] seq = r.GetSqlBinary(r.GetOrdinal("seq")).Value;
                        Debug.Assert(seq.Length == 10);
                        MediaIdLcid mediaLcid = new MediaIdLcid(new LSN(lsn, seq), mediaId, lcid);
                        _detectedIds.Add(mediaLcid);
                    }
                }
            }
            DetectorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
            DetectorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.IncrementBy(_detectedIds.Count);

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{1}|Detected {0} ids for document production", _detectedIds.Count, _instanceName));
        }
   
        private String RetrieveXmlFromQueryResult(SqlDataReader r, string column)
        {
           String document = (r.IsDBNull(r.GetOrdinal(column)) ? "" : r.GetString(r.GetOrdinal(column)));

           return Filter(document);
        }

        /// <summary>
        /// This method generates documents for each mediaId, Lcid pair
        /// </summary>
        public IEnumerable<IWatcherDocument> GetNextBatchOfDocuments(int batchSize)
        {
            // Validation. Check that a valid batchSizeis passed in. Also verify that the
            // list '_detectedIds' is not null - a value of null indicates that this instance
            // has either not been initialized correctly or is in an invalid state caused by
            // some previous exception.
            if (batchSize <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT,
                    XEvent.Id.CATALOG_WATCHER_SPEECH_PRODUCER_ERROR,
                    String.Format("BatchSize for GetNextBatchOfDocuments must be greater than zero. Current value: {0}", batchSize));
            }
            if (_detectedIds == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_STATE,
                XEvent.Id.CATALOG_WATCHER_SPEECH_PRODUCER_ERROR,
                "GetNextBatchOfDocuments invoked either without initializing the class instance or after an exception has occurred");
            }

            List<IWatcherDocument> documents = new List<IWatcherDocument>();

            //If there are no IDs detected to generate documents for, no work to do.
            if (_detectedIds.Count != 0)
            {
                int actualBatchSize = 0;

                try
                {
                    int startingPositionInDetectedIds = _overallPosition;

                    _sqlReplicaClient.ClearParameters();
                    _sqlReplicaClient.StoredProc = "dbo.GetSpeechDocuments";
                    _sqlReplicaClient.AddParameter("@version", _documentVersion);

                    // Create the set of mediaId - lcid tuples for which documents should be produced as a DataTable
                    // DataTable is standard .Net object for holding matrix of data for different types. The columns
                    // added have names that map to the columns of the table parameter expected by the sproc
                    DataTable table = new DataTable();
                    table.Columns.Add(new DataColumn("mediaId", typeof(Guid)));
                    table.Columns.Add(new DataColumn("lcid", typeof(Int32)));
                    table.Columns.Add(new DataColumn("position", typeof(Int32)));
                    for (int currentBatchCount = 0;
                        ((currentBatchCount < batchSize) && (_overallPosition < _detectedIds.Count));
                        currentBatchCount++, _overallPosition++)
                    {
                        table.Rows.Add(new Object[] {
                                                    _detectedIds[_overallPosition].MediaId,
                                                    _detectedIds[_overallPosition].Lcid,
                                                    _overallPosition });
                    }
                    SqlParameter mediaIdLcidsToProcess = _sqlReplicaClient.Command.Parameters.AddWithValue("@mediaIdLcidTuples", table);
                    mediaIdLcidsToProcess.SqlDbType = SqlDbType.Structured;
                    mediaIdLcidsToProcess.TypeName = "dbo.OrderedMediaIdLcidTuples";

                    _sqlReplicaClient.Command.CommandTimeout = Config.GetIntSetting(Setting.catalogwatcher_speech_extractor_timeout_in_secs);

                    // Execute the command against the same replica as that where the list of detected ids came
                    // from. This ensures that we will not hit a replica for the document information, where that
                    // replica is behind (e.g. replication has stopped). If this were to happen, we would publish
                    // old data, mark the LSN as completed and then not publish the new data.
                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                    using (SqlDataReader r = _sqlReplicaClient.Execute())
                    {
                        int index = startingPositionInDetectedIds;
                        while(r.Read())
                        {
                            Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                            Int32 lcid = r.GetInt32(r.GetOrdinal("lcid"));

                            for(/**/; mediaId != _detectedIds[index].MediaId || lcid != _detectedIds[index].Lcid; index++)
                            {
                                // Fast forward to next match, if any where skipped due to date filtering
                            }
                            
                            MediaIdLcid mediaIdLcid = new MediaIdLcid(_detectedIds[index].LSN, mediaId, lcid);
                            String document = RetrieveXmlFromQueryResult(r, "document");

                            // Verify that a document was produced for this mediaId, lcid tuple 
                            if (String.IsNullOrEmpty(document))
                            {
                                // we did not generate the document for the 'i'th mediaId
                                String msg = String.Format("Document not generated by extractor for mediaId: {0}  lcid: {1}", mediaId, lcid);
                                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_SPEECH_EXTRACTOR_MISSING_DOCUMENT,
                                                            XEvent.Id.CATALOG_WATCHER_SPEECH_PRODUCER_ERROR,
                                                            msg);
                            }

                            SpeechDocument doc = new SpeechDocument(mediaIdLcid, document);

                            documents.Add(doc);
                            actualBatchSize++;
                        }
                    }

                    // Bookkeeping
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsTotal.Increment();
                    ExtractorCounters.Counters[_instanceName].AverageBatchSize.IncrementBy(actualBatchSize);
                    ExtractorCounters.Counters[_instanceName].AverageBatchSizeBase.Increment();
                }
                catch (Exception e)
                {
                    ExtractorCounters.Counters[_instanceName].CallsFailedPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsFailedTotal.Increment();

                    // An error has been encountered. We set the list of detected ids to be null
                    // to prevent any more processing happening.
                    _detectedIds = null;

                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("Exception {0}", e));

                    throw e;
                }

                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Processed {1} of total {2} ids.", _instanceName, actualBatchSize, _detectedIds.Count));
            }
            return documents;
        }

        /// <summary>
        /// Remove extra Namespace tags that can occur with Sql-Gen'd XML
        /// from the Xml since we're re-assembling a feed on Publisher side
        /// </summary>
        internal static string Filter(
            string document
        )
        {
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(document);

            string innerXml = xmlDocument.DocumentElement.InnerXml;
            int length = innerXml.Length;

            // find all namespaces on root element and remove
            // them from all inner elements in  the  document

            foreach (XmlAttribute attribute in xmlDocument.DocumentElement.Attributes)
            {
                if (attribute.Name.StartsWith("xmlns"))
                {
                    string s = string.Format(" {0}=\"{1}\"", attribute.Name, attribute.Value);
                    innerXml = innerXml.Replace(s, string.Empty);
                }
            }

            // any replacements will cause  a  change in length.
            // only replace the document if the length  changed

            if (innerXml.Length != length)
            {
                xmlDocument.DocumentElement.InnerXml = innerXml;
            }

            return xmlDocument.OuterXml;
        }


        /// <summary>
        /// Returns the max queue size for the documents queue for the media documents
        /// </summary>
        public int GetMaxQueueLength()
        {
            return Config.GetIntSetting(Setting.catalogwatcher_producer_consumer_speech_max_queue_size);
        }

        /// <summary>
        /// Cleanup our resources
        /// </summary>
        public void Dispose()
        {
            if (_sqlReplicaClient != null)
            {
                _sqlReplicaClient.Dispose();
                _sqlReplicaClient = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Speech\SpeechDocumentBuilder.cs ===
using System;
using System.IO;
using System.Data.SqlClient;
using System.Xml;
using System.Collections.Generic;
using System.Text;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.mgmt;

using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    public class SpeechDocumentBuilder : IDocumentBuilder
    {

        public IWatcherDocument BuildDocument(SqlClient sqlClient, MediaIdLcid mediaIdLcid)
        {
            IWatcherDocument doc = null;
            try
            {
                Product product = DAL.GetProduct(sqlClient, mediaIdLcid);

                string xmlData = product.GetXmlString();

                doc = new SpeechDocument(mediaIdLcid, xmlData);
            }
            catch (Exception e)
            {
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("DocGen: Failed on exception {0}", e));
                throw;
            }

            return doc;
        }


        #region IDisposable Members

        public void Dispose()
        {
            //nothing to dispose right now.
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\VideoDocument.cs ===
using System;
using System.IO;
using System.Data.SqlClient;
using System.Xml;
using System.Collections.Generic;

namespace xonline.server.catalogwatcher
{
    public class VideoDocument : ILSNDocument
    {
        private MediaIdLcid mediaIdLcid = null;
        private string document = String.Empty;
        public VideoDocument(MediaIdLcid mediaIdLcid, string document)
        {
            this.mediaIdLcid = mediaIdLcid;
            this.document = document;
        }

        #region ILSNDocument Members

        public LSN LSN
        {
            get { return mediaIdLcid.LSN; }
        }

        #endregion

        #region IWatcherDocument Members

        public string DocumentId
        {
            get { return mediaIdLcid.ToString(); }
        }

        public object Document
        {
            get { return document; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Test\TestHarness\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TestHarness")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("TestHarness")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3f0c5824-2eb9-48fa-be07-b8cc0d2191ea")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\VideoDocumentBuilder.cs ===
using System;
using System.IO;
using System.Data.SqlClient;
using System.Xml;
using System.Collections.Generic;
using System.Text;

using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.mgmt;

using xonline.common.service;

namespace xonline.server.catalogwatcher
{
    public class VideoDocumentBuilder : IDocumentBuilder
    {

        public IWatcherDocument BuildDocument(SqlClient sqlClient, MediaIdLcid mediaIdLcid)
        {
            IWatcherDocument doc = null;
            try
            {
                Product product = DAL.GetProduct(sqlClient, mediaIdLcid);

                string xmlData = product.GetXmlString();

                doc = new VideoDocument(mediaIdLcid, xmlData);
            }
            catch (Exception e)
            {
                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("DocGen: Failed for {1} on exception {0}", e, mediaIdLcid.ID));
                throw;
            }

            return doc;
        }


        #region IDisposable Members

        public void Dispose()
        {
            //nothing to dispose right now.
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Media\MediaDocumentProducer.cs ===
// 
// MediaDocumentProducer.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;
using xonline.common.utilities;
using xonline.common.service;



namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// The producer for Media documents
    /// </summary>
    /// <remarks>
    /// A 'watcher' can have multiple instances, where each watcher instantiates a separate instance of 
    /// a MediaDocumentProducer. This allows for the load of document production to be distributed across
    /// both a set of CRON machines and (most importantly) a set of catalog replicas. Distribution occurs
    /// by sequentially numbering each instance, starting at zero. Each instance then uses this number to
    /// perform hashing on each document identifier to determine if it is responsible for processing that
    /// id.
    /// 
    /// Since different replicas may be out of sync (one replica may be behind in terms of not having the
    /// latest set of changes - potentially hours behind). Hence when the list of ids needing processing
    /// is retrieved, the corresponding document retrieval needs to come from the exact same replica. If
    /// the id list were retrieved from an uptodate replica but the document is retrieved from a replica
    /// that is behind, then the document pushed to ESP would consist of OLD data. This instance would then
    /// mark the LSN as having been completed and the new document information will never be pushed to ESP.
    /// By hitting the same replica, the ToDo table and document tables will be in sync - if the updated
    /// document info is not on the replica, the LSN would not exist in the ToDo table.
    /// 
    /// The MediaDocumentProducer works in the following manner:
    /// 
    /// Firstly, Init() is called passing in this instances identifier called the bucketId as well as
    /// the total number of instances (numBuckets). The init method then retrieves the last LSN which
    /// it is gaurenteed to have processed - this comes from npdb. It then connects to a replica and
    /// retrieves all mediaId, lcid tuples from the 'ToDo' table, storing them in a list called '_detectIds'.
    /// It also stores the connection to that replica which it will use when retrieveing the documents,
    /// ensuring that ids and documents come from a single source.
    /// 
    /// The method GetNextBatchOfDocuments() is then called repeatedly, passing in the number of documents
    /// to be generated. Each time the method is called the 'next' set of documents is generated. The list
    /// '_detectedIds' is used as master list of all ids for which documents need to be produced. The
    /// instance variable '_overallPosition' is used to keep track of where in this list we have got on
    /// each iteration of the method being called.
    /// 
    /// The list '_detectedIds' is, in case of error, never initialised or reset to null - this provides
    /// a simple check that can be made each time the public methods are called to make sure that the
    /// class is in a good state.
    /// </remarks>
    public class MediaDocumentProducer : IWatcherDocumentProducer
    {
        private static readonly string c_resourceName = "Media";
        private static readonly string c_destinationName = "ESP";
        private static readonly string c_xmlString = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";

        private List<MediaIdLcid> _detectedIds = null;      // The list of (MediaIds,lcids) tuples to generate documents for
        private int _overallPosition = 0;                   // maintain the poistion in the '_detectdIds' list.
        private int _bucketId = -1;                         // this instances bucket id
        private int _numBuckets = -1;                       // total number of buckets
        private string _instanceName = String.Empty;        // the name for this MediaDocumentProducer instance - used for logging, exceptions
        private int _documentVersion = 0;                   // TODO: verify what this cis, why we need it and how it works
        private string _virtualCollectionName = null;       // When deploying and using shared ESP server, virtual collection name is used to further identify documents

        // Warning!!! Please read this
        // The connection used to get the list of media ids which have changed SHOULD BE REUSED to get the actual documents
        private SqlClient _sqlReplicaClient = null; // Connection to the Replica DB; this connection will be used by Detector and the Extractor 

        private WorkerReport _report = null;

        /// <summary>
        /// Returns the name of this producer instance
        /// </summary>
        public String InstanceName
        {
            get { return _instanceName; }
        }

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }

        /// <summary>
        /// Initialize the Producer
        /// </summary>        
        public void Init(int bucketId, int numBuckets)
        {
            if (bucketId < 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                String.Format("MediaDocumentProducer initialized with invalid parameter value for 'BucketId'. Value should be greater than or equal to zero. Value is {0}", bucketId));
            }
            if (numBuckets <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                String.Format("MediaDocumentProducer initialized with invalid parameter value for 'Number of Buckets'. Value should be greater than zero. Value is {0}", numBuckets));
            }
            if (bucketId >= numBuckets)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                String.Format("MediaDocumentProducer initialized with invalid parameter values. BucketId is not less than Number of Buckets. BucketId is {0}. Number of Buckets is {1}", bucketId, numBuckets));
            }
            _bucketId = bucketId;
            _numBuckets = numBuckets;
            _instanceName = String.Format("CatalogWatcher|Producer|{0}|{1}|{2:D3}", c_resourceName, c_destinationName, bucketId); 
            _documentVersion = Config.GetIntSetting(Setting.catalogwatcher_media_extractor_version);
            _virtualCollectionName = Config.GetSetting(Setting.catalogwatcher_fast_esp_virtual_collection_name);

            // Create a connection to an FE replica an store it. All operations against the catalog must
            // happen against the same replica.
            _sqlReplicaClient = new SqlClient(VirtualInterface.fecatalogdbwatcher, true);       
            
            // Reset/zero certain counters
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.RawValue = 0;
            ExtractorCounters.Counters[_instanceName].CallsTotal.RawValue = 0;

            // Get the set of ids for which this watcher instance needs to produce documents.
            GetMediaLCIDsFromToDo();

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Initialized", _instanceName));
        }

        /// <summary>
        /// Get the Maximum Batch Size for the Extractor
        /// </summary>
        public int GetMaxBatchSize()
        {
            return Config.GetIntSetting(Setting.catalogwatcher_media_extractor_batch_size);
        }

        /// <summary>
        /// This function reads the LSN value from the CatalogWatcherStatus table in the npdb
        /// </summary>
        private LSN GetLastProcessedLSN()
        {
            LSN retVal = null;
            // Open a connection to the front door
            using (SqlClient sqlClient = new SqlClient(Interface.npdb))
            {
                sqlClient.AddParameter("@i_bucket_id", _bucketId);
                sqlClient.AddParameter("@vc_destination_name", c_destinationName);
                sqlClient.AddParameter("@vc_resource_name", c_resourceName);
                sqlClient.StoredProc = "dbo.p_catalog_watcher_get_last_lsn";

                using (SqlDataReader r = sqlClient.Execute())
                {
                    if (r.Read())
                    {
                        byte[] lsn = r.GetSqlBinary(r.GetOrdinal("lsn")).Value;
                        byte[] seq = r.GetSqlBinary(r.GetOrdinal("seq")).Value;
                        retVal = new LSN(lsn, seq);
                    }
                }
            }
            return retVal;
        }

        /// <summary>
        /// Return all the mediaId, lcids from the the ToDo table using the passed in connection to the Replica
        /// </summary>
        private void GetMediaLCIDsFromToDo()
        {
            _detectedIds = new List<MediaIdLcid>();

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            LSN lastProcessedLSN = GetLastProcessedLSN();
            _sqlReplicaClient.ClearParameters();
            _sqlReplicaClient.StoredProc = "dbo.CatalogWatcherToDoProductGet";
            _sqlReplicaClient.AddParameter("@lsn", lastProcessedLSN.Lsn);
            _sqlReplicaClient.AddParameter("@seq", lastProcessedLSN.Seq);
            using (SqlDataReader r = _sqlReplicaClient.Execute())
            {
                while (r.Read())
                {
                    Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                    if (Math.Abs(mediaId.GetHashCode()) % _numBuckets == _bucketId)
                    {
                        int lcid = r.GetInt32(r.GetOrdinal("lcid"));
                        byte[] lsn = r.GetSqlBinary(r.GetOrdinal("lsn")).Value;
                        Debug.Assert(lsn.Length == 10);
                        byte[] seq = r.GetSqlBinary(r.GetOrdinal("seq")).Value;
                        Debug.Assert(seq.Length == 10);
                        MediaIdLcid mediaLcid = new MediaIdLcid(new LSN(lsn, seq), mediaId, lcid);
                        _detectedIds.Add(mediaLcid);
                    }
                }
            }
            DetectorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
            DetectorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.IncrementBy(_detectedIds.Count);

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{1}|Detected {0} ids for document production", _detectedIds.Count, _instanceName));
        }

        /// <summary>
        /// This method adds the list of pdlc mediaTypes as a parameter to the sql command
        /// This list of mediaTypes is read from npdb from the t_multisettings table
        /// </summary>
        private void AddPDLCMediaTypes()
        {
            string[] pdlcMediaTypes = Config.GetMultiSetting(MultiSetting.pdlc_mediatypes);
            if (pdlcMediaTypes.Length == 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NO_PDLC_CONFIG,
                    XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                    "Configuration Error: pdlc_mediatypes setting is absent in t_multisettings in npdb");
            }

            // Create the set of pdlc mediaTypes
            // DataTable is standard .Net object for holding matrix of data for different types. The columns
            // added have names that map to the columns of the table parameter expected by the sproc
            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(int)));
            foreach (string pdlcMediaType in pdlcMediaTypes)
            {
                int mediaType = 0;
                try
                {
                    mediaType = Convert.ToInt32(pdlcMediaType);
                }
                catch (Exception e)
                {                    
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING,
                        XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                        String.Format("Configuration Error: pdlc_mediatypes setting in npdb should be an integer but was [{0}].", pdlcMediaType), e);
                }
                table.Rows.Add(new object[] { 
                                                mediaType 
                                            });
            }
            SqlParameter pdlcList = _sqlReplicaClient.Command.Parameters.AddWithValue("@pdlcMediaTypes", table);
            pdlcList.SqlDbType = SqlDbType.Structured;
            pdlcList.TypeName = "dbo.IntegerList";
        }

        /// <summary>
        /// Retrieves all of the exempt media ids from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        private void AddNonExemptMediaIds()
        {
            string[] fastRatingNonExemptMediaIds = Config.GetMultiSetting(MultiSetting.fastRatingNonExemptMediaIds);
            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(Guid)));
            foreach (string nonExemptMediaId in fastRatingNonExemptMediaIds)
            {
                Guid mediaId = Guid.Empty;
                try
                {
                    mediaId = new Guid(nonExemptMediaId);
                }
                catch (Exception e)
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING,
                        XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                        String.Format("Configuration Error: fastRatingNonExemptMediaIds setting in npdb should be an Guid but was [{0}].", nonExemptMediaId), e);
                }
                table.Rows.Add(new object[] { 
                                                mediaId 
                                            });
            }
            SqlParameter fastRatingNonExemptMediaIdsList = _sqlReplicaClient.Command.Parameters.AddWithValue("@nonExemptMediaIds", table);
            fastRatingNonExemptMediaIdsList.SqlDbType = SqlDbType.Structured;
            fastRatingNonExemptMediaIdsList.TypeName = "dbo.UniqueIdList";
        }

        /// <summary>
        /// Retrieves all of the exempt rating systems from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        private void AddNonExemptRatingSystem()
        {
            string[] fastRatingNonExemptRatingSystem = Config.GetMultiSetting(MultiSetting.fastRatingNonExemptRatingSystem);
            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(int)));
            foreach (string nonExemptRatingSystem in fastRatingNonExemptRatingSystem)
            {
                int ratingSystemId = 0;
                try
                {
                    ratingSystemId = Convert.ToInt32(nonExemptRatingSystem);
                }
                catch (Exception e)
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING,
                        XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                        String.Format("Configuration Error: fastRatingNonExemptRatingSystem setting in npdb should be an integer but was [{0}].", nonExemptRatingSystem), e);
                }
                table.Rows.Add(new object[] { 
                                                ratingSystemId 
                                            });
            }
            SqlParameter fastRatingNonExemptRatingSystemList = _sqlReplicaClient.Command.Parameters.AddWithValue("@nonExemptRatingSystems", table);
            fastRatingNonExemptRatingSystemList.SqlDbType = SqlDbType.Structured;
            fastRatingNonExemptRatingSystemList.TypeName = "dbo.IntegerList";
        }

        /// <summary>
        /// Retrieves all of the exempt media types from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        private void AddExemptMediaTypes()
        {
            string[] fastRatingExemptMediaTypes = Config.GetMultiSetting(MultiSetting.fastRatingExemptMediaTypes);
            if (fastRatingExemptMediaTypes.Length == 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NO_EXEMPTMEDIATYPES,
                    XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                    "Configuration Error: fastRatingExemptMediaTypes setting is absent in t_multisettings in npdb");
            }

            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(int)));
            foreach (string exemptMediaType in fastRatingExemptMediaTypes)
            {
                int mediaTypeId = 0;
                try
                {
                    mediaTypeId = Convert.ToInt32(exemptMediaType);
                }
                catch (Exception e)
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING,
                        XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                        String.Format("Configuration Error: fastRatingExemptMediaTypes setting in npdb should be an integer but was [{0}].", exemptMediaType), e);
                }
                table.Rows.Add(new object[] { 
                                                mediaTypeId 
                                            });
            }
            SqlParameter fastRatingExemptMediaTypesList = _sqlReplicaClient.Command.Parameters.AddWithValue("@exemptMediaTypes", table);
            fastRatingExemptMediaTypesList.SqlDbType = SqlDbType.Structured;
            fastRatingExemptMediaTypesList.TypeName = "dbo.IntegerList";
        }

        /// <summary>
        /// Retrieves all of the exempt game content for titles from a multisetting in NPDB, and adds them to the sql command
        /// </summary>
        private void AddExemptGCForTitles()
        {
            string[] fastRatingExemptGCForTitles = Config.GetMultiSetting(MultiSetting.fastRatingExemptGCForTitles);
            if (fastRatingExemptGCForTitles.Length == 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NO_EXEMPTGCFORTITLES,
                    XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                    "Configuration Error: fastRatingExemptGCForTitles setting is absent in t_multisettings in npdb");
            }

            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(int)));
            foreach (string exemptGCForTitle in fastRatingExemptGCForTitles)
            {
                int titleId = 0;
                try
                {
                    titleId = Convert.ToInt32(exemptGCForTitle);
                }
                catch (Exception e)
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING,
                        XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                        String.Format("Configuration Error: fastRatingExemptGCForTitles setting in npdb should be an integer but was [{0}].", exemptGCForTitle), e);
                }
                table.Rows.Add(new object[] { 
                                                titleId 
                                            });
            }
            SqlParameter fastRatingExemptGCForTitlesList = _sqlReplicaClient.Command.Parameters.AddWithValue("@exemptGCForTitles", table);
            fastRatingExemptGCForTitlesList.SqlDbType = SqlDbType.Structured;
            fastRatingExemptGCForTitlesList.TypeName = "dbo.IntegerList";
        }

        /// <summary>
        /// This method adds the list of rateable mediaTypes as a parameter to the sql command
        /// This list of mediaTypes is read from npdb from the t_multisettings table
        /// </summary>
        private void AddRateableMediaTypes()
        {
            string[] rateableMediaTypes = Config.GetMultiSetting(MultiSetting.ratings_mediatypes);
            if (rateableMediaTypes == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NO_RATEABLE_CONFIG,
                    XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                    "Configuration Error: ratings_mediatypes setting is absent in t_multisettings in npdb");
            }

            // Create the set of rateable mediaTypes
            // DataTable is standard .Net object for holding matrix of data for different types. The columns
            // added have names that map to the columns of the table parameter expected by the sproc
            DataTable table = new DataTable();
            table.Columns.Add(new DataColumn("i", typeof(int)));
            foreach (string rateableMediaType in rateableMediaTypes)
            {
                int mediaType = 0;
                try
                {
                    mediaType = Convert.ToInt32(rateableMediaType);
                }
                catch (Exception e)
                {
                    throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING,
                        XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                        String.Format("Configuration Error: ratings_mediatypes setting in npdb should be an integer but was [{0}].", rateableMediaType), e);
                }
                table.Rows.Add(new object[] { 
                                                mediaType 
                                            });
            }
            SqlParameter rateableMediaTypeList = _sqlReplicaClient.Command.Parameters.AddWithValue("@rateableMediaTypes", table);
            rateableMediaTypeList.SqlDbType = SqlDbType.Structured;
            rateableMediaTypeList.TypeName = "dbo.IntegerList";
        }

        private String RetrieveXmlFromQueryResult(SqlDataReader r, string column)
        {
            String document = (r.IsDBNull(r.GetOrdinal(column)) ? "" : r.GetString(r.GetOrdinal(column)));

            StringBuilder documentBuilder = new StringBuilder();
            documentBuilder.Append(c_xmlString);
            document = Filter(document);
            documentBuilder.Append(document);

            return documentBuilder.ToString();
        }

        private void RetrieveStringFromQueryResult(SqlDataReader r, string column, MediaDocument doc)
        {
            if(!r.IsDBNull(r.GetOrdinal(column)))
            {
                doc.FlatFieldsString[column] = r.GetString(r.GetOrdinal(column)); 
            }                       
        }

        private void RetrieveDateTimeFromQueryResult(SqlDataReader r, string column, MediaDocument doc)
        {
            if (!r.IsDBNull(r.GetOrdinal(column)))
            {
                doc.FlatFieldsDateTime[column] = r.GetDateTime(r.GetOrdinal(column));
            }
        }

        private void RetrieveInt32FromQueryResult(SqlDataReader r, string column, MediaDocument doc)
        {
            if (!r.IsDBNull(r.GetOrdinal(column)))
            {
                doc.FlatFieldsInt32[column] = r.GetInt32(r.GetOrdinal(column));
            }
        }

        private void RetrieveSingleFromQueryResult(SqlDataReader r, string column, MediaDocument doc)
        {
            if (!r.IsDBNull(r.GetOrdinal(column)))
            {
                doc.FlatFieldsSingle[column] = System.Convert.ToSingle(r.GetDecimal(r.GetOrdinal(column)));
            }
        }       
 
        /// <summary>
        /// This method generates documents for each mediaId, Lcid pair
        /// </summary>
        public IEnumerable<IWatcherDocument> GetNextBatchOfDocuments(int batchSize)
        {
            // Validation. Check that a valid batchSizeis passed in. Also verify that the
            // list '_detectedIds' is not null - a value of null indicates that this instance
            // has either not been initialized correctly or is in an invalid state caused by
            // some previous exception.
            if (batchSize <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT,
                    XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                    String.Format("BatchSize for GetNextBatchOfDocuments must be greater than zero. Current value: {0}", batchSize));
            }
            if (_detectedIds == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_STATE,
                XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                "GetNextBatchOfDocuments invoked either without initializing the class instance or after an exception has occurred");
            }

            List<IWatcherDocument> documents = new List<IWatcherDocument>();

            //If there are no IDs detected to generate documents for, no work to do.
            if (_detectedIds.Count != 0)
            {
                int actualBatchSize = 0;
                try
                {
                    int startingPositionInDetectedIds = _overallPosition;

                    _sqlReplicaClient.ClearParameters();
                    _sqlReplicaClient.StoredProc = "dbo.GetProductDocuments";
                    _sqlReplicaClient.AddParameter("@version", _documentVersion);

                    // When deploying to an xblob, all xblob will use a shared collection on a shared
                    // ESP server. To differentiate whos document is whos, the virtual collection name is
                    // added to each document.
                    if (!String.IsNullOrEmpty(_virtualCollectionName))
                    {
                        _sqlReplicaClient.AddParameter("@virtualCollection", _virtualCollectionName);
                    }

                    // Create the set of mediaId - lcid tuples for which documents should be produced as a DataTable
                    // DataTable is standard .Net object for holding matrix of data for different types. The columns
                    // added have names that map to the columns of the table parameter expected by the sproc
                    DataTable table = new DataTable();
                    table.Columns.Add(new DataColumn("mediaId", typeof(Guid)));
                    table.Columns.Add(new DataColumn("lcid", typeof(Int32)));
                    table.Columns.Add(new DataColumn("position", typeof(Int32)));
                    for (int currentBatchCount = 0;
                        ((currentBatchCount < batchSize) && (_overallPosition < _detectedIds.Count));
                        currentBatchCount++, _overallPosition++)
                    {
                        table.Rows.Add(new Object[] {
                                                    _detectedIds[_overallPosition].MediaId,
                                                    _detectedIds[_overallPosition].Lcid,
                                                    _overallPosition });
                    }
                    SqlParameter mediaIdLcidsToProcess = _sqlReplicaClient.Command.Parameters.AddWithValue("@mediaIdLcidTuples", table);
                    mediaIdLcidsToProcess.SqlDbType = SqlDbType.Structured;
                    mediaIdLcidsToProcess.TypeName = "dbo.OrderedMediaIdLcidTuples";

                    AddPDLCMediaTypes();
                    AddRateableMediaTypes();
                    AddExemptGCForTitles();
                    AddExemptMediaTypes();
                    AddNonExemptRatingSystem();
                    AddNonExemptMediaIds();

                    int userRatingMinReviewCount = 0; // Even though the setting in npdb says 'ratings_MAX_allowable_reviewcount'; it actually means min
                    try
                    {
                        userRatingMinReviewCount = Config.GetIntSetting(Setting.ratings_max_allowable_reviewcount);
                    }
                    catch (Exception ex)
                    {
                        throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING,
                            XEvent.Id.CATALOG_WATCHER_MEDIA_PRODUCER_ERROR,
                            string.Format("Configuration Error: The npdb setting [{0}] in npdb should be an integer but was [{1}]. Exception: {2}", Setting.ratings_max_allowable_reviewcount, Config.GetSetting(Setting.ratings_max_allowable_reviewcount), ex));
                    }
                    _sqlReplicaClient.AddParameter("@userRatings_min_reviewcount", userRatingMinReviewCount);
                    _sqlReplicaClient.Command.CommandTimeout = Config.GetIntSetting(Setting.catalogwatcher_extractor_timeout_in_secs);

                    // Execute the command against the same replica as that where the list of detected ids came
                    // from. This ensures that we will not hit a replica for the document information, where that
                    // replica is behind (e.g. replication has stopped). If this were to happen, we would publish
                    // old data, mark the LSN as completed and then not publish the new data.
                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                    using (SqlDataReader r = _sqlReplicaClient.Execute())
                    {
                        for (int index = startingPositionInDetectedIds; r.Read(); index++)
                        {
                            Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                            Int32 lcid = r.GetInt32(r.GetOrdinal("lcid"));
                            String document = RetrieveXmlFromQueryResult(r, "document");

                            // Verify that a document was produced for this mediaId, lcid tuple 
                            if (String.IsNullOrEmpty(document))
                            {
                                // we did not generate the document for the 'i'th mediaId
                                String msg = String.Format("Document not generated by extractor for mediaId: {0}  lcid: {1}", mediaId, lcid);
                                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_MEDIA_EXTRACTOR_MISSING_DOCUMENT,
                                                            XEvent.Id.CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR,
                                                            msg);
                            }

                            MediaDocument doc = new MediaDocument(mediaId, lcid, _detectedIds[index].LSN, _virtualCollectionName);
                            doc.Document = document;

                            String[] flatFields = Config.GetMultiSetting(MultiSetting.fastEspFlatFieldsXml);
                            foreach (String flatField in flatFields)
                            {
                                doc.FlatFieldsXml[flatField] = RetrieveXmlFromQueryResult(r, flatField);
                            }

                            flatFields = Config.GetMultiSetting(MultiSetting.fastEspFlatFieldsDateTime);
                            foreach (String flatField in flatFields)
                            {
                                RetrieveDateTimeFromQueryResult(r, flatField, doc);
                            }

                            flatFields = Config.GetMultiSetting(MultiSetting.fastEspFlatFieldsInt32);
                            foreach (String flatField in flatFields)
                            {
                                RetrieveInt32FromQueryResult(r, flatField, doc);
                            }

                            flatFields = Config.GetMultiSetting(MultiSetting.fastEspFlatFieldsString);
                            foreach (String flatField in flatFields)
                            {
                                RetrieveStringFromQueryResult(r, flatField, doc);
                            }

                            flatFields = Config.GetMultiSetting(MultiSetting.fastEspFlatFieldsSingle);
                            foreach (String flatField in flatFields)
                            {
                                RetrieveSingleFromQueryResult(r, flatField, doc);
                            }

                            documents.Add(doc);
                            actualBatchSize++;
                        }
                    }

                    // Bookkeeping
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsTotal.Increment();
                    ExtractorCounters.Counters[_instanceName].AverageBatchSize.IncrementBy(actualBatchSize);
                    ExtractorCounters.Counters[_instanceName].AverageBatchSizeBase.Increment();
                }
                catch (Exception e)
                {
                    ExtractorCounters.Counters[_instanceName].CallsFailedPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsFailedTotal.Increment();

                    // An error has been encountered. We set the list of detected ids to be null
                    // to prevent any more processing hapening.
                    _detectedIds = null;

                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("Exception {0}", e));

                    throw e;
                }

                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Processed {1} of total {2} ids.", _instanceName, actualBatchSize, _detectedIds.Count));
            }
            return documents;
        }

        internal static string Filter(
            string document
        )
        {
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(document);

            string innerXml = xmlDocument.DocumentElement.InnerXml;
            int length = innerXml.Length;

            // find all namespaces on root element and remove
            // them from all inner elements in  the  document

            foreach (XmlAttribute attribute in xmlDocument.DocumentElement.Attributes)
            {
                if (attribute.Name.StartsWith("xmlns"))
                {
                    string s = string.Format(" {0}=\"{1}\"", attribute.Name, attribute.Value);
                    innerXml = innerXml.Replace(s, string.Empty);
                }
            }

            // any replacements will cause  a  change in length.
            // only replace the document if the length  changed

            if (innerXml.Length != length)
            {
                xmlDocument.DocumentElement.InnerXml = innerXml;
            }

            return xmlDocument.OuterXml;
        }

        /// <summary>
        /// Returns the max queue size for the documents queue for the media documents
        /// </summary>
        public int GetMaxQueueLength()
        {
            return Config.GetIntSetting(Setting.catalogwatcher_producer_consumer_media_max_queue_size);
        }

        /// <summary>
        /// Cleanup our resources
        /// </summary>
        public void Dispose()
        {
            if (_sqlReplicaClient != null)
            {
                _sqlReplicaClient.Dispose();
                _sqlReplicaClient = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Availability.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;
using System.Xml;

namespace xonline.server.catalogwatcher
{

    class Availability: IElement 
    {
        public OfferType OfferType;
        public DateTime StartDateTime;
        public DateTime? EndDateTime;
        public PriceDisplayString PriceDisplayString;

        private Availability()
        {
        }

        static public Availability Create(SqlDataReader dataReader)
        {
            Availability av = new Availability();

            string offerTypeName = DAL.GetString(dataReader, "OfferType");
            if (offerTypeName != null)
            {
                av.OfferType = (OfferType)Enum.Parse(typeof(OfferType), offerTypeName);
            }
            else
            {
                av.OfferType = OfferType.Unknown;
            }
            av.StartDateTime = DAL.GetDateTime(dataReader, "StartDateTime");
            av.EndDateTime = DAL.GetNullableDateTime(dataReader, "EndDateTime");
            string s = DAL.GetString(dataReader, "PriceString");
            if (!string.IsNullOrEmpty(s))
            {
                av.PriceDisplayString = new PriceDisplayString(s);
            }

            return av;
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement("Availability");
            if (this.OfferType != OfferType.Unknown)
            {
                XmlUtility.WriteElement(writer, "OfferType", this.OfferType.ToString());
            }
            XmlUtility.WriteElement(writer, "StartDateTime", this.StartDateTime.ToString(XmlUtility.DateTimeFormat));
            if (this.EndDateTime != null)
            {
                XmlUtility.WriteElement(writer, "EndDateTime", ((DateTime)this.EndDateTime).ToString(XmlUtility.DateTimeFormat));
            }

            if (this.PriceDisplayString != null)
            {
                writer.WriteStartElement("PriceDisplayString");
                this.PriceDisplayString.WriteToXml(writer);
                writer.WriteEndElement();
            }

            writer.WriteEndElement();
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\VideoDocumentProducer.cs ===
// 
// MediaDocumentProducer.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common data structures and utility

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;
using xonline.common.utilities;
using xonline.common.service;
using System.IO;



namespace xonline.server.catalogwatcher
{
    /// <summary>
    /// The producer for Video documents
    /// </summary>
    /// <remarks>
    /// A 'watcher' can have multiple instances, where each watcher instantiates a separate instance of 
    /// a VideoDocumentProducer. This allows for the load of document production to be distributed across
    /// both a set of CRON machines and (most importantly) a set of catalog replicas. Distribution occurs
    /// by sequentially numbering each instance, starting at zero. Each instance then uses this number to
    /// perform hashing on each document identifier to determine if it is responsible for processing that
    /// id.
    /// 
    /// Since different replicas may be out of sync (one replica may be behind in terms of not having the
    /// latest set of changes - potentially hours behind). Hence when the list of ids needing processing
    /// is retrieved, the corresponding document retrieval needs to come from the exact same replica. If
    /// the id list were retrieved from an uptodate replica but the document is retrieved from a replica
    /// that is behind, then the document pushed to Azure would consist of OLD data. This instance would then
    /// mark the LSN as having been completed and the new document information will never be pushed to Azure.
    /// By hitting the same replica, the ToDo table and document tables will be in sync - if the updated
    /// document info is not on the replica, the LSN would not exist in the ToDo table.
    /// 
    /// The VideoDocumentProducer works in the following manner:
    /// 
    /// Firstly, Init() is called passing in this instances identifier called the bucketId as well as
    /// the total number of instances (numBuckets). The init method then retrieves the last LSN which
    /// it is guaranteed to have processed - this comes from npdb. It then connects to a replica and
    /// retrieves all mediaId, lcid tuples from the 'ToDo' table, storing them in a list called '_detectIds'.
    /// It also stores the connection to that replica which it will use when retrieving the documents,
    /// ensuring that ids and documents come from a single source.
    /// 
    /// The method GetNextBatchOfDocuments() is then called repeatedly, passing in the number of documents
    /// to be generated. Each time the method is called the 'next' set of documents is generated. The list
    /// '_detectedIds' is used as master list of all ids for which documents need to be produced. The
    /// instance variable '_overallPosition' is used to keep track of where in this list we have got on
    /// each iteration of the method being called.
    /// 
    /// The list '_detectedIds' is, in case of error, never initialised or reset to null - this provides
    /// a simple check that can be made each time the public methods are called to make sure that the
    /// class is in a good state.
    /// </remarks>
    public class VideoDocumentProducer : IWatcherDocumentProducer
    {
        private static readonly string c_resourceName = "Video";
        private static readonly string c_destinationName = "Azure";

        private List<MediaIdLcid> _detectedIds = null;      // The list of (MediaIds,lcids) tuples to generate documents for
        private int _overallPosition = 0;                   // maintain the position in the '_detectdIds' list.
        private int _bucketId = -1;                         // this instances bucket id
        private int _numBuckets = -1;                       // total number of buckets
        private string _instanceName = String.Empty;        // the name for this VideoDocumentProducer instance - used for logging, exceptions
 
        // Warning!!! Please read this
        // The connection used to get the list of media ids which have changed SHOULD BE REUSED to get the actual documents
        private SqlClient _sqlReplicaClient = null; // Connection to the Replica DB; this connection will be used by Detector and the Extractor 

        private WorkerReport _report = null;

        /// <summary>
        /// Returns the name of this producer instance
        /// </summary>
        public String InstanceName
        {
            get { return _instanceName; }
        }

        public WorkerReport Report
        {
            get
            {
                return _report;
            }
            set
            {
                _report = value;
            }
        }

        /// <summary>
        /// Initialize the Producer
        /// </summary>        
        public void Init(int bucketId, int numBuckets)
        {
            if (bucketId < 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_VIDEO_PRODUCER_ERROR,
                String.Format("VideoDocumentProducer initialized with invalid parameter value for 'BucketId'. Value should be greater than or equal to zero. Value is {0}", bucketId));
            }
            if (numBuckets <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_VIDEO_PRODUCER_ERROR,
                String.Format("VideoDocumentProducer initialized with invalid parameter value for 'Number of Buckets'. Value should be greater than zero. Value is {0}", numBuckets));
            }
            if (bucketId >= numBuckets)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY,
                XEvent.Id.CATALOG_WATCHER_VIDEO_PRODUCER_ERROR,
                String.Format("VideoDocumentProducer initialized with invalid parameter values. BucketId is not less than Number of Buckets. BucketId is {0}. Number of Buckets is {1}", bucketId, numBuckets));
            }
            _bucketId = bucketId;
            _numBuckets = numBuckets;
            _instanceName = String.Format("CatalogWatcher|Producer|{0}|{1}|{2:D3}", c_resourceName, c_destinationName, bucketId); 
         
            // Create a connection to an FE replica and store it. All operations against the catalog must
            // happen against the same replica.
            _sqlReplicaClient = new SqlClient(ConfigUtil.FECatalogDBZuneVirtualInterfaceInfo);       

            // Reset/zero certain counters
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.RawValue = 0;
            ExtractorCounters.Counters[_instanceName].CallsTotal.RawValue = 0;

            // Get the set of ids for which this watcher instance needs to produce documents.
            GetMediaLCIDsFromToDo();

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Initialized", _instanceName));
        }

        /// <summary>
        /// Get the Maximum Batch Size for the Extractor
        /// </summary>
        public int GetMaxBatchSize()
        {
            return Config.GetIntSetting(Setting.catalogwatcher_video_extractor_batch_size);
        }

        /// <summary>
        /// This function reads the LSN value from the CatalogWatcherStatus table in the npdb
        /// </summary>
        private LSN GetLastProcessedLSN()
        {
            LSN retVal = null;
            // Open a connection to the front door
            using (SqlClient sqlClient = new SqlClient(Interface.npdb))
            {
                sqlClient.AddParameter("@i_bucket_id", _bucketId);
                sqlClient.AddParameter("@vc_destination_name", c_destinationName);
                sqlClient.AddParameter("@vc_resource_name", c_resourceName);
                sqlClient.StoredProc = "dbo.p_catalog_watcher_get_last_lsn";

                using (SqlDataReader r = sqlClient.Execute())
                {
                    if (r.Read())
                    {
                        byte[] lsn = r.GetSqlBinary(r.GetOrdinal("lsn")).Value;
                        byte[] seq = r.GetSqlBinary(r.GetOrdinal("seq")).Value;
                        retVal = new LSN(lsn, seq);
                    }
                }
            }
            return retVal;
        }

        /// <summary>
        /// Return all the mediaId, lcids from the the ToDo table using the passed in connection to the Replica
        /// </summary>
        private void GetMediaLCIDsFromToDo()
        {
            _detectedIds = new List<MediaIdLcid>();

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            LSN lastProcessedLSN = GetLastProcessedLSN();
            _sqlReplicaClient.ClearParameters();
            _sqlReplicaClient.StoredProc = "dbo.CatalogWatcherToDoProductGet";
            _sqlReplicaClient.AddParameter("@lsn", lastProcessedLSN.Lsn);
            _sqlReplicaClient.AddParameter("@seq", lastProcessedLSN.Seq);
            using (SqlDataReader r = _sqlReplicaClient.Execute())
            {
                while (r.Read())
                {
                    Guid mediaId = r.GetGuid(r.GetOrdinal("mediaId"));
                    if (Math.Abs(mediaId.GetHashCode()) % _numBuckets == _bucketId)
                    {
                        int lcid = r.GetInt32(r.GetOrdinal("lcid"));
                        byte[] lsn = r.GetSqlBinary(r.GetOrdinal("lsn")).Value;
                        Debug.Assert(lsn.Length == 10);
                        byte[] seq = r.GetSqlBinary(r.GetOrdinal("seq")).Value;
                        Debug.Assert(seq.Length == 10);
                        MediaIdLcid mediaLcid = new MediaIdLcid(new LSN(lsn, seq), mediaId, lcid);
                        _detectedIds.Add(mediaLcid);
                    }
                }
            }
            DetectorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
            DetectorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
            DetectorCounters.Counters[_instanceName].DetectedIdsCount.IncrementBy(_detectedIds.Count);

            Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{1}|Detected {0} ids for document production", _detectedIds.Count, _instanceName));
        }
   
        /// <summary>
        /// This method generates documents for each mediaId, Lcid pair
        /// </summary>
        public IEnumerable<IWatcherDocument> GetNextBatchOfDocuments(int batchSize)
        {
            // Validation. Check that a valid batchSizeis passed in. Also verify that the
            // list '_detectedIds' is not null - a value of null indicates that this instance
            // has either not been initialized correctly or is in an invalid state caused by
            // some previous exception.
            if (batchSize <= 0)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT,
                    XEvent.Id.CATALOG_WATCHER_VIDEO_PRODUCER_ERROR,
                    String.Format("BatchSize for GetNextBatchOfDocuments must be greater than zero. Current value: {0}", batchSize));
            }
            if (_detectedIds == null)
            {
                throw new XRLException(HResult.XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_STATE,
                XEvent.Id.CATALOG_WATCHER_VIDEO_PRODUCER_ERROR,
                "GetNextBatchOfDocuments invoked either without initializing the class instance or after an exception has occurred");
            }

            List<IWatcherDocument> documents = new List<IWatcherDocument>();

            //If there are no IDs detected to generate documents for, no work to do.
            if (_detectedIds.Count != 0)
            {
                int actualBatchSize = 0;
                try
                {

                    // Execute the command against the same replica as that where the list of detected ids came
                    // from. This ensures that we will not hit a replica for the document information, where that
                    // replica is behind (e.g. replication has stopped). If this were to happen, we would publish
                    // old data, mark the LSN as completed and then not publish the new data.
                    VideoDocumentBuilder videoDocumentBuilder = (VideoDocumentBuilder)DocumentBuilderFactory.CreateDocumentBuilder("Video");
                    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                    for (int currentBatchCount = 0; 
                            ((currentBatchCount < batchSize) && (_overallPosition < _detectedIds.Count)); 
                            currentBatchCount++, _overallPosition++)
                    {
                        MediaIdLcid mediaIdLcid = _detectedIds[_overallPosition];
                        IWatcherDocument doc = videoDocumentBuilder.BuildDocument(_sqlReplicaClient, mediaIdLcid);
                        documents.Add(doc);
                    }

                    actualBatchSize = documents.Count;

                    // Bookkeeping
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTime.IncrementBy(timeElapsed.TimeElapsed);
                    ExtractorCounters.Counters[_instanceName].AverageExecutionTimeBase.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsTotal.Increment();
                    ExtractorCounters.Counters[_instanceName].AverageBatchSize.IncrementBy(actualBatchSize);
                    ExtractorCounters.Counters[_instanceName].AverageBatchSizeBase.Increment();
                }
                catch (Exception e)
                {
                    ExtractorCounters.Counters[_instanceName].CallsFailedPerSecond.Increment();
                    ExtractorCounters.Counters[_instanceName].CallsFailedTotal.Increment();

                    // An error has been encountered. We set the list of detected ids to be null
                    // to prevent any more processing happening.
                    _detectedIds = null;

                    Xom.Log(XomAreaName.catalogwatcherlog, String.Format("Exception {0}", e));

                    throw e;
                }

                Xom.Log(XomAreaName.catalogwatcherlog, String.Format("{0}|Processed {1} of total {2} ids.", _instanceName, actualBatchSize, _detectedIds.Count));
            }
            return documents;
        }

        /// <summary>
        /// Returns the max queue size for the documents queue for the media documents
        /// </summary>
        public int GetMaxQueueLength()
        {
            return Config.GetIntSetting(Setting.catalogwatcher_producer_consumer_video_max_queue_size);
        }

        /// <summary>
        /// Cleanup our resources
        /// </summary>
        public void Dispose()
        {
            if (_sqlReplicaClient != null)
            {
                _sqlReplicaClient.Dispose();
                _sqlReplicaClient = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\DeliveryFormatType.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{
    enum DeliveryFormatType
    {
        Streaming,
        Progressive
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\DataTypes.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;
using System.Xml;

namespace xonline.server.catalogwatcher
{
    class NonEmptyString : IType, IElement
    {
        public string Data;

        public NonEmptyString(string s)
        {
            this.Data = s;
        }

        public bool Validate()
        {
            return (!string.IsNullOrEmpty(Data) && Data.Length > 0);
        }

        public static explicit operator NonEmptyString(string s)
        {
            NonEmptyString nes = new NonEmptyString(s);

            return nes;
        }

        public override string ToString()
        {
            return this.Data;
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteString(this.Data);
        }
    }

    class PriceDisplayString : IType, IElement
    {
        private string data;

        public PriceDisplayString(string s)
        {
            this.data = s;
        }

        public bool Validate()
        {
            return (data != null && data.Length >= 1 && data.Length <= 60);
        }

        public void WriteToXml(XmlWriter writer)
        {
            if (this.data != null)
            {
                writer.WriteString(this.data);
            }
        }
    }


    class PositiveInt : IType
    {
        public UInt32 Data;

        public PositiveInt(int data)
        {
            if (data < 1)
                throw new Exception("Invalid init value for PositiveInt");

            this.Data = (UInt32) data;
        }

        public bool Validate()
        {
            return (Data >= 1);
        }

        public override string ToString()
        {
            return Data.ToString();
        }
    }

    class NullablePositiveInt : IType
    {
        private PositiveInt _data;

        private NullablePositiveInt()
        {
        }

        static public NullablePositiveInt Create(SqlDataReader dataReader, string columnName)
        {
            NullablePositiveInt ret = new NullablePositiveInt();
            int index = dataReader.GetOrdinal(columnName);
            if (!dataReader.IsDBNull(index))
            {
                int data = dataReader.GetInt32(index);
                if (data > 0)
                {
                    ret._data = new PositiveInt(data);
                }
            }

            return ret;
        }


        public bool Validate()
        {
            return ((null == _data) || _data.Validate());
        }

        public override string ToString()
        {
            if (_data == null)
                return null;
            return _data.ToString();
        }

        public void WriteToXml(XmlWriter writer, string elementName)
        {
            if (this._data == null)
                XmlUtility.WriteNullElement(writer, elementName);
            else
                XmlUtility.WriteElement(writer, elementName, this._data.ToString());
        }
    }

    class CombinationDateTime : IType
    {
        private DateTime datetime;

        public static CombinationDateTime Create(SqlDataReader dataReader, string columnName)
        {
            DateTime dt = DAL.GetDateTime(dataReader, columnName);
            return new CombinationDateTime(dt);
        }

        public CombinationDateTime(DateTime _datetime)
        {
            this.datetime = _datetime;
        }

        public DateTime DateTime
        {
            get
            {
                return datetime;
            }
        }

        public bool Validate()
        {
            return true;
        }

        public override string ToString()
        {
            return this.DateTime.ToString(XmlUtility.DateTimeFormat);
        }
    }


    class NullableCombinationDateTime
    {
        private CombinationDateTime cdt;

        public NullableCombinationDateTime(CombinationDateTime cdt)
        {
            this.cdt = cdt;
        }

        public string CombinationDateTime
        {
            get
            {
                if (null == cdt)
                    return string.Empty;
                else
                    return cdt.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Genre.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{
 
    class Genre:IElement
    {
        public string Name { get; private set; } // name of genre

        private Genre() { }

        static public Genre Create(SqlDataReader dataReader)
        {
            Genre g = new Genre();

            g.Name = DAL.GetString(dataReader, "Name");

            return g;
        }

        public void WriteToXml(XmlWriter writer)
        {
            XmlUtility.WriteElement(writer, "Genre", this.Name);
        }
    }

 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\File.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;
using System.Xml;

namespace xonline.server.catalogwatcher
{
   

    class File: IElement
    {
        public string Url { get; private set; }
        public long Size { get; private set; }

        private File() { }

        static public File Create(SqlDataReader dataReader)
        {
            File f = new File();
            f.Url = DAL.GetString(dataReader, "Url");
            f.Size = DAL.GetInt64(dataReader, "Size");

            return f;
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement("File");
            
            XmlUtility.WriteElement(writer, "Url", this.Url);
            XmlUtility.WriteElement(writer, "Size", this.Size.ToString());

            writer.WriteEndElement();
        }

        public DeliveryFormatType DeliveryFormat
        {
            get
            {
                string formatString = Url.ToUpper().EndsWith("WMV") ? "Progressive" : "Streaming";
                return (DeliveryFormatType) Enum.Parse(typeof(DeliveryFormatType), formatString);
            }
        }
    }

   

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Contributor.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{
    enum ContributorType
    {
        Actor,
        Director,
        Writer,
        Character
    }

    class Contributor: IElement
    {
        public ContributorType ContributorType { get; private set; }
        public NonEmptyString Name { get; private set; }
        public IList<Contributor> Characters { get; private set; }

        private Contributor() { }

        static public Contributor Create(SqlDataReader dataReader)
        {
            Contributor c = new Contributor();
            string type = DAL.GetString(dataReader, "Role");

            // special handling, for 
            if (type != "Actor" && type != "Director" && type != "Writer")
            {
                return null;
            }

            c.ContributorType = (ContributorType)Enum.Parse(typeof(ContributorType), type);
            c.Name = DAL.GetNonEmptyString(dataReader, "Name");

            if (c.ContributorType == ContributorType.Actor)
            {
                c.Characters = new List<Contributor>();

                string charName = DAL.GetString(dataReader, "Character");

                if (!string.IsNullOrEmpty(charName))
                {
                    Contributor character = new Contributor();
                    character.ContributorType = ContributorType.Character;
                    character.Name = new NonEmptyString(charName);

                    c.Characters.Add(character);
                }
            }

            return c;
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement(this.ContributorType.ToString());
            XmlUtility.WriteElement(writer, "Name", this.Name.ToString());
            if (this.ContributorType == ContributorType.Actor)
            {
                XmlUtility.WriteCollection<Contributor>(writer, "Characters", this.Characters, false);
            }
            writer.WriteEndElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Image.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{
    class Image: IElement
    {
        public string Url { get; private set; }
        public ImagePurposeType Purpose { get; private set; }

        private Product product;

        private Image() {}

        static public Image Create(Product product, SqlDataReader dataReader)
        {
            Image image = new Image();

            image.product = product;

            string imageTypeName = DAL.GetString(dataReader, "Purpose");
            image.Purpose = (ImagePurposeType)Enum.Parse(typeof(ImagePurposeType), imageTypeName);

            if (image.Purpose != ImagePurposeType.BoxArt)
            {
                image.Url = DAL.GetString(dataReader, "Url");
            }

            return image;
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement("Image");
            XmlUtility.WriteElement(writer, "ImagePurpose", this.Purpose.ToString());

            string url = (Purpose == ImagePurposeType.BoxArt) ? product.GetArtBoxImageUrl() : this.Url;
            XmlUtility.WriteElement(writer, "Url", url);

            writer.WriteEndElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\ContextId.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

namespace xonline.server.catalogwatcher
{
    class ContextId : IType
    {
        public ProductType ProductType { get; private set; }
        public String Locale { get; private set; }
        public Guid Id { get; private set; }

        public string LocaleMap { get; private set; }

        private ContextId() { }

        static public ContextId Create(Guid Id, ProductType type, string locale, string localeMap)
        {
            ContextId c = new ContextId();
            c.Id = Id;
            c.ProductType = type;
            c.Locale = locale;
            c.LocaleMap = localeMap;

            return c;
        }

        static public ContextId Create(Guid Id, ProductType type, string locale)
        {
            ContextId c = new ContextId();
            c.Id = Id;
            c.ProductType = type;
            c.Locale = locale;

            return c;
        }

        static public ContextId Create(SqlDataReader dataReader, string columnName, ProductType type, string locale)
        {
            Guid guid;
            if (!DAL.TryGetGuid(dataReader, columnName, out guid))
                return null;

            return ContextId.Create(guid, type, locale);
        }


        public bool Validate()
        {
            return true;
        }

        public override string ToString()
        {
            return string.Format("http://microsoft.com/{0}/{1}/{2}",
                                this.Locale,
                                ProductType.MovieTrailer == this.ProductType? ProductType.Movie.ToString(): this.ProductType.ToString(),
                                this.Id);
        }

        public string ToTypeString()
        {
            return string.Format("{0}",
                                ProductType.MovieTrailer == this.ProductType ? ProductType.Movie.ToString() : this.ProductType.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\DeviceType.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{
    enum DeviceType
    {
        Web,
        Xbox360,
        PC,
        Android,
        iOS
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\ImagePurposeType.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{

    enum ImagePurposeType
    {
        BoxArt,
        Thumbnail,
        Logo,
        Background
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\OfferType.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{
    enum OfferType
    {
        Unknown,
        Rent,
        PurchaseToOwn,
        Free,
        FreeWithAds,
        FreeWithSubscription,
        PayPerView
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Movie.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{
    class Movie : Product
    {
        CombinationDateTime OriginalPublicationDate;
        Studios Studios;

        NullablePositiveInt DurationInSeconds;


        protected override void FillMediaBaseInfo(SqlDataReader dataReader)
        {
            base.FillMediaBaseInfo(dataReader);

            this.OriginalPublicationDate = CombinationDateTime.Create(dataReader, "OriginalPublicationdate");
            this.DurationInSeconds = NullablePositiveInt.Create(dataReader, "Duration");
            this.Studios = Studios.Create(dataReader);
        }

        protected override void WriteTypeDataToXml(XmlWriter writer)
        {
            XmlUtility.WriteNonEmptyStringElement(writer, "ApplicationSpecificData", GetApplicationSpecificData());
            XmlUtility.WriteElement(writer, "OriginalPublicationDate", this.OriginalPublicationDate.ToString());
            if (null != Studios)
            {
                Studios.WriteToXml(writer);
            }
            this.DurationInSeconds.WriteToXml(writer, "DurationInSeconds");
            WriteContributors(writer);
        }

        public override string GetArtBoxImageUrl()
        {
            return string.Format(@"http://catalog.zune.net/v3.2/{0}/movie/{1}/primaryImage?width=800&height=800&resize=true",
                                this.ItemId.Locale,
                                this.ItemId.Id);
        }

    }

    class MovieTrailer : Movie
    {

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\ProductType.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{
    enum ProductType
    {
        All,

        TVEpisode,
        TVSeason,
        TVSeries,
        TVShow,
        Movie,
        MovieTrailer
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Instance.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{
    class Instance:IElement
    {
        public Guid MediaInstanceId;

        public DeviceType Device;
        public File File;
        public IEnumerable<Availability> Availabilities;
        public ResolutionFormatType ResolutionFormat;
        public DeliveryFormatType DeliveryFormat
        {
            get
            {
                return this.File.DeliveryFormat;
            }
        }
        public string PrimaryAudioLanguage;
        public bool? ClosedCaptioning;
        //IEnumerable<NonEmptyString> SubtitleLanguages;
        VideoInstanceType VideoInstanceType;

        private Instance()
        {
        }

        static public Instance Create(SqlDataReader dataReader, ProductType type)
        {
            Instance instance = new Instance();

            instance.MediaInstanceId = DAL.GetGuid(dataReader, "MediaInstanceId");
            instance.SetFile(dataReader);
            instance.Device = DeviceType.Xbox360;
            instance.SetResolutionFormat(dataReader);
            
            instance.PrimaryAudioLanguage = DAL.GetString(dataReader, "PrimaryAudioLanguage");
            instance.ClosedCaptioning = DAL.GetNullableBool(dataReader, "ClosedCaptioning");

            int videoInstanceTypeId = 0; // VideoInstanceType { Full = 0, Trailer = 1, ...}

            if (DAL.TryGetInt32(dataReader, "videoInstanceType", out videoInstanceTypeId))
            {
                instance.VideoInstanceType = (VideoInstanceType)videoInstanceTypeId;
            }
            else
            {
                // db side has not update yet, previous code
                instance.VideoInstanceType =
                    ((ProductType.MovieTrailer == type) ? VideoInstanceType.Trailer : VideoInstanceType.Full); 
            }

            return instance;
        }

        static public Instance Create(ProductType type)
        {
            if (ProductType.TVSeries == type)
                return new Instance();
            return null;
        }

        public void SetFile(SqlDataReader dataReader)
        {
            this.File = File.Create(dataReader);
        }

        public void SetResolutionFormat(SqlDataReader dataReader)
        {
            string resolutionFormatName = DAL.GetString(dataReader, "ResolutionFormat");
            this.ResolutionFormat = (ResolutionFormatType) Enum.Parse(typeof(ResolutionFormatType), resolutionFormatName);
        }

        public void AddAvailability(SqlDataReader dataReader)
        {
            if (null == this.Availabilities)
            {
                this.Availabilities = new List<Availability>();
            }

            ((List<Availability>) this.Availabilities).Add(Availability.Create(dataReader));
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement("VideoInstance");
            XmlUtility.WriteElement(writer, "Device", this.Device.ToString());

            writer.WriteStartElement("Files");

            XmlUtility.WriteToXmlSafe<File>(writer, this.File);

            writer.WriteEndElement();

            XmlUtility.WriteCollection<Availability>(writer, "Availabilities", this.Availabilities, true);

            XmlUtility.WriteElement(writer, "ResolutionFormat", this.ResolutionFormat.ToString());
            XmlUtility.WriteElement(writer, "DeliveryFormat", this.DeliveryFormat.ToString());
            XmlUtility.WriteNullableElement(writer, "PrimaryAudioLanguage", this.PrimaryAudioLanguage);

            XmlUtility.WriteNullableElement(writer, "ClosedCaptioning", this.ClosedCaptioning.ToString());


            XmlUtility.WriteElement(writer, "VideoInstanceType", this.VideoInstanceType.ToString());

            writer.WriteEndElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\ParentControl.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{
    enum ParentalControlType
    {
        NotRated,           // Should be used when no parental control is known for the content, however, it is known that the asset is safe to be included in results.
                            // The asset will be inlcuded in search/browse results.

        Unrated,            // Should be used when no parental control is known for the content and it is NOT known if the asset is safe to be included in results.
                            // The asset will be blocked from search/browse results if, parental controls are set to on and 'show unrated' is set to false.

        HasGuidance,        // Should be used when the partner does not age rate the content, but has assessed against the guidance content labeling system. If this option
                            // is used, it indicates that the asset metadata is safe to be included in search results. The flag is set to false to signal 
                            // that there is no guidance advice attached to the content, but it is the responsibility of the application to honor this.

        Specified           // When the value is known, it should be specified. It consists of:
                            // System, Rating, Desciptor
    }

    class ParentalControl:IElement
    {
        private ParentalControlType type;

        public string System { get; private set; }
        public NonEmptyString Rating { get; private set; }
        public List<NonEmptyString> Descriptors { get; private set; }

        private ParentalControl() { }

        static public ParentalControl CreateDefault()
        {
            ParentalControl pc = new ParentalControl();
            pc.type = ParentalControlType.Unrated;

            return pc;
        }

        static public ParentalControl Create(SqlDataReader dataReader)
        {
            ParentalControl pc = new ParentalControl();

            pc.type = ParentalControlType.Specified;
            pc.System = DAL.GetString(dataReader, "System");
            pc.Rating = DAL.GetNonEmptyString(dataReader, "Rating");
            string str = DAL.GetString(dataReader, "Descriptor");

            if (!string.IsNullOrEmpty(str))
            {
                pc.Descriptors = new List<NonEmptyString>();
                pc.Descriptors.Add(new NonEmptyString(str));
            }

            return pc;
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement("ParentalControl");

            switch (this.type)
            {
                case ParentalControlType.Specified:
                    XmlUtility.WriteElement(writer, "System", this.System);
                    XmlUtility.WriteElement(writer, "Rating", this.Rating.ToString());

                    if (this.Descriptors != null && this.Descriptors.Count > 0)
                    {
                        writer.WriteStartElement("Descriptors");
                        foreach (NonEmptyString str in this.Descriptors)
                        {
                            writer.WriteStartElement("Descriptor");
                            str.WriteToXml(writer);
                            writer.WriteEndElement();
                        }
                        writer.WriteEndElement();
                    }
                    break;
                case ParentalControlType.Unrated:
                    XmlUtility.WriteNullElement(writer, this.type.ToString());
                    break;
                default:
                    throw new Exception("Unsupported ParentalControlType");
            }


            writer.WriteEndElement();
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Product.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;
using System.Data.SqlTypes;

using System.Xml;

using xonline.common.config;

namespace xonline.server.catalogwatcher
{

    abstract class Product
    {
        static private XmlWriterSettings XmlSettings = new XmlWriterSettings();

        static Product()
        {
            XmlSettings.OmitXmlDeclaration = true;
            XmlSettings.Encoding = Encoding.UTF8; // TODO: read encoding from configuration.
        }

        // private NonEmptyString Provider;    // place holder

        protected ContextId ItemId;

        NonEmptyString Title;
        //NonEmptyString TitlePronunciation;
        NonEmptyString SortTitle;
        NonEmptyString Description;
        NonEmptyString ShortDescription;

        //IEnumerable<NonEmptyString> AlternateTitles;
        // NonEmptyString OriginalPublicationRegion; // Place holder

        //IEnumerable<NonEmptyString> AlternateIds;

        //IEnumerable<string> Keywords;
        bool IsUserGenerated = false;
        IEnumerable<Image> Images;
        DateTime LastModifiedDate;
        
        IEnumerable<Genre> Genres;
        ParentalControl ParentControl;
        protected IEnumerable<Instance> Instances { get; set; }
        // string PublicWebUri; // place holder


        IEnumerable<Contributor> Directors
        {
            get
            {
                foreach (Contributor c in Contributors)
                {
                    if (c.ContributorType == ContributorType.Director)
                    {
                        yield return c;
                    }
                }
            }
        }

        IEnumerable<Contributor> Actors
        {
            get
            {
                foreach (Contributor c in Contributors)
                {
                    if (c.ContributorType == ContributorType.Actor)
                    {
                        yield return c;
                    }
                }
            }
        }

        IEnumerable<Contributor> Writers
        {
            get
            {
                foreach (Contributor c in Contributors)
                {
                    if (c.ContributorType == ContributorType.Writer)
                    {
                        yield return c;
                    }
                }
            }
        }

        // private data member
        IEnumerable<Contributor> Contributors;


        static public Product CreateProduct(SqlDataReader dataReader)
        {
            string productTypeName = DAL.GetString(dataReader, "ProductType");
            ProductType productType = (ProductType) Enum.Parse(typeof(ProductType), productTypeName);

            Product product;

            switch (productType)
            {
                case ProductType.Movie:
                    product = new Movie();
                    break;
                case ProductType.MovieTrailer:
                    product = new MovieTrailer();
                    break;
                case ProductType.TVEpisode:
                    product = new TVEpisode();
                    break;
                case ProductType.TVSeason:
                    product = new TVSeason();
                    break;
                case ProductType.TVSeries:
                    product = new TVSeries();
                    break;

                default:
                    throw new Exception("Unsupported ProductType!");
            }

            product.ItemId = ContextId.Create(
                                        DAL.GetGuid(dataReader, "Id"),
                                        productType,
                                        DAL.GetString(dataReader, "Locale"),
                                        DAL.GetString(dataReader, "LocaleMap"));
            return product;
        }


        protected virtual void FillMediaBaseInfo(SqlDataReader dataReader)
        {
            if (dataReader.Read())
            {

                this.Title = DAL.GetNonEmptyString(dataReader, "Title");
                this.SortTitle = DAL.GetNonEmptyString(dataReader, "SortTitle");
                this.Description = DAL.GetNonEmptyString(dataReader, "Description");
                this.ShortDescription = DAL.GetNonEmptyString(dataReader, "ShortDescription");

                this.LastModifiedDate = DAL.GetDateTime(dataReader, "LastModifiedDate");
            }
        }


        protected virtual IEnumerable<Instance> FillMediaInstanceInfo(SqlDataReader dataReader)
        {
            List<Instance> instances = new List<Instance>();

            while (dataReader.Read())
            {
                Instance instance = Instance.Create(dataReader, this.ItemId.ProductType);

                instances.Add(instance);
            }

            return instances;
        }

        protected virtual void FillMediaOfferInfo(SqlDataReader dataReader)
        {
            while (dataReader.Read())
            {
                Guid mediaInstanceId = DAL.GetGuid(dataReader, "MediaInstanceId");

                foreach (Instance instance in this.Instances)
                {
                    if (mediaInstanceId == instance.MediaInstanceId)
                    {
                        instance.AddAvailability(dataReader);
                    }
                }
            }
        }

        protected virtual IEnumerable<Contributor> FillMediaContributorInfo(SqlDataReader dataReader)
        {
            List<Contributor> contributors = new List<Contributor>();

            while (dataReader.Read())
            {
                Contributor contributor = Contributor.Create(dataReader);
                if (contributor != null) // some of ContributorType are not support, ignore.
                {
                    contributors.Add(contributor);
                }
            }

            return contributors;
        }

        protected virtual IEnumerable<Image> FillMediaImageInfo(SqlDataReader dataReader)
        {
            List<Image> images = new List<Image>();

            while (dataReader.Read())
            {
                images.Add(Image.Create(this, dataReader));
            }

            return images;
        }

        protected virtual IEnumerable<Genre> FillMediaGenreInfo(SqlDataReader dataReader)
        {
            List<Genre> genres = new List<Genre>();

            while (dataReader.Read())
            {
                genres.Add(Genre.Create(dataReader));
            }

            return genres;
        }

        protected virtual ParentalControl FillMediaRatingInfo(SqlDataReader dataReader)
        {
            if (dataReader.Read())
            {
                return ParentalControl.Create(dataReader);
            }
            return ParentalControl.CreateDefault();
        }

        public virtual void FillData(SqlDataReader dataReader)
        {
            // MediaBase
            dataReader.NextResult();
            FillMediaBaseInfo(dataReader);

            // MediaInstance
            dataReader.NextResult();
            this.Instances = FillMediaInstanceInfo(dataReader);

            // MediaOffer
            dataReader.NextResult();
            FillMediaOfferInfo(dataReader);

            // Contributor
            dataReader.NextResult();
            this.Contributors = FillMediaContributorInfo(dataReader);

            // Image
            dataReader.NextResult();
            this.Images = FillMediaImageInfo(dataReader);

            // Genre
            dataReader.NextResult();
            this.Genres = FillMediaGenreInfo(dataReader);

            // Rating
            dataReader.NextResult();
            this.ParentControl = FillMediaRatingInfo(dataReader);
        }

        protected abstract void WriteTypeDataToXml(XmlWriter writer);
        public abstract string GetArtBoxImageUrl();

        private void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement(this.ItemId.ToTypeString());

            string provider = Config.GetSetting(Setting.catalogwatcher_video_document_builder_firstpartyprovider);

            XmlUtility.WriteElement(writer, "Provider", provider);

            XmlUtility.WriteElement(writer, "ItemId", this.ItemId.ToString());

            XmlUtility.WriteNonEmptyStringElement(writer, "Title", this.Title.ToString());
            XmlUtility.WriteNonEmptyStringElement(writer, "SortTitle", this.SortTitle.ToString());
            XmlUtility.WriteNonEmptyStringElement(writer, "Description", this.Description.ToString());
            XmlUtility.WriteNonEmptyStringElement(writer, "ShortDescription", this.ShortDescription.ToString());

            XmlUtility.WriteNullElement(writer, "AlternateTitles");

            XmlUtility.WriteNullElement(writer, "AlternateIds");
            XmlUtility.WriteNullElement(writer, "Keywords");

            XmlUtility.WriteElement(writer, "IsUserGenerated", this.IsUserGenerated.ToString().ToLower());

            // write image data
            XmlUtility.WriteCollection<Image>(writer, "Images", this.Images, false);

            XmlUtility.WriteElement(writer, "LastModifiedDate", this.LastModifiedDate.ToString(XmlUtility.DateTimeFormat));

            XmlUtility.WriteCollection<Genre>(writer, "Genres", this.Genres, false);

            XmlUtility.WriteToXmlSafe<ParentalControl>(writer, this.ParentControl);

            XmlUtility.WriteCollection<Instance>(writer, "Instances", this.Instances, false);

            WriteTypeDataToXml(writer);

            writer.WriteEndElement();
        }

        protected void WriteContributors(XmlWriter writer)
        {
            XmlUtility.WriteCollection<Contributor>(writer, "Directors", this.Directors, false);
            XmlUtility.WriteCollection<Contributor>(writer, "Actors", this.Actors, false);
            XmlUtility.WriteCollection<Contributor>(writer, "Writers", this.Writers, false);
        }

        public string GetXmlString()
        {
            StringBuilder sb = new StringBuilder();
            using (XmlWriter writer = XmlWriter.Create(sb, XmlSettings))
            {
                this.WriteToXml(writer);
            }

            return sb.ToString();
        }

        protected virtual string GetApplicationSpecificData()
        {
            return string.Format("Details?ContentType={0}&ContentId={1}",
                                this.ItemId.ProductType.ToString(),
                                this.ItemId.Id.ToString());
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\ResolutionFormatType.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{

    enum ResolutionFormatType
    {
        SD,
        HD
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\TVEpisode.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{

    class TVEpisode : Product
    {
        CombinationDateTime OriginalPublicationDate;
        int EpisodeNumber;
        NullablePositiveInt DurationInSeconds;
        string Network;
        Studios Studios;

        ContextId SeriesId;
        ContextId SeasonId;

        protected override void FillMediaBaseInfo(SqlDataReader dataReader)
        {
            base.FillMediaBaseInfo(dataReader);

            this.OriginalPublicationDate = CombinationDateTime.Create(dataReader, "OriginalPublicationdate");
            this.Studios = Studios.Create(dataReader);

            this.DurationInSeconds = NullablePositiveInt.Create(dataReader, "Duration");

            this.EpisodeNumber = DAL.GetInt32(dataReader, "EpisodeNumber");
            this.Network = DAL.GetString(dataReader, "Network");

            this.SeriesId = ContextId.Create(dataReader, "SeriesId", ProductType.TVSeries, this.ItemId.Locale);
            this.SeasonId = ContextId.Create(dataReader, "SeasonId", ProductType.TVSeason, this.ItemId.Locale);

        }

        protected override void WriteTypeDataToXml(XmlWriter writer)
        {
            XmlUtility.WriteNonEmptyStringElement(writer, "ApplicationSpecificData", GetApplicationSpecificData());
            XmlUtility.WriteElement(writer, "OriginalPublicationDate", this.OriginalPublicationDate.ToString());
            XmlUtility.WriteElement(writer, "EpisodeNumber", this.EpisodeNumber.ToString());
            this.DurationInSeconds.WriteToXml(writer, "DurationInSeconds");
            if (null != this.Network)
            {
                XmlUtility.WriteElement(writer, "Network", this.Network);
            }

            if (null != this.Studios)
            {
                this.Studios.WriteToXml(writer);
            }

            if (null != this.SeriesId)
            {
                XmlUtility.WriteElement(writer, "SeriesId", this.SeriesId.ToString());
            }

            if (null != this.SeasonId)
            {
                XmlUtility.WriteElement(writer, "SeasonId", this.SeasonId.ToString());
            }

            WriteContributors(writer);
        }

        public override string GetArtBoxImageUrl()
        {
            return string.Format(@"http://catalog.zune.net/v3.2/{0}/tv/episode/{1}/primaryImage?width=480&height=480&resize=true",
                                this.ItemId.Locale,
                                this.ItemId.Id);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\TVSeason.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;
using System.Xml;

namespace xonline.server.catalogwatcher
{
    class TVSeason : Product
    {
        CombinationDateTime OriginalPublicationDate;
        int SeasonNumber;
        ContextId SeriesId;
        string Network;
        Studios Studios;

        protected override void FillMediaBaseInfo(SqlDataReader dataReader)
        {
            base.FillMediaBaseInfo(dataReader);

            this.OriginalPublicationDate = CombinationDateTime.Create(dataReader, "OriginalPublicationdate");
            this.SeasonNumber = DAL.GetInt32(dataReader, "SeasonNumber");
            this.SeriesId = ContextId.Create(dataReader, "SeriesId", ProductType.TVSeries, this.ItemId.Locale);
            this.Network = DAL.GetString(dataReader, "Network");
            this.Studios = Studios.Create(dataReader);
        }



        protected override void WriteTypeDataToXml(XmlWriter writer)
        {
            if (null != this.OriginalPublicationDate)
            {
                XmlUtility.WriteElement(writer, "OriginalPublicationDate", this.OriginalPublicationDate.ToString());
            }
            XmlUtility.WriteElement(writer, "SeasonNumber", this.SeasonNumber.ToString());
            XmlUtility.WriteElement(writer, "SeriesId", this.SeriesId.ToString());
            if (null != this.Network)
            {
                XmlUtility.WriteElement(writer, "Network", this.Network);
            }

            if (null != this.Studios)
            {
                this.Studios.WriteToXml(writer);
            }
        }

        protected override string GetApplicationSpecificData()
        {
            return string.Format("Details?ContentType={0}&ContentId={1}&ContentId2={2}",
                                this.ItemId.ProductType.ToString(),
                                this.ItemId.Id.ToString(),
                                this.SeasonNumber);
        }

        public override string GetArtBoxImageUrl()
        {
            return string.Format(@"http://catalog.zune.net/v3.2/{0}/tv/series/{1}/seasons/{2}/primaryImage?width=480&height=480&resize=true",
                                this.ItemId.Locale,
                                this.SeriesId.Id,
                                this.SeasonNumber);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\TVSeries.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;

using System.Xml;

namespace xonline.server.catalogwatcher
{

    class TVSeries : Product
    {
        CombinationDateTime OriginalPublicationDate;
        string Network;
        Studios Studios;


        protected override void FillMediaBaseInfo(SqlDataReader dataReader)
        {
            base.FillMediaBaseInfo(dataReader);

            this.OriginalPublicationDate = CombinationDateTime.Create(dataReader, "OriginalPublicationdate");
            this.Network = DAL.GetString(dataReader, "Network");
            this.Studios = Studios.Create(dataReader);
        }


        protected override void WriteTypeDataToXml(XmlWriter writer)
        {
            if (null != this.OriginalPublicationDate)
            {
                XmlUtility.WriteElement(writer, "OriginalPublicationDate", this.OriginalPublicationDate.ToString());
            }

            if (null != this.Network)
            {
                XmlUtility.WriteElement(writer, "Network", this.Network);
            }

            if (null != this.Studios)
            {
                this.Studios.WriteToXml(writer);
            }
        }

        public override string GetArtBoxImageUrl()
        {
            return string.Format(@"http://catalog.zune.net/v3.2/{0}/tv/series/{1}/primaryImage?width=480&height=480&resize=true",
                                this.ItemId.Locale,
                                this.ItemId.Id);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\VideoInstanceType.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.catalogwatcher
{
    enum VideoInstanceType
    {
        Full,
        Trailer,
        Highlights
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\DataModel\Studios.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Data.SqlClient;

namespace xonline.server.catalogwatcher
{
    class Studios:IElement
    {
        private NonEmptyString Studio;

        private Studios()
        {
        }

        public static Studios Create(SqlDataReader dataReader)
        {
            Studios s = new Studios();

            string studioName = DAL.GetString(dataReader, "Studio");

            if (!string.IsNullOrEmpty(studioName))
            {
                s.Studio = new NonEmptyString(studioName);
                return s;
            }

            return null;
        }

        public void WriteToXml(XmlWriter writer)
        {
            writer.WriteStartElement("Studios");
            writer.WriteStartElement("Studio");
            Studio.WriteToXml(writer);
            writer.WriteEndElement();
            writer.WriteEndElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\CatalogWatcher\src\Video\Helpers\DAL.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Data.SqlClient;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.sql.sqlclient;

using System.Globalization;

namespace xonline.server.catalogwatcher
{
    // Data Accesss Layer
    static class DAL
    {
        static public Product GetProduct(SqlClient sqlClient, MediaIdLcid mediaItem)
        {
            sqlClient.ClearParameters();
            using (SqlCommand command = sqlClient.Command)
            {
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.CommandText = "dbo.York_GetMediaInfo";
                // TODO: change to this setting
                // catalogwatcher_video_extractor_timeout_in_secs
                command.CommandTimeout = Config.GetIntSetting(Setting.catalogwatcher_extractor_timeout_in_secs);

                command.Parameters.Add(new SqlParameter("@mediaId", mediaItem.MediaId));
                command.Parameters.Add(new SqlParameter("@lcid", mediaItem.Lcid));

                using (SqlDataReader dataReader = command.ExecuteReader())
                {
                    // the first rowset has one row: ProductType
                    dataReader.Read();
                        
                    Product product = Product.CreateProduct(dataReader);
                    product.FillData(dataReader);

                    return product;
                }
            }
        }

        static public string GetString(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            if (dataReader.IsDBNull(index))
                return null;

            return dataReader.GetString(index);
        }

        static public NonEmptyString GetNonEmptyString(SqlDataReader dataReader, string columnName)
        {
            string data = GetString(dataReader, columnName);
            if (data == null)
            {
                data = string.Empty;
            }

            return new NonEmptyString(data);
        }

        static public bool GetBool(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            return dataReader.GetBoolean(index);
        }

        static public bool? GetNullableBool(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            if (dataReader.IsDBNull(index))
                return null;

            return dataReader.GetBoolean(index);
        }

        static public DateTime GetDateTime(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            return dataReader.GetDateTime(index);
        }

        static public DateTime? GetNullableDateTime(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            if (dataReader.IsDBNull(index))
                return null;

            return dataReader.GetDateTime(index);
        }

        static public long GetInt64(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            return (long) dataReader.GetInt64(index);
        }

        static public int GetInt32(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            if (dataReader.IsDBNull(index))
                return 0;

            return dataReader.GetInt32(index);
        }

        static public bool ResultsetHasColumn(SqlDataReader dataReader, string columnName)
        {
            // this function check if a column exist or not. 
            // situation happens when db and binary code release out of sync.
            // in most of cases, there should a new column added in the end
            // so, we do backward search
            for (int i = dataReader.FieldCount - 1; i >= 0; i--)
            {
                if (0 == string.Compare(columnName, dataReader.GetName(i), true /* ignoreCase */))
                {
                    return true;
                }
            }

            return false;
        }

        static public bool TryGetInt32(SqlDataReader dataReader, string columnName, out int theValue)
        {
            if (!ResultsetHasColumn(dataReader, columnName))
            {
                theValue = 0;
                return false;
            }

            int index = dataReader.GetOrdinal(columnName);
            if (dataReader.IsDBNull(index))
            {
                theValue = 0;
                return false;
            }

            theValue = dataReader.GetInt32(index);

            return true;
        }


        static public Guid GetGuid(SqlDataReader dataReader, string columnName)
        {
            int index = dataReader.GetOrdinal(columnName);
            return dataReader.GetGuid(index);
        }

        static public bool TryGetGuid(SqlDataReader dataReader, string columnName, out Guid guid)
        {
            int index = dataReader.GetOrdinal(columnName);
            if (dataReader.IsDBNull(index))
            {
                guid = Guid.Empty;
                return false;
            }

            guid = dataReader.GetGuid(index);

            return true;
        }

        static public bool TryGetGuid(SqlDataReader dataReader, int ordinalIndex, out Guid guid)
        {
            if (ordinalIndex < 0
                || dataReader.IsDBNull(ordinalIndex))
            {
                guid = Guid.Empty;
                return false;
            }

            guid = dataReader.GetGuid(ordinalIndex);
            return true;
        }

        static public string GetNonNullString(SqlDataReader dataReader, int ordinalIndex)
        {
            if (ordinalIndex < 0
                || dataReader.IsDBNull(ordinalIndex))
            {
                return string.Empty;
            }

            return dataReader.GetString(ordinalIndex);
        }
