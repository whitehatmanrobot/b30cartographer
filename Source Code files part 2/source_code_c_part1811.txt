xMenu, 
                        MF_STRING | MF_BYPOSITION, 
                        idCmdFirst + IDM_ENCRYPT + 1, 
                        szDecryptMsg))  
                    {
                        hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_DECRYPT + 1));
                    }
                }
            }
        }
        else if (idCmdLast - idCmdFirst >= 2)
        {
            LoadString(HINST_THISDLL, IDS_ECM_ENCRYPT, szEncryptMsg, ARRAYSIZE(szDecryptMsg));
            LoadString(HINST_THISDLL, IDS_ECM_DECRYPT, szDecryptMsg, ARRAYSIZE(szDecryptMsg));

            // If more than one item is selected, display both enc and dec
            if (InsertMenu(hmenu, 
                indexMenu, 
                MF_STRING | MF_BYPOSITION, 
                idCmdFirst + IDM_ENCRYPT, 
                szEncryptMsg))
            {
                if (InsertMenu(hmenu, 
                    indexMenu + 1, 
                    MF_STRING | MF_BYPOSITION, 
                    idCmdFirst + IDM_DECRYPT, 
                    szDecryptMsg))  
                {
                    hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_DECRYPT + 1));
                }
                else
                {
                    // If you can't add both, add neither
                    RemoveMenu(hmenu, indexMenu, MF_BYPOSITION);
                }
            }
        }
    }

    return hr;
}

const ICIVERBTOIDMAP c_IDMap[] =
{
    { L"encrypt", "encrypt", IDM_ENCRYPT, IDM_ENCRYPT, },
    { L"decrypt", "decrypt", IDM_DECRYPT, IDM_DECRYPT, },
};

STDMETHODIMP CEncryptionContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT uID;
    HRESULT hr = E_FAIL;
    if (_fEncryptAllowed)
    {
        hr = SHMapICIVerbToCmdID(pici, c_IDMap, ARRAYSIZE(c_IDMap), &uID);
        if (SUCCEEDED(hr))
        {
            switch (uID)
            {
            case IDM_ENCRYPT:
            case IDM_DECRYPT:
                _fEncrypt = (IDM_ENCRYPT == uID);
                break;

            default:
                ASSERTMSG(0, "Should never get commands we didn't put on the menu...");
                break;
            }

            _hwnd = pici->hwnd;  // The handle to the explorer window that called us.
           
            ASSERT(NULL == _fpsp.pfci->hida);

            hr = DataObj_CopyHIDA(_pdtobj, &_fpsp.pfci->hida);
            if (SUCCEEDED(hr))
            {
                AddRef();   // Give our background thread a ref

                // Start the new thread here
                if (SHCreateThread(EncryptThreadProc, this, CTF_COINIT | CTF_FREELIBANDEXIT, NULL))
                {
                    hr = S_OK;
                }
                else
                {
                    Release();  // thread create failed
                }
            }
        }
    }

    // If we succeeded or not, we give up our data here
    ATOMICRELEASE(_pdtobj);
    return hr;
}


STDMETHODIMP CEncryptionContextMenu::GetCommandString(UINT_PTR idCommand, UINT uFlags,
                                               UINT *pRes, LPSTR pszName, UINT uMaxNameLen)
{
    HRESULT  hr = E_INVALIDARG;

    // Note that because we can be specifically asked for 
    // UNICODE or ansi strings, we have to be ready to load all strings in
    // either version.

    if (idCommand == IDM_ENCRYPT ||
        idCommand == IDM_DECRYPT)
    {
        switch(uFlags)
        {
        case GCS_HELPTEXTA:
            if (idCommand == IDM_ENCRYPT)
            {
                LoadStringA(HINST_THISDLL, IDS_ECM_ENCRYPT_HELP, pszName, uMaxNameLen);
            }
            else
            {
                LoadStringA(HINST_THISDLL, IDS_ECM_DECRYPT_HELP, pszName, uMaxNameLen);
            }

            hr = S_OK;
            break; 
            
        case GCS_HELPTEXTW: 
            if (idCommand == IDM_ENCRYPT)
            {
                LoadStringW(HINST_THISDLL, IDS_ECM_ENCRYPT_HELP, (LPWSTR)pszName, uMaxNameLen);
            }
            else
            {
                LoadStringW(HINST_THISDLL, IDS_ECM_DECRYPT_HELP, (LPWSTR)pszName, uMaxNameLen);
            }

            hr = S_OK;
            break; 
            
        case GCS_VERBA:
        case GCS_VERBW:
            hr = SHMapCmdIDToVerb(idCommand, c_IDMap, ARRAYSIZE(c_IDMap), pszName, uMaxNameLen, GCS_VERBW == uFlags);
            break; 
            
        default:
            hr = S_OK;
            break; 
        }
    }
    return hr;

}

STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;
    CEncryptionContextMenu *pdocp = new CEncryptionContextMenu();
    if (pdocp)
    {
        hr = pdocp->Init_FolderContentsInfo();
        if (SUCCEEDED(hr))
        {
            hr = pdocp->QueryInterface(riid, ppv);
        }
        pdocp->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Multithread code

// Proc for thread that does the encryption and manages the progress dialong.
// The passed parameter is a ptr hwnd to be made modal for the context menu
DWORD CEncryptionContextMenu::_Encrypt(void)
{
    // Transfer ownership in case someone reenters our thread creator
    // Init the property sheet
    BOOL fSuccess = _InitPrsht(&_fpsp);    
    if (fSuccess)
    {
        // Set encryption opts, turn off compression
        if (_fEncrypt)
        {
            _fpsp.asCurrent.fCompress = FALSE;
            _fpsp.asCurrent.fEncrypt = TRUE;    
        }
        else
        {
            _fpsp.asCurrent.fEncrypt = FALSE;
        }
        
        // See if the user wants to do this recursive-style
        if (_fpsp.fIsDirectory)
        {
            // check to see if the user wants to apply the attribs recursively or not
            fSuccess = (int)DialogBoxParam(HINST_THISDLL, 
                MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                _hwnd, RecursivePromptDlgProc, (LPARAM)&_fpsp);
        }
        
        // Apply encryption, remember to turn off compression
        if (fSuccess)
        {
            if (_fpsp.pfci->fMultipleFiles || _fpsp.fRecursive)
            {
                ApplyMultipleFileAttributes(&_fpsp);
            }
            else
            {
                ApplySingleFileAttributesNoDlg(&_fpsp, _hwnd);
            }
        }
    }
    // As far as I can tell, nothing in fpsp must be freed
    // But, we give up the storage medium here
    Release();      // Release our ref
    return fSuccess;  // Must give a ret value
}

// Helper to init the passed prsht
BOOL CEncryptionContextMenu::_InitPrsht(FILEPROPSHEETPAGE * pfpsp)
{
    // Init the propsht properly 
    BOOL fSuccess = S_OK == InitCommonPrsht(pfpsp);
    if (fSuccess)
    {        
        if (_uFileCount == 1)
        {
            fSuccess = InitSinglePrshtNoDlg(pfpsp);
        }
        else if (_uFileCount > 1)
        {
            fSuccess = InitMultiplePrshtNoDlg(pfpsp);
        }
    }
    return fSuccess;
}

//
// Descriptions:
//   This function fills fields of the multiple object property sheet,
//   without getting the current state from the dialog.
//
BOOL InitMultiplePrshtNoDlg(FILEPROPSHEETPAGE* pfpsp)
{
    SHFILEINFO sfi;
    TCHAR szBuffer[MAX_PATH+1];
    TCHAR szType[MAX_PATH] = {0};
    TCHAR szDirPath[MAX_PATH] = {0};
    int iItem;
    BOOL fMultipleType = FALSE;
    BOOL fSameLocation = TRUE;
    DWORD dwFlagsOR = 0;                // start all clear
    DWORD dwFlagsAND = (DWORD)-1;       // start all set
    DWORD dwVolumeFlagsAND = (DWORD)-1; // start all set

    // For all the selected files compare their types and get their attribs
    for (iItem = 0; HIDA_FillFindData(pfpsp->pfci->hida, iItem, szBuffer, NULL, FALSE); iItem++)
    {
        DWORD dwFileAttributes = GetFileAttributes(szBuffer);

        dwFlagsAND &= dwFileAttributes;
        dwFlagsOR  |= dwFileAttributes;

        // process types only if we haven't already found that there are several types
        if (!fMultipleType)
        {
            SHGetFileInfo((LPTSTR)IDA_GetIDListPtr((LPIDA)GlobalLock(pfpsp->pfci->hida), iItem), 0,
                &sfi, sizeof(sfi), SHGFI_PIDL|SHGFI_TYPENAME);

            if (szType[0] == TEXT('\0'))
                lstrcpy(szType, sfi.szTypeName);
            else
                fMultipleType = lstrcmp(szType, sfi.szTypeName) != 0;
        }

        dwVolumeFlagsAND &= GetVolumeFlags(szBuffer, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys));
        // check to see if the files are in the same location
        if (fSameLocation)
        {
            PathRemoveFileSpec(szBuffer);

            if (szDirPath[0] == TEXT('\0'))
                StrCpyN(szDirPath, szBuffer, ARRAYSIZE(szDirPath));
            else
                fSameLocation = (lstrcmpi(szDirPath, szBuffer) == 0);
        }
    }

    if ((dwVolumeFlagsAND & FS_FILE_ENCRYPTION) && !SHRestricted(REST_NOENCRYPTION))
    {
        // all the files are on volumes that support encryption (eg NTFS)
        pfpsp->fIsEncryptionAvailable = TRUE;
    }
    
    if (dwVolumeFlagsAND & FS_FILE_COMPRESSION)
    {
        pfpsp->pfci->fIsCompressionAvailable = TRUE;
    }

    //
    // HACKHACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we 
    // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
    // appeared first on NTFS5 volumes, at the same time sparse file support
    // was implemented.
    //
    if (dwVolumeFlagsAND & FILE_SUPPORTS_SPARSE_FILES)
    {
        // yup, we are on NTFS5 or greater
        pfpsp->fIsIndexAvailable = TRUE;
    }

    // if any of the files was a directory, then we set this flag
    if (dwFlagsOR & FILE_ATTRIBUTE_DIRECTORY)
    {
        pfpsp->fIsDirectory = TRUE;
    }

    // setup all the flags based on what we found out
    SetInitialFileAttribs(pfpsp, dwFlagsAND, dwFlagsOR);

    // set the current attributes to the same as the initial
    pfpsp->asCurrent = pfpsp->asInitial;

    if (fSameLocation)
    {
        LoadString(HINST_THISDLL, IDS_ALLIN, szBuffer, ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, szDirPath, ARRAYSIZE(szBuffer));
        StrCpyN(pfpsp->szPath, szDirPath, ARRAYSIZE(pfpsp->szPath));
    }

    UpdateSizeField(pfpsp, NULL);

    return TRUE;
}

//
// Descriptions:
//   This function fills fields of the "general" dialog box (a page of
//  a property sheet) with attributes of the associated file. Doesn't
//  make calss to hDlg
//
BOOL InitSinglePrshtNoDlg(FILEPROPSHEETPAGE * pfpsp)
{
    TCHAR szBuffer[MAX_PATH];
    SHFILEINFO sfi;

    // fd is filled in with info from the pidl, but this
    // does not contain all the date/time information so hit the disk here.
    HANDLE hfind = FindFirstFile(pfpsp->szPath, &pfpsp->fd);
    ASSERT(hfind != INVALID_HANDLE_VALUE);
    if (hfind == INVALID_HANDLE_VALUE)
    {
        // if this failed we should clear out some values as to not show garbage on the screen.
        ZeroMemory(&pfpsp->fd, sizeof(pfpsp->fd));
    }
    else
    {
        FindClose(hfind);
    }

    // get info about the file.
    SHGetFileInfo(pfpsp->szPath, pfpsp->fd.dwFileAttributes, &sfi, sizeof(sfi),
        SHGFI_ICON|SHGFI_LARGEICON|
        SHGFI_DISPLAYNAME|
        SHGFI_TYPENAME | SHGFI_ADDOVERLAYS);

    // .ani cursor hack!
    if (StrCmpI(PathFindExtension(pfpsp->szPath), TEXT(".ani")) == 0)
    {
        HICON hIcon = (HICON)LoadImage(NULL, pfpsp->szPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
        if (hIcon)
        {
            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);

            sfi.hIcon = hIcon;
        }
    }

    // set the initial rename state
    pfpsp->fRename = FALSE;

    // set the file type
    if (pfpsp->fMountedDrive)
    {
        TCHAR szVolumeGUID[MAX_PATH];
        TCHAR szVolumeLabel[MAX_PATH];

        //Borrow szVolumeGUID
        LoadString(HINST_THISDLL, IDS_MOUNTEDVOLUME, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        //use szVolumeLabel temporarily
        lstrcpy(szVolumeLabel, pfpsp->szPath);
        PathAddBackslash(szVolumeLabel);
        GetVolumeNameForVolumeMountPoint(szVolumeLabel, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        if (!GetVolumeInformation(szVolumeGUID, szVolumeLabel, ARRAYSIZE(szVolumeLabel),
            NULL, NULL, NULL, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys)))
        {
            *szVolumeLabel = 0;
        }

        if (!(*szVolumeLabel))
            LoadString(HINST_THISDLL, IDS_UNLABELEDVOLUME, szVolumeLabel, ARRAYSIZE(szVolumeLabel));        
    }

    // save off the initial short filename, and set the "Name" edit box
    lstrcpy(pfpsp->szInitialName, sfi.szDisplayName);

    // use a strcmp to see if we are showing the extension
    if (lstrcmpi(sfi.szDisplayName, PathFindFileName(pfpsp->szPath)) == 0)
    {
        // since the strings are the same, we must be showing the extension
        pfpsp->fShowExtension = TRUE;
    }

    lstrcpy(szBuffer, pfpsp->szPath);
    PathRemoveFileSpec(szBuffer);
    
    // Are we a folder shortcut?
    if (!pfpsp->fFolderShortcut)
    {
        // set the initial attributes
        SetInitialFileAttribs(pfpsp, pfpsp->fd.dwFileAttributes, pfpsp->fd.dwFileAttributes);
        
        // set the current attributes to the same as the initial
        pfpsp->asCurrent = pfpsp->asInitial;
        
        UpdateSizeField(pfpsp, &pfpsp->fd);
        
        if (!(pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // Check to see if the target file is a lnk, because if it is a lnk then 
            // we need to display the type information for the target, not the lnk itself.
            if (PathIsShortcut(pfpsp->szPath, pfpsp->fd.dwFileAttributes))
            {
                pfpsp->fIsLink = TRUE;
            }
            if (!(GetFileAttributes(pfpsp->szPath) & FILE_ATTRIBUTE_OFFLINE))
            {
                 UpdateOpensWithInfo(pfpsp);
            }
        }
        else
        {
            pfpsp->fIsDirectory = TRUE;
        }
        
        // get the full path to the folder that contains this file.
        StrCpyN(szBuffer, pfpsp->szPath, ARRAYSIZE(szBuffer));
        PathRemoveFileSpec(szBuffer);
    }
    return TRUE;
}

STDAPI_(BOOL) ApplySingleFileAttributesNoDlg(FILEPROPSHEETPAGE* pfpsp, HWND hwnd)
{
    BOOL bRet = TRUE;
    BOOL bSomethingChanged = FALSE;

    if (!pfpsp->fRecursive)
    {
        bRet = ApplyFileAttributes(pfpsp->szPath, pfpsp, hwnd, &bSomethingChanged);
        
        if (bSomethingChanged)
        {
            // something changed, so generate a notification for the item
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);
        }
    }
    else
    {
        // We only should be doing a recursive operation if we have a directory!
        ASSERT(pfpsp->fIsDirectory);

        CreateAttributeProgressDlg(pfpsp);

        // apply attribs to this folder & sub files/folders
        bRet = ApplyRecursiveFolderAttribs(pfpsp->szPath, pfpsp);
        
        // send out a notification for the whole dir, regardless of the return value since
        // something could have changed even if the user hit cancel
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, pfpsp->szPath, NULL);
        
        DestroyAttributeProgressDlg(pfpsp);
    }

    if (bRet)
    {
        // since we just sucessfully applied attribs, reset any tri-state checkboxes as necessary
        //UpdateTriStateCheckboxes(pfpsp);

        // the user did NOT hit cancel, so update the prop sheet to reflect the new attribs
        pfpsp->asInitial = pfpsp->asCurrent;
    }

    // handle any events we may have generated
    SHChangeNotifyHandleEvents();

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\sencrypt.h ===
#ifndef _SENCRYPT_H_
#define _SENCRYPT_H_

#include "prshtcpp.h" // for UpdateOpensWithInfo()

// Funcs in sencrypt.cpp
STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **pcpOut);
BOOL InitSinglePrshtNoDlg(FILEPROPSHEETPAGE * pfpsp);
BOOL InitMultiplePrshtNoDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) ApplySingleFileAttributesNoDlg(FILEPROPSHEETPAGE* pfpsp, HWND hwnd);

// Funcs from mulpshrt.c  -- use C linkage
STDAPI_(BOOL) ApplyMultipleFileAttributes(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) ApplySingleFileAttributes(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) HIDA_FillFindData(HIDA hida, UINT iItem, LPTSTR pszPath, WIN32_FIND_DATA *pfd, BOOL fReturnCompressedSize);
STDAPI_(void) UpdateSizeField(FILEPROPSHEETPAGE* pfpsp, WIN32_FIND_DATA* pfd);

#endif  // _SENCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\sfvext.cpp ===
#include "shellprv.h"
#include <shellp.h>
#include "ole2dup.h"
#include "defview.h"
#include "bookmk.h"

#include <sfview.h>
#include "defviewp.h"
#include "ids.h"
#include <htiface.h>
#include <olectl.h>
#include "mshtml.h"
#include <mshtmdid.h>
#include <shguidp.h>    // get the CLSID definitions, the bits are built into shguidp.lib
#include "basefvcb.h"
#include "clsobj.h"

#define TF_FOCUS    TF_ALLOC

CSFVFrame::~CSFVFrame()
{
    ATOMICRELEASE(_pvoActive);
    ATOMICRELEASE(_pActive);
    ATOMICRELEASE(_pDocView);
    ATOMICRELEASE(_pOleObj);
    if (_dwConnectionCookie)
        _RemoveReadyStateNotifyCapability();
    ATOMICRELEASE(_pOleObjNew);
}

// Default implementation of SFVM_GETVIEWDATA is to grab the info
// from SFVM_GETVIEWS.  We no longer provide a default implementation
// of that message, so if SFVM_GETVIEWS fails, we manually look in:
// shellex\ExtShellFolderViews\{VID_WebView}\PersistMoniker
//
HRESULT CCallback::OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);

    // try the old message
    pvit->szWebView[0] = 0;

    // For now, use the old one - clean up soon...
    SFVM_VIEWINFO_DATA data;
    data.bWantWebview = TRUE;
    HRESULT hr = pView->CallCB(SFVM_GETVIEWINFO, (WPARAM)uViewMode, (LPARAM)&data);
    if (SUCCEEDED(hr))
    {
        StrCpyN(pvit->szWebView, data.szWebView, ARRAYSIZE(pvit->szWebView));
    }
    else
    {
        if (FAILED(hr))
            hr = TryLegacyGetViews(pvit);
    }

    return hr;
}

void CleanUpDocView(IOleDocumentView* pDocView, IOleObject* pOleObj)
{
    pDocView->UIActivate(FALSE);

    IOleInPlaceObject* pipo;
    if (SUCCEEDED(pOleObj->QueryInterface(IID_PPV_ARG(IOleInPlaceObject, &pipo))))
    {
        pipo->InPlaceDeactivate();
        pipo->Release();
    }
    pDocView->CloseView(0);
    pDocView->SetInPlaceSite(NULL);
    pDocView->Release();
}

void CSFVFrame::_CleanupOldDocObject( )
{
    //See if we have already switched to the new Ole Obj
    if (_pDocView)
    {
        //Save the current values first!
        IOleObject          *pOleObjOld = _pOleObj;
        IOleDocumentView    *pDocViewOld = _pDocView;

        _pDocView = NULL;
        _pOleObj = NULL;
        CleanUpDocView(pDocViewOld, pOleObjOld);
        _CleanUpOleObjAndDt(pOleObjOld);
        SetActiveObject(NULL, NULL);
    }

    if (_dwConnectionCookie)
        _RemoveReadyStateNotifyCapability();

    _CleanupNewOleObj();
}

void CSFVFrame::_CleanUpOleObj(IOleObject* pOleObj)
{
    pOleObj->Close(OLECLOSE_NOSAVE);
    pOleObj->SetClientSite(NULL);
    pOleObj->Release();
}

void CSFVFrame::_CleanUpOleObjAndDt(IOleObject* pOleObj)
{
    _CleanUpOleObj(pOleObj);

    // If we have a wrapping droptarget, release it now. 
    IDropTarget* pdtTemp = _cSite._dt._pdtFrame;
    if (pdtTemp) 
    {
        _cSite._dt._pdtFrame = NULL;
        pdtTemp->Release();
    }
}

void CSFVFrame::_CleanupNewOleObj()
{
    IOleObject *pOleObj = _pOleObjNew;
    if (pOleObj)
    {
        _pOleObjNew = NULL;
        _CleanUpOleObj(pOleObj);
    }
}

// Parameters:
//  pszUniqueName -- Specify the buffer where the unique name should be copied
//  cchMax        -- Specify the size of the buffer
//  pszTemplate   -- Specify the base name
//  pszDir        -- Specify the directory
//
void _MakeShortPsuedoUniqueName(LPTSTR pszUniqueName, UINT cchMax,
                                LPCTSTR pszTemplate, LPCTSTR pszDir)
{

    TCHAR szFullPath[MAX_PATH];

    // It is assuming that the template has a %d in it...
    lstrcpy(szFullPath, pszDir);
    PathAppend(szFullPath, pszTemplate);
    wsprintf(pszUniqueName, szFullPath, LOWORD(GetTickCount()));
}

void DisableActiveDesktop()
{
    SHELLSTATE  ss;

    // Disable this settings in the registry!
    ss.fDesktopHTML = FALSE;
    SHGetSetSettings(&ss, SSF_DESKTOPHTML, TRUE);  // Write back the new

    // Tell the user that we have just disabled the active desktop!
    ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_HTMLFILE_NOTFOUND),
                       MAKEINTRESOURCE(IDS_DESKTOP),
                       MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
}

HRESULT CSFVFrame::_GetCurrentZone(IOleObject *pOleObj, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    VariantInit(pvar);
    V_VT(pvar) = VT_EMPTY;

    IOleCommandTarget* pct;
    if (pOleObj && SUCCEEDED(GetCommandTarget(&pct)))
    {
        hr = pct->Exec(&CGID_Explorer, SBCMDID_MIXEDZONE, 0, 0, pvar);
        pct->Release();
    } 
    else 
    {
        V_VT(pvar) = VT_UI4;
        V_UI4(pvar) = URLZONE_LOCAL_MACHINE; // Default is "My Computer"
        pView->CallCB(SFVM_GETZONE, 0, (LPARAM)&V_UI4(pvar));
    }

    if (V_VT(pvar) == VT_UI4) // We were able to figure out what zone we are in
        { }                   // the zone is just fine
    else if (V_VT(pvar) == VT_NULL)  // MSHTML has figured us to be in a mixed zone
        V_UI4(pvar) = ZONE_MIXED;
    else // We don't have zone info
        V_UI4(pvar) = ZONE_UNKNOWN;
       
    V_VT(pvar) = VT_UI4;
            
    return hr;
}

HRESULT CSFVFrame::_UpdateZonesStatusPane(IOleObject *pOleObj)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    VARIANT var;
    HRESULT hr = _GetCurrentZone(pOleObj, &var);

    // Tell CShellbrowser to show the zone stuff in the second pane
    ASSERT(V_VT(&var) == VT_UI4);

    // The "2" means "second pane"
    V_UI4(&var) = MAKELONG(2, V_UI4(&var));

    IUnknown_Exec(pView->_psb, &CGID_Explorer, SBCMDID_MIXEDZONE, 0, &var, NULL);

    ASSERT((V_VT(&var) == VT_I4)    || (V_VT(&var) == VT_UI4)  || 
           (V_VT(&var) == VT_EMPTY) || (V_VT(&var) == VT_NULL));

    return hr;
}

HRESULT CSFVFrame::_GetHTMLBackgroundColor(COLORREF *pclr)
{
    HRESULT hr = E_FAIL;

    if (_bgColor == CLR_INVALID)
        hr = IUnknown_HTMLBackgroundColor(_pOleObj, &_bgColor);
    else
        hr = S_OK;  // cached

    if (SUCCEEDED(hr))
        *pclr = _bgColor;
    return hr;
}

#ifdef DEBUG

BOOL_PTR CALLBACK s_WVDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM 
lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        RECT rc;
        if (GetWindowRect(hWnd, &rc))
        {
            HWND hEdit = CreateWindow(TEXT("edit"), NULL, WS_CHILD|WS_VISIBLE|ES_MULTILINE|ES_AUTOVSCROLL, 10, 10, (rc.right-rc.left)-20, (rc.bottom-rc.top)-20, hWnd, NULL, NULL, 0);
            if (hEdit)
            {
                SetWindowTextA(hEdit, (LPCSTR)lParam);
            }
        }
        SetWindowText(hWnd, TEXT("WebView Content (DEBUG)"));
        break;
    }

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            EndDialog(hWnd, 0);
            break;
        }
        break;
    }

    return FALSE;
}

void CSFVFrame::_ShowWebViewContent()
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);

    HRESULT hr = E_FAIL;
    LPSTR pszFree = NULL;

    if (_pOleObj)
    {
        IStream* pstm = SHCreateMemStream(NULL, 0);
        if (pstm)
        {
            VARIANTARG vt;
            vt.vt = VT_UNKNOWN;
            vt.punkVal = pstm;

            #define IDM_DEBUG_GETTREETEXT 7102 // stolen from mshtml\src\include\privcid.h

            if (SUCCEEDED(IUnknown_Exec(_pOleObj, &CGID_MSHTML, IDM_DEBUG_GETTREETEXT, 0, &vt, NULL)))
            {
                STATSTG stg;
                if (SUCCEEDED(pstm->Stat(&stg, 0)))
                {
                    pszFree = (LPSTR)LocalAlloc(LPTR, stg.cbSize.LowPart+2); // stream doesn't include NULL...
                    if (pszFree)
                    {
                        pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);
                        pstm->Read(pszFree, stg.cbSize.LowPart, NULL);
                    }
                }
            }

            pstm->Release();
        }
    }

    // I'm not sure if the output from Trident is always ANSI, but right now that seems to be the case.
    LPSTR pszMessage = pszFree ? pszFree : "Error collecting WebView content";

    DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DRV_HWTAB), pView->_hwndView, s_WVDlgProc, (LPARAM)pszFree);

    if (pszFree)
        LocalFree(pszFree);
}
#endif

// ready state complete has occured, ready to do the switch thing.  

HRESULT CSFVFrame::_SwitchToNewOleObj()
{
    HRESULT hr = S_OK;

    if (!_fSwitchedToNewOleObj && _pOleObjNew)
    {
        _fSwitchedToNewOleObj = TRUE;

        CDefView* pView = IToClass(CDefView, _cFrame, this);
    
        //Save the current values first!
        IOleObject          *pOleObjOld = _pOleObj;
        IOleDocumentView    *pDocViewOld = _pDocView;
        IOleObject          *pOleObjNew = _pOleObjNew;
        
        _pDocView = NULL;
        _pOleObj = NULL;
        _pOleObjNew = NULL;
    
        //If we already have one, destroy it!
        if (pDocViewOld)
        {
            //To prevent flashing, set the flag that avoids the painting
            SendMessage(pView->_hwndView, WM_SETREDRAW, 0, 0);
    
            CleanUpDocView(pDocViewOld, pOleObjOld);
            _CleanUpOleObjAndDt(pOleObjOld);
            SetActiveObject(NULL, NULL);
    
            //Is the ViewWindow still around?
            if (IsWindow(pView->_hwndView))
            {
                SendMessage(pView->_hwndView, WM_SETREDRAW, TRUE, 0);
                if (pView->_hwndListview)
                    InvalidateRect(pView->_hwndListview, NULL, TRUE);
            }
        }
    
        // HACK: We need to set the host names for Word to force embedding mode
        pOleObjNew->SetHostNames(L"1", L"2");
    
        OleRun(pOleObjNew);
    
        IOleDocumentView* pDocView = NULL;
    
        IOleDocument* pDocObj;
        hr = pOleObjNew->QueryInterface(IID_PPV_ARG(IOleDocument, &pDocObj));
        if (SUCCEEDED(hr))
        {
            hr = pDocObj->CreateView(&_cSite, NULL, 0, &pDocView);
            if (SUCCEEDED(hr))
            {
                RECT rcView;
    
                pDocView->SetInPlaceSite(&_cSite);
    
                GetClientRect(pView->_hwndView, &rcView);
                hr = pOleObjNew->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL,
                                &_cSite, (UINT)-1, pView->_hwndView, &rcView);
                if (FAILED(hr))
                    CleanUpDocView(pDocView, pOleObjNew);
            }
    
            pDocObj->Release();
        }
    
        if (SUCCEEDED(hr))
        {
            hr = S_OK; // S_FALSE -> S_OK, needed?

            ASSERT(_pOleObj == NULL);
            ASSERT(_pDocView == NULL);

            _pDocView = pDocView;
            pDocView->AddRef();     // copy hold the ref for our copy

            _pOleObj = pOleObjNew;
            _pOleObjNew = NULL;

            RECT rcClient;
    
            // Make sure the new view is the correct size
            GetClientRect(pView->_hwndView, &rcClient);
            SetRect(&rcClient);

            // If this is desktop, then we need to see the listview's background color
            if (pView->_IsDesktop())
            {
                _bgColor = CLR_INVALID;

                pView->_SetFolderColors(); //Tell the listview about color change!
            }
        }
        else
        {
            if (pView->_IsDesktop())
                PostMessage(pView->_hwndView, WM_DSV_DISABLEACTIVEDESKTOP, 0, 0);
    
            // Clean up if necessary
            _CleanupNewOleObj();
        }

        ATOMICRELEASE(pDocView);
    }

    return hr;
}

// IBindStatusCallback impl
HRESULT CSFVFrame::CBindStatusCallback::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSFVFrame::CBindStatusCallback, IBindStatusCallback),  // IID_IBindStatusCallback
        QITABENT(CSFVFrame::CBindStatusCallback, IServiceProvider),     // IID_IServiceProvider
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CSFVFrame::CBindStatusCallback::AddRef(void)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _bsc, this);
    return pFrame->AddRef();
}

ULONG CSFVFrame::CBindStatusCallback::Release(void)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _bsc, this);
    return pFrame->Release();
}

HRESULT CSFVFrame::CBindStatusCallback::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::GetPriority(LONG *pnPriority)
{
    *pnPriority = NORMAL_PRIORITY_CLASS;
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnLowResource(DWORD reserved)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnStopBinding(HRESULT hr, LPCWSTR pszError)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return S_OK;
}

HRESULT CSFVFrame::CBindStatusCallback::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _bsc, this);

    if (IsEqualGUID(guidService, SID_DefView))
    {
        // QueryService from a pluggable protocol/mime filter winds up
        // here during the Bind, but Trident re-binds during F5 processing
        // so the QueryService winds up directly at _cSite. Handle all
        // SID_DefView processing there so there's no discrepencies.
        //
        return pFrame->_cSite.QueryService(guidService, riid, ppv);
    }

    *ppv = NULL;
    return E_FAIL;
}

HRESULT CSFVFrame::_CreateNewOleObjFromMoniker(LPCWSTR wszMoniker, IOleObject **ppOleObj)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    HRESULT hr = E_FAIL;
    IOleObject* pOleObj = NULL;

    if (wszMoniker[0])
    {
        LPWSTR pwszExtension = PathFindExtensionW(wszMoniker);
        // Only htt's are allowed
        if (StrCmpIW(pwszExtension, L".htt") == 0)
        {
            IMoniker * pMoniker;
            hr = CreateURLMoniker(NULL, wszMoniker, &pMoniker);
            if (SUCCEEDED(hr))
            {
                IBindCtx * pbc;
                hr = CreateBindCtx(0, &pbc);
                if (SUCCEEDED(hr))
                {
                    // NOTE: We only support synchronous bind here!
                    //
                    //
                    //  Associate the client site as an object parameter to this
                    // bind context so that Trident can pick it up while processing
                    // IPersistMoniker::Load().
                    //
                    pbc->RegisterObjectParam(WSZGUID_OPID_DocObjClientSite,
                                                SAFECAST((&_cSite), IOleClientSite*));
                                        
                    RegisterBindStatusCallback(pbc, SAFECAST(&_bsc, IBindStatusCallback*), 0, 0);

                    hr = pMoniker->BindToObject(pbc, NULL, IID_PPV_ARG(IOleObject, &pOleObj));
                    if (FAILED(hr))
                    {
                        if (pView->_IsDesktop())
                            PostMessage(pView->_hwndView, WM_DSV_DISABLEACTIVEDESKTOP, 0, 0);
                    }

                    RevokeBindStatusCallback(pbc, SAFECAST(&_bsc, IBindStatusCallback*));
                    pbc->Release();
                }
                pMoniker->Release();
            }
        }
    }

    *ppOleObj = pOleObj;

    return hr;
}

HRESULT CSFVFrame::_GetCurrentWebViewMoniker(LPWSTR pszCurrentMoniker, DWORD cchCurrentMoniker)
{
    StrCpyN(pszCurrentMoniker, _szCurrentWebViewMoniker, cchCurrentMoniker);
    return pszCurrentMoniker[0] ? S_OK : E_FAIL;
}

// Show Web View content for the specified template/moniker
//
HRESULT CSFVFrame::ShowWebView(LPCWSTR pszMoniker)
{
    if (GetSystemMetrics(SM_CLEANBOOT))
        return E_FAIL;

    // kill previous readystatenotify and cleanup old pending hoster.
    //
    // TODO: move into _CleanupNewOleObj
    if (_dwConnectionCookie)
        _RemoveReadyStateNotifyCapability();

    // Clean up if a new Ole object is already awaiting ready state
    if (_pOleObjNew)
        _CleanupNewOleObj();    // TODO: rename to _CleanupPendingView
    ASSERT(_dwConnectionCookie == NULL);
    ASSERT(_pOleObjNew == NULL);

    // Create and initialize the new old object!
    IOleObject *pOleObj;

    HRESULT hr = _CreateNewOleObjFromMoniker(pszMoniker, &pOleObj);
    if (SUCCEEDED(hr) && pOleObj)
    {
        if (!_pOleObjNew)
        {
            CDefView* pView = IToClass(CDefView, _cFrame, this);

            StrCpyN(_szCurrentWebViewMoniker, pszMoniker, ARRAYSIZE(_szCurrentWebViewMoniker));
            hr = _ShowExtView_Helper(pOleObj);
            pOleObj->SetClientSite(&_cSite);

            pView->ShowHideListView(); // we just changed IsWebView
        }
        else
        {
            // Yikes!  We got reentered during the creation of the OleObj, blow away the object
            // and just return.
            pOleObj->Release();
        }
    }

    return hr;
}

HRESULT CSFVFrame::HideWebView()
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    _szCurrentWebViewMoniker[0] = 0;
    _CleanupOldDocObject();

    pView->ShowHideListView(); // we just changed IsWebView

    return S_OK;
}


HRESULT CSFVFrame::_ShowExtView_Helper(IOleObject* pOleObj)
{
    HRESULT hr;

    // Don't leak the old object, it must be NULL at this point
    ASSERT(_pOleObjNew == NULL);

    // Save the new ole object
    _pOleObjNew = pOleObj;
    _fSwitchedToNewOleObj = FALSE;

    // Establish to connection point to receive the READYSTATE notification.
    if (!_SetupReadyStateNotifyCapability())
    {
        _SwitchToNewOleObj();
        _UpdateZonesStatusPane(_pOleObj);   
        // If the object doesn't support readystate (or it's already interactive)
        // then we return S_OK to indicate synchronous switch.
        hr = S_OK;
    }
    else
    {
        // We're waiting on the docobj, we'll call _SwitchToNewOleObj
        // when it goes interactive...
        hr = S_FALSE;
    }

    return hr;
}

BOOL CSFVFrame::_SetupReadyStateNotifyCapability()
{
    // By default we don't have gray-flash communication
    BOOL fSupportsReadystate = FALSE;
    
    // Sanity Check
    if (!_pOleObjNew)  
        return fSupportsReadystate;
    
    // Check for proper readystate support
    BOOL fReadyStateOK = FALSE;
    IDispatch *pdisp;
    if (SUCCEEDED(_pOleObjNew->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp))))
    {
        EXCEPINFO exInfo;
        VARIANTARG va = {0};
        DISPPARAMS dp = {0};

        if (SUCCEEDED(pdisp->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &dp, &va, &exInfo, NULL)))
        {
            if ((va.vt == VT_I4) && (va.lVal < READYSTATE_COMPLETE))
            {
                fReadyStateOK = TRUE;
            }
        }
        pdisp->Release();
    }

    if (fReadyStateOK)
    {
        // Check and Set-Up IPropertyNotifySink
        if (SUCCEEDED(ConnectToConnectionPoint(SAFECAST(this, IPropertyNotifySink*), IID_IPropertyNotifySink, TRUE, _pOleObjNew, &_dwConnectionCookie, NULL)))
        {
            fSupportsReadystate = TRUE;
            _fReadyStateInteractiveProcessed = FALSE;
            _fReadyStateComplete = FALSE;
            _pOleObjReadyState = _pOleObjNew;
            _pOleObjReadyState->AddRef();
        }
    }

    return fSupportsReadystate;
}

BOOL CSFVFrame::_RemoveReadyStateNotifyCapability()
{
    BOOL fRet = FALSE;

    if (_dwConnectionCookie)
    {
        ASSERT(_pOleObjReadyState);
        ConnectToConnectionPoint(NULL, IID_IPropertyNotifySink, FALSE, _pOleObjReadyState, &_dwConnectionCookie, NULL);
        ATOMICRELEASE(_pOleObjReadyState);
        fRet = TRUE;
        _dwConnectionCookie = 0;
    }

    return fRet;
}

HWND CSFVFrame::GetExtendedViewWindow()
{
    HWND hwnd;

    if (SUCCEEDED(IUnknown_GetWindow(_pDocView, &hwnd)))
        return hwnd;
        
    if (_pActive && SUCCEEDED(_pActive->GetWindow(&hwnd)))
        return hwnd;

    return NULL;
}

STDMETHODIMP CSFVSite::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSFVSite, IOleInPlaceSite),
        QITABENTMULTI(CSFVSite, IOleWindow, IOleInPlaceSite),
        QITABENT(CSFVSite, IOleClientSite),
        QITABENT(CSFVSite, IOleDocumentSite),
        QITABENT(CSFVSite, IServiceProvider),
        QITABENT(CSFVSite, IOleCommandTarget),
        QITABENT(CSFVSite, IDocHostUIHandler),
        QITABENT(CSFVSite, IOleControlSite),
        QITABENT(CSFVSite, IDispatch),
        QITABENT(CSFVSite, IInternetSecurityManager),
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSFVSite::AddRef()
{
    return IToClass(CSFVFrame, _cSite, this)->AddRef();
}

STDMETHODIMP_(ULONG) CSFVSite::Release()
{
    return IToClass(CSFVFrame, _cSite, this)->Release();
}

// IOleWindow
STDMETHODIMP CSFVSite::GetWindow(HWND *phwnd)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    return pFrame->GetWindow(phwnd);
}

STDMETHODIMP CSFVSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    return pFrame->ContextSensitiveHelp(fEnterMode);
}

// IInternetSecurityManager
HRESULT CSFVSite::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE * pPolicy, DWORD cbPolicy, BYTE * pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if ((((URLACTION_ACTIVEX_MIN <= dwAction) &&
          (URLACTION_ACTIVEX_MAX >= dwAction)) ||
         ((URLACTION_SCRIPT_MIN <= dwAction) &&
          (URLACTION_SCRIPT_MAX >= dwAction))) &&
        pContext &&
        (sizeof(CLSID) == cbContext) &&
        (IsEqualIID(*(CLSID *) pContext, CLSID_WebViewFolderContents) ||
        (IsEqualIID(*(CLSID *) pContext, CLSID_ThumbCtl))))
    {
        if (EVAL(pPolicy) && EVAL(sizeof(DWORD) == cbPolicy))
        {
            *pPolicy = (DWORD) URLPOLICY_ALLOW;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

// IOleInPlaceSite
STDMETHODIMP CSFVSite::CanInPlaceActivate(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnInPlaceActivate(void)
{
    TraceMsg(TF_FOCUS, "sfvf.oipa: _pAct=%x", IToClass(CSFVFrame, _cSite, this)->_pActive);
    IToClass(CSFVFrame, _cSite, this)->_uState = SVUIA_ACTIVATE_NOFOCUS;
    return S_OK;
}

STDMETHODIMP CSFVSite::OnUIActivate(void)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame._cSite, this);

    HRESULT hr = pView->_OnViewWindowActive();

    pFrame->_uState = SVUIA_ACTIVATE_FOCUS;
    TraceMsg(TF_FOCUS, "sfvf.ouia: _pAct'=%x", IToClass(CSFVFrame, _cSite, this)->_pActive);
    return hr;
}

STDMETHODIMP CSFVSite::GetWindowContext(
    /* [out] */ IOleInPlaceFrame **ppFrame,
    /* [out] */ IOleInPlaceUIWindow **ppDoc,
    /* [out] */ LPRECT lprcPosRect,
    /* [out] */ LPRECT lprcClipRect,
    /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    *ppFrame = pFrame; pFrame->AddRef();
    *ppDoc = NULL; // indicating that doc window == frame window

    GetClientRect(pView->_hwndView, lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = pView->_hwndView;   // Yes, should be view window
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;

    return S_OK;
}

STDMETHODIMP CSFVSite::Scroll(SIZE scrollExtant)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnUIDeactivate(BOOL fUndoable)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnInPlaceDeactivate(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::DiscardUndoState(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::DeactivateAndUndo(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnPosRectChange(LPCRECT lprcPosRect)
{
    return S_OK;
}

// IOleClientSite
STDMETHODIMP CSFVSite::SaveObject(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    return E_FAIL;
}

STDMETHODIMP CSFVSite::GetContainer(IOleContainer **ppContainer)
{
    *ppContainer = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CSFVSite::ShowObject(void)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

STDMETHODIMP CSFVSite::RequestNewObjectLayout(void)
{
    return S_OK;
}

// IOleDocumentSite
STDMETHODIMP CSFVSite::ActivateMe(IOleDocumentView *pviewToActivate)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    if (pView->_uState == SVUIA_ACTIVATE_FOCUS)
        pviewToActivate->UIActivate(TRUE);
    pviewToActivate->Show(TRUE);
    return S_OK;
}

//
// IOleCommandTarget stuff - just forward to _psb
//
STDMETHODIMP CSFVSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);
    IOleCommandTarget* pct;
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (SUCCEEDED(pView->_psb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
    {
        hr = pct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        pct->Release();
    }

    return hr;
}

STDMETHODIMP CSFVSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup)
    {
        if (IsEqualIID(*pguidCmdGroup, CGID_DefView))
        {
            hr = E_INVALIDARG;
            if (pvarargOut) 
            {
                VariantClear(pvarargOut);
                TCHAR szPath[MAX_PATH];

                switch (nCmdID)
                {
                case DVCMDID_GETTHISDIRPATH:
                case DVCMDID_GETTHISDIRNAME:
                    hr = pView->_GetNameAndFlags(nCmdID == DVCMDID_GETTHISDIRPATH ? 
                            SHGDN_FORPARSING : SHGDN_INFOLDER, 
                            szPath, ARRAYSIZE(szPath), NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = InitVariantFromStr(pvarargOut, szPath);
                    }
                    break;

                case DVCMDID_GETTEMPLATEDIRNAME:
                    if (pFrame->IsWebView()) 
                    {
                        WCHAR wszMoniker[MAX_PATH];
                        if (SUCCEEDED(pFrame->_GetCurrentWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker))) ||
                            SUCCEEDED(pView->_GetWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker))))
                        {
                            hr = InitVariantFromStr(pvarargOut, wszMoniker);
                        }
                    }
                    break;
                }
            }
            return hr;
        }
        else if (IsEqualIID(*pguidCmdGroup, CGID_Explorer))
        {
            if ((SBCMDID_UPDATETRAVELLOG == nCmdID) && !pView->_fCanActivateNow)
            {
                //
                // We get a spurious UPDATETRAVELLOG command because we have enabled
                // CDefviewPersistHistory to call the MSHTML IPersistHistory in webview
                // mode. 
                // This seems to be the best place to fix this as the call stack
                // below this call is trident, and the call stack above this call is 
                // browser code.
                //
                // The travellog is subsequently updated correctly when 
                // CBaseBrowser2::ActivatePendingView is called.
                //
                return S_OK;
            }
        }
        // fall through on other cmd groups...
    }
    else if ((OLECMDID_SETTITLE == nCmdID) && !pView->_fCanActivateNow)
    {
        // NT #282632: Don't forward this message if we aren't the active view.
        return S_OK;
    }
   
    IOleCommandTarget* pct;
    if (SUCCEEDED(pView->_psb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
    {
        hr = pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        pct->Release();
    }

    return hr;
}

//***   IOleControlSite {

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    int nDir = 0;

    if (!pMsg)
        return nDir;

    if (pMsg->message != WM_KEYDOWN)
        return nDir;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return nDir;

    nDir = (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;

#ifdef KEYBOARDCUES
    SendMessage(GetParent(pMsg->hwnd), WM_CHANGEUISTATE,
        MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0);
#endif
    
    return nDir;
}

//***   CSFVSite::TranslateAccelerator (IOCS::TranslateAccelerator)
// NOTES
//  (following comment/logic stolen from shdocvw/dochost.cpp)
//  trident (or any other DO that uses IOCS::TA) calls us back when TABing
//  off the last link.  to handle it, we flag it for our original caller
//  (IOIPAO::TA), and then pretend we handled it by telling trident S_OK.
//  trident returns S_OK to IOIPAO::TA, which checks the flag and says
//  'trident did *not* handle it' by returning S_FALSE.  that propagates
//  way up to the top where it sees it was a TAB so it does a CycleFocus.
//
//  that's how we do it when we're top-level.  when we're a frameset, we
//  need to do it the 'real' way, sending it up to our parent IOCS.
HRESULT CSFVSite::TranslateAccelerator(MSG *pMsg, DWORD grfModifiers)
{
    if (IsVK_TABCycler(pMsg)) 
    {
        CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
        CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

        TraceMsg(TF_FOCUS, "csfvs::IOCS::TA(wParam=VK_TAB) ret _fCycleFocus=TRUE hr=S_OK (lie)");
        // defer it, set flag for cdv::IOIPAO::TA, and pretend we handled it
        ASSERT(!pView->_fCycleFocus);
        pView->_fCycleFocus = TRUE;
        return S_OK;
    }
    //ASSERT(!pView->_fCycleFocus);
    return S_FALSE;
}

// }

// IServiceProvider

HRESULT CSFVSite::QueryService(REFGUID guidService, REFIID riid, void ** ppv)
{
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    *ppv = NULL;
    HRESULT hr = E_FAIL;
    if (guidService == SID_DefView)
    {
        if (riid == IID_IDefViewFrame && pView->_IsDesktop()) 
        {
            return E_FAIL; 
        } 
        // Try site QI
        hr = QueryInterface(riid, ppv);
    }

    if (FAILED(hr))
    {
        // Delegate to defview QS
        hr = pView->QueryService(guidService, riid, ppv);
        if (FAILED(hr))
        {
            // Look for IID_IInternetSecurityManager
            if (guidService == IID_IInternetSecurityManager)
            {
                ASSERT(riid == IID_IInternetSecurityManager);
                hr = QueryInterface(riid, ppv);
            }
        }
    }
    return hr;
}

HRESULT CSFVSite::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                         VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!pVarResult)
        return E_INVALIDARG;

    //Get pointer to the defview
    CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
    CDefView* pView = IToClass(CDefView, _cFrame, pFrame);

    // We handle the query of whether we want to show images, ourselves.
    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
            case DISPID_AMBIENT_DLCONTROL:
            {
                // Do the following only if this is NOT the desktop. 
                // (Because Desktop is in offline mode, it should 
                // return DLCTL_OFFLINEIFNOTCONNECTED flag). The following code
                // should be executed only for NON-desktop folders.
                if (!(pView->_IsDesktop()))
                {
                    pVarResult->vt = VT_I4;
                    pVarResult->lVal = DLCTL_DLIMAGES | DLCTL_VIDEOS;
                    return S_OK;
                }
            }
        }
    }

    // We delegate all other queries to shdocvw.
    if (!_peds)
    {
        IUnknown_QueryService(pView->_psb, IID_IExpDispSupport, IID_PPV_ARG(IExpDispSupport, &_peds));
    }

    if (!_peds)
        return E_NOTIMPL;

    return _peds->OnInvoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr);
}

HRESULT CHostDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CHostDropTarget, IDropTarget),  // IID_IDropTarget
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CHostDropTarget::AddRef(void)
{
    CSFVSite* pcsfvs = IToClass(CSFVSite, _dt, this);
    return pcsfvs->AddRef();
}

ULONG CHostDropTarget::Release(void)
{
    CSFVSite* pcsfvs = IToClass(CSFVSite, _dt, this);
    return pcsfvs->Release();
}

HRESULT CHostDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _pdtFrame->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
}

HRESULT CHostDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _pdtFrame->DragOver(grfKeyState, pt, pdwEffect);
}

HRESULT CHostDropTarget::DragLeave(void)
{
    return _pdtFrame->DragLeave();
}

HRESULT CHostDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _pdtFrame->Drop(pdtobj, grfKeyState, pt, pdwEffect);
}

STDMETHODIMP CSFVFrame::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CSFVFrame, IOleWindow, IOleInPlaceFrame),  // IID_IOleWindow
        QITABENTMULTI(CSFVFrame, IOleInPlaceUIWindow, IOleInPlaceFrame),  // IID_IOleInPlaceUIWindow
        QITABENT(CSFVFrame, IOleInPlaceFrame),        // IID_IOleInPlaceFrame
        QITABENT(CSFVFrame, IAdviseSink),             // IID_IAdviseSink
        QITABENT(CSFVFrame, IPropertyNotifySink),     // IID_IPropertyNotifySink
        { 0 }
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSFVFrame::AddRef()
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->AddRef();
}

STDMETHODIMP_(ULONG) CSFVFrame::Release()
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->Release();
}

// IOleWindow
STDMETHODIMP CSFVFrame::GetWindow(HWND *phwnd)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->GetWindow(phwnd);
}

STDMETHODIMP CSFVFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->ContextSensitiveHelp(fEnterMode);
}

// IOleInPlaceUIWindow
STDMETHODIMP CSFVFrame::GetBorder(LPRECT lprectBorder)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    GetClientRect(pView->_hwndView, lprectBorder);
    return S_OK;
}

STDMETHODIMP CSFVFrame::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    return INPLACE_E_NOTOOLSPACE;
}

STDMETHODIMP CSFVFrame::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    return INPLACE_E_NOTOOLSPACE;
}

STDMETHODIMP CSFVFrame::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    TraceMsg(TF_FOCUS, "sfvf.sao(pAct'=%x): _pAct=%x", pActiveObject, _pActive);
    if (pActiveObject != _pActive)
    {
        IAdviseSink* pOurSink = SAFECAST(this, IAdviseSink*);
#ifdef DEBUG
        QueryInterface(IID_PPV_ARG(IAdviseSink, &pOurSink));
#endif
        if (_pActive)
        {
            //
            // if we had an OLE view object then disconnect our advise sink and
            // release the view object.
            //
            if (_pvoActive)
            {
                IAdviseSink *pSink;
                if (SUCCEEDED(_pvoActive->GetAdvise(NULL, NULL, &pSink)))
                {
                    // Be polite, only blow away the advise if we're the
                    // one who's listening
                    if (pSink == pOurSink)
                    {
                        _pvoActive->SetAdvise(0, 0, NULL);
                    }

                    // If there was no sink, GetAdvise succeeds but sets
                    // pSink to NULL, so need to check pSink here.
                    if (pSink)
                        pSink->Release();
                }
                ATOMICRELEASE(_pvoActive);
            }

            ATOMICRELEASE(_pActive);
        }
    
        _pActive = pActiveObject;
    
        if (_pActive)
        {
            _pActive->AddRef();

            //
            // try to get an OLE view object and set up an advisory connection.
            //
            if (SUCCEEDED(_pActive->QueryInterface(IID_PPV_ARG(IViewObject, &_pvoActive))))
            {
                ASSERT(_pvoActive);
                _pvoActive->SetAdvise(DVASPECT_CONTENT, 0, pOurSink);
            }
        }

        //
        // since we changed the active view, tell our owner that the content
        // may have changed...
        //
        OnViewChange(DVASPECT_CONTENT, -1);

#ifdef DEBUG
        ATOMICRELEASE(pOurSink);
#endif
    }

    return S_OK;
}


// IOleInPlaceFrame
STDMETHODIMP CSFVFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    if (hmenuShared)
    {
        // No menu merging
        // or fill lpMenuWidths with 0 and return success
        lpMenuWidths->width[0] = 0;
        lpMenuWidths->width[2] = 0;
        lpMenuWidths->width[4] = 0;
    }
    return S_OK;
}

STDMETHODIMP CSFVFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return S_OK;    // No menu merging
}

STDMETHODIMP CSFVFrame::RemoveMenus(HMENU hmenuShared)
{
    return E_FAIL;      // No menu merging
}

//
//  This one is a bit tricky.  If the client wants to clear the status
//  area, then restore it to the original defview status area text.
//
//  For example, in webview, MSHTML will keep clearing the status area
//  whenever you are not over a link, which would otherwise keep erasing
//  the "n object(s) selected" message from defview.
//
//  To really clear the status area, set the text to " " instead of "".
//
STDMETHODIMP CSFVFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    if (pszStatusText && pszStatusText[0])
        return pView->_psb->SetStatusTextSB(pszStatusText);

    pView->_UpdateStatusBar(FALSE);
    return S_OK;
}

STDMETHODIMP CSFVFrame::EnableModeless(BOOL fEnable)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);

    if (pView->_IsDesktop())
    {
        if (fEnable)
        {
            pView->_fDesktopModal = FALSE;
            if (pView->_fDesktopRefreshPending)  //Was a refresh pending?
            {
                pView->_fDesktopRefreshPending = FALSE;
                //Let's do a refresh asynchronously. 
                PostMessage(pView->_hwndView, WM_KEYDOWN, (WPARAM)VK_F5, 0);
            }
            TraceMsg(TF_DEFVIEW, "A Modal dlg is going away!");
        }
        else
        {
            pView->_fDesktopModal = TRUE;
            TraceMsg(TF_DEFVIEW, "A Modal dlg is coming up for Desktop!");
        }
    }

    return pView->_psb->EnableModelessSB(fEnable);
}

STDMETHODIMP CSFVFrame::TranslateAccelerator(LPMSG lpmsg,WORD wID)
{
    CDefView* pView = IToClass(CDefView, _cFrame, this);
    return pView->_psb->TranslateAcceleratorSB(lpmsg, wID);
}

// IAdviseSink
void CSFVFrame::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CSFVFrame::OnViewChange(DWORD dwAspect, LONG lindex)
{
    if (IsWebView() && _pvoActive)
    {
        CDefView *pView = IToClass(CDefView, _cFrame, this);
        pView->PropagateOnViewChange(dwAspect, lindex);
    }
}

void CSFVFrame::OnRename(IMoniker *)
{
}

void CSFVFrame::OnSave()
{
}

void CSFVFrame::OnClose()
{
    if (IsWebView() && _pvoActive)
    {
        CDefView *pView = IToClass(CDefView, _cFrame, this);
        pView->PropagateOnClose();
    }
}

HRESULT CSFVFrame::OnChanged(DISPID dispid)
{
    if (DISPID_READYSTATE == dispid || DISPID_UNKNOWN == dispid)
    {
        ASSERT(_pOleObjReadyState);
        if (!_pOleObjReadyState)
            return S_OK;  //Documentation says we need to return this all the time

        IDispatch *pdisp;
        if (SUCCEEDED(_pOleObjReadyState->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp))))
        {
            CDefView* pView = IToClass(CDefView, _cFrame, this);
            EXCEPINFO exInfo;
            VARIANTARG va = {0};
            DISPPARAMS dp = {0};

            if (EVAL(SUCCEEDED(pdisp->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &dp, &va, &exInfo, NULL))
                && va.vt == VT_I4))
            {
                if (va.lVal >= READYSTATE_INTERACTIVE)
                {
                    if (!_fReadyStateInteractiveProcessed)
                    {
                        _fReadyStateInteractiveProcessed = TRUE;

                        // First time through this function we need to request
                        // activation.  After that, we can switch immediately.
                        //
                        // Switch the bit early since SHDVID_ACTIVATEMENOW calls
                        // SHDVID_CANACTIVATENOW which checks it.
                        //
                        BOOL fTmp = !pView->_fCanActivateNow;
                        pView->_fCanActivateNow = TRUE;
                        if (fTmp)
                        {
                            // If we did an async CreateViewWindow2, then we
                            // need to notify the browser that we're ready
                            // to be activated - it will uiactivate us which
                            // will cause us to switch.

                            //Don't Make the View Visible, if it is in
                            //DEACTIVATE State. The View would be made visible
                            //during uiactivate call. - KishoreP 

                            if (pView->_uState != SVUIA_DEACTIVATE)
                            {
                                SetWindowPos(pView->_hwndView, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
                            }
                            IUnknown_Exec(pView->_psb, &CGID_ShellDocView, SHDVID_ACTIVATEMENOW, NULL, NULL, NULL);
                        }
                        else
                        {
                            // Technically we only want to do this iff our view is currently
                            // the active visible view.  !fCanActivateNow => we are definitely not visible,
                            // but _fCanActivateNow does NOT imply visible, it implies we are ready to be
                            // made the active visible guy, and that we've requested to be made the active
                            // visible view, but not necessarily that we *are* the active visible view.  If
                            // the previous view wasn't ready to go away, then we are in limbo.  But if that's
                            // the case, then our menus aren't merged, so there's no way the user could
                            // switch views on us...  Verify this.
#ifdef DEBUG
                            CDefView* pView = IToClass(CDefView, _cFrame, this);
                            IShellView* psvCurrent;
                            if (EVAL(SUCCEEDED(pView->_psb->QueryActiveShellView(&psvCurrent))))
                            {
                                ASSERT(SHIsSameObject(SAFECAST(pView, IShellView2*), psvCurrent));
                                psvCurrent->Release();
                            }

                            ASSERT(pView->_uState != SVUIA_DEACTIVATE)
#endif
                        
                            // If we're simply switching views, go ahead
                            // and do it.
                            _SwitchToNewOleObj();
                        }

                        if (g_dwProfileCAP & 0x00010000)
                            StopCAP();
                    }
                }
            }

            if (va.lVal == READYSTATE_COMPLETE)
            {
                _UpdateZonesStatusPane(_pOleObjReadyState);
                
                _RemoveReadyStateNotifyCapability();

                _fReadyStateComplete = TRUE;
            }    
            pdisp->Release();
        }
    }

    return S_OK;
}

HRESULT CSFVFrame::OnRequestEdit(DISPID dispid)
{
    return E_NOTIMPL;
}

// randum stuff
HRESULT CSFVFrame::GetCommandTarget(IOleCommandTarget** ppct)
{
    if (_pDocView)
    {
        return _pDocView->QueryInterface(IID_PPV_ARG(IOleCommandTarget, ppct));
    }
    *ppct = NULL;
    return E_FAIL;
}

HRESULT CSFVFrame::SetRect(LPRECT prc)
{
    if (IsWebView() && _pDocView)
        return _pDocView->SetRect(prc);
    return E_FAIL;
}

HRESULT CSFVFrame::OnTranslateAccelerator(LPMSG pmsg, BOOL* pbTabOffLastTridentStop)
{
    HRESULT hr = E_FAIL;

    *pbTabOffLastTridentStop = FALSE;
    if (IsWebView())
    {
        if (_pActive)
        {
            hr = _pActive->TranslateAccelerator(pmsg);
        }
        else if (_pOleObj)
        {
            IOleInPlaceActiveObject* pIAO;
            if (SUCCEEDED(_pOleObj->QueryInterface(IID_PPV_ARG(IOleInPlaceActiveObject, &pIAO))))
            {
                hr = pIAO->TranslateAccelerator(pmsg);
                pIAO->Release();
            }
        }
        if (hr == S_OK)
        {
            CDefView* pView = IToClass(CDefView, _cFrame, this);

            if (pView->_fCycleFocus)
            {
                // we got called back by trident (IOCS::TA), but deferred it.
                // time to pay the piper.
                *pbTabOffLastTridentStop = TRUE;
                TraceMsg(TF_FOCUS, "sfvf::IOIPAO::OnTA piao->TA==S_OK ret _fCycleFocus=FALSE hr=S_FALSE (piper)");
                pView->_fCycleFocus = FALSE;
                // _UIActivateIO(FALSE, NULL);
                hr = S_FALSE;       // time to pay the piper
            }
        }

        ASSERT(! IToClass(CDefView, _cFrame, this)->_fCycleFocus);
    }

    return hr;
}

HRESULT CSFVFrame::_HasFocusIO()
{
    TraceMsg(TF_FOCUS, "sfvf._hfio: uState=%x hr=%x", _uState, (_uState == SVUIA_ACTIVATE_FOCUS) ? S_OK : S_FALSE);
    if (IsWebView()) 
    {
        return (_uState == SVUIA_ACTIVATE_FOCUS) ? S_OK : S_FALSE;
    }
    return S_FALSE;
}

HRESULT CSFVFrame::_UIActivateIO(BOOL fActivate, MSG *pMsg)
{
    HRESULT hr;
    if (IsWebView() && _pOleObj) 
    {
        CSFVFrame* pFrame = IToClass(CSFVFrame, _cSite, this);
        CDefView* pView = IToClass(CDefView, _cFrame, pFrame);
        LONG iVerb;
        RECT rcView;

        if (fActivate) 
        {
            iVerb = OLEIVERB_UIACTIVATE;
            _uState = SVUIA_ACTIVATE_FOCUS;
        }
        else 
        {
            iVerb = OLEIVERB_INPLACEACTIVATE;
            _uState = SVUIA_ACTIVATE_NOFOCUS;
        }
        if (fActivate) 
        {
            GetClientRect(pView->_hwndView, &rcView);
            hr = _pOleObj->DoVerb(iVerb, pMsg,
                &_cSite, (UINT)-1, pView->_hwndView, &rcView);
        }
        else 
        {
            IOleInPlaceObject *pipo;
            hr = _pOleObj->QueryInterface(IID_PPV_ARG(IOleInPlaceObject, &pipo));
            if (SUCCEEDED(hr)) 
            {
                hr = pipo->UIDeactivate();
                pipo->Release();
            }
        }

        ASSERT(SUCCEEDED(hr));
        ASSERT(_uState == (UINT)(fActivate ? SVUIA_ACTIVATE_FOCUS : SVUIA_ACTIVATE_NOFOCUS));
        TraceMsg(TF_FOCUS, "sfvf._uiaio(fAct=%d) ExtView DoVerb S_OK", fActivate);
        hr = S_OK;
    }
    else
    {
        TraceMsg(TF_FOCUS, "sfvf._uiaio(fAct=%d) else S_FALSE", fActivate);
        hr = S_FALSE;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\sfvcmpt.cpp ===
#include "shellprv.h"
#include <shellp.h>
#include <sfview.h>
#include "basefvcb.h"
#include "ids.h"
#include "prop.h"

CBaseShellFolderViewCB::CBaseShellFolderViewCB(LPCITEMIDLIST pidl, LONG lEvents)
    : _cRef(1), _hwndMain(NULL), _lEvents(lEvents)
{
    _pidl = ILClone(pidl);
}

CBaseShellFolderViewCB::~CBaseShellFolderViewCB()
{
    ILFree(_pidl);    // accpets NULL
}

STDMETHODIMP CBaseShellFolderViewCB::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBaseShellFolderViewCB, IShellFolderViewCB),   // IID_IShellFolderViewCB
        QITABENT(CBaseShellFolderViewCB, IObjectWithSite),      // IID_IObjectWithSite
        QITABENT(CBaseShellFolderViewCB, IServiceProvider),     // IID_IServiceProvider
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CBaseShellFolderViewCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBaseShellFolderViewCB::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CBaseShellFolderViewCB::MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = RealMessage(uMsg, wParam, lParam);
    if (FAILED(hr))
    {
        switch (uMsg)
        {
        case SFVM_HWNDMAIN:
            _hwndMain = (HWND)lParam;
            hr = S_OK;
            break;

        case SFVM_GETNOTIFY:
            *(LPCITEMIDLIST*)wParam = _pidl;
            *(LONG*)lParam = _lEvents;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

class CWrapOldCallback : public CBaseShellFolderViewCB
{
public:
    CWrapOldCallback(LPCSFV pcsfv);

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);

private:
    ~CWrapOldCallback();

    LPFNVIEWCALLBACK _pfnCB;
    IShellView* _psvOuter;
    IShellFolder *_psf;

    UINT _fvm;
    LPARAM _lSelChangeInfo;
};

CWrapOldCallback::CWrapOldCallback(LPCSFV pcsfv) : CBaseShellFolderViewCB(pcsfv->pidl, pcsfv->lEvents)
{
    _psf = pcsfv->pshf;
    _psf->AddRef();
    _psvOuter  = pcsfv->psvOuter;
    _fvm = pcsfv->fvm;
    _pfnCB = pcsfv->pfnCallback;
}

CWrapOldCallback::~CWrapOldCallback()
{
    _psf->Release();
}

// Some older clients may not support IObjectWithSite::SetSite
// For compat send them the old SFVM_SETISFV message
HRESULT CWrapOldCallback::SetSite(IUnknown *punkSite)
{
    HRESULT hr = CBaseShellFolderViewCB::SetSite( punkSite );
    MessageSFVCB( SFVM_SETISFV, 0, (LPARAM)punkSite );
    return hr;
}


STDMETHODIMP CWrapOldCallback::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DVSELCHANGEINFO dvsci;

    switch (uMsg)
    {
    case SFVM_DEFVIEWMODE:
        if (_fvm)
            *(UINT*)lParam = _fvm;
        break;

    case SFVM_SELCHANGE:
    {
        SFVM_SELCHANGE_DATA* pSelChange = (SFVM_SELCHANGE_DATA*)lParam;

        dvsci.uNewState = pSelChange->uNewState;
        dvsci.uOldState = pSelChange->uOldState;
        dvsci.plParam = &_lSelChangeInfo;
        dvsci.lParamItem = pSelChange->lParamItem;
        lParam = (LPARAM)&dvsci;
        break;
    }

    case SFVM_INSERTITEM:
    case SFVM_DELETEITEM:
    case SFVM_WINDOWCREATED:
        dvsci.plParam = &_lSelChangeInfo;
        dvsci.lParamItem = lParam;
        lParam = (LPARAM)&dvsci;
        break;

    case SFVM_REFRESH:
    case SFVM_SELECTALL:
    case SFVM_UPDATESTATUSBAR:
    case SFVM_SETFOCUS:
    case SFVM_PRERELEASE:
        lParam = _lSelChangeInfo;
        break;

    default:
        break;
    }

    // NOTE: The DVM_ messages are the same as the SFVM_ message
    return _pfnCB(_psvOuter, _psf, _hwndMain, uMsg, wParam, lParam);
}

LRESULT _ShellFolderViewMessage(IShellFolderView* psfv, UINT uMsg, LPARAM lParam)
{
    UINT uScratch;

    switch (uMsg)
    {
    case SFVM_REARRANGE:
        psfv->Rearrange(lParam);
        break;

    case SFVM_ARRANGEGRID:
        psfv->ArrangeGrid();
        break;

    case SFVM_AUTOARRANGE:
        psfv->AutoArrange();
        break;

    case SFVM_GETAUTOARRANGE:
        return psfv->GetAutoArrange() == S_OK;

    case SFVM_GETARRANGEPARAM:
        psfv->GetArrangeParam(&lParam);
        return lParam;

    case SFVM_ADDOBJECT:
        if (SUCCEEDED(psfv->AddObject((LPITEMIDLIST)lParam, &uScratch))
             && (int)uScratch >= 0)
        {
            // New semantics make a copy of the IDList
            ILFree((LPITEMIDLIST)lParam);
            return uScratch;
        }
        return -1;

    case SFVM_GETOBJECTCOUNT:
        return SUCCEEDED(psfv->GetObjectCount(&uScratch)) ? uScratch : -1;

    case SFVM_GETOBJECT:
    {
        LPITEMIDLIST pidl;

        return SUCCEEDED(psfv->GetObject(&pidl, (UINT)lParam)) ? (LPARAM)pidl : NULL;
    }

    case SFVM_REMOVEOBJECT:
        return SUCCEEDED(psfv->RemoveObject((LPITEMIDLIST)lParam, &uScratch)) ? uScratch : -1;

    case SFVM_UPDATEOBJECT:
    {
        LPITEMIDLIST *ppidl = (LPITEMIDLIST*)lParam;

        if (SUCCEEDED(psfv->UpdateObject(ppidl[0], ppidl[1], &uScratch))
            && (int)uScratch >= 0)
        {
            // New semantics make a copy of the IDList
            ILFree(ppidl[1]);
            return uScratch;
        }
        return -1;
    }

    case SFVM_REFRESHOBJECT:
    {
        LPITEMIDLIST *ppidl = (LPITEMIDLIST*)lParam;

        return SUCCEEDED(psfv->RefreshObject(ppidl[0], &uScratch)) ? uScratch : -1;
    }

    case SFVM_SETREDRAW:
        psfv->SetRedraw(BOOLFROMPTR(lParam));
        break;

    case SFVM_GETSELECTEDOBJECTS:
        return SUCCEEDED(psfv->GetSelectedObjects((LPCITEMIDLIST**)lParam, &uScratch)) ? uScratch : -1;

    case SFVM_GETSELECTEDCOUNT:
        return SUCCEEDED(psfv->GetSelectedCount(&uScratch)) ? uScratch : -1;

    case SFVM_ISDROPONSOURCE:
        return psfv->IsDropOnSource((IDropTarget *)lParam) == S_OK;

    case SFVM_MOVEICONS:
        psfv->MoveIcons((IDataObject *)lParam);
        break;

    case SFVM_GETDROPPOINT:
        return psfv->GetDropPoint((POINT *)lParam) == S_OK;

    case SFVM_GETDRAGPOINT:
        return psfv->GetDragPoint((POINT *)lParam) == S_OK;

    case SFVM_SETITEMPOS:
    {
        SFV_SETITEMPOS* psip = (SFV_SETITEMPOS*)lParam;
        psfv->SetItemPos(psip->pidl, &psip->pt);
        break;
    }

    case SFVM_ISBKDROPTARGET:
        return psfv->IsBkDropTarget((IDropTarget *)lParam) == S_OK;

    case SFVM_SETCLIPBOARD:
        psfv->SetClipboard(lParam == DFM_CMD_MOVE);
        break;

    case SFVM_SETPOINTS:
        psfv->SetPoints((IDataObject *)lParam);
        return 0;

    case SFVM_GETITEMSPACING:
        return psfv->GetItemSpacing((LPITEMSPACING)lParam) == S_OK;

    default:
        // -1L is the default return value
        return 0;
    }

    return 1;
}

IShellFolderView* ShellFolderViewFromWindow(HWND hwnd)
{
    IShellFolderView* psfv = NULL;

    // HPCView sometimes gets confused and passes HWND_BROADCAST as its
    // window.  We can't let this reach FileCabinet_GetIShellBrowser or
    // we end up broadcasting the CWM_GETISHELLBROWSER message and screwing
    // up everybody in the system.  (Not to mention that it will return TRUE,
    // indicating a successful broadcast, and then we fault thinking that
    // it's a vtbl.)

    if (hwnd && hwnd != HWND_BROADCAST)
    {
        IShellBrowser* psb = FileCabinet_GetIShellBrowser(hwnd);

        // Use !IS_INTRESOURCE() to protect against blatanly bogus values
        // that clearly aren't pointers to objects.
        if (!IS_INTRESOURCE(psb))
        {
            IShellView* psv;
            if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
            {
                psv->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv));
                psv->Release();
            }
        }
    }
    return psfv;
}

STDAPI_(HWND) ShellFolderViewWindow(HWND hwnd)
{
    HWND hwndRet = NULL;
    IShellBrowser *psb = FileCabinet_GetIShellBrowser(hwnd);
    if (psb)
    {
        IShellView *psv;
        if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
        {
            IUnknown_GetWindow(psv, &hwndRet);
            psv->Release();
        }
    }
    return hwndRet;
}

// undoced shell32 export
STDAPI_(IShellFolderViewCB *) SHGetShellFolderViewCB(HWND hwnd)
{
    ASSERT(0);
    return NULL;    // no one calls this (search of the NT code finds no callers)
}

// old msg based way of programming defview (pre dates IShellFolderView)

STDAPI_(LRESULT) SHShellFolderView_Message(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    LRESULT lret = 0;
    IShellFolderView* psfv = ShellFolderViewFromWindow(hwnd);
    if (psfv)
    {
        lret = _ShellFolderViewMessage(psfv, uMsg, lParam);
        psfv->Release();
    }
    return lret;
}


STDAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, IShellView **ppsv)
{
    SFV_CREATE sfvc;

    sfvc.cbSize = sizeof(sfvc);
    sfvc.pshf = pcsfv->pshf;
    sfvc.psvOuter = pcsfv->psvOuter;

    sfvc.psfvcb = pcsfv->pfnCallback ? new CWrapOldCallback(pcsfv) : NULL;

    HRESULT hr = SHCreateShellFolderView(&sfvc, ppsv);

    if (sfvc.psfvcb)
        sfvc.psfvcb->Release();

    return hr;
}

STDAPI_(void) InitializeStatus(IUnknown *psite)
{
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        LONG_PTR nParts = 0, n;

        psb->SendControlMsg(FCW_STATUS, SB_GETPARTS, 0, 0, &nParts);

        for (n = 0; n < nParts; n ++)
        {
            psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, n, (LPARAM)TEXT(""), NULL);
            psb->SendControlMsg(FCW_STATUS, SB_SETICON, n, (LPARAM)NULL, NULL);
        }
        psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, 0, 0, NULL);
        psb->Release();
    }
}

//
//  The status bar partitioning has undergone several changes.  Here's
//  what we've got right now:
//
//      Pane 0 = Selection - all remaining space
//      Pane 1 = Size      - just big enough to say 9,999 bytes (11 chars)
//      Pane 2 = Zone      - just big enough to hold longest zone
//

STDAPI_(void) ResizeStatus(IUnknown *psite, UINT cx)
{
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        HWND hwndStatus;
        if (SUCCEEDED(psb->GetControlWindow(FCW_STATUS, &hwndStatus)) && hwndStatus)
        {
            RECT rc;
            int ciParts[3];
            int ciBorders[3];
            int cxPart;
            GetClientRect(hwndStatus, &rc);

            // Must also take status bar borders into account.
            psb->SendControlMsg(FCW_STATUS, SB_GETBORDERS, 0, (LPARAM)ciBorders, NULL);

            // We build the panes from right to left.
            ciParts[2] = -1;

            // The Zones part
            cxPart = ciBorders[0] + ZoneComputePaneSize(hwndStatus) + ciBorders[2];
            ciParts[1] = rc.right - cxPart;

            // The Size part
            HDC hdc = GetDC(hwndStatus);
            HFONT hfPrev = SelectFont(hdc, GetWindowFont(hwndStatus));
            SIZE siz;
            GetTextExtentPoint32(hdc, TEXT("0"), 1, &siz);
            SelectObject(hdc, hfPrev);
            ReleaseDC(hwndStatus, hdc);
            
            cxPart = ciBorders[0] + siz.cx * (11 + 2); // "+2" for slop
            ciParts[0] = ciParts[1] - cxPart;

            //
            //  If we underflowed, then give up and just give everybody
            //  one third.
            //
            if (ciParts[0] < 0)
            {
                ciParts[0] = rc.right / 3;
                ciParts[1] = 2 * ciParts[0];
            }

            psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts, NULL);
        }
        psb->Release();
    }
}

STDAPI_(void) SetStatusText(IUnknown *psite, LPCTSTR *ppszText, int iStart, int iEnd)
{
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        for (; iStart <= iEnd; iStart++) 
        {
            LPCTSTR psz;

            if (ppszText) 
            {
                psz = *ppszText;
                ppszText++;
            } 
            else 
                psz = c_szNULL;

            psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, (WPARAM)iStart, (LPARAM)psz, NULL);
        }
        psb->Release();
    }
}

STDAPI_(void) ViewShowSelectionState(IUnknown *psite, FSSELCHANGEINFO *pfssci)
{
    TCHAR szTemp[20], szBytes[30];
    LPTSTR pszStatus = NULL;

    if (pfssci->nItems > 1)
    {
        pszStatus = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FSSTATUSSELECTED),
                            AddCommas(pfssci->nItems, szTemp, ARRAYSIZE(szTemp)));
    }

    if (pfssci->cNonFolders)
        ShortSizeFormat64(pfssci->cbBytes, szBytes, ARRAYSIZE(szBytes));
    else
        szBytes[0] = 0;

    LPCTSTR rgpsz[] = { pszStatus, szBytes };
    SetStatusText(psite, rgpsz, 0, 1);

    if (pszStatus)
        LocalFree(pszStatus);
}

HRESULT _UpdateDiskFreeSpace(LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci)
{
    IShellFolder2 *psf2;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidlFolder, IID_PPV_ARG(IShellFolder2, &psf2), &pidlLast);
    if (SUCCEEDED(hr))
    {
        ULONGLONG ullTotalFreeCaller;
        hr = GetLongProperty(psf2, pidlLast, &SCID_FREESPACE, &ullTotalFreeCaller);
        if (SUCCEEDED(hr))
        {
            pfssci->cbFree = ullTotalFreeCaller;
        }
        else if (!ILIsEmpty(pidlFolder) && !ILIsEmpty(_ILNext(pidlFolder)))
        {
            // if there are at least 2 segments in the IDList rip off the
            // last item and recurse to compute the size
            LPITEMIDLIST pidl = ILCloneParent(pidlFolder);
            if (pidl)
            {
                hr = _UpdateDiskFreeSpace(pidl, pfssci);
                ILFree(pidl);
            }
        }
        psf2->Release();
    }
    return hr;
}

void _ShowNoSelectionState(IUnknown *psite, LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci)
{
    TCHAR szTemp[30], szTempHidden[30], szFreeSpace[30];
    UINT ids = IDS_FSSTATUSBASE;

    // Assume we don't need freespace info
    szFreeSpace[0] = 0;

    // See if we need the freespace info (idDrive != -1)
    ULONGLONG cbFree = -1;
    if (pidlFolder && IsExplorerModeBrowser(psite))
    {
        if (pfssci->cbFree == -1)
            _UpdateDiskFreeSpace(pidlFolder, pfssci);

        // cbFree couldstill be -1 if GetDiskFreeSpace didn't get any info
        cbFree = pfssci->cbFree;
        if (cbFree != -1)
        {
            ShortSizeFormat64(pfssci->cbFree, szFreeSpace, ARRAYSIZE(szFreeSpace));
            ids += DIDS_FSSPACE;            // Also show freespace
        }
    }

    // hidden files -> show "and nn hidden".
    if (pfssci->cHiddenFiles)
        ids += DIDS_FSHIDDEN;

    // Get the status string
    LPTSTR pszStatus = ShellConstructMessageString(HINST_THISDLL, IntToPtr_(LPCTSTR, ids),
                AddCommas(pfssci->cFiles, szTemp, ARRAYSIZE(szTemp)),
                AddCommas(pfssci->cHiddenFiles, szTempHidden, ARRAYSIZE(szTempHidden)),
                szFreeSpace);

    // Get the size portion
    StrFormatByteSize64(pfssci->cbSize, szTemp, ARRAYSIZE(szTemp));

    LPCTSTR rgpsz[] = { pszStatus, szTemp };
    SetStatusText(psite, rgpsz, 0, 1);

    LocalFree(pszStatus);   // may be NULL
}

STDAPI ViewUpdateStatusBar(IUnknown *psite, LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci)
{
    HRESULT hr = S_OK;
    switch (pfssci->nItems)
    {
    case 0:
        _ShowNoSelectionState(psite, pidlFolder, pfssci);
        hr = S_OK;
        break;

    case 1:
        ViewShowSelectionState(psite, pfssci); //Set the Size only.
        hr = SFVUSB_INITED;   // Make defview set infotip as text
        break;

    default:
        ViewShowSelectionState(psite, pfssci);
        hr = S_OK;
        break;
    }
    return hr;
}

STDAPI_(void) ViewInsertDeleteItem(IShellFolder2 *psf, FSSELCHANGEINFO *pfssci, LPCITEMIDLIST pidl, int iMul)
{
    ULONGLONG ullSize;
    if (SUCCEEDED(GetLongProperty(psf, pidl, &SCID_SIZE, &ullSize)))
    {
        pfssci->cFiles += iMul;
        pfssci->cbSize += iMul * ullSize;
        if (pfssci->cFiles <= 0)
        {
            pfssci->cbSize = 0;
            pfssci->cFiles = 0;
        }
    } 
    else 
    {
        // means a delete all
        pfssci->cFiles = 0;
        pfssci->cbSize = 0;
        pfssci->nItems = 0;
        pfssci->cbBytes = 0;
        pfssci->cNonFolders = 0;
        pfssci->cHiddenFiles = 0;
    }
}

STDAPI_(void) ViewSelChange(IShellFolder2 *psf, SFVM_SELCHANGE_DATA* pdvsci, FSSELCHANGEINFO *pfssci)
{
    ULONGLONG ullSize;
    LPCITEMIDLIST pidl = (LPCITEMIDLIST)pdvsci->lParamItem;
    if (SUCCEEDED(GetLongProperty(psf, pidl, &SCID_SIZE, &ullSize)))
    {
        int iMul = -1;

        // Update selection count
        if (pdvsci->uNewState & LVIS_SELECTED)
            iMul = 1;
        else
            ASSERT(0 != pfssci->nItems);

        // assert that soemthing changed
        ASSERT((pdvsci->uOldState & LVIS_SELECTED) != (pdvsci->uNewState & LVIS_SELECTED));

        pfssci->nItems += iMul;

        pfssci->cbBytes += (iMul * ullSize);
        if (!SHGetAttributes(psf, pidl, SFGAO_FOLDER))
            pfssci->cNonFolders += iMul;
    }
}

STDAPI DefaultGetWebViewTemplateFromHandler(LPCTSTR pszKey, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    HRESULT hr = S_OK;

    TCHAR szKey[200];
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}"), pszKey);

    DWORD cbSize = sizeof(pvit->szWebView);
    if (ERROR_SUCCESS == SHGetValueW(HKEY_CLASSES_ROOT, szKey, TEXT("PersistMoniker"), NULL, pvit->szWebView, &cbSize))
    {
        //if the %UserAppData% exists, expand it!
        ExpandOtherVariables(pvit->szWebView, ARRAYSIZE(pvit->szWebView));
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI DefaultGetWebViewTemplateFromClsid(REFCLSID clsid, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    TCHAR szHandler[6+40] = TEXT("CLSID\\"); // 6 for "CLSID\\", 40 for GUID
    SHStringFromGUID(clsid, &szHandler[6], ARRAYSIZE(szHandler)-6);
    return DefaultGetWebViewTemplateFromHandler(szHandler, pvit);
}

STDAPI DefaultGetWebViewTemplateFromPath(LPCTSTR pszDir, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    TCHAR szPath[MAX_PATH+40]; // slop for "webview://file://"
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_WEBVIEWTEMPLATE;
    fcs.pszWebViewTemplate = szPath;
    fcs.cchWebViewTemplate = ARRAYSIZE(szPath);
    HRESULT hr = SHGetSetFolderCustomSettings(&fcs, pszDir, FCS_READ);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszPath = szPath;
        // We want to allow relative paths for the file: protocol
        //
        if (0 == StrCmpNI(TEXT("file://"), pszPath, 7)) // ARRAYSIZE(TEXT("file://"))
        {
            pszPath += 7;   // ARRAYSIZE(TEXT("file://"))
        }
        // for webview:// compatibility, keep this working:
        else if (0 == StrCmpNI(TEXT("webview://file://"), pszPath, 17)) // ARRAYSIZE(TEXT("webview://file://"))
        {
            pszPath += 17;  // ARRAYSIZE(TEXT("webview://file://"))
        }
        // handle relative references...
        PathCombine(pszPath, pszDir, pszPath);

        StrCpyN(pvit->szWebView, szPath, ARRAYSIZE(pvit->szWebView));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shcombox.h ===
// shcombox.h : Shared shell comboboxEx methods

#ifndef __SHCOMBOX_H__
#define __SHCOMBOX_H__

//  COMBOITEMEX wrap with string storage.
typedef struct
{
    UINT    mask;
    INT_PTR iItem;
    TCHAR   szText[MAX_PATH] ;
    int     cchTextMax;
    int     iImage;
    int     iSelectedImage;
    int     iOverlay;
    int     iIndent;
    int     iID;  // application-specific item identifier.
    ULONG   Reserved; 
    LPARAM  lParam;

} CBXITEM, *PCBXITEM;
typedef CBXITEM CONST *PCCBXITEM;

//  ADDCBXITEMCALLBACK fAction flags
#define CBXCB_ADDING       0x00000001     // if callback returns E_ABORT, combo population aborts
#define CBXCB_ADDED        0x00000002     // callback's return value is ignored.

//  SendMessageTimeout constants
#define CBX_SNDMSG_TIMEOUT_FLAGS          SMTO_BLOCK
#define CBX_SNDMSG_TIMEOUT                15000 // milliseconds
#define CBX_SNDMSG_TIMEOUT_HRESULT        HRESULT_FROM_WIN32(ERROR_TIMEOUT)

//  Misc constants
#define NO_ITEM_NOICON_INDENT -2 // -1 to make up for the icon indent.
#define NO_ITEM_INDENT       0
#define ITEM_INDENT          1

#define LISTINSERT_FIRST    0
#define LISTINSERT_LAST     -1

#ifdef __cplusplus
extern "C"
{
#endif

//  General shell comboboxex methods
typedef HRESULT (WINAPI *LPFNPIDLENUM_CB)(LPCITEMIDLIST, void *);
typedef HRESULT (WINAPI *ADDCBXITEMCALLBACK)(ULONG fAction, PCBXITEM pItem, LPARAM lParam);

STDAPI AddCbxItemToComboBox(IN HWND hwndComboEx, IN PCCBXITEM pItem, IN INT_PTR *pnPosAdded);
STDAPI AddCbxItemToComboBoxCallback(IN HWND hwndComboEx, IN OUT PCBXITEM pItem, IN ADDCBXITEMCALLBACK pfn, IN LPARAM lParam);
STDAPI_(void) MakeCbxItem(OUT PCBXITEM pcbi, IN  LPCTSTR pszDisplayName, IN  void *pvData, IN  LPCITEMIDLIST pidlIcon, IN  INT_PTR nPos, IN  int iIndent);
STDAPI EnumSpecialItemIDs(int csidl, DWORD dwSHCONTF, LPFNPIDLENUM_CB pfn, void *pvData);

STDAPI_(HIMAGELIST) GetSystemImageListSmallIcons();

// local drive picker combo methods
STDAPI PopulateLocalDrivesCombo(IN HWND hwndComboEx, IN ADDCBXITEMCALLBACK pfn, IN LPARAM lParam);

//  helpers (note: once all dependents are brought into line using the above methods, we can eliminate
//  decl of the following:
typedef HRESULT (*LPFNRECENTENUM_CB)(IN LPCTSTR pszPath, IN BOOL fAddEntries, IN void *pvParam);

//  File Associations picker combo methods.
STDAPI PopulateFileAssocCombo(IN HWND, IN ADDCBXITEMCALLBACK, IN LPARAM);
STDAPI_(LONG) GetFileAssocComboSelItemText(IN HWND, OUT LPTSTR *ppszText);
STDAPI_(LRESULT) DeleteFileAssocComboItem(IN LPNMHDR pnmh);

#define FILEASSOCIATIONSID_ALLFILETYPES          20
#define FILEASSOCIATIONSID_FILE_PATH             1   // Go parse it.
#define FILEASSOCIATIONSID_MAX                   FILEASSOCIATIONSID_ALLFILETYPES

#ifdef __cplusplus
}
#endif

#endif __SHCOMBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shared.c ===
#include "shellprv.h"
#pragma  hdrstop

//---------------------------------------------------------------------------
// SHAllocShared  - Allocates a handle (in a given process) to a copy of a
//                  memory block in this process.
// SHFreeShared   - Releases the handle (and the copy of the memory block)
//
// SHLockShared   - Maps a handle (from a given process) into a memory block
//                  in this process.  Has the option of transfering the handle
//                  to this process, thereby deleting it from the given process
// SHUnlockShared - Opposite of SHLockShared, unmaps the memory block
//---------------------------------------------------------------------------

HANDLE _SHAllocShared(LPCVOID pvData, DWORD dwSize, DWORD dwDestinationProcessId) 
{
    return SHAllocShared(pvData, dwSize, dwDestinationProcessId);
}

void *_SHLockShared(HANDLE hData, DWORD dwSourceProcessId) 
{
    return SHLockShared(hData, dwSourceProcessId);
}

BOOL _SHUnlockShared(void * pvData) 
{
    return SHUnlockShared(pvData);
}

BOOL _SHFreeShared(HANDLE hData, DWORD dwSourceProcessId) 
{
    return SHFreeShared(hData, dwSourceProcessId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shapi.cpp ===
#include "shellprv.h"
#include "util.h"

#include "ids.h"
#include "ole2dup.h"
#include "datautil.h"
#include "filetbl.h"
#include "copy.h"
#include "prop.h"
#include <pif.h>
#include "fstreex.h"    // GetIconOverlayManager()
#include <runtask.h>

extern void PathStripTrailingDots(LPTSTR szPath);

HRESULT IExtractIcon_Extract(IExtractIcon *pei, LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    // wrapper to let us ask an IExtractIcon for only one icon (the large one)
    // since many implementations will fault if you pass NULL phiconSmall

    HICON hiconDummy;
    if (phiconSmall == NULL)
    {
        phiconSmall = &hiconDummy;
        nIconSize = MAKELONG(nIconSize, nIconSize);
    }

    HRESULT hr = pei->Extract(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    if (hr == S_OK && phiconSmall == &hiconDummy)
    {
        DestroyIcon(hiconDummy);
    }
    return hr;
}

HRESULT IExtractIconA_Extract(IExtractIconA *peia, LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    // wrapper to let us ask an IExtractIcon for only one icon (the large one)
    // since many dudes don't check for NULL phiconSmall

    HICON hiconDummy;
    if (phiconSmall == NULL)
    {
        phiconSmall = &hiconDummy;
        nIconSize = MAKELONG(nIconSize, nIconSize);
    }

    HRESULT hr = peia->Extract(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    if (hr == S_OK && phiconSmall == &hiconDummy)
    {
        DestroyIcon(hiconDummy);
    }
    return hr;
}

//  try to figure out if this is an icon already
//  in our system image list, so that we dont re-add
BOOL _HijackOfficeIcons(HICON hLarge, int iIndex)
{
    BOOL fRet = FALSE;
    HIMAGELIST himl;
    ASSERT(hLarge);
    if (Shell_GetImageLists(NULL, &himl))
    {
        HICON hMaybe = ImageList_GetIcon(himl, iIndex, 0);
        if (hMaybe)
        {
            fRet = SHAreIconsEqual(hLarge, hMaybe);
            DestroyIcon(hMaybe);
        }
    }

#ifdef DEBUG
    if (!fRet)
        TraceMsg(TF_WARNING, "_HijackOfficeIcons() called in suspicious circumstance");
#endif        

    return fRet;
}

HRESULT _GetILIndexGivenPXIcon(IExtractIcon *pxicon, UINT uFlags, LPCITEMIDLIST pidl, int *piImage, BOOL fAnsiCrossOver)
{
    TCHAR szIconFile[MAX_PATH];
    CHAR szIconFileA[MAX_PATH];
    IExtractIconA *pxiconA = (IExtractIconA *)pxicon;
    int iIndex;
    int iImage = -1;
    UINT wFlags=0;
    HRESULT hr;

    if (fAnsiCrossOver)
    {
        szIconFileA[0] = 0;
        hr = pxiconA->GetIconLocation(uFlags | GIL_FORSHELL,
                    szIconFileA, ARRAYSIZE(szIconFileA), &iIndex, &wFlags);
        SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
    }
    else
    {
        szIconFile[0] = '\0';
        hr = pxicon->GetIconLocation(uFlags | GIL_FORSHELL,
                    szIconFile, ARRAYSIZE(szIconFile), &iIndex, &wFlags);
    }

    //
    //  "*" as the file name means iIndex is already a system
    //  icon index, we are done.
    //
    //  this is a hack for our own internal icon handler
    //
    if (SUCCEEDED(hr) && (wFlags & GIL_NOTFILENAME) &&
        szIconFile[0] == TEXT('*') && szIconFile[1] == 0)
    {
        *piImage = iIndex;
        return hr;
    }

    // Do not replace this with SUCCEEDED(hr). hr = S_FALSE means we need to use a default icon.
    if (hr == S_OK)
    {
        // If we have it in shell32, don't delay the extraction
        if (!(wFlags & GIL_NOTFILENAME) && lstrcmpi(PathFindFileName(szIconFile), c_szShell32Dll) == 0)
        {
            iImage = Shell_GetCachedImageIndex(szIconFile, iIndex, wFlags);
        }
        else
        {
            //
            // if GIL_DONTCACHE was returned by the icon handler, dont
            // lookup the previous icon, assume a cache miss.
            //
            if (!(wFlags & GIL_DONTCACHE) && *szIconFile)
            {
                iImage = LookupIconIndex(szIconFile, iIndex, wFlags);
            }
        }
    }

    // if we miss our cache...
    if (iImage == -1 && hr != S_FALSE)
    {
        if (uFlags & GIL_ASYNC)
        {
            // If we couldn't get the final icon, try to get a good temporary one
            if (fAnsiCrossOver)
            {
                szIconFileA[0] = 0;
                hr = pxiconA->GetIconLocation(uFlags | GIL_FORSHELL | GIL_DEFAULTICON,
                            szIconFileA, ARRAYSIZE(szIconFileA), &iIndex, &wFlags);
                SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
            }
            else
            {
                hr = pxicon->GetIconLocation(uFlags | GIL_FORSHELL | GIL_DEFAULTICON,
                            szIconFile, ARRAYSIZE(szIconFile), &iIndex, &wFlags);
            }
            if (hr == S_OK)
            {
                iImage = LookupIconIndex(szIconFile, iIndex, wFlags);
            }

            // When all else fails...
            if (iImage == -1)
            {
                iImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);
            }

            // force a lookup incase we are not in explorer.exe
            *piImage = iImage;
            return E_PENDING;
        }

        // try getting it from the ExtractIcon member fuction
        HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};
        BOOL fHandlerOk = FALSE;

        for (int i = 0; i < ARRAYSIZE(g_rgshil); i += 2)
        {
            // Ask for two at a time because
            //
            // (a) it's slightly more efficient, and
            //
            // (b) otherwise we break compatibility with IExtractIcon::Extract
            //     implementions which ignore the size parameter (the Network
            //     Connections folder is one).  The SHIL_'s are conveniently
            //     arranged in large/small alternating order for this purpose.
            //
            HICON *phiconSmall = NULL;

            HICON *phiconLarge = &rghicon[i];
            UINT nIconSize = g_rgshil[i].size.cx;

            if (i + 1 < ARRAYSIZE(g_rgshil))
            {
                phiconSmall = &rghicon[i+1];
                nIconSize = MAKELONG(nIconSize, g_rgshil[i+1].size.cx);
            }

            if (fAnsiCrossOver)
            {
                hr = IExtractIconA_Extract(pxiconA, szIconFileA, iIndex,
                    phiconLarge, phiconSmall, nIconSize);
            }
            else
            {
                hr = IExtractIcon_Extract(pxicon, szIconFile, iIndex,
                    phiconLarge, phiconSmall, nIconSize);
            }
            // S_FALSE means, can you please do it...Thanks

            if (hr == S_FALSE && !(wFlags & GIL_NOTFILENAME))
            {
                hr = SHDefExtractIcon(szIconFile, iIndex, wFlags,
                    phiconLarge, phiconSmall, nIconSize);
            }
            if (SUCCEEDED(hr))
            {
                fHandlerOk = TRUE;
            }
        }

        //  our belief knows no bounds
        if (!*szIconFile && rghicon[1] && iIndex > 0 && _HijackOfficeIcons(rghicon[1], iIndex))
        {
            //  it lives!
            iImage = iIndex;
        }
        else
        {
            //  if we extracted a icon add it to the cache.
            iImage = SHAddIconsToCache(rghicon, szIconFile, iIndex, wFlags);
        }

        _DestroyIcons(rghicon, ARRAYSIZE(rghicon));

        // if we failed in any way pick a default icon

        if (iImage == -1)
        {
            if (wFlags & GIL_SIMULATEDOC)
            {
                iImage = II_DOCUMENT;
            }
            else if ((wFlags & GIL_PERINSTANCE) && PathIsExe(szIconFile))
            {
                iImage = II_APPLICATION;
            }
            else
            {
                iImage = II_DOCNOASSOC;
            }

            // force a lookup incase we are not in explorer.exe
            iImage = Shell_GetCachedImageIndex(c_szShell32Dll, iImage, 0);

            // if the handler failed dont cache this default icon.
            // so we will try again later and maybe get the right icon.
            // handlers should only fail if they cant access the file
            // or something equally bad.
            //
            // if the handler succeeded then go ahead and assume this is
            // a usable icon, we must be in some low memory situation, or
            // something.  So keep mapping to the same shell icon.
            //
            if (fHandlerOk)
            {
                if (iImage != -1 && *szIconFile && !(wFlags & (GIL_DONTCACHE | GIL_NOTFILENAME)))
                {
                    AddToIconTable(szIconFile, iIndex, wFlags, iImage);
                }
            }
            else
            {
                TraceMsg(TF_DEFVIEW, "not caching icon for '%s' because cant access file", szIconFile);
            }
        }
    }

    if (iImage < 0)
    {
        iImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);
    }

    *piImage = iImage;
    return hr;
}

// given an IShellFolder and and an Idlist that is
// contained in it, get back the index into the system image list.

STDAPI SHGetIconFromPIDL(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, int *piImage)
{
    HRESULT hr;

    if (psi)
    {
#ifdef DEBUG
        *piImage = -1;
#endif
        hr = psi->GetIconOf(pidl, flags, piImage);

        if (hr == S_OK)
        {
            ASSERT(*piImage != -1);
            return hr;
        }

        if (hr == E_PENDING)
        {
            ASSERT(flags & GIL_ASYNC);
            ASSERT(*piImage != -1);
            return hr;
        }
    }

    *piImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);

    // Be careful.  Some shellfolders erroneously return S_OK when they fail
    IExtractIcon *pxi = NULL;
    hr = psf->GetUIObjectOf(NULL, pidl ? 1 : 0, pidl ? &pidl : NULL, IID_PPV_ARG_NULL(IExtractIcon, &pxi));
    if (SUCCEEDED(hr) && pxi)
    {
        hr = _GetILIndexGivenPXIcon(pxi, flags, pidl, piImage, FALSE);
        pxi->Release();
    }
    else
    {
        // Try the ANSI interface, see if we are dealing with an old set of code
        IExtractIconA *pxiA = NULL;
        hr = psf->GetUIObjectOf(NULL, pidl ? 1 : 0, pidl ? &pidl : NULL, IID_PPV_ARG_NULL(IExtractIconA, &pxiA));
        if (SUCCEEDED(hr))
        {
            if (pxiA)
            {
                hr = _GetILIndexGivenPXIcon((IExtractIcon *)pxiA, flags, pidl, piImage, TRUE);
                pxiA->Release();
            }
            else
            {
                // IShellFolder lied to us - returned S_OK even though it failed
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


// given an IShellFolder and and an Idlist that is
// contained in it, get back the index into the system image list.

STDAPI_(int) SHMapPIDLToSystemImageListIndex(IShellFolder *psf, LPCITEMIDLIST pidl, int *piIndexSel)
{
    int iIndex;

    if (piIndexSel)
    {
        SHGetIconFromPIDL(psf, NULL, pidl, GIL_OPENICON, piIndexSel);
    }

    SHGetIconFromPIDL(psf, NULL, pidl,  0, &iIndex);
    return iIndex;
}


class CGetIconTask : public CRunnableTask
{
public:
    STDMETHODIMP RunInitRT(void);

    CGetIconTask(HRESULT *phr, IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, BOOL fGetOpenIcon,
                 PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint);
protected:
    ~CGetIconTask();

    IShellFolder *_psf;
    IShellIcon *_psi;
    LPITEMIDLIST _pidl;
    UINT _flags;
    BOOL _fGetOpenIcon;
    PFNASYNCICONTASKBALLBACK _pfn;
    void *_pvData;
    void *_pvHint;
};

CGetIconTask::CGetIconTask(HRESULT *phr, IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, BOOL fGetOpenIcon,
                           PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint) : 
    CRunnableTask(RTF_DEFAULT), _psf(psf), _psi(psi), _flags(flags), _fGetOpenIcon(fGetOpenIcon), _pfn(pfn), _pvData(pvData), _pvHint(pvHint)
{
    *phr = SHILClone(pidl, &_pidl);

    _psf->AddRef();

    if (_psi)
        _psi->AddRef();
}

CGetIconTask::~CGetIconTask()
{
    ILFree(_pidl);
    _psf->Release();

    if (_psi)
        _psi->Release();
}

STDMETHODIMP CGetIconTask::RunInitRT()
{
    int iIcon = -1;
    int iOpenIcon = -1;

    ASSERT(_pidl);

    if (_fGetOpenIcon)
    {
        SHGetIconFromPIDL(_psf, _psi, _pidl, _flags | GIL_OPENICON, &iOpenIcon);
    }

    // get the icon for this item.
    SHGetIconFromPIDL(_psf, _psi, _pidl, _flags, &iIcon);

    _pfn(_pidl, _pvData, _pvHint, iIcon, iOpenIcon);

    return S_OK;
}

HRESULT CGetIconTask_CreateInstance(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, BOOL fGetOpenIcon,
                                    PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint, IRunnableTask **ppTask)
{
    *ppTask = NULL;
    
    HRESULT hr;
    CGetIconTask * pNewTask = new CGetIconTask(&hr, psf, psi, pidl, flags, fGetOpenIcon, pfn, pvData, pvHint);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pNewTask, IRunnableTask *);
        else
            pNewTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


// given an IShellFolder and and an Idlist that is
// contained in it, get back a -possibly temporary - index into the system image list,
// and get the final icon from the callback if necessary

STDAPI SHMapIDListToImageListIndexAsync(IShellTaskScheduler* pts, IShellFolder *psf, LPCITEMIDLIST pidl, UINT flags,
                                        PFNASYNCICONTASKBALLBACK pfn, void *pvData, void *pvHint, int *piIndex, int *piIndexSel)
{
    HRESULT hr = S_OK;

    IShellIcon *psi = NULL;
    psf->QueryInterface(IID_PPV_ARG(IShellIcon, &psi));

    // We are doing all the ASYNC handling, not the caller.
    flags &= ~GIL_ASYNC;

    // Try asynchronous first
    if (pfn)
    {
        hr = SHGetIconFromPIDL(psf, psi, pidl,  flags | GIL_ASYNC, piIndex);

        if (piIndexSel)
        {
            HRESULT hr2 = SHGetIconFromPIDL(psf, psi, pidl, flags | GIL_OPENICON | GIL_ASYNC, piIndexSel);

            if (SUCCEEDED(hr))
            {
                // Don't lose the result if the first GetIcon succeeds, but the second one is E_PENDING
                hr = hr2;
            }
        }

        if (hr == E_PENDING)
        {
            if (pts)
            {
                IRunnableTask *pTask;
                hr = CGetIconTask_CreateInstance(psf, psi, pidl, flags, (piIndexSel != NULL), pfn, pvData, pvHint, &pTask);
                if (SUCCEEDED(hr))
                {
                    hr = pts->AddTask(pTask, TOID_DVIconExtract, 0, ITSAT_DEFAULT_PRIORITY);
                    if (SUCCEEDED(hr))
                    {
                        hr = E_PENDING;
                    }
                    pTask->Release();
                }
            }
            else
            {
                hr = E_POINTER;
            }
        }
        else if (hr == S_OK)
        {
            goto cleanup;
        }
    }

    // If asynchronous get failed, try synchronous
    if (hr != E_PENDING)
    {
        if (piIndexSel)
        {
            SHGetIconFromPIDL(psf, psi, pidl, flags | GIL_OPENICON, piIndexSel);
        }

        hr = SHGetIconFromPIDL(psf, psi, pidl, flags, piIndex);
    }

cleanup:
    if (psi)
    {
        psi->Release();
    }
    
    return hr;
}


// returns the icon handle to be used to represent the specified
// file. The caller should destroy the icon eventually.

STDAPI_(HICON) SHGetFileIcon(HINSTANCE hinst, LPCTSTR pszPath, DWORD dwFileAttributes, UINT uFlags)
{
    SHFILEINFO sfi;
    SHGetFileInfo(pszPath, dwFileAttributes, &sfi, sizeof(sfi), uFlags | SHGFI_ICON);
    return sfi.hIcon;
}

// Return 1 on success and 0 on failure.
DWORD_PTR _GetFileInfoSections(LPITEMIDLIST pidl, SHFILEINFO *psfi, UINT uFlags)
{
    DWORD_PTR dwResult = 1;
    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        // get attributes for file
        if (uFlags & SHGFI_ATTRIBUTES)
        {
            // [New in IE 4.0] If SHGFI_ATTR_SPECIFIED is set, we use psfi->dwAttributes as is

            if (!(uFlags & SHGFI_ATTR_SPECIFIED))
                psfi->dwAttributes = 0xFFFFFFFF;      // get all of them

            if (FAILED(psf->GetAttributesOf(1, &pidlLast, &psfi->dwAttributes)))
                psfi->dwAttributes = 0;
        }

        //
        // get icon location, place the icon path into szDisplayName
        //
        if (uFlags & SHGFI_ICONLOCATION)
        {
            IExtractIcon *pxi;

            if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_PPV_ARG_NULL(IExtractIcon, &pxi))))
            {
                UINT wFlags;
                pxi->GetIconLocation(0, psfi->szDisplayName, ARRAYSIZE(psfi->szDisplayName),
                    &psfi->iIcon, &wFlags);

                pxi->Release();

                // the returned location is not a filename we cant return it.
                // just give then nothing.
                if (wFlags & GIL_NOTFILENAME)
                {
                    // special case one of our shell32.dll icons......

                    if (psfi->szDisplayName[0] != TEXT('*'))
                        psfi->iIcon = 0;

                    psfi->szDisplayName[0] = 0;
                }
            }
        }

        HIMAGELIST himlLarge, himlSmall;

        // get the icon for the file.
        if ((uFlags & SHGFI_SYSICONINDEX) || (uFlags & SHGFI_ICON))
        {
            Shell_GetImageLists(&himlLarge, &himlSmall);

            if (uFlags & SHGFI_SYSICONINDEX)
                dwResult = (DWORD_PTR)((uFlags & SHGFI_SMALLICON) ? himlSmall : himlLarge);

            if (uFlags & SHGFI_OPENICON)
                SHMapPIDLToSystemImageListIndex(psf, pidlLast, &psfi->iIcon);
            else
                psfi->iIcon = SHMapPIDLToSystemImageListIndex(psf, pidlLast, NULL);
        }

        if (uFlags & SHGFI_ICON)
        {
            HIMAGELIST himl;
            UINT flags = 0;
            int cx, cy;

            if (uFlags & SHGFI_SMALLICON)
            {
                himl = himlSmall;
                cx = GetSystemMetrics(SM_CXSMICON);
                cy = GetSystemMetrics(SM_CYSMICON);
            }
            else
            {
                himl = himlLarge;
                cx = GetSystemMetrics(SM_CXICON);
                cy = GetSystemMetrics(SM_CYICON);
            }

            if (!(uFlags & SHGFI_ATTRIBUTES))
            {
                psfi->dwAttributes = SFGAO_LINK;    // get link only
                psf->GetAttributesOf(1, &pidlLast, &psfi->dwAttributes);
            }

            //
            //  check for a overlay image thing (link overlay)
            //
            if ((psfi->dwAttributes & SFGAO_LINK) || (uFlags & SHGFI_LINKOVERLAY))
            {
                IShellIconOverlayManager *psiom;
                HRESULT hrT = GetIconOverlayManager(&psiom);
                if (SUCCEEDED(hrT))
                {
                    int iOverlayIndex = 0;
                    hrT = psiom->GetReservedOverlayInfo(NULL, -1, &iOverlayIndex, SIOM_OVERLAYINDEX, SIOM_RESERVED_LINK);
                    if (SUCCEEDED(hrT))
                        flags |= INDEXTOOVERLAYMASK(iOverlayIndex);
                }
            }
            if ((uFlags & SHGFI_ADDOVERLAYS) || (uFlags & SHGFI_OVERLAYINDEX))
            {
                IShellIconOverlay * pio;
                if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &pio))))
                {
                    int iOverlayIndex = 0;
                    if (SUCCEEDED(pio->GetOverlayIndex(pidlLast, &iOverlayIndex)))
                    {
                        if (uFlags & SHGFI_ADDOVERLAYS)
                        {
                            flags |= INDEXTOOVERLAYMASK(iOverlayIndex);
                        }
                        if (uFlags & SHGFI_OVERLAYINDEX)
                        {
                            // use the upper 16 bits for the overlayindex
                            psfi->iIcon |= iOverlayIndex << 24;
                        }
                    }
                    pio->Release();
                }
            }
            
            
            //  check for selected state
            if (uFlags & SHGFI_SELECTED)
                flags |= ILD_BLEND50;

            psfi->hIcon = ImageList_GetIcon(himl, psfi->iIcon, flags);

            // if the caller does not want a "shell size" icon
            // convert the icon to the "system" icon size.
            if (psfi->hIcon && !(uFlags & SHGFI_SHELLICONSIZE))
                psfi->hIcon = (HICON)CopyImage(psfi->hIcon, IMAGE_ICON, cx, cy, LR_COPYRETURNORG | LR_COPYDELETEORG);
        }

        // get display name for the path
        if (uFlags & SHGFI_DISPLAYNAME)
        {
            DisplayNameOf(psf, pidlLast, SHGDN_NORMAL, psfi->szDisplayName, ARRAYSIZE(psfi->szDisplayName));
        }

        if (uFlags & SHGFI_TYPENAME)
        {
            IShellFolder2 *psf2;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                VARIANT var;
                VariantInit(&var);
                if (SUCCEEDED(psf2->GetDetailsEx(pidlLast, &SCID_TYPE, &var)))
                {
                    VariantToStr(&var, psfi->szTypeName, ARRAYSIZE(psfi->szTypeName));
                    VariantClear(&var);
                }
                psf2->Release();
            }
        }

        psf->Release();
    }
    else
        dwResult = 0;

    return dwResult;
}

//
//  This function returns shell info about a given pathname.
//  a app can get the following:
//
//      Icon (large or small)
//      Display Name
//      Name of File Type
//
//  this function replaces SHGetFileIcon

#define BUGGY_SHELL16_CBFILEINFO    (sizeof(SHFILEINFO) - 4)

STDAPI_(DWORD_PTR) SHGetFileInfo(LPCTSTR pszPath, DWORD dwFileAttributes, SHFILEINFO *psfi, UINT cbFileInfo, UINT uFlags)
{
    LPITEMIDLIST pidlFull;
    DWORD_PTR res = 1;
    TCHAR szPath[MAX_PATH];

    // this was never enforced in the past
    // TODDB: The 16 to 32 bit thunking layer passes in the wrong value for cbFileInfo.
    // The size passed in looks to be the size of the 16 bit version of the structure
    // rather than the size of the 32 bit version, as such it is 4 bytes shorter.
    // TJGREEN: Special-case that size to keep the assertion from firing and party on.
    // 
    ASSERT(!psfi || cbFileInfo == sizeof(*psfi) || cbFileInfo == BUGGY_SHELL16_CBFILEINFO);

    // You can't use both SHGFI_ATTR_SPECIFIED and SHGFI_ICON.
    ASSERT(uFlags & SHGFI_ATTR_SPECIFIED ? !(uFlags & SHGFI_ICON) : TRUE);

    if (pszPath == NULL)
        return 0;

    if (uFlags == SHGFI_EXETYPE)
        return GetExeType(pszPath);     // funky way to get EXE type

    if (psfi == NULL)
        return 0;

    psfi->hIcon = 0;

    // Zip Pro 6.0 relies on the fact that if you don't ask for the icon,
    // the iIcon field doesn't change.
    //
    // psfi->iIcon = 0;

    psfi->szDisplayName[0] = 0;
    psfi->szTypeName[0] = 0;

    //  do some simmple check on the input path.
    if (!(uFlags & SHGFI_PIDL))
    {
        // If the caller wants us to give them the file attributes, we can't trust
        // the attributes they gave us in the following two situations.
        if (uFlags & SHGFI_ATTRIBUTES)
        {
            if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
            {
                DebugMsg(TF_FSTREE, TEXT("SHGetFileInfo cant use caller supplied file attribs for a sys/ro directory (possible junction)"));
                uFlags &= ~SHGFI_USEFILEATTRIBUTES;
            }
            else if (PathIsRoot(pszPath))
            {
                DebugMsg(TF_FSTREE, TEXT("SHGetFileInfo cant use caller supplied file attribs for a roots"));
                uFlags &= ~SHGFI_USEFILEATTRIBUTES;
            }
        }

        if (PathIsRelative(pszPath))
        {
            if (uFlags & SHGFI_USEFILEATTRIBUTES)
            {
                // get a shorter path than the current directory to support
                // long pszPath names (that might get truncated in the 
                // long current dir case)

                GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
            }
            else
            {
                GetCurrentDirectory(ARRAYSIZE(szPath), szPath);
            }
            PathCombine(szPath, szPath, pszPath);
            pszPath = szPath;
        }
    }

    if (uFlags & SHGFI_PIDL)
        pidlFull = (LPITEMIDLIST)pszPath;
    else if (uFlags & SHGFI_USEFILEATTRIBUTES)
    {
        WIN32_FIND_DATA fd = {0};
        fd.dwFileAttributes = dwFileAttributes;
        SHSimpleIDListFromFindData(pszPath, &fd, &pidlFull);
    }
    else
        pidlFull = ILCreateFromPath(pszPath);

    if (pidlFull)
    {
        if (uFlags & (
            SHGFI_DISPLAYNAME   |
            SHGFI_ATTRIBUTES    |
            SHGFI_SYSICONINDEX  |
            SHGFI_ICONLOCATION  |
            SHGFI_ICON          | 
            SHGFI_TYPENAME))
        {
            res = _GetFileInfoSections(pidlFull, psfi, uFlags);
        }

        if (!(uFlags & SHGFI_PIDL))
            ILFree(pidlFull);
    }
    else
        res = 0;

    return res;
}


//===========================================================================
//
// SHGetFileInfoA Stub
//
//  This function calls SHGetFileInfoW and then converts the returned
//  information back to ANSI.
//
//===========================================================================
STDAPI_(DWORD_PTR) SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags)
{
    WCHAR szPathW[MAX_PATH];
    LPWSTR pszPathW;
    DWORD_PTR dwRet;

    if (uFlags & SHGFI_PIDL)
    {
        pszPathW = (LPWSTR)pszPath;     // Its a pidl, fake it as a WSTR
    }
    else
    {
        SHAnsiToUnicode(pszPath, szPathW, ARRAYSIZE(szPathW));
        pszPathW = szPathW;
    }
    if (psfi)
    {
        SHFILEINFOW sfiw;

        ASSERT(cbFileInfo == sizeof(*psfi));

        // Zip Pro 6.0 sets SHGFI_SMALLICON | SHGFI_OPENICON but forgets to
        // pass SHGFI_ICON or SHGFI_SYSICONINDEX, even though they really
        // wanted the sys icon index.
        //
        // In Windows 95, fields of the SHFILEINFOA structure that you didn't
        // query for were left unchanged.  They happened to have the icon for
        // a closed folder lying around there from a previous query, so they
        // got away with it by mistake.  They got the wrong icon, but it was
        // close enough that nobody really complained.
        //
        // So pre-initialize the sfiw's iIcon with the app's iIcon.  That
        // way, if it turns out the app didn't ask for the icon, he just
        // gets his old value back.
        //

        sfiw.iIcon = psfi->iIcon;
        sfiw.dwAttributes = psfi->dwAttributes;

        dwRet = SHGetFileInfoW(pszPathW, dwFileAttributes, &sfiw, sizeof(sfiw), uFlags);

        psfi->hIcon = sfiw.hIcon;
        psfi->iIcon = sfiw.iIcon;
        psfi->dwAttributes = sfiw.dwAttributes;
        SHUnicodeToAnsi(sfiw.szDisplayName, psfi->szDisplayName, ARRAYSIZE(psfi->szDisplayName));
        SHUnicodeToAnsi(sfiw.szTypeName, psfi->szTypeName, ARRAYSIZE(psfi->szTypeName));
    }
    else
    {
        dwRet = SHGetFileInfoW(pszPathW, dwFileAttributes, NULL, 0, uFlags);
    }
    return dwRet;
}

STDAPI ThunkFindDataWToA(WIN32_FIND_DATAW *pfd, WIN32_FIND_DATAA *pfda, int cb)
{
    if (cb < sizeof(WIN32_FIND_DATAA))
        return DISP_E_BUFFERTOOSMALL;

    memcpy(pfda, pfd, FIELD_OFFSET(WIN32_FIND_DATAA, cFileName));

    SHUnicodeToAnsi(pfd->cFileName, pfda->cFileName, ARRAYSIZE(pfda->cFileName));
    SHUnicodeToAnsi(pfd->cAlternateFileName, pfda->cAlternateFileName, ARRAYSIZE(pfda->cAlternateFileName));
    return S_OK;
}

STDAPI ThunkNetResourceWToA(LPNETRESOURCEW pnrw, LPNETRESOURCEA pnra, UINT cb)
{
    HRESULT hr;

    if (cb >= sizeof(NETRESOURCEA))
    {
        LPSTR psza, pszDest[4] = {NULL, NULL, NULL, NULL};

        CopyMemory(pnra, pnrw, FIELD_OFFSET(NETRESOURCE, lpLocalName));

        psza = (LPSTR)(pnra + 1);   // Point just past the structure
        if (cb > sizeof(NETRESOURCE))
        {
            LPWSTR pszSource[4];
            UINT i, cchRemaining = cb - sizeof(NETRESOURCE);

            pszSource[0] = pnrw->lpLocalName;
            pszSource[1] = pnrw->lpRemoteName;
            pszSource[2] = pnrw->lpComment;
            pszSource[3] = pnrw->lpProvider;

            for (i = 0; i < 4; i++)
            {
                if (pszSource[i])
                {
                    UINT cchItem;
                    pszDest[i] = psza;
                    cchItem = SHUnicodeToAnsi(pszSource[i], pszDest[i], cchRemaining);
                    cchRemaining -= cchItem;
                    psza += cchItem;
                }
            }

        }
        pnra->lpLocalName  = pszDest[0];
        pnra->lpRemoteName = pszDest[1];
        pnra->lpComment    = pszDest[2];
        pnra->lpProvider   = pszDest[3];
        hr = S_OK;
    }
    else
        hr = DISP_E_BUFFERTOOSMALL;
    return hr;
}

STDAPI NetResourceWVariantToBuffer(const VARIANT* pvar, void* pv, UINT cb)
{
    HRESULT hr;

    if (cb >= sizeof(NETRESOURCEW))
    {
        if (pvar && pvar->vt == (VT_ARRAY | VT_UI1))
        {
            int i;
            NETRESOURCEW* pnrw = (NETRESOURCEW*) pvar->parray->pvData;
            UINT cbOffsets[4] = { 0, 0, 0, 0 };
            UINT cbEnds[4] = { 0, 0, 0, 0 };
            LPWSTR pszPtrs[4] = { pnrw->lpLocalName, pnrw->lpRemoteName,
                                  pnrw->lpComment, pnrw->lpProvider };
            hr = S_OK;
            for (i = 0; i < ARRAYSIZE(pszPtrs); i++)
            {
                if (pszPtrs[i])
                {
                    cbOffsets[i] = (UINT) ((BYTE*) pszPtrs[i] - (BYTE*) pnrw);
                    cbEnds[i] = cbOffsets[i] + (sizeof(WCHAR) * (lstrlenW(pszPtrs[i]) + 1));
                
                    // If any of the strings start or end too far into the buffer, then fail:
                    if ((cbOffsets[i] >= cb) || (cbEnds[i] > cb))
                    {
                        hr = DISP_E_BUFFERTOOSMALL;
                        break;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                hr = VariantToBuffer(pvar, pv, cb) ? S_OK : E_FAIL;
                pnrw = (NETRESOURCEW*) pv;
                if (SUCCEEDED(hr))
                {
                    // Fixup pointers in structure to point into the output buffer,
                    // instead of the variant buffer:
                    LPWSTR* ppszPtrs[4] = { &(pnrw->lpLocalName), &(pnrw->lpRemoteName),
                                            &(pnrw->lpComment), &(pnrw->lpProvider) };
                                
                    for (i = 0; i < ARRAYSIZE(ppszPtrs); i++)
                    {
                        if (*ppszPtrs[i])
                        {
                            *ppszPtrs[i] = (LPWSTR) ((BYTE*) pnrw + cbOffsets[i]);
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = DISP_E_BUFFERTOOSMALL;
    }
    return hr;
}

//  This function will extract information that is cached in the pidl such
//  in the information that was returned from a FindFirst file.  This function
//  is sortof a hack as t allow outside callers to be able to get at the infomation
//  without knowing how we store it in the pidl.
//  a app can get the following:

STDAPI SHGetDataFromIDListW(IShellFolder *psf, LPCITEMIDLIST pidl, int nFormat, void *pv, int cb)
{
    HRESULT hr = E_NOTIMPL;
    SHCOLUMNID* pscid;

    if (!pv || !psf || !pidl)
        return E_INVALIDARG;

    switch (nFormat)
    {
        case SHGDFIL_FINDDATA:
            if (cb < sizeof(WIN32_FIND_DATAW))
                return DISP_E_BUFFERTOOSMALL;
            else
                pscid = (SHCOLUMNID*)&SCID_FINDDATA;
            break;
        case SHGDFIL_NETRESOURCE:
            if (cb < sizeof(NETRESOURCEW))
                return  DISP_E_BUFFERTOOSMALL;
            else
                pscid = (SHCOLUMNID*)&SCID_NETRESOURCE;
            break;
        case SHGDFIL_DESCRIPTIONID:
            pscid = (SHCOLUMNID*)&SCID_DESCRIPTIONID;
            break;
        default:
            return E_INVALIDARG;
    }

    IShellFolder2 *psf2;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        VARIANT var;
        VariantInit(&var);
        hr = psf2->GetDetailsEx(pidl, pscid, &var);
        if (SUCCEEDED(hr))
        {
            if (SHGDFIL_NETRESOURCE == nFormat)
            {
                hr = NetResourceWVariantToBuffer(&var, pv, cb);
            }
            else
            {
                if (!VariantToBuffer(&var, pv, cb))
                    hr = E_FAIL;
            }
            VariantClear(&var);
        }
        else
        {
            TraceMsg(TF_WARNING, "Trying to retrieve find data from unknown PIDL %s", DumpPidl(pidl));
        }

        psf2->Release();
    }

    return hr;
}

STDAPI SHGetDataFromIDListA(IShellFolder *psf, LPCITEMIDLIST pidl, int nFormat, void *pv, int cb)
{
    HRESULT hr;
    WIN32_FIND_DATAW fdw;
    NETRESOURCEW *pnrw = NULL;
    void *pvData = pv;
    int cbData = cb;

    if (nFormat == SHGDFIL_FINDDATA)
    {
        cbData = sizeof(fdw);
        pvData = &fdw;
    }
    else if (nFormat == SHGDFIL_NETRESOURCE)
    {
        cbData = cb;
        pvData = pnrw = (NETRESOURCEW *)LocalAlloc(LPTR, cbData);
        if (pnrw == NULL)
            return E_OUTOFMEMORY;
    }

    hr = SHGetDataFromIDListW(psf, pidl, nFormat, pvData, cbData);

    if (SUCCEEDED(hr))
    {
        if (nFormat == SHGDFIL_FINDDATA)
        {
            hr = ThunkFindDataWToA(&fdw, (WIN32_FIND_DATAA *)pv, cb);
        }
        else if (nFormat == SHGDFIL_NETRESOURCE)
        {
            hr = ThunkNetResourceWToA(pnrw, (NETRESOURCEA *)pv, cb);
        }
    }

    if (pnrw)
        LocalFree(pnrw);

    return hr;
}


int g_iUseLinkPrefix = -1;

#define INITIALLINKPREFIXCOUNT 20
#define MAXLINKPREFIXCOUNT  30

void LoadUseLinkPrefixCount()
{
    TraceMsg(TF_FSTREE, "LoadUseLinkPrefixCount %d", g_iUseLinkPrefix);
    if (g_iUseLinkPrefix < 0)
    {
        DWORD cb = sizeof(g_iUseLinkPrefix);
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, c_szLink, NULL, &g_iUseLinkPrefix, &cb))
        || g_iUseLinkPrefix < 0)
        {
            g_iUseLinkPrefix = INITIALLINKPREFIXCOUNT;
        }
    }
}

void SaveUseLinkPrefixCount()
{
    if (g_iUseLinkPrefix >= 0)
    {
        SKSetValue(SHELLKEY_HKCU_EXPLORER, NULL, c_szLink, REG_BINARY, &g_iUseLinkPrefix, sizeof(g_iUseLinkPrefix));
    }
}

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

// psz2 = destination
// psz1 = source
void StripNumber(LPTSTR psz2, LPCTSTR psz1)
{
    // strip out the '(' and the numbers after it
    // We need to verify that it is either simply () or (999) but not (A)
    for (; *psz1; psz1 = CharNext(psz1), psz2 = CharNext(psz2)) 
    {
        if (*psz1 == TEXT('(')) 
        {
            LPCTSTR pszT = psz1;
            do 
            {
                psz1 = CharNext(psz1);
            } while (*psz1 && ISDIGIT(*psz1));

            if (*psz1 == TEXT(')'))
            {
                psz1 = CharNext(psz1);
                if (*psz1 == TEXT(' '))
                    psz1 = CharNext(psz1);  // skip the extra space
                lstrcpy(psz2, psz1);
                return;
            }

            // We have a (that does not match the format correctly!
            psz1 = pszT;  // restore pointer back to copy this char through and continue...
        }
        *psz2 = *psz1;
    }
    *psz2 = *psz1;
}

#define SHORTCUT_PREFIX_DECR 5
#define SHORTCUT_PREFIX_INCR 1

// this checks to see if you've renamed 'Shortcut #x To Foo' to 'Foo'

void CheckShortcutRename(LPCTSTR pszOldPath, LPCTSTR pszNewPath)
{
    ASSERT(pszOldPath);
    ASSERT(pszNewPath);

    // already at 0.
    if (g_iUseLinkPrefix)
    {
        LPCTSTR pszOldName = PathFindFileName(pszOldPath);
        if (PathIsLnk(pszOldName)) 
        {
            TCHAR szBaseName[MAX_PATH];
            TCHAR szLinkTo[80];
            TCHAR szMockName[MAX_PATH];

            LPCTSTR pszNewName = PathFindFileName(pszNewPath);

            lstrcpy(szBaseName, pszNewName);
            PathRemoveExtension(szBaseName);

            // mock up a name using the basename and the linkto template
            LoadString(HINST_THISDLL, IDS_LINKTO, szLinkTo, ARRAYSIZE(szLinkTo));
            wnsprintf(szMockName, ARRAYSIZE(szMockName), szLinkTo, szBaseName);

            StripNumber(szMockName, szMockName);
            StripNumber(szBaseName, pszOldName);

            // are the remaining gunk the same?
            if (!lstrcmp(szMockName, szBaseName)) 
            {
                // yes!  do the link count magic
                LoadUseLinkPrefixCount();
                ASSERT(g_iUseLinkPrefix >= 0);
                g_iUseLinkPrefix -= SHORTCUT_PREFIX_DECR;
                if (g_iUseLinkPrefix < 0)
                    g_iUseLinkPrefix = 0;
                SaveUseLinkPrefixCount();
            }
        }
    }
}

STDAPI_(int) SHRenameFileEx(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszDir, 
                            LPCTSTR pszOldName, LPCTSTR pszNewName)
{
    int iRet = ERROR_CANCELLED; // user saw the error, don't report again
    TCHAR szOldPathName[MAX_PATH + 1];    // +1 for double nul terminating on SHFileOperation
    TCHAR szTempNewPath[MAX_PATH];
    BOOL bEnableUI = hwnd || punkEnableModless;

    IUnknown_EnableModless(punkEnableModless, FALSE);

    PathCombine(szOldPathName, pszDir, pszOldName);
    szOldPathName[lstrlen(szOldPathName) + 1] = 0;

    StrCpyN(szTempNewPath, pszNewName, ARRAYSIZE(szTempNewPath));
    int err = PathCleanupSpec(pszDir, szTempNewPath);
    if (err)
    {
        if (bEnableUI)
        {
            ShellMessageBox(HINST_THISDLL, hwnd,
                    err & PCS_PATHTOOLONG ?
                        MAKEINTRESOURCE(IDS_REASONS_INVFILES) :
                        IsLFNDrive(pszDir) ?
                            MAKEINTRESOURCE(IDS_INVALIDFN) :
                            MAKEINTRESOURCE(IDS_INVALIDFNFAT),
                    MAKEINTRESOURCE(IDS_RENAME), MB_OK | MB_ICONHAND);
        }
    }
    else
    {
        // strip off leading and trailing blanks off of the new file name.
        StrCpyN(szTempNewPath, pszNewName, ARRAYSIZE(szTempNewPath));
        PathRemoveBlanks(szTempNewPath);
        if (!szTempNewPath[0] || (szTempNewPath[0] == TEXT('.')))
        {
            if (bEnableUI)
            {
                ShellMessageBox(HINST_THISDLL, hwnd,
                    MAKEINTRESOURCE(IDS_NONULLNAME),
                    MAKEINTRESOURCE(IDS_RENAME), MB_OK | MB_ICONHAND);
            }
        }
        else
        {
            int idPrompt = IDYES;
            TCHAR szNewPathName[MAX_PATH + 1];    // +1 for double nul terminating on SHFileOperation

            PathCombine(szNewPathName, pszDir, szTempNewPath);

            // if there was an old extension and the new and old don't match complain
            LPTSTR pszExt = PathFindExtension(pszOldName);
            if (*pszExt && lstrcmpi(pszExt, PathFindExtension(szTempNewPath)))
            {
                HKEY hk;
                if (!PathIsDirectory(szOldPathName) && 
                    SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, pszExt, NULL, &hk)))
                {
                    RegCloseKey(hk);

                    if (bEnableUI)
                    {
                        idPrompt = ShellMessageBox(HINST_THISDLL, hwnd,
                            MAKEINTRESOURCE(IDS_WARNCHANGEEXT),
                            MAKEINTRESOURCE(IDS_RENAME), MB_YESNO | MB_ICONEXCLAMATION);
                    }
                }
            }

            if (IDYES == idPrompt)
            {
                szNewPathName[lstrlen(szNewPathName) + 1] = 0;     // double NULL terminate

                SHFILEOPSTRUCT fo = { hwnd, FO_RENAME, szOldPathName, szNewPathName, FOF_SILENT | FOF_ALLOWUNDO, };

                iRet = SHFileOperation(&fo);

                if (ERROR_SUCCESS == iRet)
                    CheckShortcutRename(szOldPathName, szNewPathName);
            }
        }
    }
    IUnknown_EnableModless(punkEnableModless, TRUE);
    return iRet;
}


HKEY SHOpenShellFolderKey(const CLSID *pclsid)
{
    HKEY hkey;
    return SUCCEEDED(SHRegGetCLSIDKey(*pclsid, TEXT("ShellFolder"), FALSE, FALSE, &hkey)) ? hkey : NULL;
}

BOOL SHQueryShellFolderValue(const CLSID *pclsid, LPCTSTR pszValueName)
{
    BOOL bRet = FALSE;      // assume no
    HKEY hkey = SHOpenShellFolderKey(pclsid);
    if (hkey)
    {
        bRet = SHQueryValueEx(hkey, pszValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
        RegCloseKey(hkey);
    }
    return bRet;
}

//
//  The SZ_REGKEY_MYCOMPUTER_NONENUM_POLICY key contains a bunch of values,
//  each named after a GUID.  The data associated with each value is a
//  DWORD, which is either...
//
//  0 = no restriction on this CLSID
//  1 = unconditional restriction on this CLSID
//  0xFFFFFFFF = same as 1 (in case somebody got "creative")
//  any other value = pass to SHRestricted() to see what the restriction is
//
//  We support 0xFFFFFFFF only out of paranoia.  This flag was only 0 or 1
//  in Windows 2000, and somebody might've decided that "all bits set"
//  is better than "just one bit set".
//
#define SZ_REGKEY_MYCOMPUTER_NONENUM_POLICY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\NonEnum")

BOOL _IsNonEnumPolicySet(const CLSID *pclsid)
{
    BOOL fPolicySet = FALSE;
    TCHAR szCLSID[GUIDSTR_MAX];
    DWORD dwDefault = 0;
    RESTRICTIONS rest = REST_NONE;
    DWORD cbSize = sizeof(rest);

    if (EVAL(SHStringFromGUID(*pclsid, szCLSID, ARRAYSIZE(szCLSID))) &&
       (ERROR_SUCCESS == SHRegGetUSValue(SZ_REGKEY_MYCOMPUTER_NONENUM_POLICY, szCLSID, NULL, &rest, &cbSize, FALSE, &dwDefault, sizeof(dwDefault))) &&
       rest)
    {
        fPolicySet = rest == 1 || rest == 0xFFFFFFFF || SHRestricted(rest);
    }

    return fPolicySet;
}

//
//  This function returns the attributes (to be returned IShellFolder::
// GetAttributesOf) of the junction point specified by the class ID.
//
STDAPI_(DWORD) SHGetAttributesFromCLSID(const CLSID *pclsid, DWORD dwDefault)
{
    return SHGetAttributesFromCLSID2(pclsid, dwDefault, (DWORD)-1);
}

DWORD QueryCallForAttributes(HKEY hkey, const CLSID *pclsid, DWORD dwDefAttrs, DWORD dwRequested)
{
    DWORD dwAttr = dwDefAttrs;
    DWORD dwData, cbSize = sizeof(dwAttr);

    // consider caching this folder to avoid creating over and over
    // mydocs.dll uses this for compat with old apps

    // See if this folder has asked us specifically to call and get
    // the attributes...
    //
    if (SHQueryValueEx(hkey, TEXT("CallForAttributes"), NULL, NULL, &dwData, &cbSize) == ERROR_SUCCESS)
    {
        // CallForAttributes can be a masked value. See if it's being supplied in the value.
        // NOTE: MyDocs.dll registers with a NULL String, so this check works.
        DWORD dwMask = (DWORD)-1;
        if (sizeof(dwData) == cbSize)
        {
            // There is a mask, Use this.
            dwMask = dwData;
        }

        // Is the requested bit contained in the specified mask?
        if (dwMask & dwRequested)
        {
            // Yes. Then CoCreate and Query.
            IShellFolder *psf;
            if (SUCCEEDED(SHExtCoCreateInstance(NULL, pclsid, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                dwAttr = dwRequested;
                psf->GetAttributesOf(0, NULL, &dwAttr);
                psf->Release();
            }
            else
            {
                 dwAttr |= SFGAO_FILESYSTEM;
            }
        }
    }

    return dwAttr;
}

// dwRequested is the bits you are explicitly looking for. This is an optimization that prevents reg hits.

STDAPI_(DWORD) SHGetAttributesFromCLSID2(const CLSID *pclsid, DWORD dwDefAttrs, DWORD dwRequested)
{
    DWORD dwAttr = dwDefAttrs;
    HKEY hkey = SHOpenShellFolderKey(pclsid);
    if (hkey)
    {
        DWORD dwData, cbSize = sizeof(dwAttr);

        // We are looking for some attributes on a shell folder. These attributes can be in two locations:
        // 1) In the "Attributes" value in the registry.
        // 2) Stored in a the shell folder's GetAttributesOf.

        // First, Check to see if the reqested value is contained in the registry.
        if (SHQueryValueEx(hkey, TEXT("Attributes"), NULL, NULL, (BYTE *)&dwData, &cbSize) == ERROR_SUCCESS &&
            cbSize == sizeof(dwData))
        {
            // We have data there, but it may not contain the data we are looking for
            dwAttr = dwData & dwRequested;

            // Does it contain the bit we are looking for?
            if (((dwAttr & dwRequested) != dwRequested) && dwRequested != 0)
            {
                // No. Check to see if it is in the shell folder implementation
                goto CallForAttributes;
            }
        }
        else
        {
CallForAttributes:
            // See if we have to talk to the shell folder.
            // I'm passing dwAttr, because if the previous case did not generate any attributes, then it's
            // equal to dwDefAttrs. If the call to CallForAttributes fails, then it will contain the value of
            // dwDefAttrs or whatever was in the shell folder's Attributes key
            dwAttr = QueryCallForAttributes(hkey, pclsid, dwAttr, dwRequested);
        }

        RegCloseKey(hkey);
    }

    if (_IsNonEnumPolicySet(pclsid))
        dwAttr |= SFGAO_NONENUMERATED;

    if (SHGetObjectCompatFlags(NULL, pclsid) & OBJCOMPATF_NOTAFILESYSTEM)
        dwAttr &= ~SFGAO_FILESYSTEM;

    return dwAttr;
}

// _BuildLinkName
//
// Used during the creation of a shortcut, this function determines an appropriate name for the shortcut.
// This is not the exact name that will be used becuase it will usually contain "() " which will either
// get removed or replaced with "(x) " where x is a number that makes the name unique.  This removal is done
// elsewhere (currently in PathYetAnotherMakeUniqueName).
//
// in:
//      pszName file spec part
//      pszDir  path part of name to know how to limit the long name...
//
// out:
//      pszLinkName - Full path to link name (May fit in 8.3...).  Can be the same buffer as pszName.
//
// NOTES: If pszDir + pszLinkName is greater than MAX_PATH we will fail to create the shortcut.
// In an effort to prevent 
void _BuildLinkName(LPTSTR pszLinkName, LPCTSTR pszName, LPCTSTR pszDir, BOOL fLinkTo)
{
    TCHAR szLinkTo[40]; // "Shortcut to %s.lnk"
    TCHAR szTemp[MAX_PATH + 40];

    if (fLinkTo)
    {
        // check to see if we're in the "don't ever say 'shortcut to' mode"
        LoadUseLinkPrefixCount();

        if (!g_iUseLinkPrefix)
        {
            fLinkTo = FALSE;
        }
        else if (g_iUseLinkPrefix > 0)
        {
            if (g_iUseLinkPrefix < MAXLINKPREFIXCOUNT)
            {
                g_iUseLinkPrefix += SHORTCUT_PREFIX_INCR;
                SaveUseLinkPrefixCount();
            }
        }
    }

    if (!fLinkTo)
    {
        // Generate the title of this link ("XX.lnk")
        LoadString(HINST_THISDLL, IDS_LINKEXTENSION, szLinkTo, ARRAYSIZE(szLinkTo));
    }
    else
    {
        // Generate the title of this link ("Shortcut to XX.lnk")
        LoadString(HINST_THISDLL, IDS_LINKTO, szLinkTo, ARRAYSIZE(szLinkTo));
    }
    wnsprintf(szTemp, ARRAYSIZE(szTemp), szLinkTo, pszName);

    PathCleanupSpecEx(pszDir, szTemp);      // get rid of illegal chars AND ensure correct filename length
    lstrcpyn(pszLinkName, szTemp, MAX_PATH);

    ASSERT(PathIsLnk(pszLinkName));
}

// return a new destination path for a link
//
// in:
//      fErrorSoTryDesktop      we are called because there was an error saving
//                              the shortcut and we want to prompt to see if the
//                              desktop should be used.
//
// in/out:
//      pszPath     on input the place being tried, on output the desktop folder
//
// returns:
//
//      IDYES       user said yes to creating a link at new place
//      IDNO        user said no to creating a link at new place
//      -1          error
//

int _PromptTryDesktopLinks(HWND hwnd, LPTSTR pszPath, BOOL fErrorSoTryDesktop)
{
    TCHAR szPath[MAX_PATH];
    if (!SHGetSpecialFolderPath(hwnd, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
        return -1;      // fail no desktop dir

    int idOk;

    if (fErrorSoTryDesktop)
    {
        // Fail, if pszPath already points to the desktop directory.
        if (lstrcmpi(szPath, pszPath) == 0)
            return -1;

        idOk = ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_TRYDESKTOPLINK),
                        MAKEINTRESOURCE(IDS_LINKTITLE),
                        MB_YESNO | MB_ICONQUESTION);
    }
    else
    {
        ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_MAKINGDESKTOPLINK),
                        MAKEINTRESOURCE(IDS_LINKTITLE),
                        MB_OK | MB_ICONASTERISK);
        idOk = IDYES;
    }

    if (idOk == IDYES)
        lstrcpy(pszPath , szPath);  // output

    return idOk;    // return yes or no
}

// in:
//      pszpdlLinkTo    LPCITEMIDLIST or LPCTSTR, target of link to create
//      pszDir          where we will put the link
//      uFlags          SHGNLI_ flags
//       
// out:
//      pszName         file name to create "c:\Shortcut to Foo.lnk"
//      pfMustCopy      pszpdlLinkTo was a link itself, make a copy of this

STDAPI_(BOOL) SHGetNewLinkInfo(LPCTSTR pszpdlLinkTo, LPCTSTR pszDir, LPTSTR pszName,
                               BOOL *pfMustCopy, UINT uFlags)
{
    BOOL fDosApp = FALSE;
    BOOL fLongFileNames = IsLFNDrive(pszDir);
    SHFILEINFO sfi;

    *pfMustCopy = FALSE;

    sfi.dwAttributes = SFGAO_FILESYSTEM | SFGAO_LINK | SFGAO_FOLDER;

    if (uFlags & SHGNLI_PIDL)
    {
        if (FAILED(SHGetNameAndFlags((LPCITEMIDLIST)pszpdlLinkTo, SHGDN_NORMAL,
                            pszName, MAX_PATH, &sfi.dwAttributes)))
            return FALSE;
    }
    else
    {
        if (SHGetFileInfo(pszpdlLinkTo, 0, &sfi, sizeof(sfi),
                          SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES | SHGFI_ATTR_SPECIFIED |
                          ((uFlags & SHGNLI_PIDL) ? SHGFI_PIDL : 0)))
            lstrcpy(pszName, sfi.szDisplayName);
        else
            return FALSE;
    }

    if (PathCleanupSpecEx(pszDir, pszName) & PCS_FATAL)
        return FALSE;

    //
    //  WARNING:  From this point on, sfi.szDisplayName may be re-used to
    //  contain the file path of the PIDL we are linking to.  Don't rely on
    //  it containing the display name.
    //
    if (sfi.dwAttributes & SFGAO_FILESYSTEM)
    {
        LPTSTR pszPathSrc;

        if (uFlags & SHGNLI_PIDL)
        {
            pszPathSrc = sfi.szDisplayName;
            SHGetPathFromIDList((LPCITEMIDLIST)pszpdlLinkTo, pszPathSrc);
        }
        else
        {
            pszPathSrc = (LPTSTR)pszpdlLinkTo;
        }
        fDosApp = (lstrcmpi(PathFindExtension(pszPathSrc), TEXT(".pif")) == 0) ||
                  (LOWORD(GetExeType(pszPathSrc)) == 0x5A4D); // 'MZ'

        if (sfi.dwAttributes & SFGAO_LINK)
        {
            *pfMustCopy = TRUE;
            if (!(sfi.dwAttributes & SFGAO_FOLDER))
            {
                uFlags &= ~SHGNLI_NOLNK; // if copying the file then don't trim the extension
            }
            lstrcpy(pszName, PathFindFileName(pszPathSrc));
        }
        else
        {
            //
            // when making a link to a drive root. special case a few things
            //
            // if we are not on a LFN drive, dont use the full name, just
            // use the drive letter.    "C.LNK" not "Label (C).LNK"
            //
            // if we are making a link to removable media, we dont want the
            // label as part of the name, we want the media type.
            //
            // CD-ROM drives are currently the only removable media we
            // show the volume label for, so we only need to special case
            // cdrom drives here.
            //
            if (PathIsRoot(pszPathSrc) && !PathIsUNC(pszPathSrc))
            {
                if (!fLongFileNames)
                    lstrcpy(pszName, pszPathSrc);
                else if (IsCDRomDrive(DRIVEID(pszPathSrc)))
                    LoadString(HINST_THISDLL, IDS_DRIVES_CDROM, pszName, MAX_PATH);
            }
        }
        if (fLongFileNames && fDosApp)
        {
            HANDLE hPif = PifMgr_OpenProperties(pszPathSrc, NULL, 0, OPENPROPS_INHIBITPIF);
            if (hPif)
            {
                PROPPRG PP = {0};
                if (PifMgr_GetProperties(hPif, (LPCSTR)MAKELP(0, GROUP_PRG), &PP, sizeof(PP), 0) &&
                    ((PP.flPrgInit & PRGINIT_INFSETTINGS) ||
                    ((PP.flPrgInit & (PRGINIT_NOPIF | PRGINIT_DEFAULTPIF)) == 0)))
                {
                    SHAnsiToTChar(PP.achTitle, pszName, MAX_PATH);
                }
                PifMgr_CloseProperties(hPif, 0);
            }
        }
    }
    if (!*pfMustCopy)
    {
        // create full dest path name.  only use template iff long file names
        // can be created and the caller requested it.  _BuildLinkName will
        // truncate files on non-lfn drives and clean up any invalid chars.
        _BuildLinkName(pszName, pszName, pszDir,
           (!(*pfMustCopy) && fLongFileNames && (uFlags & SHGNLI_PREFIXNAME)));
    }

    if (fDosApp)
        PathRenameExtension(pszName, TEXT(".pif"));

    if (uFlags & SHGNLI_NOLNK)
    {
        // Don't do PathRemoveExtension because pszName might contain
        // internal dots ("Windows 3.1") and passing that to
        // PathYetAnotherMakeUniqueName will result in
        // "Windows 3  (2).1" which is wrong.  We leave the dot at the
        // end so we get "Windows 3.1 (2)." back.  We will strip off the
        // final dot later.
        PathRenameExtension(pszName, TEXT("."));
    }

    // make sure the name is unique
    // NOTE: PathYetAnotherMakeUniqueName will return the directory+filename in the pszName buffer.
    // It returns FALSE if the name is not unique or the dir+filename is too long.  If it returns
    // false then this function should return false because creation will fail.
    BOOL fSuccess;
    if (!(uFlags & SHGNLI_NOUNIQUE))
        fSuccess = PathYetAnotherMakeUniqueName(pszName, pszDir, pszName, pszName);
    else
        fSuccess = TRUE;

    // Strip off any trailing dots that may have been generated by SHGNI_NOLNK
    PathStripTrailingDots(pszName);

    return fSuccess;
}

STDAPI_(BOOL) SHGetNewLinkInfoA(LPCSTR pszpdlLinkTo, LPCSTR pszDir, LPSTR pszName,
                                BOOL *pfMustCopy, UINT uFlags)
{
    ThunkText * pThunkText;
    BOOL bResult = FALSE;

    if (uFlags & SHGNLI_PIDL) 
    {
        // 1 string (pszpdlLinkTo is a pidl)
        pThunkText = ConvertStrings(2, NULL, pszDir);

        if (pThunkText)
            pThunkText->m_pStr[0] = (LPWSTR)pszpdlLinkTo;
    } 
    else 
    {
        // 2 strings
        pThunkText = ConvertStrings(2, pszpdlLinkTo, pszDir);
    }

    if (pThunkText)
    {
        WCHAR wszName[MAX_PATH];
        bResult = SHGetNewLinkInfoW(pThunkText->m_pStr[0], pThunkText->m_pStr[1],
                                    wszName, pfMustCopy, uFlags);
        LocalFree(pThunkText);
        if (bResult)
        {
            if (0 == WideCharToMultiByte(CP_ACP, 0, wszName, -1,
                                         pszName, MAX_PATH, NULL, NULL))
            {
                SetLastError((DWORD)E_FAIL);
                bResult = FALSE;
            }
        }
    }
    return bResult;
}

//
// in:
//      pidlTo

STDAPI CreateLinkToPidl(LPCITEMIDLIST pidlTo, LPCTSTR pszDir, LPITEMIDLIST *ppidl, UINT uFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szPathDest[MAX_PATH];
    BOOL fCopyLnk;
    BOOL fUseLinkTemplate = (SHCL_USETEMPLATE & uFlags);
    UINT uSHGNLI = fUseLinkTemplate ? SHGNLI_PIDL | SHGNLI_PREFIXNAME : SHGNLI_PIDL;

    if (uFlags & SHCL_MAKEFOLDERSHORTCUT)
    {
        // Don't add ".lnk" to the folder shortcut name; that's just stupid
        uSHGNLI |= SHGNLI_NOLNK;
    }

    if (uFlags & SHCL_NOUNIQUE)
    {
        uSHGNLI |= SHGNLI_NOUNIQUE;
    }

    if (SHGetNewLinkInfo((LPTSTR)pidlTo, pszDir, szPathDest, &fCopyLnk, uSHGNLI))
    {
        TCHAR szPathSrc[MAX_PATH];
        IShellLink *psl = NULL;

        // If we passed SHGNLI_NOUNIQUE then we need to do the PathCombine ourselves
        // because SHGetNewLinkInfo won't
        if (uFlags & SHCL_NOUNIQUE)
        {
            PathCombine(szPathDest, pszDir, szPathDest);
        }

        DWORD dwAttributes = SFGAO_FILESYSTEM | SFGAO_FOLDER;
        SHGetNameAndFlags(pidlTo, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szPathSrc, ARRAYSIZE(szPathSrc), &dwAttributes);

        if (fCopyLnk)
        {
            // if it is file system and not a folder (CopyFile does not work on folders)
            // just copy it.
            if (((dwAttributes & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM) &&
                CopyFile(szPathSrc, szPathDest, TRUE))
            {
                TouchFile(szPathDest);

                SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szPathDest, NULL);
                SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPathDest, NULL);
                hr = S_OK;
            }
            else
            {
                // load the source object that will be "copied" below (with the ::Save call)
                hr = SHGetUIObjectFromFullPIDL(pidlTo, NULL, IID_PPV_ARG(IShellLink, &psl));
            }
        } 
        else
        {
            hr = SHCoCreateInstance(NULL, uFlags & SHCL_MAKEFOLDERSHORTCUT ?
                &CLSID_FolderShortcut : &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIDList(pidlTo);
                // set the working directory to the same path
                // as the file we are linking too
                if (szPathSrc[0] && ((dwAttributes & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM))
                {
                    PathRemoveFileSpec(szPathSrc);
                    psl->SetWorkingDirectory(szPathSrc);
                }
            }
        }

        if (psl)
        {
            if (SUCCEEDED(hr))
            {
                IPersistFile *ppf;
                hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                if (SUCCEEDED(hr))
                {
                    USES_CONVERSION;
                    hr = ppf->Save(T2CW(szPathDest), TRUE);
                    if (SUCCEEDED(hr))
                    {
                        // in case ::Save translated the name of the 
                        // file (.LNK -> .PIF, or Folder Shortcut)
                        WCHAR *pwsz;
                        if (SUCCEEDED(ppf->GetCurFile(&pwsz)) && pwsz)
                        {
                            SHUnicodeToTChar(pwsz, szPathDest, ARRAYSIZE(szPathDest));
                            SHFree(pwsz);
                        }
                    }
                    ppf->Release();
                }
            }
            psl->Release();
        }
    }

    if (ppidl)
    {
        *ppidl = SUCCEEDED(hr) ? SHSimpleIDListFromPath(szPathDest) : NULL;
    }
    return hr;
}


// in/out:
//      pszDir         inital folder to try, output new folder (desktop)
// out:
//      ppidl          optional output PIDL of thing created

HRESULT _CreateLinkRetryDesktop(HWND hwnd, LPCITEMIDLIST pidlTo, LPTSTR pszDir, UINT fFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    if (ppidl)
        *ppidl = NULL;          // assume error

    if (*pszDir && (fFlags & SHCL_CONFIRM))
    {
        hr = CreateLinkToPidl(pidlTo, pszDir, ppidl, fFlags);
    }
    else
    {
        hr = E_FAIL;
    }

    // if we were unable to save, ask user if they want us to
    // try it again but change the path to the desktop.

    if (FAILED(hr))
    {
        int id;

        if (hr == STG_E_MEDIUMFULL)
        {
            DebugMsg(TF_ERROR, TEXT("failed to create link because disk is full"));
            id = IDYES;
        }
        else
        {
            if (fFlags & SHCL_CONFIRM)
            {
                id = _PromptTryDesktopLinks(hwnd, pszDir, (fFlags & SHCL_CONFIRM));
            }
            else
            {
                id = (SHGetSpecialFolderPath(hwnd, pszDir, CSIDL_DESKTOPDIRECTORY, FALSE)) ? IDYES : IDNO;
            }

            if (id == IDYES && *pszDir)
            {
                hr = CreateLinkToPidl(pidlTo, pszDir, ppidl, fFlags);
            }
        }

        //  we failed to create the link complain to the user.
        if (FAILED(hr) && id != IDNO)
        {
            ShellMessageBox(HINST_THISDLL, hwnd,
                            MAKEINTRESOURCE(IDS_CANNOTCREATELINK),
                            MAKEINTRESOURCE(IDS_LINKTITLE),
                            MB_OK | MB_ICONASTERISK);
        }
    }

#ifdef DEBUG
    if (FAILED(hr) && ppidl)
        ASSERT(*ppidl == NULL);
#endif

    return hr;
}

//
// This function creates links to the stuff in the IDataObject
//
// Arguments:
//  hwnd        for any UI
//  pszDir      optional target directory (where to create links)
//  pDataObj    data object describing files (array of idlist)
//  ppidl       optional pointer to an array that receives pidls pointing to the new links
//              or NULL if not interested
STDAPI SHCreateLinks(HWND hwnd, LPCTSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl)
{
    DECLAREWAITCURSOR;
    STGMEDIUM medium;
    HRESULT hr;

    SetWaitCursor();

    LPIDA pida = DataObj_GetHIDA(pDataObj, &medium);
    if (pida)
    {
        TCHAR szTargetDir[MAX_PATH];
        hr = S_OK;          // In case hida contains zero elements

        szTargetDir[0] = 0;

        if (pszDir)
            lstrcpyn(szTargetDir, pszDir, ARRAYSIZE(szTargetDir));

        if (!(fFlags & SHCL_USEDESKTOP))
            fFlags |= SHCL_CONFIRM;

        for (UINT i = 0; i < pida->cidl; i++)
        {
            LPITEMIDLIST pidlTo = IDA_ILClone(pida, i);
            if (pidlTo)
            {
                hr = _CreateLinkRetryDesktop(hwnd, pidlTo, szTargetDir, fFlags, ppidl ? &ppidl[i] : NULL);

                ILFree(pidlTo);

                if (FAILED(hr))
                    break;
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
        hr = E_OUTOFMEMORY;

    SHChangeNotifyHandleEvents();
    ResetWaitCursor();

    return hr;
}

#if 1
HRESULT SelectPidlInSFV(IShellFolderViewDual *psfv, LPCITEMIDLIST pidl, DWORD dwOpts)
{
    VARIANT var;
    HRESULT hr = InitVariantFromIDList(&var, pidl);
    if (SUCCEEDED(hr))
    {
        hr = psfv->SelectItem(&var, dwOpts);
        VariantClear(&var);
    }
    return hr;
}

HRESULT OpenFolderAndGetView(LPCITEMIDLIST pidlFolder, IShellFolderViewDual **ppsfv)
{
    *ppsfv = NULL;

    IWebBrowserApp *pauto;
    HRESULT hr = SHGetIDispatchForFolder(pidlFolder, &pauto);
    if (SUCCEEDED(hr))
    {
        HWND hwnd;
        if (SUCCEEDED(pauto->get_HWND((LONG_PTR*)&hwnd)))
        {
            // Make sure we make this the active window
            SetForegroundWindow(hwnd);
            ShowWindow(hwnd, SW_SHOWNORMAL);
        }

        IDispatch *pdoc;
        hr = pauto->get_Document(&pdoc);
        if (S_OK == hr) // careful, automation returns S_FALSE
        {
            hr = pdoc->QueryInterface(IID_PPV_ARG(IShellFolderViewDual, ppsfv));
            pdoc->Release();
        }
        else
            hr = E_FAIL;
        pauto->Release();
    }
    return hr;
}

// pidlFolder   - fully qualified pidl to the folder to open
// cidl/apidl   - array of items in that folder to select
//
// if cild == 0 then pidlFolder is the fully qualified pidl to a single item, it's
// folder is opened and it is selected.
//
// dwFlags - optional flags, pass 0 for now

SHSTDAPI SHOpenFolderAndSelectItems(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl, DWORD dwFlags)
{
    HRESULT hr;
    if (0 == cidl)
    {
        // overload the 0 item case to mean pidlFolder is the full pidl to the item
        LPITEMIDLIST pidlTemp;
        hr = SHILClone(pidlFolder, &pidlTemp);
        if (SUCCEEDED(hr))
        {
            ILRemoveLastID(pidlTemp); // strip to the folder
            LPCITEMIDLIST pidl = ILFindLastID(pidlFolder);

            hr = SHOpenFolderAndSelectItems(pidlTemp, 1, &pidl, 0); // recurse

            ILFree(pidlTemp);
        }
    }
    else
    {
        IShellFolderViewDual *psfv;
        hr = OpenFolderAndGetView(pidlFolder, &psfv);
        if (SUCCEEDED(hr))
        {
            DWORD dwSelFlags = SVSI_SELECT | SVSI_FOCUSED | SVSI_DESELECTOTHERS | SVSI_ENSUREVISIBLE;
            for (UINT i = 0; i < cidl; i++)
            {
                hr = SelectPidlInSFV(psfv, apidl[i], dwSelFlags);
                dwSelFlags = SVSI_SELECT;   // second items append to sel
            }
           psfv->Release();
        }
    }
    return hr;
}

#else
HRESULT OpenFolderAndGetView(LPCITEMIDLIST pidlFolder, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IWebBrowserApp *pauto;
    HRESULT hr = SHGetIDispatchForFolder(pidlFolder, &pauto);
    if (SUCCEEDED(hr))
    {
        HWND hwnd;
        if (SUCCEEDED(pauto->get_HWND((LONG_PTR*)&hwnd)))
        {
            // Make sure we make this the active window
            SetForegroundWindow(hwnd);
            ShowWindow(hwnd, SW_SHOWNORMAL);
        }

        IShellBrowser* psb;
        hr = IUnknown_QueryService(pauto, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
        if (SUCCEEDED(hr)) 
        {
            IShellView* psv;
            hr = psb->QueryActiveShellView(&psv);
            if (SUCCEEDED(hr)) 
            {
                hr = psv->QueryInterface(riid, ppv);
                psv->Release();
            }
            psb->Release();
        }

        pauto->Release();
    }
    return hr;
}

// pidlFolder   - fully qualified pidl to the folder to open
// cidl/apidl   - array of items in that folder to select
//
// if cild == 0 then pidlFolder is the fully qualified pidl to a single item, it's
// folder is opened and it is selected.
//
// dwFlags - optional flags, pass 0 for now

SHSTDAPI SHOpenFolderAndSelectItems(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl, DWORD dwFlags)
{
    HRESULT hr;
    if (0 == cidl)
    {
        // overload the 0 item case to mean pidlFolder is the full pidl to the item
        LPITEMIDLIST pidlTemp;
        hr = SHILClone(pidlFolder, &pidlTemp);
        if (SUCCEEDED(hr))
        {
            ILRemoveLastID(pidlTemp); // strip to the folder
            LPCITEMIDLIST pidl = ILFindLastID(pidlFolder);

            hr = SHOpenFolderAndSelectItems(pidlTemp, 1, &pidl, 0); // recurse

            ILFree(pidlTemp);
        }
    }
    else
    {
        IFolderView *pfv;
        hr = OpenFolderAndGetView(pidlFolder, IID_PPV_ARG(IFolderView, &pfv));
        if (SUCCEEDED(hr))
        {
            pfv->SelectAndPositionItems(1, apidl, NULL, SVSI_SELECT | SVSI_FOCUSED | SVSI_DESELECTOTHERS | SVSI_ENSUREVISIBLE);
            if (cidl > 1)
                pfv->SelectAndPositionItems(cidl - 1, apidl + 1, NULL, SVSI_SELECT);
           pfv->Release();
        }
    }
    return hr;
}
#endif

SHSTDAPI SHCreateShellItem(LPCITEMIDLIST pidlParent, IShellFolder *psfParent, LPCITEMIDLIST pidl, IShellItem **ppsi)
{
    *ppsi = NULL;
    IShellItem *psi;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellItem, NULL, IID_PPV_ARG(IShellItem, &psi));
    if (SUCCEEDED(hr))
    {
        if (pidlParent || psfParent)
        {
            IParentAndItem *pinit;

            ASSERT(pidl);

            hr = psi->QueryInterface(IID_PPV_ARG(IParentAndItem, &pinit));
            if (SUCCEEDED(hr))
            {
                hr = pinit->SetParentAndItem(pidlParent, psfParent, pidl);
                pinit->Release();
            }
        }
        else
        {
            IPersistIDList *pinit;
            hr = psi->QueryInterface(IID_PPV_ARG(IPersistIDList, &pinit));
            if (SUCCEEDED(hr))
            {
                hr = pinit->SetIDList(pidl);
                pinit->Release();
            }
        }

        if (SUCCEEDED(hr))
            *ppsi = psi;
        else
            psi->Release();
    }

    return hr;
}

STDAPI SHCreateShellItemFromParent(IShellItem *psiParent, LPCWSTR pszName, IShellItem **ppsi)
{
    *ppsi = NULL;

    IShellFolder *psf;
    HRESULT hr = psiParent->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = SHGetIDListFromUnk(psiParent, &pidl);
        if (SUCCEEDED(hr))
        {
            ULONG cchEaten;
            LPITEMIDLIST pidlChild;
            hr = psf->ParseDisplayName(NULL, NULL, (LPWSTR)pszName, &cchEaten, &pidlChild, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHCreateShellItem(pidl, psf, pidlChild, ppsi);
                ILFree(pidlChild);
            }
            ILFree(pidl);
        }
        psf->Release();
    }

    return hr;
}

SHSTDAPI SHSetLocalizedName(LPWSTR pszPath, LPCWSTR pszResModule, int idsRes)
{
    IShellFolder *psfDesktop;
    HRESULT hrInit = SHCoInitialize();
    HRESULT hr = hrInit;

    if (SUCCEEDED(hrInit))
    {
        hr = SHGetDesktopFolder(&psfDesktop);

        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = psfDesktop->ParseDisplayName(NULL, NULL, pszPath, NULL, &pidl, NULL);
        
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlChild;
                IShellFolder *psf;
                hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);

                if (SUCCEEDED(hr))
                {
                    //  WARNING - this is a stack sensitive function - ZekeL 29-Jan-2001
                    //  since this function is called by winlogon/userenv
                    //  we need to be sensitive to the stack limitations of those callers

                    //  the shortname will be no larger than the long name
                    DWORD cchShort = lstrlenW(pszResModule) + 1;
                    WCHAR *pszShort = (WCHAR *)alloca(CbFromCchW(cchShort));
                    DWORD cch = GetShortPathName(pszResModule, pszShort, cchShort);
                    if (cch)
                    {
                        pszResModule = pszShort;
                    }
                    else
                    {
                        //  GSPN() fails when the module passed in is a relative path
                        cch = cchShort;
                    }
                        
                    cch += 14;  //  11 for id + ',' + '@' + null
                    WCHAR *pszName = (WCHAR *)alloca(CbFromCchW(cch));
                    wnsprintfW(pszName, cch, L"@%s,%d", pszResModule, (idsRes * -1));
                    
                    hr = psf->SetNameOf(NULL, pidlChild, pszName, SHGDN_NORMAL, NULL);

                    psf->Release();
                }
                SHFree(pidl);
            }
            psfDesktop->Release();
        }
    }

    SHCoUninitialize(hrInit);

    return hr;
}

// ShellHookProc was mistakenly exported in the original NT SHELL32.DLL when
// it didn't need to be (hookproc's, like wndproc's don't need to be exported
// in the 32-bit world).  In order to maintain loadability of a app
// which might have linked to it, we stub it here.  If some app ended up really
// using it, then we'll look into a specific fix for that app.
STDAPI_(LONG) ShellHookProc(int code, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

// RegisterShellHook - wrapper around RegisterShellHookWindow()/DeregisterShellHookWindow()
// the GetTaskmanWindow() stuff is legacy that I don't think is really needed

HWND g_hwndTaskMan = NULL;

STDAPI_(BOOL) RegisterShellHook(HWND hwnd, BOOL fInstall)
{
    BOOL fOk = TRUE;

    switch (fInstall) 
    {
    case 0:
        // un-installation of shell hooks
        g_hwndTaskMan = GetTaskmanWindow();
        if (hwnd == g_hwndTaskMan)
        {
            SetTaskmanWindow(NULL);
        }
        DeregisterShellHookWindow(hwnd);
        return TRUE;

    case 3:
        // explorer.exe Tray uses this
        if (g_hwndTaskMan != NULL)
        {
            SetTaskmanWindow(NULL);
            g_hwndTaskMan = NULL;
        }
        fOk = SetTaskmanWindow(hwnd);
        if (fOk)
        {
            g_hwndTaskMan = hwnd;
        }
        RegisterShellHookWindow(hwnd);   // install
        break;
    }
    return TRUE;
}

EXTERN_C DWORD g_dwThreadBindCtx;

class CThreadBindCtx : public IBindCtx
{
public:
    CThreadBindCtx(IBindCtx *pbc) : _cRef(1) { _pbc = pbc; _pbc->AddRef(); }
    ~CThreadBindCtx();
    
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IBindCtx methods ***
    STDMETHODIMP RegisterObjectBound(IUnknown *punk)
    {   return _pbc->RegisterObjectBound(punk); }
    
    STDMETHODIMP RevokeObjectBound(IUnknown *punk)
    {   return _pbc->RevokeObjectBound(punk); }
    
    STDMETHODIMP ReleaseBoundObjects(void)
    {   return _pbc->ReleaseBoundObjects(); }
    
    STDMETHODIMP SetBindOptions(BIND_OPTS *pbindopts)
    {   return _pbc->SetBindOptions(pbindopts); }
    
    STDMETHODIMP GetBindOptions(BIND_OPTS *pbindopts)
    {   return _pbc->GetBindOptions(pbindopts); }
    
    STDMETHODIMP GetRunningObjectTable(IRunningObjectTable **pprot)
    {   return _pbc->GetRunningObjectTable(pprot); }
    
    STDMETHODIMP RegisterObjectParam(LPOLESTR pszKey, IUnknown *punk)
    {   return _pbc->RegisterObjectParam(pszKey, punk); }
    
    STDMETHODIMP GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk)
    {   return _pbc->GetObjectParam(pszKey, ppunk); }
    
    STDMETHODIMP EnumObjectParam(IEnumString **ppenum)
    {   return _pbc->EnumObjectParam(ppenum); }
    
    STDMETHODIMP RevokeObjectParam(LPOLESTR pszKey)
    {   return _pbc->RevokeObjectParam(pszKey); }
    
private:
    LONG _cRef;
    IBindCtx *  _pbc;
};

CThreadBindCtx::~CThreadBindCtx()
{
    ATOMICRELEASE(_pbc);
}

HRESULT CThreadBindCtx::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThreadBindCtx, IBindCtx),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CThreadBindCtx::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CThreadBindCtx::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    //  clear ourselves out
    TlsSetValue(g_dwThreadBindCtx, NULL);
    return 0;
}

STDAPI TBCGetBindCtx(BOOL fCreate, IBindCtx **ppbc)
{
    HRESULT hr = E_UNEXPECTED;
    *ppbc = NULL;
    if ((DWORD) -1 != g_dwThreadBindCtx)
    {
        CThreadBindCtx *ptbc = (CThreadBindCtx *)TlsGetValue(g_dwThreadBindCtx);
        if (ptbc)
        {
            ptbc->AddRef();
            *ppbc = SAFECAST(ptbc, IBindCtx *);
            hr = S_OK;
        }
        else if (fCreate)
        {
            IBindCtx *pbcInner;
            hr = CreateBindCtx(0, &pbcInner);

            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;
                ptbc = new CThreadBindCtx(pbcInner);
                if (ptbc)
                {
                    if (TlsSetValue(g_dwThreadBindCtx, ptbc))
                    {
                        *ppbc = SAFECAST(ptbc, IBindCtx *);
                        hr = S_OK;
                    }
                    else
                        delete ptbc;
                }
                pbcInner->Release();
            }
        }
    }

    return hr;
}

STDAPI TBCRegisterObjectParam(LPCOLESTR pszKey, IUnknown *punk, IBindCtx **ppbcLifetime)
{
    IBindCtx *pbc;
    HRESULT hr = TBCGetBindCtx(TRUE, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = BindCtx_RegisterObjectParam(pbc, pszKey, punk, ppbcLifetime);
        pbc->Release();    
    }
    else
        *ppbcLifetime = 0;
    
    return hr;
}

STDAPI TBCGetObjectParam(LPCOLESTR pszKey, REFIID riid, void **ppv)
{
    IBindCtx *pbc;
    HRESULT hr = TBCGetBindCtx(FALSE, &pbc);
    if (SUCCEEDED(hr))
    {
        IUnknown *punk;
        hr = pbc->GetObjectParam((LPOLESTR)pszKey, &punk);
        if (SUCCEEDED(hr) )
        {
            if (ppv)
                hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
        pbc->Release();
    }
    return hr;
}

#define TBCENVOBJECT    L"ThreadEnvironmentVariables"
STDAPI TBCGetEnvironmentVariable(LPCWSTR pszVar, LPWSTR pszValue, DWORD cchValue)
{
    IPropertyBag *pbag;
    HRESULT hr = TBCGetObjectParam(TBCENVOBJECT, IID_PPV_ARG(IPropertyBag, &pbag));
    if (SUCCEEDED(hr))
    {
        hr = SHPropertyBag_ReadStr(pbag, pszVar, pszValue, cchValue);
        pbag->Release();
    }
    return hr;
}

STDAPI TBCSetEnvironmentVariable(LPCWSTR pszVar, LPCWSTR pszValue, IBindCtx **ppbcLifetime)
{
    *ppbcLifetime = 0;
    IPropertyBag *pbag;
    HRESULT hr = TBCGetObjectParam(TBCENVOBJECT, IID_PPV_ARG(IPropertyBag, &pbag));

    if (FAILED(hr))
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &pbag));

    if (SUCCEEDED(hr))
    {
        hr = SHPropertyBag_WriteStr(pbag, pszVar, pszValue);

        if (SUCCEEDED(hr))
            hr = TBCRegisterObjectParam(TBCENVOBJECT, pbag, ppbcLifetime);

        pbag->Release();
    }

    return hr;
}

// create a stock IExtractIcon handler for a thing that is file like. this is typically
// used by name space extensiosn that display things that are like files in the
// file system. that is the extension, file attributes decrive all that is needed
// for a simple icon extractor

STDAPI SHCreateFileExtractIconW(LPCWSTR pszFile, DWORD dwFileAttributes, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;

    SHFILEINFO sfi = {0};
    if (SHGetFileInfo(pszFile, dwFileAttributes, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES))
    {
        hr = SHCreateDefExtIcon(TEXT("*"), sfi.iIcon, sfi.iIcon, GIL_PERCLASS | GIL_NOTFILENAME, -1, riid, ppv);
        DestroyIcon(sfi.hIcon);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\sharedfldr.cpp ===
#include "shellprv.h"
#include "util.h"
#include "ids.h"
#include "infotip.h"
#include "fstreex.h"
#include "lm.h"
#include "shgina.h"
#include "prop.h"
#include "datautil.h"
#include "filefldr.h"
#include "buytasks.h"
#pragma hdrstop


// this define causes the shared folder code to work on domains (for debug)
//#define SHOW_SHARED_FOLDERS 

// filter out the current user accounts
#define FILTER_CURRENT_USER 0

// where do we store the doc folder paths
#define REGSTR_PATH_DOCFOLDERPATH  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DocFolderPaths")

// state API for showing the shared documents folder

STDAPI_(BOOL) SHShowSharedFolders()
{
#ifndef SHOW_SHARED_FOLDERS
    // restriction overrides all logic for the shared documents

    if (SHRestricted(REST_NOSHAREDDOCUMENTS))
        return FALSE;

    // if we haven't computed the "show shared folders flag" then do so

    static int iShow = -1;
    if (iShow == -1)      
        iShow = IsOS(OS_DOMAINMEMBER) ? 0:1;    // only works if we are not a domain user

    return (iShow >= 1);
#else
    return true;
#endif
}


// implementation of a delegate shell folder for merging in shared documents

STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);

HRESULT CSharedDocsEnum_CreateInstance(HDPA hItems, DWORD grfFlags, IEnumIDList **ppenum);

#pragma pack(1)
typedef struct
{
    // these memebers overlap DELEGATEITEMID struct
    // for our IDelegateFolder support
    WORD cbSize;
    WORD wOuter;
    WORD cbInner;

    // our stuff
    DWORD dwType;               // our type of folder
    TCHAR wszID[1];             // unique ID for the user
} SHAREDITEM;
#pragma pack()

typedef UNALIGNED SHAREDITEM * LPSHAREDITEM;
typedef const UNALIGNED SHAREDITEM * LPCSHAREDITEM;

#define SHAREDID_COMMON 0x0
#define SHAREDID_USER   0x2


class CSharedDocuments : public IDelegateFolder, IPersistFolder2, IShellFolder2, IShellIconOverlay
{
public:
    CSharedDocuments();
    ~CSharedDocuments();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDelegateFolder
    STDMETHODIMP SetItemAlloc(IMalloc *pmalloc);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pclsid)
        { *pclsid = CLSID_SharedDocuments; return S_OK; }
        
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        { return BindToObject(pidl, pbc, riid, ppv); }
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
        { return E_NOTIMPL; }
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,REFIID riid, UINT* prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST* ppidlOut)
        { return E_NOTIMPL; }

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
        { return E_NOTIMPL; }
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
        { return E_NOTIMPL; }

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
        { return _GetOverlayIndex(pidl, pIndex, FALSE); }
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
        { return _GetOverlayIndex(pidl, pIconIndex, TRUE); }

private:
    LONG _cRef;
    IMalloc *_pmalloc;
    LPITEMIDLIST _pidl;

    CRITICAL_SECTION _cs;                   // critical section for managing lifetime of the cache

    TCHAR _szCurrentUser[UNLEN+1];          // user name (cached for current user)

    BOOL _fCachedAllUser:1;                 // cached the all user account
    TCHAR _szCachedUser[UNLEN+1];           //  if (FALSE) then this contains the user ID.

    IUnknown *_punkCached;                  // IUnknown object (from FS folder) that we cache
    LPITEMIDLIST _pidlCached;               // IDLIST of the cached folder

    void _ClearCachedObjects();
    BOOL _IsCached(LPCITEMIDLIST pidl);
    HRESULT _CreateFolder(LPBC pbc, LPCITEMIDLIST pidl, REFIID riid, void **ppv, BOOL fRegisterAlias);
    HRESULT _GetTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);
    HRESULT _GetTargetIDList(BOOL fForceReCache, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);
    HRESULT _AddIDList(HDPA hdpa, DWORD dwType, LPCTSTR pszUser);
    HRESULT _AllocIDList(DWORD dwType, LPCTSTR pszUser, LPITEMIDLIST *ppidl);
    HRESULT _GetSharedFolders(HDPA *phItems);
    HRESULT _GetAttributesOf(LPCITEMIDLIST pidl, DWORD rgfIn, DWORD *prgfOut);
    LPCTSTR _GetUserFromIDList(LPCITEMIDLIST pidl, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _GetPathForUser(LPCTSTR pcszUser, LPTSTR pszBuffer, int cchBuffer);
    HRESULT _GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex, BOOL fIcon);

    static HRESULT s_FolderMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    friend class CSharedDocsEnum;
};


// constructors

CSharedDocuments::CSharedDocuments() :
    _cRef(1)
{
    InitializeCriticalSection(&_cs);
}

CSharedDocuments::~CSharedDocuments()
{
    ATOMICRELEASE(_pmalloc);
    ATOMICRELEASE(_punkCached);

    ILFree(_pidlCached);
    ILFree(_pidl);
    
    DeleteCriticalSection(&_cs);
}

STDAPI CSharedDocFolder_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv)
{
    CSharedDocuments *psdf = new CSharedDocuments;
    if (!psdf)
        return E_OUTOFMEMORY;

    HRESULT hr = psdf->QueryInterface(riid, ppv);
    psdf->Release();
    return hr;
}


// IUnknown handling

STDMETHODIMP CSharedDocuments::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSharedDocuments, IDelegateFolder),                                // IID_IDelegateFolder
        QITABENTMULTI(CSharedDocuments, IShellFolder, IShellFolder2),               // IID_IShellFOlder
        QITABENT(CSharedDocuments, IShellFolder2),                                  // IID_IShellFolder2
        QITABENTMULTI(CSharedDocuments, IPersistFolder, IPersistFolder2),           // IID_IPersistFolder
        QITABENTMULTI(CSharedDocuments, IPersist, IPersistFolder2),                 // IID_IPersist
        QITABENT(CSharedDocuments, IPersistFolder2),                                // IID_IPersistFolder2
        QITABENT(CSharedDocuments, IShellIconOverlay),                              // IID_IShellIconOverlay
        QITABENTMULTI2(CSharedDocuments, IID_IPersistFreeThreadedObject, IPersist), // IID_IPersistFreeThreadedObject
        { 0 },
    };

    if (riid == CLSID_SharedDocuments)
    {
        *ppv = this;                        // no ref
        return S_OK;
    }

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSharedDocuments::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSharedDocuments::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
            
    delete this;
    return 0;
}

// IDelegateFolder
HRESULT CSharedDocuments::SetItemAlloc(IMalloc *pmalloc)
{
    IUnknown_Set((IUnknown**)&_pmalloc, pmalloc);
    return S_OK;
}


HRESULT CSharedDocuments::Initialize(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    return SHILClone(pidl, &_pidl);
}

HRESULT CSharedDocuments::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return SHILClone(_pidl, ppidl);
}


// single level cache for the objects

void CSharedDocuments::_ClearCachedObjects()
{
    ATOMICRELEASE(_punkCached);      // clear out the cached items (old)
    ILFree(_pidlCached);
    _pidlCached = NULL;
}

BOOL CSharedDocuments::_IsCached(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;

    TCHAR szUser[UNLEN+1];
    if (_GetUserFromIDList(pidl, szUser, ARRAYSIZE(szUser)))    
    {
        // did we cache the users account information?

        if (!_szCachedUser[0] || (StrCmpI(_szCachedUser, szUser) != 0))
        {
            _fCachedAllUser = FALSE;
            StrCpyN(_szCachedUser, szUser, ARRAYSIZE(_szCachedUser));
            _ClearCachedObjects();
        }
        else
        {
            fResult = TRUE;             // were set!
        }
    }
    else
    {
        // the all user case is keyed on a flag rather than the
        // account name we are supposed to be using.

        if (!_fCachedAllUser)
        {
            _fCachedAllUser = TRUE;
            _szCachedUser[0] = TEXT('\0');
            _ClearCachedObjects();
        }
        else
        {   
            fResult = TRUE;             // were set
        }
    }

    return fResult;
}

// IShellFolder methods

HRESULT CSharedDocuments::_CreateFolder(LPBC pbc, LPCITEMIDLIST pidl, REFIID riid, void **ppv, BOOL fRegisterAlias)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&_cs);

    // get the target folder (were already in a critical section) 
    // and then bind down to the shell folder if we have not already
    // cached one for ourselves.

    if (!_IsCached(pidl) || !_punkCached)
    {
        LPITEMIDLIST pidlTarget;
        hr = _GetTargetIDList(TRUE, pidl, &pidlTarget); // clears _punkCached in here (so no leak)
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlInit;
            hr = SHILCombine(_pidl, pidl, &pidlInit);
            if (SUCCEEDED(hr))
            {
                hr = SHCoCreateInstance(NULL, &CLSID_ShellFSFolder, NULL, IID_PPV_ARG(IUnknown, &_punkCached));
                if (SUCCEEDED(hr))
                {
                    IPersistFolder3 *ppf;
                    hr = _punkCached->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf));
                    if (SUCCEEDED(hr))
                    {
                        PERSIST_FOLDER_TARGET_INFO pfti = {0};
                        pfti.pidlTargetFolder = (LPITEMIDLIST)pidlTarget;
                        pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
                        pfti.csidl = -1;
                        hr = ppf->InitializeEx(NULL, pidlInit, &pfti);
                        ppf->Release();
                    }

                    if (SUCCEEDED(hr) && fRegisterAlias)
                        SHChangeNotifyRegisterAlias(pidlTarget, pidlInit);

                    if (FAILED(hr))
                    {
                        _punkCached->Release();
                        _punkCached = NULL;
                    }
                }
                ILFree(pidlInit);
            }
            ILFree(pidlTarget);
        }
    }

    if (SUCCEEDED(hr))
        hr = _punkCached->QueryInterface(riid, ppv);

    LeaveCriticalSection(&_cs);
    return hr;
}


HRESULT CSharedDocuments::_GetTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    EnterCriticalSection(&_cs);
    HRESULT hr = _GetTargetIDList(FALSE, pidl, ppidl);
    LeaveCriticalSection(&_cs);
    return hr;
}

HRESULT CSharedDocuments::_GetTargetIDList(BOOL fForceReCache, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;
    if (fForceReCache || !_IsCached(pidl) || !_pidlCached)
    {
        _ClearCachedObjects();              // we don't have it cached now

        LPCSHAREDITEM psid = (LPCSHAREDITEM)pidl;
        if (psid->dwType == SHAREDID_COMMON)
        {
            hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DOCUMENTS|CSIDL_FLAG_NO_ALIAS, &_pidlCached);
        }
        else if (psid->dwType == SHAREDID_USER)
        {
            TCHAR szPath[MAX_PATH], szUser[UNLEN+1];
            hr = _GetPathForUser(_GetUserFromIDList(pidl, szUser, ARRAYSIZE(szUser)), szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hr))
            {
                hr = ILCreateFromPathEx(szPath, NULL, ILCFP_FLAG_NO_MAP_ALIAS, &_pidlCached, NULL);
            }
        }
        else
        {
            hr = E_INVALIDARG;              // invalid IDLIST passed
        }
    }

    if (SUCCEEDED(hr))
        hr = SHILClone(_pidlCached, ppidl);
    
    return hr;
}

HRESULT CSharedDocuments::_AddIDList(HDPA hdpa, DWORD dwType, LPCTSTR pszUser)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _AllocIDList(dwType, pszUser, &pidl);
    if (SUCCEEDED(hr))
    {
        DWORD grfFlags = SFGAO_FOLDER;
        hr = _GetAttributesOf(pidl, SFGAO_FOLDER, &grfFlags);
        if (SUCCEEDED(hr) && grfFlags & SFGAO_FOLDER)
        {        
            if (-1 == DPA_AppendPtr(hdpa, pidl))
            {
                ILFree(pidl);
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = S_OK;
            }
        }
        else
        {
            ILFree(pidl); 
        }   
    }
    return hr;
}


HRESULT CSharedDocuments::_AllocIDList(DWORD dwType, LPCTSTR pszUser, LPITEMIDLIST *ppidl)
{
    DWORD cb = sizeof(SHAREDITEM);
    int cchUser = pszUser ? lstrlen(pszUser) + 1 : 0;

    // ID list contains strings if its a user 
    
    if (dwType == SHAREDID_USER)
        cb += sizeof(TCHAR) * cchUser;

    SHAREDITEM *psid = (SHAREDITEM*)_pmalloc->Alloc(cb);
    if (!psid)
        return E_OUTOFMEMORY;

    psid->dwType = dwType;                  // type is universal

    if (dwType == SHAREDID_USER)
        StrCpyW(psid->wszID, pszUser);   

    *ppidl = (LPITEMIDLIST)psid;
    return S_OK;
}

LPCTSTR CSharedDocuments::_GetUserFromIDList(LPCITEMIDLIST pidl, LPTSTR pszUser, int cchUser)
{
    LPCSHAREDITEM psid = (LPCSHAREDITEM)pidl;

    if (psid->dwType == SHAREDID_COMMON)
    {
        pszUser[0] = 0;               // initialize
        return NULL;
    }

    ualstrcpynW(pszUser, psid->wszID, cchUser);
    return pszUser;
}

HRESULT CSharedDocuments::_GetPathForUser(LPCTSTR pszUser, LPTSTR pszBuffer, int cchBuffer)
{
    HRESULT hr = E_FAIL;
    BOOL fResult = FALSE;

    if (!pszUser)
    {
        // get the common documents path (which covers all users), this user is always defined
        // so lets return TRUE if they just want to check to see if its defined, otherwise
        // just pass out the result from fetching the path.

        fResult = !pszBuffer || (SHGetSpecialFolderPath(NULL, pszBuffer, CSIDL_COMMON_DOCUMENTS, FALSE));
    }
    else
    {
        // we have a user ID, so lets attempt to get the path fro that from the registry
        // if we get it then pass it back to the caller.

        DWORD dwType;
        DWORD cbBuffer = cchBuffer*sizeof(TCHAR);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DOCFOLDERPATH, pszUser, &dwType,  pszBuffer, &cbBuffer))
        {
            fResult = ((dwType == REG_SZ) && cbBuffer);      // did we get a value back?
        }
    }

    if (fResult)
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CSharedDocuments::_GetSharedFolders(HDPA *phItems)
{
    HRESULT hr = E_OUTOFMEMORY;
    HDPA hItems = DPA_Create(16);
    if (hItems)
    {
        if (!IsUserAGuest()) // all other users' my documents folders should appear in my computer for non-guest users on workgroup machines
        {
            ILogonEnumUsers *peu;
            hr = SHCoCreateInstance(NULL, &CLSID_ShellLogonEnumUsers, NULL, IID_PPV_ARG(ILogonEnumUsers, &peu));
            if (SUCCEEDED(hr))
            {
                UINT cUsers, iUser;
                hr = peu->get_length(&cUsers);
                for (iUser = 0; (cUsers != iUser) && SUCCEEDED(hr); iUser++)
                {
                    VARIANT varUser = {VT_I4};
                    InitVariantFromInt(&varUser, iUser);

                    ILogonUser *plu;
                    hr = peu->item(varUser, &plu);
                    if (SUCCEEDED(hr))
                    {
                        // only show document folders for users that can log in
                        VARIANT_BOOL vbLogonAllowed;
                        hr = plu->get_interactiveLogonAllowed(&vbLogonAllowed);
                        if (SUCCEEDED(hr) && (vbLogonAllowed != VARIANT_FALSE))
                        {
                            // get the user name as this is our key to to the users documents path
                            VARIANT var = {0};
                            hr = plu->get_setting(L"LoginName", &var);
                            if (SUCCEEDED(hr))
                            {
#if FILTER_CURRENT_USER                            
                                if (!_szCurrentUser[0])
                                {
                                    DWORD cchUser = ARRAYSIZE(_szCurrentUser);
                                    if (!GetUserName(_szCurrentUser, &cchUser))
                                    {
                                        _szCurrentUser[0] = TEXT('\0');
                                    }
                                }

                                if (!_szCurrentUser[0] || (StrCmpI(var.bstrVal, _szCurrentUser) != 0))
                                {
                                    HRESULT hrT = _AddIDList(hItems, SHAREDID_USER, var.bstrVal);
                                    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrT)
                                    {
                                        SHDeleteValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DOCFOLDERPATH, var.bstrVal);
                                    }                                    
                                }
#else
                                HRESULT hrT = _AddIDList(hItems, SHAREDID_USER, var.bstrVal);
                                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrT)
                                {
                                    SHDeleteValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DOCFOLDERPATH, var.bstrVal);
                                }                                    
#endif
                                VariantClear(&var);
                            }
                        }
                        plu->Release();
                    }
                }

                peu->Release();
            }            
        }

        _AddIDList(hItems, SHAREDID_COMMON, NULL);  
        hr = S_OK;
    }

    *phItems = hItems;
    return hr;
}


// parsing support allows us to pick off SharedDocuments from the root
// of the shell namespace and navigate there - this a canonical name
// that we use for binding to the shared documents folder attached
// to the My Computer namespace.

HRESULT CSharedDocuments::ParseDisplayName(HWND hwnd, LPBC pbc, LPTSTR pszName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;
    if (SHShowSharedFolders())
    {
        if (0 == StrCmpI(pszName, L"SharedDocuments"))
        {
            hr = _AllocIDList(SHAREDID_COMMON, NULL, ppidl);
            if (SUCCEEDED(hr) && pdwAttributes)
            {
                hr = _GetAttributesOf(*ppidl, *pdwAttributes, pdwAttributes);
            }
        }
    }
    return hr;
}


// enumerate the shared documents folders

HRESULT CSharedDocuments::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    *ppenumIDList = NULL;               // no enumerator yet

    HRESULT hr = S_FALSE;
    if (SHShowSharedFolders())
    {
        HDPA hItems;
        hr = _GetSharedFolders(&hItems);
        if (SUCCEEDED(hr))
        {
            hr = CSharedDocsEnum_CreateInstance(hItems, grfFlags, ppenumIDList);
            if (FAILED(hr))
            {
                DPA_FreeIDArray(hItems);
            }
        }
    }
    return hr;
}


// return the display name for the folders that we have

HRESULT CSharedDocuments::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
{
    HRESULT hr = S_OK; 
    TCHAR szName[MAX_PATH] = {0};
 
    LPCSHAREDITEM psid = (LPCSHAREDITEM)pidl;
    if (((uFlags & (SHGDN_INFOLDER|SHGDN_FORPARSING)) == SHGDN_INFOLDER) && 
         (psid && (psid->dwType == SHAREDID_USER)))
    {
        // compute the <user>'s Documents name that we will show, we key this on 
        // the user name we have in the IDList and its display string.

        USER_INFO_10 *pui;
        TCHAR szUser[MAX_PATH];
        if (NERR_Success == NetUserGetInfo(NULL, _GetUserFromIDList(pidl, szUser, ARRAYSIZE(szUser)), 10, (LPBYTE*)&pui))
        {
            if (*pui->usri10_full_name)
            {
                StrCpyN(szUser, pui->usri10_full_name, ARRAYSIZE(szUser));
            }
            NetApiBufferFree(pui);
        }     

        TCHAR szFmt[MAX_PATH];
        LoadString(g_hinst, IDS_LOCALGDN_FLD_THEIRDOCUMENTS, szFmt, ARRAYSIZE(szFmt));
        wnsprintf(szName, ARRAYSIZE(szName), szFmt, szUser);
    }
    else
    {
        // all other scenarios dump down to the real folder to get their display
        // name for this folder.

        LPITEMIDLIST pidlTarget;
        hr = _GetTarget(pidl, &pidlTarget);
        if (SUCCEEDED(hr))
        {
            hr = SHGetNameAndFlags(pidlTarget, uFlags, szName, ARRAYSIZE(szName), NULL);
            ILFree(pidlTarget);
        }
    }

    if (SUCCEEDED(hr))
        hr = StringToStrRet(szName, lpName);

    return hr;
}

LONG CSharedDocuments::_GetAttributesOf(LPCITEMIDLIST pidl, DWORD rgfIn, DWORD *prgfOut)
{
    DWORD dwResult = rgfIn;
    LPITEMIDLIST pidlTarget;
    HRESULT hr = _GetTarget(pidl, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlChild;
        hr = SHBindToIDListParent(pidlTarget, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetAttributesOf(1, &pidlChild, &dwResult);
            psf->Release();
        }
        ILFree(pidlTarget);
    }

    if (!SHShowSharedFolders())
        dwResult |= SFGAO_NONENUMERATED;

    *prgfOut = *prgfOut & (dwResult & ~(SFGAO_CANDELETE|SFGAO_CANRENAME|SFGAO_CANMOVE|SFGAO_CANCOPY));

    return hr;
}

HRESULT CSharedDocuments::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut)
{
    ULONG rgfOut = *rgfInOut;

    if (!cidl || !apidl)
        return E_INVALIDARG;

    for (UINT i = 0; i < cidl; i++)
        _GetAttributesOf(apidl[i], *rgfInOut, &rgfOut);

    *rgfInOut = rgfOut;
    return S_OK;
}


// bind through our folder 

HRESULT CSharedDocuments::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (IsEqualIID(riid, IID_IShellIconOverlay))
    {
        hr = this->QueryInterface(riid, ppv);
    }
    else
    {
        LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
        if (pidlFirst)
        {
            IShellFolder *psf;
            hr = _CreateFolder(pbc, pidlFirst, IID_PPV_ARG(IShellFolder, &psf), TRUE);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlNext = _ILNext(pidl);
                if (ILIsEmpty(pidlNext))
                {
                    hr = psf->QueryInterface(riid, ppv);
                }
                else
                {
                    hr = psf->BindToObject(pidlNext, pbc, riid, ppv);
                }
                psf->Release();
            }
            ILFree(pidlFirst);
        }
    }
    return hr;
}


// handle UI objects - for the most part we delegate to the real namespace implementation

HRESULT CSharedDocuments::s_FolderMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSharedDocuments *psd;
    psf->QueryInterface(CLSID_SharedDocuments, (void **)&psd);

    // defcm will only add the default handlers (eg. Open/Explore) if we have a callback
    // and the DFM_MERGECONTEXTMENU is successful.  so lets honor that so we can navigate

    if (uMsg == DFM_MERGECONTEXTMENU)
    {
        return S_OK;
    }
    else if (uMsg == DFM_INVOKECOMMAND)
    {
        HRESULT hr;
        DFMICS *pdfmics = (DFMICS *)lParam;
        switch (wParam)
        {
            case DFM_CMD_LINK:
                hr = SHCreateLinks(hwnd, NULL, pdo, SHCL_CONFIRM|SHCL_USETEMPLATE|SHCL_USEDESKTOP, NULL);                
                break;
            
            case DFM_CMD_PROPERTIES:
                hr = SHLaunchPropSheet(CFSFolder_PropertiesThread, pdo, (LPCTSTR)lParam, NULL, (void *)&c_idlDesktop);
                break;

            default:
                hr = S_FALSE;           // use the default handler for this item
                break;
        }
        return hr;
    }

    return E_NOTIMPL;
}

HRESULT CSharedDocuments::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl, REFIID riid, UINT* prgfInOut, void **ppv)
{
    if (cidl != 1)
        return E_FAIL;

    HRESULT hr = E_FAIL;
    if (IsEqualIID(riid, IID_IContextMenu))
    {
        // we must construct our own context menu for this item, we do this using the
        // shell default implementation and we pass it the information about a folder
        // that way we can navigate up and down through the namespace.

        IQueryAssociations *pqa;
        hr = GetUIObjectOf(hwnd, 1, apidl, IID_PPV_ARG_NULL(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            // this is broken for docfiles (shell\ext\stgfldr's keys work though)
            // maybe because GetClassFile punts when it's not fs?

            HKEY ahk[MAX_ASSOC_KEYS];
            DWORD cKeys = SHGetAssocKeys(pqa, ahk, ARRAYSIZE(ahk));
            hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, this, 
                                        s_FolderMenuCB, 
                                        cKeys, ahk, 
                                        (IContextMenu **)ppv);
            SHRegCloseKeys(ahk, cKeys);
            pqa->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        hr = SHCreateFileDataObject(_pidl, cidl, apidl, NULL, (IDataObject **)ppv);
    }
    else if (IsEqualIID(riid, IID_IQueryInfo))
    {
        IQueryAssociations *pqa;
        hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            WCHAR szCLSID[GUIDSTR_MAX];
            SHStringFromGUIDW(CLSID_SharedDocuments, szCLSID, ARRAYSIZE(szCLSID));
            hr = pqa->Init(0, szCLSID, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                WCHAR szInfotip[INFOTIPSIZE];
                DWORD cchInfotip = ARRAYSIZE(szInfotip);
                hr = pqa->GetString(0, ASSOCSTR_INFOTIP, NULL, szInfotip, &cchInfotip);
                if (SUCCEEDED(hr))
                {
                    hr = CreateInfoTipFromText(szInfotip, IID_IQueryInfo, ppv); // _the_ InfoTip COM object
                }
            }
            pqa->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations))
    {
        LPITEMIDLIST pidlTarget;
        hr = _GetTarget(apidl[0], &pidlTarget);
        if (SUCCEEDED(hr))
        {
            hr = SHGetUIObjectOf(pidlTarget, hwnd, riid, ppv);
            ILFree(pidlTarget);
        }
    }
    else if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW))
    {
        UINT iIcon = II_FOLDER;
        UINT iIconOpen = II_FOLDEROPEN;

        TCHAR szModule[MAX_PATH];
        GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));

        hr = SHCreateDefExtIcon(szModule, iIcon, iIconOpen, GIL_PERCLASS, -1, riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        IShellFolder *psf;
        hr = _CreateFolder(NULL, *apidl, IID_PPV_ARG(IShellFolder, &psf), TRUE);
        if (SUCCEEDED(hr))
        {
            hr = psf->CreateViewObject(hwnd, riid, ppv);
            psf->Release();
        }
    }
    return hr;
}


HRESULT CSharedDocuments::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = ResultFromShort(0);

    // compare the contents of our IDLIST before we attemt to compare other elements
    // within it.

    LPCSHAREDITEM psid1 = (LPCSHAREDITEM)pidl1;
    LPCSHAREDITEM psid2 = (LPCSHAREDITEM)pidl2;

    if (psid1->dwType == psid2->dwType)
    {
        if (psid1->dwType == SHAREDID_USER)
        {
            hr = ResultFromShort(ualstrcmpi(psid1->wszID, psid2->wszID));
        }
        else
        {
            hr = ResultFromShort(0);            // common item == common item?    
        }
    }
    else
    {
        hr = ResultFromShort(psid1->dwType - psid2->dwType);
    }

    // if there was an exact match then lets compare the trailing elements of the IDLIST
    // if there are some (by binding down) etc.

    if (hr == ResultFromShort(0))
    {
        LPITEMIDLIST pidlNext1 = _ILNext(pidl1);
        LPITEMIDLIST pidlNext2 = _ILNext(pidl2);

        if (ILIsEmpty(pidlNext1))
        {
            if (ILIsEmpty(pidlNext2))
            {
                hr = ResultFromShort(0);    // pidl1 == pidl2 (in length)
            }
            else
            {
                hr = ResultFromShort(-1);   // pidl1 < pidl2 (in length)
            }
        }
        else
        {
            // if IDLIST2 is shorter then return > otherwise we should just
            // recurse down the IDLIST and let the next level compare.

            if (ILIsEmpty(pidlNext2))
            {
                hr = ResultFromShort(+1);   // pidl1 > pidl2 (in lenght)
            }
            else
            {
                LPITEMIDLIST pidlFirst = ILCloneFirst(pidl1);
                if (pidlFirst)
                {
                    IShellFolder *psf;
                    hr = _CreateFolder(NULL, pidlFirst, IID_PPV_ARG(IShellFolder, &psf), FALSE);
                    if (SUCCEEDED(hr))
                    {
                        hr = psf->CompareIDs(lParam, pidlNext1, pidlNext2);
                        psf->Release();    
                    }
                    ILFree(pidlFirst);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    return hr;
}

HRESULT CSharedDocuments::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_FAIL;
    if (IsEqualSCID(SCID_DESCRIPTIONID, *pscid))
    {
        SHDESCRIPTIONID did = {0};
        did.dwDescriptionId = SHDID_COMPUTER_SHAREDDOCS;
        did.clsid = CLSID_NULL;
        hr = InitVariantFromBuffer(pv, &did, sizeof(did));
    }
    else
    {
        LPITEMIDLIST pidlTarget;
        hr = _GetTarget(pidl, &pidlTarget);
        if (SUCCEEDED(hr))
        {
            IShellFolder2 *psf2;
            LPCITEMIDLIST pidlChild;
            hr = SHBindToIDListParent(pidlTarget, IID_PPV_ARG(IShellFolder2, &psf2), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf2->GetDetailsEx(pidlChild, pscid, pv);
                psf2->Release();
            }
            ILFree(pidlTarget);
        }
    }
    return hr;
}


// icon overlay handling.   deligate this to the right handler

HRESULT CSharedDocuments::_GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex, BOOL fGetIconIndex)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = _GetTarget(pidl, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        IShellIconOverlay *psio;
        LPCITEMIDLIST pidlChild;
        hr = SHBindToIDListParent(pidlTarget, IID_PPV_ARG(IShellIconOverlay, &psio), &pidlChild);
        if (SUCCEEDED(hr))
        {   
            if (fGetIconIndex)
            {
                hr = psio->GetOverlayIconIndex(pidlChild, pIndex);
            }
            else
            {
                hr = psio->GetOverlayIndex(pidlChild, pIndex);
            }
            psio->Release();
        }
        ILFree(pidlTarget);
    }
    return hr;
}


// enumerator for listing all the shared documents in the system.

class CSharedDocsEnum : public IEnumIDList
{
private:
    LONG _cRef;
    HDPA _hItems;
    DWORD _grfFlags;
    int _index;

public:
    CSharedDocsEnum(HDPA hItems, DWORD grf);
    ~CSharedDocsEnum();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) 
        { return E_NOTIMPL; }
    STDMETHODIMP Reset()    
        { _index = 0; return S_OK; }
    STDMETHODIMP Clone(IEnumIDList **ppenum) 
        { return E_NOTIMPL; };

};

CSharedDocsEnum::CSharedDocsEnum(HDPA hItems, DWORD grfFlags) :
    _cRef(1),
    _hItems(hItems),
    _grfFlags(grfFlags),
    _index(0)
{
}

CSharedDocsEnum::~CSharedDocsEnum()
{
    DPA_FreeIDArray(_hItems);
}

HRESULT CSharedDocsEnum_CreateInstance(HDPA hItems, DWORD grfFlags, IEnumIDList **ppenum)
{
    CSharedDocsEnum *penum = new CSharedDocsEnum(hItems, grfFlags);
    if (!penum)
        return E_OUTOFMEMORY;

    HRESULT hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
    penum->Release();
    return hr;
}


// IUnknown handling

STDMETHODIMP CSharedDocsEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSharedDocsEnum, IEnumIDList),                              // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSharedDocsEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSharedDocsEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
            
    delete this;
    return 0;
}


// enumeration handling

HRESULT CSharedDocsEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{   
    HRESULT hr = S_FALSE;
    ULONG cFetched = 0;

    if (_grfFlags & SHCONTF_FOLDERS)
    {
        // if we have more items to return and the buffer is still not full
        // then lets ensure that we return them.

        while (SUCCEEDED(hr) && (celt != cFetched) && (_index != DPA_GetPtrCount(_hItems)))
        {
            if (_index != DPA_GetPtrCount(_hItems))
            {
                hr = SHILClone((LPITEMIDLIST)DPA_GetPtr(_hItems, _index), &rgelt[cFetched]);
                if (SUCCEEDED(hr))
                {
                    cFetched++;       
                }
            }
            _index++;
        }
    }

    if (pceltFetched)
        *pceltFetched = cFetched;

    return hr;
}


// handle system initialization of the shared documents objects

void _SetLocalizedName(INT csidl, LPTSTR pszResModule, INT idsRes)
{
    TCHAR szPath[MAX_PATH];
    if (SHGetSpecialFolderPath(NULL, szPath, csidl, TRUE))
    {
        SHSetLocalizedName(szPath, pszResModule, idsRes);
    }
}

HRESULT SHGetSampleMediaFolder(int nAllUsersMediaFolder, LPITEMIDLIST *ppidlSampleMedia);
#define PICTURES_BUYURL L"SamplePictures"
#define SAMPLEMUSIC_BUYURL L"http://windowsmedia.com/redir/xpsample.asp"

STDAPI_(void) InitializeSharedDocs(BOOL fWow64)
{
    // ACL the DocFolder paths key so that users can touch the keys and store their paths
    // for the document folders they have. 

    // we want the "Everyone" to have read/write access
    SHELL_USER_PERMISSION supEveryone;
    supEveryone.susID = susEveryone;
    supEveryone.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supEveryone.dwAccessMask = KEY_READ|KEY_WRITE;
    supEveryone.fInherit = TRUE;
    supEveryone.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supEveryone.dwInheritAccessMask = GENERIC_READ;

    // we want the "SYSTEM" to have full control
    SHELL_USER_PERMISSION supSystem;
    supSystem.susID = susSystem;
    supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supSystem.dwAccessMask = KEY_ALL_ACCESS;
    supSystem.fInherit = TRUE;
    supSystem.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supSystem.dwInheritAccessMask = GENERIC_ALL;

    // we want the "Administrators" to have full control
    SHELL_USER_PERMISSION supAdministrators;
    supAdministrators.susID = susAdministrators;
    supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supAdministrators.dwAccessMask = KEY_ALL_ACCESS;
    supAdministrators.fInherit = TRUE;
    supAdministrators.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supAdministrators.dwInheritAccessMask = GENERIC_ALL;

    PSHELL_USER_PERMISSION aPerms[3] = {&supEveryone, &supSystem, &supAdministrators};
    SECURITY_DESCRIPTOR* psd = GetShellSecurityDescriptor(aPerms, ARRAYSIZE(aPerms));
    if (psd)
    {
        HKEY hk;
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DocFolderPaths"), 0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hk, NULL) == ERROR_SUCCESS)
        {
            RegSetKeySecurity(hk, DACL_SECURITY_INFORMATION, psd);
            RegCloseKey(hk);
        }
        LocalFree(psd);
    }
 
    // do file system initialization as needed so that the shared music/pictures folders
    // have the correct display names.

    if (!fWow64)
    {   
        _SetLocalizedName(CSIDL_COMMON_PICTURES, TEXT("shell32.dll"), IDS_SHAREDPICTURES);    
        _SetLocalizedName(CSIDL_COMMON_MUSIC, TEXT("shell32.dll"), IDS_SHAREDMUSIC);

        // Set the Sample Pictures buy URL
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetSampleMediaFolder(CSIDL_COMMON_PICTURES, &pidl)))
        {
            WCHAR szPath[MAX_PATH];
            WCHAR szDesktopIni[MAX_PATH];
            if (SUCCEEDED(SHGetPathFromIDList(pidl, szPath)) && PathCombine(szDesktopIni, szPath, L"desktop.ini"))
            {
                WritePrivateProfileString(L".ShellClassInfo", c_BuySamplePictures.szURLKey, PICTURES_BUYURL, szDesktopIni);

                // Ensure this is a system folder
                PathMakeSystemFolder(szPath);
            }

            ILFree(pidl);
        }

        // Set the Sample Music buy URL
        if (SUCCEEDED(SHGetSampleMediaFolder(CSIDL_COMMON_MUSIC, &pidl)))
        {
            WCHAR szPath[MAX_PATH];
            WCHAR szDesktopIni[MAX_PATH];
            if (SUCCEEDED(SHGetPathFromIDList(pidl, szPath)) && PathCombine(szDesktopIni, szPath, L"desktop.ini"))
            {
                WritePrivateProfileString(L".ShellClassInfo", c_BuySampleMusic.szURLKey, SAMPLEMUSIC_BUYURL, szDesktopIni);

                // Ensure this is a system folder
                PathMakeSystemFolder(szPath);
            }

            ILFree(pidl);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shell.h ===
/*
 *  shell.h
 *
 *  Header file for shell association database management functions
 */

#include <shellapi.h>   // make sure we don't conflict
#include "winuserp.h"
#include "wowshlp.h"

#ifndef PUBLIC_ONLY

// HANDLE hInstance;               // hinstance of DLL

#define SE_ERR_FNF                      2       // ShellExec() error returns
#define SE_ERR_PNF                      3
#define SE_ERR_OOM                      8


BOOL APIENTRY RegisterShellHook(HWND, BOOL);
#endif  // closes #ifndef PUBLIC_ONLY

//****************************************************************************
// THIS INFORMATION IS PUBLIC

#define CP_WINDOWS              1004        // windows code page

BOOL APIENTRY RegenerateUserEnvironment(PVOID *pPrevEnv,
                                        BOOL bSetCurrentEnv);


int     SheGetCurDrive(VOID);
int     SheSetCurDrive(int iDrive);

int     SheFullPathA(CHAR *fname, DWORD sizpath, CHAR *buf);
int     SheGetDirA(int iDrive, CHAR *str);
int     SheChangeDirA(register CHAR *newdir);

int     SheFullPathW(WCHAR *fname, DWORD sizpath, WCHAR *buf);
int     SheGetDirW(INT iDrive, WCHAR *str);
int     SheChangeDirW(register WCHAR *newdir);

BOOL SheGetDirExW(LPWSTR lpszCurDisk, LPDWORD lpcchCurDir,LPWSTR lpszCurDir);
INT SheChangeDirExW(register WCHAR *newdir);

INT SheChangeDirExA(register CHAR *newdir);

INT SheGetPathOffsetW(LPWSTR lpszDir);

HANDLE APIENTRY InternalExtractIconListA(HANDLE hInst, LPSTR lpszExeFileName, LPINT lpnIcons);
HANDLE APIENTRY InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons);

HICON APIENTRY ExtractAssociatedIconA(HINSTANCE hInst,LPSTR lpIconPath,LPWORD lpiIcon);
HICON APIENTRY ExtractAssociatedIconW(HINSTANCE hInst,LPWSTR lpIconPath,LPWORD lpiIcon);

HICON APIENTRY ExtractAssociatedIconExA(HINSTANCE hInst,LPSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);
HICON APIENTRY ExtractAssociatedIconExW(HINSTANCE hInst,LPWSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);

WORD APIENTRY ExtractIconResInfoA(HANDLE hInst,LPSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
WORD APIENTRY ExtractIconResInfoW(HANDLE hInst,LPWSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);

VOID APIENTRY CheckEscapesA(LPSTR lpFileA, DWORD cch);
VOID APIENTRY CheckEscapesW(LPWSTR szFile, DWORD cch);

LPSTR APIENTRY SheRemoveQuotesA(LPSTR sz);
LPWSTR APIENTRY SheRemoveQuotesW(LPWSTR sz);

BOOL APIENTRY SheShortenPathA(LPSTR pPath, BOOL bShorten);
BOOL APIENTRY SheShortenPathW(LPWSTR pPath, BOOL bShorten);

BOOL SheConvertPathW(LPWSTR lpApp, LPWSTR lpFile, UINT cchCmdBuf);

DWORD ExtractVersionResource16W(LPCWSTR  lpwstrFilename, LPHANDLE lphData);

#ifndef UNICODE
#define RealShellExecute RealShellExecuteA
#define RealShellExecuteEx RealShellExecuteExA
#define SheFullPath SheFullPathA
#define SheGetDir SheGetDirA
#define SheChangeDir SheChangeDirA
#define InternalExtractIconList InternalExtractIconListA
#define ExtractAssociatedIcon ExtractAssociatedIconA
#define ExtractAssociatedIconEx ExtractAssociatedIconExA
#define ExtractIconResInfo ExtractIconResInfoA
#define CheckEscapes CheckEscapesA
#define SheRemoveQuotes SheRemoveQuotesA
#define SheShortenPath SheShortenPathA
#else
#define RealShellExecute RealShellExecuteW
#define RealShellExecuteEx RealShellExecuteExW
#define SheFullPath SheFullPathW
#define SheGetDir SheGetDirW
#define SheChangeDir SheChangeDirW
#define InternalExtractIconList InternalExtractIconListW
#define ExtractAssociatedIcon ExtractAssociatedIconW
#define ExtractAssociatedIconEx ExtractAssociatedIconExW
#define ExtractIconResInfo ExtractIconResInfoW
#define CheckEscapes CheckEscapesW
#define SheRemoveQuotes SheRemoveQuotesW
#define SheShortenPath SheShortenPathW
#endif //unicode

#undef ExpandEnvironmentStrings
#define ExpandEnvironmentStrings #error "Use SHExpandEnvironmentStrings instead"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shell32.inc ===
#
#  Common settings for shell32
#
C_DEFINES= $(C_DEFINES) -DMIME -DDBCS

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES= $(C_DEFINES) -DVSTF
!endif

!if !defined(TARGET_WIN95)
#  (We don't want this defined if we're building for Win95)
C_DEFINES= $(C_DEFINES) -DWINDOWS_ME
!endif

# Defines for nt sdk
C_DEFINES= $(C_DEFINES) -D_NTSDK 

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

# NTRAID 135202 (reinerf) - I promised bryant that I would fix these
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

INCLUDES= \
    $(INCLUDES);                \
    $(PROJECT_ROOT)\shell32;    \
    $(PRINTSCAN_INC_PATH);      \
    $(INETCORE_INC_PATH);       \
    $(DS_INC_PATH);             \
    $(BASE_INC_PATH);           \
    $(TERMSRV_INC_PATH);        \
    $(NET_INC_PATH);            \
    $(ADMIN_INC_PATH);          \
    $(WINDOWS_INC_PATH)\duser;  \
    $(PUBLIC_INTERNAL_PATH)\qfe\inc

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED= $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

USE_STATIC_ATL=1

CONDITIONAL_INCLUDES= \
    $(CONDITIONAL_INCLUDES) \
    filter.h                \
    rcids.h                 \
    tracker.h               \
    ver.h                   \
    unicpp\clsobj.tbl       \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shcombox.cpp ===
#include "shellprv.h"
#include "shcombox.h"
#include "filetype.h"
#include "recdocs.h"
#include "ids.h"

//  Adds the specified item to a comboboxex window
HRESULT AddCbxItemToComboBox(HWND hwndComboEx, PCCBXITEM pItem, INT_PTR *pnPosAdded)
{
    ASSERT(hwndComboEx);

    //  Convert to COMBOBOXEXITEM.
    COMBOBOXEXITEM cei;
    cei.mask            = pItem->mask;
    cei.iItem           = pItem->iItem;
    cei.pszText         = (LPTSTR)pItem->szText;
    cei.cchTextMax      = ARRAYSIZE(pItem->szText);
    cei.iImage          = pItem->iImage;
    cei.iSelectedImage  = pItem->iSelectedImage;
    cei.iOverlay        = pItem->iOverlay;
    cei.iIndent         = pItem->iIndent;
    cei.lParam          = pItem->lParam;

    int nPos = (int)::SendMessage(hwndComboEx, CBEM_INSERTITEM, 0, (LPARAM)&cei);

    *pnPosAdded = nPos;

    return nPos < 0 ? E_FAIL : S_OK;
}

//  Adds the specified item to a comboboxex window, and invokes
//  a notification callback function if successful.
HRESULT AddCbxItemToComboBoxCallback(IN HWND hwndComboEx, IN PCBXITEM pItem, IN ADDCBXITEMCALLBACK pfn, IN LPARAM lParam)
{
    INT_PTR iPos = -1;

    if (pfn && E_ABORT == pfn(CBXCB_ADDING, pItem, lParam))
        return E_ABORT;

    HRESULT hr = AddCbxItemToComboBox(hwndComboEx, pItem, &iPos);
    
    if (pfn && S_OK == hr)
    {
        ((CBXITEM*)pItem)->iItem = iPos;
        pfn(CBXCB_ADDED, pItem, lParam);
    }
    return hr;
}

//  image list indices known
void MakeCbxItemKnownImage(CBXITEM* pcbi, LPCTSTR pszDisplayName, void *pvData, 
                            int iImage, int iSelectedImage, INT_PTR nPos, int iIndent)
{
    ZeroMemory(pcbi, sizeof(*pcbi));

    lstrcpyn(pcbi->szText, pszDisplayName, ARRAYSIZE(pcbi->szText));
    pcbi->lParam = (LPARAM)pvData;
    pcbi->iIndent = iIndent;
    pcbi->iItem = nPos;
    pcbi->mask = (CBEIF_TEXT | CBEIF_INDENT | CBEIF_LPARAM);
    if (-1 != iImage)
    {
        pcbi->mask |= CBEIF_IMAGE;
        pcbi->iImage = iImage;
    }
    if (-1 != iSelectedImage)
    {
        pcbi->mask |= CBEIF_SELECTEDIMAGE;
        pcbi->iSelectedImage = iSelectedImage;
    }
}

//  Retrieves the system image list indices for the specified ITEMIDLIST
HRESULT _GetPidlIcon(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage)
{
    IShellFolder *psfParent;
    LPCITEMIDLIST pidlChild;

    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfParent), &pidlChild);
    if (SUCCEEDED(hr))
    {
        *piImage = SHMapPIDLToSystemImageListIndex(psfParent, pidlChild, NULL);

        *piSelectedImage = *piImage;

        psfParent->Release();
    }
    return hr;
}

//  image icon image list indices unknown
STDAPI_(void) MakeCbxItem(CBXITEM* pcbi, LPCTSTR pszDisplayName, void *pvData, LPCITEMIDLIST pidlIcon, INT_PTR nPos, int iIndent)
{
    int iImage = -1;
    int iSelectedImage = -1;

    if (pidlIcon)
        _GetPidlIcon(pidlIcon, &iImage, &iSelectedImage);

    MakeCbxItemKnownImage(pcbi, pszDisplayName, pvData, iImage, iSelectedImage, nPos, iIndent);
}

HRESULT _MakeFileTypeCbxItem(
    OUT CBXITEM* pcbi, 
    IN  LPCTSTR pszDisplayName, 
    IN  LPCTSTR pszExt, 
    IN  LPCITEMIDLIST pidlIcon, 
    IN  INT_PTR nPos, 
    IN  int iIndent)
{
    HRESULT hr = E_OUTOFMEMORY;
    void *pvData = NULL;
    LPITEMIDLIST pidlToFree = NULL;

    if (!pidlIcon)
    {
        TCHAR szFileName[MAX_PATH] = TEXT("C:\\notexist");       // This is bogus and that's ok

        StrCatBuff(szFileName, pszExt, ARRAYSIZE(szFileName));
        pidlIcon = pidlToFree = SHSimpleIDListFromPath(szFileName);
    }

    if (pidlIcon && Str_SetPtr((LPTSTR *)&pvData, pszExt))
    {
        MakeCbxItem(pcbi, pszDisplayName, pvData, pidlIcon, nPos, iIndent);
        hr = S_OK;
    }

    ILFree(pidlToFree); // may be NULL

    return hr;
}

//  Enumerates children of the indicated special shell item id.
HRESULT EnumSpecialItemIDs(int csidl, DWORD dwSHCONTF, LPFNPIDLENUM_CB pfn, void *pvData)
{
    LPITEMIDLIST pidlFolder;
    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidlFolder)))
    {
        IShellFolder *psf;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf))))
        {
            IEnumIDList * penum;
            if (S_OK == psf->EnumObjects(NULL, dwSHCONTF, &penum))
            {
                LPITEMIDLIST pidl;
                BOOL bContinue = TRUE;

                while (bContinue && (S_OK == penum->Next(1, &pidl, NULL)))
                {
                    LPITEMIDLIST pidlFull = ILCombine(pidlFolder, pidl);
                    if (pidlFull)
                    {
                        if (FAILED(pfn(pidlFull, pvData)))
                            bContinue = FALSE;

                        ILFree(pidlFull);
                    }
                    ILFree(pidl);
                }
                penum->Release();
            }
            psf->Release();
        }
        ILFree(pidlFolder);
    }

    return S_OK;
}

STDAPI_(HIMAGELIST) GetSystemImageListSmallIcons()
{
    HIMAGELIST himlSmall;
    Shell_GetImageLists(NULL, &himlSmall);
    return himlSmall;
}

HRESULT _MakeLocalDrivesCbxItem(CBXITEM* pItem, LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = S_FALSE;
    ULONG ulAttrs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED;

    if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), &ulAttrs)) &&
        ((SFGAO_FOLDER | SFGAO_FILESYSTEM) == (ulAttrs & (SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED))) &&
        (GetDriveType(szPath) == DRIVE_FIXED))
    {
        TCHAR szDisplayName[MAX_PATH];       
        SHGetNameAndFlags(pidl, SHGDN_NORMAL, szDisplayName, SIZECHARS(szDisplayName), NULL);

        LPTSTR pszPath = NULL;
        Str_SetPtr(&pszPath, szPath);

        MakeCbxItem(pItem, szDisplayName, (void *)pszPath, pidl, LISTINSERT_LAST, NO_ITEM_INDENT);
        hr = S_OK;
    }
    return hr;
}

typedef struct
{
    HWND                hwndComboBox;
    ADDCBXITEMCALLBACK  pfn; 
    LPARAM              lParam;
} ENUMITEMPARAM;

HRESULT _PopulateLocalDrivesCB(LPCITEMIDLIST pidl, void *pv) 
{ 
    CBXITEM item;
    HRESULT hr = _MakeLocalDrivesCbxItem(&item, pidl);
    if (hr == S_OK)
    {
        ENUMITEMPARAM *peip = (ENUMITEMPARAM *) pv;
        item.iID = CSIDL_DRIVES;
        hr = AddCbxItemToComboBoxCallback(peip->hwndComboBox, &item, peip->pfn, peip->lParam);
    }
    return hr;    
}

STDAPI PopulateLocalDrivesCombo(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    ENUMITEMPARAM eip;

    eip.hwndComboBox = hwndComboBoxEx;
    eip.pfn          = pfn;
    eip.lParam       = lParam;

    ::SendMessage(hwndComboBoxEx, CB_RESETCONTENT, 0, 0);

    return EnumSpecialItemIDs(CSIDL_DRIVES, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, _PopulateLocalDrivesCB, &eip);
}

//  File Associations selector combo methods

HRESULT _AddFileType(IN HWND hwndComboBox, IN LPCTSTR pszDisplayName, IN LPCTSTR pszExt, IN LPCITEMIDLIST pidlIcon, IN int iIndent,
                      IN OPTIONAL ADDCBXITEMCALLBACK pfn, IN OPTIONAL LPARAM lParam);


HRESULT _AddFileTypes(HWND hwndComboBox, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    HRESULT hr = S_OK;
    DWORD dwSubKey = 0;
    TCHAR szExtension[MAX_PATH];   // string containing the classes key
    DWORD dwExtension;
    BOOL bFoundFirstExt = FALSE;

    // Enumerate extensions from registry to get file types
    dwExtension = ARRAYSIZE(szExtension);
    while (hr != E_ABORT && SHEnumKeyEx(HKEY_CLASSES_ROOT, dwSubKey, szExtension, &dwExtension) != ERROR_NO_MORE_ITEMS)
    {
        if (*szExtension == TEXT('.'))  // find the file type identifier and description from the extension
        {
            IQueryAssociations *pqa;
            if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa))))
            {
                if (SUCCEEDED(pqa->Init(0, szExtension, NULL, NULL)))
                {
                    TCHAR szDesc[MAX_PATH];
                    DWORD dwAttributes = 0;
                    DWORD dwSize = sizeof(dwAttributes);
                    BOOL fAdd;

                    if (SUCCEEDED(pqa->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwAttributes, &dwSize)))
                    {
                        fAdd = !(dwAttributes & FTA_Exclude);
                    }
                    else
                    {
                        dwSize = MAX_PATH;
                        fAdd = SUCCEEDED(pqa->GetString(NULL, ASSOCSTR_DEFAULTICON, NULL, NULL, &dwSize));
                    }

                    if (fAdd)
                    {
                        dwSize = ARRAYSIZE(szDesc);
                        pqa->GetString(NULL, ASSOCSTR_FRIENDLYDOCNAME, NULL, szDesc, &dwSize);
                        hr = _AddFileType(hwndComboBox, szDesc, szExtension, NULL, NO_ITEM_INDENT, pfn, lParam);
                    }
                }
                pqa->Release();
             }

            bFoundFirstExt = TRUE;
        }
        else if (bFoundFirstExt)      // stop after first non-ext key (if sorted registry)
            break;

        dwSubKey++;
        dwExtension = ARRAYSIZE(szExtension);
    }

    if (hr != E_ABORT && LoadString(HINST_THISDLL, IDS_FOLDERTYPENAME, szExtension, ARRAYSIZE(szExtension)))
    {
        LPITEMIDLIST pidlIcon = SHCloneSpecialIDList(NULL, CSIDL_RECENT, FALSE);
        if (pidlIcon)
        {
            hr = _AddFileType(hwndComboBox, szExtension, TEXT("."), pidlIcon, NO_ITEM_INDENT, pfn, lParam);
            ILFree(pidlIcon);
        }
    }

    return hr;
}

HRESULT _AddFileType(HWND hwndComboBox, LPCTSTR pszDisplayName, LPCTSTR pszExt, LPCITEMIDLIST pidlIcon, int iIndent, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    HRESULT hr = S_OK;
    BOOL    bExists = FALSE;

    LRESULT lRet = ::SendMessage(hwndComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM) pszDisplayName);
    LRESULT nIndex = lRet;
    
    // Is the string already in the list?
    if (CB_ERR != nIndex)
    {
        // Yes, so we want to combine our extension with the current extension or extension list
        // and erase the old one.  Then we can continue to add it below.
        LPTSTR pszOldExt = NULL;

        lRet = SendMessage(hwndComboBox, CB_GETITEMDATA, nIndex, 0);
        if (!(0 == lRet || CB_ERR == lRet))
        {
            pszOldExt = (LPTSTR)lRet;
            UINT cchLen = lstrlen(pszOldExt) + 1 + lstrlen(pszExt) + 1;

            LPTSTR pszNewExt = (LPTSTR)LocalReAlloc(pszOldExt, sizeof(TCHAR) * cchLen, LMEM_ZEROINIT | LMEM_MOVEABLE);
            if (pszNewExt)
            {
                StrCat(pszNewExt, TEXT(";"));
                StrCat(pszNewExt, pszExt);
                lRet = ::SendMessage(hwndComboBox, CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pszNewExt);
            }
            bExists = TRUE;
        }
    }

    if (!bExists)
    {
        // No, so we can add it.
        TCHAR szString[MAX_URL_STRING];
        INT_PTR nPos = 0;
        INT_PTR nLast = CB_ERR;
        
        lRet = ::SendMessage(hwndComboBox, CB_GETCOUNT, 0, 0);

        if (lRet == CB_ERR)
            return E_FAIL;

        nLast = lRet - 1;
        *szString = 0;

        lRet = ::SendMessage(hwndComboBox, CB_GETLBTEXT, (WPARAM)nLast, (LPARAM)szString);

        if (lRet == CB_ERR)
            return E_FAIL;

        // Base case, does his the new string need to be inserted into the end?
        if ((-1 == nLast) || (0 > StrCmp(szString, pszDisplayName)))
        {
            // Yes, so add it to the end.
            CBXITEM item;
            hr = _MakeFileTypeCbxItem(&item, pszDisplayName, pszExt, pidlIcon, (nLast + 1), iIndent);
            if (SUCCEEDED(hr))
                hr = AddCbxItemToComboBoxCallback(hwndComboBox, &item, pfn, lParam);
        }
        else
        {
#ifdef DEBUG
            INT_PTR nCycleDetector = nLast + 5;
#endif // DEBUG
            BOOL bDisplayName = TRUE;
            do
            {
                //  Determine ordered insertion point:
                INT_PTR nTest = nPos + ((nLast - nPos) / 2);
                bDisplayName = CB_ERR != ::SendMessage(hwndComboBox, CB_GETLBTEXT, (WPARAM)nTest, (LPARAM)szString);

                if (bDisplayName)
                {
                    // Does the string need to before nTest?
                    if (0 > StrCmp(pszDisplayName, szString))
                        nLast = nTest;  // Yes
                    else
                    {
                        if (nPos == nTest)
                            nPos++;
                        else
                            nPos = nTest;  // No
                    }

#ifdef DEBUG
                    ASSERT(nCycleDetector);   // Make sure we converge.
                    nCycleDetector--;
#endif // DEBUG
                }

            } while (bDisplayName && nLast - nPos);
            
            if (bDisplayName)
            {
                CBXITEM item;
                hr = _MakeFileTypeCbxItem(&item, pszDisplayName, pszExt, pidlIcon, nPos, iIndent);
                if (SUCCEEDED(hr))
                    hr = AddCbxItemToComboBoxCallback(hwndComboBox, &item, pfn, lParam);
            }
        }
    }

    return hr;
}

STDAPI PopulateFileAssocCombo(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    ASSERT(hwndComboBoxEx);

    ::SendMessage(hwndComboBoxEx, CB_RESETCONTENT, 0, 0);

    HRESULT hr = _AddFileTypes(hwndComboBoxEx, pfn, lParam);
    if (E_ABORT == hr)
        return hr;
    
    // Now add this to the top of the list.
    CBXITEM item;
    TCHAR szDisplayName[MAX_PATH];
    LoadString(HINST_THISDLL, IDS_SNS_ALL_FILE_TYPES, szDisplayName, ARRAYSIZE(szDisplayName));
    MakeCbxItem(&item, szDisplayName, (void *)FILEASSOCIATIONSID_ALLFILETYPES, NULL, LISTINSERT_FIRST, NO_ITEM_NOICON_INDENT);

    return AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
}

void *_getFileAssocComboData(HWND hwndComboBox)
{
    LRESULT nSelected = ::SendMessage(hwndComboBox, CB_GETCURSEL, 0, 0);

    if (-1 == nSelected)
        return NULL;

    LRESULT itemData = ::SendMessage(hwndComboBox, CB_GETITEMDATA, nSelected, 0);

    if (itemData == CB_ERR)
        itemData = NULL;

    return (LPVOID)itemData;
}

DWORD _getFileAssocComboID(HWND hwndComboBox)
{
    DWORD dwID = 0;
    void *pvData = _getFileAssocComboData(hwndComboBox);

    // Is this an ID?
    if (pvData && ((DWORD_PTR)pvData <= FILEASSOCIATIONSID_MAX))
    {
        // Yes, so let's get it.
        dwID = PtrToUlong(pvData);
    }

    return dwID;
}

LONG GetFileAssocComboSelItemText(IN HWND hwndComboBox, OUT LPTSTR *ppszText)
{
    ASSERT(hwndComboBox);
    ASSERT(ppszText);
    *ppszText = NULL;

    int nSel = (LONG)::SendMessage(hwndComboBox, CB_GETCURSEL, 0, 0);
    if (nSel >= 0)
    {
        DWORD dwID = _getFileAssocComboID(hwndComboBox);

        if (dwID > FILEASSOCIATIONSID_FILE_PATH)
        {
            *ppszText = StrDup(TEXT(".*"));
        }
        else
        {
            LPTSTR pszText = (LPTSTR)_getFileAssocComboData(hwndComboBox);
            if (pszText)
            {            
                *ppszText = StrDup((LPCTSTR)pszText);
            }
        }
    }

    if (!*ppszText)
    {
        nSel = -1;
    }
    return nSel;
}


LRESULT DeleteFileAssocComboItem(IN LPNMHDR pnmh)
{
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnmh;
    if (pnmce->ceItem.lParam)
    {
        // Is this a pidl?
        if ((pnmce->ceItem.lParam) > FILEASSOCIATIONSID_MAX)
        {
            // Yes, so let's free it.
            Str_SetPtr((LPTSTR *)&pnmce->ceItem.lParam, NULL);
        }
    }
    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shell32p.h ===
//
//  This file contains definintions of WINUTIL helper functions that are
// exported from SHELL32.DLL. These functions are used only by WUTILS32
// to deal with 16-bit CPL files. Note that SHELL32.DLL just provide
// thunk layer for those functions whose bodies reside in SHELL.DLL.
//
// History:
//  09-20-93 SatoNa     Created
//

// This file is solely for Win9x 16-bit support
//
#ifndef WINNT

#define ISVALIDHINST16(hinst16) ((UINT_PTR)hinst16 >= (UINT_PTR)32)

//
// protos for thunks.  half is in shell32.dll, half in shell.dll
//
//  Notes: CALLCPLEntry16 is defined in shsemip.h
//
DWORD WINAPI GetModuleFileName16(HINSTANCE hinst, LPTSTR szFileName, DWORD cbMax);
HMODULE WINAPI GetModuleHandle16(LPCTSTR szName);

#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shelldlg.h ===
#define ABOUTDLG           100
#define IDD_APPNAME        101
//#define IDD_CONFIG         102
#define IDD_CONVTITLE      103
#define IDD_CONVENTIONAL   104
//#define IDD_EMSFREE        105
//#define IDD_SDTEXT         106
//#define IDD_SDUSING        107
#define IDD_USERNAME       108
#define IDD_COMPANYNAME    109
#define IDD_SERIALNUM      110
#define IDD_ICON           111
#define IDD_VERSION        112
//#define IDD_EMSTEXT        113
#define IDD_OTHERSTUFF     115
#define IDD_DOSVER         116
#define IDD_PROCESSOR      117
#define IDD_PRODUCTID      118
#define IDD_OEMID          119

#define WINBMP             130

#define FINDEXEDLG         200
#define IDD_BROWSE             201
#define IDD_PATH               203
#define IDD_HELP               204
#define IDD_TEXT1              205
#define IDD_TEXT2              206

#define DLG_BROWSE             300
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shelllnk.h ===
#ifndef __SHLINK_H__
#define __SHLINK_H__

#include <trkwks.h>
#include <rpcasync.h>
#include <filter.h>
#include "cowsite.h"

class CDarwinContextMenuCB;
class CTracker;

class CShellLink : public IShellLinkA,
                   public IShellLinkW,
                   public IPersistStream,
                   public IPersistFile,
                   public IShellExtInit,
                   public IContextMenu3,
                   public IDropTarget,
                   public IQueryInfo,
                   public IShellLinkDataList,
                   public IExtractIconA,
                   public IExtractIconW,
                   public IExtractImage2,
                   public IPersistPropertyBag,
                   public IServiceProvider,
                   public IFilter,
                   public CObjectWithSite,
                   public ICustomizeInfoTip
{
    friend CTracker;
    friend CDarwinContextMenuCB;

public:
    CShellLink();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IShellLinkA methods
    STDMETHOD(GetPath)(LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD flags);
    STDMETHOD(SetPath)(LPCSTR pszFile);
    //STDMETHOD(GetIDList)(LPITEMIDLIST *ppidl);
    //STDMETHOD(SetIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(GetDescription)(LPSTR pszName, int cchMaxName);
    STDMETHOD(SetDescription)(LPCSTR pszName);
    STDMETHOD(GetWorkingDirectory)(LPSTR pszDir, int cchMaxPath);
    STDMETHOD(SetWorkingDirectory)(LPCSTR pszDir);
    STDMETHOD(GetArguments)(LPSTR pszArgs, int cchMaxPath);
    STDMETHOD(SetArguments)(LPCSTR pszArgs);
    //STDMETHOD(GetHotkey)(WORD *pwHotkey);
    //STDMETHOD(SetHotkey)(WORD wHotkey);
    //STDMETHOD(GetShowCmd)(int *piShowCmd);
    //STDMETHOD(SetShowCmd)(int iShowCmd);
    STDMETHOD(GetIconLocation)(LPSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHOD(SetIconLocation)(LPCSTR pszIconPath, int iIcon);
    //STDMETHOD(Resolve)(HWND hwnd, DWORD dwResolveFlags);
    STDMETHOD(SetRelativePath)(LPCSTR pszPathRel, DWORD dwReserved);
    
    // IShellLinkW
    STDMETHOD(GetPath)(LPWSTR pszFile, int cchMaxPath, WIN32_FIND_DATAW *pfd, DWORD fFlags);
    STDMETHOD(GetIDList)(LPITEMIDLIST *ppidl);
    STDMETHOD(SetIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(GetDescription)(LPWSTR pszName, int cchMaxName);
    STDMETHOD(SetDescription)(LPCWSTR pszName);
    STDMETHOD(GetWorkingDirectory)(LPWSTR pszDir, int cchMaxPath);
    STDMETHOD(SetWorkingDirectory)(LPCWSTR pszDir);
    STDMETHOD(GetArguments)(LPWSTR pszArgs, int cchMaxPath);
    STDMETHOD(SetArguments)(LPCWSTR pszArgs);
    STDMETHOD(GetHotkey)(WORD *pwHotKey);
    STDMETHOD(SetHotkey)(WORD wHotkey);
    STDMETHOD(GetShowCmd)(int *piShowCmd);
    STDMETHOD(SetShowCmd)(int iShowCmd);
    STDMETHOD(GetIconLocation)(LPWSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHOD(SetIconLocation)(LPCWSTR pszIconPath, int iIcon);
    STDMETHOD(SetRelativePath)(LPCWSTR pszPathRel, DWORD dwReserved);
    STDMETHOD(Resolve)(HWND hwnd, DWORD dwResolveFlags);
    STDMETHOD(SetPath)(LPCWSTR pszFile);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();

    // IPersistStream
    STDMETHOD(Load)(IStream *pstm);
    STDMETHOD(Save)(IStream *pstm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // IPersistFile
    STDMETHOD(Load)(LPCOLESTR pwszFile, DWORD grfMode);
    STDMETHOD(Save)(LPCOLESTR pwszFile, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pwszFile);
    STDMETHOD(GetCurFile)(LPOLESTR *lplpszFileName);

    // IPersistPropertyBag
    STDMETHOD(Save)(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    STDMETHOD(Load)(IPropertyBag* pPropBag, IErrorLog* pErrorLog);
    STDMETHOD(InitNew)(void);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    // IContextMenu3
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO piciIn);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT wFlags, UINT *pmf, LPSTR pszName, UINT cchMax);
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *lResult);

    // IDropTarget
    STDMETHOD(DragEnter)(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IQueryInfo
    STDMETHOD(GetInfoTip)(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHOD(GetInfoFlags)(LPDWORD pdwFlags);

    // IShellLinkDataList
    STDMETHOD(AddDataBlock)(void *pdb);
    STDMETHOD(CopyDataBlock)(DWORD dwSig, void **ppdb);
    STDMETHOD(RemoveDataBlock)(DWORD dwSig);
    STDMETHOD(GetFlags)(LPDWORD pdwFlags);
    STDMETHOD(SetFlags)(DWORD dwFlags);
    
    // IExtractIconA
    STDMETHOD(GetIconLocation)(UINT uFlags,LPSTR szIconFile,UINT cchMax,int *piIndex,UINT * pwFlags);
    STDMETHOD(Extract)(LPCSTR pszFile,UINT nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons);

    // IExtractIconW
    STDMETHOD(GetIconLocation)(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

    // IExtractImage
    STDMETHOD (GetLocation)(LPWSTR pszPathBuffer, DWORD cch, DWORD * pdwPriority, const SIZE * prgSize,
                            DWORD dwRecClrDepth, DWORD *pdwFlags);
    STDMETHOD (Extract)(HBITMAP *phBmpThumbnail);

    // IExtractImage2
    STDMETHOD (GetDateStamp)(FILETIME *pftDateStamp);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppv);

    // IFilter
    STDMETHOD(Init)(ULONG grfFlags, ULONG cAttributes, const FULLPROPSPEC *aAttributes, ULONG *pFlags);
    STDMETHOD(GetChunk)(STAT_CHUNK *pStat);
    STDMETHOD(GetText)(ULONG *pcwcBuffer, WCHAR *awcBuffer);
    STDMETHOD(GetValue)(PROPVARIANT **ppPropValue);
    STDMETHOD(BindRegion)(FILTERREGION origPos, REFIID riid, void **ppunk);

    //*** IObjectWithSite ***
    //STDMETHOD(SetSite)(IUnknown *punkSite);
    //STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

    // ICustomizeInfoTip
    STDMETHODIMP SetPrefixText(LPCWSTR pszPrefix);
    STDMETHODIMP SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid);

    // public non interface members
    void   _AddExtraDataSection(DATABLOCK_HEADER *pdbh);
    void   _RemoveExtraDataSection(DWORD dwSig);
    void * _ReadExtraDataSection(DWORD dwSig);

protected:
    HRESULT _Resolve(HWND hwnd, DWORD dwResolveFlags, DWORD dwTracker);

private:
    ~CShellLink();

    static DWORD CALLBACK _InvokeThreadProc(void *pv);
    static DWORD CALLBACK _VerifyPathThreadProc(void *pv);

    void _ResetPersistData();
    BOOL _GetRelativePath(LPTSTR pszPath);
    BOOL _GetUNCPath(LPTSTR pszName);

    HRESULT _SetPIDLPath(LPCITEMIDLIST pidl, LPCTSTR pszPath, BOOL bUpdateTrackingData);
    HRESULT _SetSimplePIDL(LPCTSTR pszPath);
    void _UpdateWorkingDir(LPCTSTR pszPath);

    PLINKINFO _GetLinkInfo(LPCTSTR pszPath);
    void _FreeLinkInfo();
    HRESULT _GetFindDataAndTracker(LPCTSTR pszPath);
    void _ClearTrackerData();

    BOOL _SetFindData(const WIN32_FIND_DATA *pfd);
    void _GetFindData(WIN32_FIND_DATA *pfd);
    BOOL _IsEqualFindData(const WIN32_FIND_DATA *pfd);

    HRESULT _ResolveIDList(HWND hwnd, DWORD dwResolveFlags);
    HRESULT _ResolveLinkInfo(HWND hwnd, DWORD dwResolveFlags, LPTSTR pszPath, DWORD *pfifFlags);
    HRESULT _ResolveRemovable(HWND hwnd, LPCTSTR pszPath);
    BOOL    _ShouldTryRemovable(HRESULT hr, LPCTSTR pszPath);
    void    _SetIDListFromEnvVars();
    BOOL    _ResolveDarwin(HWND hwnd, DWORD dwResolveFlags, HRESULT *phr);

    HRESULT _ResolveLogo3Link(HWND hwnd, DWORD dwResolveFlags);
    HRESULT _CheckForLinkBlessing(LPCTSTR *ppszPathIn);
    HRESULT BlessLink(LPCTSTR *ppszPath, DWORD dwSignature);
    BOOL _EncodeSpecialFolder();
    void _DecodeSpecialFolder();
    HRESULT _SetRelativePath(LPCTSTR pszRelSource);
    HRESULT _UpdateTracker();
    HRESULT _LoadFromFile(LPCTSTR pszPath);
    HRESULT _LoadFromPIF(LPCTSTR szPath);
    HRESULT _SaveToFile(LPTSTR pszPathSave, BOOL fRemember);
    HRESULT _SaveAsLink(LPCTSTR szPath);
    HRESULT _SaveAsPIF(LPCTSTR pszPath, BOOL fPath);
    BOOL _GetWorkingDir(LPTSTR pszDir);
    HRESULT _GetUIObject(HWND hwnd, REFIID riid, void **ppvOut);
    HRESULT _ShortNetTimeout();

    HRESULT _CreateDarwinContextMenu(HWND hwnd,IContextMenu **pcmOut);
    HRESULT _CreateDarwinContextMenuForPidl(HWND hwnd, LPCITEMIDLIST pidlTarget, IContextMenu **pcmOut);
    HRESULT _InvokeCommandAsync(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InitDropTarget();
    HRESULT _GetExtractIcon(REFIID riid, void **ppvOut);
    HRESULT _InitExtractIcon();
    HRESULT _InitExtractImage();
    BOOL _GetExpandedPath(LPTSTR psz, DWORD cch);
    HRESULT _SetField(LPTSTR *ppszField, LPCWSTR pszValueW);
    HRESULT _SetField(LPTSTR *ppszField, LPCSTR  pszValueA);
    HRESULT _GetField(LPCTSTR pszField, LPWSTR pszValueW, int cchValue);
    HRESULT _GetField(LPCTSTR pszField, LPSTR  pszValueA, int cchValue);
    int _IsOldDarwin(LPCTSTR pszPath);
    HRESULT _SetPathOldDarwin(LPCTSTR pszPath);
    BOOL _LinkInfo(LINKINFODATATYPE info, LPTSTR psz, UINT cch);
    HRESULT _CreateProcessWithShimLayer(HANDLE hData, BOOL fAllowAsync);
    HRESULT _MaybeAddShim(IBindCtx **ppbcRelease);
    HRESULT _UpdateIconFromExpIconSz();

    //
    //  Inner class to manage the context menu of the shortcut target.
    //  We do this to ensure that the target's context menu gets a proper
    //  SetSite call so it can contact the containing shortcut.
    //
    class TargetContextMenu {
    public:
        operator IUnknown*() { return _pcmTarget; }

        // WARNING!  Use only as an output pointer
        IContextMenu **GetOutputPtr() { return &_pcmTarget; }

        HRESULT QueryContextMenu(IShellLink *outer, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
        {
            IUnknown_SetSite(_pcmTarget, outer);
            HRESULT hr = _pcmTarget->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
            IUnknown_SetSite(_pcmTarget, NULL);
            return hr;
        }

        HRESULT InvokeCommand(IShellLink *outer, LPCMINVOKECOMMANDINFO pici)
        {
            IUnknown_SetSite(_pcmTarget, outer);
            HRESULT hr = _pcmTarget->InvokeCommand(pici);
            IUnknown_SetSite(_pcmTarget, NULL);
            return hr;
        }

        HRESULT HandleMenuMsg2(IShellLink *outer, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

        // This doesn't need to be wrapped in a SetSite (yet)
        UINT GetCommandString(IShellLink *outer, UINT_PTR idCmd, UINT wFlags, UINT *pmf, LPSTR pszName, UINT cchMax)
        {
            HRESULT hr = _pcmTarget->GetCommandString(idCmd, wFlags, pmf, pszName, cchMax);
            return hr;
        }

        // This doesn't need to be wrapped in a SetSite (yet)
        UINT GetMenuIndexForCanonicalVerb(IShellLink *outer, HMENU hMenu, UINT idCmdFirst, LPCWSTR pwszVerb)
        {
            UINT ui = ::GetMenuIndexForCanonicalVerb(hMenu, _pcmTarget, idCmdFirst, pwszVerb);
            return ui;
        }

        void AtomicRelease()
        {
            ATOMICRELEASE(_pcmTarget);
        }

        ~TargetContextMenu()
        {
            IUnknown_SetSite(_pcmTarget, NULL);
            AtomicRelease();
        }

    private:
        IContextMenu        *_pcmTarget;    // stuff for IContextMenu
    };

    // Data Members
    LONG                _cRef;              // Ref Count
    BOOL                _bDirty;            // something has changed
    LPTSTR              _pszCurFile;        // current file from IPersistFile
    LPTSTR              _pszRelSource;      // overrides pszCurFile in relative tracking

    TargetContextMenu   _cmTarget;          // stuff for IContextMenu
    CDarwinContextMenuCB *_pcbDarwin;

    UINT                _indexMenuSave;
    UINT                _idCmdFirstSave;
    UINT                _idCmdLastSave;
    UINT                _uFlagsSave;

    // IDropTarget specific
    IDropTarget*        _pdtSrc;        // IDropTarget of link source (unresolved)
    DWORD               _grfKeyStateLast;

    IExtractIconW       *_pxi;          // for IExtractIcon support
    IExtractIconA       *_pxiA;
    IExtractImage       *_pxthumb;
    UINT                _gilFlags;      // ::GetIconLocation() flags

    // persistant data

    LPITEMIDLIST        _pidl;          // may be NULL
    PLINKINFO           _pli;           // may be NULL

    LPTSTR              _pszName;       // title on short volumes
    LPTSTR              _pszRelPath;
    LPTSTR              _pszWorkingDir;
    LPTSTR              _pszArgs;
    LPTSTR              _pszIconLocation;

    LPDBLIST            _pExtraData;    // extra data to preserve for future compatibility

    CTracker            *_ptracker;

    WORD                _wOldHotkey;   // to broadcast hotkey changes
    WORD                _wAllign;
    SHELL_LINK_DATA     _sld;
    BOOL                _bExpandedIcon;  // have we already tried to update the icon from the env variable for this instance?

    // IFilter stuff
    UINT _iChunkIndex;
    UINT _iValueIndex;

    LPWSTR _pszPrefix;
};

DECLARE_INTERFACE_(ISLTracker, IUnknown)
{
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Resolve)(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions) PURE;
    STDMETHOD(GetIDs)(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid) PURE;
    STDMETHOD(CancelSearch)() PURE;
};

//  This class implements the object ID-based link tracking (new to NT5).

class CTracker : public ISLTracker
{
public:
    //  IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  ISLTracker
    STDMETHODIMP Resolve(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions);
    STDMETHODIMP GetIDs(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid);

    CTracker(CShellLink *psl) : _psl(psl)
    {
        _fLoadedAtLeastOnce = _fLoaded = _fDirty = FALSE;
        _fCritsecInitialized = _fMendInProgress = _fUserCancelled = FALSE;
        _hEvent = NULL;
        _pRpcAsyncState = NULL;
    };

    ~CTracker()
    {
        if (_fCritsecInitialized)
        {
            DeleteCriticalSection(&_cs);
            _fCritsecInitialized = FALSE;
        }

        if (NULL != _pRpcAsyncState)
        {
            delete[] _pRpcAsyncState;
            _pRpcAsyncState = NULL;
        }

        if (NULL != _hEvent)
        {
            CloseHandle(_hEvent);
            _hEvent = NULL;
        }
    }

    // Initialization.

    HRESULT     InitFromHandle(const HANDLE hFile, const TCHAR* ptszFile);
    HRESULT     InitNew();
    void        UnInit();

    // Load and Save

    HRESULT Load(BYTE *pb, ULONG cb);
    ULONG GetSize()
    {
        return sizeof(DWORD)   // To save the length
             + sizeof(DWORD) // To save flags
             + sizeof(_mcidLast) + sizeof(_droidLast) + sizeof(_droidBirth);
    }

    void Save(BYTE *pb, ULONG cb);

    // Search for a file

    HRESULT Search(const DWORD dwTickCountDeadline,
                    const WIN32_FIND_DATA *pfdIn,
                    WIN32_FIND_DATA *pfdOut,
                    UINT uShlinkFlags,
                    DWORD TrackerRestrictions);
    STDMETHODIMP CancelSearch(); // Also in ISLTracker

    BOOL IsDirty()
    {
        return _fDirty;
    }

    BOOL IsLoaded()
    {
        return _fLoaded;
    }

    BOOL WasLoadedAtLeastOnce()
    {
        return _fLoadedAtLeastOnce;
    }

private:
    // Call this from either InitNew or Load
    HRESULT     InitRPC();

    BOOL                    _fDirty:1;

    // TRUE => InitNew has be called, but neither InitFromHandle nor Load
    // has been called since.
    BOOL                    _fLoaded:1;

    // TRUE => _cs has been intialized and must be deleted on destruction.
    BOOL                    _fCritsecInitialized:1;

    // TRUE => An async call to LnkMendLink is active
    BOOL                    _fMendInProgress:1;

    BOOL                    _fUserCancelled:1;

    // Event used for the async RPC call LnkMendLink, and a critsec to
    // coordinate the search thread and UI thread.

    HANDLE                  _hEvent;
    CRITICAL_SECTION        _cs;

    // Either InitFromHandle or Load has been called at least once, though
    // InitNew may have been called since.
    BOOL                    _fLoadedAtLeastOnce:1;
    CShellLink             *_psl;
    PRPC_ASYNC_STATE        _pRpcAsyncState;

    CMachineId              _mcidLast;
    CDomainRelativeObjId    _droidLast;
    CDomainRelativeObjId    _droidBirth;
};

#endif //__SHLINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shelllnk.cpp ===
#include "shellprv.h"
#include <shlobjp.h>
#include "shelllnk.h"

#include "datautil.h"
#include "vdate.h"      // For VDATEINPUTBUF
#include "ids.h"        // For String Resource identifiers
#include "pif.h"        // For manipulating PIF files
#include "trayp.h"      // For  WMTRAY_* messages 
#include "views.h"      // For FSIDM_OPENPRN
#include "os.h"         // For Win32MoveFile ...
#include "util.h"       // For GetMenuIndexForCanonicalVerb
#include "defcm.h"      // For CDefFolderMenu_Create2Ex
#include "uemapp.h"
#include <filterr.h>
#include "folder.h"
#include <msi.h>
#include <msip.h>
#include "treewkcb.h"

#define GetLastHRESULT()    HRESULT_FROM_WIN32(GetLastError())

//  Flags for FindInFilder.fifFlags
//
// The drive referred to by the shortcut does not exist.
// Let pTracker search for it, but do not perform an old-style
// ("downlevel") search of our own.

#define FIF_NODRIVE     0x0001


// Only if the file we found scores more than this number do we 
// even show the user this result, any thing less than this would
// be too shameful of us to show the user. 
#define MIN_SHOW_USER_SCORE     10

// magic score that stops searches and causes us not to warn
// whe the link is actually found
#define MIN_NO_UI_SCORE         40

// If no User Interface will be provided during the search,
// then do not search more than 3 seconds.
#define NOUI_SEARCH_TIMEOUT     (3 * 1000)

// If a User Interface will be provided during the search,
// then search as much as 2 minutes.
#define UI_SEARCH_TIMEOUT       (120 * 1000)

#define LNKTRACK_HINTED_UPLEVELS 4  // directory levels to search upwards from last know object locn
#define LNKTRACK_DESKTOP_DOWNLEVELS 4 // infinite downlevels
#define LNKTRACK_ROOT_DOWNLEVELS 4  // levels down from root of fixed disks
#define LNKTRACK_HINTED_DOWNLEVELS 4 // levels down at each level on way up during hinted uplevels



class CLinkResolver : public CBaseTreeWalkerCB
{
public:
    CLinkResolver(CTracker *ptrackerobject, const WIN32_FIND_DATA *pofd, UINT dwResolveFlags, DWORD TrackerRestrictions, DWORD fifFlags);

    int Resolve(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszCurFile);
    void GetResult(LPTSTR psz, UINT cch);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

private:
    ~CLinkResolver();

    static DWORD CALLBACK _ThreadStartCallBack(void *pv);
    static DWORD CALLBACK _SearchThreadProc(void *pv);
    static BOOL_PTR CALLBACK _DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    void _HeuristicSearch();
    void _InitDlg(HWND hDlg);
    DWORD _Search();
    DWORD _GetTimeOut();
    int _ScoreFindData(const WIN32_FIND_DATA *pfd);
    HRESULT _ProcessFoundFile(LPCTSTR pszPath, WIN32_FIND_DATAW * pwfdw);
    BOOL _SearchInFolder(LPCTSTR pszFolder, int cLevels);
    HRESULT _InitWalkObject();

    HANDLE _hThread;
    DWORD _dwTimeOutDelta;
    HWND  _hDlg;
    UINT_PTR _idtDelayedShow;           // timer for delayed-show
    DWORD _fifFlags;                    // FIF_ flags
    CTracker *_ptracker;                // Implements ObjectID-based link tracking
    DWORD _TrackerRestrictions;         // Flags from the TrkMendRestrictions enumeration

    DWORD  _dwSearchFlags;
    int    _iFolderBonus;
    
    WCHAR  _wszSearchSpec[64];          // holds file extension filter for search
    LPCWSTR _pwszSearchSpec;            // NULL for folders
    IShellTreeWalker *_pstw;

    BOOL                _fFindLnk;      // are we looking for a lnk file?
    DWORD               _dwMatch;       // must match attributes
    WIN32_FIND_DATA     _ofd;           // original find data

    DWORD               _dwTimeLimit;   // don't go past this

    BOOL                _bContinue;     // keep going

    LPCTSTR             _pszSearchOrigin;       // path where current search originated, to help avoid dup searchs
    LPCTSTR             _pszSearchOriginFirst;  // path where search originated, to help avoid dup searchs

    int                 _iScore;        // score for current item
    WIN32_FIND_DATA     _fdFound;       // results

    WIN32_FIND_DATA     _sfd;           // to save stack space 
    UINT                _dwResolveFlags;        // SLR_ flags

    TCHAR               _szSearchStart[MAX_PATH];
};


// NOTE:(seanf) This is sleazy - This fn is defined in shlobj.h, but only if urlmon.h
// was included first. Rather than monkey with the include order in
// shellprv.h, we'll duplicate the prototype here, where SOFTDISTINFO
// is now defined.
SHDOCAPI_(DWORD) SoftwareUpdateMessageBox(HWND hWnd,
                                           LPCWSTR pszDistUnit,
                                           DWORD dwFlags,
                                           LPSOFTDISTINFO psdi);



// The following strings are used to support the shell link set path hack that
// allows us to bless links for Darwin without exposing stuff from IShellLinkDataList

#define DARWINGUID_TAG TEXT("::{9db1186e-40df-11d1-aa8c-00c04fb67863}:")
#define LOGO3GUID_TAG  TEXT("::{9db1186f-40df-11d1-aa8c-00c04fb67863}:")

#define TF_DEBUGLINKCODE 0x00800000

EXTERN_C BOOL IsFolderShortcut(LPCTSTR pszName);

class CDarwinContextMenuCB : public IContextMenuCB
{
public:
    CDarwinContextMenuCB() : _cRef(1) { }

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv) 
    {
        static const QITAB qit[] = {
            QITABENT(CDarwinContextMenuCB, IContextMenuCB), // IID_IContextMenuCB
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }

    STDMETHOD_(ULONG,AddRef)() 
    {
        return InterlockedIncrement(&_cRef);
    }

    STDMETHOD_(ULONG,Release)() 
    {
        if (InterlockedDecrement(&_cRef)) 
            return _cRef;

        delete this;
        return 0;
    }

    // IContextMenuCB
    STDMETHOD(CallBack)(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

public:

    void SetProductCodeFromDarwinID(LPCTSTR szDarwinID)
    {
        MsiDecomposeDescriptor(szDarwinID, _szProductCode, NULL, NULL, NULL);
    }

private:
    LONG _cRef;
    TCHAR _szProductCode[MAX_PATH];
};

CShellLink::CShellLink() : _cRef(1)
{
    _ptracker = new CTracker(this);
    _ResetPersistData();
}

CShellLink::~CShellLink()
{
    _ResetPersistData();        // free all data

    if (_pcbDarwin)
    {
        _pcbDarwin->Release(); 
    }

    if (_pdtSrc)
    {
        _pdtSrc->Release();
    }

    if (_pxi)
    {
        _pxi->Release();
    }

    if (_pxiA)
    {
        _pxiA->Release();
    }

    if (_pxthumb)
    {
        _pxthumb->Release();
    }

    Str_SetPtr(&_pszCurFile, NULL);
    Str_SetPtr(&_pszRelSource, NULL);

    if (_ptracker)
    {
        delete _ptracker;
    }
}

// Private interface used for testing

/* 7c9e512f-41d7-11d1-8e2e-00c04fb9386d */
EXTERN_C const IID IID_ISLTracker = { 0x7c9e512f, 0x41d7, 0x11d1, {0x8e, 0x2e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d} };

STDMETHODIMP CShellLink::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellLink, IShellLinkA),
        QITABENT(CShellLink, IShellLinkW),
        QITABENT(CShellLink, IPersistFile),
        QITABENT(CShellLink, IPersistStream),
        QITABENT(CShellLink, IShellExtInit),
        QITABENTMULTI(CShellLink, IContextMenu, IContextMenu3),
        QITABENTMULTI(CShellLink, IContextMenu2, IContextMenu3),
        QITABENT(CShellLink, IContextMenu3),
        QITABENT(CShellLink, IDropTarget),
        QITABENT(CShellLink, IExtractIconA),
        QITABENT(CShellLink, IExtractIconW),
        QITABENT(CShellLink, IShellLinkDataList),
        QITABENT(CShellLink, IQueryInfo),
        QITABENT(CShellLink, IPersistPropertyBag),
        QITABENT(CShellLink, IObjectWithSite),
        QITABENT(CShellLink, IServiceProvider),
        QITABENT(CShellLink, IFilter),
        QITABENT(CShellLink, IExtractImage2),
        QITABENTMULTI(CShellLink, IExtractImage, IExtractImage2),
        QITABENT(CShellLink, ICustomizeInfoTip),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr) && (IID_ISLTracker == riid) && _ptracker)
    {
        // ISLTracker is a private test interface, and isn't implemented
        *ppvObj = SAFECAST(_ptracker, ISLTracker*);
        _ptracker->AddRef();
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CShellLink::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

void CShellLink::_ClearTrackerData()
{
    if (_ptracker)
        _ptracker->InitNew();
}

void CShellLink::_ResetPersistData()
{
    Pidl_Set(&_pidl, NULL);

    _FreeLinkInfo();
    _ClearTrackerData();

    Str_SetPtr(&_pszName, NULL);
    Str_SetPtr(&_pszRelPath, NULL);
    Str_SetPtr(&_pszWorkingDir, NULL);
    Str_SetPtr(&_pszArgs, NULL);
    Str_SetPtr(&_pszIconLocation, NULL);
    Str_SetPtr(&_pszPrefix, NULL);

    if (_pExtraData)
    {
        SHFreeDataBlockList(_pExtraData);
        _pExtraData = NULL;
    }

    // init data members.  all others are zero inited
    memset(&_sld, 0, sizeof(_sld));

    _sld.iShowCmd = SW_SHOWNORMAL;

    _bExpandedIcon = FALSE;
}

STDMETHODIMP_(ULONG) CShellLink::Release()
{
    if (InterlockedDecrement(&_cRef))
    {
       return _cRef;
    }

    delete this;
    return 0;
}

#ifdef DEBUG
void DumpPLI(PCLINKINFO pli)
{
    DebugMsg(DM_TRACE, TEXT("DumpPLI:"));
    if (pli)
    {
        const void *p;
        if (GetLinkInfoData(pli, LIDT_VOLUME_SERIAL_NUMBER, &p))
            DebugMsg(DM_TRACE, TEXT("\tSerial #\t%8X"), *(DWORD *)p);

        if (GetLinkInfoData(pli, LIDT_DRIVE_TYPE, &p))
            DebugMsg(DM_TRACE, TEXT("\tDrive Type\t%d"), *(DWORD *)p);

        if (GetLinkInfoData(pli, LIDT_VOLUME_LABEL, &p))
            DebugMsg(DM_TRACE, TEXT("\tLabel\t%hs"), p);

        if (GetLinkInfoData(pli, LIDT_LOCAL_BASE_PATH, &p))
            DebugMsg(DM_TRACE, TEXT("\tBase Path\t%hs"), p);

        if (GetLinkInfoData(pli, LIDT_NET_RESOURCE, &p))
            DebugMsg(DM_TRACE, TEXT("\tNet Res\t%hs"), p);

        if (GetLinkInfoData(pli, LIDT_COMMON_PATH_SUFFIX, &p))
            DebugMsg(DM_TRACE, TEXT("\tPath Sufix\t%hs"), p);
    }
}
#else
#define DumpPLI(p)
#endif

BOOL CShellLink::_LinkInfo(LINKINFODATATYPE info, LPTSTR psz, UINT cch)
{
    *psz = 0;
    
    BOOL bRet = FALSE;
    const void *p;
    if (_pli && GetLinkInfoData(_pli, info, &p) && p)
    {
        switch (info)
        {
        case LIDT_VOLUME_LABEL:
        case LIDT_LOCAL_BASE_PATH:
        case LIDT_NET_RESOURCE:
        case LIDT_REDIRECTED_DEVICE:
        case LIDT_COMMON_PATH_SUFFIX:
            SHAnsiToTChar((LPCSTR)p, psz, cch);
            bRet = TRUE;
            break;

        case LIDT_VOLUME_LABELW:
        case LIDT_NET_RESOURCEW:
        case LIDT_REDIRECTED_DEVICEW:
        case LIDT_LOCAL_BASE_PATHW:
        case LIDT_COMMON_PATH_SUFFIXW:
            SHUnicodeToTChar((LPCWSTR)p, psz, cch);
            bRet = TRUE;
            break;
        }
    }
    else switch (info)  // failure of a UNICODE var fall back and try ANSI
    {
        case LIDT_VOLUME_LABELW:
            bRet = _LinkInfo(LIDT_VOLUME_LABEL, psz, cch);
            break;

        case LIDT_NET_RESOURCEW:
            bRet = _LinkInfo(LIDT_NET_RESOURCE, psz, cch);
            break;

        case LIDT_REDIRECTED_DEVICEW:
            bRet = _LinkInfo(LIDT_REDIRECTED_DEVICE, psz, cch);
            break;

        case LIDT_LOCAL_BASE_PATHW:
            bRet = _LinkInfo(LIDT_LOCAL_BASE_PATH, psz, cch);
            break;

        case LIDT_COMMON_PATH_SUFFIXW:
            bRet = _LinkInfo(LIDT_COMMON_PATH_SUFFIX, psz, cch);
            break;
    }
    return bRet;
}

BOOL CShellLink::_GetUNCPath(LPTSTR pszName)
{
    TCHAR szRoot[MAX_PATH], szBase[MAX_PATH];
    
    *pszName = 0;

    if (_LinkInfo(LIDT_NET_RESOURCEW, szRoot, ARRAYSIZE(szRoot)) &&
        _LinkInfo(LIDT_COMMON_PATH_SUFFIXW, szBase, ARRAYSIZE(szBase)))
    {
        PathCombine(pszName, szRoot, szBase);
    }
    return PathIsUNC(pszName);
}
        

// Compare _sld to a WIN32_FIND_DATA

BOOL CShellLink::_IsEqualFindData(const WIN32_FIND_DATA *pfd)
{
    return (pfd->dwFileAttributes == _sld.dwFileAttributes)                       &&
           (CompareFileTime(&pfd->ftCreationTime, &_sld.ftCreationTime) == 0)     &&
           (CompareFileTime(&pfd->ftLastWriteTime, &_sld.ftLastWriteTime) == 0)   &&
           (pfd->nFileSizeLow == _sld.nFileSizeLow);
}

BOOL CShellLink::_SetFindData(const WIN32_FIND_DATA *pfd)
{
    if (!_IsEqualFindData(pfd))
    {
        _sld.dwFileAttributes = pfd->dwFileAttributes;
        _sld.ftCreationTime = pfd->ftCreationTime;
        _sld.ftLastAccessTime = pfd->ftLastAccessTime;
        _sld.ftLastWriteTime = pfd->ftLastWriteTime;
        _sld.nFileSizeLow = pfd->nFileSizeLow;
        _bDirty = TRUE;
        return TRUE;
    }
    return FALSE;
}

// make a copy into LocalAlloc memory, to avoid having to load linkinfo.dll
// just to call DestroyLinkInfo()

PLINKINFO CopyLinkInfo(PCLINKINFO pcliSrc)
{
    ASSERT(pcliSrc);
    DWORD dwSize = pcliSrc->ucbSize; // size of this thing
    PLINKINFO pli = (PLINKINFO)LocalAlloc(LPTR, dwSize);      // make a copy
    if (pli)
        CopyMemory(pli, pcliSrc, dwSize);
    return  pli;
}

void CShellLink::_FreeLinkInfo()
{
    if (_pli)
    {
        LocalFree((HLOCAL)_pli);
        _pli = NULL;
    }
}

// creates a LINKINFO _pli from a given file name
//
// returns:
//
//      success, pointer to the LINKINFO
//      NULL     this link does not have LINKINFO

PLINKINFO CShellLink::_GetLinkInfo(LPCTSTR pszPath)
{
    // this bit disables LINKINFO tracking on a per link basis, this is set
    // externally by admins to make links more "transparent"
    if (!(_sld.dwFlags & SLDF_FORCE_NO_LINKINFO))
    {
        if (pszPath)
        {
            PLINKINFO pliNew;
            if (CreateLinkInfo(pszPath, &pliNew))
            {
                // avoid marking the link dirty if the linkinfo
                // blocks are the same, comparing the bits
                // gives us an accurate positive test
                if (!_pli || (_pli->ucbSize != pliNew->ucbSize) || memcmp(_pli, pliNew, pliNew->ucbSize))
                {
                    _FreeLinkInfo();

                    _pli = CopyLinkInfo(pliNew);
                    _bDirty = TRUE;
                }

                DumpPLI(_pli);

                DestroyLinkInfo(pliNew);
            }
        }
    }
    return _pli;
}

void PathGetRelative(LPTSTR pszPath, LPCTSTR pszFrom, DWORD dwAttrFrom, LPCTSTR pszRel)
{
    TCHAR szRoot[MAX_PATH];

    lstrcpy(szRoot, pszFrom);
    if (!(dwAttrFrom & FILE_ATTRIBUTE_DIRECTORY))
    {
        PathRemoveFileSpec(szRoot);
    }

    ASSERT(PathIsRelative(pszRel));

    PathCombine(pszPath, szRoot, pszRel);
}

//
// update the working dir to match changes being made to the link target
//
void CShellLink::_UpdateWorkingDir(LPCTSTR pszNew)
{
    TCHAR szOld[MAX_PATH], szPath[MAX_PATH];

    if ((_sld.dwFlags & SLDF_HAS_DARWINID)  ||
        (_pszWorkingDir == NULL)            ||
        (_pszWorkingDir[0] == 0)            ||
        StrChr(_pszWorkingDir, TEXT('%'))   ||
        (_pidl == NULL)                     ||
        !SHGetPathFromIDList(_pidl, szOld)  ||
        (lstrcmpi(szOld, pszNew) == 0))
    {
        return;
    }

    if (PathRelativePathTo(szPath, szOld, _sld.dwFileAttributes, _pszWorkingDir, FILE_ATTRIBUTE_DIRECTORY))
    {
        PathGetRelative(szOld, pszNew, GetFileAttributes(pszNew), szPath);        // get result is szOld

        if (PathIsDirectory(szOld))
        {
            DebugMsg(DM_TRACE, TEXT("working dir updated to %s"), szOld);
            Str_SetPtr(&_pszWorkingDir, szOld);
            _bDirty = TRUE;
        }
    }
}

HRESULT CShellLink::_SetSimplePIDL(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;
    WIN32_FIND_DATA fd = {0};
    fd.dwFileAttributes = _sld.dwFileAttributes;
            
    HRESULT hr = SHSimpleIDListFromFindData(pszPath, &fd, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = _SetPIDLPath(pidl, NULL, FALSE);
        ILFree(pidl);
    }
    return hr;
}

// set the pidl either based on a new pidl or a path
// this will set the dirty flag if this info is different from the current
//
// in:
//      pidlNew         if non-null, use as new PIDL for link
//      pszPath         if non-null, create a pidl for this and set it
//
// returns:
//      hr based on success
//      FAILED() codes on failure (parsing failure for path case)

HRESULT CShellLink::_SetPIDLPath(LPCITEMIDLIST pidl, LPCTSTR pszPath, BOOL bUpdateTrackingData)
{
    LPITEMIDLIST pidlCreated;
    HRESULT hr;

    if (pszPath && !pidl)
    {
        // path as input. this can map the pidl into the alias form (relative to
        // ::{my docs} for example) but allow link to override that behavior
        ILCFP_FLAGS ilcfpFlags = (_sld.dwFlags & SLDF_NO_PIDL_ALIAS) ? ILCFP_FLAG_NO_MAP_ALIAS : ILCFP_FLAG_NORMAL;

        hr = ILCreateFromPathEx(pszPath, NULL, ilcfpFlags, &pidlCreated, NULL);
        
        // Force a SHGetPathFromIDList later so that the linkinfo will not get confused by letter case changing
        // as in c:\Winnt\System32\App.exe versus C:\WINNT\system32\app.exe
        pszPath = NULL;
    }
    else if (!pszPath && pidl)
    {
        // pidl as input, make copy that we will keep
        hr = SHILClone(pidl, &pidlCreated);
    }
    else if (!pszPath && !pidl)
    {
        pidlCreated = NULL;
        // setting to empty
        hr = S_OK;
    }
    else
    {
        // can't set path and pidl at the same time
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // this data needs to be kept in sync with _pidl
        _RemoveExtraDataSection(EXP_SPECIAL_FOLDER_SIG);

        if (pidlCreated)
        {
            TCHAR szPath[MAX_PATH];

            if (!_pidl || !ILIsEqual(_pidl, pidlCreated))
            {
                // new pidl
                _bDirty = TRUE;
            }

            if (!pszPath && SHGetPathFromIDList(pidlCreated, szPath))
            {
                pszPath = szPath;
            }

            if (pszPath)
            {
                // needs old _pidl to work
                _UpdateWorkingDir(pszPath);
            }

            ILFree(_pidl);
            _pidl = pidlCreated;

            if (pszPath)
            {
                if (bUpdateTrackingData)
                {
                    // this is a file/folder, get tracking info (ignore failures)
                    _GetLinkInfo(pszPath);              // the LinkInfo (_pli)
                    _GetFindDataAndTracker(pszPath);    // tracker & find data
                }
            }
            else
            {
                // not a file, clear the tracking info
                WIN32_FIND_DATA fd = {0};
                _SetFindData(&fd);
                _ClearTrackerData();
                _FreeLinkInfo();
            }
        }
        else
        {
            // clear out the contents of the link
            _ResetPersistData();
            _bDirty = TRUE;
        }
    }

    return hr;
}

// compute the relative path for the target is there is one
// pszPath is optionatl to test if there is a relative path

BOOL CShellLink::_GetRelativePath(LPTSTR pszPath)
{
    BOOL bRet = FALSE;

    LPCTSTR pszPathRel = _pszRelSource ? _pszRelSource : _pszCurFile;
    if (pszPathRel && _pszRelPath)
    {
        TCHAR szRoot[MAX_PATH];

        lstrcpy(szRoot, pszPathRel);
        PathRemoveFileSpec(szRoot);         // pszPathRel is a file (not a directory)

        // this can fail for really deep paths
        if (PathCombine(pszPath, szRoot, _pszRelPath))
        {
            bRet = TRUE;
        }
    }
    return bRet;
}

void CShellLink::_GetFindData(WIN32_FIND_DATA *pfd)
{
    ZeroMemory(pfd, sizeof(*pfd));

    pfd->dwFileAttributes = _sld.dwFileAttributes;
    pfd->ftCreationTime = _sld.ftCreationTime;
    pfd->ftLastAccessTime = _sld.ftLastAccessTime;
    pfd->ftLastWriteTime = _sld.ftLastWriteTime;
    pfd->nFileSizeLow = _sld.nFileSizeLow;

    TCHAR szPath[MAX_PATH];
    SHGetPathFromIDList(_pidl, szPath);
    ASSERT(szPath[0]);  // no one should call this on a pidl without a path

    lstrcpy(pfd->cFileName, PathFindFileName(szPath));
}


STDMETHODIMP CShellLink::GetPath(LPWSTR pszFile, int cchFile, WIN32_FIND_DATAW *pfd, DWORD fFlags)
{
    TCHAR szPath[MAX_PATH];
    VDATEINPUTBUF(pszFile, TCHAR, cchFile);

    if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {                                                                          
        // For darwin enabled links, we do NOT want to have to go and call         
        // ParseDarwinID here because that could possible force the app to install.
        // So, instead we return the path to the icon as the path for darwin enable
        // shortcuts. This allows the icon to be correct and since the darwin icon 
        // will always be an .exe, ensuring that the context menu will be correct. 
        SHExpandEnvironmentStrings(_pszIconLocation ? _pszIconLocation : TEXT(""), szPath, ARRAYSIZE(szPath));
    }
    else
    {
        DumpPLI(_pli);

        if (!_pidl || !SHGetPathFromIDListEx(_pidl, szPath, (fFlags & SLGP_SHORTPATH) ? GPFIDL_ALTNAME : 0))
            szPath[0] = 0;

        // Must do the pfd thing before we munge szPath, because the stuff
        // we do to szPath might render it unsuitable for PathFindFileName.
        // (For example, "C:\WINNT\Profiles\Bob" might turn into "%USERPROFILE%",
        // and we want to make sure we save "Bob" before it's too late.)

        if (pfd)
        {
            memset(pfd, 0, sizeof(*pfd));
            if (szPath[0])
            {
                pfd->dwFileAttributes = _sld.dwFileAttributes;
                pfd->ftCreationTime = _sld.ftCreationTime;
                pfd->ftLastAccessTime = _sld.ftLastAccessTime;
                pfd->ftLastWriteTime = _sld.ftLastWriteTime;
                pfd->nFileSizeLow = _sld.nFileSizeLow;
                SHTCharToUnicode(PathFindFileName(szPath), pfd->cFileName, ARRAYSIZE(pfd->cFileName));
            }
        }

        if ((_sld.dwFlags & SLDF_HAS_EXP_SZ) && (fFlags & SLGP_RAWPATH))
        {
            // Special case where we grab the Target name from
            // the extra data section of the link rather than from
            // the pidl.  We do this after we grab the name from the pidl
            // so that if we fail, then there is still some hope that a
            // name can be returned.
            LPEXP_SZ_LINK pszl = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_LINK_SIG);
            if (pszl)
            {
                SHUnicodeToTChar(pszl->swzTarget, szPath, ARRAYSIZE(szPath));
                DebugMsg(DM_TRACE, TEXT("CShellLink::GetPath() %s (from xtra data)"), szPath);
            }
        }
    }

    if (pszFile)
    {
        SHTCharToUnicode(szPath, pszFile, cchFile);
    }

    // note the lame return semantics, check for S_OK to be sure you have a path
    return szPath[0] ? S_OK : S_FALSE;
}

STDMETHODIMP CShellLink::GetIDList(LPITEMIDLIST *ppidl)
{
    if (_pidl)
    {
        return SHILClone(_pidl, ppidl);
    }

    *ppidl = NULL;
    return S_FALSE;     // success but empty
}

#ifdef DEBUG

#define DumpTimes(ftCreate, ftAccessed, ftWrite) \
    DebugMsg(DM_TRACE, TEXT("create   %8x%8x"), ftCreate.dwLowDateTime,   ftCreate.dwHighDateTime);     \
    DebugMsg(DM_TRACE, TEXT("accessed %8x%8x"), ftAccessed.dwLowDateTime, ftAccessed.dwHighDateTime);   \
    DebugMsg(DM_TRACE, TEXT("write    %8x%8x"), ftWrite.dwLowDateTime,    ftWrite.dwHighDateTime);

#else

#define DumpTimes(ftCreate, ftAccessed, ftWrite)

#endif

void CheckAndFixNullCreateTime(LPCTSTR pszFile, FILETIME *pftCreationTime, const FILETIME *pftLastWriteTime)
{
    if (IsNullTime(pftCreationTime) && !IsNullTime(pftLastWriteTime))
    {
        // this file has a bogus create time, set it to the last accessed time
        HANDLE hfile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL, OPEN_EXISTING, 0, NULL);

        if (INVALID_HANDLE_VALUE != hfile)
        {
            DebugMsg(DM_TRACE, TEXT("create   %8x%8x"), pftCreationTime->dwLowDateTime, pftCreationTime->dwHighDateTime);

            if (SetFileTime(hfile, pftLastWriteTime, NULL, NULL))
            {
                // get the time back to make sure we match the precision of the file system
                *pftCreationTime = *pftLastWriteTime;     // patch this up
#ifdef DEBUG
                {
                    FILETIME ftCreate, ftAccessed, ftWrite;
                    if (GetFileTime((HANDLE)hfile, &ftCreate, &ftAccessed, &ftWrite))
                    {
                        // we can't be sure that ftCreate == pftCreationTime because the GetFileTime
                        // spec says that the granularity of Set and Get may be different.
                        DumpTimes(ftCreate, ftAccessed, ftWrite);
                    }
                }
#endif
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("unable to set create time"));
            }
            CloseHandle(hfile);
        }
    }
}

//
// sets the current links find data and link tracker based on a path.
//
// returns:
//      S_OK        the file/folder is there
//      FAILED(hr)  the file could not be found
//      _bDirty set if the find data for the file (or tracker data) has been updated
//

HRESULT CShellLink::_GetFindDataAndTracker(LPCTSTR pszPath)
{
    WIN32_FIND_DATA fd = {0};
    HRESULT hr = S_OK;
    // Open the file or directory or root path.  We have to set FILE_FLAG_BACKUP_SEMANTICS
    // to get CreateFile to give us directory handles.
    HANDLE hFile = CreateFile(pszPath,
                              FILE_READ_ATTRIBUTES,
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              NULL, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                              NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        // Get the file attributes
        BY_HANDLE_FILE_INFORMATION fi;
        if (GetFileInformationByHandle(hFile, &fi))
        {
            fd.dwFileAttributes = fi.dwFileAttributes;
            fd.ftCreationTime = fi.ftCreationTime;
            fd.ftLastAccessTime = fi.ftLastAccessTime;
            fd.ftLastWriteTime = fi.ftLastWriteTime;
            fd.nFileSizeLow = fi.nFileSizeLow;

            // save the Object IDs as well.
            if (_ptracker)
            {
                if (SUCCEEDED(_ptracker->InitFromHandle(hFile, pszPath)))
                {
                    if (_ptracker->IsDirty())
                        _bDirty = TRUE;
                }
                else
                {
                    // Save space in the .lnk file
                    _ptracker->InitNew();
                }
            }
        }
        else
        {
            hr = GetLastHRESULT();
        }
        CloseHandle(hFile);
    }
    else
    {
        hr = GetLastHRESULT();
    }

    if (SUCCEEDED(hr))
    {
        // If this file doesn't have a create time for some reason, set it to be the
        // current last-write time.
        CheckAndFixNullCreateTime(pszPath, &fd.ftCreationTime, &fd.ftLastWriteTime);
        _SetFindData(&fd);      // update _bDirty
    }
    return hr;
}

// IShellLink::SetIDList()
//
// note: the error returns here are really poor, they don't express
// any failures that might have occured (out of memory for example)

STDMETHODIMP CShellLink::SetIDList(LPCITEMIDLIST pidlnew)
{
    _SetPIDLPath(pidlnew, NULL, TRUE);
    return S_OK;    // return 
}

BOOL DifferentStrings(LPCTSTR psz1, LPCTSTR psz2)
{
    if (psz1 && psz2)
    {
        return lstrcmp(psz1, psz2);
    }
    else
    {
        return (!psz1 && psz2) || (psz1 && !psz2);
    }
}

// NOTE: NULL string ptr is valid argument for this function

HRESULT CShellLink::_SetField(LPTSTR *ppszField, LPCWSTR pszValueW)
{
    TCHAR szValue[INFOTIPSIZE], *pszValue;

    if (pszValueW)
    {
        SHUnicodeToTChar(pszValueW, szValue, ARRAYSIZE(szValue));
        pszValue = szValue;
    }
    else
    {
        pszValue = NULL;
    }

    if (DifferentStrings(*ppszField, pszValue))
    {
        _bDirty = TRUE;
    }

    Str_SetPtr(ppszField, pszValue);
    return S_OK;
}

HRESULT CShellLink::_SetField(LPTSTR *ppszField, LPCSTR pszValueA)
{
    TCHAR szValue[INFOTIPSIZE], *pszValue;

    if (pszValueA)
    {
        SHAnsiToTChar(pszValueA, szValue, ARRAYSIZE(szValue));
        pszValue = szValue;
    }
    else
    {
        pszValue = NULL;
    }

    if (DifferentStrings(*ppszField, pszValue))
    {
        _bDirty = TRUE;
    }

    Str_SetPtr(ppszField, pszValue);
    return S_OK;
}


HRESULT CShellLink::_GetField(LPCTSTR pszField, LPWSTR pszValue, int cchValue)
{
    if (pszField == NULL)
    {
        *pszValue = 0;
    }
    else
    {
        SHLoadIndirectString(pszField, pszValue, cchValue, NULL);
    }

    return S_OK;
}

HRESULT CShellLink::_GetField(LPCTSTR pszField, LPSTR pszValue, int cchValue)
{
    LPWSTR pwsz = (LPWSTR)alloca(cchValue * sizeof(WCHAR));

    _GetField(pszField, pwsz, cchValue);

    SHUnicodeToAnsi(pwsz, pszValue, cchValue);

    return S_OK;
}

//  order is important
const int c_rgcsidlUserFolders[] = {
    CSIDL_MYPICTURES | TEST_SUBFOLDER,
    CSIDL_PERSONAL | TEST_SUBFOLDER,
    CSIDL_DESKTOPDIRECTORY | TEST_SUBFOLDER,
    CSIDL_COMMON_DESKTOPDIRECTORY | TEST_SUBFOLDER,
};

STDAPI_(void) SHMakeDescription(LPCITEMIDLIST pidlDesc, int ids, LPTSTR pszDesc, UINT cch)
{
    LPCITEMIDLIST pidlName = pidlDesc;
    TCHAR szPath[MAX_PATH], szFormat[64];
    DWORD gdn;

    ASSERT(pidlDesc);
    
    //
    //  we want to only show the INFOLDER name for 
    //  folders the user sees often.  so in the desktop
    //  or mydocs or mypics we just show that name.
    //  otherwise show the whole path.
    //
    //  NOTE - there can be some weirdness if you start making
    //  shortcuts to special folders off the desktop
    //  specifically if you make a shortcut to mydocs the comment
    //  ends up being %USERPROFILE%, but this is a rare enough 
    //  case that i dont think we need to worry too much.
    //
    SHGetNameAndFlags(pidlDesc, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
    int csidl = GetSpecialFolderID(szPath, c_rgcsidlUserFolders, ARRAYSIZE(c_rgcsidlUserFolders));
    if (-1 != csidl)
    {
        gdn = SHGDN_INFOLDER   | SHGDN_FORADDRESSBAR;
        switch (csidl)
        {
        case CSIDL_DESKTOPDIRECTORY:
        case CSIDL_COMMON_DESKTOPDIRECTORY:
            {
                ULONG cb;
                if (csidl == GetSpecialFolderParentIDAndOffset(pidlDesc, &cb))
                {
                    //  reorient based off the desktop.
                    pidlName = (LPCITEMIDLIST)(((BYTE *)pidlDesc) + cb);
                }
            }
            break;

        case CSIDL_PERSONAL:
            if (SUCCEEDED(GetMyDocumentsDisplayName(szPath, ARRAYSIZE(szPath))))
                pidlName = NULL;
            break;

        default:
            break;
        }
    }
    else
        gdn = SHGDN_FORPARSING | SHGDN_FORADDRESSBAR;

    if (pidlName)
    {
        SHGetNameAndFlags(pidlName, gdn, szPath, ARRAYSIZE(szPath), NULL);
    }

#if 0       //  if we ever want to handle frienly URL comments
    if (UrlIs(pszPath, URLIS_URL))
    {
        DWORD cchPath = SIZECHARS(szPath);
        if (FAILED(UrlCombine(pszPath, TEXT(""), szPath, &cchPath, 0)))
        {
            // if the URL is too big, then just use the hostname...
            cchPath = SIZECHARS(szPath);
            UrlCombine(pszPath, TEXT("/"), szPath, &cchPath, 0);
        }
    }
#endif

    if (ids != -1)
    {
        LoadString(HINST_THISDLL, ids, szFormat, ARRAYSIZE(szFormat));

        wnsprintf(pszDesc, cch, szFormat, szPath);
    }
    else
        StrCpyN(pszDesc, szPath, cch);
}

void _MakeDescription(LPCITEMIDLIST pidlTo, LPTSTR pszDesc, UINT cch)
{
    LPCITEMIDLIST pidlInner;
    if (ILIsRooted(pidlTo))
    {
        pidlInner = ILRootedFindIDList(pidlTo);
    }
    else
    {
        pidlInner = pidlTo;
    }

    LPITEMIDLIST pidlParent = ILCloneParent(pidlInner);
    if (pidlParent)
    {
        SHMakeDescription(pidlParent, IDS_LOCATION, pszDesc, cch);
        ILFree(pidlParent);
    }
    else
    {
        *pszDesc = 0;
    }
}

STDMETHODIMP CShellLink::GetDescription(LPWSTR pszDesc, int cchMax)
{
    return _GetField(_pszName, pszDesc, cchMax);
}

STDMETHODIMP CShellLink::GetDescription(LPSTR pszDesc, int cchMax)
{
    return _GetField(_pszName, pszDesc, cchMax);
}

STDMETHODIMP CShellLink::SetDescription(LPCWSTR pszDesc)
{
    return _SetField(&_pszName, pszDesc);
}

STDMETHODIMP CShellLink::SetDescription(LPCSTR pszDesc)
{
    return _SetField(&_pszName, pszDesc);
}

STDMETHODIMP CShellLink::GetWorkingDirectory(LPWSTR pszDir, int cchDir)
{
    return _GetField(_pszWorkingDir, pszDir, cchDir);
}

STDMETHODIMP CShellLink::GetWorkingDirectory(LPSTR pszDir, int cchDir)
{
    return _GetField(_pszWorkingDir, pszDir, cchDir);
}

STDMETHODIMP CShellLink::SetWorkingDirectory(LPCWSTR pszWorkingDir)
{
    return _SetField(&_pszWorkingDir, pszWorkingDir);
}

STDMETHODIMP CShellLink::SetWorkingDirectory(LPCSTR pszDir)
{
    return _SetField(&_pszWorkingDir, pszDir);
}

STDMETHODIMP CShellLink::GetArguments(LPWSTR pszArgs, int cchArgs)
{
    return _GetField(_pszArgs, pszArgs, cchArgs);
}

STDMETHODIMP CShellLink::GetArguments(LPSTR pszArgs, int cch)
{
    return _GetField(_pszArgs, pszArgs, cch);
}

STDMETHODIMP CShellLink::SetArguments(LPCWSTR pszArgs)
{
    return _SetField(&_pszArgs, pszArgs);
}

STDMETHODIMP CShellLink::SetArguments(LPCSTR pszArgs)
{
    return _SetField(&_pszArgs, pszArgs);
}

STDMETHODIMP CShellLink::GetHotkey(WORD *pwHotkey)
{
    *pwHotkey = _sld.wHotkey;
    return S_OK;
}

STDMETHODIMP CShellLink::SetHotkey(WORD wHotkey)
{
    if (_sld.wHotkey != wHotkey)
    {
        _bDirty = TRUE;
        _sld.wHotkey = wHotkey;
    }
    return S_OK;
}

STDMETHODIMP CShellLink::GetShowCmd(int *piShowCmd)
{
    *piShowCmd = _sld.iShowCmd;
    return S_OK;
}

STDMETHODIMP CShellLink::SetShowCmd(int iShowCmd)
{
    if (_sld.iShowCmd != iShowCmd)
    {
        _bDirty = TRUE;
    }
    _sld.iShowCmd = iShowCmd;
    return S_OK;
}

// IShellLinkW::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(LPWSTR pszIconPath, int cchIconPath, int *piIcon)
{
    VDATEINPUTBUF(pszIconPath, TCHAR, cchIconPath);
    
    _UpdateIconFromExpIconSz();

    _GetField(_pszIconLocation, pszIconPath, cchIconPath);
    *piIcon = _sld.iIcon;

    return S_OK;
}

// IShellLinkA::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(LPSTR pszPath, int cch, int *piIcon)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = GetIconLocation(szPath, ARRAYSIZE(szPath), piIcon);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(szPath, pszPath, cch);
    }
    return hr;
}


// IShellLinkW::SetIconLocation
// NOTE: 
//      pszIconPath may be NULL

STDMETHODIMP CShellLink::SetIconLocation(LPCWSTR pszIconPath, int iIcon)
{
    TCHAR szIconPath[MAX_PATH];

    if (pszIconPath)
    {
        SHUnicodeToTChar(pszIconPath, szIconPath, ARRAYSIZE(szIconPath));
    }

    if (pszIconPath)
    {
        HANDLE  hToken;
        TCHAR   szIconPathEnc[MAX_PATH];

        if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken) == FALSE)
        {
            hToken = NULL;
        }

        if (PathUnExpandEnvStringsForUser(hToken, szIconPath, szIconPathEnc, ARRAYSIZE(szIconPathEnc)) != 0)
        {
            EXP_SZ_LINK expLink;

            // mark that link has expandable strings, and add them
            _sld.dwFlags |= SLDF_HAS_EXP_ICON_SZ; // should this be unique for icons?

            LPEXP_SZ_LINK lpNew = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_ICON_SIG);
            if (!lpNew) 
            {
                lpNew = &expLink;
                expLink.cbSize = 0;
                expLink.dwSignature = EXP_SZ_ICON_SIG;
            }

            // store both A and W version (for no good reason!)
            SHTCharToAnsi(szIconPathEnc, lpNew->szTarget, ARRAYSIZE(lpNew->szTarget));
            SHTCharToUnicode(szIconPathEnc, lpNew->swzTarget, ARRAYSIZE(lpNew->swzTarget));

            // See if this is a new entry that we need to add
            if (lpNew->cbSize == 0)
            {
                lpNew->cbSize = sizeof(*lpNew);
                _AddExtraDataSection((DATABLOCK_HEADER *)lpNew);
            }
        }
        else 
        {
            _sld.dwFlags &= ~SLDF_HAS_EXP_ICON_SZ;
            _RemoveExtraDataSection(EXP_SZ_ICON_SIG);
        }
        if (hToken != NULL)
        {
            CloseHandle(hToken);
        }
    }

    _SetField(&_pszIconLocation, pszIconPath);

    if (_sld.iIcon != iIcon)
    {
        _sld.iIcon = iIcon;
        _bDirty = TRUE;
    }

    if ((_sld.dwFlags & SLDF_HAS_DARWINID) && pszIconPath)
    {
        // NOTE: The comment below is for darwin as it shipped in win98/IE4.01,
        // and is fixed in the > NT5 versions of the shell's darwin implementation.
        //
        // for darwin enalbed links, we make the path point to the
        // icon location (which is must be of the type (ie same ext) as the real
        // destination. So, if I want a darwin link to readme.txt, the shell
        // needs the icon to be icon1.txt, which is not good!!. This ensures
        // that the context menu will be correct and allows us to return
        // from CShellLink::GetPath & CShellLink::GetIDList without faulting the 
        // application in because we lie to people and tell them that we 
        // really point to our icon, which is the same type as the real target,
        // thus making our context menu be correct.
        _SetPIDLPath(NULL, szIconPath, FALSE);
    }

    return S_OK;
}

// IShellLinkA::SetIconLocation
STDMETHODIMP CShellLink::SetIconLocation(LPCSTR pszPath, int iIcon)
{
    WCHAR szPath[MAX_PATH];
    LPWSTR pszPathW;

    if (pszPath)
    {
        SHAnsiToUnicode(pszPath, szPath, ARRAYSIZE(szPath));
        pszPathW = szPath;
    }
    else
    {
        pszPathW = NULL;
    }

    return SetIconLocation(pszPathW, iIcon);
}

HRESULT CShellLink::_InitExtractImage()
{
    HRESULT hr;
    if (_pxthumb)
    {
        hr = S_OK;
    }
    else
    {
        hr = _GetUIObject(NULL, IID_PPV_ARG(IExtractImage, &_pxthumb));
    }
    return hr;
}

// IExtractImage

STDMETHODIMP CShellLink::GetLocation(LPWSTR pszPathBuffer, DWORD cch,
                                    DWORD * pdwPriority, const SIZE * prgSize,
                                    DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr = _InitExtractImage();
    if (SUCCEEDED(hr))
    {
        hr = _pxthumb->GetLocation(pszPathBuffer, cch, pdwPriority, prgSize, dwRecClrDepth, pdwFlags);
    }
    return hr;
}

STDMETHODIMP CShellLink::Extract(HBITMAP *phBmpThumbnail)
{
    HRESULT hr = _InitExtractImage();
    if (SUCCEEDED(hr))
    {
        hr = _pxthumb->Extract(phBmpThumbnail);
    }
    return hr;
}

STDMETHODIMP CShellLink::GetDateStamp(FILETIME *pftDateStamp)
{
    HRESULT hr = _InitExtractImage();
    if (SUCCEEDED(hr))
    {
        IExtractImage2 * pExtract2;
        hr = _pxthumb->QueryInterface(IID_PPV_ARG(IExtractImage2, &pExtract2));
        if (SUCCEEDED(hr))
        {
            hr = pExtract2->GetDateStamp(pftDateStamp);
            pExtract2->Release();
        }
    }
    return hr;
}



// set the relative path, this is used before a link is saved so we know what
// we should use to store the link relative to as well as before the link is resolved
// so we know the new path to use with the saved relative path.
//
// in:
//      pszPathRel      path to make link target relative to, must be a path to
//                      a file, not a directory.
//
//      dwReserved      must be 0
//
// returns:
//      S_OK            relative path is set
//

STDMETHODIMP CShellLink::SetRelativePath(LPCWSTR pszPathRel, DWORD dwRes)
{
    if (dwRes != 0)
    {
        return E_INVALIDARG;
    }

    return _SetField(&_pszRelSource, pszPathRel);
}

STDMETHODIMP CShellLink::SetRelativePath(LPCSTR pszPathRel, DWORD dwRes)
{
    if (dwRes != 0)
    {
        return E_INVALIDARG;
    }

    return _SetField(&_pszRelSource, pszPathRel);
}

// IShellLink::Resolve()
// 
// If SLR_UPDATE isn't set, check IPersistFile::IsDirty after
// calling this to see if the link info has changed and save it.
//
// returns:
//      S_OK    all things good
//      S_FALSE user canceled (bummer, should be ERROR_CANCELLED)

STDMETHODIMP CShellLink::Resolve(HWND hwnd, DWORD dwResolveFlags)
{
    HRESULT hr = _Resolve(hwnd, dwResolveFlags, 0);
    
    if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
    {
        hr = S_FALSE;
    }

    return hr;
}

//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
//    NOTE: Stolen from inet\urlmon\download\helpers.cxx
HRESULT GetVersionFromString(TCHAR *szBuf, DWORD *pdwFileVersionMS, DWORD *pdwFileVersionLS)
{
    const TCHAR *pch = szBuf;
    TCHAR ch;
    USHORT n = 0;
    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (lstrcmp(pch, TEXT("-1,-1,-1,-1")) == 0)
    {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
        return S_OK;
    }

    for (ch = *pch++;;ch = *pch++)
    {
        if ((ch == ',') || (ch == '\0'))
        {
            switch (have)
            {
            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0')
            {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        }
        else if ((ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}

//  Purpose:    A _Resolve-time check to see if the link has
//              Logo3 application channel
//
//  Inputs:     [LPCTSTR] - pszLogo3ID - the id/keyname for
//                          our Logo3 software.
//
//  Outputs:    [BOOL]
//                  -   TRUE if our peek at the registry
//                      indicates we have an ad to show
//                  -   FALSE indicates no new version
//                      to advertise.
//
//  Algorithm:  Check the software update registry info for the
//              ID embedded in the link. This is a sleazy hack
//              to avoid loading shdocvw and urlmon, which are
//              the normal code path for this check.
//              NOTE: The version checking logic is stolen from
//              shell\shdocvw\sftupmb.cpp

HRESULT GetLogo3SoftwareUpdateInfo(LPCTSTR pszLogo3ID, LPSOFTDISTINFO psdi)
{    
    HRESULT     hr = S_OK;
    HKEY        hkeyDistInfo = 0;
    HKEY        hkeyAvail = 0;
    HKEY        hkeyAdvertisedVersion = 0;
    DWORD       lResult = 0;
    DWORD       dwSize = 0;
    DWORD       dwType;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szVersionBuf[MAX_PATH];
    DWORD       dwLen = 0;
    DWORD       dwCurAdvMS = 0;
    DWORD       dwCurAdvLS = 0;

    wsprintf(szBuffer,
             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s"),
             pszLogo3ID);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                     &hkeyDistInfo) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Exit;
    }
    
    if (RegOpenKeyEx(hkeyDistInfo, TEXT("AvailableVersion"), 0, KEY_READ,
                     &hkeyAvail) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Exit;
    }

    dwSize = sizeof(lResult);
    if (SHQueryValueEx(hkeyAvail, TEXT("Precache"), 0, &dwType,
                        (unsigned char *)&lResult, &dwSize) == ERROR_SUCCESS)
    {
        // Precached value was the code download HR
        if (lResult == S_OK)
            psdi->dwFlags = SOFTDIST_FLAG_USAGE_PRECACHE;
    }


    dwSize = sizeof(szVersionBuf);
    if (SHQueryValueEx(hkeyAvail, TEXT("AdvertisedVersion"), NULL, &dwType, 
                        szVersionBuf, &dwSize) == ERROR_SUCCESS)
    {
        GetVersionFromString(szVersionBuf, &psdi->dwAdvertisedVersionMS, &psdi->dwAdvertisedVersionLS);
        // Get the AdState, if any
        dwSize = sizeof(psdi->dwAdState);
        SHQueryValueEx(hkeyAvail, TEXT("AdState"), NULL, NULL, &psdi->dwAdState, &dwSize);
    }
 


    dwSize = sizeof(szVersionBuf);
    if (SHQueryValueEx(hkeyAvail, NULL, NULL, &dwType, szVersionBuf, &dwSize) != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if (FAILED(GetVersionFromString(szVersionBuf, &psdi->dwUpdateVersionMS, &psdi->dwUpdateVersionLS)))
    {
        hr = S_FALSE;
        goto Exit;
    }

 
    dwLen = sizeof(psdi->dwInstalledVersionMS);
    if (SHQueryValueEx(hkeyDistInfo, TEXT("VersionMajor"), 0, &dwType,
                        &psdi->dwInstalledVersionMS, &dwLen) != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto Exit;
    }

    dwLen = sizeof(psdi->dwInstalledVersionLS);
    if (SHQueryValueEx(hkeyDistInfo, TEXT("VersionMinor"), 0, &dwType,
                        &psdi->dwInstalledVersionLS, &dwLen) != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if (psdi->dwUpdateVersionMS > psdi->dwInstalledVersionMS ||
        (psdi->dwUpdateVersionMS == psdi->dwInstalledVersionMS &&
         psdi->dwUpdateVersionLS > psdi->dwInstalledVersionLS))
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Exit:
    if (hkeyAdvertisedVersion)
    {
        RegCloseKey(hkeyAdvertisedVersion);
    }

    if (hkeyAvail)
    {
        RegCloseKey(hkeyAvail);
    }

    if (hkeyDistInfo)
    {
        RegCloseKey(hkeyDistInfo);
    }

    return hr;
}

//  Purpose:    A _Resolve-time check to see if the link has
//              Logo3 application channel
//
//  Inputs:     [LPCTSTR] - pszLogo3ID - the id/keyname for
//                          our Logo3 software.
//
//  Outputs:    [BOOL]
//                  -   TRUE if our peek at the registry
//                      indicates we have an ad to show
//                  -   FALSE indicates no new version
//                      to advertise.
//
//  Algorithm:  Check the software update registry info for the
//              ID embedded in the link. This is a sleazy hack
//              to avoid loading shdocvw and urlmon, which are
//              the normal code path for this check.
//              The version checking logic is stolen from

BOOL FLogo3RegPeek(LPCTSTR pszLogo3ID)
{
    BOOL            bHaveAd = FALSE;
    SOFTDISTINFO    sdi = { 0 };
    DWORD           dwAdStateNew = SOFTDIST_ADSTATE_NONE;

    HRESULT hr = GetLogo3SoftwareUpdateInfo(pszLogo3ID, &sdi);
 
    // we need an HREF to work properly. The title and abstract are negotiable.
    if (SUCCEEDED(hr))
    {
        // see if this is an update the user already knows about.
        // If it is, then skip the dialog.
        if ( (sdi.dwUpdateVersionMS >= sdi.dwInstalledVersionMS ||
                (sdi.dwUpdateVersionMS == sdi.dwInstalledVersionMS &&
                 sdi.dwUpdateVersionLS >= sdi.dwInstalledVersionLS))    && 
              (sdi.dwUpdateVersionMS >= sdi.dwAdvertisedVersionMS ||
                (sdi.dwUpdateVersionMS == sdi.dwAdvertisedVersionMS &&
                 sdi.dwUpdateVersionLS >= sdi.dwAdvertisedVersionLS)))
        { 
            if (hr == S_OK) // new version
            {
                // we have a pending update, either on the net, or downloaded
                if (sdi.dwFlags & SOFTDIST_FLAG_USAGE_PRECACHE)
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_DOWNLOADED;
                }
                else
                {
                    dwAdStateNew = SOFTDIST_ADSTATE_AVAILABLE;
                }
            }
            else if (sdi.dwUpdateVersionMS == sdi.dwInstalledVersionMS &&
                      sdi.dwUpdateVersionLS == sdi.dwInstalledVersionLS)
            {
                // if installed version matches advertised, then we autoinstalled already
                // NOTE: If the user gets gets channel notification, then runs out
                // to the store and buys the new version, then installs it, we'll
                // mistake this for an auto-install.
                dwAdStateNew = SOFTDIST_ADSTATE_INSTALLED;
            }

            // only show the dialog if we've haven't been in this ad state before for
            // this update version
            if (dwAdStateNew > sdi.dwAdState)
            {
                bHaveAd = TRUE;
            }
        } // if update is a newer version than advertised
    }

    return bHaveAd;
}


//  Purpose:    A _Resolve-time check to see if the link has
//              Logo3 application channel
//
//  Inputs:     [HWND] hwnd
//                  -   The parent window (which could be the desktop).
//              [DWORD] dwResolveFlags
//                  -   Flags from the SLR_FLAGS enumeration.
//
// returns:
//  S_OK    The user wants to pursue the
//          software update thus we should not continue
//                  
// S_FALSE  No software update, or the user doesn't want it now.
//          proceed with regular resolve path
//
//  Algorithm:  Check the software update registry info for the
//              ID embedded in the link. If there's a new version
//              advertised, prompt the user with shdocvw's message
//              box. If the mb says update, tell the caller we
//              don't want the link target, as we're headed to the
//              link update page.

HRESULT CShellLink::_ResolveLogo3Link(HWND hwnd, DWORD dwResolveFlags)
{
    HRESULT hr = S_FALSE; // default to no update.

    if ((_sld.dwFlags & SLDF_HAS_LOGO3ID) &&
        !SHRestricted(REST_NOLOGO3CHANNELNOTIFY))
    {
        LPEXP_DARWIN_LINK pdl = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, EXP_LOGO3_ID_SIG);
        if (pdl)
        {
            TCHAR szLogo3ID[MAX_PATH];
            WCHAR szwLogo3ID[MAX_PATH];
            int cchBlessData;
            WCHAR *pwch;

            TCHAR *pch = pdl->szwDarwinID;

            // Ideally, we support multiple, semi-colon delmited IDs, for now
            // just grab the first one.
            for (pwch = pdl->szwDarwinID, cchBlessData = 0;
                  *pch != ';' && *pch != '\0' && cchBlessData < MAX_PATH;
                  pch++, pwch++, cchBlessData++)
            {
                szLogo3ID[cchBlessData] = *pch;
                szwLogo3ID[cchBlessData] = *pwch;
            }
            // and terminate
            szLogo3ID[cchBlessData] = '\0';
            szwLogo3ID[cchBlessData] = L'\0';
        
            // Before well haul in shdocvw, we'll sneak a peak at our Logo3 reg goo 
            if (!(dwResolveFlags & SLR_NO_UI) && FLogo3RegPeek(szLogo3ID))
            {
                // stuff stolen from shdocvw\util.cpp's CheckSoftwareUpdateUI
                BOOL fLaunchUpdate = FALSE;
                SOFTDISTINFO sdi = { 0 };
                sdi.cbSize = sizeof(sdi);

                int nRes = SoftwareUpdateMessageBox(hwnd, szwLogo3ID, 0, &sdi);

                if (nRes != IDABORT)
                {
                    if (nRes == IDYES)
                    {
                        // NOTE: This differ's from Shdocvw in that we don't
                        // have the cool internal navigation stuff to play with.
                        // Originally, this was done with ShellExecEx. This failed
                        // because the http hook wasn't 100% reliable on Win95.
                        //ShellExecuteW(NULL, NULL, sdi.szHREF, NULL, NULL, 0);
                        hr = HlinkNavigateString(NULL, sdi.szHREF);

                    } // if user wants update

                    if (sdi.szTitle != NULL)
                        SHFree(sdi.szTitle);
                    if (sdi.szAbstract != NULL)
                        SHFree(sdi.szAbstract);
                    if (sdi.szHREF != NULL)
                        SHFree(sdi.szHREF);
    
                    fLaunchUpdate = nRes == IDYES && SUCCEEDED(hr);
                } // if no message box abort (error)

                if (fLaunchUpdate)
                {
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}

BOOL _TryRestoreConnection(HWND hwnd, LPCTSTR pszPath)
{
    BOOL bRet = FALSE;
    if (!PathIsUNC(pszPath) && IsDisconnectedNetDrive(DRIVEID(pszPath)))
    {
        TCHAR szDrive[4];
        szDrive[0] = *pszPath;
        szDrive[1] = TEXT(':');
        szDrive[2] = 0;
        bRet = WNetRestoreConnection(hwnd, szDrive) == WN_SUCCESS;
    }
    return bRet;
}

//
// updates then resolves LinkInfo associated with a CShellLink instance
// if the resolve results in a new path updates the pidl to the new path
//
// in:
//      hwnd    to post resolve UI on (if dwFlags indicates UI)
//      dwResolveFlags  IShellLink::Resolve() flags
//
// in/out:
//      pszPath     may be updated with new path to use in case of failure
//
// returns:
//      FAILED()    we failed the update, either UI cancel or memory failure, 
//                  be sure to respect ERROR_CANCELLED
//      S_OK        we have a valid pli and pidl read to be used OR
//                  we should search for this path using the link search code

HRESULT CShellLink::_ResolveLinkInfo(HWND hwnd, DWORD dwResolveFlags, LPTSTR pszPath, DWORD *pfifFlags)
{
    HRESULT hr;
    if (SHRestricted(REST_LINKRESOLVEIGNORELINKINFO))
    {
        _TryRestoreConnection((dwResolveFlags & SLR_NO_UI) ? NULL : hwnd, pszPath);
        hr = _SetPIDLPath(NULL, pszPath, TRUE);
    } 
    else
    {
        ASSERTMSG(_pli != NULL, "_ResolveLinkInfo should only be called when _pli != NULL");

        DWORD dwLinkInfoFlags = (RLI_IFL_CONNECT | RLI_IFL_TEMPORARY);

        if (!PathIsRoot(pszPath))
            dwLinkInfoFlags |= RLI_IFL_LOCAL_SEARCH;

        if (!(dwResolveFlags & SLR_NO_UI))
            dwLinkInfoFlags |= RLI_IFL_ALLOW_UI;

        ASSERT(!(dwLinkInfoFlags & RLI_IFL_UPDATE));

        TCHAR szResolvedPath[MAX_PATH];
        DWORD dwOutFlags;
        if (ResolveLinkInfo(_pli, szResolvedPath, dwLinkInfoFlags, hwnd, &dwOutFlags, NULL))
        {
            ASSERT(!(dwOutFlags & RLI_OFL_UPDATED));

            PathRemoveBackslash(szResolvedPath);    // remove extra trailing slashes
            lstrcpy(pszPath, szResolvedPath);       // in case of failure, use this

            // net connection might have been re-established, try again
            hr = _SetPIDLPath(NULL, pszPath, TRUE);
        }
        else 
        {
            // don't try searching this drive/volume again
            *pfifFlags |= FIF_NODRIVE;
            hr = GetLastHRESULT();
        }
    }
    return hr;
}

DWORD TimeoutDeltaFromResolveFlags(DWORD dwResolveFlags)
{
    DWORD dwTimeOutDelta;
    if (SLR_NO_UI & dwResolveFlags)
    {
        dwTimeOutDelta = HIWORD(dwResolveFlags);
        if (dwTimeOutDelta == 0)
        {
            dwTimeOutDelta = NOUI_SEARCH_TIMEOUT;
        }
        else if (dwTimeOutDelta == 0xFFFF)
        {
            TCHAR szTimeOut[10];
            LONG cbTimeOut = sizeof(szTimeOut);
    
            if (ERROR_SUCCESS == SHRegQueryValue(HKEY_LOCAL_MACHINE,
                                                 TEXT("Software\\Microsoft\\Tracking\\TimeOut"),
                                                 szTimeOut,
                                                 &cbTimeOut))
            {
                dwTimeOutDelta = StrToInt(szTimeOut);
            }
            else
            {
                dwTimeOutDelta = NOUI_SEARCH_TIMEOUT;
            }
        }
    }
    else
    {
        dwTimeOutDelta = UI_SEARCH_TIMEOUT;
    }
    return dwTimeOutDelta;
}


// allows the name space to be able to hook the resolve process and thus
// provide custom behavior. this is used for reg items and shortcuts to the 
// MyDocs folder
//
// this also resolves by re-parsing the relative parsing name as the optimal way
// to run the success case of ::Resolve()
//
// returns:
//      S_OK    this resolution was taken care of
//      HRESULT_FROM_WIN32(ERROR_CANCELLED) UI cancel
//      HRESULT_FROM_WIN32(ERROR_TIMEOUT) timeout on the parse
//      other FAILED() codes (implies name space did not resolve for you)

HRESULT CShellLink::_ResolveIDList(HWND hwnd, DWORD dwResolveFlags)
{
    ASSERT(!(_sld.dwFlags & SLDF_HAS_DARWINID));
    
    HRESULT hr = E_FAIL;   // generic failure, we did not handle this
    IShellFolder* psf;
    LPCITEMIDLIST pidlChild;
    if (_pidl && SUCCEEDED(SHBindToIDListParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        IResolveShellLink *prl = NULL;
        
        // 2 ways to get the link resolve object
        // 1. ask the folder for the resolver for the item
        if (FAILED(psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_PPV_ARG_NULL(IResolveShellLink, &prl))))
        {
            // 2. bind to the object directly and ask it (CreateViewObject)
            IShellFolder *psfItem;
            if (SUCCEEDED(psf->BindToObject(pidlChild, NULL, IID_PPV_ARG(IShellFolder, &psfItem))))
            {
                psfItem->CreateViewObject(NULL, IID_PPV_ARG(IResolveShellLink, &prl));
                psfItem->Release();
            }
        }
        
        if (prl)
        {
            hr = prl->ResolveShellLink(SAFECAST(this, IShellLink*), hwnd, dwResolveFlags);
            prl->Release();
        }
        else
        {
            // perf short circuit: avoid the many net round trips that happen in 
            // _SetPIDLPath() in the common success case where the file is there
            // we validate the target based on reparsing the relative name
            //
            // this is a universal way to "resolve" an object in the name space
            
            // note, code here is very similart to SHGetRealIDL() but this version
            // does not mask the error cases that we need to detect
            
            TCHAR szName[MAX_PATH];
            if (SUCCEEDED(DisplayNameOf(psf, pidlChild, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
            {
                // we limit this to file system items for compat with some name spaces
                // (WinCE) that support parse, but do a bad job of it
                if (SHGetAttributes(psf, pidlChild, SFGAO_FILESYSTEM))
                {
                    IBindCtx *pbcTimeout;
                    BindCtx_CreateWithTimeoutDelta(TimeoutDeltaFromResolveFlags(dwResolveFlags), &pbcTimeout);

                    if (dwResolveFlags & SLR_NO_UI)
                    {
                        hwnd = NULL;    // make sure parse does not get this
                    }
                    
                    LPITEMIDLIST pidlChildNew;
                    hr = psf->ParseDisplayName(hwnd, pbcTimeout, szName, NULL, &pidlChildNew, NULL);
                    if (SUCCEEDED(hr))
                    {
                        // no construct the new full IDList and set that
                        // note many pidls here, make sure we don't leak any
                        
                        LPITEMIDLIST pidlParent = ILCloneParent(_pidl);
                        if (pidlParent)
                        {
                            LPITEMIDLIST pidlFull = ILCombine(pidlParent, pidlChildNew);
                            if (pidlFull)
                            {
                                // we set this as the new target of this link, 
                                // with FALSE for bUpdateTrackingData to avoid the cost of that
                                hr = _SetPIDLPath(pidlFull, NULL, FALSE);
                                ILFree(pidlFull);
                            }
                            ILFree(pidlParent);
                        }
                        ILFree(pidlChildNew);
                    }
                    
                    if (pbcTimeout)
                        pbcTimeout->Release();
                }
            }
        }
        psf->Release();
    }
    return hr;
}

BOOL CShellLink::_ResolveDarwin(HWND hwnd, DWORD dwResolveFlags, HRESULT *phr)
{
    // check to see if this is a Darwin link
    BOOL bIsDrawinLink = _sld.dwFlags & SLDF_HAS_DARWINID;
    if (bIsDrawinLink)
    {
        HRESULT hr = S_OK;
        // we only envoke darwin if they are passing the correct SLR_INVOKE_MSI
        // flag. This prevents poor apps from going and calling resolve and
        // faulting in a bunch of darwin apps.
        if ((dwResolveFlags & SLR_INVOKE_MSI) && IsDarwinEnabled())
        {
            LPEXP_DARWIN_LINK pdl = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, EXP_DARWIN_ID_SIG);
            if (pdl)
            {
                TCHAR szDarwinCommand[MAX_PATH];

                hr = ParseDarwinID(pdl->szwDarwinID, szDarwinCommand, SIZECHARS(szDarwinCommand));
                if (FAILED(hr) || 
                    HRESULT_CODE(hr) == ERROR_SUCCESS_REBOOT_REQUIRED || 
                    HRESULT_CODE(hr) == ERROR_SUCCESS_REBOOT_INITIATED)
                {
                    switch (HRESULT_CODE(hr))
                    {
                    case ERROR_INSTALL_USEREXIT:            // User pressed cancel. They don't need UI.
                    case ERROR_SUCCESS_REBOOT_INITIATED:    // Machine is going to reboot
                    case ERROR_SUCCESS_REBOOT_REQUIRED:
                        // dont run the darwin app in all of the above cases,
                        // ERROR_CANCELLED suppresses further error UI
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        break;

                    default:
                        if (!(dwResolveFlags & SLR_NO_UI))
                        {
                            TCHAR szTemp[MAX_PATH];
                            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, HRESULT_CODE(hr), 0, szTemp, ARRAYSIZE(szTemp), NULL);

                            ShellMessageBox(HINST_THISDLL, hwnd, szTemp,
                                            MAKEINTRESOURCE(IDS_LINKERROR),
                                            MB_OK | MB_ICONSTOP, NULL, NULL);
                            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        }
                        break;
                    }
                }
                else
                {
                    // We want to fire an event for the product code, not the path. Do this here since we've got the product code.
                    if (_pcbDarwin)
                    {
                        _pcbDarwin->SetProductCodeFromDarwinID(pdl->szwDarwinID);
                    }

                    PathUnquoteSpaces(szDarwinCommand);
                    hr = _SetPIDLPath(NULL, szDarwinCommand, FALSE);
                }
            }
        }
        *phr = hr;
    }
    return bIsDrawinLink;
}

// if the link has encoded env vars we will set them now, possibly updating _pidl

void CShellLink::_SetIDListFromEnvVars()
{
    TCHAR szPath[MAX_PATH];

    // check to see whether this link has expandable environment strings
    if (_GetExpandedPath(szPath, ARRAYSIZE(szPath)))
    {
        if (FAILED(_SetPIDLPath(NULL, szPath, TRUE)))
        {
            // The target file is no longer valid so we should dump the EXP_SZ section before
            // we continue.  Note that we don't set bDirty here, that is only set later if
            // we actually resolve this link to a new path or pidl.  The result is we'll only
            // save this modification if a new target is found and accepted by the user.
            _sld.dwFlags &= ~SLDF_HAS_EXP_SZ;

            _SetSimplePIDL(szPath);
        }
    } 
}

HRESULT CShellLink::_ResolveRemovable(HWND hwnd, LPCTSTR pszPath)
{
    HANDLE hfind;
    WIN32_FIND_DATA fd;
    HRESULT hr = FindFirstRetryRemovable(hwnd, _punkSite, pszPath, &fd, &hfind);
    if (S_OK == hr)
    {
        FindClose(hfind);   // throw that out
        hr = _SetPIDLPath(NULL, pszPath, TRUE);
    }
    return hr;
}

_inline BOOL FAILED_AND_NOT_STOP_ERROR(HRESULT hr)
{
    return FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) && (HRESULT_FROM_WIN32(ERROR_TIMEOUT) != hr);
}

//
//  implementation for IShellLink::Resolve and IShellLinkTracker::Resolve
//
//  Inputs:     hwnd
//                  -   The parent window (which could be the desktop).
//              dwResolveFlags
//                  -   Flags from the SLR_FLAGS enumeration.
//              dwTracker
//                  -   Restrict CTracker::Resolve from the
//                      TrkMendRestrictions enumeration
//
//  Outputs:    S_OK    resolution was successful
//
//  Algorithm:  Look for the link target and update the link path and IDList.
//              Check IPersistFile::IsDirty after calling this to see if the
//              link info has changed as a result.
//

HRESULT CShellLink::_Resolve(HWND hwnd, DWORD dwResolveFlags, DWORD dwTracker)
{
    if (S_OK == _ResolveLogo3Link(hwnd, dwResolveFlags))
    {
        // the link is being updated or the user canceled
        // either case we bail
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    HRESULT hr = S_OK;

    if (!_ResolveDarwin(hwnd, dwResolveFlags, &hr))
    {
        _SetIDListFromEnvVars();    // possibly sets _pidl via env vars

        // normal link resolve sequence starts here

        hr = _ResolveIDList(hwnd, dwResolveFlags);

        if (FAILED_AND_NOT_STOP_ERROR(hr))
        {
            TCHAR szPath[MAX_PATH];

            if (_pidl == NULL)
            {
                // APP COMPAT! Inso Quick View Plus demands S_OK on empty .lnk
                hr = S_OK;  
            }
            else if (SHGetPathFromIDList(_pidl, szPath) && !PathIsRoot(szPath))
            {
                DWORD fifFlags = 0;

                // file system specific link tracking kicks in now
                // see if it is where it was before...

                // see if it there is a UNC or net path alias, if so try that
                if (!(dwResolveFlags & SLR_NOLINKINFO) && _pli)
                {
                    hr = _ResolveLinkInfo(hwnd, dwResolveFlags, szPath, &fifFlags);
                }
                else
                {
                    hr = E_FAIL;
                }

                if (FAILED_AND_NOT_CANCELED(hr))
                {
                    // use the relative path info if that is available
                    TCHAR szNew[MAX_PATH];
                    if (_GetRelativePath(szNew))
                    {
                        if (StrCmpI(szNew, szPath))
                        {
                            lstrcpy(szPath, szNew); // use this in case of failure
                            hr = _SetPIDLPath(NULL, szPath, TRUE);
                        }
                    }
                }

                if (FAILED_AND_NOT_CANCELED(hr) && !(dwResolveFlags & SLR_NO_UI) && 
                    PathRetryRemovable(hr, szPath))
                {
                    // do prompt for removable media if approprate
                    hr = _ResolveRemovable(hwnd, szPath);
                    fifFlags &= ~FIF_NODRIVE; // now it is back
                }

                if (FAILED_AND_NOT_CANCELED(hr))
                {
                    WIN32_FIND_DATA fd;
                    _GetFindData(&fd);  // fd input to search

                    // standard places failed, now do the search/track stuff
                    CLinkResolver *prs = new CLinkResolver(_ptracker, &fd, dwResolveFlags, dwTracker, fifFlags);
                    if (prs)
                    {
                        int id = prs->Resolve(hwnd, szPath, _pszCurFile);
                        if (IDOK == id)
                        {
                            // get fully qualified result
                            prs->GetResult(szPath, ARRAYSIZE(szPath));
                            hr = _SetPIDLPath(NULL, szPath, TRUE);
                            ASSERT(SUCCEEDED(hr) ? _bDirty : TRUE)  // must be dirty on success
                        }
                        else
                        {
                            ASSERT(!_bDirty);      // should not be dirty now
                            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        }
                        prs->Release();
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
            {
                // non file system target, validate it. this is another way to "resolve" name space
                // objects. the other method is inside of _ResolveIDList() where we do the
                // name -> pidl round trip via parse calls. that version is restricted to
                // file system parts of the name space to avoid compat issues so we end up
                // here for all other name spaces

                ULONG dwAttrib = SFGAO_VALIDATE;     // to check for existance
                hr = SHGetNameAndFlags(_pidl, SHGDN_NORMAL, szPath, ARRAYSIZE(szPath), &dwAttrib);
                if (FAILED(hr))
                {
                    if (!(dwResolveFlags & SLR_NO_UI))
                    {
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CANTFINDORIGINAL), NULL,
                                    MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND, szPath);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    }
                }
            }
        }
    }

    // if the link is dirty update it (if it was loaded from a file)
    if (SUCCEEDED(hr) && _bDirty && (dwResolveFlags & SLR_UPDATE))
        Save((LPCOLESTR)NULL, TRUE);

    ASSERT(SUCCEEDED(hr) ? S_OK == hr : TRUE);  // make sure no S_FALSE values get through

    return hr;
}


// This will just add a section to the end of the extra data -- it does
// not check to see if the section already exists, etc.
void CShellLink::_AddExtraDataSection(DATABLOCK_HEADER *peh)
{
    if (SHAddDataBlock(&_pExtraData, peh))
    {
        _bDirty = TRUE;
    }
}

// This will remove the extra data section with the given signature.
void CShellLink::_RemoveExtraDataSection(DWORD dwSig)
{
    if (SHRemoveDataBlock(&_pExtraData, dwSig))
    {
        _bDirty = TRUE;
    }
}

// currently this function is used for NT shell32 builds only
void * CShellLink::_ReadExtraDataSection(DWORD dwSig)
{
    DATABLOCK_HEADER *pdb;

    CopyDataBlock(dwSig, (void **)&pdb);
    return (void *)pdb;
}

// Darwin and Logo3 blessings share the same structure
HRESULT CShellLink::BlessLink(LPCTSTR *ppszPath, DWORD dwSignature)
{
    EXP_DARWIN_LINK expLink;
    TCHAR szBlessID[MAX_PATH];
    int   cchBlessData;
    TCHAR *pch;

    // Copy the blessing data and advance *ppszPath to the end of the data.
    for (pch = szBlessID, cchBlessData = 0; **ppszPath != ':' && **ppszPath != '\0' && cchBlessData < MAX_PATH; pch++, (*ppszPath)++, cchBlessData++)
    {
        *pch = **ppszPath;
    }

    // Terminate the blessing data
    *pch = 0;
    
    // Set the magic flag
    if (dwSignature == EXP_DARWIN_ID_SIG)
    {
        _sld.dwFlags |= SLDF_HAS_DARWINID;
    }
    else if (dwSignature == EXP_LOGO3_ID_SIG)
    {
        _sld.dwFlags |= SLDF_HAS_LOGO3ID;
    }
    else
    {
        TraceMsg(TF_WARNING, "BlessLink was passed a bad data block signature.");
        return E_INVALIDARG;
    }

    // locate the old block, if it's there
    LPEXP_DARWIN_LINK lpNew = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, dwSignature);
    // if not, use our stack var
    if (!lpNew)
    {
        lpNew = &expLink;
        expLink.dbh.cbSize = 0;
        expLink.dbh.dwSignature = dwSignature;
    }

    SHTCharToAnsi(szBlessID, lpNew->szDarwinID, ARRAYSIZE(lpNew->szDarwinID));
    SHTCharToUnicode(szBlessID, lpNew->szwDarwinID, ARRAYSIZE(lpNew->szwDarwinID));

    // See if this is a new entry that we need to add
    if (lpNew->dbh.cbSize == 0)
    {
        lpNew->dbh.cbSize = sizeof(*lpNew);
        _AddExtraDataSection((DATABLOCK_HEADER *)lpNew);
    }

    return S_OK;
}

// in/out:
//      ppszPathIn

HRESULT CShellLink::_CheckForLinkBlessing(LPCTSTR *ppszPathIn)
{
    HRESULT hr = S_FALSE; // default to no-error, no blessing

    while (SUCCEEDED(hr) && (*ppszPathIn)[0] == ':' && (*ppszPathIn)[1] == ':')
    {
        // identify type of link blessing and perform
        if (StrCmpNI(*ppszPathIn, DARWINGUID_TAG, ARRAYSIZE(DARWINGUID_TAG) - 1) == 0)
        {
            *ppszPathIn = *ppszPathIn + ARRAYSIZE(DARWINGUID_TAG) - 1;
            hr = BlessLink(ppszPathIn, EXP_DARWIN_ID_SIG);
        }
        else if (StrCmpNI(*ppszPathIn, LOGO3GUID_TAG, ARRAYSIZE(LOGO3GUID_TAG) - 1) == 0)
        {
            *ppszPathIn = *ppszPathIn + ARRAYSIZE(LOGO3GUID_TAG) - 1;
            HRESULT hrBless = BlessLink(ppszPathIn, EXP_LOGO3_ID_SIG);
            // if the blessing failed, report the error, otherwise keep the
            // default hr == S_FALSE or the result of the Darwin blessing.
            if (FAILED(hrBless))
                hr = hrBless;
        }
        else
        {
            break;
        }
    }
        
    return hr;
}

// TODO: Remove OLD_DARWIN stuff once we have transitioned Darwin to
//       the new link blessing syntax.
#define OLD_DARWIN

int CShellLink::_IsOldDarwin(LPCTSTR pszPath)
{
#ifdef OLD_DARWIN
    int iLength = lstrlen(pszPath);
    if ((pszPath[0] == TEXT('[')) && (pszPath[iLength - 1] == TEXT(']')))
    {
        return iLength;
    }
#endif
    return 0;
}

// we have a path that is enclosed in []'s,
// so this must be a Darwin link.

HRESULT CShellLink::_SetPathOldDarwin(LPCTSTR pszPath)
{
    TCHAR szDarwinID[MAX_PATH];

    // strip off the []'s
    lstrcpy(szDarwinID, &pszPath[1]);
    szDarwinID[lstrlen(pszPath) - 1] = 0;

    _sld.dwFlags |= SLDF_HAS_DARWINID;

    EXP_DARWIN_LINK expLink;
    LPEXP_DARWIN_LINK pedl = (LPEXP_DARWIN_LINK)SHFindDataBlock(_pExtraData, EXP_DARWIN_ID_SIG);
    if (!pedl)
    {
        pedl = &expLink;
        expLink.dbh.cbSize = 0;
        expLink.dbh.dwSignature = EXP_DARWIN_ID_SIG;
    }

    SHTCharToAnsi(szDarwinID, pedl->szDarwinID, ARRAYSIZE(pedl->szDarwinID));
    SHTCharToUnicode(szDarwinID, pedl->szwDarwinID, ARRAYSIZE(pedl->szwDarwinID));

    // See if this is a new entry that we need to add
    if (pedl->dbh.cbSize == 0)
    {
        pedl->dbh.cbSize = sizeof(*pedl);
        _AddExtraDataSection((DATABLOCK_HEADER *)pedl);
    }

    // For darwin links, we ignore the path and pidl for now. We would
    // normally call _SetPIDLPath and SetIDList but we skip these
    // steps for darwin links because all _SetPIDLPath does is set the pidl
    // and all SetIDList does is set fd (the WIN32_FIND_DATA)
    // for the target, and we dont have a target since we are a darwin link.
    return S_OK;
}

// IShellLink::SetPath()

STDMETHODIMP CShellLink::SetPath(LPCWSTR pszPathW)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    LPCTSTR pszPath;

    // NOTE: all the other Set* functions allow NULL pointer to be passed in, but this
    // one does not because it would AV. 
    if (!pszPathW)
    {
        return E_INVALIDARG;
    }
    else if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {
        return S_FALSE; // a darwin link already, then we dont allow the path to change
    }

    SHUnicodeToTChar(pszPathW, szPath, ARRAYSIZE(szPath));

    pszPath = szPath;

    int iLength = _IsOldDarwin(pszPath);
    if (iLength)
    {
        hr = _SetPathOldDarwin(pszPath);
    }
    else
    {
        // Check for ::<guid>:<data>: prefix, which signals us to bless the
        // the lnk with extra data. NOTE: we pass the &pszPath here so that this fn can 
        // advance the string pointer past the ::<guid>:<data>: sections and point to 
        // the path, if there is one.
        hr = _CheckForLinkBlessing(&pszPath);
        if (S_OK != hr)
        {
            // Check to see if the target has any expandable environment strings
            // in it.  If so, set the appropriate information in the CShellLink
            // data.
            TCHAR szExpPath[MAX_PATH];
            SHExpandEnvironmentStrings(pszPath, szExpPath, ARRAYSIZE(szExpPath));

            if (lstrcmp(szExpPath, pszPath)) 
            {
                _sld.dwFlags |= SLDF_HAS_EXP_SZ;    // link has expandable strings

                EXP_SZ_LINK expLink;
                LPEXP_SZ_LINK pel = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_LINK_SIG);
                if (!pel) 
                {
                    pel = &expLink;
                    expLink.cbSize = 0;
                    expLink.dwSignature = EXP_SZ_LINK_SIG;
                }

                // store both A and W version (for no good reason!)
                SHTCharToAnsi(pszPath, pel->szTarget, ARRAYSIZE(pel->szTarget));
                SHTCharToUnicode(pszPath, pel->swzTarget, ARRAYSIZE(pel->swzTarget));

                // See if this is a new entry that we need to add
                if (pel->cbSize == 0)
                {
                    pel->cbSize = sizeof(*pel);
                    _AddExtraDataSection((DATABLOCK_HEADER *)pel);
                }
                hr = _SetPIDLPath(NULL, szExpPath, TRUE);
            }
            else 
            {
                _sld.dwFlags &= ~SLDF_HAS_EXP_SZ;
                _RemoveExtraDataSection(EXP_SZ_LINK_SIG);

                hr = _SetPIDLPath(NULL, pszPath, TRUE);
            }

            if (FAILED(hr))
            {
                PathResolve(szExpPath, NULL, PRF_TRYPROGRAMEXTENSIONS);
                hr = _SetSimplePIDL(szExpPath);
            }
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ShellLink;
    return S_OK;
}

STDMETHODIMP CShellLink::IsDirty()
{
    return _bDirty ? S_OK : S_FALSE;
}

HRESULT LinkInfo_LoadFromStream(IStream *pstm, PLINKINFO *ppli, DWORD cbMax)
{
    DWORD dwSize;
    ULONG cbBytesRead;

    if (*ppli)
    {
        LocalFree((HLOCAL)*ppli);
        *ppli = NULL;
    }

    HRESULT hr = pstm->Read(&dwSize, sizeof(dwSize), &cbBytesRead);     // size of data
    if (SUCCEEDED(hr) && (cbBytesRead == sizeof(dwSize)))
    {
        if (dwSize <= cbMax)
        {
            if (dwSize >= sizeof(dwSize))   // must be at least this big
            {
                /* Yes.  Read remainder of LinkInfo into local memory. */
                PLINKINFO pli = (PLINKINFO)LocalAlloc(LPTR, dwSize);
                if (pli)
                {
                    *(DWORD *)pli = dwSize;         // Copy size

                    dwSize -= sizeof(dwSize);       // Read remainder of LinkInfo

                    hr = pstm->Read(((DWORD *)pli) + 1, dwSize, &cbBytesRead);
                    // Note that if the linkinfo is invalid, we still return S_OK
                    // because linkinfo is not essential to the shortcut
                    if (SUCCEEDED(hr) && (cbBytesRead == dwSize) && IsValidLinkInfo(pli))
                       *ppli = pli; // LinkInfo read successfully
                    else
                       LocalFree((HLOCAL)pli);
                }
            }
        }
        else
        {
            // This will happen if the .lnk is corrupted and the size in the stream
            // is larger than the physical file on disk.
            hr = E_FAIL;
        }
    }
    return hr;
}

// Decodes the CSIDL_ relative target pidl

void CShellLink::_DecodeSpecialFolder()
{
    LPEXP_SPECIAL_FOLDER pData = (LPEXP_SPECIAL_FOLDER)SHFindDataBlock(_pExtraData, EXP_SPECIAL_FOLDER_SIG);
    if (pData)
    {
        LPITEMIDLIST pidlFolder = SHCloneSpecialIDList(NULL, pData->idSpecialFolder, FALSE);
        if (pidlFolder)
        {
            ASSERT(IS_VALID_PIDL(_pidl));

            LPITEMIDLIST pidlTarget = _ILSkip(_pidl, pData->cbOffset);
            LPITEMIDLIST pidlSanityCheck = _pidl;

            while (!ILIsEmpty(pidlSanityCheck) && (pidlSanityCheck < pidlTarget))
            {
                // We go one step at a time until pidlSanityCheck == pidlTarget.  If we reach the end
                // of pidlSanityCheck, or if we go past pidlTarget, before this condition is met then
                // we have an invalid pData->cbOffset.
                pidlSanityCheck = _ILNext(pidlSanityCheck);
            }

            if (pidlSanityCheck == pidlTarget)
            {
                LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlTarget);
                if (pidlNew)
                {
                    _SetPIDLPath(pidlNew, NULL, FALSE);
                    ILFree(pidlNew);
                }
            }
            ILFree(pidlFolder);
        }

        // in case above stuff fails for some reason
        _RemoveExtraDataSection(EXP_SPECIAL_FOLDER_SIG);
    }
}


HRESULT CShellLink::_UpdateIconFromExpIconSz()
{
    HRESULT hr = S_FALSE;
    
    // only try once per link instance
    if (!_bExpandedIcon)
    {
        TCHAR szExpIconPath[MAX_PATH];

        if (_sld.dwFlags & SLDF_HAS_EXP_ICON_SZ)
        {
            LPEXP_SZ_LINK pszl = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_ICON_SIG);
            if (pszl)
            {
                if (SHExpandEnvironmentStringsW(pszl->swzTarget, szExpIconPath, ARRAYSIZE(szExpIconPath)) &&
                    PathFileExists(szExpIconPath))
                {
                    hr = S_OK;
                }
            }
            else
            {
                ASSERTMSG(FALSE, "CShellLink::_UpdateIconAtLoad - lnk has SLDF_HAS_EXP_ICON_SZ but no actual datablock!!");
                hr = E_FAIL;
            }
        }

        if (hr == S_OK)
        {
            // update _pszIconLocation if its different from the expanded string
            if (lstrcmpi(_pszIconLocation, szExpIconPath) != 0)
            {
                _SetField(&_pszIconLocation, szExpIconPath);
                _bDirty = TRUE;
            }
        }

        _bExpandedIcon = TRUE;
    }

    return hr;
}

STDMETHODIMP CShellLink::Load(IStream *pstm)
{
    ULONG cbBytes;
    DWORD cbSize;

    TraceMsg(TF_DEBUGLINKCODE, "Loading link from stream.");

    _ResetPersistData();        // clear out our state

    HRESULT hr = pstm->Read(&cbSize, sizeof(cbSize), &cbBytes);
    if (SUCCEEDED(hr))
    {
        if (cbBytes == sizeof(cbSize))
        {
            if (cbSize == sizeof(_sld))
            {
                hr = pstm->Read((LPBYTE)&_sld + sizeof(cbSize), sizeof(_sld) - sizeof(cbSize), &cbBytes);
                if (SUCCEEDED(hr) && cbBytes == (sizeof(_sld) - sizeof(cbSize)) && IsEqualGUID(_sld.clsid, CLSID_ShellLink))
                {
                    _sld.cbSize = sizeof(_sld);

                    switch (_sld.iShowCmd) 
                    {
                        case SW_SHOWNORMAL:
                        case SW_SHOWMINNOACTIVE:
                        case SW_SHOWMAXIMIZED:
                        break;

                        default:
                            DebugMsg(DM_TRACE, TEXT("Shortcut Load, mapping bogus ShowCmd: %d"), _sld.iShowCmd);
                            _sld.iShowCmd = SW_SHOWNORMAL;
                        break;
                    }

                    // save so we can generate notify on save
                    _wOldHotkey = _sld.wHotkey;   

                    // read all of the members

                    if (_sld.dwFlags & SLDF_HAS_ID_LIST)
                    {
                        hr = ILLoadFromStream(pstm, &_pidl);
                        if (SUCCEEDED(hr))
                        {
                            // Check for a valid pidl.  File corruption can cause pidls to become bad which will cause
                            // explorer to AV unless we catch it here.  Also, people have been known to write invalid
                            // pidls into link files from time to time.
                            if (!SHIsValidPidl(_pidl))
                            {
                                // In theory this will only happen due to file corruption, but I've seen this too
                                // often not to suspect that we might be doing something wrong.
                                // turn off the flag, which we know is on to start with

                                _sld.dwFlags &= ~SLDF_HAS_ID_LIST;
                                Pidl_Set(&_pidl, NULL);
                                _bDirty = TRUE;

                                // continue as though there was no SLDF_HAS_ID_LIST flag to start with
                                // REVIEW: should we only continue if certain other sections are also included
                                // in the link?  What will happen if SLDF_HAS_ID_LIST was the only data set for
                                // this link file?  We would get a null link. 
                            }
                        }
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_LINK_INFO))
                    {
                        DWORD cbMaxRead;
                        // We need to worry about link files that are corrupt.  So read the link
                        // size so we don't keep reading for ever in case the stream has an invalid
                        // size in it.
                        // We need to check if it is a valid pidl because hackers will
                        // try to create invalid pidls to crash the system or run buffer
                        // over run attacks.  -BryanSt 

                        STATSTG stat;
                        if (SUCCEEDED(pstm->Stat(&stat, STATFLAG_NONAME)))
                            cbMaxRead = stat.cbSize.LowPart;
                        else
                            cbMaxRead = 0xFFFFFFFF;

                        hr = LinkInfo_LoadFromStream(pstm, &_pli, cbMaxRead);
                        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_FORCE_NO_LINKINFO))
                        {
                            _FreeLinkInfo();    // labotimizing link
                        }
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_NAME))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Name...");
                        hr = Str_SetFromStream(pstm, &_pszName, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_RELPATH))
                    {
                        hr = Str_SetFromStream(pstm, &_pszRelPath, _sld.dwFlags & SLDF_UNICODE);
                        if (!_pidl && SUCCEEDED(hr))
                        {
                            TCHAR szTmp[MAX_PATH];
                            if (_GetRelativePath(szTmp))
                                _SetPIDLPath(NULL, szTmp, TRUE);
                        }
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_WORKINGDIR))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Working Dir...");
                        hr = Str_SetFromStream(pstm, &_pszWorkingDir, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ARGS))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Arguments...");
                        hr = Str_SetFromStream(pstm, &_pszArgs, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ICONLOCATION))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Icon Location...");
                        hr = Str_SetFromStream(pstm, &_pszIconLocation, _sld.dwFlags & SLDF_UNICODE);
                    }

                    if (SUCCEEDED(hr))
                    {
                        TraceMsg(TF_DEBUGLINKCODE, "  CShellLink: Loading Data Block...");
                        hr = SHReadDataBlockList(pstm, &_pExtraData);
                    }

                    // reset the darwin info on load
                    if (_sld.dwFlags & SLDF_HAS_DARWINID)
                    {
                        // since darwin links rely so heavily on the icon, do this now
                        _UpdateIconFromExpIconSz();

                        // we should never have a darwin link that is missing
                        // the icon path
                        if (_pszIconLocation)
                        {
                            // we always put back the icon path as the pidl at
                            // load time since darwin could change the path or
                            // to the app (eg: new version of the app)
                            TCHAR szPath[MAX_PATH];
                            
                            // expand any env. strings in the icon path before
                            // creating the pidl.
                            SHExpandEnvironmentStrings(_pszIconLocation, szPath, ARRAYSIZE(szPath));
                            _SetPIDLPath(NULL, szPath, FALSE);
                        }
                    }
                    else
                    {
                        // The Darwin stuff above creates a new pidl, which
                        // would cause this stuff to blow up. We should never
                        // get both at once, but let's be extra robust...
                        //
                        // Since we store the offset into the pidl here, and
                        // the pidl can change for various reasons, we can
                        // only do this once at load time. Do it here.
                        //
                        if (_pidl)
                        {
                            _DecodeSpecialFolder();
                        }
                    }

                    if (SUCCEEDED(hr) && _ptracker)
                    {
                        // load the tracker from extra data
                        EXP_TRACKER *pData = (LPEXP_TRACKER)SHFindDataBlock(_pExtraData, EXP_TRACKER_SIG);
                        if (pData) 
                        {
                            hr = _ptracker->Load(pData->abTracker, pData->cbSize - sizeof(EXP_TRACKER));
                            if (FAILED(hr))
                            {
                                // Failure of the Tracker isn't just cause to make
                                // the shortcut unusable.  So just re-init it and move on.
                                _ptracker->InitNew();
                                hr = S_OK;
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                        _bDirty = FALSE;
                }
                else
                {
                    DebugMsg(DM_TRACE, TEXT("failed to read link struct"));
                    hr = E_FAIL;      // invalid file size
                }
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("invalid length field in link:%d"), cbBytes);
                hr = E_FAIL;  // invalid file size
            }
        }
        else if (cbBytes == 0)
        {
            _sld.cbSize = 0;   // zero length file is ok
        }
        else
        {
            hr = E_FAIL;      // invalid file size
        }
    }
    return hr;
}

// set the relative path
// in:
//      pszRelSource    fully qualified path to a file (must be file, not directory)
//                      to be used to find a relative path with the link target.
//
// returns:
//      S_OK            relative path is set
//      S_FALSE         pszPathRel is not relative to the destination or the
//                      destionation is not a file (could be link to a pidl only)
// notes:
//      set the dirty bit if this is a new relative path
//

HRESULT CShellLink::_SetRelativePath(LPCTSTR pszRelSource)
{
    TCHAR szPath[MAX_PATH], szDest[MAX_PATH];

    ASSERT(!PathIsRelative(pszRelSource));

    if (_pidl == NULL || !SHGetPathFromIDList(_pidl, szDest))
    {
        DebugMsg(DM_TRACE, TEXT("SetRelative called on non path link"));
        return S_FALSE;
    }

    // assume pszRelSource is a file, not a directory
    if (PathRelativePathTo(szPath, pszRelSource, 0, szDest, _sld.dwFileAttributes))
    {
        pszRelSource = szPath;
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("paths are not relative"));
        pszRelSource = NULL;    // clear the stored relative path below
    }

    _SetField(&_pszRelPath, pszRelSource);

    return S_OK;
}

BOOL CShellLink::_EncodeSpecialFolder()
{
    BOOL bRet = FALSE;

    if (_pidl)
    {
        // make sure we don't already have a EXP_SPECIAL_FOLDER_SIG data block, otherwise we would
        // end up with two of these and the first one would win on read.
        // If you hit this ASSERT in a debugger, contact ToddB with a remote.  We need to figure out
        // why we are corrupting our shortcuts.
        ASSERT(NULL == SHFindDataBlock(_pExtraData, EXP_SPECIAL_FOLDER_SIG));

        EXP_SPECIAL_FOLDER exp;
        exp.idSpecialFolder = GetSpecialFolderParentIDAndOffset(_pidl, &exp.cbOffset);
        if (exp.idSpecialFolder)
        {
            exp.cbSize = sizeof(exp);
            exp.dwSignature = EXP_SPECIAL_FOLDER_SIG;

            _AddExtraDataSection((DATABLOCK_HEADER *)&exp);
            bRet = TRUE;
        }
    }

    return bRet;
}

HRESULT LinkInfo_SaveToStream(IStream *pstm, PCLINKINFO pcli)
{
    ULONG cbBytes;
    DWORD dwSize = *(DWORD *)pcli;    // Get LinkInfo size

    HRESULT hr = pstm->Write(pcli, dwSize, &cbBytes);
    if (SUCCEEDED(hr) && (cbBytes != dwSize))
        hr = E_FAIL;
    return hr;
}


//
// Replaces the tracker extra data with current tracker state
//
HRESULT CShellLink::_UpdateTracker()
{
    ULONG ulSize = _ptracker->GetSize();

    if (!_ptracker->IsLoaded())
    {
        _RemoveExtraDataSection(EXP_TRACKER_SIG);
        return S_OK;
    }

    if (!_ptracker->IsDirty())
    {
        return S_OK;
    }

    HRESULT hr = E_FAIL;
    // Make sure the Tracker size is a multiple of DWORDs.
    // If we hit this assert then we would have mis-aligned stuff stored in the extra data.
    //
    if (EVAL(0 == (ulSize & 3)))
    {
        EXP_TRACKER *pExpTracker = (EXP_TRACKER *)LocalAlloc(LPTR, ulSize + sizeof(DATABLOCK_HEADER));
        if (pExpTracker)
        {
            _RemoveExtraDataSection(EXP_TRACKER_SIG);
        
            pExpTracker->cbSize = ulSize + sizeof(DATABLOCK_HEADER);
            pExpTracker->dwSignature = EXP_TRACKER_SIG;
            _ptracker->Save(pExpTracker->abTracker, ulSize);
        
            _AddExtraDataSection((DATABLOCK_HEADER *)&pExpTracker->cbSize);
            DebugMsg(DM_TRACE, TEXT("_UpdateTracker: EXP_TRACKER at %08X."), &pExpTracker->cbSize);

            LocalFree(pExpTracker);
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CShellLink::Save(IStream *pstm, BOOL fClearDirty)
{
    ULONG cbBytes;
    BOOL fEncode;

    _sld.cbSize = sizeof(_sld);
    _sld.clsid = CLSID_ShellLink;
    //  _sld.dwFlags = 0;
    // We do the following & instead of zeroing because the SLDF_HAS_EXP_SZ and
    // SLDF_RUN_IN_SEPARATE and SLDF_RUNAS_USER and SLDF_HAS_DARWINID are passed to us and are valid,
    // the others can be reconstructed below, but these three can not, so we need to
    // preserve them!

    _sld.dwFlags &= (SLDF_HAS_EXP_SZ        | 
                     SLDF_HAS_EXP_ICON_SZ   |
                     SLDF_RUN_IN_SEPARATE   |
                     SLDF_HAS_DARWINID      |
                     SLDF_HAS_LOGO3ID       |
                     SLDF_RUNAS_USER        |
                     SLDF_RUN_WITH_SHIMLAYER);

    if (_pszRelSource)
    {
        _SetRelativePath(_pszRelSource);
    }

    _sld.dwFlags |= SLDF_UNICODE;

    fEncode = FALSE;
    
    if (_pidl)
    {
        _sld.dwFlags |= SLDF_HAS_ID_LIST;

        // we dont want to have special folder tracking for darwin links
        if (!(_sld.dwFlags & SLDF_HAS_DARWINID))
            fEncode = _EncodeSpecialFolder();
    }

    if (_pli)
        _sld.dwFlags |= SLDF_HAS_LINK_INFO;

    if (_pszName && _pszName[0])
        _sld.dwFlags |= SLDF_HAS_NAME;
    if (_pszRelPath && _pszRelPath[0])
        _sld.dwFlags |= SLDF_HAS_RELPATH;
    if (_pszWorkingDir && _pszWorkingDir[0])
        _sld.dwFlags |= SLDF_HAS_WORKINGDIR;
    if (_pszArgs && _pszArgs[0])
        _sld.dwFlags |= SLDF_HAS_ARGS;
    if (_pszIconLocation && _pszIconLocation[0])
        _sld.dwFlags |= SLDF_HAS_ICONLOCATION;

    HRESULT hr = pstm->Write(&_sld, sizeof(_sld), &cbBytes);

    if (SUCCEEDED(hr) && (cbBytes == sizeof(_sld)))
    {
        if (_pidl)
            hr = ILSaveToStream(pstm, _pidl);

        if (SUCCEEDED(hr) && _pli)
            hr = LinkInfo_SaveToStream(pstm, _pli);

        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_NAME))
            hr = Stream_WriteString(pstm, _pszName, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_RELPATH))
            hr = Stream_WriteString(pstm, _pszRelPath, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_WORKINGDIR))
            hr = Stream_WriteString(pstm, _pszWorkingDir, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ARGS))
            hr = Stream_WriteString(pstm, _pszArgs, _sld.dwFlags & SLDF_UNICODE);
        if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_HAS_ICONLOCATION))
            hr = Stream_WriteString(pstm, _pszIconLocation, _sld.dwFlags & SLDF_UNICODE);

        if (SUCCEEDED(hr) && _ptracker && _ptracker->WasLoadedAtLeastOnce())
            hr = _UpdateTracker();

        if (SUCCEEDED(hr))
        {
            hr = SHWriteDataBlockList(pstm, _pExtraData);
        }

        if (SUCCEEDED(hr) && fClearDirty)
            _bDirty = FALSE;
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("Failed to write link"));
        hr = E_FAIL;
    }

    if (fEncode)
    {
        _RemoveExtraDataSection(EXP_SPECIAL_FOLDER_SIG);
    }

    return hr;
}

STDMETHODIMP  CShellLink::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    pcbSize->LowPart = 16 * 1024;       // 16k?  who knows...
    pcbSize->HighPart = 0;
    return S_OK;
}

BOOL PathIsPif(LPCTSTR pszPath)
{
    return lstrcmpi(PathFindExtension(pszPath), TEXT(".pif")) == 0;
}

HRESULT CShellLink::_LoadFromPIF(LPCTSTR pszPath)
{
    HANDLE hPif = PifMgr_OpenProperties(pszPath, NULL, 0, 0);
    if (hPif == 0)
        return E_FAIL;

    PROPPRG ProgramProps = {0};

    if (!PifMgr_GetProperties(hPif, (LPSTR)MAKEINTATOM(GROUP_PRG), &ProgramProps, sizeof(ProgramProps), 0))
    {
        return E_FAIL;
    }

    SetDescription(ProgramProps.achTitle);
    SetWorkingDirectory(ProgramProps.achWorkDir);
    SetArguments(PathGetArgsA(ProgramProps.achCmdLine));
    SetHotkey(ProgramProps.wHotKey);
    SetIconLocation(ProgramProps.achIconFile, ProgramProps.wIconIndex);

    TCHAR szTemp[MAX_PATH];
    SHAnsiToTChar(ProgramProps.achCmdLine, szTemp, ARRAYSIZE(szTemp));

    PathRemoveArgs(szTemp);

    // If this is a network path, we want to create a simple pidl
    // instead of a full pidl to circumvent net hits
    if (PathIsUNC(szTemp) || IsRemoteDrive(DRIVEID(szTemp)))
    {
        _SetSimplePIDL(szTemp);
    }
    else
    {
        _SetPIDLPath(NULL, szTemp, FALSE);
    }

    if (ProgramProps.flPrgInit & PRGINIT_MINIMIZED)
    {
        SetShowCmd(SW_SHOWMINNOACTIVE);
    }
    else if (ProgramProps.flPrgInit & PRGINIT_MAXIMIZED)
    {
        SetShowCmd(SW_SHOWMAXIMIZED);
    }
    else
    {
        SetShowCmd(SW_SHOWNORMAL);
    }

    PifMgr_CloseProperties(hPif, 0);

    _bDirty = FALSE;

    return S_OK;
}


HRESULT CShellLink::_LoadFromFile(LPCTSTR pszPath)
{
    HRESULT hr;

    if (PathIsPif(pszPath))
    {
        hr = _LoadFromPIF(pszPath);
    }
    else
    {
        IStream *pstm;
        hr = SHCreateStreamOnFile(pszPath, STGM_READ | STGM_SHARE_DENY_WRITE, &pstm);
        if (SUCCEEDED(hr))
        {
            hr = Load(pstm);
            pstm->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];

        if (_pidl && SHGetPathFromIDList(_pidl, szPath) && !lstrcmpi(szPath, pszPath))
        {
            DebugMsg(DM_TRACE, TEXT("Link points to itself, aaahhh!"));
            hr = E_FAIL;
        }
        else
        {
            Str_SetPtr(&_pszCurFile, pszPath);
        }
    }
    else if (IsFolderShortcut(pszPath))
    {
        // this support here is a hack to make Office file open work. that code
        // depends on loading folder shortcuts using CLSID_ShellLink. this is because
        // we lie about the attributes of folder shortcuts to office to make other
        // stuff work.

        TCHAR szPath[MAX_PATH];
        PathCombine(szPath, pszPath, TEXT("target.lnk"));

        IStream *pstm;
        hr = SHCreateStreamOnFile(szPath, STGM_READ | STGM_SHARE_DENY_WRITE, &pstm);
        if (SUCCEEDED(hr))
        {
            hr = Load(pstm);
            pstm->Release();
        }
    }

    ASSERT(!_bDirty);

    return hr;
}

STDMETHODIMP CShellLink::Load(LPCOLESTR pwszFile, DWORD grfMode)
{
    HRESULT hr = E_INVALIDARG;
    
    TraceMsg(TF_DEBUGLINKCODE, "Loading link from file %ls.", pwszFile);

    if (pwszFile) 
    {
        hr = _LoadFromFile(pwszFile);

        // convert the succeeded code to S_OK so that THOSE DUMB apps like HitNrun 
        // who do hr == 0 don't fail miserably.

        if (SUCCEEDED(hr))
            hr = S_OK;
    }
    
    return hr;
}

HRESULT CShellLink::_SaveAsLink(LPCTSTR pszPath)
{
    TraceMsg(TF_DEBUGLINKCODE, "Save link to file %s.", pszPath);

    IStream *pstm;
    HRESULT hr = SHCreateStreamOnFile(pszPath, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstm);
    if (SUCCEEDED(hr))
    {
        if (_pszRelSource == NULL)
            _SetRelativePath(pszPath);

        hr = Save(pstm, TRUE);

        if (SUCCEEDED(hr))
        {
            hr = pstm->Commit(0);
        }

        pstm->Release();

        if (FAILED(hr))
        {
            DeleteFile(pszPath);
        }
    }

    return hr;
}

BOOL RenameChangeExtension(LPTSTR pszPathSave, LPCTSTR pszExt, BOOL fMove)
{
    TCHAR szPathSrc[MAX_PATH];

    lstrcpy(szPathSrc, pszPathSave);
    PathRenameExtension(pszPathSave, pszExt);

    // this may fail because the source file does not exist, but we dont care
    if (fMove && lstrcmpi(szPathSrc, pszPathSave) != 0)
    {
        DWORD dwAttrib;

        PathYetAnotherMakeUniqueName(pszPathSave, pszPathSave, NULL, NULL);
        dwAttrib = GetFileAttributes(szPathSrc);
        if ((dwAttrib == 0xFFFFFFFF) || (dwAttrib & FILE_ATTRIBUTE_READONLY))
        {
            // Source file is read only, don't want to change the extension
            // because we won't be able to write any changes to the file...
            return FALSE;
        }
        Win32MoveFile(szPathSrc, pszPathSave, FALSE);
    }

    return TRUE;
}


// out:
//      pszDir  MAX_PATH path to get directory, maybe with env expanded
//
// returns:
//      TRUE    has a working directory, pszDir filled in.
//      FALSE   no working dir, if the env expands to larger than the buffer size (MAX_PATH)
//              this will be returned (FALSE)
//

BOOL CShellLink::_GetWorkingDir(LPTSTR pszDir)
{
    *pszDir = 0;

    if (_pszWorkingDir && _pszWorkingDir[0])
    {
        return (SHExpandEnvironmentStrings(_pszWorkingDir, pszDir, MAX_PATH) != 0);
    }

    return FALSE;
}

HRESULT CShellLink::_SaveAsPIF(LPCTSTR pszPath, BOOL fPath)
{
    HANDLE hPif;
    PROPPRG ProgramProps;
    HRESULT hr;
    TCHAR szDir[MAX_PATH];
    TCHAR achPath[MAX_PATH];

    //
    // get filename and convert it to a short filename
    //
    if (fPath)
    {
        hr = GetPath(achPath, ARRAYSIZE(achPath), NULL, 0);
        PathGetShortPath(achPath);
        
        ASSERT(!PathIsPif(achPath));
        ASSERT(LOWORD(GetExeType(achPath)) == 0x5A4D);
        ASSERT(PathIsPif(pszPath));
        ASSERT(hr == S_OK);
    }
    else
    {
        lstrcpy(achPath, pszPath);
    }

    DebugMsg(DM_TRACE, TEXT("_SaveAsPIF(%s,%s)"), achPath, pszPath);

#if 0
    //
    // we should use OPENPROPS_INHIBITPIF to prevent PIFMGR from making a
    // temp .pif file in \windows\pif but it does not work now.
    //
    hPif = PifMgr_OpenProperties(achPath, pszPath, 0, OPENPROPS_INHIBITPIF);
#else
    hPif = PifMgr_OpenProperties(achPath, pszPath, 0, 0);
#endif

    if (hPif == 0)
    {
        return E_FAIL;
    }

    if (!PifMgr_GetProperties(hPif,(LPSTR)MAKEINTATOM(GROUP_PRG), &ProgramProps, sizeof(ProgramProps), 0))
    {
        DebugMsg(DM_TRACE, TEXT("_SaveToPIF: PifMgr_GetProperties *failed*"));
        hr = E_FAIL;
        goto Error1;
    }

    // Set a title based on the link name.
    if (_pszName && _pszName[0])
    {
        SHTCharToAnsi(_pszName, ProgramProps.achTitle, sizeof(ProgramProps.achTitle));
    }

    // if no work dir. is given default to the dir of the app.
    if (_GetWorkingDir(szDir))
    {

        TCHAR szTemp[PIFDEFPATHSIZE];

        GetShortPathName(szDir, szTemp, ARRAYSIZE(szTemp));
        SHTCharToAnsi(szTemp, ProgramProps.achWorkDir, ARRAYSIZE(ProgramProps.achWorkDir));
    }
    else if (fPath && !PathIsUNC(achPath))
    {
        TCHAR szTemp[PIFDEFPATHSIZE];
        lstrcpyn(szTemp, achPath, ARRAYSIZE(szTemp));
        PathRemoveFileSpec(szTemp);
        SHTCharToAnsi(szTemp, ProgramProps.achWorkDir, ARRAYSIZE(ProgramProps.achWorkDir));
    }

    // And for those network share points we need to quote blanks...
    PathQuoteSpaces(achPath);

    // add the args to build the full command line
    if (_pszArgs && _pszArgs[0])
    {
        lstrcat(achPath, c_szSpace);
        lstrcat(achPath, _pszArgs);
    }

    if (fPath)
    {
        SHTCharToAnsi(achPath, ProgramProps.achCmdLine, ARRAYSIZE(ProgramProps.achCmdLine));
    }

    if (_sld.iShowCmd == SW_SHOWMAXIMIZED)
    {
        ProgramProps.flPrgInit |= PRGINIT_MAXIMIZED;
    }
    if ((_sld.iShowCmd == SW_SHOWMINIMIZED) || (_sld.iShowCmd == SW_SHOWMINNOACTIVE))
    {    
        ProgramProps.flPrgInit |= PRGINIT_MINIMIZED;
    }

    if (_sld.wHotkey)
    {
        ProgramProps.wHotKey = _sld.wHotkey;
    }

    if (_pszIconLocation && _pszIconLocation[0])
    {
        SHTCharToAnsi(_pszIconLocation, ProgramProps.achIconFile, ARRAYSIZE(ProgramProps.achIconFile));
        ProgramProps.wIconIndex = (WORD) _sld.iIcon;
    }

    if (!PifMgr_SetProperties(hPif, (LPSTR)MAKEINTATOM(GROUP_PRG), &ProgramProps, sizeof(ProgramProps), 0))
    {
        DebugMsg(DM_TRACE, TEXT("_SaveToPIF: PifMgr_SetProperties *failed*"));
        hr = E_FAIL;
    } 
    else 
    {
        hr = S_OK;
    }

    _bDirty = FALSE;

Error1:
    PifMgr_CloseProperties(hPif, 0);
    return hr;
}

// This will allow global hotkeys to be available immediately instead
// of having to wait for the StartMenu to pick them up.
// Similarly this will remove global hotkeys immediately if req.

const UINT c_rgHotKeyFolders[] = {
    CSIDL_PROGRAMS,
    CSIDL_COMMON_PROGRAMS,
    CSIDL_STARTMENU,
    CSIDL_COMMON_STARTMENU,
    CSIDL_DESKTOPDIRECTORY,
    CSIDL_COMMON_DESKTOPDIRECTORY,
};

void HandleGlobalHotkey(LPCTSTR pszFile, WORD wHotkeyOld, WORD wHotkeyNew)
{
    if (PathIsEqualOrSubFolderOf(pszFile, c_rgHotKeyFolders, ARRAYSIZE(c_rgHotKeyFolders)))
    {
        // Find tray?
        HWND hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), 0);
        if (hwndTray)
        {
            // Yep.
            if (wHotkeyOld)
                SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wHotkeyOld, 0);
            if (wHotkeyNew)
            {
                ATOM atom = GlobalAddAtom(pszFile);
                if (atom)
                {
                    SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wHotkeyNew, (LPARAM)atom);
                    GlobalDeleteAtom(atom);
                }
            }
        }
    }
}

HRESULT CShellLink::_SaveToFile(LPTSTR pszPathSave, BOOL fRemember)
{
    HRESULT hr = E_FAIL;
    BOOL fDosApp;
    BOOL fFile;
    TCHAR szPathSrc[MAX_PATH];
    BOOL fWasSameFile = _pszCurFile && (lstrcmpi(pszPathSave, _pszCurFile) == 0);
    BOOL bFileExisted = PathFileExistsAndAttributes(pszPathSave, NULL);

    // when saving darwin links we dont want to resolve the path
    if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {
        fRemember = FALSE;
        hr = _SaveAsLink(pszPathSave);
        goto Update;
    }

    GetPath(szPathSrc, ARRAYSIZE(szPathSrc), NULL, 0);

    fFile = !(_sld.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
    fDosApp = fFile && LOWORD(GetExeType(szPathSrc)) == 0x5A4D;

    // handle a link to link case. (or link to pif)
    //
    // NOTE: we loose all new attributes, including icon, but it's been this way since Win95.
    if (fFile && (PathIsPif(szPathSrc) || PathIsLnk(szPathSrc)))
    {
        if (RenameChangeExtension(pszPathSave, PathFindExtension(szPathSrc), fWasSameFile))
        {
            if (CopyFile(szPathSrc, pszPathSave, FALSE))
            {
                if (PathIsPif(pszPathSave))
                    hr = _SaveAsPIF(pszPathSave, FALSE);
                else
                    hr = S_OK;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else if (fDosApp)
    {
        //  if the linked to file is a DOS app, we need to write a .PIF file
        if (RenameChangeExtension(pszPathSave, TEXT(".pif"), fWasSameFile))
        {
            hr = _SaveAsPIF(pszPathSave, TRUE);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        //  else write a link file
        if (PathIsPif(pszPathSave))
        {
            if (!RenameChangeExtension(pszPathSave, TEXT(".lnk"), fWasSameFile))
            {
                hr = E_FAIL;
                goto Update;
            }
        }
        hr = _SaveAsLink(pszPathSave);
    }

Update:
    if (SUCCEEDED(hr))
    {
        // Knock out file close
        SHChangeNotify(bFileExisted ? SHCNE_UPDATEITEM : SHCNE_CREATE, SHCNF_PATH, pszPathSave, NULL);
        SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, pszPathSave, NULL);

        if (_wOldHotkey != _sld.wHotkey)
        {
            HandleGlobalHotkey(pszPathSave, _wOldHotkey, _sld.wHotkey);
        }

        if (fRemember)
        {
            Str_SetPtr(&_pszCurFile, pszPathSave);
        }
    }

    return hr;
}

STDMETHODIMP CShellLink::Save(LPCOLESTR pwszFile, BOOL fRemember)
{
    TCHAR szSavePath[MAX_PATH];

    if (pwszFile == NULL)
    {
        if (_pszCurFile == NULL)
        {
            // fail
            return E_FAIL;
        }

        lstrcpy(szSavePath, _pszCurFile);
    }
    else
    {
        SHUnicodeToTChar(pwszFile, szSavePath, ARRAYSIZE(szSavePath));
    }

    return _SaveToFile(szSavePath, fRemember);
}

STDMETHODIMP CShellLink::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

STDMETHODIMP CShellLink::GetCurFile(LPOLESTR *ppszFile)
{
    if (_pszCurFile == NULL)
    {
        *ppszFile = NULL;
        return S_FALSE;
    }
    return SHStrDup(_pszCurFile, ppszFile);
}

STDMETHODIMP CShellLink::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    HRESULT hr;

    ASSERT(_sld.iShowCmd == SW_SHOWNORMAL);

    if (pdtobj)
    {
        STGMEDIUM medium = {0};
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        hr = pdtobj->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath));
            hr = _LoadFromFile(szPath);

            ReleaseStgMedium(&medium);
        }
        else
        {
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                IShellFolder *psf;
                hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, IDA_GetIDListPtr(pida, -1), &psf));
                if (SUCCEEDED(hr))
                {
                    IStream *pstm;
                    hr = psf->BindToStorage(IDA_GetIDListPtr(pida, 0), NULL, IID_PPV_ARG(IStream, &pstm));
                    if (SUCCEEDED(hr))
                    {
                        hr = Load(pstm);
                        pstm->Release();
                    }
                    psf->Release();
                }

                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI CDarwinContextMenuCB::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU:
        // S_FALSE indicates no need to get verbs from extensions.

        hr = S_FALSE;
        break;

    case DFM_MERGECONTEXTMENU_TOP:
    {
        UINT uFlags = (UINT)wParam;
        LPQCMINFO pqcm = (LPQCMINFO)lParam;

        CDefFolderMenu_MergeMenu(HINST_THISDLL,
                                 (uFlags & CMF_EXTENDEDVERBS) ? MENU_GENERIC_CONTROLPANEL_VERBS : MENU_GENERIC_OPEN_VERBS,  // if extended verbs then add "Run as..."
                                 0,
                                 pqcm);

        SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);
        break;
    }

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    // NTRAID94991-2000/03/16-MikeSh- DFM_MAPCOMMANDNAME DFM_GETVERB[A|W] not implemented

    case DFM_INVOKECOMMANDEX:
        switch (wParam)
        {
        case FSIDM_OPENPRN:
        case FSIDM_RUNAS:
            hr = PidlFromDataObject(pdtobj, &pidl);
            if (SUCCEEDED(hr))
            {
                CMINVOKECOMMANDINFOEX iciex;
                SHELLEXECUTEINFO sei;
                DFMICS* pdfmics = (DFMICS *)lParam;
                LPVOID pvFree;

                ICI2ICIX(pdfmics->pici, &iciex, &pvFree);
                ICIX2SEI(&iciex, &sei);
                sei.fMask |= SEE_MASK_IDLIST;
                sei.lpIDList = pidl;

                if (wParam == FSIDM_RUNAS)
                {
                    // we only set the verb in the "Run As..." case since we want
                    // the "open" verb for darwin links to really execute the default action.
                    sei.lpVerb = TEXT("runas");
                }

                if (ShellExecuteEx(&sei))
                {
                    // Tell UEM that we ran a Darwin app
                    if (_szProductCode[0])
                    {
                        UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)_szProductCode);
                    }
                }
                
                ILFree(pidl);
                if (pvFree)
                {
                    LocalFree(pvFree);
                }
            }
            // Never return E_NOTIMPL or defcm will try to do a default thing
            if (hr == E_NOTIMPL)
                hr = E_FAIL;
            break;


        default:
            // This is common menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break; // DFM_INVOKECOMMANDEX

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

//
// CShellLink::CreateDarwinContextMenuForPidl (non-virtual)
//
// Worker function for CShellLink::CreateDarwinContextMenu that tries
// to create the context menu for the specified pidl.

HRESULT CShellLink::_CreateDarwinContextMenuForPidl(HWND hwnd, LPCITEMIDLIST pidlTarget, IContextMenu **pcmOut)
{
    LPITEMIDLIST pidlFolder, pidlItem;

    HRESULT hr = SHILClone(pidlTarget, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        if (ILRemoveLastID(pidlFolder) &&
            (pidlItem = ILFindLastID(pidlTarget)))
        {
            IShellFolder *psf;
            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));
            if (SUCCEEDED(hr))
            {
                if (!_pcbDarwin)
                {
                    _pcbDarwin = new CDarwinContextMenuCB();
                }
                if (_pcbDarwin)
                {
                    HKEY ahkeys[1] = { NULL };
                    RegOpenKey(HKEY_CLASSES_ROOT, TEXT("MSILink"), &ahkeys[0]);
                    hr = CDefFolderMenu_Create2Ex(
                                pidlFolder,
                                hwnd,
                                1, (LPCITEMIDLIST *)&pidlItem, psf, _pcbDarwin,
                                ARRAYSIZE(ahkeys), ahkeys, pcmOut);

                    SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                psf->Release();
            }
        }
        else
        {
            // Darwin shortcut to the desktop?  I don't think so.
            hr = E_FAIL;
        }
        ILFree(pidlFolder);
    }
    return hr;
}

//
// CShellLink::CreateDarwinContextMenu (non-virtual)
//
// Creates a context menu for a Darwin shortcut.  This is special because
// the ostensible target is an .EXE file, but in reality it could be
// anything.  (It's just an .EXE file until the shortcut gets resolved.)
// Consequently, we can't create a real context menu for the item because
// we don't know what kind of context menu to create.  We just cook up
// a generic-looking one.
//
// Bonus annoyance: _pidl might be invalid, so you need to have
// a fallback plan if it's not there.  We will use c_idlDrives as our
// fallback.  That's a pidl guaranteed actually to exist.
//
// Note that this means you can't invoke a command on the fallback object,
// but that's okay because ShellLink will always resolve the object to
// a real file and create a new context menu before invoking.
//

HRESULT CShellLink::_CreateDarwinContextMenu(HWND hwnd, IContextMenu **pcmOut)
{
    HRESULT hr;

    *pcmOut = NULL;

    if (_pidl == NULL ||
        FAILED(hr = _CreateDarwinContextMenuForPidl(hwnd, _pidl, pcmOut)))
    {
        // The link target is busted for some reason - use the fallback pidl
        hr = _CreateDarwinContextMenuForPidl(hwnd, (LPCITEMIDLIST)&c_idlDrives, pcmOut);
    }

    return hr;
}

BOOL CShellLink::_GetExpandedPath(LPTSTR psz, DWORD cch)
{
    if (_sld.dwFlags & SLDF_HAS_EXP_SZ)
    {
        LPEXP_SZ_LINK pesl = (LPEXP_SZ_LINK)SHFindDataBlock(_pExtraData, EXP_SZ_LINK_SIG);
        if (pesl) 
        {
            TCHAR sz[MAX_PATH];
            sz[0] = 0;
        
            // prefer the UNICODE version...
            if (pesl->swzTarget[0])
                SHUnicodeToTChar(pesl->swzTarget, sz, SIZECHARS(sz));

            if (!sz[0] && pesl->szTarget[0])
                SHAnsiToTChar(pesl->szTarget, sz, SIZECHARS(sz));

            if (sz[0])
            {
                return SHExpandEnvironmentStrings(sz, psz, cch);
            }
        }
        else
        {
            _sld.dwFlags &= ~SLDF_HAS_EXP_SZ;
        }
    }

    return FALSE;
}

#define DEFAULT_TIMEOUT      7500   // 7 1/2 seconds...

DWORD g_dwNetLinkTimeout = (DWORD)-1;

DWORD _GetNetLinkTimeout()
{
    if (g_dwNetLinkTimeout == -1)
    {
        DWORD cb = sizeof(g_dwNetLinkTimeout);
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("NetLinkTimeout"), NULL, &g_dwNetLinkTimeout, &cb)))
            g_dwNetLinkTimeout = DEFAULT_TIMEOUT;
    }
    return g_dwNetLinkTimeout;
}

DWORD CShellLink::_VerifyPathThreadProc(void *pv)
{
    LPTSTR psz = (LPTSTR)pv;
    
    PathStripToRoot(psz);
    BOOL bFoundRoot = PathFileExistsAndAttributes(psz, NULL);   // does WNet stuff for us
    
    LocalFree(psz);     // this thread owns this buffer
    return bFoundRoot;  // retrieved via GetExitCodeThread()
}

// since net timeouts can be very long this is a manual way to timeout
// an operation explictly rather than waiting for the net layers to do their
// long timeouts

HRESULT CShellLink::_ShortNetTimeout()
{
    HRESULT hr = S_OK;      // assume good
    
    TCHAR szPath[MAX_PATH];
    if (_pidl && SHGetPathFromIDList(_pidl, szPath) && PathIsNetworkPath(szPath))
    {
        hr = E_OUTOFMEMORY;     // assume failure (2 cases below)
        
        LPTSTR psz = StrDup(szPath);    // give thread a copy of string to avoid buffer liftime issues
        if (psz)
        {
            DWORD dwID;
            HANDLE hThread = CreateThread(NULL, 0, _VerifyPathThreadProc, psz, 0, &dwID);
            if (hThread)
            {
                // assume timeout...
                hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT); // timeout return value
                
                if (WAIT_OBJECT_0 == WaitForSingleObject(hThread, _GetNetLinkTimeout()))
                {
                    // thread finished
                    DWORD dw;
                    if (GetExitCodeThread(hThread, &dw) && dw)
                    {
                        hr = S_OK;  // bool thread result maps to S_OK
                    }
                }
                CloseHandle(hThread);
            }
            else
            {
                LocalFree(psz);
            }
        }
    }
    return hr;
}


//
// This function returns the specified UI object from the link source.
//
// Parameters:
//  hwnd   -- optional hwnd for UI (for drop target)
//  riid   -- Specifies the interface (IID_IDropTarget, IID_IExtractIcon, IID_IContextMenu, ...)
//  ppv    -- Specifies the place to return the pointer.
//
// Notes:
//  Don't put smart-resolving code here. Such a thing should be done
//  BEFORE calling this function.
//

HRESULT CShellLink::_GetUIObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;     // Do this once and for all
    HRESULT hr = E_FAIL;

    if (_sld.dwFlags & SLDF_HAS_DARWINID)
    {
        // We commandeer a couple of IIDs if this is a Darwin link.
        // Must do this before any pseudo-resolve goo because Darwin
        // shortcuts don't resolve the normal way.

        if (IsEqualIID(riid, IID_IContextMenu))
        {
            // Custom Darwin context menu.
            hr = _CreateDarwinContextMenu(hwnd, (IContextMenu **)ppv);
        }
        else if (!IsEqualIID(riid, IID_IDropTarget) && _pidl)
        {
            hr = SHGetUIObjectFromFullPIDL(_pidl, hwnd, riid, ppv);
        }
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        if (!_pidl && _GetExpandedPath(szPath, SIZECHARS(szPath)))
        {
            _SetSimplePIDL(szPath);
        } 

        if (_pidl)
        {
            hr = SHGetUIObjectFromFullPIDL(_pidl, hwnd, riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr;

    if (_cmTarget == NULL)
    {
        hr = _GetUIObject(NULL, IID_PPV_ARG(IContextMenu, _cmTarget.GetOutputPtr()));
        if (FAILED(hr))
            return hr;

        ASSERT(_cmTarget);
    }

    // save these if in case we need to rebuild the cm because the resolve change the
    // target of the link

    _indexMenuSave = indexMenu;
    _idCmdFirstSave = idCmdFirst;
    _idCmdLastSave = idCmdLast;
    _uFlagsSave = uFlags;

    uFlags |= CMF_VERBSONLY;

    if (_sld.dwFlags & SLDF_RUNAS_USER)
    {
        // "runas" for exe's is an extenede verb, so we have to ask for those as well.
        uFlags |= CMF_EXTENDEDVERBS;
    }

    hr = _cmTarget.QueryContextMenu(this, hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);

    // set default verb to "runas" if the "Run as different user" checkbox is checked
    if (SUCCEEDED(hr) && (_sld.dwFlags & SLDF_RUNAS_USER))
    {
        int i = _cmTarget.GetMenuIndexForCanonicalVerb(this, hmenu, idCmdFirst, L"runas");

        if (i != -1)
        {
            // we found runas, so set it as the default
            SetMenuDefaultItem(hmenu, i, MF_BYPOSITION);
        }
        else
        {
            // the checkbox was enabled and checked, which means that the "runas" verb was supposed
            // to be in the context menu, but we couldnt find it.
            ASSERTMSG(FALSE, "CSL::QueryContextMenu - failed to set 'runas' as default context menu item!");
        }
    }

    return hr;
}

HRESULT CShellLink::_InvokeCommandAsync(LPCMINVOKECOMMANDINFO pici)
{
    TCHAR szWorkingDir[MAX_PATH];
    CHAR szVerb[32];
    CHAR szWorkingDirAnsi[MAX_PATH];
    WCHAR szVerbW[32];

    szVerb[0] = 0;

    // if needed, get the canonical name in case the IContextMenu changes as
    // a result of the resolve call BUT only do this for folders (to be safe)
    // as that is typically the only case where this happens
    // sepcifically we resolve from a D:\ -> \\SERVER\SHARE

    if (IS_INTRESOURCE(pici->lpVerb) && (_sld.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        _cmTarget.GetCommandString(this, LOWORD(pici->lpVerb), GCS_VERBA, NULL, szVerb, ARRAYSIZE(szVerb));
    }

    ASSERT(!_bDirty);

    // we pass SLR_ENVOKE_MSI since we WANT to invoke darwin since we are
    // really going to execute the link now
    DWORD slrFlags = SLR_INVOKE_MSI;
    if (pici->fMask & CMIC_MASK_FLAG_NO_UI)
    {
        slrFlags |= SLR_NO_UI;
    }
        
    HRESULT hr = _Resolve(pici->hwnd, slrFlags, 0);
    if (hr == S_OK)
    {
        if (_bDirty)
        {
            // the context menu we have for this link is out of date - recreate it
            _cmTarget.AtomicRelease();

            hr = _GetUIObject(NULL, IID_PPV_ARG(IContextMenu, _cmTarget.GetOutputPtr()));
            if (SUCCEEDED(hr))
            {
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    hr = _cmTarget.QueryContextMenu(this, hmenu, _indexMenuSave, _idCmdFirstSave, _idCmdLastSave, _uFlagsSave | CMF_VERBSONLY);
                    DestroyMenu(hmenu);
                }
            }
            Save((LPCOLESTR)NULL, TRUE);    // don't care if this fails...
        }
        else
        {
            szVerb[0] = 0;
            ASSERT(SUCCEEDED(hr));
        }

        if (SUCCEEDED(hr))
        {
            TCHAR szArgs[MAX_PATH];
            TCHAR szExpArgs[MAX_PATH];
            CMINVOKECOMMANDINFOEX ici;
            CHAR szArgsAnsi[MAX_PATH];

            // copy to local ici
            if (pici->cbSize > sizeof(CMINVOKECOMMANDINFOEX))
            {
                memcpy(&ici, pici, sizeof(CMINVOKECOMMANDINFOEX));
                ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);
            }
            else
            {
                memset(&ici, 0, sizeof(ici));
                memcpy(&ici, pici, pici->cbSize);
                ici.cbSize = sizeof(ici);
            }

            if (szVerb[0])
            {
                ici.lpVerb = szVerb;
                SHAnsiToUnicode(szVerb, szVerbW, ARRAYSIZE(szVerbW));
                ici.lpVerbW = szVerbW;
            }
            // build the args from those passed in cated on the end of the the link args

            lstrcpyn(szArgs, _pszArgs ? _pszArgs : c_szNULL, ARRAYSIZE(szArgs));
            if (ici.lpParameters)
            {
                int nArgLen = lstrlen(szArgs);
                LPCTSTR lpParameters;
                WCHAR szParameters[MAX_PATH];

                if (ici.cbSize < CMICEXSIZE_NT4
                    || (ici.fMask & CMIC_MASK_UNICODE) != CMIC_MASK_UNICODE)
                {
                    SHAnsiToUnicode(ici.lpParameters, szParameters, ARRAYSIZE(szParameters));
                    lpParameters = szParameters;
                }
                else
                {
                    lpParameters = ici.lpParametersW;
                }
                lstrcpyn(szArgs + nArgLen, c_szSpace, ARRAYSIZE(szArgs) - nArgLen - 1);
                lstrcpyn(szArgs + nArgLen + 1, lpParameters, ARRAYSIZE(szArgs) - nArgLen - 2);
            }

            // Expand environment strings in szArgs
            SHExpandEnvironmentStrings(szArgs, szExpArgs, ARRAYSIZE(szExpArgs));

            SHTCharToAnsi(szExpArgs, szArgsAnsi, ARRAYSIZE(szArgsAnsi));
            ici.lpParameters = szArgsAnsi;
            ici.lpParametersW = szExpArgs;
            ici.fMask |= CMIC_MASK_UNICODE;

            // if we have a working dir in the link over ride what is passed in

            if (_GetWorkingDir(szWorkingDir))
            {
                LPCTSTR pszDir = PathIsDirectory(szWorkingDir) ? szWorkingDir : NULL;
                if (pszDir)
                {
                    SHTCharToAnsi(pszDir, szWorkingDirAnsi, ARRAYSIZE(szWorkingDirAnsi));
                    ici.lpDirectory = szWorkingDirAnsi;
                    ici.lpDirectoryW = pszDir;
                }
            }

            // set RUN IN SEPARATE VDM if needed
            if (_sld.dwFlags & SLDF_RUN_IN_SEPARATE)
            {
                ici.fMask |= CMIC_MASK_FLAG_SEP_VDM;
            }
            // and of course use our hotkey
            if (_sld.wHotkey)
            {
                ici.dwHotKey = _sld.wHotkey;
                ici.fMask |= CMIC_MASK_HOTKEY;
            }

            // override normal runs, but let special show cmds through
            if (ici.nShow == SW_SHOWNORMAL)
            {
                DebugMsg(DM_TRACE, TEXT("using shorcut show cmd"));
                ici.nShow = _sld.iShowCmd;
            }

            //
            // On NT we want to pass the title to the
            // thing that we are about to start.
            //
            // CMIC_MASK_HASLINKNAME means that the lpTitle is really
            // the full path to the shortcut.  The console subsystem
            // sees the bit and reads all his properties directly from
            // the LNK file.
            //
            // ShellExecuteEx also uses the path to the shortcut so it knows
            // what to set in the SHCNEE_SHORTCUTINVOKE notification.
            //
            if (!(ici.fMask & CMIC_MASK_HASLINKNAME) && !(ici.fMask & CMIC_MASK_HASTITLE))
            {
                if (_pszCurFile)
                {
                    ici.lpTitle = NULL;     // Title is one or the other...
                    ici.lpTitleW = _pszCurFile;
                    ici.fMask |= CMIC_MASK_HASLINKNAME | CMIC_MASK_HASTITLE;
                }
            }
            ASSERT((ici.nShow > SW_HIDE) && (ici.nShow <= SW_MAX));

            IBindCtx *pbc;
            hr = _MaybeAddShim(&pbc);
            if (SUCCEEDED(hr))
            {
                hr = _cmTarget.InvokeCommand(this, (LPCMINVOKECOMMANDINFO)&ici);
                if (pbc)
                {
                    pbc->Release();
                }
            }
        }
    }
    return hr;
}


// Structure which encapsulates the paramters needed for InvokeCommand (so
// that we can pass both parameters though a single LPARAM in CreateThread)

typedef struct
{
    CShellLink *psl;
    CMINVOKECOMMANDINFOEX ici;
} ICMPARAMS;

#define ICM_BASE_SIZE (sizeof(ICMPARAMS) - sizeof(CMINVOKECOMMANDINFOEX))

// Runs as a separate thread, does the actual work of calling the "real"
// InvokeCommand

DWORD CALLBACK CShellLink::_InvokeThreadProc(void *pv)
{
    ICMPARAMS * pParams = (ICMPARAMS *) pv;
    CShellLink *psl = pParams->psl;
    IBindCtx *pbcRelease;

    HRESULT hr = TBCRegisterObjectParam(TBCDIDASYNC, SAFECAST(psl, IShellLink *), &pbcRelease);
    if (SUCCEEDED(hr))
    {
        //  since we are ASYNC, this hwnd may now go bad.  we just assume it has.
        //  we will make sure it doesnt by giving a chance for it to go bad
        if (IsWindow(pParams->ici.hwnd))
        {
            Sleep(100);
        }
        if (!IsWindow(pParams->ici.hwnd))
            pParams->ici.hwnd = NULL;
        
        hr = psl->_InvokeCommandAsync((LPCMINVOKECOMMANDINFO)&pParams->ici);
        pbcRelease->Release();
    }

    psl->Release();

    LocalFree(pParams);
    return (DWORD) hr;
}


// CShellLink::InvokeCommand
//
// Function that spins a thread to do the real work, which has been moved into
// CShellLink::InvokeCommandASync.

HRESULT CShellLink::InvokeCommand(LPCMINVOKECOMMANDINFO piciIn)
{
    HRESULT hr = S_OK;
    DWORD cchVerb, cchParameters, cchDirectory;
    DWORD cchVerbW, cchParametersW, cchDirectoryW;
    LPCMINVOKECOMMANDINFOEX   pici = (LPCMINVOKECOMMANDINFOEX) piciIn;
    const BOOL fUnicode = pici->cbSize >= CMICEXSIZE_NT4 &&
                                         (pici->fMask & CMIC_MASK_UNICODE) == CMIC_MASK_UNICODE;

    if (_cmTarget == NULL)
        return E_FAIL;

    if (0 == (piciIn->fMask & CMIC_MASK_ASYNCOK))
    {
        // Caller didn't indicate that Async startup was OK, so we call
        // InvokeCommandAync SYNCHRONOUSLY
        return _InvokeCommandAsync(piciIn);
    }

    // Calc how much space we will need to duplicate the INVOKECOMMANDINFO
    DWORD cbBaseSize = (DWORD)(ICM_BASE_SIZE + max(piciIn->cbSize, sizeof(CMINVOKECOMMANDINFOEX)));


    //   One byte slack in case of Unicode roundup for pPosW, below
    DWORD cbSize = cbBaseSize + 1;

    if (HIWORD(pici->lpVerb))
    {
        cbSize += (cchVerb   = pici->lpVerb       ? (lstrlenA(pici->lpVerb) + 1)       : 0) * sizeof(CHAR);
    }
    cbSize += (cchParameters = pici->lpParameters ? (lstrlenA(pici->lpParameters) + 1) : 0) * sizeof(CHAR);
    cbSize += (cchDirectory  = pici->lpDirectory  ? (lstrlenA(pici->lpDirectory) + 1)  : 0) * sizeof(CHAR);

    if (HIWORD(pici->lpVerbW))
    {
        cbSize += (cchVerbW  = pici->lpVerbW      ? (lstrlenW(pici->lpVerbW) + 1)       : 0) * sizeof(WCHAR);
    }
    cbSize += (cchParametersW= pici->lpParametersW? (lstrlenW(pici->lpParametersW) + 1) : 0) * sizeof(WCHAR);
    cbSize += (cchDirectoryW = pici->lpDirectoryW ? (lstrlenW(pici->lpDirectoryW) + 1)  : 0) * sizeof(WCHAR);

    ICMPARAMS *pParams = (ICMPARAMS *) LocalAlloc(LPTR, cbSize);
    if (NULL == pParams)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // Text data will start going in right after the structure
    CHAR *pPos = (CHAR *)((LPBYTE)pParams + cbBaseSize);

    // Start with a copy of the static fields
    CopyMemory(&pParams->ici, pici, pici->cbSize);

    // Walk along and dupe all of the string pointer fields
    if (HIWORD(pici->lpVerb))
    {
        pPos += cchVerb   ? lstrcpyA(pPos, pici->lpVerb), pParams->ici.lpVerb = pPos, cchVerb   : 0;
    }
    pPos += cchParameters ? lstrcpyA(pPos, pici->lpParameters), pParams->ici.lpParameters = pPos, cchParameters : 0;
    pPos += cchDirectory  ? lstrcpyA(pPos, pici->lpDirectory),  pParams->ici.lpDirectory  = pPos, cchDirectory  : 0;

    WCHAR *pPosW = (WCHAR *) ((DWORD_PTR)pPos & 0x1 ? pPos + 1 : pPos);   // Ensure Unicode alignment
    if (HIWORD(pici->lpVerbW))
    {
        pPosW += cchVerbW  ? lstrcpyW(pPosW, pici->lpVerbW), pParams->ici.lpVerbW = pPosW, cchVerbW : 0;
    }
    pPosW += cchParametersW? lstrcpyW(pPosW, pici->lpParametersW),pParams->ici.lpParametersW= pPosW, cchParametersW : 0;
    pPosW += cchDirectoryW ? lstrcpyW(pPosW, pici->lpDirectoryW), pParams->ici.lpDirectoryW = pPosW, cchDirectoryW  : 0;

    // Pass all of the info off to the worker thread that will call the actual
    // InvokeCommand API for us

    //Set the object pointer to this object
    pParams->psl  = this;
    pParams->psl->AddRef();
    
    //  need to be able to be refcounted, 
    //  so that the dataobject we create 
    //  will stick around as long as needed.
    if (!SHCreateThread(_InvokeThreadProc, pParams, CTF_COINIT | CTF_REF_COUNTED, NULL))
    {
        // Couldn't start the thread, so the onus is on us to clean up
        pParams->psl->Release();
        LocalFree(pParams);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CShellLink::GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pmf, LPSTR pszName, UINT cchMax)
{
    VDATEINPUTBUF(pszName, TCHAR, cchMax);
    
    if (_cmTarget)
    {
        return _cmTarget.GetCommandString(this, idCmd, wFlags, pmf, pszName, cchMax);
    }
    else
    {
        return E_FAIL;
    }
}

//
//  Note that we do not do a SetSite around the call to the inner HandleMenuMsg
//  It isn't necessary (yet)
//
HRESULT CShellLink::TargetContextMenu::HandleMenuMsg2(IShellLink *outer, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    return SHForwardContextMenuMsg(_pcmTarget, uMsg, wParam, lParam, plResult, NULL==plResult);
}

STDMETHODIMP CShellLink::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    if (_cmTarget)
    {
        return _cmTarget.HandleMenuMsg2(this, uMsg, wParam, lParam, plResult);
    }

    return E_NOTIMPL;
}

STDMETHODIMP CShellLink::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

HRESULT CShellLink::_InitDropTarget()
{
    if (_pdtSrc)
    {
        return S_OK;
    }

    HWND hwnd;
    IUnknown_GetWindow(_punkSite, &hwnd);
    return _GetUIObject(hwnd, IID_PPV_ARG(IDropTarget, &_pdtSrc));
}

STDMETHODIMP CShellLink::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        _grfKeyStateLast = grfKeyState;
        hr = _pdtSrc->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }
    return hr;
}

STDMETHODIMP CShellLink::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        _grfKeyStateLast = grfKeyState;
        hr = _pdtSrc->DragOver(grfKeyState, pt, pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }
    return hr;
}

STDMETHODIMP CShellLink::DragLeave()
{
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        hr = _pdtSrc->DragLeave();
    }
    return hr;
}

STDMETHODIMP CShellLink::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HWND hwnd = NULL;
    HRESULT hr = _InitDropTarget();
    if (SUCCEEDED(hr))
    {
        IUnknown_GetWindow(_punkSite, &hwnd);

        _pdtSrc->DragLeave();       // leave from the un-resolved drop target.

        hr = _Resolve(hwnd, 0, 0);  // track the target
        if (S_OK == hr)
        {
            IDropTarget *pdtgtResolved;
            if (SUCCEEDED(_GetUIObject(hwnd, IID_PPV_ARG(IDropTarget, &pdtgtResolved))))
            {
                IUnknown_SetSite(pdtgtResolved, SAFECAST(this, IShellLink *));

                SHSimulateDrop(pdtgtResolved, pdtobj, _grfKeyStateLast, &pt, pdwEffect);

                IUnknown_SetSite(pdtgtResolved, NULL);

                pdtgtResolved->Release();
            }
        }
    }

    if (FAILED_AND_NOT_CANCELED(hr))
    {
        TCHAR szLinkSrc[MAX_PATH];
        if (_pidl && SHGetPathFromIDList(_pidl, szLinkSrc))
        {
            ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_ENUMERR_PATHNOTFOUND),
                        MAKEINTRESOURCE(IDS_LINKERROR),
                        MB_OK | MB_ICONEXCLAMATION, NULL, szLinkSrc);
        }
    }

    if (hr != S_OK)
    {
        // make sure nothing happens (if we failed)
        *pdwEffect = DROPEFFECT_NONE;
    }

    return hr;
}

STDMETHODIMP CShellLink::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    TCHAR szTip[INFOTIPSIZE];
    TCHAR szDesc[INFOTIPSIZE];

    StrCpyN(szTip, _pszPrefix ? _pszPrefix : TEXT(""), ARRAYSIZE(szTip));

    // QITIPF_USENAME could be replaced with ICustomizeInfoTip::SetPrefixText()

    if ((dwFlags & QITIPF_USENAME) && _pszCurFile)
    {
        SHFILEINFO sfi;
        if (SHGetFileInfo(_pszCurFile, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES))
        {
            if (szTip[0])
                StrCatBuff(szTip, TEXT("\n"), ARRAYSIZE(szTip));
            StrCatBuff(szTip, sfi.szDisplayName, ARRAYSIZE(szTip));
        }
    }
        
    GetDescription(szDesc, ARRAYSIZE(szDesc));

    //  if there is no comment, then we create one based on 
    //  the target's location.  only do this if we are not
    //  a darwin link, since the location has no meaning there
    if (!szDesc[0] && !(_sld.dwFlags & SLDF_HAS_DARWINID) && !(dwFlags & QITIPF_LINKNOTARGET))
    {
        if (dwFlags & QITIPF_LINKUSETARGET)
        {
            SHMakeDescription(_pidl, -1, szDesc, ARRAYSIZE(szDesc));
        }
        else
        {
            _MakeDescription(_pidl, szDesc, ARRAYSIZE(szDesc));
        }
    }
    else if (szDesc[0] == TEXT('@'))
    {
        WCHAR sz[INFOTIPSIZE];

        if (SUCCEEDED(SHLoadIndirectString(szDesc, sz, ARRAYSIZE(sz), NULL)))
        {
            StrCpyN(szDesc, sz, ARRAYSIZE(szDesc));
        }
    }
    

    if (szDesc[0])
    {
        if (szTip[0])
        {
            StrCatBuff(szTip, TEXT("\n"), ARRAYSIZE(szTip));
        }

        StrCatBuff(szTip, szDesc, ARRAYSIZE(szTip));
    }

    if (*szTip)
    {
        return SHStrDup(szTip, ppwszTip);
    }
    else
    {
        *ppwszTip = NULL;
        return S_FALSE;
    }
}

STDMETHODIMP CShellLink::GetInfoFlags(DWORD *pdwFlags)
{
    pdwFlags = 0;
    return E_NOTIMPL;
}

HRESULT CShellLink::_GetExtractIcon(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (_pszIconLocation && _pszIconLocation[0])
    {
        TCHAR szPath[MAX_PATH];
        
        // update our _pszIconLocation if we have a EXP_SZ_ICON_SIG datablock
        _UpdateIconFromExpIconSz();
        
        if (_pszIconLocation[0] == TEXT('.'))
        {
            TCHAR szBogusFile[MAX_PATH];
            
            // We allow people to set ".txt" for an icon path. In this case 
            // we cook up a simple pidl and use it to get to the IExtractIcon for 
            // whatever extension the user has specified.
            
            hr = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, szBogusFile);
            if (SUCCEEDED(hr))
            {
                PathAppend(szBogusFile, TEXT("*"));
                lstrcatn(szBogusFile, _pszIconLocation, ARRAYSIZE(szBogusFile));
                
                LPITEMIDLIST pidl = SHSimpleIDListFromPath(szBogusFile);
                if (pidl)
                {
                    hr = SHGetUIObjectFromFullPIDL(pidl, NULL, riid, ppv);
                    ILFree(pidl);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                
            }
        }
        else if ((_sld.iIcon == 0)                  &&
                 _pidl                              &&
                 SHGetPathFromIDList(_pidl, szPath) &&
                 (lstrcmpi(szPath, _pszIconLocation) == 0))
        {
            // IExtractIconA/W
            hr = _GetUIObject(NULL, riid, ppv);
        }
        else
        {
            hr = SHCreateDefExtIcon(_pszIconLocation, _sld.iIcon, _sld.iIcon, GIL_PERINSTANCE, -1, riid, ppv);
        }
    }
    else
    {
        // IExtractIconA/W
        hr = _GetUIObject(NULL, riid, ppv);
    }

    return hr;
}

HRESULT CShellLink::_InitExtractIcon()
{
    if (_pxi || _pxiA)
        return S_OK;

    HRESULT hr = _GetExtractIcon(IID_PPV_ARG(IExtractIconW, &_pxi));
    if (FAILED(hr))
    {
        hr = _GetExtractIcon(IID_PPV_ARG(IExtractIconA, &_pxiA));
    }

    return hr;
}

// IExtractIconW::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(UINT uFlags, LPWSTR pszIconFile, 
                                         UINT cchMax, int *piIndex, UINT *pwFlags)
{
    // If we are in a situation where a shortcut points to itself (or LinkA <--> LinkB), then break the recursion here...
    if (uFlags & GIL_FORSHORTCUT)
    {
        RIPMSG(uFlags & GIL_FORSHORTCUT,"CShellLink::GIL called with GIL_FORSHORTCUT (uFlags=%x)",uFlags);
        return E_INVALIDARG;
    }

    HRESULT hr = _InitExtractIcon();

    if (SUCCEEDED(hr))
    {
        uFlags |= GIL_FORSHORTCUT;

        if (_pxi)
        {
            hr = _pxi->GetIconLocation(uFlags, pszIconFile, cchMax, piIndex, pwFlags);
        }
        else if (_pxiA)
        {
            CHAR sz[MAX_PATH];
            hr = _pxiA->GetIconLocation(uFlags, sz, ARRAYSIZE(sz), piIndex, pwFlags);
            if (SUCCEEDED(hr) && hr != S_FALSE)
                SHAnsiToUnicode(sz, pszIconFile, cchMax);
        }
        if (SUCCEEDED(hr))
        {
            _gilFlags = *pwFlags;
        }
    }
    return hr;
}

// IExtractIconA::GetIconLocation
STDMETHODIMP CShellLink::GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    WCHAR szFile[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szFile, ARRAYSIZE(szFile), piIndex, pwFlags);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(szFile, pszIconFile, cchMax);
    }
    return hr;
}

// IExtractIconW::Extract
STDMETHODIMP CShellLink::Extract(LPCWSTR pszFile, UINT nIconIndex, 
                                 HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = _InitExtractIcon();
    if (SUCCEEDED(hr))
    {
        // GIL_PERCLASS, GIL_PERINSTANCE
        if ((_gilFlags & GIL_PERINSTANCE) || !(_gilFlags & GIL_PERCLASS))
        {
            hr = _ShortNetTimeout();    // probe the net path
        }

        if (SUCCEEDED(hr))  // check again for _ShortNetTimeout() above case
        {
            if (_pxi)
            {
                hr = _pxi->Extract(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
            }
            else if (_pxiA)
            {
                CHAR sz[MAX_PATH];
                SHUnicodeToAnsi(pszFile, sz, ARRAYSIZE(sz));
                hr = _pxiA->Extract(sz, nIconIndex, phiconLarge, phiconSmall, nIconSize);
            }
        }
    }
    return hr;
}

// IExtractIconA::Extract
STDMETHODIMP CShellLink::Extract(LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    WCHAR szFile[MAX_PATH];
    SHAnsiToUnicode(pszFile, szFile, ARRAYSIZE(szFile));
    return Extract(szFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}    

STDMETHODIMP CShellLink::AddDataBlock(void *pdb)
{
    _AddExtraDataSection((DATABLOCK_HEADER *)pdb);
    return S_OK;
}

STDMETHODIMP CShellLink::CopyDataBlock(DWORD dwSig, void **ppdb)
{
    DATABLOCK_HEADER *peh = (DATABLOCK_HEADER *)SHFindDataBlock(_pExtraData, dwSig);
    if (peh)
    {
        *ppdb = LocalAlloc(LPTR, peh->cbSize);
        if (*ppdb)
        {
            CopyMemory(*ppdb, peh, peh->cbSize);
            return S_OK;
        }
        return E_OUTOFMEMORY;
    }
    *ppdb = NULL;
    return E_FAIL;
}

STDMETHODIMP CShellLink::RemoveDataBlock(DWORD dwSig)
{
    _RemoveExtraDataSection(dwSig);
    return S_OK;
}

STDMETHODIMP CShellLink::GetFlags(DWORD *pdwFlags)
{
    *pdwFlags = _sld.dwFlags;
    return S_OK;
}

STDMETHODIMP CShellLink::SetFlags(DWORD dwFlags)
{
    if (dwFlags != _sld.dwFlags)
    {
        _bDirty = TRUE;
        _sld.dwFlags = dwFlags;
        return S_OK;
    }
    return S_FALSE;     // no change made
}

STDMETHODIMP CShellLink::GetPath(LPSTR pszFile, int cchFile, WIN32_FIND_DATAA *pfd, DWORD fFlags)
{
    WCHAR szPath[MAX_PATH];
    WIN32_FIND_DATAW wfd;
    VDATEINPUTBUF(pszFile, CHAR, cchFile);

    //Call the unicode version
    HRESULT hr = GetPath(szPath, ARRAYSIZE(szPath), &wfd, fFlags);

    if (pszFile)
    {
        SHUnicodeToAnsi(szPath, pszFile, cchFile);
    }
    if (pfd)
    {
        if (szPath[0])
        {
            pfd->dwFileAttributes = wfd.dwFileAttributes;
            pfd->ftCreationTime   = wfd.ftCreationTime;
            pfd->ftLastAccessTime = wfd.ftLastAccessTime;
            pfd->ftLastWriteTime  = wfd.ftLastWriteTime;
            pfd->nFileSizeLow     = wfd.nFileSizeLow;
            pfd->nFileSizeHigh    = wfd.nFileSizeHigh;

            SHUnicodeToAnsi(wfd.cFileName, pfd->cFileName, ARRAYSIZE(pfd->cFileName));
        }
        else
        {
            ZeroMemory(pfd, sizeof(*pfd));
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::SetPath(LPCSTR pszPath)
{
    WCHAR szPath[MAX_PATH];
    LPWSTR pszPathW;
    
    if (pszPath)
    {
        SHAnsiToUnicode(pszPath, szPath, ARRAYSIZE(szPath));
        pszPathW = szPath;
    }
    else
    {
        pszPathW = NULL;
    }

    return SetPath(pszPathW);
}

STDAPI CShellLink_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CShellLink *pshlink = new CShellLink();
    if (pshlink)
    {
        hr = pshlink->QueryInterface(riid, ppv);
        pshlink->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CShellLink::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellLink::InitNew(void)
{
    _ResetPersistData();        // clear out our state
    return S_OK;
}

STDMETHODIMP CShellLink::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    _ResetPersistData();        // clear out our state

    TCHAR szPath[MAX_PATH];

    // TBD: Shortcut key, Run, Icon, Working Dir, Description

    INT iCSIDL;    
    HRESULT hr = SHPropertyBag_ReadInt(pPropBag, L"TargetSpecialFolder", &iCSIDL);
    if (SUCCEEDED(hr))
    {
        hr = SHGetFolderPath(NULL, iCSIDL, NULL, SHGFP_TYPE_CURRENT, szPath);
    }
    else
    {
        szPath[0] = 0;
        hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        WCHAR wsz[MAX_PATH];
        if (SUCCEEDED(SHPropertyBag_ReadStr(pPropBag, L"Target", wsz, ARRAYSIZE(wsz))))
        {
            TCHAR szTempPath[MAX_PATH];
            SHUnicodeToTChar(wsz, szTempPath, ARRAYSIZE(szTempPath));
            // Do we need to append it to the Special path?
            if (szPath[0])
            {
                // Yes
                if (!PathAppend(szPath, szTempPath))
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                // No, there is no special path
                // Maybe we have an Env Var to expand
                if (0 == SHExpandEnvironmentStrings(szTempPath, szPath, ARRAYSIZE(szPath)))
                {
                    hr = E_FAIL;
                }
            }
        }
        else if (0 == szPath[0])
        {
            // make sure not empty
            hr = E_FAIL;
            
        }
        if (SUCCEEDED(hr))
        {
            // FALSE for bUpdateTrackingData as we won't need any tracking data
            // for links loaded via a property bag
            hr = _SetPIDLPath(NULL, szPath, FALSE); 
        }
    }
    return hr;
}

STDMETHODIMP CShellLink::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_LinkSite)
        return QueryInterface(riid, ppv);
    return IUnknown_QueryService(_punkSite, guidService, riid, ppv);
}

const FULLPROPSPEC c_rgProps[] =
{
    { PSGUID_SUMMARYINFORMATION, {  PRSPEC_PROPID, PIDSI_COMMENTS } },
};

STDMETHODIMP CShellLink::Init(ULONG grfFlags, ULONG cAttributes,
                              const FULLPROPSPEC *rgAttributes, ULONG *pFlags)
{
    *pFlags = 0;

    if (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES)
    {
        // start at the beginning
        _iChunkIndex = 0;
    }
    else
    {
        // indicate EOF
        _iChunkIndex = ARRAYSIZE(c_rgProps);
    }
    _iValueIndex = 0;
    return S_OK;
}
        
STDMETHODIMP CShellLink::GetChunk(STAT_CHUNK *pStat)
{
    HRESULT hr = S_OK;
    if (_iChunkIndex < ARRAYSIZE(c_rgProps))
    {
        pStat->idChunk          = _iChunkIndex + 1;
        pStat->idChunkSource    = _iChunkIndex + 1;
        pStat->breakType        = CHUNK_EOP;
        pStat->flags            = CHUNK_VALUE;
        pStat->locale           = GetSystemDefaultLCID();
        pStat->attribute        = c_rgProps[_iChunkIndex];
        pStat->cwcStartSource   = 0;
        pStat->cwcLenSource     = 0;

        _iValueIndex = 0;
        _iChunkIndex++;
    }
    else
    {
        hr = FILTER_E_END_OF_CHUNKS;
    }
    return hr;
}

STDMETHODIMP CShellLink::GetText(ULONG *pcwcBuffer, WCHAR *awcBuffer)
{
    return FILTER_E_NO_TEXT;
}
        
STDMETHODIMP CShellLink::GetValue(PROPVARIANT **ppPropValue)
{
    HRESULT hr;
    if ((_iChunkIndex <= ARRAYSIZE(c_rgProps)) && (_iValueIndex < 1))
    {
        *ppPropValue = (PROPVARIANT*)CoTaskMemAlloc(sizeof(PROPVARIANT));
        if (*ppPropValue)
        {
            (*ppPropValue)->vt = VT_BSTR;

            if (_pszName)
            {
                (*ppPropValue)->bstrVal = SysAllocStringT(_pszName);
            }
            else
            {
                // since _pszName is null, return an empty bstr
                (*ppPropValue)->bstrVal = SysAllocStringT(TEXT(""));
            }

            if ((*ppPropValue)->bstrVal)
            {
                hr = S_OK;
            }
            else
            {
                CoTaskMemFree(*ppPropValue);
                *ppPropValue = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        _iValueIndex++;
    }
    else
    {
        hr = FILTER_E_NO_MORE_VALUES;
    }
    return hr;
}
        
STDMETHODIMP CShellLink::BindRegion(FILTERREGION origPos, REFIID riid, void **ppunk)
{
    *ppunk = NULL;
    return E_NOTIMPL;
}

// ICustomizeInfoTip

STDMETHODIMP CShellLink::SetPrefixText(LPCWSTR pszPrefix)
{
    Str_SetPtrW(&_pszPrefix, pszPrefix);
    return S_OK;
}

STDMETHODIMP CShellLink::SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid)
{
    return S_OK;
}

HRESULT CShellLink::_MaybeAddShim(IBindCtx **ppbcRelease)
{
    // set the __COMPAT_LAYER environment variable if necessary
    HRESULT hr = S_FALSE;
    *ppbcRelease = 0;
    if ((_sld.dwFlags & SLDF_RUN_WITH_SHIMLAYER))
    {
        EXP_SHIMLAYER* pShimData = (EXP_SHIMLAYER*)SHFindDataBlock(_pExtraData, EXP_SHIMLAYER_SIG);

        if (pShimData && pShimData->wszLayerEnvName[0])
        {
            //  we shouldnt recurse
            ASSERT(FAILED(TBCGetEnvironmentVariable(TEXT("__COMPAT_LAYER"), NULL, 0)));
            hr = TBCSetEnvironmentVariable(L"__COMPAT_LAYER", pShimData->wszLayerEnvName, ppbcRelease);
        }
    }
    return hr;
}

DWORD CALLBACK CLinkResolver::_ThreadStartCallBack(void *pv)
{
    CLinkResolver *prs = (CLinkResolver *)pv;
    prs->_hThread = OpenThread(SYNCHRONIZE, FALSE, GetCurrentThreadId());
    prs->AddRef();
    return 0;
}

DWORD CLinkResolver::_Search()
{
    // Attempt to find the link using the CTracker
    // object (which uses NTFS object IDs and persisted information
    // about link-source moves).
    if (_ptracker)
    {
        HRESULT hr = _ptracker->Search(_dwTimeLimit,            // GetTickCount()-relative timeout
                                       &_ofd,                   // Original WIN32_FIND_DATA
                                       &_fdFound,               // WIN32_FIND_DATA of new location
                                       _dwResolveFlags,         // SLR_ flags
                                       _TrackerRestrictions);   // TrkMendRestriction flags
        if (SUCCEEDED(hr))
        {
           // We've found the link source, and we're certain it's correct.
           // So set the score to the highest possible value, and
           // return.
 
           _iScore = MIN_NO_UI_SCORE;
           _bContinue = FALSE;
        }
        else if (HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND) == hr)
        {
            // We've found "a" link source, but we're not certain it's correct.
            // Allow the search algorithm below to run and see if it finds
            // a better match.

            _iScore = MIN_NO_UI_SCORE - 1;
        }
        else if (HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT) == hr)
        {
            // The CTracker search stopped because we've timed out.
            _bContinue = FALSE;
        }
    }

    // Attempt to find the link source using an enumerative search
    // (unless the downlevel search has been suppressed by the caller)

    if (_bContinue && !(_fifFlags & FIF_NODRIVE))
    {
        _HeuristicSearch();
    }

    if (_hDlg)
    {
        PostMessage(_hDlg, WM_COMMAND, IDOK, 0);
    }

    return _iScore;
}

DWORD CALLBACK CLinkResolver::_SearchThreadProc(void *pv)
{
    // Sleep(45 * 1000);    // test the network long time out case

    CLinkResolver *prs = (CLinkResolver *)pv;
    DWORD dwRet = prs->_Search();
    prs->Release();  // AddRef in the CallBack while thread creation.
    return dwRet;
}

DWORD CLinkResolver::_GetTimeOut()
{
    if (0 == _dwTimeOutDelta)
    {
        _dwTimeOutDelta = TimeoutDeltaFromResolveFlags(_dwResolveFlags);
    }
    return _dwTimeOutDelta;
}

#define IDT_SHOWME          1
#define IDT_NO_UI_TIMEOUT   2

void CLinkResolver::_InitDlg(HWND hDlg)
{
    _hDlg = hDlg;
    
    if (SHCreateThread(_SearchThreadProc, this, CTF_COINIT | CTF_FREELIBANDEXIT, _ThreadStartCallBack))
    {
        CloseHandle(_hThread);
        _hThread = NULL;

        if (_dwResolveFlags & SLR_NO_UI)
        {
            SetTimer(hDlg, IDT_NO_UI_TIMEOUT, _GetTimeOut(), 0);
        }
        else
        {
            TCHAR szFmt[128], szTemp[MAX_PATH + ARRAYSIZE(szFmt)];
            
            GetDlgItemText(hDlg, IDD_NAME, szFmt, ARRAYSIZE(szFmt));
            wsprintf(szTemp, szFmt, _ofd.cFileName);
            SetDlgItemText(hDlg, IDD_NAME, szTemp);
            
            HWND hwndAni = GetDlgItem(hDlg, IDD_STATUS);
            
            Animate_Open(hwndAni, MAKEINTRESOURCE(IDA_SEARCH)); // open the resource
            Animate_Play(hwndAni, 0, -1, -1);     // play from start to finish and repeat
        
            // delay showing the dialog for the common case where we quickly
            // find the target (in less than 1/2 a sec)
            _idtDelayedShow = SetTimer(hDlg, IDT_SHOWME, 500, 0);
        }
    }
    else
    {
        EndDialog(hDlg, IDCANCEL);
    }
}

BOOL_PTR CALLBACK CLinkResolver::_DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CLinkResolver *prs = (CLinkResolver *)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (wMsg) 
    {
    case WM_INITDIALOG:
        
        // This Dialog is created in Synchronous to the Worker thread who already has Addref'd prs, so 
        // no need to Addref it here.
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        prs = (CLinkResolver *)lParam;
        prs->_InitDlg(hDlg);
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDD_BROWSE:
            prs->_hDlg = NULL;              // don't let the thread close us
            prs->_bContinue = FALSE;         // cancel thread
            
            Animate_Stop(GetDlgItem(hDlg, IDD_STATUS));
            
            if (GetFileNameFromBrowse(hDlg, prs->_sfd.cFileName, ARRAYSIZE(prs->_sfd.cFileName), prs->_pszSearchOriginFirst, prs->_ofd.cFileName, NULL, NULL))
            {
                HANDLE hfind = FindFirstFile(prs->_sfd.cFileName, &prs->_fdFound);
                ASSERT(hfind != INVALID_HANDLE_VALUE);
                FindClose(hfind);
                lstrcpy(prs->_fdFound.cFileName, prs->_sfd.cFileName);
                
                prs->_iScore = MIN_NO_UI_SCORE;
                wParam = IDOK;
            }
            else
            {
                wParam = IDCANCEL;
            }
            // Fall through...
            
        case IDCANCEL:
            // tell searching thread to stop
            prs->_bContinue = FALSE;
            
            // if the searching thread is currently in the tracker
            // waiting for results, wake it up and tell it to abort
            
            if (prs->_ptracker)
                prs->_ptracker->CancelSearch();
            // Fall through...
            
        case IDOK:
            // thread posts this to us
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;
        }
        break;
        
        case WM_TIMER:
            KillTimer(hDlg, wParam);    // both are one shots
            switch (wParam)
            {
            case IDT_NO_UI_TIMEOUT:
                PostMessage(prs->_hDlg, WM_COMMAND, IDCANCEL, 0);
                break;
                
            case IDT_SHOWME:
                prs->_idtDelayedShow = 0;
                ShowWindow(hDlg, SW_SHOW);
                break;
            }
            break;
            
        case WM_WINDOWPOSCHANGING:
            if ((prs->_dwResolveFlags & SLR_NO_UI) || prs->_idtDelayedShow) 
            {
                WINDOWPOS *pwp = (WINDOWPOS *)lParam;
                pwp->flags &= ~SWP_SHOWWINDOW;
            }
            break;
            
        default:
            return FALSE;
    }
    return TRUE;
}

typedef struct 
{
    LPCTSTR pszLinkName;
    LPCTSTR pszNewTarget;
    LPCTSTR pszCurFile;
} DEADLINKDATA;

BOOL_PTR DeadLinkProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DEADLINKDATA *pdld = (DEADLINKDATA *)GetWindowPtr(hwnd, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pdld = (DEADLINKDATA*)lParam;
        SetWindowPtr(hwnd, DWLP_USER, pdld);

        HWNDWSPrintf(GetDlgItem(hwnd, IDC_DEADTEXT1), PathFindFileName(pdld->pszLinkName));
        if (GetDlgItem(hwnd, IDC_DEADTEXT2)) 
            PathSetDlgItemPath(hwnd, IDC_DEADTEXT2, pdld->pszNewTarget);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDC_DELETE:
            {
                TCHAR szName[MAX_PATH + 1] = {0};
                SHFILEOPSTRUCT fo = {
                    hwnd,
                    FO_DELETE,
                    szName,
                    NULL, 
                    FOF_NOCONFIRMATION
                };

                lstrcpy(szName, pdld->pszCurFile);
                SHFileOperation(&fo);
            }
            // fall through...
        case IDCANCEL:
        case IDOK:
            EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
            break;
        }
        break;
    }
    
    return FALSE;
}

// in:
//      hwnd            for UI if needed
//
// returns:
//      IDOK            found something
//      IDNO            didn't find it
//      IDCANCEL        user canceled the operation

int CLinkResolver::Resolve(HWND hwnd, LPCTSTR pszPath, LPCTSTR pszCurFile)
{
    lstrcpyn(_szSearchStart, pszPath, ARRAYSIZE(_szSearchStart));
    PathRemoveFileSpec(_szSearchStart);
    
    _dwTimeLimit = GetTickCount() + _GetTimeOut();
    
    int id = IDCANCEL;

    if (SLR_NO_UI == (SLR_NO_UI_WITH_MSG_PUMP & _dwResolveFlags))
    {
        if (SHCreateThread(_SearchThreadProc, this, CTF_COINIT | CTF_FREELIBANDEXIT, _ThreadStartCallBack))
        {
            // don't care if it completes or times out. as long as it has a result
            WaitForSingleObject(_hThread, _GetTimeOut());
            CloseHandle(_hThread);
            _hThread = NULL;
            _bContinue = FALSE;    // cancel that thread if it is still running
            id = IDOK;
        }
    }
    else
    {
        id = (int)DialogBoxParam(HINST_THISDLL,
                                 MAKEINTRESOURCE(DLG_LINK_SEARCH), 
                                 hwnd,
                                 _DlgProc,
                                 (LPARAM)this);
    }

    if (IDOK == id) 
    {
        if (_iScore < MIN_NO_UI_SCORE)
        {
            if (_dwResolveFlags & SLR_NO_UI)
            {
                id = IDCANCEL;
            }
            else
            {
                // we must display UI since this file is questionable
                if (_fifFlags & FIF_NODRIVE) 
                {
                    LPCTSTR pszName = pszCurFile ? (LPCTSTR)PathFindFileName(pszCurFile) : c_szNULL;
                    
                    ShellMessageBox(HINST_THISDLL,
                                    hwnd,
                                    MAKEINTRESOURCE(IDS_LINKUNAVAILABLE),
                                    MAKEINTRESOURCE(IDS_LINKERROR),
                                    MB_OK | MB_ICONEXCLAMATION,
                                    pszName);
                    id = IDCANCEL;
                }
                else if (pszCurFile)
                {
                    DEADLINKDATA dld;
                    dld.pszLinkName = pszPath;
                    dld.pszNewTarget = _fdFound.cFileName;
                    dld.pszCurFile = pszCurFile;
                    
                    int idDlg = _iScore <= MIN_SHOW_USER_SCORE ? DLG_DEADSHORTCUT : DLG_DEADSHORTCUT_MATCH;
                    id = (int)DialogBoxParam(HINST_THISDLL,
                                             MAKEINTRESOURCE(idDlg), 
                                             hwnd,
                                             DeadLinkProc,
                                             (LPARAM)&dld);
                }
                else if (_iScore <= MIN_SHOW_USER_SCORE) 
                {
                    ShellMessageBox(HINST_THISDLL,
                                    hwnd,
                                    MAKEINTRESOURCE(IDS_LINKNOTFOUND),
                                    MAKEINTRESOURCE(IDS_LINKERROR),
                                    MB_OK | MB_ICONEXCLAMATION,
                                    PathFindFileName(pszPath));
                    id = IDCANCEL;
                }
                else
                {
                    if (IDYES == ShellMessageBox(HINST_THISDLL,
                                                 hwnd, 
                                                 MAKEINTRESOURCE(IDS_LINKCHANGED),
                                                 MAKEINTRESOURCE(IDS_LINKERROR),
                                                 MB_YESNO | MB_ICONEXCLAMATION,
                                                 PathFindFileName(pszPath),
                                                 _fdFound.cFileName))
                    {
                        id = IDOK;
                    }
                    else
                    {
                        id = IDCANCEL;
                    }
                }
            }
        }
    }
    _ofd = _fdFound;
    return id;
}

void CLinkResolver::GetResult(LPTSTR psz, UINT cch)
{
    // _ofd.cFileName is a fully qualified name (strange for win32_find_data usage)
    StrCpyN(psz, _ofd.cFileName, cch);
}

CLinkResolver::CLinkResolver(CTracker *ptrackerobject, const WIN32_FIND_DATA *pofd, UINT dwResolveFlags, DWORD TrackerRestrictions, DWORD fifFlags) : 
    _dwTimeOutDelta(0), _bContinue(TRUE), _hThread(NULL), _pstw(NULL),
    _ptracker(ptrackerobject), _dwResolveFlags(dwResolveFlags), _TrackerRestrictions(TrackerRestrictions), _fifFlags(fifFlags)
{
    if (_ptracker)
    {
       _ptracker->AddRef();
    }

    _ofd = *pofd;   // original find data
    _pszSearchOriginFirst = _szSearchStart;
    _pszSearchOrigin = _szSearchStart;
    _dwMatch = _ofd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;      // must match bits
}

CLinkResolver::~CLinkResolver()
{
    if (_ptracker)
    {
        _ptracker->Release();
    }

    ATOMICRELEASE(_pstw);

    ASSERT(NULL == _hThread);
}

HRESULT CLinkResolver::_InitWalkObject()
{
    HRESULT hr = _pstw ? S_OK : CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &_pstw));
    if (SUCCEEDED(hr))
    {
        ASSERT(_pwszSearchSpec == NULL);
        // Note: We only search files with the same extension, this saves us a lot
        // of useless work and from the humiliation of coming up with a ridiculous answer
        _dwSearchFlags = WT_NOTIFYFOLDERENTER | WT_EXCLUDEWALKROOT;
        if (_dwMatch & FILE_ATTRIBUTE_DIRECTORY)
        {
            _dwSearchFlags |= WT_FOLDERONLY;
        }
        else
        {
            // Note that this does the right thing if the file has no extension
            LPTSTR pszExt = PathFindExtension(_ofd.cFileName);
            _wszSearchSpec[0] = L'*';
            SHTCharToUnicode(pszExt, &_wszSearchSpec[1], ARRAYSIZE(_wszSearchSpec) - 1);
            _pwszSearchSpec = _wszSearchSpec;

            // Shortcuts to shortcuts are generally not allowed, but the
            // Personal Start Menu uses them for link tracking purposes...
            _fFindLnk = PathIsLnk(_ofd.cFileName);
        }
    }
    return hr;
}

//
// Compare two FileTime structures.  First, see if they're really equal
// (using CompareFileTime).  If not, see if one has 10ms granularity,
// and if the other rounds down to the same value.  This is done
// to handle the case where a file is moved from NTFS to FAT;
// FAT file tiems are 10ms granularity, while NTFS is 100ns.  When
// an NTFS file is moved to FAT, its time is rounded down.
//

#define NTFS_UNITS_PER_FAT_UNIT  100000

BOOL IsEqualFileTimesWithTruncation(const FILETIME *pft1, const FILETIME *pft2)
{
    ULARGE_INTEGER uli1, uli2;
    ULARGE_INTEGER *puliFAT, *puliNTFS;
    FILETIME ftFAT, ftNTFS;

    if (0 == CompareFileTime(pft1, pft2))
        return TRUE;

    uli1.LowPart  = pft1->dwLowDateTime;
    uli1.HighPart = pft1->dwHighDateTime;

    uli2.LowPart  = pft2->dwLowDateTime;
    uli2.HighPart = pft2->dwHighDateTime;

    // Is one of the times 10ms granular?

    if (0 == (uli1.QuadPart % NTFS_UNITS_PER_FAT_UNIT))
    {
        puliFAT = &uli1;
        puliNTFS = &uli2;
    }
    else if (0 == (uli2.QuadPart % NTFS_UNITS_PER_FAT_UNIT))
    {
        puliFAT = &uli2;
        puliNTFS = &uli1;
    }
    else
    {
        // Neither time appears to be FAT, so they're
        // really different.
        return FALSE;
    }

    // If uliNTFS is already 10ms granular, then again the two times
    // are really different.

    if (0 == (puliNTFS->QuadPart % NTFS_UNITS_PER_FAT_UNIT))
    {
        return FALSE;
    }

    // Now see if the FAT time is the same as the NTFS time
    // when the latter is rounded down to the nearest 10ms.

    puliNTFS->QuadPart = (puliNTFS->QuadPart / NTFS_UNITS_PER_FAT_UNIT) * NTFS_UNITS_PER_FAT_UNIT;

    ftNTFS.dwLowDateTime = puliNTFS->LowPart;
    ftNTFS.dwHighDateTime = puliNTFS->HighPart;
    ftFAT.dwLowDateTime = puliFAT->LowPart;
    ftFAT.dwHighDateTime = puliFAT->HighPart;

    return (0 == CompareFileTime(&ftFAT, &ftNTFS));
}

//
// compute a weighted score for a given find
//
int CLinkResolver::_ScoreFindData(const WIN32_FIND_DATA *pfd)
{
    int iScore = 0;

    BOOL bSameName = lstrcmpi(_ofd.cFileName, pfd->cFileName) == 0;

    BOOL bSameExt = lstrcmpi(PathFindExtension(_ofd.cFileName), PathFindExtension(pfd->cFileName)) == 0;

    BOOL bHasCreateDate = !IsNullTime(&pfd->ftCreationTime);

    BOOL bSameCreateDate = bHasCreateDate &&
                      IsEqualFileTimesWithTruncation(&pfd->ftCreationTime, &_ofd.ftCreationTime);

    BOOL bSameWriteTime  = !IsNullTime(&pfd->ftLastWriteTime) &&
                      IsEqualFileTimesWithTruncation(&pfd->ftLastWriteTime, &_ofd.ftLastWriteTime);

    if (bSameName || bSameCreateDate)
    {
        if (bSameName)
            iScore += bHasCreateDate ? 16 : 32;

        if (bSameCreateDate)
        {
            iScore += 32;

            if (bSameExt)
                iScore += 8;
        }

        if (bSameWriteTime)
            iScore += 8;

        if (pfd->nFileSizeLow == _ofd.nFileSizeLow)
            iScore += 4;

        // if it is in the same folder as the original give it a slight bonus
        iScore += _iFolderBonus;
    }
    else
    {
        // doesn't have create date, apply different rules

        if (bSameExt)
            iScore += 8;

        if (bSameWriteTime)
            iScore += 8;

        if (pfd->nFileSizeLow == _ofd.nFileSizeLow)
            iScore += 4;
    }

    return iScore;
}

//
//  Helper function for both EnterFolder and FoundFile
//
HRESULT CLinkResolver::_ProcessFoundFile(LPCTSTR pszPath, WIN32_FIND_DATAW * pwfdw)
{
    HRESULT hr = S_OK;

    if (_fFindLnk || !PathIsLnk(pwfdw->cFileName))
    {
        // both are files or folders, see how it scores
        int iScore = _ScoreFindData(pwfdw);

        if (iScore > _iScore)
        {
            _fdFound = *pwfdw;

            // store the score and fully qualified path
            _iScore = iScore;
            lstrcpyn(_fdFound.cFileName, pszPath, ARRAYSIZE(_fdFound.cFileName));
        }
    }

    if ((_iScore >= MIN_NO_UI_SCORE) || (GetTickCount() >= _dwTimeLimit))
    {
        _bContinue = FALSE;
        hr = E_FAIL;
    }
    
    return hr;
}

// IShellTreeWalkerCallBack::FoundFile

HRESULT CLinkResolver::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (!_bContinue)
    {
        return E_FAIL;
    }

    // We should've excluded files if we're looking for a folder
    ASSERT(!(_dwMatch & FILE_ATTRIBUTE_DIRECTORY));

    return _ProcessFoundFile(pwszPath, pwfd);
}

//
// IShellTreeWalkerCallBack::EnterFolder
//
HRESULT CLinkResolver::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hr = S_OK;
    //  Respond quickly to the Cancel button.
    if (!_bContinue)
    {
        return E_FAIL;
    }

    // Once we enter a directory, we lose the "we are still in the starting
    // folder" bonus.
    _iFolderBonus = 0;

    if (PathIsPrefix(pwszPath, _pszSearchOrigin) || IS_SYSTEM_HIDDEN(pwfd->dwFileAttributes))
    {
        // If we're about to enter a directory we've already looked in,
        // or if this is superhidden (implies recycle bin dirs), then skip it.
        return S_FALSE;
    }

    // If our target was a folder, treat this folder as a file found
    if (_dwMatch & FILE_ATTRIBUTE_DIRECTORY)
    {
        hr = _ProcessFoundFile(pwszPath, pwfd);
    }
    return hr;
}

BOOL CLinkResolver::_SearchInFolder(LPCTSTR pszFolder, int cLevels)
{
    int iMaxDepth = 0;

    // cLevels == -1 means inifinite depth
    if (cLevels != -1)
    {
        _dwSearchFlags |= WT_MAXDEPTH;
        iMaxDepth = cLevels;
    }
    else
    {
        _dwSearchFlags &= ~WT_MAXDEPTH;
    }

    // Our folder bonus code lies on the fact that files in the
    // starting folder come before anything else.
    ASSERT(!(_dwSearchFlags & WT_FOLDERFIRST));

    _pstw->WalkTree(_dwSearchFlags, pszFolder, _pwszSearchSpec, iMaxDepth, SAFECAST(this, IShellTreeWalkerCallBack *));
    _iFolderBonus = 0; // You only get one chance at the folder bonus
    return _bContinue;
}

//
// search function for heuristic based link resolution
// the result will be in _fdFound.cFileName
//
void CLinkResolver::_HeuristicSearch()
{
    if (!SHRestricted(REST_NORESOLVESEARCH) &&
        !(SLR_NOSEARCH & _dwResolveFlags) &&
        SUCCEEDED(_InitWalkObject()))
    {
        int cUp = LNKTRACK_HINTED_UPLEVELS;
        BOOL bSearchOrigin = TRUE;
        TCHAR szRealSearchOrigin[MAX_PATH], szFolderPath[MAX_PATH];

        // search up from old location

        // In the olden days pszSearchOriginFirst was verified to be a valid directory
        // (ie it returned TRUE to PathIsDirectory) and _HeuristicSearch was never called
        // if this was not true.  Alas, this is no more.  Why not search the desktop and
        // fixed drives anyway?  In the interest of saving some time the check that used
        // to be in FindInFolder which caused an early out is now here instead.  The rub
        // is that we only skip the downlevel search of the original volume instead of
        // skipping the entire link resolution phase.

        lstrcpy(szRealSearchOrigin, _pszSearchOriginFirst);
        while (!PathIsDirectory(szRealSearchOrigin))
        {
            if (PathIsRoot(szRealSearchOrigin) || !PathRemoveFileSpec(szRealSearchOrigin))
            {
                DebugMsg(DM_TRACE, TEXT("root path does not exists %s"), szRealSearchOrigin);
                bSearchOrigin = FALSE;
                break;
            }
        }

        if (bSearchOrigin)
        {
            lstrcpy(szFolderPath, szRealSearchOrigin);
            _pszSearchOrigin = szRealSearchOrigin;

            // Files found in the starting folder get a slight bonus.
            // _iFolderBonus is set to zero by
            // CLinkResolver::EnterFolder when we leave
            // the starting folder and enter a new one.

            _iFolderBonus = 2;

            while (cUp-- != 0 && _SearchInFolder(szFolderPath, LNKTRACK_HINTED_DOWNLEVELS))
            {
                if (PathIsRoot(szFolderPath) || !PathRemoveFileSpec(szFolderPath))
                    break;
            }
        }

        if (_bContinue)
        {
            // search down from desktop
            if (S_OK == SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szFolderPath))
            {
                _pszSearchOrigin = szFolderPath;
                _SearchInFolder(szFolderPath, LNKTRACK_DESKTOP_DOWNLEVELS);
            }
        }

        if (_bContinue)
        {
            // search down from root of fixed drives
            TCHAR szRoot[4];
            _pszSearchOrigin = szRoot;

            for (int i = 0; _bContinue && (i < 26); i++)
            {
                if (GetDriveType(PathBuildRoot(szRoot, i)) == DRIVE_FIXED)
                {
                    lstrcpy(szFolderPath, szRoot);
                    _SearchInFolder(szFolderPath, LNKTRACK_ROOT_DOWNLEVELS);
                }
            }
        }

        if (_bContinue && bSearchOrigin)
        {
            // resume search of last volume (should do an exclude list)
            lstrcpy(szFolderPath, szRealSearchOrigin);
            _pszSearchOrigin = szRealSearchOrigin;

            while (_SearchInFolder(szFolderPath, -1))
            {
                if (PathIsRoot(szFolderPath) || !PathRemoveFileSpec(szFolderPath))
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shlexec.h ===
//
//  shlexec.h
//  routines and macros shared between the different shell exec files
//


#ifndef SHLEXEC_H
#define SHLEXEC_H

#ifdef __cplusplus
extern "C" {
#endif

#include <krnlcmn.h>

typedef LPSTR LPSZ;
#include "wowshlp.h"

extern LPVOID lpfnWowShellExecCB;

#define CH_GUIDFIRST TEXT('{') // '}'

// These fake ERROR_ values are used to display non-winerror.h available error
// messages. They are mapped to valid winerror.h values in _ShellExecuteError.
#define ERROR_RESTRICTED_APP ((UINT)-1)

#define SEE_MASK_CLASS (SEE_MASK_CLASSNAME|SEE_MASK_CLASSKEY)
#define _UseClassName(_mask) (((_mask)&SEE_MASK_CLASS) == SEE_MASK_CLASSNAME)
#define _UseClassKey(_mask)  (((_mask)&SEE_MASK_CLASS) == SEE_MASK_CLASSKEY)
#define _UseTitleName(_mask) (((_mask)&SEE_MASK_HASTITLE) || ((_mask)&SEE_MASK_HASLINKNAME))

#define SEE_MASK_PIDL (SEE_MASK_IDLIST|SEE_MASK_INVOKEIDLIST)
#define _UseIDList(_mask)     (((_mask)&SEE_MASK_PIDL) == SEE_MASK_IDLIST)
#define _InvokeIDList(_mask)  (((_mask)&SEE_MASK_PIDL) == SEE_MASK_INVOKEIDLIST)
#define _UseHooks(_mask)      (!(pei->fMask & SEE_MASK_NO_HOOKS))

void ActivateHandler(HWND hwnd, DWORD_PTR dwHotKey);
BOOL Window_IsLFNAware(HWND hwnd);

//  routines that need to be moved to CShellExecute
BOOL DoesAppWantUrl(LPCTSTR lpszFullPathToApp);
HWND _FindPopupFromExe(LPTSTR lpExe);
HINSTANCE Window_GetInstance(HWND hwnd);
BOOL RestrictedApp(LPCTSTR pszApp);
BOOL DisallowedApp(LPCTSTR pszApp);
BOOL CheckAppCompatibility(LPCTSTR pszApp, LPCTSTR *ppszNewEnvString, BOOL fNoUI, HWND hwnd);
HRESULT TryShellExecuteHooks(LPSHELLEXECUTEINFO pei);
void RegGetValue(HKEY hkRoot, LPCTSTR lpKey, LPTSTR lpValue);
UINT ReplaceParameters(LPTSTR lpTo, UINT cchTo, LPCTSTR lpFile,
        LPCTSTR lpFrom, LPCTSTR lpParms, int nShow, DWORD * pdwHotKey, BOOL fLFNAware,
        LPCITEMIDLIST lpID, LPITEMIDLIST *ppidlGlobal);


DWORD ShellExecuteNormal(LPSHELLEXECUTEINFO pei);
void _DisplayShellExecError(ULONG fMask, HWND hwnd, LPCTSTR pszFile, LPCTSTR pszTitle, DWORD dwErr);
BOOL InRunDllProcess(void);

// in exec2.c
int FindAssociatedExe(HWND hwnd, LPTSTR lpCommand, UINT cchCommand, LPCTSTR pszDocument, HKEY hkeyProgID);

#ifdef __cplusplus
}
#endif

#endif // SHLEXEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shellvm.h ===
/******************************************************************************
 *
 *  (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *  Title:      SHELL header file
 *
 *  Version:    2.00
 *
 *  Date:       2-06-89
 *
 *  Author:     ARR
 *
 *******************************************************************************
 *
 *  Change log:
 *
 *    DATE    REVISION                  DESCRIPTION
 *  --------  --------  -------------------------------------------------------
 *  06-Feb-1989 ARR     Original
 *  28-Feb-1992 rjc     Partially converted from inc to h file. 
 *  25-Sep-1992 rjc     Change old-style ULONG/USHORT into modern DWORD/WORD
 *
 *==============================================================================
 */

/*
 * All directed VM hot keys are PriorityNotify.  This is the timeout for them.
 * If it takes longer than this many milliseconds, the key is discarded.
 *
 *   0 means no time out
 */
#define KEYTIMEOUT      4000    /* 4 sec, long enough for floppy operations */

/*
 * This is the structure of the PIF file hot key information.
 *
 *  The bits of Val are as follows:
 *
 *      bit 0 (value 1) = key is an extended key
 *
 *          This tells us whether or not to look for an E0 prefix.
 *
 *      bit 1 (value 2) = key requires NumLock down (new for 4.0)
 *
 *          This tells us whether to treat scan code 047h as
 *          VK_HOME or VK_NUMPAD7.
 */

#define MAXHKYINFOSIZE          16

/* H2INCSWITCHES -t */
typedef struct PIFKEY { /* PIF_Ky */
        WORD    Scan;   /* Scan code in lower byte */
        WORD    ShVal;  /* Shift state */
        WORD    ShMsk;  /* Mask for shift states interested in */
        BYTE    Val;    /* Enhanced key stuff */
        BYTE    Pad[9]; /* Pad PIF struc to MAXHKYINFOSIZE bytes */
} PIFKEY;
typedef UNALIGNED PIFKEY *LPPIFKEY;
typedef const UNALIGNED PIFKEY *LPCPIFKEY;

/* ASM
.errnz  SIZE PIFKEY - MAXHKYINFOSIZE
 */

/*
 * PIF_Ky_Val
 *      = 1, if extended code   (key is an extended code only)
 *      = 0FFh, if either       (key is EITHER extended or not extended)
 *      = 0  if not extended    (key is not extended only)
 *
 *          bit 15 - Ins depressed
 *          bit 14 - Caps Lock depressed
 *          bit 13 - Num Lock depressed
 *          bit 12 - Scroll Lock depressed
 *          bit 11 - hold state active(Ctrl-Num Lock)
 *          bit 10 - 0
 *          bit  9 - 0
 *          bit  8 - 0
 *          bit  7 - Insert state active
 *          bit  6 - Caps Lock state active
 *          bit  5 - Num Lock state active
 *          bit  4 - Scroll Lock state active
 *          bit  3 - Alt shift depressed
 *          bit  2 - Ctrl shift depressed
 *          bit  1 - left shift depressed
 *          bit  0 - right shift depressed
 */
#define fPIFSh_RShf     0x0001          /* Right shift key */
#define fPIFSh_RShfBit  0

#define fPIFSh_LShf     0x0002          /* Left shift key */
#define fPIFSh_LShfBit  1

#define fPIFSh_Ctrl     0x0004          /* Either Control shift key */
#define fPIFSh_CtrlBit  2

#define fPIFSh_Alt      0x0008          /* Either Alt shift key */
#define fPIFSh_AltBit   3

#define fPIFSh_ScLok    0x0010          /* Scroll lock active */
#define fPIFSh_ScLokBit 4

#define fPIFSh_NmLok    0x0020          /* Num lock active */
#define fPIFSh_NmLokBit 5

#define fPIFSh_CpLok    0x0040          /* Caps lock active */
#define fPIFSh_CpLokBit 6

#define fPIFSh_Insrt    0x0080          /* Insert active */
#define fPIFSh_InsrtBit 7

#define fPIFSh_Ext0     0x0400          /* Extended K/B shift */
#define fPIFSh_Ext0Bit  10

#define fPIFSh_Hold     0x0800          /* Ctrl-Num-Lock/Pause active */
#define fPIFSh_HoldBit  11

#define fPIFSh_LAlt     0x1000          /* Left Alt key is down */
#define fPIFSh_LAltBit  12

#define fPIFSh_RAlt     0x2000          /* Right Alt key is down */
#define fPIFSh_RAltBit  13

#define fPIFSh_LCtrl    0x4000          /* Left Ctrl key is down */
#define fPIFSh_LCtrlBit 14

#define fPIFSh_RCtrl    0x8000          /* Right Ctrl key is down */
#define fPIFSh_RCtrlBit 15

#define MAXVMTITLELENGTH        32      /* Size of name buffer */
#define PIFNAMESIZE     30              /* Amount of buffer actually used */

/*
 * VM descriptor structure used to create and modify VM attributes.
 *
 */
/* H2INCSWITCHES -t- */
struct VM_Descriptor {
        DWORD   VD_Flags;       /* Flags                                */
        DWORD   VD_Flags2;      /* More Flags                           */
        DWORD   VD_ProgName;    /* Pointer to program name              */
        WORD    VD_ProgNameSeg; /*                                      */
        DWORD   VD_CmdLine;     /* Command line ptr                     */
        WORD    VD_CmdLineSeg;  /*                                      */
        DWORD   VD_DrivePath;   /* Current drive and dir ptr            */
        WORD    VD_DrivePathSeg;/*                                      */
        WORD    VD_MaxMem;      /* Maximum VM memory in Kb              */
        WORD    VD_MinMem;      /* Minimum VM memory in Kb              */
        WORD    VD_FPriority;   /* Priority of process when FOCUS       */
        WORD    VD_BPriority;   /* Priority of process when Not FOCUS   */
        WORD    VD_MaxEMSMem;   /* Maximum EMS memory in Kb             */
        WORD    VD_MinEMSMem;   /* Minimum EMS memory in Kb             */
        WORD    VD_MaxXMSMem;   /* Maximum XMS (extended) memory in Kb  */
        WORD    VD_MinXMSMem;   /* Minimum XMS (extended) memory in Kb  */
        WORD    VD_WindHand;    /* Window handle of VMDOSAPP instance   */
        WORD    VD_InstHand;    /* Instance handle of VMDOSAPP instance */
        BYTE    VD_Title[MAXVMTITLELENGTH]; /* Title of app             */
        PIFKEY  VD_HotKeyBuf;   /* Buffer for Hot key spec  */
};

/* ASM
;
; Access the MaxMem and MinMem fields as a single DWORD.
;
VD_VMSize       equ     DWORD PTR VD_MaxMem

*/

/* ASM
ifndef MASM6
IF2
    IFDEF VMStat_Exclusive_Bit
    .erre VD_F_ExclusiveBit    EQ VMStat_Exclusive_Bit
    .erre VD_F_BackgroundBit   EQ VMStat_Background_Bit
    ENDIF
ENDIF
else  ; MASM6
    IFDEF VMStat_Exclusive_Bit
    .erre VD_F_ExclusiveBit    EQ VMStat_Exclusive_Bit
    .erre VD_F_BackgroundBit   EQ VMStat_Background_Bit
    ENDIF
endif ; MASM6
*/

/*
 * Masks and bit numbers for VD_Flags
 *
 */
#define VD_F_ExclusiveBit       0       /* This bit indicates that when the VM
                                         * has the focus it has Exclusive use
                                         * of the CPU.
                                         */
#define VD_F_Exclusive          (1L << VD_F_ExclusiveBit)

#define VD_F_BackgroundBit      1       /* This bit indicates that when the VM
                                         * does not have the focus it continues
                                         * to get CPU time. If this bit is
                                         * clear the VM is effectively
                                         * suspended unless it has the
                                         * input focus.
                                         */
#define VD_F_Background         (1L << VD_F_BackgroundBit)

#define VD_F_WindowBit          2       /* This bit indicates that the VM
                                         * runs in a window.
                                         * If the bit is clear the VM is a
                                         * full screen VM.
                                         */
#define VD_F_Window             (1L << VD_F_WindowBit)

/* VD_F_Window2 is set if the VDD thinks that the VM is         ;Internal
 * running in a window.  This bit is only if...                 ;Internal
 *      1.  The VM is running in a window.                      ;Internal
 *      2.  The VM is not minimized.                            ;Internal
 *      3.  The VM's client area is visible.                    ;Internal
 * This is different from VD_F_Window, which is set iff the     ;Internal
 * VM is running in a window, possible minimized or obscured.   ;Internal
 * We lie to the VDD so that it won't try to track the VM's     ;Internal
 * display when there is no reason to do so.                    ;Internal
 */                                                          /* ;Internal */
#define VD_F_Window2Bit         3                            /* ;Internal */
#define VD_F_Window2            (1L << VD_F_Window2Bit)      /* ;Internal */
                                                             /* ;Internal */
#define VD_F_SuspendedBit       4       /* Set if app suspended by VMDOSAPP */
#define VD_F_Suspended          (1L << VD_F_SuspendedBit)

#define VD_F_ALTTABdisBit       5       /* Set if the Standard
                                         * ALT-TAB Hot key is disabled for
                                         * this VM.
                                         */
#define VD_F_ALTTABdis          (1L << VD_F_ALTTABdisBit)

#define VD_F_ALTESCdisBit       6       /* Set if the Standard
                                         * ALT-ESC Hot key is disabled for
                                         * this VM.
                                         */
#define VD_F_ALTESCdis          (1L << VD_F_ALTESCdisBit)

#define VD_F_ALTSPACEdisBit     7       /* Set if the Standard
                                         * ALT-SPACE Hot key is disabled for
                                         * this VM.
                                         */
#define VD_F_ALTSPACEdis        (1L << VD_F_ALTSPACEdisBit)

#define VD_F_ALTENTERdisBit     8       /* Set if the Standard
                                         * ALT-ENTER Hot key is disabled for
                                         * this VM.
                                         */
#define VD_F_ALTENTERdis        (1L << VD_F_ALTENTERdisBit)

#define VD_F_ALTPRTSCdisBit     9       /* Set if the Standard
                                         * ALT-PRTSC Hot key is disabled for
                                         * this VM.
                                         */
#define VD_F_ALTPRTSCdis        (1L << VD_F_ALTPRTSCdisBit)

#define VD_F_PRTSCdisBit        10      /* Set if the Standard
                                         * PRTSC Hot key is disabled for
                                         * this VM.
                                         */
#define VD_F_PRTSCdis           (1L << VD_F_PRTSCdisBit)

#define VD_F_CTRLESCdisBit      11      /* Set if the Standard
                                         * CTRL-ESC Hot key is disabled for
                                         * this VM.
                                         */
#define VD_F_CTRLESCdis         (1L << VD_F_CTRLESCdisBit)

#define VD_F_PollingDetectBit   12      /* Set if the polling
                                         * detection is allowed for this VM
                                         */
#define VD_F_PollingDetect      (1L << VD_F_PollingDetectBit)

#define VD_F_NoHMABit           13      /* Set if access to
                                         * the XMS HMA is disallowed in
                                         * this VM.
                                         */
#define VD_F_NoHMA              (1L << VD_F_NoHMABit)

#define VD_F_HasHotKeyBit       14      /* Set if this app
                                         * has specified a hot key in
                                         * this VM.
                                         */
#define VD_F_HasHotKey          (1L << VD_F_HasHotKeyBit)

#define VD_F_EMS_Is_LockBit     15      /* Set if XMS memory
                                         * should be locked in this VM.
                                         */
#define VD_F_EMS_Is_Lock        (1L << VD_F_EMS_Is_LockBit)

#define VD_F_XMS_Is_LockBit     16      /* Set if EMS memory
                                         * should be locked in this VM.
                                         */
#define VD_F_XMS_Is_Lock        (1L << VD_F_XMS_Is_LockBit)

#define VD_F_INT16PasteBit      17      /* Paste via INT 16 is OK */
#define VD_F_INT16Paste         (1L << VD_F_INT16PasteBit)

#define VD_F_VMLockedBit        18      /* VM is to be Always LOCKED. */
#define VD_F_VMLocked           (1L << VD_F_VMLockedBit)

#define VD_F_IsBatchBit         19      /* VM is a .BAT file run */
#define VD_F_IsBatch            (1L << VD_F_IsBatchBit)

                                                                        /* ;Internal */
#define VD_F_VolumeLockBit      27      /* Owns a level 3 volume lock *//* ;Internal */
#define VD_F_VolumeLock         (1L << VD_F_VolumeLockBit)              /* ;Internal */
                                                                        /* ;Internal */
#define VD_F_IsTextBit          28      /* Am in a text mode */         /* ;Internal */
#define VD_F_IsText             (1L << VD_F_IsTextBit)                  /* ;Internal */
                                                                        /* ;Internal */
#define VD_F_DynaWindowBit      29      /* Auto switch when in graphics mode */
#define VD_F_DynaWindow         (1L << VD_F_DynaWindowBit)

#define VD_F_ExitCloseBit       30      /* VM is to be closed on exit */
#define VD_F_ExitClose          (1L << VD_F_ExitCloseBit)

#define VD_F_PastingBit         31      /* VM is pasting also used for hot key
                                         * flag
                                         */
#define VD_F_Pasting            (1L << VD_F_PastingBit)

/*
 * Following bits are bits for the VDD to interpret in VD_Flags2
 */

#define VD_F2_VDDPrivMask       0x0000FFFF
#define VD_F2_VDDPrivMinBit     0
#define VD_F2_VDDPrivMaxBit     15

/* Validate the above three defines */

#if ((1 << (1+VD_F2_VDDPrivMaxBit))-1) - ((1 << VD_F2_VDDPrivMinBit)-1) != VD_F2_VDDPrivMask
/* XLATOFF */
#error VD_F2_VDDPrivMask conflicts with MaxBit and MinBit.
/* XLATON */
/* ASM
%OUT   VD_F2_VDDPrivMask conflicts with MaxBit and MinBit.
.err
 */
#endif

#define VD_F2_DynaWindowingBit  16      /* Internal semaphore */
#define VD_F2_DynaWindowIng     (1L << VD_F2_DynaWindowingBit)
#define VD_F2_DynaWaitingBit    17      /* Internal semaphore */
#define VD_F2_DynaWaiting       (1L << VD_F2_DynaWaitingBit)

/*
 * These are the bits of VD_Flags which are "exported" to the outside world
 *   via the SHELL_GetVMInfo service
 */
/* XLATOFF */
#define VD_Flags_Exported (VD_F_Window+VD_F_ALTTABdis+VD_F_ALTESCdis+\
                          VD_F_ALTSPACEdis+VD_F_ALTENTERdis+VD_F_ALTPRTSCdis+\
                          VD_F_PRTSCdis+VD_F_CTRLESCdis+VD_F_PollingDetect+\
                          VD_F_NoHMA+VD_F_HasHotKey+VD_F_EMS_Is_Lock+\
                          VD_F_XMS_Is_Lock+VD_F_INT16Paste+VD_F_VMLocked+\
                          VD_F_ExitClose)
/* XLATON */
/* ASM
VD_Flags_Exported   equ   (VD_F_Window+VD_F_ALTTABdis+VD_F_ALTESCdis+\
                          VD_F_ALTSPACEdis+VD_F_ALTENTERdis+VD_F_ALTPRTSCdis+\
                          VD_F_PRTSCdis+VD_F_CTRLESCdis+VD_F_PollingDetect+\
                          VD_F_NoHMA+VD_F_HasHotKey+VD_F_EMS_Is_Lock+\
                          VD_F_XMS_Is_Lock+VD_F_INT16Paste+VD_F_VMLocked+\
                          VD_F_ExitClose)
*/

#ifdef  DOS7                                                            /* ;Internal */
#define VD_Flags2_Exported VD_F2_CreateVisible                          /* ;Internal */
#else                                                                   /* ;Internal */
#define VD_Flags2_Exported 0
#endif                                                                  /* ;Internal */

/*
 * Special exit codes
 *
 *  VMDA_EXIT_ExecFail can trigger for the following reasons:
 *
 *      An ugly TSR is present in the system.
 *      You are in clean-boot mode.
 *      Administration restrictions forbid DOS boxes.
 *                                                                  ;Internal
 *  NOTE!  If you add a new exit code, make sure to adjust the call ;Internal
 *  to WOAAbort in ttywin.asm accordingly!                          ;Internal
 */
#define VMDA_EXIT_NoFile        0x81    /* File not found */
#define VMDA_EXIT_NoMem         0x82    /* Insufficient memory */
#define VMDA_EXIT_Crash         0x83    /* Application terminated abnormally */
#define VMDA_EXIT_BadVer        0x84    /* Mismatched system components */
#define VMDA_EXIT_ExecFail      0x85    /* Could not run due to incompatible
                                         * system configuration.
                                         */

/*
 * These are the ordinals for the Shell-exported V86-mode and protect-mode
 * services.
 *
 */

#define SHSV_Get_Version                0x0100
#define SHSV_Install_New_Task_Manager   0x0101
#define SHSV_ShellExecute               0x0102
#define SHSV_WinExecWait                0x0103
#define SHSV_Enumerate_Properties       0x0104
#define SHSV_Update_Properties          0x0105
#define SHSV_Set_ScreenSaver_Info       0x0106
#define SHSV_Get_VxD_Version            0x0107

#define NUMSHELLSERVICES                8

/* H2INCSWITCHES -t */
typedef struct TaskManagerDescriptorBlock { /* TMDB */
        DWORD   TaskManNameOffs;
        WORD    TaskManNameSeg;
        DWORD   ProgNameOffs;
        WORD    ProgNameSeg;
        DWORD   CmdLineOffs;
        WORD    CmdLineSeg;
        DWORD   DrivePathOffs;
        WORD    DrivePathSeg;
} TMDB;

#define TMDBSTRINGCOUNT           4
#define MAXTMDBSTRINGLENGTH     128     /* 127 chars + terminating 0 */

/*
 * Error values for WinExecWait.
 */
#define ERR_WEW_FIRST           0x0100
#define ERR_WEW_INSMEM          0x0100  /* Insufficient memory */
#define ERR_WEW_NOTASK          0x0101  /* No such task, or task is Win32 */
#define ERR_WEW_TOOLHELP        0x0102  /* Could not load TOOLHELP */
#define ERR_WEW_LAST            0x0102  /* ;Internal */

/*
 * Definitions for the VM Close API.
 */
#define VMCLFL_ENABLECLOSE      1

#ifndef V86MODE

#ifdef  TASKMAN
/*
 * Structure for installable task managers to notify the Shell VxD
 * which services they want to hook.
 */
typedef struct TMHandlers {             /* TMH */
        DWORD   Len;
        PVOID   Resolve_Contention_Pre;
        PVOID   Resolve_Contention_Post;
        PVOID   Event;
        PVOID   Sysmodal_Message_Pre;
        PVOID   Sysmodal_Message_Post;
        PVOID   Message_Pre;
        PVOID   Message_Post;
        PVOID   Svc_Call;
        PVOID   Clipboard;
        PVOID   Not_Executeable;
        PVOID   Set_Focus;
        PVOID   HotKey;
        PVOID   PostMessage;
        PVOID   ShellExecute;
        PVOID   CallDll;
        PVOID   VmTitle;
        PVOID   VmClose;
        PVOID   QueryAppyTimeAvailable;
        PVOID   CallAtAppyTime;
        PVOID   CancelAppyTimeEvent;
        PVOID   BroadcastSystemMessage;
        PVOID   HookSystemBroadcast;
        PVOID   UnhookSystemBroadcast;
        PVOID   LocalAllocEx;
        PVOID   LocalFree;
        PVOID   LoadLibrary;
        PVOID   FreeLibrary;
        PVOID   GetProcAddress;
        PVOID   DispatchRing0AppyEvents;
} TMH;

/*
 * This is the structure the SHELL_Install_TaskMan_Hooks returns a pointer to.
 *
 * It is an array of pointers to helper functions provided by the Shell VxD
 * to task managers.  These helper functions are not exported as services
 * because they expose the sensitive innards of the Shell VxD.
 */
typedef struct SHHandlers {             /* SHH */
        PVOID   GetVmDescriptor;
        PVOID   RegisterVMHotKey;
        PVOID   DisplayMessage;
} SHH;
#endif

/*
 * When expanding this structure, make sure to PREPEND fields, so as to
 * retain backwards compatibility.
 */
typedef struct VM_Desc2 {               /* VD2 */
        DWORD   phvmOwner;              /* Back-pointer to owner */
        BYTE    Err_Code;               /* Error code for Exec failure */
        BYTE    Exit_Code;              /* Exit code */
} VM_Desc2;

/* ASM
;
; Potentially handy abbreviation so you can say
;
;       call    [SHELL_GetVmDescriptor]
;       mov     eax, [eax.MVM_Desc2.VD2_HotKeyHandle]
;
MVM_Desc2       =       - SIZE VM_Desc2

 */


#endif /* ifndef V86MODE */

#define MAX_DLL_NAME    80
#ifndef MAX_GROUP_NAME
#define MAX_GROUP_NAME  16
#else
#if     MAX_GROUP_NAME != 16
#error  Invalid definition of MAX_GROUP_NAME.
#endif
#endif

/* H2INCSWITCHES -t- */
struct PropID {
        DWORD   ordGroup;
        BYTE    achGroup[MAX_GROUP_NAME];
        BYTE    achDLL[MAX_DLL_NAME];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shitemid.h ===
#ifndef _WINNETWK_
#include <winnetwk.h>
#endif // _WINNETWK_

// NOTE: these values can never change. they define the format of IDLIST that
// may be persisted in .lnk files and elsewhere.

#define SHID_JUNCTION           0x80

#define SHID_GROUPMASK          0x70
#define SHID_TYPEMASK           0x7f
#define SHID_INGROUPMASK        0x0f

#define SHID_ROOT               0x10
#define SHID_ROOT_REGITEM       0x1f    // MyDocuments, Internet, etc

#if ((DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK) != 0x07)
#error Definitions of DRIVE_* are changed!
#endif

#define SHID_COMPUTER           0x20
#define SHID_COMPUTER_1         0x21    // free
#define SHID_COMPUTER_REMOVABLE (0x20 | DRIVE_REMOVABLE)  // 2
#define SHID_COMPUTER_FIXED     (0x20 | DRIVE_FIXED)      // 3
#define SHID_COMPUTER_REMOTE    (0x20 | DRIVE_REMOTE)     // 4
#define SHID_COMPUTER_CDROM     (0x20 | DRIVE_CDROM)      // 5
#define SHID_COMPUTER_RAMDISK   (0x20 | DRIVE_RAMDISK)    // 6
#define SHID_COMPUTER_7         0x27    // free
#define SHID_COMPUTER_DRIVE525  0x28    // 5.25 inch floppy disk drive
#define SHID_COMPUTER_DRIVE35   0x29    // 3.5 inch floppy disk drive
#define SHID_COMPUTER_NETDRIVE  0x2a    // Network drive
#define SHID_COMPUTER_NETUNAVAIL 0x2b   // Network drive that is not restored.
#define SHID_COMPUTER_C         0x2c    // free
#define SHID_COMPUTER_D         0x2d    // free
#define SHID_COMPUTER_REGITEM   0x2e    // Controls, Printers, ...
#define SHID_COMPUTER_MISC      0x2f    // Unknown drive type

#define SHID_FS                   0x30  // base simple IDList, we don't generate these anymore
#define SHID_FS_TYPEMASK          0x37
#define SHID_FS_DIRECTORY         0x31  // WINDOWS (a folder)
#define SHID_FS_FILE              0x32  // FOO.TXT (a file)
#define SHID_FS_UNICODE           0x34  // unicode (this is a bitmask)
#define SHID_FS_DIRUNICODE        0x35  // Folder with a unicode name
#define SHID_FS_FILEUNICODE       0x36  // File with a unicode name
#define SHID_FS_COMMONITEM        0x38  // Common item ("8" is the bit)
#define SHID_FS_COMMONDIRECTORY   0x39  // Common directory (ansi)
#define SHID_FS_COMMONFILE        0x3a  // Common file (ansi)
#define SHID_FS_COMMONDIRUNICODE  0x3d  // Common folder with a unicode name
#define SHID_FS_COMMONFILEUNICODE 0x3e  // Common file with a unicode name


#define SHID_NET                0x40
#define SHID_NET_DOMAIN         (SHID_NET | RESOURCEDISPLAYTYPE_DOMAIN)         // 0x41
#define SHID_NET_SERVER         (SHID_NET | RESOURCEDISPLAYTYPE_SERVER)         // 0x42
#define SHID_NET_SHARE          (SHID_NET | RESOURCEDISPLAYTYPE_SHARE)          // 0x43
#define SHID_NET_FILE           (SHID_NET | RESOURCEDISPLAYTYPE_FILE)           // 0x44
#define SHID_NET_GROUP          (SHID_NET | RESOURCEDISPLAYTYPE_GROUP)          // 0x45
#define SHID_NET_NETWORK        (SHID_NET | RESOURCEDISPLAYTYPE_NETWORK)        // 0x46
#define SHID_NET_RESTOFNET      (SHID_NET | RESOURCEDISPLAYTYPE_ROOT)           // 0x47
#define SHID_NET_SHAREADMIN     (SHID_NET | RESOURCEDISPLAYTYPE_SHAREADMIN)     // 0x48
#define SHID_NET_DIRECTORY      (SHID_NET | RESOURCEDISPLAYTYPE_DIRECTORY)      // 0x49
#define SHID_NET_TREE           (SHID_NET | RESOURCEDISPLAYTYPE_TREE)           // 0x4A
#define SHID_NET_NDSCONTAINER   (SHID_NET | RESOURCEDISPLAYTYPE_NDSCONTAINER)   // 0x4B
#define SHID_NET_REGITEM        0x4d    // RegItem in either Entire Net, or the Root
#define SHID_NET_REMOTEREGITEM  0x4e    // Remote Computer items
#define SHID_NET_PRINTER        0x4f    // \\PYREX\LASER1

#ifndef SHID_LOC
// this group is for location items.
// they are defined in inc\shellp.h
#define SHID_LOC                0x50
#define SHID_LOC_TYPEMASK       0x5F
#endif

#define SHID_CONTROLPANEL_REGITEM       0x70
#define SHID_CONTROLPANEL_REGITEM_EX    0x71

#define SIL_GetType(pidl)       (ILIsEmpty(pidl) ? 0 : (pidl)->mkid.abID[0])
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shellprv.h ===
#ifndef _SHELLPRV_H_
#define _SHELLPRV_H_

// We now always rely on Win2k or Millennium at least.
#define OVERRIDE_SHLWAPI_PATH_FUNCTIONS     // see comment in shsemip.h

#define _SHELL32_
#define _WIN32_DCOM     // for COINIT_DISABLE_OLE1DDE

#ifdef __cplusplus
#define NO_INCLUDE_UNION
#endif  /* __cplusplus */

#define NOWINDOWSX
#ifndef STRICT
#define STRICT
#endif
#define OEMRESOURCE // FSMenu needs the menu triangle

#define INC_OLE2
#define CONST_VTABLE

// Disable a few warnings so we can include the system header files at /W4.
#include "w4warn.h"
#pragma warning(disable:4706) // assignment within conditional expression
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4131) // 'CreateInfoFile' : uses old-style declarator
#pragma warning(disable:4221) // nonstandard extension used : 'pFrom' : cannot be initialized using address of automatic variable 'szBBPathToNuke'
#pragma warning(disable:4245) // 'initializing' : conversion from 'const int' to 'const DWORD', signed/unsigned mismatch
#pragma warning(disable:4057) // '=' : 'CHAR *' differs in indirection to slightly different base types from 'PBYTE '
#pragma warning(disable:4189) // 'fWrite' : local variable is initialized but not referenced
#pragma warning(disable:4701) // local variable 'lListIndex' may be used without having been initialized
#pragma warning(disable:4213) // nonstandard extension used : cast on l-value
#pragma warning(disable:4702) // unreachable code
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4210) // nonstandard extension used : function given file scope
#pragma warning(disable:4055) // 'type cast' : from data pointer 'IDataObject *' to function pointer 'FARPROC '
#pragma warning(disable:4267) // '=' : conversion from 'size_t' to 'UINT', possible loss of data
#pragma warning(disable:4328) // indirection alignment of formal parameter 4 (2) is greater than the actual argument alignment (1)

//  These NT headers must come before <windows.h> or you get redefinition
//  errors!  It's a miracle the system builds at all...
#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */
#include <nt.h>         // Some of the NT specific code needs Rtl functions
#include <ntrtl.h>      // which requires all of these header files...
#include <nturtl.h>
#include <ntseapi.h>
#include <dfsfsctl.h>

#ifdef __cplusplus
}       /* End of extern "C" */
#endif  /* __cplusplus */

#define CC_INTERNAL   // this is because docfind uses the commctrl internal prop sheet structures

//--------------------------------------------------------------------------
//
//  The order of these is critical for ATL.
//
//  1.  ATL has its own definition of InlineIsEqualGUID that conflicts with
//      the definition in <objbase.h>, so we must explicitly include
//      <ole2.h> to get the <objbase.h> definition, then use a hacky macro
//      to disable the ATL version so it doesn't conflict with the OLE one.
//
//  2.  ATL has methods called SubclassWindow, which conflicts with a
//      macro in <windowsx.h>, so we must include <windowsx.h> after ATL.
//
//  3.  We want ATL to use the shell debug macros, so we must include
//      <debug.h> before ATL so it can see the shell debug macros.
//
//  4.  VariantInit is such a trivial function that we inline it in order
//      to avoid pulling in OleAut32.
//
//  5.  We want ATL to use the shell version of the ANSI/UNICODE conversion
//      functions (because the shell versions can be called from C).
//

#include <oaidl.h>
#include <docobj.h>

#include <windows.h>
#include "shfusion.h"
#include <ole2.h>           // Get the real InlineIsEqualGUID
#define _ATL_NO_DEBUG_CRT   // Use the shell debug macros
#include <stddef.h>
#include <debug.h>          // Get the shell debug macros
#include <shconv.h>         // Shell version of <atlconv.h>
 

#define VariantInit(p) memset(p, 0, sizeof(*(p)))

#ifdef __cplusplus

#define _ATL_APARTMENT_THREADED

#ifndef _SYS_GUID_OPERATORS_
// Re-route the ATL version of InlineIsEqualGUID
#define InlineIsEqualGUID ATL_InlineIsEqualGUID
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>
#include <atliface.h>
#include <atlwin.h>

#ifndef _SYS_GUID_OPERATORS_
#undef InlineIsEqualGUID    // Return InlineIsEqualGUID to its normal state
#endif

#include <memt.h>

#endif  /* __cplusplus */

// end of ATL Stuff
//--------------------------------------------------------------------------
#ifndef _SYS_GUID_OPERATORS_
#ifdef _OLE32_ // {
// turning on _OLE32_ (which we did for delay load stuff) gives us f-a-t
// versions of IsEqualGUID.  undo that here (hack on top of a hack...)
#undef IsEqualGUID
#ifdef __cplusplus
__inline BOOL IsEqualGUID(IN REFGUID rguid1, IN REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
#else   //  ! __cplusplus
#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#endif  //  __cplusplus
#endif // }
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// This flag indicates that we are on a system where data alignment is a concern

#if (defined(UNICODE) && (defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)))
#define ALIGNMENT_SCENARIO
#endif

#include <windowsx.h>
#include <winnetp.h>

//  Dependencies among header files:
//
//      <oaidl.h> must come before <shlwapi.h> if you want to have
//      OLE command target helper functions.
//
#include <hlink.h> // must include before shellp in order to get IBrowserService2!
#include <commctrl.h>
#include <shellapi.h>
#include <wininet.h>
#include <shlobj.h>

#include <shlwapi.h>
#include <commdlg.h>
#include <port32.h>         // in    shell\inc
#define DISALLOW_Assert
#include <linkinfo.h>
#include <shlobjp.h>
#include <shsemip.h>
#include <docobj.h>
#include <shguidp.h>
#include <ieguidp.h>
#include <shellp.h>
#include <shdocvw.h>
#include <iethread.h>
#include "browseui.h"
#include <ccstock.h>
#include <ccstock2.h>
#include <objidl.h>
#include "apithk.h"
#define SECURITY_WIN32
#include <security.h>
#include <mlang.h>
#include <krnlcmn.h>    // GetProcessDword
#include <regapix.h>        // MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH
#include <heapaloc.h>
#include <fmifs.h>


#include "util.h"
#include "varutil.h"
#include "cstrings.h"
#include "securent.h"
#include "winprtp.h"

#include "qistub.h"
#ifdef DEBUG
#include "dbutil.h"
#endif

#define CP_HEBREW        1255
#define CP_ARABIC        1256

EXTERN_C const ITEMIDLIST c_idlDesktop;   // NULL IDList

#undef CharNext
#undef CharPrev

#define CharNext(x) ((x)+1)
#define CharPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) ((x), FALSE)

// these functions are not available on NT
#undef ReinitializeCriticalSection
#undef LoadLibrary16
#undef FreeLibrary16
#undef GetProcAddress16
#define ReinitializeCriticalSection #error_ReinitializeCriticalSection_not_available_on_NT
#define LoadLibrary16 #error_LoadLibrary16_not_available_on_NT
#define FreeLibrary16 #error_FreeLibrary16_not_available_on_NT
#define GetProcAddress16 #error_GetProcAddress16_not_available_on_NT
#define GetModuleHandle16(sz) (0)
#define GetModuleFileName16(hinst, buf, cch) buf[0]='\0'

DWORD
SetPrivilegeAttribute(
    IN  LPCTSTR PrivilegeName,
    IN  DWORD   NewPrivilegeAttributes,
    OUT DWORD   *OldPrivilegeAttribute
    );


// drivesx.c
BOOL IsUnavailableNetDrive(int iDrive);
BOOL IsDisconnectedNetDrive(int iDrive);
BOOL IsAudioDisc(LPTSTR pszDrive);
BOOL IsDVDDisc(int iDrive);

// futil.c
BOOL  IsShared(LPNCTSTR pszPath, BOOL fUpdateCache);
DWORD GetConnection(LPCTSTR lpDev, LPTSTR lpPath, UINT cbPath, BOOL bConvertClosed);

// rundll32.c
HWND _CreateStubWindow(POINT* ppt, HWND hwndParent);
#define STUBM_SETDATA       (WM_USER)
#define STUBM_GETDATA       (WM_USER + 1)
#define STUBM_SETICONTITLE  (WM_USER + 2)

#define STUBCLASS_PROPSHEET     1
#define STUBCLASS_FORMAT        2

// shlexe.c
BOOL IsDarwinEnabled();
STDAPI ParseDarwinID(LPTSTR pszDarwinDescriptor, LPTSTR pszDarwinCommand, DWORD cchDarwinCommand);

// shprsht.c
typedef struct {
    HWND    hwndStub;
    HANDLE  hClassPidl;
    HICON   hicoStub;
} UNIQUESTUBINFO;
STDAPI_(BOOL) EnsureUniqueStub(LPITEMIDLIST pidl, int iClass, POINT *ppt, UNIQUESTUBINFO *pusi);
STDAPI_(void) FreeUniqueStub(UNIQUESTUBINFO *pusi);
STDAPI_(void) SHFormatDriveAsync(HWND hwnd, UINT drive, UINT fmtID, UINT options);

// bitbuck.c
void  RelayMessageToChildren(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
BOOL IsFileInBitBucket(LPCTSTR pszPath);

BOOL CreateWriteCloseFile(HWND hwnd, LPCTSTR pszFileName, void *pv, DWORD cbData);

// idlist.c
STDAPI_(BOOL) SHIsValidPidl(LPCITEMIDLIST pidl);

STDAPI_(BOOL) IsExeTSAware(LPCTSTR pszExe);

// exec stuff

/* common exe code with error handling */
#define SECL_USEFULLPATHDIR     0x00000001
#define SECL_NO_UI              0x00000002
#define SECL_SEPARATE_VDM       0x00000004
#define SECL_LOG_USAGE          0x00000008
BOOL ShellExecCmdLine(HWND hwnd, LPCTSTR lpszCommand, LPCTSTR lpszDir,
        int nShow, LPCTSTR lpszTitle, DWORD dwFlags);
#define ISSHELLEXECSUCCEEDED(hinst) ((UINT_PTR)hinst>32)
#define ISWINEXECSUCCEEDED(hinst)   ((UINT_PTR)hinst>=32)
void _ShellExecuteError(LPSHELLEXECUTEINFO pei, LPCTSTR lpTitle, DWORD dwErr);

// fsnotify.c (private stuff) ----------------------

BOOL SHChangeNotifyInit();
STDAPI_(void) SHChangeNotifyTerminate(BOOL bLastTerm, BOOL bProcessShutdown);
void SHChangeNotifyReceiveEx(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime);
LRESULT SHChangeNotify_OnNotify(WPARAM wParam, LPARAM lParam);
LRESULT SHChangeNotify_OnChangeRegistration(WPARAM wParam, LPARAM lParam);
LRESULT SHChangeNotify_OnNotifySuspendResume(WPARAM wParam, LPARAM lParam);
LRESULT SHChangeNotify_OnDeviceChange(ULONG_PTR code, struct _DEV_BROADCAST_HDR *pbh);
void    SHChangeNotify_DesktopInit();
void    SHChangeNotify_DesktopTerm();
STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);

void _Shell32ThreadAddRef(BOOL fLeaveSuspended);
void _Shell32ThreadRelease(UINT nClients);
void _Shell32ThreadAwake(void);

// Entry points for managing registering name to IDList translations.
void NPTRegisterNameToPidlTranslation(LPCTSTR pszPath, LPCITEMIDLIST pidl);
LPWSTR NPTMapNameToPidl(LPCWSTR pszPath, LPCITEMIDLIST *ppidl);

// path.c (private stuff) ---------------------

#define PQD_NOSTRIPDOTS 0x00000001

STDAPI_(void) PathQualifyDef(LPTSTR psz, LPCTSTR szDefDir, DWORD dwFlags);

STDAPI_(BOOL) PathIsRemovable(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsRemote(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsTemporary(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsWild(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsLnk(LPCTSTR pszFile);
STDAPI_(BOOL) PathIsSlow(LPCTSTR pszFile, DWORD dwFileAttr);
STDAPI_(BOOL) PathIsInvalid(LPCTSTR pPath);
STDAPI_(BOOL) PathIsBinaryExe(LPCTSTR szFile);
STDAPI_(BOOL) PathMergePathName(LPTSTR pPath, LPCTSTR pName);
STDAPI_(BOOL) PathGetMountPointFromPath(LPCTSTR pcszPath, LPTSTR pszMountPoint, int cchMountPoint);
STDAPI_(BOOL) PathIsShortcutToProgram(LPCTSTR pszFile);

#if (defined(UNICODE) && (defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)))

#else

#define uaPathFindExtension PathFindExtension

#endif

void SpecialFolderIDTerminate();
void ReleaseRootFolders();
extern HINSTANCE g_hinst;

// get the desktop HWND if it is this process...
HWND GetInProcDesktop();

// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
extern BOOL g_bMirroredOS;

// Is DATE_LTRREADING supported by GetDateFormat() API?  (it is supported in all the BiDi platforms.)
extern BOOL g_bBiDiPlatform;

// for control panel and printers folder:
extern TCHAR const c_szNull[];
extern TCHAR const c_szDotDot[];
extern TCHAR const c_szRunDll[];
extern TCHAR const c_szNewObject[];


// lang platform
extern UINT g_uCodePage;


// other stuff
#define HINST_THISDLL   g_hinst

//
// Trace/dump/break flags specific to shell32.
//   (Standard flags defined in shellp.h)
//

// Trace flags
#define TF_IMAGE            0x00000010      // Image/icon related stuff
#define TF_PROPERTY         0x00000020      // Property traces
#define TF_PATH             0x00000040      // Path whacking traces
#define TF_MENU             0x00000080      // Menu stuff
#define TF_ALLOC            0x00000100      // Allocation traces
#define TF_REG              0x00000200      // Registry traces
#define TF_DDE              0x00000400      // Shell progman DDE message tracing
#define TF_HASH             0x00000800      // Hash table stuff
#define TF_ASSOC            0x00001000      // File/URL Association traces
#define TF_FILETYPE         0x00002000      // File Type stuff
#define TF_SHELLEXEC        0x00004000      // ShellExecute stuff
#define TF_OLE              0x00008000      // OLE-specific stuff
#define TF_DEFVIEW          0x00010000      // Defview
#define TF_PERF             0x00020000      // Performance timings
#define TF_FSNOTIFY         0x00040000      // FSNotify stuff
#define TF_LIFE             0x00080000      // Object lifetime traces
#define TF_IDLIST           0x00100000      // "PIDLy" things
#define TF_FSTREE           0x00200000      // FSTree traces
#define TF_PRINTER          0x00400000      // Printer traces
//#define TF_QISTUB          0x00800000      // defined in unicpp\shellprv.h
#define TF_DOCFIND          0x01000000      // DocFind
#define TF_MENUBAND         0x02000000      // menubands
#define TF_CPANEL           0x10000000      // Control Panel
#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2


// "Olde names"
#define DM_ALLOC            TF_ALLOC
#define DM_REG              TF_REG

// Function trace flags
#define FTF_DEFVIEW         0x00000004      // DefView calls
#define FTF_DDE             0x00000008      // DDE functions
#define FTF_CPANEL          0x00000010      // Control Panel

// Dump flags
#define DF_INTSHCUT         0x00000001      // Internet shortcut structures
#define DF_HASH             0x00000002      // Hash table
#define DF_FSNPIDL          0x00000004      // Pidl for FSNotify
#define DF_URLPROP          0x00000008      // URL property structures
#define DF_DEBUGQI          0x00000010
#define DF_DEBUGQINOREF     0x00000020
#define DF_ICONCACHE        0x00000040      // Icon cache
#define DF_CLASSFLAGS       0x00000080      // File class cache
#define DF_DELAYLOADDLL     0x00000100      // Delay load

// Break flags
#define BF_ONLOADED         0x00000010      // Stop when loaded
#define BF_COCREATEINSTANCE 0x10000000      // On CoCreateInstance failure

// Debugging strings
#define GEN_DEBUGSTRW(str)  ((str) ? (str) : L"<Null Str>")
#define GEN_DEBUGSTRA(str)  ((str) ? (str) : "<Null Str>")

#ifdef UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRW
#else // UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRA
#endif // UNICODE

// Note:  raymondc - ATOMICRELEASE isn't particularly atomic.  There is a race
// condition if two people try to ATOMICRELEASE the same thing simultaneously.

// shorthand
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#   ifdef __cplusplus
#       define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#   else
#       define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#   endif
#endif
#endif //ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif
#define SAFERELEASE(p) ATOMICRELEASE(p)


// fileicon.c
void    FileIconTerm(void);


#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

void ReplaceParams(LPTSTR szDst, LPCTSTR szFile);


#ifdef __IPropertyStorage_INTERFACE_DEFINED__
WINSHELLAPI HRESULT SHPropVariantClear(PROPVARIANT * ppropvar);
WINSHELLAPI HRESULT SHFreePropVariantArray(ULONG cel, PROPVARIANT * ppropvar);
WINSHELLAPI HRESULT SHPropVariantCopy(PROPVARIANT * ppropvar, const PROPVARIANT * ppropvarFrom);
#endif


//
// fsassoc.c
//

#define GCD_MUSTHAVEOPENCMD     0x0001
#define GCD_ADDEXETODISPNAME    0x0002  // must be used with GCD_MUSTHAVEOPENCMD
#define GCD_ALLOWPSUDEOCLASSES  0x0004  // .ext type extensions

// Only valid when used with FillListWithClasses
#define GCD_MUSTHAVEEXTASSOC    0x0008  // There must be at least one extension assoc

BOOL GetClassDescription(HKEY hkClasses, LPCTSTR pszClass, LPTSTR szDisplayName, int cbDisplayName, UINT uFlags);

//
// Registry key handles
//
extern HKEY g_hklmApprovedExt;      // For approved shell extensions

// always zero, see init.c
extern const LARGE_INTEGER g_li0;
extern const ULARGE_INTEGER g_uli0;


// from link.c
BOOL PathSeperateArgs(LPTSTR pszPath, LPTSTR pszArgs);

// from fstree.cpp and drives.cpp

STDAPI SFVCB_OnAddPropertyPages(IN DWORD pv, IN SFVM_PROPPAGE_DATA * ppagedata);

//
// this used to be in shprst.c
//

#define MAX_FILE_PROP_PAGES 32

HKEY NetOpenProviderClass(HDROP);
void OpenNetResourceProperties(HWND, HDROP);

// msgbox.c
// Constructs strings like ShellMessagebox "xxx %1%s yyy %2%s..."
LPTSTR WINCAPI ShellConstructMessageString(HINSTANCE hAppInst, LPCTSTR lpcText, ...);

//  Copy.c
#define SPEED_SLOW  400
DWORD GetPathSpeed(LPCTSTR pszPath);


// SharedFldr.cpp
STDAPI_(BOOL) SHShowSharedFolders();


// mulprsht.c

STDAPI_(BOOL) SHEncryptFile(LPCTSTR pszPath, BOOL fEncrypt);
// wuutil.c
void cdecl SetFolderStatusText(HWND hwndStatus, int iField, UINT ids,...);

#ifdef DEBUG
extern BOOL  g_bInDllEntry;

#undef SendMessage
#define SendMessage  SendMessageD
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

//
//  The DEBUG build validates that every class we register is in the
//  unregister list so we don't leak classes at unload.
//
#undef RegisterClass
#undef RegisterClassEx
#define RegisterClass       RegisterClassD
#define RegisterClassEx     RegisterClassExD
ATOM WINAPI RegisterClassD(CONST WNDCLASS *lpWndClass);
ATOM WINAPI RegisterClassExD(CONST WNDCLASSEX *lpWndClass);
#endif // DEBUG

#ifdef UNICODE
#define RealRegisterClass   RegisterClassW
#define RealRegisterClassEx RegisterClassExW
#else
#define RealRegisterClass   RegisterClassA
#define RealRegisterClassEx RegisterClassExA
#endif

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow sends interthreadmessages,
//  which is not obvious.
//
#ifdef DEBUG
#undef  FindWindow
#undef  FindWindowEx
#define FindWindow              FindWindowD
#define FindWindowEx            FindWindowExD

STDAPI_(HWND) FindWindowD  (LPCTSTR lpClassName, LPCTSTR lpWindowName);
STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName);
#ifdef UNICODE
#define RealFindWindowEx        FindWindowExW
#else
#define RealFindWindowEx        FindWindowExA
#endif // UNICODE
#endif // DEBUG

// our wrapper for GetCompressedFileSize, which is NT only
STDAPI_(DWORD) SHGetCompressedFileSizeW(LPCWSTR pszFileName, LPDWORD pFileSizeHigh);

#undef GetCompressedFileSize
#define GetCompressedFileSize SHGetCompressedFileSize

#ifdef UNICODE
#define SHGetCompressedFileSize SHGetCompressedFileSizeW
#else
#define SHGetCompressedFileSize #error // not implemented, because its an nt only API
#endif // UNICODE

#define ASSERTDLLENTRY      ASSERT(g_bInDllEntry);

//
// STATIC macro
//
#ifndef STATIC
#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif
#endif

//
// Debug helper functions
//


//
// Validation functions
//

BOOL IsValidPSHELLEXECUTEINFO(LPSHELLEXECUTEINFO pei);


// Defining FULL_DEBUG allows us debug memory problems.
#if defined(FULL_DEBUG)
#include <deballoc.h>
#endif // defined(FULL_DEBUG)

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = SIZEOF(SHELLEXECUTEINFO);

STDAPI_(LONG) SHRegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpValue, LONG *lpcbValue);
STDAPI_(LONG) SHRegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpValue, LONG *lpcbValue);

#ifdef UNICODE
#define SHRegQueryValue     SHRegQueryValueW
#else
#define SHRegQueryValue     SHRegQueryValueA
#endif

#ifdef DEBUG
#if 1
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}
#else
    __inline DWORD clockrate() {return 1000;}
    __inline DWORD clock()     {return GetTickCount();}
#endif

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEIN(t)     t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) TraceMsg(TF_PERF, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEIN(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

// in extract.c
STDAPI_(DWORD) GetExeType(LPCTSTR pszFile);
STDAPI_(UINT)  ExtractIcons(LPCTSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);

/*
in pickicon.c
Return Values for PickIconDlgWithTitle()

User Operation       Return Values
Cancel            -> HRESULT_FROM_WIN32(ERROR_CANCELLED) 
Ok                -> S_OK
RestoreDefault    -> S_FALSE
*/
STDAPI PickIconDlgWithTitle(HWND hwnd, LPCTSTR pszTitle, BOOL bShowRestoreButton, LPTSTR pszIconPath, UINT cbIconPath, int *piIconIndex);


// defxicon.c

STDAPI SHCreateDefExtIconKey(HKEY hkey, LPCTSTR pszModule, int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags, REFIID riid, void **pxiconOut);
STDAPI SHCreateDefExtIcon(LPCTSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, int iDefIcon, REFIID riid, void **pxiconOut);


STDAPI_(UINT) SHSysErrorMessageBox(HWND hwnd, LPCTSTR pszTitle, UINT idTemplate, DWORD err, LPCTSTR pszParam, UINT dwFlags);

//======Hash Item=============================================================
typedef struct _HashTable **HHASHTABLE;
#define PHASHITEM LPCTSTR

typedef void (CALLBACK *HASHITEMCALLBACK)(HHASHTABLE hht, LPCTSTR sz, UINT wUsage, DWORD_PTR param);

STDAPI_(LPCTSTR) FindHashItem  (HHASHTABLE hht, LPCTSTR lpszStr);
STDAPI_(LPCTSTR) AddHashItem   (HHASHTABLE hht, LPCTSTR lpszStr);
STDAPI_(LPCTSTR) DeleteHashItem(HHASHTABLE hht, LPCTSTR lpszStr);
STDAPI_(LPCTSTR) PurgeHashItem (HHASHTABLE hht, LPCTSTR lpszStr);

#define     GetHashItemName(pht, sz, lpsz, cch)  lstrcpyn(lpsz, sz, cch)

HHASHTABLE  WINAPI CreateHashItemTable(UINT wBuckets, UINT wExtra);
void        WINAPI DestroyHashItemTable(HHASHTABLE hht);

void        WINAPI SetHashItemData(HHASHTABLE hht, LPCTSTR lpszStr, int n, DWORD_PTR dwData);
DWORD_PTR   WINAPI GetHashItemData(HHASHTABLE hht, LPCTSTR lpszStr, int n);
void *      WINAPI GetHashItemDataPtr(HHASHTABLE hht, LPCTSTR lpszStr);

void        WINAPI EnumHashItems(HHASHTABLE hht, HASHITEMCALLBACK callback, DWORD_PTR dwParam);

#ifdef DEBUG
void        WINAPI DumpHashItemTable(HHASHTABLE hht);
#endif


//======== Text thunking stuff ===========================================================
typedef struct _THUNK_TEXT_
{
    LPTSTR m_pStr[1];
} ThunkText;

#ifdef UNICODE
    typedef CHAR        XCHAR;
    typedef LPSTR       LPXSTR;
    typedef const XCHAR * LPCXSTR;
    #define lstrlenX(r) lstrlenA(r)
#else // unicode
    typedef WCHAR       XCHAR;
    typedef LPWSTR      LPXSTR;
    typedef const XCHAR * LPCXSTR;
    #define lstrlenX(r) lstrlenW(r)
#endif // unicode

ThunkText * ConvertStrings(UINT cCount, ...);

#include "uastrfnc.h"
#ifdef __cplusplus
}       /* End of extern "C" { */
#endif /* __cplusplus */

#include <help.h>


//======== Discriminate inclusion ========================================

#ifndef NO_INCLUDE_UNION        // define this to avoid including all
                                // of the extra files that were not
                                // previously included in shellprv.h
#include <wchar.h>
#include <tchar.h>

#include <process.h>
#include <wowshlp.h>
#include <vdmapi.h>
#include "shell.h"
#include "dde.h"
#include <regstr.h>
#include "findhlp.h"
#include <krnlcmn.h>
#include <dlgs.h>
#include <err.h>
#include <msprintx.h>
#include <pif.h>
#include <windisk.h>
#include <brfcasep.h>
#include <trayp.h>
#include <brfcasep.h>
#include <wutilsp.h>
#include "bitbuck.h"
#include "drawpie.h"
#include "fileop.h"
#include "pidl.h"
#include "ids.h"
#include <newexe.h>
#include "newres.h"
#include "ole2dup.h"
#include "os.h"
#include "privshl.h"
#include "reglist.h"
#include "shell32p.h"
#include "shitemid.h"
#include "undo.h"
#include "vdate.h"
#include "views.h"

// NT shell uses 32-bit version of this pifmgr code.
#ifndef NO_PIF_HDRS
#include "pifmgrp.h"
#include "piffntp.h"
#include "pifinfp.h"
#include "doshelp.h"
#include "machinep.h"   // Japanese domestic machine (NEC) support
#endif

#endif // NO_INCLUDE_UNION

#include "shdguid.h"

#define SetWindowBits SHSetWindowBits
#define IsSameObject SHIsSameObject
#define IsChildOrSelf SHIsChildOrSelf
#define MenuIndexFromID  SHMenuIndexFromID
#define _GetMenuFromID  SHGetMenuFromID
#define GetCurColorRes SHGetCurColorRes
#define WaitForSendMessageThread SHWaitForSendMessageThread

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

// Stack allocated BSTR (to avoid calling SysAllocString)
typedef struct _SA_BSTR {
    ULONG   cb;
    WCHAR   wsz[MAX_URL_STRING];
} SA_BSTR;

// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))

//
//  The cb field of a BSTR is the count of bytes, not including the
//  terminating L('\0').
//
//
//  DECLARE_CONST_BSTR - Goes into header file (if any)
//  DEFINE_CONST_BSTR  - Creates the variable, must already be declared
//  MAKE_CONST_BSTR    - Combines DECLARE and DEFINE
//
#define DECLARE_CONST_BSTR(name, str) \
 extern const struct BSTR##name { ULONG cb; WCHAR wsz[sizeof(str)/sizeof(WCHAR)]; } name

#define DEFINE_CONST_BSTR(name, str) \
        const struct BSTR##name name = { sizeof(str) - sizeof(WCHAR), str }

#define MAKE_CONST_BSTR(name, str) \
        const struct BSTR##name { ULONG cb; WCHAR wsz[sizeof(str)/sizeof(WCHAR)]; } \
                                name = { sizeof(str) - sizeof(WCHAR), str }

DECLARE_CONST_BSTR(s_sstrIDMember,         L"id");
DECLARE_CONST_BSTR(s_sstrSubSRCMember,     L"subscribed_url");
DECLARE_CONST_BSTR(s_sstrSRCMember,        L"src");

//======== Header file hacks =============================================================

//
//  The compiler will tell us if we are defining these NT5-only parameters
//  incorrectly.  If you get "invalid redefinition" errors, it means that
//  the definition in windows.h changed and we need to change to match.
//

#define ASFW_ANY    ((DWORD)-1)

#define CMIDM_LINK      0x0001
#define CMIDM_COPY      0x0002
#define CMIDM_MOVE      0x0003

// Downlevel shutdown dialog function
DWORD DownlevelShellShutdownDialog(HWND hwndParent, DWORD dwItems, LPCTSTR szUsername);

// from shell32\unicode\format.c
STDAPI_(DWORD) SHChkDskDriveEx(HWND hwnd, LPWSTR pszDrive);

//
// On NT, sometimes CreateDirectory succeeds in creating the directory, but, you can not do
// anything with it that directory. This happens if the directory name being created does
// not have room for an 8.3 name to be tagged onto the end of it,
// i.e., lstrlen(new_directory_name)+12 must be less or equal to MAX_PATH.
//
// the magic # "12" is 8 + 1 + 3 for and 8.3 name.
// 
// The following macro is used in places where we need to detect this to make
// MoveFile to be consistent with CreateDir(files  os.c and copy.c use this)
//

#define  IsDirPathTooLongForCreateDir(pszDir)    ((lstrlen(pszDir) + 12) > MAX_PATH)

// call the shlwapi version of this, note we have an export from shell32 that forwards to this
#define ShellMessageBoxW    ShellMessageBoxWrapW

#define REGSTR_EXPLORER_ADVANCED (REGSTR_PATH_EXPLORER TEXT("\\Advanced"))

#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
#define RECTWIDTH(rc) ((rc).right - (rc).left)

STDAPI_(BOOL) IsGuimodeSetupRunning();

#endif // _SHELLPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shlnot.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <trayp.h>

TCHAR const c_szTrayClass[] = TEXT(WNDCLASS_TRAYNOTIFY);

STDAPI_(BOOL) Shell_NotifyIcon(DWORD dwMessage, NOTIFYICONDATA *pnid)
{
    HWND hwndTray;

    SetLastError(0);        // Clean any previous last error (code to help catch another bug)

    hwndTray = FindWindow(c_szTrayClass, NULL);
    if (hwndTray)
    {
        COPYDATASTRUCT cds;
        TRAYNOTIFYDATA tnd = {0};
        DWORD_PTR dwRes = FALSE;
        DWORD dwValidFlags;

        int cbSize = pnid->cbSize;

        if (cbSize == sizeof(*pnid))
        {
            dwValidFlags = NIF_VALID;
        }
        // Win2K checked for size of this struct
        else if (cbSize == NOTIFYICONDATA_V2_SIZE)
        {
            dwValidFlags = NIF_VALID_V2;
        }
        else
        {
            // This will RIP if the app was buggy and passed stack
            // garbage as cbSize.  Apps got away with this on Win95
            // and NT4 because those versions didn't validate cbSize.
            // So if we see a strange cbSize, assume it's the V1 size.
            RIP(cbSize == NOTIFYICONDATA_V1_SIZE);
            cbSize = NOTIFYICONDATA_V1_SIZE;

            dwValidFlags = NIF_VALID_V1;
        }

#ifdef  _WIN64
        // Thunking NOTIFYICONDATA to NOTIFYICONDATA32 is annoying
        // on Win64 due to variations in the size of HWND and HICON
        // We have to copy each field individually.
        tnd.nid.dwWnd            = PtrToUlong(pnid->hWnd);
        tnd.nid.uID              = pnid->uID;
        tnd.nid.uFlags           = pnid->uFlags;
        tnd.nid.uCallbackMessage = pnid->uCallbackMessage;
        tnd.nid.dwIcon           = PtrToUlong(pnid->hIcon);

        // The rest of the fields don't change size between Win32 and
        // Win64, so just block copy them over

        // Toss in an assertion to make sure
        COMPILETIME_ASSERT(
            sizeof(NOTIFYICONDATA  ) - FIELD_OFFSET(NOTIFYICONDATA  , szTip) ==
            sizeof(NOTIFYICONDATA32) - FIELD_OFFSET(NOTIFYICONDATA32, szTip));

        memcpy(&tnd.nid.szTip, &pnid->szTip, cbSize - FIELD_OFFSET(NOTIFYICONDATA, szTip));

#else
        // On Win32, the two structures are the same
        COMPILETIME_ASSERT(sizeof(NOTIFYICONDATA) == sizeof(NOTIFYICONDATA32));
        memcpy(&tnd.nid, pnid, cbSize);
#endif

        tnd.nid.cbSize = sizeof(NOTIFYICONDATA32);

        // This will RIP if the app was really buggy and passed stack
        // garbage as uFlags.
        RIP(!(pnid->uFlags & ~dwValidFlags));
        tnd.nid.uFlags &= dwValidFlags;

        // Toss in an extra NULL to ensure that the tip is NULL terminated...
        if (tnd.nid.uFlags & NIF_TIP)
        {
            tnd.nid.szTip[ARRAYSIZE(tnd.nid.szTip)-1] = TEXT('\0');
        }

        if ( (cbSize == sizeof(*pnid)) || (cbSize == NOTIFYICONDATA_V2_SIZE) )
        {
            if (tnd.nid.uFlags & NIF_INFO)
            {
                tnd.nid.szInfo[ARRAYSIZE(tnd.nid.szInfo)-1] = TEXT('\0');
                tnd.nid.szInfoTitle[ARRAYSIZE(tnd.nid.szInfoTitle)-1] = TEXT('\0');
            }
        }

        if (dwMessage == NIM_SETFOCUS)
        {
            DWORD dwProcId;
            GetWindowThreadProcessId(hwndTray, &dwProcId);
            AllowSetForegroundWindow(dwProcId);
        }
        
        tnd.dwSignature = NI_SIGNATURE;
        tnd.dwMessage = dwMessage;

        cds.dwData = TCDM_NOTIFY;
        cds.cbData = sizeof(tnd);
        cds.lpData = &tnd;

        if (SendMessageTimeout(hwndTray, WM_COPYDATA, (WPARAM)pnid->hWnd, (LPARAM)&cds,
            SMTO_ABORTIFHUNG | SMTO_BLOCK, 4000, &dwRes))
        {
            return (BOOL) dwRes;
        }
    }

    return FALSE;
}

#ifdef UNICODE
STDAPI_(BOOL) Shell_NotifyIconA(DWORD dwMessage, NOTIFYICONDATAA *pnid)
{
    NOTIFYICONDATAW tndw = {0};
    
    tndw.cbSize           = sizeof(tndw);
    tndw.hWnd             = pnid->hWnd;
    tndw.uID              = pnid->uID;
    tndw.uFlags           = pnid->uFlags;
    tndw.uCallbackMessage = pnid->uCallbackMessage;
    tndw.hIcon            = pnid->hIcon;

    if (pnid->cbSize == sizeof(*pnid))
    {
        tndw.dwState        = pnid->dwState;
        tndw.dwStateMask    = pnid->dwStateMask;
        tndw.uTimeout       = pnid->uTimeout;
        tndw.dwInfoFlags    = pnid->dwInfoFlags;
    }
    // Transfer those fields we are aware of as of this writing
    else if (pnid->cbSize == NOTIFYICONDATAA_V2_SIZE) 
    {
        tndw.cbSize         = NOTIFYICONDATAW_V2_SIZE;
        tndw.dwState        = pnid->dwState;
        tndw.dwStateMask    = pnid->dwStateMask;
        tndw.uTimeout       = pnid->uTimeout;
        tndw.dwInfoFlags    = pnid->dwInfoFlags;

        // This will RIP if the app was really buggy and passed stack
        // garbage as uFlags.  We have to clear out bogus flags to
        // avoid accidentally trying to read from invalid data.
        RIP(!(pnid->uFlags & ~NIF_VALID_V2));
        tndw.uFlags &= NIF_VALID_V2;
    }
    else 
    {
        // This will RIP if the app was buggy and passed stack
        // garbage as cbSize.  Apps got away with this on Win95
        // and NT4 because those versions didn't validate cbSize.
        // So if we see a strange cbSize, assume it's the V1 size.
        RIP(pnid->cbSize == (DWORD)NOTIFYICONDATAA_V1_SIZE);
        tndw.cbSize = NOTIFYICONDATAW_V1_SIZE;

        // This will RIP if the app was really buggy and passed stack
        // garbage as uFlags.  We have to clear out bogus flags to
        // avoid accidentally trying to read from invalid data.
        RIP(!(pnid->uFlags & ~NIF_VALID_V1));
        tndw.uFlags &= NIF_VALID_V1;
    }

    if (tndw.uFlags & NIF_TIP)
        SHAnsiToUnicode(pnid->szTip, tndw.szTip, ARRAYSIZE(tndw.szTip));

    if (tndw.uFlags & NIF_INFO)
    {
        SHAnsiToUnicode(pnid->szInfo, tndw.szInfo, ARRAYSIZE(tndw.szInfo));
        SHAnsiToUnicode(pnid->szInfoTitle, tndw.szInfoTitle, ARRAYSIZE(tndw.szInfoTitle));
    }

    if (tndw.uFlags & NIF_GUID)
    {
        memcpy(&(tndw.guidItem), &(pnid->guidItem), sizeof(pnid->guidItem));
    }

    return Shell_NotifyIconW(dwMessage, &tndw);
}
#else
STDAPI_(BOOL) Shell_NotifyIconW(DWORD dwMessage, NOTIFYICONDATAW *pnid)
{
    return FALSE;
}
#endif

//***   CopyIn -- copy app data in to shared region (and create shared)
// ENTRY/EXIT
//  return      handle on success, NULL on failure
//  pvData      app buffer
//  cbData      count
//  dwProcId    ...
// NOTES
//  should make it handle pvData=NULL for cases where param is OUT not INOUT.
//
HANDLE CopyIn(void *pvData, int cbData, DWORD dwProcId)
{
    HANDLE hShared = SHAllocShared(NULL, cbData, dwProcId);
    if (hShared) 
    {
        void *pvShared = SHLockShared(hShared, dwProcId);
        if (pvShared == NULL) 
        {
            SHFreeShared(hShared, dwProcId);
            hShared = NULL;
        }
        else 
        {
            memcpy(pvShared, pvData, cbData);
            SHUnlockShared(pvShared);
        }
    }
    return hShared;
}

// copy out to app data from shared region (and free shared)
// ENTRY/EXIT
//  return      TRUE on success, FALSE on failure.
//  hShared     shared data, freed when done
//  pvData      app buffer
//  cbData      count
BOOL CopyOut(HANDLE hShared, void *pvData, int cbData, DWORD dwProcId)
{
    void *pvShared = SHLockShared(hShared, dwProcId);
    if (pvShared)
    {
        memcpy(pvData, pvShared, cbData);
        SHUnlockShared(pvShared);
    }
    SHFreeShared(hShared, dwProcId);
    return (pvShared != 0);
}

STDAPI_(UINT_PTR) SHAppBarMessage(DWORD dwMessage, APPBARDATA *pabd)
{
    TRAYAPPBARDATA tabd;
    UINT_PTR fret = FALSE;
    HWND hwndTray = FindWindow(c_szTrayClass, NULL);
    if (hwndTray && (pabd->cbSize <= sizeof(*pabd)))
    {
        COPYDATASTRUCT cds;

        RIP(pabd->cbSize == sizeof(*pabd));

#ifdef _WIN64
        tabd.abd.dwWnd = PtrToUlong(pabd->hWnd);
        tabd.abd.uCallbackMessage = pabd->uCallbackMessage;
        tabd.abd.uEdge = pabd->uEdge;
        tabd.abd.rc = pabd->rc;
#else
        // Sadly, the Win32 compiler doesn't realize that the code
        // sequence above can be optimized into a single memcpy, so
        // we need to spoon-feed it...
        memcpy(&tabd.abd.dwWnd, &pabd->hWnd,
               FIELD_OFFSET(APPBARDATA, lParam) - FIELD_OFFSET(APPBARDATA, hWnd));
#endif
        tabd.abd.cbSize = sizeof(tabd.abd);
        tabd.abd.lParam = pabd->lParam;

        tabd.dwMessage = dwMessage;
        tabd.hSharedABD = PtrToUlong(NULL);
        tabd.dwProcId = GetCurrentProcessId();

        cds.dwData = TCDM_APPBAR;
        cds.cbData = sizeof(tabd);
        cds.lpData = &tabd;

        //
        //  These are the messages that return data back to the caller.
        //
        switch (dwMessage)
        {
        case ABM_QUERYPOS:
        case ABM_SETPOS:
        case ABM_GETTASKBARPOS:
            tabd.hSharedABD = PtrToUlong(CopyIn(&tabd.abd, sizeof(tabd.abd), tabd.dwProcId));
            if (tabd.hSharedABD == PtrToUlong(NULL))
                return FALSE;

            break;
        }

        fret = SendMessage(hwndTray, WM_COPYDATA, (WPARAM)pabd->hWnd, (LPARAM)&cds);
        if (tabd.hSharedABD) 
        {
            if (CopyOut(UlongToPtr(tabd.hSharedABD), &tabd.abd, sizeof(tabd.abd), tabd.dwProcId))
            {
#ifdef _WIN64
                pabd->hWnd = (HWND)UIntToPtr(tabd.abd.dwWnd);
                pabd->uCallbackMessage = tabd.abd.uCallbackMessage;
                pabd->uEdge = tabd.abd.uEdge;
                pabd->rc = tabd.abd.rc;
#else
                // Sadly, the Win32 compiler doesn't realize that the code
                // sequence above can be optimized into a single memcpy, so
                // we need to spoon-feed it...
                memcpy(&pabd->hWnd, &tabd.abd.dwWnd,
                       FIELD_OFFSET(APPBARDATA, lParam) - FIELD_OFFSET(APPBARDATA, hWnd));
#endif
                pabd->lParam = (LPARAM)tabd.abd.lParam;
            }
            else
                fret = FALSE;
        }
    }
    return fret;
}

HRESULT _TrayLoadInProc(REFCLSID rclsid, DWORD dwFlags)
{
    HWND hwndTray = FindWindow(c_szTrayClass, NULL);
    if (hwndTray)
    {
        COPYDATASTRUCT cds;
        LOADINPROCDATA lipd;
        lipd.clsid = rclsid;
        lipd.dwFlags = dwFlags;

        cds.dwData = TCDM_LOADINPROC;
        cds.cbData = sizeof(lipd);
        cds.lpData = &lipd;

        return (HRESULT)SendMessage(hwndTray, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&cds);
    }
    else
    {
        return E_FAIL;
    }
}

STDAPI SHLoadInProc(REFCLSID rclsid)
{
    return _TrayLoadInProc(rclsid, LIPF_ENABLE);
}

STDAPI SHEnableServiceObject(REFCLSID rclsid, BOOL fEnable)
{
    DWORD dwFlags = fEnable ? LIPF_ENABLE | LIPF_HOLDREF : LIPF_HOLDREF;

    return _TrayLoadInProc(rclsid, dwFlags);
}

// used to implement a per process reference count for the main thread
// the browser msg loop and the proxy desktop use this to let other threads
// extend their lifetime. 
// there is a thread level equivelent of this, shlwapi SHGetThreadRef()/SHSetThreadRef()

IUnknown *g_punkProcessRef = NULL;

STDAPI_(void) SHSetInstanceExplorer(IUnknown *punk)
{
    g_punkProcessRef = punk;
}

// This should be thread safe since we grab the punk locally before
// checking/using it, plus it never gets freed since it is not actually
// alloced in Explorer so we can always use it

STDAPI SHGetInstanceExplorer(IUnknown **ppunk)
{
    *ppunk = g_punkProcessRef;
    if (*ppunk)
    {
        (*ppunk)->AddRef();
        return NOERROR;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shlunimp.c ===
#define  DebugPrintf  dprintf

#include <windef.h>
#include "stdarg.h"
#include <winerror.h>
#include <winbase.h>
#include <unimp.h>

APISTUB_1 (SheChangeDirA,              0)
APISTUB_1 (SheChangeDirW,              0)
APISTUB_3 (SheFullPathA,               0)
APISTUB_3 (SheFullPathW,               0)
APISTUB_2 (SheGetDirA,                 0)
APISTUB_2 (SheGetDirW,                 0)
APISTUB_0 (SheGetCurDrive,             0)
APISTUB_1 (SheSetCurDrive,             0)

APISTUB_2 (DuplicateIcon,              0)
APISTUB_10 (RealShellExecuteA,          0)
APISTUB_3  (FindExecutableW,            0)
APISTUB_6  (ShellExecuteW,              0)
APISTUB_3  (ExtractIconW,               0)
APISTUB_4  (InternalExtractIconW,       0)
APISTUB_3  (ExtractAssociatedIconW,     0)
APISTUB_10 (RealShellExecuteW,          0)
    
#ifndef UNICODE
APISTUB_4  (ShellAboutW,                0)
#endif
APISTUB_4  (DragQueryFileW,             0)
APISTUB_2  (DoEnvironmentSubstW,        0)
APISTUB_1  (FindEnvironmentStringW,     0)

APISTUB_2  (CheckEscapesA               ,0)     // 2 param. LPSTR,DWORD
APISTUB_2  (CheckEscapesW               ,0)     // 2 param. LPWSTR,DWORD
APISTUB_2  (CommandLineToArgvW          ,0)     // 2 param. WCHAR*,int*
APISTUB_6  (DragQueryFileAorW           ,0)     // 6 param. HDROP,UINT,PVOID,UINT,BOOL,BOOL
APISTUB_4  (ExtractAssociatedIconExW    ,0)     // 4 param. HINSTANCE,LPWSTR,LPWORD,LPWORD

APISTUB_4  (ExtractAssociatedIconExA    ,0)     // 4 param. HINSTANCE,LPWSTR,LPWORD,LPWORD
APISTUB_5  (ExtractIconResInfoA         ,0)     // 5 param. HINSTANCE,LPSTR,WORD,LPWORD,LPHANDLE
APISTUB_5  (ExtractIconResInfoW         ,0)     // 5 param. HINSTANCE,LPWSTR,WORD,LPWORD,LPHANDLE
APISTUB_2  (ExtractVersionResource16W   ,0)     // 2 param. LPCWSTR,LPHANDLE
APISTUB_3  (InternalExtractIconListA    ,0)     // 3 param. HINSTANCE,LPSTR,LPINT
APISTUB_3  (InternalExtractIconListW    ,0)     // 3 param. HINSTANCE,LPWSTR,LPINT
APISTUB_2  (FreeIconList                ,0)     // 2 param. HANDLE,int
APISTUB_11 (RealShellExecuteExA         ,0)     // 11 param. HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,LPSTR,LPCSTR,LPSTR,WORD,LPHANDLE,DWORD
APISTUB_11 (RealShellExecuteExW         ,0)     // 11 param. HWND,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,LPCWSTR,LPWSTR,WORD,LPHANDLE,DWORD
APISTUB_2  (RegenerateUserEnvironment   ,0)     // 2 param. PVOID *,BOOL
APISTUB_1  (SheChangeDirExA             ,0)     // 1 param. CHAR*
APISTUB_1  (SheChangeDirExW             ,0)     // 1 param. WCHAR*
APISTUB_3  (SheConvertPathW             ,0)     // 3 param. LPWSTR,LPWSTR,UINT
APISTUB_3  (SheGetDirExW                ,0)     // 3 param. LPWSTR,LPDWORD,LPWSTR
APISTUB_1  (SheGetPathOffsetW           ,0)     // 1 param. LPWSTR
APISTUB_1  (SheRemoveQuotesA            ,0)     // 1 param. LPSTR
APISTUB_1  (SheRemoveQuotesW            ,0)     // 1 param. LPWSTR
APISTUB_2  (SheShortenPathA             ,0)     // 2 param. LPSTR,BOOL
APISTUB_2  (SheShortenPathW             ,0)     // 2 param. LPWSTR,BOOL
APISTUB_3  (ShellHookProc               ,0)     // 3 param. INT,WPARAM,LPARAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shlobjs.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <dpa.h>
#include "ids.h"
#include "idlcomm.h"
#include "recdocs.h"
#include "datautil.h"
#include "mtpt.h"
#include <cowsite.h>

typedef struct _DKAITEM {       // dkai
    HKEY hk;
    TCHAR    sz[CCH_KEYMAX];
} DKAITEM, *PDKAITEM;
typedef const DKAITEM * PCDKAITEM;

class CDKA : public CDSA<DKAITEM>
{
public:
    ~CDKA();
    UINT AddKeys(HKEY hk, LPCTSTR pszSubKey, PCTSTR pszDefaultOrder);

    PCTSTR ExposeName(int id)
        {   return GetItemPtr(id)->sz; }
        
    HKEY ExposeKey(int id)
        {   return GetItemPtr(id)->hk; }
        
    HRESULT GetValue(int id, 
        PCTSTR pszSubKey, 
        PCTSTR pszValue, 
        DWORD *pdwType, 
        void *pvData, 
        DWORD *pcbData);

    BOOL DeleteItem(int id);
    BOOL DeleteAllItems();
    void Reset()
        { if ((HDSA)this) DestroyCallback(_ReleaseItem, NULL); }
    BOOL HasDefault(HKEY hkProgid);

protected:
    BOOL _AppendItem(HKEY hk, PDKAITEM pdkai);
    void _AddOrderedKeys(HKEY hk, PCTSTR pszDefOrder);
    void _AddEnumKeys(HKEY hk);
    static int CALLBACK _ReleaseItem(PDKAITEM pdkai, void *pv);

protected:
    TRIBIT _tbHasDefault;
};

BOOL CDKA::_AppendItem(HKEY hk, PDKAITEM pdkai)
{
    BOOL fRet = FALSE;
    // Verify that the key exists before adding it to the list
    if (RegOpenKeyEx(hk, pdkai->sz, 0L, KEY_READ, &pdkai->hk) == ERROR_SUCCESS)
    {
        fRet = (AppendItem(pdkai) >= 0);

        if (!fRet)
            RegCloseKey(pdkai->hk);
    }
    return fRet;
}

void CDKA::_AddOrderedKeys(HKEY hk, PCTSTR pszDefOrder)
{
    // First, add the subkeys from the value of the specified key
    // This should never fail, since we just opened this key
    DKAITEM dkai;
    TCHAR szOrder[CCH_KEYMAX * 5];
    LONG cbOrder = CbFromCch(ARRAYSIZE(szOrder));
    *szOrder = 0;
    RegQueryValue(hk, NULL, szOrder, &cbOrder);
    if (*szOrder)
    {
        //  now we must find something in this string in order to have a default
        _tbHasDefault = TRIBIT_FALSE;
    }
    else if (pszDefOrder)
    {
        // If there is no value, use the order requested
        //  typically "Open" or "Explore Open" in explorer mode
        StrCpyN(szOrder, pszDefOrder, ARRAYSIZE(szOrder));
    }

    PTSTR psz = szOrder;
    while (psz && *psz)
    {
        // skip the space or comma characters
        while(*psz==TEXT(' ') || *psz==TEXT(','))
            psz++;          // NLS Notes: OK to ++

        if (*psz)
        {
            // Search for the space or comma character
            LPTSTR pszNext = psz + StrCSpn(psz, TEXT(" ,"));
            if (*pszNext) {
                *pszNext++=0;    // NLS Notes: OK to ++
            }
            StrCpyN(dkai.sz, psz, ARRAYSIZE(dkai.sz));

            if (_AppendItem(hk, &dkai))
                _tbHasDefault = TRIBIT_TRUE;

            psz = pszNext;
        }
    } 
}

void CDKA::_AddEnumKeys(HKEY hk)
{
    DKAITEM dkai;
    // Then, append the rest if they are not in the list yet.
    for (int i = 0; RegEnumKey(hk, i, dkai.sz, ARRAYSIZE(dkai.sz)) == ERROR_SUCCESS; i++)
    {
        // Check if the key is already in the list.
        for (int idsa = 0; idsa < GetItemCount(); idsa++)
        {
            PDKAITEM pdkai = GetItemPtr(idsa);
            if (lstrcmpi(dkai.sz, pdkai->sz)==0)
                break;
        }

        //  we made it throug our array
        //  so this isnt in there
        if (idsa == GetItemCount())
            _AppendItem(hk, &dkai);
    }
}

UINT CDKA::AddKeys(HKEY hkRoot, LPCTSTR pszSubKey, PCTSTR pszDefaultOrder)
{
    UINT cKeys = GetItemCount();
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(hkRoot, pszSubKey, 0L, KEY_READ, &hk))
    {
        _AddOrderedKeys(hk, pszDefaultOrder);
        _AddEnumKeys(hk);
        RegCloseKey(hk);
    }
    return GetItemCount() - cKeys;
}

int CALLBACK CDKA::_ReleaseItem(PDKAITEM pdkai, void *pv)
{
    if (pdkai->hk)
    {
        RegCloseKey(pdkai->hk);
        pdkai->hk = NULL;        
    }
    return 1;
}

CDKA::~CDKA()
{
    Reset();
}

//  override this DSA methods to get release
BOOL CDKA::DeleteItem(int id)
{
    PDKAITEM p = GetItemPtr(id);
    if (p)
    {
        _ReleaseItem(p, NULL);
        return CDSA<DKAITEM>::DeleteItem(id);
    }
    return FALSE;
}

//  override this DSA methods to get release
BOOL CDKA::DeleteAllItems()
{
    EnumCallback(_ReleaseItem, NULL);
    return CDSA<DKAITEM>::DeleteAllItems();
}

HRESULT CDKA::GetValue(int id, 
    PCTSTR pszSubKey, 
    PCTSTR pszValue, 
    DWORD *pdwType, 
    void *pvData, 
    DWORD *pcbData)
{
    DWORD err = SHGetValue(GetItemPtr(id)->hk, pszSubKey, pszValue, pdwType, pvData, pcbData);
    return HRESULT_FROM_WIN32(err);
}

BOOL CDKA::HasDefault(HKEY hkProgid)
{
    if (_tbHasDefault == TRIBIT_UNDEFINED)
    {
        HKEY hk;
        if (ERROR_SUCCESS== RegOpenKeyEx(hkProgid, L"ShellFolder", 0, MAXIMUM_ALLOWED, &hk))
        {
            //  APPCOMPAT - regitems need to have the open verb - ZekeL - 30-JAN-2001
            //  so that the IQA and ICM will behave the same,
            //  and regitem folders will always default to 
            //  folder\shell\open unless they implement open 
            //  or specify default verbs.
            //
            _tbHasDefault = TRIBIT_FALSE;
            RegCloseKey(hk);
        }
        else
        {
            _tbHasDefault = TRIBIT_TRUE;
        }
    }
    return _tbHasDefault == TRIBIT_TRUE;
}

            
typedef HRESULT (__stdcall *LPFNADDPAGES)(IDataObject *, LPFNADDPROPSHEETPAGE, LPARAM);

class CShellExecMenu : public IShellExtInit, public IContextMenu, public IShellPropSheetExt, CObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);        
    STDMETHODIMP_(ULONG) Release(void);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pwRes, LPSTR pszName, UINT cchMax);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    CShellExecMenu(LPFNADDPAGES pfnAddPages);

protected:  // methods
    ~CShellExecMenu();
    void _Cleanup();
    HRESULT _InsureVerbs(UINT idVerb = 0);
    UINT _VerbCount();
    LPCTSTR _GetVerb(UINT id);
    UINT _FindIndex(LPCTSTR pszVerb);
    DWORD _BrowseFlagsFromVerb(UINT idVerb);
    BOOL _GetMenuString(UINT id, BOOL fExtended, LPTSTR pszMenu, UINT cchMax);
    BOOL _IsExplorerMode();
    BOOL _SupportsType(UINT idVerb);
    BOOL _IsRestricted(UINT idVerb);
    BOOL _IsVisible(BOOL fExtended, UINT idVerb);
    BOOL _RemoveVerb(UINT idVerb);
    BOOL _VerbCanDrop(UINT idVerb, CLSID *pclsid);
    HRESULT _DoDrop(REFCLSID clsid, UINT idVerb, LPCMINVOKECOMMANDINFOEX pici);

    HRESULT _MapVerbForInvoke(CMINVOKECOMMANDINFOEX *pici, UINT *pidVerb);
    HRESULT _TryBrowseObject(LPCITEMIDLIST pidl, DWORD uFlags);
    void _DoRecentStuff(LPCITEMIDLIST pidl, LPCTSTR pszPath);
    HRESULT _InvokeOne(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPCITEMIDLIST pidl);
    HRESULT _InvokeMany(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida);
    HRESULT _InvokeEach(LPCITEMIDLIST pidl, CMINVOKECOMMANDINFOEX *pici);
    HRESULT _PromptUser(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida);

    HRESULT _MapVerbForGCS(UINT_PTR idCmd, UINT uType, UINT *pidVerb);
    HRESULT _GetHelpText(UINT idVerb, UINT uType, LPSTR pszName, UINT cchMax);

private:  // members
    LONG _cRef;
    IDataObject *_pdtobj;
    HKEY _hkeyProgID;
    CDKA _dka;
    LPFNADDPAGES _pfnAddPages;
    UINT _uFlags;
};

CShellExecMenu::CShellExecMenu(LPFNADDPAGES pfnAddPages) : _pfnAddPages(pfnAddPages), _cRef(1)
{
}

CShellExecMenu::~CShellExecMenu()
{
    _Cleanup();
}

void CShellExecMenu::_Cleanup()
{
    _dka.Reset();
    
    if (_hkeyProgID) 
    {
        RegCloseKey(_hkeyProgID);
        _hkeyProgID = NULL;
    }

    ATOMICRELEASE(_pdtobj);
}

STDMETHODIMP CShellExecMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellExecMenu, IShellExtInit),
        QITABENT(CShellExecMenu, IContextMenu),
        QITABENT(CShellExecMenu, IShellPropSheetExt),
        QITABENT(CShellExecMenu, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShellExecMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellExecMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
       return _cRef;
    
    delete this;
    return 0;
}

HRESULT CShellExecMenu::_InsureVerbs(UINT idVerb)
{
    //  the idVerb is the minimum verb that we need to succeed
    if (!(HDSA)_dka && _hkeyProgID)
    {
        // create either "open" or "explore open"
        if (_dka.Create(4))
        {
            _dka.AddKeys(_hkeyProgID, c_szShell, _IsExplorerMode() ? TEXT("Explore open") : TEXT("open"));

            //  WARNING - some verbs are not valid and need to be removed
            for (int id = 0; id < _dka.GetItemCount(); id++)
            {
                if (_RemoveVerb(id))
                    _dka.DeleteItem(id);
            }
        }

    }
    
    return ((HDSA)_dka && idVerb < (UINT)_dka.GetItemCount()) ? S_OK : E_FAIL;
}

// Descriptions:
//   This function generates appropriate menu string from the given
//  verb key string. This function is called if the verb key does
//  not have the value.

BOOL _MenuString(LPCTSTR pszVerbKey, LPTSTR pszMenuString, UINT cchMax)
{
    // Table look-up (verb key -> menu string mapping)
    const static struct 
    {
        LPCTSTR pszVerb;
        UINT  id;
    } sVerbTrans[] = {
        c_szOpen,    IDS_MENUOPEN,
        c_szExplore, IDS_MENUEXPLORE,
        TEXT("edit"),IDS_MENUEDIT,
        c_szFind,    IDS_MENUFIND,
        c_szPrint,   IDS_MENUPRINT,
        c_szOpenAs,  IDS_MENUOPEN,
        TEXT("runas"),IDS_MENURUNAS
    };

    for (int i = 0; i < ARRAYSIZE(sVerbTrans); i++)
    {
        if (lstrcmpi(pszVerbKey, sVerbTrans[i].pszVerb) == 0)
        {
            if (LoadString(HINST_THISDLL, sVerbTrans[i].id, pszMenuString, cchMax))
                return TRUE;
            break;
        }
    }

    // Worst case: Just put '&' on the top.
    pszMenuString[0] = TEXT('&');
    pszMenuString++;
    cchMax--;
    lstrcpyn(pszMenuString, pszVerbKey, cchMax);

    return TRUE;
}

// Checks to see if there is a user policy in place that disables this key,
//
// For example, in the registry:
//
// CLSID_MyComputer
//   +---Shell
//         +---Manage   
//                       (Default)           = "Mana&ge"
//                       SuppressionPolicy   = REST_NOMANAGEMYCOMPUTERVERB
//
// (Where REST_NOMANAGEMYCOMPUTERVERB is the DWORD value of that particular policy)

BOOL CShellExecMenu::_IsRestricted(UINT idVerb)
{
    RESTRICTIONS rest;
    BOOL fRestrict = FALSE;
    if (0 == lstrcmpi(TEXT("runas"), _dka.ExposeName(idVerb)))
    {
        rest = REST_HIDERUNASVERB;
        fRestrict = TRUE;
    }
    else
    {
        DWORD cb = sizeof(rest);
        fRestrict = SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("SuppressionPolicy"), NULL, &rest, &cb));
    }
    return fRestrict && SHRestricted(rest);
}

HRESULT _GetAppSource(HKEY hk, PCWSTR pszVerb, IQuerySource **ppqs)
{
    CComPtr<IAssociationElement> spae;
    HRESULT hr = AssocElemCreateForKey(&CLSID_AssocShellElement, hk, &spae);
    if (SUCCEEDED(hr))
    {
        CComPtr<IObjectWithQuerySource> spowqsApp;
        hr = spae->QueryObject(AQVO_APPLICATION_DELEGATE, pszVerb, IID_PPV_ARG(IObjectWithQuerySource, &spowqsApp));
        if (SUCCEEDED(hr))
        {
            hr = spowqsApp->GetSource(IID_PPV_ARG(IQuerySource, ppqs));
        }
    }
    return hr;
}

BOOL CShellExecMenu::_SupportsType(UINT idVerb)
{
    BOOL fRet = TRUE;
    if (SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("CheckSupportedTypes"), NULL, NULL, NULL)))
    {
        //  need to check the supported types for this application
        // get the first item and then check it against SupportedFileExtensions
        CComPtr<IShellItem> spsi;
        if (SUCCEEDED(DataObj_GetIShellItem(_pdtobj, &spsi)))
        {
            SFGAOF sfgao;
            if (S_OK == spsi->GetAttributes(SFGAO_STREAM, &sfgao))
            {
                CSmartCoTaskMem<OLECHAR> spszName;
                if (SUCCEEDED(spsi->GetDisplayName(SIGDN_PARENTRELATIVEPARSING, &spszName)))
                {
                    PWSTR pszExt = PathFindExtension(spszName);
                    if (*pszExt)
                    {
                        CComPtr<IQuerySource> spqs;
                        if (SUCCEEDED(_GetAppSource(_hkeyProgID, _dka.ExposeName(idVerb), &spqs)))
                        {
                            fRet = SUCCEEDED(spqs->QueryValueExists(L"SupportedTypes", pszExt));
                        }
                    }
                }
            }
        }
    }
    return fRet;
}
                            
//                       
//      LegacyDisable 
//  LegacyDisable is set, then the verb exists only for legacy reasons, and 
//  is actually superceded by a context menu extension or some other behavior
//  it there only to retain legacy behavior for external clients that require
//  the existence of a verb.
//
BOOL CShellExecMenu::_RemoveVerb(UINT idVerb)
{
    if (SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("LegacyDisable"), NULL, NULL, NULL)))
        return TRUE;

    if (!_SupportsType(idVerb))
        return TRUE;
        
    return (_IsRestricted(idVerb));
}

BOOL CShellExecMenu::_IsVisible(BOOL fExtended, UINT idVerb)
{
    //  this is not an extended verb, or
    //  the request includes extended verbs
    if (!fExtended && SUCCEEDED(_dka.GetValue(idVerb, NULL, TEXT("Extended"), NULL, NULL, NULL)))
        return FALSE;

    static const struct {
        LPCTSTR pszVerb;
    } sVerbIgnore[] = {
        c_szPrintTo
    };

    for (int i = 0; i < ARRAYSIZE(sVerbIgnore); i++)
    {
        if (lstrcmpi(_dka.ExposeName(idVerb), sVerbIgnore[i].pszVerb) == 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

    
BOOL CShellExecMenu::_GetMenuString(UINT id, BOOL fExtended, LPTSTR pszMenu, UINT cchMax)
{
    BOOL bRet = FALSE;
    //  other verbs are hidden and just shouldnt be shown.
    if (SUCCEEDED(_InsureVerbs(id)) && _IsVisible(fExtended, id))
    {
        DWORD cbVerb = CbFromCch(cchMax);
        *pszMenu = 0;
        //  try the MUIVerb value first
        //  if that fails use the default value
        //  either of these can actually have an MUI string
        if (FAILED(_dka.GetValue(id, NULL, TEXT("MUIVerb"), NULL, pszMenu, &cbVerb)))
        {
            cbVerb = CbFromCch(cchMax);
            _dka.GetValue(id, NULL, NULL, NULL, pszMenu, &cbVerb);
        }

        if (!*pszMenu || FAILED(SHLoadIndirectString(pszMenu, pszMenu, cchMax, NULL)))
        {
            // If it does not have the value, generate it.
            bRet = _MenuString(_dka.ExposeName(id), pszMenu, cchMax);
        }
        else
        {
            //  use the value
            bRet = TRUE;
        }
        ASSERT(!bRet || *pszMenu);
    }
    return bRet;
}

STDMETHODIMP CShellExecMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    // new behavior: good context menus should interpret a NULL pidlFolder/hkeyProgID on a re-init
    // as meaning they should use the ones they already have.
    if (hkeyProgID)
    {
        _Cleanup(); // cleans up hkey and hdka, pdtobj too but that's ok
        _hkeyProgID = SHRegDuplicateHKey(hkeyProgID);   // make a copy
    }
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

UINT CShellExecMenu::_VerbCount()
{
    return SUCCEEDED(_InsureVerbs()) ? _dka.GetItemCount() : 0;
}

UINT CShellExecMenu::_FindIndex(LPCTSTR pszVerb)
{
    for (UINT i = 0; i < _VerbCount(); i++)
    {
        if (!lstrcmpi(pszVerb, _dka.ExposeName(i)))
            return i;       // found it!
    }
    return -1;
}

STDMETHODIMP CShellExecMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT cVerbs = 0;
    _uFlags = uFlags;   // caller may force explorer mode (CMF_EXPLORE) here

    TCHAR szMenu[CCH_MENUMAX];
    for (UINT idCmd = idCmdFirst;
         idCmd <= idCmdLast && (idCmd - idCmdFirst) < _VerbCount(); idCmd++)
    {
        UINT uMenuFlags = MF_BYPOSITION | MF_STRING;
        if (_GetMenuString(idCmd - idCmdFirst, uFlags & CMF_EXTENDEDVERBS, szMenu, ARRAYSIZE(szMenu)))
        {
            InsertMenu(hmenu, indexMenu + cVerbs, uMenuFlags, idCmd, szMenu);
            cVerbs++;
        }
    }

    if (cVerbs && (GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1))
    {
        if (_dka.HasDefault(_hkeyProgID))
        {
            //  if there is a default verb on this key,
            //  trust that it was the first one that the CDKA added
            SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);
        }
    }

    return ResultFromShort(_VerbCount());
}

LPCTSTR CShellExecMenu::_GetVerb(UINT id)
{
    return SUCCEEDED(_InsureVerbs()) ? _dka.ExposeName(id) : NULL;
}

STATIC BOOL s_fAbortInvoke = FALSE;

// This private export allows the folder code a way to cause the main invoke
// loops processing several different files to abort.

STDAPI_(void) SHAbortInvokeCommand()
{
    DebugMsg(DM_TRACE, TEXT("AbortInvokeCommand was called"));
    s_fAbortInvoke = TRUE;
}

// Call shell exec (for the folder class) using the given file and the
// given pidl. The file will be passed as %1 in the dde command and the pidl
// will be passed as %2.

STDAPI _InvokePidl(LPCMINVOKECOMMANDINFOEX pici, DWORD dwAttribs, LPCTSTR pszPath, LPCITEMIDLIST pidl, HKEY hkClass)
{
    SHELLEXECUTEINFO ei;
    HRESULT hr = ICIX2SEI(pici, &ei);
    pszPath = (dwAttribs & SFGAO_FILESYSTEM) ? pszPath : NULL;
    if (SUCCEEDED(hr))
    {
        ei.fMask |= SEE_MASK_IDLIST;

        ei.lpFile = pszPath;
        ei.lpIDList = (void *)pidl;

        // if a directory is specifed use that, else make the current
        // directory be the folder it self. UNLESS it is a AUDIO CDRom, it
        // should never be the current directory (causes CreateProcess errors)
        if (!ei.lpDirectory && (dwAttribs & SFGAO_FOLDER))
            ei.lpDirectory = pszPath;

        if (pszPath && ei.lpDirectory)
        {
            INT iDrive = PathGetDriveNumber(ei.lpDirectory);

            CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive);

            if (pmtpt)
            {
                if (pmtpt->IsAudioCDNoData())
                {
                    ei.lpDirectory = NULL;
                }

                pmtpt->Release();
            }
        }

        if (hkClass)
        {
            ei.hkeyClass = hkClass;
            ei.fMask |= SEE_MASK_CLASSKEY;
        }
        else 
            ei.fMask |= SEE_MASK_INVOKEIDLIST;
    
        if (ShellExecuteEx(&ei))
            hr = S_OK;
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

BOOL _QuitInvokeLoop()
{
    MSG msg;

    // Try to give the user a way to escape out of this
    if (s_fAbortInvoke || GetAsyncKeyState(VK_ESCAPE) < 0)
        return TRUE;

    // And the next big mondo hack to handle CAD of our window
    // because the user thinks it is hung.
    if (PeekMessage(&msg, NULL, WM_CLOSE, WM_CLOSE, PM_NOREMOVE))
        return TRUE;  // Lets also bail..

    return FALSE;
}

#define CMINVOKE_VERBT(pici) (pici)->lpVerbW

HRESULT CShellExecMenu::_MapVerbForInvoke(CMINVOKECOMMANDINFOEX *pici, UINT *pidVerb)
{
    LPCTSTR pszVerbKey;
    // is pici->lpVerb specifying the verb index (0-based).
    if (IS_INTRESOURCE(pici->lpVerb))
    {
        // find it in the CDKA
        *pidVerb = LOWORD((ULONG_PTR)pici->lpVerb);
        pszVerbKey = _GetVerb(*pidVerb);
        CMINVOKE_VERBT(pici) = pszVerbKey;  // alias into the CDKA
        RIPMSG(pszVerbKey != NULL, "CShellExecMenu::InvokeCommand() passed an invalid verb id");
    }
    else
    {
        pszVerbKey = CMINVOKE_VERBT(pici);
        if (pszVerbKey)
        {  
            *pidVerb = _FindIndex(pszVerbKey);
            if (-1 == *pidVerb)
                pszVerbKey = NULL;  // not in our list
        }
    }

    ASSERT(!pszVerbKey || *pidVerb != -1);
    return pszVerbKey ? S_OK : E_INVALIDARG;
}

BOOL CShellExecMenu::_IsExplorerMode()
{
    BOOL bRet = (_uFlags & CMF_EXPLORE);
    if (!bRet)
    {
        bRet = IsExplorerModeBrowser(_punkSite);
        if (bRet)
            _uFlags |= CMF_EXPLORE;
    }
    return bRet;
}

DWORD CShellExecMenu::_BrowseFlagsFromVerb(UINT idVerb)
{
    DWORD dwFlags = 0;
    DWORD cbFlags = sizeof(dwFlags);
    _dka.GetValue(idVerb, NULL, _IsExplorerMode() ? TEXT("ExplorerFlags") : TEXT("BrowserFlags"), NULL, &dwFlags, &cbFlags);
    return dwFlags;
}

HRESULT CShellExecMenu::_TryBrowseObject(LPCITEMIDLIST pidl, DWORD uFlags)
{
    HRESULT hr = S_FALSE;

    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        hr = psb->BrowseObject(pidl, (UINT) uFlags);
        psb->Release();
    }
    return hr;
}

HRESULT _CanTryBrowseObject(DWORD dwAttribs, CMINVOKECOMMANDINFOEX* pici)
{
    HRESULT hr = S_FALSE;

    if (dwAttribs & SFGAO_FOLDER)
    {
        // we need to sniff the iciex here to see if there is anything special in it
        // that cannot be conveyed to IShellBrowser::BrowseObject() (eg the nShow parameter)
        if ((pici->nShow == SW_SHOWNORMAL)  ||
            (pici->nShow == SW_SHOW))
        {
            // nothing special in the ICIEX, should be safe to discard it and use 
            // IShellBrowser::BrowseObject() instead of ShellExecuteEx
            hr = S_OK;
        }
    }

    return hr;
}

BOOL CShellExecMenu::_VerbCanDrop(UINT idVerb, CLSID *pclsid)
{
    TCHAR sz[GUIDSTR_MAX];
    DWORD cb = sizeof(sz);
    return (SUCCEEDED(_dka.GetValue(idVerb, L"DropTarget", L"Clsid", NULL, sz, &cb))
            && GUIDFromString(sz, pclsid));
}

HRESULT CShellExecMenu::_DoDrop(REFCLSID clsid, UINT idVerb, LPCMINVOKECOMMANDINFOEX pici)
{
    //  i think i need to persist the pici into the _pdtobj
    //  and probably add some values under the pqs
    //  we assume that the app will do something appropriate 
    //  QueryService(_punkSite, clsid) might be useful
    return SHSimulateDropOnClsid(clsid, _punkSite, _pdtobj);
}

STDMETHODIMP CShellExecMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    CMINVOKECOMMANDINFOEX ici;
    void *pvFree;
    HRESULT hr = ICI2ICIX(pici, &ici, &pvFree); // thunk incomming params
    if (SUCCEEDED(hr))
    {   
        UINT idVerb;
        hr = _MapVerbForInvoke(&ici, &idVerb);
        if (SUCCEEDED(hr))
        {
            CLSID clsid;
            if (_VerbCanDrop(idVerb, &clsid))
            {
                hr = _DoDrop(clsid, idVerb, &ici);
            }
            else
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(_pdtobj, &medium);
                if (pida)
                {
                    if (pida->cidl == 1)
                    {
                        LPITEMIDLIST pidl = IDA_FullIDList(pida, 0);
                        if (pidl)
                        {
                            hr = _InvokeOne(&ici, idVerb, pidl);
                            ILFree(pidl);
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        hr = _InvokeMany(&ici, idVerb, pida);
                    }

                    HIDA_ReleaseStgMedium(pida, &medium);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }

        if (pvFree)
            LocalFree(pvFree);
    }

    return hr;
}

HRESULT CShellExecMenu::_InvokeOne(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    TCHAR szPath[MAX_PATH];
    DWORD dwAttrib = SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_LINK;
    SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &dwAttrib);

    if (S_OK == _CanTryBrowseObject(dwAttrib, pici))
    {
        DWORD uFlags = _BrowseFlagsFromVerb(idVerb);
        if (uFlags)
        {
            // if we did the site based navigation, we are done
            hr = _TryBrowseObject(pidl, uFlags);
        }
    }

    if (hr != S_OK)
    {
        hr = _InvokePidl(pici, dwAttrib, szPath, pidl, _hkeyProgID);

        //  only set recent on non-folders (SFGAO_STREAM?)
        //  and non-link since we know those should never be added
        if (SUCCEEDED(hr) && !(dwAttrib & (SFGAO_FOLDER | SFGAO_LINK)))
        {
            AddToRecentDocs(pidl, szPath);
        }
    }
    
    return hr;
}

BOOL _ShouldPrompt(DWORD cItems)
{
    DWORD dwMin, cb = sizeof(dwMin);
    if (SHRegGetUSValue(REGSTR_PATH_EXPLORER, TEXT("MultipleInvokePromptMinimum"), NULL, &dwMin, &cb, FALSE, NULL, 0) != ERROR_SUCCESS)
        dwMin = 15;

    return cItems > dwMin;
}

HRESULT CShellExecMenu::_PromptUser(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida)
{
    HRESULT hr = S_FALSE;
    if (pici->hwnd && !(pici->fMask & CMIC_MASK_FLAG_NO_UI)
    && _ShouldPrompt(pida->cidl))
    {
        //  prompt the user with the verb and count
        //  we make a better experience if we keyed off 
        //  homo/hetero types and had different behaviors
        //  but its not worth it.  instead we should 
        //  switch to using AutoPlay sniffing and dialog.
        TCHAR szVerb[64];
        TCHAR szNum[10];
        wnsprintf(szNum, ARRAYSIZE(szNum), TEXT("%d"), pida->cidl);
        hr = _GetHelpText(idVerb, GCS_HELPTEXT, (PSTR)szVerb, ARRAYSIZE(szVerb));
        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            PTSTR pszTitle = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_MULTIINVOKEPROMPT_TITLE), szVerb);
            if (pszTitle)
            {
                PTSTR pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_MULTIINVOKEPROMPT_MESSAGE), szVerb, szNum);
                if (pszMsg)
                {
                    int iRet = SHMessageBoxCheck(pici->hwnd, pszMsg, pszTitle, (MB_OKCANCEL | MB_ICONEXCLAMATION), IDOK, TEXT("MultipleInvokePrompt"));
                    hr = iRet == IDOK ? S_OK : HRESULT_FROM_WIN32(ERROR_CANCELLED);

                    LocalFree(pszMsg);
                }
                LocalFree(pszTitle);
            }
        }
    }
    return hr;
}

HRESULT CShellExecMenu::_InvokeEach(LPCITEMIDLIST pidl, CMINVOKECOMMANDINFOEX *pici)
{
    HRESULT hr = E_OUTOFMEMORY;
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        CComPtr<IContextMenu> spcm;
        hr = SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IContextMenu, &spcm));
        if (SUCCEEDED(hr))
        {
            if (_punkSite)
                IUnknown_SetSite(spcm, _punkSite);

            hr = spcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, _uFlags);
            if (SUCCEEDED(hr)) 
            {
                hr = spcm->InvokeCommand((CMINVOKECOMMANDINFO *)pici);
            }

            if (_punkSite)
                IUnknown_SetSite(spcm, NULL);
        }

        DestroyMenu(hmenu);
    }
    return hr;
}

HRESULT CShellExecMenu::_InvokeMany(CMINVOKECOMMANDINFOEX *pici, UINT idVerb, LPIDA pida)
{
    HRESULT hr = _PromptUser(pici, idVerb, pida);
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        s_fAbortInvoke = FALSE; // reset this global for this run...
        //  we want to alter the pici
        //  so that each item is handled individually
        pici->hwnd = NULL;
        pici->fMask |= CMIC_MASK_FLAG_NO_UI;

        //  NTBUG #502223 - MSI apps with DDE start multiple copies - ZekeL 2001-DEC-07
        //  ShellExec() will create a new thread for MSI apps to 
        //  avoid a deadlock with the MSI APIs calling SHChangeNotify().
        //  this is described in NTBUG #200961
        //  however in the multiple invoke case we create one thread
        //  for each item in the invoke, which results in several processes
        //  contending for the DDE conversation.
        //  
        //  this is a half fix.  we prefer to have the buggy behavior in 502223 
        //  over the deadlock behavior in 200961 (a definite PSS call).  
        //  since the deadlock case should only occur for the desktop, 
        //  the rest of the time we will force a synchronous invoke.
        IBindCtx *pbcRelease = NULL;
        if (!IsDesktopBrowser(_punkSite))
        {
            TBCRegisterObjectParam(TBCDIDASYNC, SAFECAST(this, IContextMenu *), &pbcRelease);
        }

        pici->lpVerb = T2A(_dka.ExposeName(idVerb));
        pici->lpVerbW = _dka.ExposeName(idVerb);
        
        for (UINT iItem = 0; !_QuitInvokeLoop() && (iItem < pida->cidl); iItem++)
        {
            LPITEMIDLIST pidl = IDA_FullIDList(pida, iItem);
            if (pidl)
            {
                hr = _InvokeEach(pidl, pici);
                ILFree(pidl);
            }
            else 
                hr = E_OUTOFMEMORY;

            if (hr == E_OUTOFMEMORY)
                break;

        }

        ATOMICRELEASE(pbcRelease);
    }
    return hr;
}

HRESULT CShellExecMenu::_GetHelpText(UINT idVerb, UINT uType, LPSTR pszName, UINT cchMax)
{
    //  TODO - shouldnt we let the registry override?
    HRESULT hr = E_OUTOFMEMORY;
    TCHAR szMenuString[CCH_MENUMAX];
    if (_GetMenuString(idVerb, TRUE, szMenuString, ARRAYSIZE(szMenuString)))
    {
        SHStripMneumonic(szMenuString);
        //  NOTE on US, IDS_VERBHELP is the same as "%s"
        //  do we want some better description?
        LPTSTR pszHelp = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_VERBHELP), szMenuString);
        if (pszHelp)
        {
            if (uType == GCS_HELPTEXTA)
                SHTCharToAnsi(pszHelp, pszName, cchMax);
            else
                SHTCharToUnicode(pszHelp, (LPWSTR)pszName, cchMax);
            LocalFree(pszHelp);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CShellExecMenu::_MapVerbForGCS(UINT_PTR idCmd, UINT uType, UINT *pidVerb)
{
    HRESULT hr = _InsureVerbs();
    if (SUCCEEDED(hr))
    {
        if (IS_INTRESOURCE(idCmd))
            *pidVerb = (UINT)idCmd;
        else
        {
            *pidVerb = -1;
            if (!(uType & GCS_UNICODE))
            {
                USES_CONVERSION;
                *pidVerb = _FindIndex(A2W((LPCSTR)idCmd));
            }

            // we fall back to the TCHAR version regardless
            // of what the caller passed in uType
            if (*pidVerb == -1)
            {
                if (!IsBadStringPtrW((LPCWSTR)idCmd, (UINT)-1))
                    *pidVerb = _FindIndex((LPCWSTR)idCmd);
            }
        }
        hr = *pidVerb < _VerbCount() ? S_OK : E_INVALIDARG;
    }

    //  VALIDATE returns S_FALSE for bad verbs
    if (FAILED(hr) && (uType == GCS_VALIDATEA || uType == GCS_VALIDATEW))
        hr = S_FALSE;
        
    return hr;
}
    
STDMETHODIMP CShellExecMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax)
{
    UINT idVerb;
    HRESULT hr = _MapVerbForGCS(idCmd, uType, &idVerb);
    if (SUCCEEDED(hr))
    {
        //  the verb is good!
        switch (uType)
        {
        case GCS_HELPTEXTA:
        case GCS_HELPTEXTW:
            hr = _GetHelpText(idVerb, uType, pszName, cchMax);
            break;
            
        case GCS_VERBA:
        case GCS_VERBW:
            {
                if (uType == GCS_VERBA)
                    SHTCharToAnsi(_dka.ExposeName(idVerb), pszName, cchMax);
                else
                    SHTCharToUnicode(_dka.ExposeName(idVerb), (LPWSTR)pszName, cchMax);
                hr = S_OK;
            }
            break;

        case GCS_VALIDATEA:
        case GCS_VALIDATEW:
            //  the hr from MapVerb is good enough
            break;
            
        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    
    return hr;
}

STDMETHODIMP CShellExecMenu::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    return _pfnAddPages(_pdtobj, pfnAddPage, lParam);
}

STDMETHODIMP CShellExecMenu::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}    

STDAPI CShellExecMenu_CreateInstance(LPFNADDPAGES pfnAddPages, REFIID riid, void **ppv)
{
    HRESULT hr;
    CShellExecMenu *pdext = new CShellExecMenu(pfnAddPages); 
    if (pdext)
    {
        hr = pdext->QueryInterface(riid, ppv);
        pdext->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// these handlers slime off of CShellExecMenu's IShellPropSheetExt implementation

STDAPI FileSystem_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

STDAPI CShellFileDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CShellExecMenu_CreateInstance(FileSystem_AddPages, riid, ppv);
}

STDAPI CDrives_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

STDAPI CShellDrvDefExt_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CShellExecMenu_CreateInstance(CDrives_AddPages, riid, ppv);
}

STDAPI PIF_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

STDAPI CProxyPage_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CShellExecMenu_CreateInstance(PIF_AddPages, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shpif.cpp ===
//
//  CPifFile class
//
//  supports:
//
//      IPersistFile    - "load" a PIF file
//      IExtractIcon    - extract a icon from a PIF file.
//

#define NO_INCLUDE_UNION

#include "shellprv.h"

////////////////////////////////////////////////////////////////////////
//  PifFile class
////////////////////////////////////////////////////////////////////////

class PifFile : IShellExtInit, IExtractIcon, IPersistFile
#ifdef UNICODE
    , IExtractIconA
#endif
{

public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IShellExtInit methods ***
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // *** IPersist methods ***
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // *** IPersistFile methods ***
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName);
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // *** IExtractIcon methods ***
    STDMETHODIMP GetIconLocation(UINT uFlags,LPTSTR szIconFile,UINT cchMax,int *piIndex,UINT * pwFlags);
    STDMETHODIMP ExtractIcon(LPCTSTR pszFile,UINT nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons);

#ifdef UNICODE
    // *** IExtractIconA methods ***
    STDMETHODIMP GetIconLocation(UINT uFlags,LPSTR szIconFile,UINT cchMax,int *piIndex,UINT * pwFlags);
    STDMETHODIMP ExtractIcon(LPCSTR pszFile,UINT nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons);
#endif

    PifFile();
    ~PifFile();

    //
    // data
    //
private:
    UINT                cRef;
    int                 hPifProps;
};

////////////////////////////////////////////////////////////////////////
//
//  CPifFile_CreateInstance
//
//      public function to create a instance of a CPifFile
//
////////////////////////////////////////////////////////////////////////

STDAPI CPifFile_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID * ppvOut)
{
    HRESULT hres;
    PifFile *p;

    // does not support aggregation.
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    p = new PifFile();

    if (p == NULL)
        return E_FAIL;

    //
    // Note that the Release member will free the object, if QueryInterface
    // failed.
    //
    hres = p->QueryInterface(riid, ppvOut);
    p->Release();

    return hres;        // S_OK or E_NOINTERFACE
}

////////////////////////////////////////////////////////////////////////
//  constuct/destruct
////////////////////////////////////////////////////////////////////////

PifFile::PifFile()
{
    this->cRef = 1;
}

PifFile::~PifFile()
{
    if (hPifProps)
        PifMgr_CloseProperties(hPifProps, 0);
    hPifProps=0;
}

////////////////////////////////////////////////////////////////////////
//  IUnknown
////////////////////////////////////////////////////////////////////////

STDMETHODIMP PifFile::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        DebugMsg(DM_TRACE, TEXT("PifFile::QueryInterface(IUnknown)"));
        *ppvObj = (IUnknown *)this;
    }
    else if (IsEqualIID(riid, IID_IShellExtInit))
    {
        DebugMsg(DM_TRACE, TEXT("PifFile::QueryInterface(IShellExtInit)"));
        *ppvObj = (IShellExtInit*)this;
    }
    else if (IsEqualIID(riid, IID_IPersistFile))
    {
        DebugMsg(DM_TRACE, TEXT("PifFile::QueryInterface(IPersistFile)"));
        *ppvObj = (IPersistFile*)this;
    }
    else if (IsEqualIID(riid, IID_IExtractIcon))
    {
        DebugMsg(DM_TRACE, TEXT("PifFile::QueryInterface(IExtractIcon)"));
        *ppvObj = (IExtractIcon*)this;
    }
#ifdef UNICODE
    else if (IsEqualIID(riid, IID_IExtractIconA))
    {
        DebugMsg(DM_TRACE, TEXT("PifFile::QueryInterface(IExtractIconA)"));
        *ppvObj = (IExtractIconA*)this;
    }
#endif
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) PifFile::AddRef()
{
    DebugMsg(DM_TRACE, TEXT("PifFile::AddRef() ==> %d"), this->cRef+1);

    this->cRef++;

    return this->cRef;
}

STDMETHODIMP_(ULONG) PifFile::Release()
{
    DebugMsg(DM_TRACE, TEXT("PifFile::Release() ==> %d"), this->cRef-1);

    this->cRef--;

    if (this->cRef>0)
    {
        return this->cRef;
    }

    delete this;

    return 0;
}

////////////////////////////////////////////////////////////////////////
//  IShellExtInit
////////////////////////////////////////////////////////////////////////

STDMETHODIMP PifFile::Initialize(LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj, HKEY hkeyProgID)
{
    DebugMsg(DM_TRACE, TEXT("PifFile::Initialize()"));
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//  IPersistFile
////////////////////////////////////////////////////////////////////////

STDMETHODIMP PifFile::GetClassID(LPCLSID lpClassID)
{
    DebugMsg(DM_TRACE, TEXT("PifFile::GetClass()"));

    *lpClassID = CLSID_PifFile;
    return NOERROR;
}

STDMETHODIMP PifFile::IsDirty()
{
    DebugMsg(DM_TRACE, TEXT("PifFile::IsDirty()"));

    return S_FALSE;
}

STDMETHODIMP PifFile::Load(LPCOLESTR pwszFile, DWORD grfMode)
{
    TCHAR szPath[MAX_PATH];

    SHUnicodeToTChar(pwszFile, szPath, ARRAYSIZE(szPath));

    DebugMsg(DM_TRACE, TEXT("PifFile::Load(%s)"), szPath);

    if (hPifProps)
        PifMgr_CloseProperties(hPifProps, 0);

    hPifProps = PifMgr_OpenProperties(szPath, NULL, 0, 0);

    return hPifProps == 0 ? E_FAIL : S_OK;
}

STDMETHODIMP PifFile::Save(LPCOLESTR pwszFile, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP PifFile::SaveCompleted(LPCOLESTR pwszFile)
{
    return E_NOTIMPL;
}

STDMETHODIMP PifFile::GetCurFile(LPOLESTR * lplpszFileName)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//  IExtractIcon
////////////////////////////////////////////////////////////////////////

STDMETHODIMP PifFile::GetIconLocation(UINT uFlags, LPTSTR szIconFile,UINT cchMax,int *piIndex,UINT * pwFlags)
{
    PROPPRG ProgramProps;

    VDATEINPUTBUF(szIconFile, TCHAR, cchMax);

    if (hPifProps == 0)
        return E_FAIL;

    if (!PifMgr_GetProperties(hPifProps,MAKEINTATOM(GROUP_PRG), &ProgramProps, SIZEOF(ProgramProps), 0))
    {
        DebugMsg(DM_TRACE, TEXT("PifFile::GetIconLocation() PifMgr_GetProperties *failed*"));
        return E_FAIL;
    }

    if (ProgramProps.achIconFile[0] == 0)
    {
        lstrcpy(szIconFile, ICONFILE_DEFAULT);
        *piIndex = ICONINDEX_DEFAULT;
    }
    else
    {
        lstrcpy(szIconFile, ProgramProps.achIconFile);
        *piIndex = ProgramProps.wIconIndex;
    }
    *pwFlags = 0;

    DebugMsg(DM_TRACE, TEXT("PifFile::GetIconLocation() ==> %s!%d"), szIconFile, *piIndex);
    return S_OK;
}

STDMETHODIMP PifFile::ExtractIcon(LPCTSTR pszFile,UINT nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons)
{
    DebugMsg(DM_TRACE, TEXT("PifFile::ExtractIcon()"));
    return E_NOTIMPL;
}

#ifdef UNICODE
////////////////////////////////////////////////////////////////////////
//  IExtractIconA
////////////////////////////////////////////////////////////////////////

STDMETHODIMP PifFile::GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT cchMax,int *piIndex, UINT * pwFlags)
{
    WCHAR szIconFile[MAX_PATH];
    HRESULT hres;

    VDATEINPUTBUF(pszIconFile, TCHAR, cchMax);

    DebugMsg(DM_TRACE, TEXT("PifFile::IExtractIconA::GetIconLocation()"));

    hres = this->GetIconLocation(uFlags,szIconFile,ARRAYSIZE(szIconFile), piIndex, pwFlags);

    //
    // We don't want to copy the icon file name on the S_FALSE case
    //
    if (SUCCEEDED(hres) && hres != S_FALSE)
    {
        SHUnicodeToAnsi(szIconFile, pszIconFile, cchMax);
    }
    return hres;
}

STDMETHODIMP PifFile::ExtractIcon(LPCSTR pszFile,UINT nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons)
{
    DebugMsg(DM_TRACE, TEXT("PifFile::IExtractIconA::ExtractIcon()"));
    return E_NOTIMPL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shlexec2.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "fstreex.h"

typedef struct {
    HWND hDlg;
    // input output
    LPTSTR   lpszExe;   // base file name (to search for)
    LPTSTR   lpszPath;  // starting location for search
    LPCTSTR  lpszName;  // doc type name "Winword Document"
} FINDEXE_PARAMS, *LPFINDEXE_PARAMS;


int CALLBACK LocateCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    TCHAR szPath[MAX_PATH + 80];
    int id;
    LPFINDEXE_PARAMS lpfind = (LPFINDEXE_PARAMS)lpData;

    switch(uMsg)
    {
        case BFFM_SELCHANGED:
            SHGetPathFromIDList((LPITEMIDLIST)lParam, szPath);
            if ((lstrlen(szPath) + lstrlen(lpfind->lpszExe)) <  MAX_PATH)
            {
                PathAppend(szPath, lpfind->lpszExe);
                if (PathFileExistsAndAttributes(szPath, NULL))
                {
                    id = IDS_FILEFOUND;
                }
                else
                {
                    id = IDS_FILENOTFOUND;
                }
            }
            else
            {
                id = IDS_FILENOTFOUND;
            }
            SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, id);
            break;

        case BFFM_INITIALIZED:
            SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, IDS_FILENOTFOUND);
            break;
    }
    return 0;
}

void _GetBrowseTitle(LPFINDEXE_PARAMS lpfind, LPTSTR lpszBuffer, UINT cchBuffer)
{
    TCHAR szTemplate[100];
    LoadString(HINST_THISDLL, IDS_FINDASSEXEBROWSETITLE, szTemplate, ARRAYSIZE(szTemplate));
    wnsprintf(lpszBuffer, cchBuffer, szTemplate, lpfind->lpszExe);
}

void DoBrowseForFile(LPFINDEXE_PARAMS lpfind)
{
    TCHAR szFilePath[MAX_PATH] = { 0 };       // buffer for file name
    TCHAR szInitialDir[MAX_PATH] = { 0 };       // buffer for file name

    // initial directory to Program Files
    SHGetSpecialFolderPath(NULL, szInitialDir, CSIDL_PROGRAM_FILES, TRUE); 

    if (GetFileNameFromBrowse(lpfind->hDlg, szFilePath, ARRAYSIZE(szFilePath), szInitialDir, 
            MAKEINTRESOURCE(IDS_EXE), MAKEINTRESOURCE(IDS_PROGRAMSFILTER), MAKEINTRESOURCE(IDS_BROWSE)))
    {
        SetDlgItemText(lpfind->hDlg, IDD_PATH, szFilePath);
        lstrcpy((LPTSTR)lpfind->lpszPath, szFilePath);
    }
}

void InitFindDlg(HWND hDlg, LPFINDEXE_PARAMS lpfind)
{
    TCHAR szPath[MAX_PATH]; /* This must be the same size as lpfind->lpszPath */
    TCHAR szBuffer[MAX_PATH + 100];

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpfind);
    lpfind->hDlg = hDlg;

    GetDlgItemText(hDlg, IDD_TEXT1, szPath, ARRAYSIZE(szPath));
    wsprintf(szBuffer, szPath, lpfind->lpszExe, lpfind->lpszName);
    SetDlgItemText(hDlg, IDD_TEXT1, szBuffer);

    GetDlgItemText(hDlg, IDD_TEXT2, szPath, ARRAYSIZE(szPath));
    wsprintf(szBuffer, szPath, lpfind->lpszExe);
    SetDlgItemText(hDlg, IDD_TEXT2, szBuffer);

    SetDlgItemText(hDlg, IDD_PATH, lpfind->lpszPath);

    SHAutoComplete(GetDlgItem(hDlg, IDD_PATH), (SHACF_FILESYSTEM | SHACF_URLALL | SHACF_FILESYS_ONLY));
}

BOOL FindOk(LPFINDEXE_PARAMS lpfind)
{
    GetDlgItemText(lpfind->hDlg, IDD_PATH, lpfind->lpszPath, MAX_PATH);

    // If they entered a directory, then append the EXE name to it
    // The dialog is confusing - it asks for the "location".  Does that
    // mean I should enter the directory or the filename?
    // Allow both to work.
    if (PathIsDirectory(lpfind->lpszPath))
    {
        PathAppend(lpfind->lpszPath, lpfind->lpszExe);
    }

    if (!PathFileExistsAndAttributes(lpfind->lpszPath, NULL))
    {
        ShellMessageBox(HINST_THISDLL, lpfind->hDlg,
                          MAKEINTRESOURCE(IDS_STILLNOTFOUND), NULL, MB_ICONHAND | MB_OK, (LPTSTR)lpfind->lpszPath);
        return FALSE;
    }

    // HACKHACK we should use the registry but it's too late now;
    // Win95 shipped with this code so it's gonna be in win.ini forever...
    WriteProfileString(TEXT("programs"), lpfind->lpszExe, lpfind->lpszPath);
    return TRUE;
}

//----------------------------------------------------------------------------
// FindExeDlgProc was mistakenly exported in the original NT SHELL32.DLL when
// it didn't need to be (dlgproc's, like wndproc's don't need to be exported
// in the 32-bit world).  In order to maintain loadability of some app
// which might have linked to it, we stub it here.  If some app ended up really
// using it, then we'll look into a specific fix for that app.
//
// -BobDay
//
BOOL_PTR WINAPI FindExeDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LONG lParam )
{
    return FALSE;
}

BOOL_PTR CALLBACK FindExeDlgProcA(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
  LPFINDEXE_PARAMS lpfind = (LPFINDEXE_PARAMS)GetWindowLongPtr(hDlg, DWLP_USER);

  switch (wMsg)
    {
      case WM_INITDIALOG:
        InitFindDlg(hDlg, (LPFINDEXE_PARAMS)lParam);
        break;

      case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
          {
            case IDD_BROWSE:
              DoBrowseForFile(lpfind);
              break;

            case IDOK:
              if (!FindOk(lpfind))
                break;

              // fall through

            case IDCANCEL:
              EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
              break;

          }

        break;

      default:
        return FALSE;
    }

  return TRUE;
}

//
//  Give a command line, change the exe (leaving the args).  For example,
//  PathReplaceExe(C:\Old\foo.exe -silent, C:\NewDirectory\foo.exe)
//  yields C:\NewDirectory\foo.exe -silent.
//
void PathReplaceExe(LPTSTR lpCommand, UINT cchCommand, LPCTSTR pszExe)
{
    LPTSTR lpArgs;

    lpArgs = PathGetArgs(lpCommand);
    if (*lpArgs)
    {
        // Must save the original args before copying pszExe because it
        // might overwrite lpCommand.  I could be clever with hmemcpy and
        // avoid allocating memory but this function is called so rarely
        // it isn't worth it.
        UINT cchArgs = lstrlen(lpArgs);
        LPTSTR lpArgsCopy = (LPTSTR)_alloca((cchArgs + 1) * sizeof(TCHAR));
        lstrcpy(lpArgsCopy, lpArgs);

        lstrcpyn(lpCommand, pszExe, cchCommand);
        PathQuoteSpaces(lpCommand);
        // lpArgs is no good after this point

        lstrcatn(lpCommand, c_szSpace, cchCommand);
        lstrcatn(lpCommand, lpArgsCopy, cchCommand);
    }
    else
    {
        lstrcpyn(lpCommand, pszExe, cchCommand);
        PathQuoteSpaces(lpCommand);
    }
}

 //
 // put up cool ui to find the exe responsible for performing
 // a ShellExecute()
 // "excel.exe foo.xls" -> "c:\excel\excel.exe foo.xls"
 //
 // in:
 //     hwnd        to post UI on
 //     lpCommand   command line to try to repair [in/out]
 //     cchCommand  size of lpCommand buffer
 //     hkeyProgID  program ID
 //
 // out:
 //     lpCommand   change cmd line if we returned -1
 //
 // returns:
 //     -1  we found a new location lpCommand, use it
 //     or other win exec error codes, notably...
 //     2   we really didn't find it
 //     15  user cancel, fail the exec quietly
 //

int FindAssociatedExe(HWND hwnd, LPTSTR lpCommand, UINT cchCommand,
                                 LPCTSTR pszDocument, HKEY hkeyProgID)
{
    FINDEXE_PARAMS find;
    TCHAR szPath[MAX_PATH];
    TCHAR szExe[MAX_PATH];
    TCHAR szType[MAX_PATH];

    // strip down to just the EXE name
    lstrcpyn(szPath, lpCommand, ARRAYSIZE(szPath));
    PathRemoveArgs(szPath);
    PathUnquoteSpaces(szPath);

    // check to see if the file does exist. if it does then
    // the original exec must have failed because some
    // dependant DLL is missing.  so we return file not
    // found, even though we really found the file

    PathAddExtension(szPath, NULL);
    if (PathFileExists(szPath))
        return SE_ERR_FNF;          // file exists, but some dll must not

    // store the file name component
    lstrcpyn(szExe, PathFindFileName(szPath), ARRAYSIZE(szExe));

    // HACKHACK we should use the registry but it's too late now;
    // Win95 shipped with this code so it's gonna be in win.ini forever...

    GetProfileString(TEXT("programs"), szExe, szNULL, szPath, ARRAYSIZE(szPath));
    if (szPath[0]) {
        if (PathFileExists(szPath)) {
            PathReplaceExe(lpCommand, cchCommand, szPath); // return the new path
            return -1;                      // this means to try again
        }

        PathRemoveFileSpec(szPath);
    } else {
        /* Prompt with the disk that Windows is on */
        GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
        szPath[3] = TEXT('\0');
    }

    SHGetTypeName(pszDocument, hkeyProgID, FALSE, szType, ARRAYSIZE(szType));

    find.lpszExe = szExe;       // base file name (to search for)
    find.lpszPath = szPath;     // starting location for search
    find.lpszName = szType;     // file type we are looking for

    switch (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_FINDEXE), hwnd, FindExeDlgProcA, (LPARAM)(LPFINDEXE_PARAMS)&find))
    {
    case IDOK:
        PathReplaceExe(lpCommand, cchCommand, szPath); // return the new path
        return -1;                  // file found and lpCommand fixed up

    case IDCANCEL:
        return ERROR_INVALID_FUNCTION; // This is the user cancel return

    default:
        return SE_ERR_FNF;             // stick with the file not found
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shtdndlg.c ===
/*************************************************************************
 Private shell shutdown dialog implementation

  The shell needs a shutdown dialog implementation independent of MSGINA's
  implementation to ensure it will function on NT4 and Win9x machines.

  This version of shutdown should only be called if the LoadLib and
  GetProcAddress for the MSGINA version fail.

  This code should be kept in some type of sync with the code in 
  win/gina/msgina/shtdndlg.c

  -dsheldon 10/27/98
*************************************************************************/

#include "shellprv.h"

#include <windowsx.h>
#include <help.h>

#define MAX_SHTDN_OPTIONS               7

#define MAX_CCH_NAME 64
#define MAX_CCH_DESC 256

typedef struct _SHUTDOWNOPTION
{
    DWORD dwOption;
    TCHAR szName[MAX_CCH_NAME + 1];
    TCHAR szDesc[MAX_CCH_DESC + 1];
} SHUTDOWNOPTION, *PSHUTDOWNOPTION;

typedef struct _SHUTDOWNDLGDATA
{
    SHUTDOWNOPTION rgShutdownOptions[MAX_SHTDN_OPTIONS];
    int cShutdownOptions;
    DWORD dwFlags;
    DWORD dwItemSelect;
    BOOL fEndDialogOnActivate;
} SHUTDOWNDLGDATA, *PSHUTDOWNDLGDATA;

// Internal function prototypes
void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc, 
                               PSHUTDOWNOPTION pOption);

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata);

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

DWORD GetOptionSelection(HWND hwndCombo);

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

BOOL_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam);

// Copied function implementations and constants
// A function copied from gina that shutdown dialog needs.
/*-----------------------------------------------------------------------------
/ MoveControls
/ ------------
/   Load the image and add the control to the dialog.
/
/ In:
/   hWnd = window to move controls in
/   aID, cID = array of control ids to be moved
/   dx, dy = deltas to apply to controls
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID MoveControls(HWND hWnd, UINT* aID, INT cID, INT dx, INT dy, BOOL fSizeWnd)
{
    RECT rc;

    while ( --cID >= 0 )
    {
        HWND hWndCtrl = GetDlgItem(hWnd, aID[cID]);

        if ( hWndCtrl )
        {
            GetWindowRect(hWndCtrl, &rc);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);
            OffsetRect(&rc, dx, dy);
            SetWindowPos(hWndCtrl, NULL, rc.left, rc.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
        }
    }

    if ( fSizeWnd )
    {
        GetWindowRect(hWnd, &rc);
        MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT)&rc, 2);
        SetWindowPos(hWnd, NULL,
                     0, 0, (rc.right-rc.left)+dx, (rc.bottom-rc.top)+dy,
                     SWP_NOZORDER|SWP_NOMOVE);
    }
}

/****************************************************
 Option flags (dwFlags)
 ----------------------
****************************************************/
#define SHTDN_NOHELP                    0x000000001
#define SHTDN_NOPALETTECHANGE           0x000000002

// Shutdown reg value name
#define SHUTDOWN_SETTING TEXT("Shutdown Setting")

// Da code
// -------

BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc, 
                               PSHUTDOWNOPTION pOption)
{
    BOOL fSuccess = (LoadString(HINST_THISDLL, idStringName, pOption->szName,
        ARRAYSIZE(pOption->szName)) != 0);

    fSuccess &= (LoadString(HINST_THISDLL, idStringDesc, pOption->szDesc,
        ARRAYSIZE(pOption->szDesc)) != 0);

    return fSuccess;
}

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata)
{
    BOOL fSuccess = TRUE;
    pdata->cShutdownOptions = 0;

    if (dwItems & SHTDN_LOGOFF)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_LOGOFF;

        // Note that logoff is a special case: format using a user name ala
        // "log off <username>".
        fSuccess &= LoadShutdownOptionStrings(IDS_LOGOFF_NAME, 
            IDS_LOGOFF_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions]));

        if (fSuccess)
        {
            TCHAR szTemp[ARRAYSIZE(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName)];

            if (szUsername != NULL)
            {
                wnsprintf(szTemp, ARRAYSIZE(szTemp),
                    pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                    szUsername);
            }
            else
            {
                wnsprintf(szTemp, ARRAYSIZE(szTemp),
                    pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                    TEXT(""));
            }

            // Now we have the real logoff title in szTemp; copy is back
            lstrcpy(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                szTemp); 

            // Success!
            pdata->cShutdownOptions ++;
        }

    }

    if (dwItems & SHTDN_SHUTDOWN)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SHUTDOWN;
        fSuccess &= LoadShutdownOptionStrings(IDS_SHUTDOWN_NAME, 
            IDS_SHUTDOWN_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_RESTART)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART;
        fSuccess &= LoadShutdownOptionStrings(IDS_RESTART_NAME, 
            IDS_RESTART_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_RESTART_DOS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART_DOS;
        fSuccess &= LoadShutdownOptionStrings(IDS_RESTARTDOS_NAME, 
            IDS_RESTARTDOS_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_SLEEP)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP;
        fSuccess &= LoadShutdownOptionStrings(IDS_SLEEP_NAME, 
            IDS_SLEEP_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_SLEEP2)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP2;
        fSuccess &= LoadShutdownOptionStrings(IDS_SLEEP2_NAME, 
            IDS_SLEEP2_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_HIBERNATE)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_HIBERNATE;
        fSuccess &= LoadShutdownOptionStrings(IDS_HIBERNATE_NAME, 
            IDS_HIBERNATE_DESC, 
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    return fSuccess;
}

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) lParam;
    HWND hwndCombo;
    int iOption;
    int iComboItem;
    
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);

    // Hide the help button and move over OK and Cancel if applicable
    if (pdata->dwFlags & SHTDN_NOHELP)
    {
        static UINT rgidNoHelp[] = {IDOK, IDCANCEL};
        RECT rc1, rc2;
        int dx;
        HWND hwndHelp = GetDlgItem(hwnd, IDHELP);

        EnableWindow(hwndHelp, FALSE);
        ShowWindow(hwndHelp, SW_HIDE);

        GetWindowRect(hwndHelp, &rc1);
        GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc2);

        dx = rc1.left - rc2.left;

        MoveControls(hwnd, rgidNoHelp, ARRAYSIZE(rgidNoHelp), dx, 0, FALSE);
    }

    // Add the items specified to the combo box
    hwndCombo = GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO);

    for (iOption = 0; iOption < pdata->cShutdownOptions; iOption ++)
    {
        // Add the option
        iComboItem = ComboBox_AddString(hwndCombo, 
            pdata->rgShutdownOptions[iOption].szName);

        if (iComboItem != (int) CB_ERR)
        {
            // Store a pointer to the option
            ComboBox_SetItemData(hwndCombo, iComboItem, 
                &(pdata->rgShutdownOptions[iOption]));

            // See if we should select this option
            if (pdata->rgShutdownOptions[iOption].dwOption == pdata->dwItemSelect)
            {
                ComboBox_SetCurSel(hwndCombo, iComboItem);
            }
        }
    }

    // If we don't have a selection in the combo, do a default selection
    if (ComboBox_GetCurSel(hwndCombo) == CB_ERR)
    {
        ComboBox_SetCurSel(hwndCombo, 0);
    }

    SetShutdownOptionDescription(hwndCombo, 
        GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));

    // If we get an activate message, dismiss the dialog, since we just lost
    // focus
    pdata->fEndDialogOnActivate = TRUE;

    return TRUE;
}

DWORD GetOptionSelection(HWND hwndCombo)
{
    DWORD dwResult;
    PSHUTDOWNOPTION pOption;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != (int) CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);
        dwResult = pOption->dwOption;
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    return dwResult;
}

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic)
{
    int iItem;
    PSHUTDOWNOPTION pOption;

    iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);

        SetWindowText(hwndStatic, pOption->szDesc);
    }
}

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL fHandled = FALSE;
    DWORD dwDlgResult;
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) 
        GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (id)
    {
    case IDOK:
        dwDlgResult = GetOptionSelection(GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO));
        if (dwDlgResult != SHTDN_NONE)
        {
            pdata->fEndDialogOnActivate = FALSE;
            fHandled = TRUE;
            EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
    case IDCANCEL:
        pdata->fEndDialogOnActivate = FALSE;
        EndDialog(hwnd, (int) SHTDN_NONE);
        fHandled = TRUE;
        break;
    case IDC_EXITOPTIONS_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetShutdownOptionDescription(hwndCtl, 
                GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));
            fHandled = TRUE;
        }
        break;
    case IDHELP:
        WinHelp(hwnd, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
        break;
    }
    return fHandled;
}

BOOL_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Shutdown_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Shutdown_OnCommand);
        case WM_INITMENUPOPUP:
        {
            EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        }
        break;
        case WM_SYSCOMMAND:
            // Blow off moves (only really needed for 32bit land).
            if ((wParam & ~0x0F) == SC_MOVE)
                return TRUE;
            break;
        case WM_ACTIVATE:
            // If we're loosing the activation for some other reason than
            // the user click OK/CANCEL then bail.
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

                if (pdata->fEndDialogOnActivate)
                {
                    pdata->fEndDialogOnActivate = FALSE;
                    EndDialog(hwnd, SHTDN_NONE);
                }
            }
            break;
    }

    return FALSE;
}

/****************************************************************************
 ShutdownDialog
 --------------

  Launches the shutdown dialog. 
  
  hWlx and pfnWlxDialogBoxParam MUST be null for this shell-only version

  Other flags are listed in shtdnp.h.
****************************************************************************/
DWORD ShutdownDialog(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect,
                     LPCTSTR szUsername, DWORD dwFlags, void* hWlx, 
                     void* pfnWlxDialogBoxParam)
{
    // Array of shutdown options - the dialog data
    SHUTDOWNDLGDATA data;
    DWORD dwResult;

    // Set the flags
    data.dwFlags = dwFlags;

    // Set the initially selected item
    data.dwItemSelect = dwItemSelect;

    // Read in the strings for the shutdown option names and descriptions
    if (BuildShutdownOptionArray(dwItems, szUsername, &data))
    {
        // Display the dialog and return the user's selection

        // ..if the caller wants, use a Wlx dialog box function
        if ((hWlx != NULL) || (pfnWlxDialogBoxParam != NULL))
        {
            // Error; winlogon should never call this
            // cheesy shell version of shutdown
            dwResult = SHTDN_NONE;
        }
        else
        {
            // Use standard dialog box
            dwResult = (DWORD) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_EXITWINDOWS_DIALOG), hwndParent,
                Shutdown_DialogProc, (LPARAM) &data);
        }
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    return dwResult;
}

DWORD DownlevelShellShutdownDialog(HWND hwndParent, DWORD dwItems, LPCTSTR szUsername)
{
    DWORD dwSelect = SHTDN_NONE;
    DWORD dwDialogResult;
    
    HKEY hkeyShutdown;
    DWORD dwType;
    DWORD dwDisposition;
    LONG lResult;

    // get the User's last selection.
    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER,
                0, 0, 0, KEY_READ, NULL, &hkeyShutdown, &dwDisposition);

    if (lResult == ERROR_SUCCESS) 
    {
        DWORD cbData = sizeof(dwSelect);
        lResult = SHQueryValueEx(hkeyShutdown, SHUTDOWN_SETTING,
            0, &dwType, (LPBYTE)&dwSelect, &cbData);
        RegCloseKey(hkeyShutdown);
    }

    if (dwSelect == SHTDN_NONE)
    {
        dwSelect = SHTDN_SHUTDOWN;
    }

    dwDialogResult = ShutdownDialog(hwndParent, dwItems, dwSelect,
        szUsername, SHTDN_NOPALETTECHANGE, NULL, NULL);

    if (dwDialogResult != SHTDN_NONE)
    {
        // Save back the user's choice to the registry
        if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER,
            0, 0, 0, KEY_WRITE, NULL, &hkeyShutdown, &dwDisposition) == ERROR_SUCCESS) 
        {
            RegSetValueEx(hkeyShutdown, SHUTDOWN_SETTING,
                0, REG_DWORD, (LPBYTE)&dwDialogResult, sizeof(dwDialogResult));
            RegCloseKey(hkeyShutdown);
        }
    }

    return dwDialogResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\shprsht.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "datautil.h"

//
//  This function is a callback function from property sheet page extensions.
//
BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_FILE_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }

    return FALSE;
}

//
//  This function enumerates all the property sheet page extensions for
// specified class and let them add pages.
//
//
int DCA_AppendClassSheetInfo(HDCA hdca, HKEY hkeyProgID, LPPROPSHEETHEADER ppsh, IDataObject *pdtobj)
{
    int i, iStart = -1;
    for (i = 0; i < DCA_GetItemCount(hdca); i++)
    {
        IShellExtInit *psei;
        // These came from HKCR hence need to go through administrator approval
        if (DCA_ExtCreateInstance(hdca, i, &IID_IShellExtInit, &psei) == NOERROR)
        {
            IShellPropSheetExt *pspse;
            if (SUCCEEDED(psei->lpVtbl->Initialize(psei, NULL, pdtobj, hkeyProgID))
              && SUCCEEDED(psei->lpVtbl->QueryInterface(psei, &IID_IShellPropSheetExt, &pspse)))
            {
                int nPagesSave = ppsh->nPages;
                HRESULT hres = pspse->lpVtbl->AddPages(pspse, _AddPropSheetPage, (LPARAM)ppsh);
                if (SUCCEEDED(hres) && hres != S_OK)
                {
                    // Some shell extensions get confused and return S_FALSE when
                    // they didn't add anything, unaware that S_FALSE means "Please
                    // take the page I added and make it the default".  So ignore
                    // the return value if it is out of range.
                    DWORD nPagesAdded = ppsh->nPages - nPagesSave;
                    DWORD nPageWanted = hres - 1;
                    if (nPageWanted < nPagesAdded)
                        iStart = nPagesSave + nPageWanted;
                }
                pspse->lpVtbl->Release(pspse);
            }
            psei->lpVtbl->Release(psei);
        }
    }
    return iStart;
}

HWND FindStubForPidlClass(LPCITEMIDLIST pidl, int iClass)
{
    HWND hwnd;

    if (!pidl)
        return NULL;

    for (hwnd = FindWindow(c_szStubWindowClass, NULL); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        TCHAR szClass[80];

        // find stub windows only
        GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
        if (lstrcmpi(szClass, c_szStubWindowClass) == 0)
        {
            HANDLE hClassPidl;
            DWORD dwProcId;
            DWORD_PTR dwResult;

            GetWindowThreadProcessId(hwnd, &dwProcId);

            // since a propsheet could be doing work & not pumping messages, use a timeout
            // we can almost just do this: hClassPidl = GetWindowLongPtr(hwnd, 0)
            if (!SendMessageTimeout(hwnd, STUBM_GETDATA, 0, 0, SMTO_BLOCK, 3000, &dwResult))
                continue;
            hClassPidl = (HANDLE)dwResult;
            if (hClassPidl)
            {
                LPBYTE lpb = (LPBYTE)SHLockShared(hClassPidl, dwProcId);
                if (lpb)
                {
                    int iClassFound = *(int *)lpb;

                    if (iClassFound == iClass &&
                        ILIsEqual(pidl, (LPITEMIDLIST)(lpb + sizeof(int))) )
                    {
                        SHUnlockShared(lpb);
                        return hwnd;
                    }
                    SHUnlockShared(lpb);
                }
            }
        }
    }
    return NULL;
}

HANDLE _StuffStubWindow(HWND hwnd, LPITEMIDLIST pidlT, int iClass)
{
    DWORD dwProcId;
    HANDLE  hSharedClassPidl;
    UINT uidlSize;

    uidlSize = ILGetSize(pidlT);
    GetWindowThreadProcessId(hwnd, &dwProcId);

    hSharedClassPidl = SHAllocShared(NULL, sizeof(int)+uidlSize, dwProcId);
    if (hSharedClassPidl)
    {
        LPBYTE lpb = SHLockShared(hSharedClassPidl, dwProcId);
        if (lpb)
        {
            *(int *)lpb = iClass;
            memcpy(lpb+sizeof(int),pidlT, uidlSize);
            SHUnlockShared(lpb);
            SendMessage(hwnd, STUBM_SETDATA, (WPARAM)hSharedClassPidl, 0);
            return hSharedClassPidl;
        }
        SHFreeShared(hSharedClassPidl, dwProcId);
    }

    return NULL;
}

//
//  Make sure we are the only stub window for this pidl/class.
//
//  If so, saves information in the UNIQUESTUBINFO structure which keeps
//  track of the uniqueness key.  After you are done, you must pass the
//  UNIQUESTUBINFO structure to FreeUniqueStub() to clean up the uniqueness
//  key and destroy the stub window.  Returns TRUE.
//
//  If a stub window already exists for this pidl/class, then sets focus
//  to the existing window that matches our uniqueness key and returns FALSE.
//
//  In low memory conditions, plays it safe and declares the pidl/class
//  unique.
//
//
//  Example:
//
//      UNIQUESTUBINFO usi;
//      if (EnsureUniqueStub(pidl, STUBCLASS_PROPSHEET, NULL, &usi)) {
//          DoStuff(usi.hwndStub, pidl);
//          FreeUniqueStub(&usi);
//      }
//

STDAPI_(BOOL)
EnsureUniqueStub(LPITEMIDLIST pidl, int iClass, POINT *ppt, UNIQUESTUBINFO *pusi)
{
    HWND hwndOther;

    ZeroMemory(pusi, sizeof(UNIQUESTUBINFO));

    hwndOther = FindStubForPidlClass(pidl, iClass);
    if (hwndOther)
    {
        SwitchToThisWindow(GetLastActivePopup(hwndOther), TRUE);
        return FALSE;
    }
    else
    {   // Tag ourselves as the unique stub for this pidl/class
        pusi->hwndStub = _CreateStubWindow(ppt, NULL);

        // If no pidl, then nothing to tag *with*
        // If no stub window, then nothing to attach the tag *to*
        // But they are both still considered success.

        if (pusi->hwndStub && pidl)
        {
            SHFILEINFO sfi;

            pusi->hClassPidl = _StuffStubWindow(pusi->hwndStub, pidl, iClass);

            if (SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_PIDL)) {
                pusi->hicoStub = sfi.hIcon;

                // Cannot stuff the title because the window might belong to another process
                SendMessage(pusi->hwndStub, STUBM_SETICONTITLE, (WPARAM)pusi->hicoStub, 0);

            }
        }
        return TRUE;
    }
}

STDAPI_(void) FreeUniqueStub(UNIQUESTUBINFO *pusi)
{
    if (pusi->hwndStub)
        DestroyWindow(pusi->hwndStub);
    if (pusi->hClassPidl)
        SHFreeShared(pusi->hClassPidl, GetCurrentProcessId());
    if (pusi->hicoStub)
        DestroyIcon(pusi->hicoStub);
}

BOOL _IsAnyDuplicatedKey(HKEY ahkeys[], UINT ckeys, HKEY hkey)
{
    UINT ikey;
    for (ikey=0; ikey<ckeys; ikey++)
    {
        if (ahkeys[ikey]==hkey) {
            return TRUE;
        }
    }
    return FALSE;
}

STDAPI_(BOOL) SHOpenPropSheet(
    LPCTSTR pszCaption,
    HKEY ahkeys[],
    UINT ckeys,
    const CLSID * pclsidDef,    OPTIONAL
    IDataObject *pdtobj,
    IShellBrowser * psb,
    LPCTSTR pStartPage)         OPTIONAL
{
    BOOL fSuccess = FALSE;
    BOOL fUnique;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE ahpage[MAX_FILE_PROP_PAGES];
    HWND hwndStub = NULL;
    STGMEDIUM medium;
    HDCA hdca = NULL;
    HICON hicoStuff = NULL;
    UNIQUESTUBINFO usi;

    ASSERT(IS_VALID_STRING_PTR(pszCaption, -1));
    ASSERT(NULL == pclsidDef || IS_VALID_READ_PTR(pclsidDef, CLSID));
    ASSERT(IS_VALID_CODE_PTR(pdtobj, DATAOBJECT));
    ASSERT(NULL == psb || IS_VALID_CODE_PTR(psb, IShellBrowser));
    ASSERT(NULL == pStartPage || IS_VALID_STRING_PTR(pStartPage, -1));

    // Create the stub window
    {
        POINT pt;
        POINT * ppt = NULL;
        LPITEMIDLIST pidl = NULL;

        if (SUCCEEDED(DataObj_GetOFFSETs(pdtobj, &pt)))
            ppt = &pt;

        if (DataObj_GetHIDA(pdtobj, &medium))
        {
            HIDA hida = medium.hGlobal;
            if (hida && (HIDA_GetCount(hida) == 1))
            {
                pidl = HIDA_ILClone(hida, 0);
            }
            HIDA_ReleaseStgMedium(NULL, &medium);
        }


        fUnique = EnsureUniqueStub(pidl, STUBCLASS_PROPSHEET, ppt, &usi);
        ILFree(pidl);
    }

    // If there's already a property sheet up for this guy, then our job is done
    if (!fUnique) {
        return TRUE;
    }

    psh.hwndParent = usi.hwndStub;
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE;
    psh.hInstance = HINST_THISDLL;
    psh.pszCaption = pszCaption;
    psh.nPages = 0;     // incremented in callback
    psh.nStartPage = 0;   // set below if specified
    psh.phpage = ahpage;
    if (pStartPage)
    {
        psh.dwFlags |= PSH_USEPSTARTPAGE;
        psh.pStartPage = pStartPage;
    }

    hdca = DCA_Create();
    if (hdca)
    {
        UINT ikey;
        int nStartPage;
        //
        // Always add this default extention at the top, if any.
        //
        if (pclsidDef)
        {
            DCA_AddItem(hdca, pclsidDef);
        }

        for (ikey = 0; ikey < ckeys; ikey++)
        {
            if (ahkeys[ikey] && !_IsAnyDuplicatedKey(ahkeys, ikey, ahkeys[ikey]))
            {
                DCA_AddItemsFromKey(hdca, ahkeys[ikey], STRREG_SHEX_PROPSHEET);
            }
        }

        // Notes: ahkeys[ckeys-1] as hkeyProgID
        ASSERT(ckeys);
        nStartPage = DCA_AppendClassSheetInfo(hdca, ahkeys[ckeys-1], &psh, pdtobj);

        // If a shell extension requested to be the default and the caller didn't
        // specify a preferred initial page, then let the shell extension win.
        if (!pStartPage && nStartPage >= 0)
            psh.nStartPage = nStartPage;
        DCA_Destroy(hdca);
    }

    // Open the property sheet, only if we have some pages.
    if (psh.nPages > 0)
    {
        _try
        {
            if (PropertySheet(&psh) >= 0)   // IDOK or IDCANCEL (< 0 is error)
                fSuccess = TRUE;
        }
        _except(UnhandledExceptionFilter(GetExceptionInformation()))
        {
            DebugMsg(DM_ERROR, TEXT("PRSHT: Fault in property sheet"));
        }
    }
    else
    {
        ShellMessageBox(HINST_THISDLL, NULL,
                        MAKEINTRESOURCE(IDS_NOPAGE),
                        MAKEINTRESOURCE(IDS_DESKTOP),
                        MB_OK|MB_ICONHAND);
    }

    // clean up the stub window and data
    FreeUniqueStub(&usi);

    return fSuccess;
}


#ifdef UNICODE

STDAPI_(BOOL) SHOpenPropSheetA(
    LPCSTR pszCaption,
    HKEY ahkeys[],
    UINT ckeys,
    const CLSID * pclsidDef,
    IDataObject *pdtobj,
    IShellBrowser * psb,
    LPCSTR pszStartPage)       OPTIONAL
{
    BOOL bRet = FALSE;

    if (IS_VALID_STRING_PTRA(pszCaption, MAX_PATH))
    {
        WCHAR wszCaption[MAX_PATH];
        WCHAR wszStartPage[MAX_PATH];

        SHAnsiToUnicode(pszCaption, wszCaption, SIZECHARS(wszCaption));

        if (pszStartPage)
        {
            ASSERT(IS_VALID_STRING_PTRA(pszStartPage, MAX_PATH));

            SHAnsiToUnicode(pszStartPage, wszStartPage, SIZECHARS(wszStartPage));
            pszStartPage = (LPCSTR)wszStartPage;
        }

        bRet = SHOpenPropSheet(wszCaption, ahkeys, ckeys, pclsidDef, pdtobj, psb, (LPCWSTR)pszStartPage);
    }

    return bRet;
}

#else

STDAPI_(BOOL) SHOpenPropSheetW(
    LPCWSTR pszCaption,
    HKEY ahkeys[],
    UINT ckeys,
    const CLSID * pclsidDef,
    IDataObject *pdtobj,
    IShellBrowser * psb,
    LPCWSTR pszStartPage)       OPTIONAL
{
    BOOL bRet = FALSE;

    if (IS_VALID_STRING_PTRW(pszCaption, MAX_PATH))
    {
        char szCaption[MAX_PATH];
        char szStartPage[MAX_PATH];

        SHUnicodeToAnsi(pszCaption, szCaption, SIZECHARS(szCaption));

        if (pszStartPage)
        {
            ASSERT(IS_VALID_STRING_PTRW(pszStartPage, MAX_PATH));

            SHUnicodeToAnsi(pszStartPage, szStartPage, SIZECHARS(szStartPage));
            pszStartPage = (LPCWSTR)szStartPage;
        }

        bRet = SHOpenPropSheet(szCaption, ahkeys, ckeys, pclsidDef, pdtobj, psb, (LPCSTR)pszStartPage);
    }

    return bRet;
}

#endif // UNICODE

//
//  Async version of SHFormatDrive - creates a separate thread to do the
//  format and returns immediately.
//

typedef struct {
    HWND hwnd;
    UINT drive;
    UINT fmtID;
    UINT options;
} FORMATTHREADINFO;

STDAPI_(DWORD) _FormatThreadProc(LPVOID lpParam)
{
    FORMATTHREADINFO* pfi = (FORMATTHREADINFO*)lpParam;
    LPITEMIDLIST pidl;
    TCHAR szDrive[4];

    lstrcpy(szDrive, TEXT("A:\\"));
    ASSERT(pfi->drive < 26);
    szDrive[0] += (TCHAR)pfi->drive;

    pidl = ILCreateFromPath(szDrive);
    if (pidl)
    {
        UNIQUESTUBINFO usi;
        LPPOINT ppt = NULL;
        RECT rcWindow;
        if (pfi->hwnd)
        {
            GetWindowRect(pfi->hwnd, &rcWindow);
            ppt = (LPPOINT)&rcWindow;
        }

        if (EnsureUniqueStub(pidl, STUBCLASS_FORMAT, ppt, &usi))
        {
            SHFormatDrive(usi.hwndStub, pfi->drive, pfi->fmtID, pfi->options);
            FreeUniqueStub(&usi);
        }
        ILFree(pidl);
    }
    LocalFree(pfi);
    return 0;
}

STDAPI_(void) SHFormatDriveAsync(
    HWND hwnd,
    UINT drive,
    UINT fmtID,
    UINT options
)
{
    FORMATTHREADINFO* pfi = (FORMATTHREADINFO*)LocalAlloc(LPTR, sizeof(FORMATTHREADINFO));
    if (pfi)
    {
        pfi->hwnd = hwnd;
        pfi->drive = drive;
        pfi->fmtID = fmtID;
        pfi->options = options;
        SHCreateThread(_FormatThreadProc, pfi, CTF_INSIST | CTF_PROCESS_REF, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\srccpp.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

!include $(CCSHELL_DIR)\shell32\shell32.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\shell32\shell32.inc
INCLUDES        = $(INCLUDES); $(COM_INC_PATH);

NO_BROWSER_FILE = 1

PRECOMPILED_CXX = 1

TARGETNAME      = srccpp
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = \
                  ..\apdlg.cpp     \
                  ..\apdlglog.cpp  \
                  ..\apprmdlg.cpp  \
                  ..\assocarray.cpp \
                  ..\autocm.cpp    \
                  ..\balmsg.cpp    \
                  ..\basedlg.cpp   \
                  ..\bbckfldr.cpp  \
                  ..\brffldr.cpp   \
                  ..\browse.cpp    \
                  ..\category.cpp  \
                  ..\cdburn.cpp    \
                  ..\cdburnfldr.cpp \
                  ..\clientxi.cpp  \
                  ..\colhndlr.cpp  \
                  ..\combview.cpp  \
                  ..\confirmationui.cpp \
                  ..\contextmenu.cpp \
                  ..\copyfgd.cpp   \
                  ..\cpaction.cpp \
                  ..\cpduihlp.cpp \
                  ..\cpguids.cpp \
                  ..\cplnkele.cpp \
                  ..\cpnamespc.cpp \
                  ..\cpuiele.cpp \
                  ..\cputil.cpp \
                  ..\cpview.cpp \
                  ..\ctrlfldr.cpp  \
                  ..\ctrlxicon.cpp \
                  ..\dataprv.cpp   \
                  ..\datautil.cpp  \
                  ..\defcm.cpp     \
                  ..\defview.cpp   \
				  ..\defviewcoldlg.cpp \
                  ..\defviewlegacy.cpp \
                  ..\defvphst.cpp  \
                  ..\defxicon.cpp  \
                  ..\deskfldr.cpp  \
                  ..\dlglogic.cpp  \
                  ..\dll.cpp       \
                  ..\dragdrop.cpp  \
                  ..\drivfldr.cpp  \
                  ..\drivxicon.cpp \
                  ..\drvx.cpp      \
                  ..\duidrag.cpp   \
                  ..\duihost.cpp   \
                  ..\duiinfo.cpp   \
                  ..\duilist.cpp   \
                  ..\duisec.cpp    \
                  ..\duitask.cpp   \
                  ..\duiview.cpp   \
                  ..\dvmenu.cpp    \
                  ..\dvtasks.cpp   \
                  ..\dvthumbnail.cpp \
                  ..\dynastg.cpp   \
                  ..\eballoon.cpp  \
                  ..\enumidlist.cpp \
                  ..\enumuicommand.cpp \
                  ..\execute.cpp   \
                  ..\executil.cpp  \
                  ..\exedrop.cpp   \
                  ..\fassoc.cpp    \
                  ..\findband.cpp  \
                  ..\finddlg.cpp   \
                  ..\findfilter.cpp \
                  ..\findfldr.cpp  \
                  ..\filefldr.cpp  \
                  ..\fileenum.cpp  \
                  ..\fileicon.cpp  \
                  ..\filetbl.cpp   \
                  ..\filetype.cpp  \
                  ..\filtgrep.cpp  \
                  ..\findcmd.cpp   \
                  ..\findfldr.cpp  \
                  ..\fldrcust.cpp  \
                  ..\fldrscut.cpp  \
                  ..\folder.cpp    \
                  ..\foldertip.cpp \
                  ..\folderviewhost.cpp \
                  ..\format.cpp    \
                  ..\fsassoc.cpp   \
                  ..\fsdata.cpp    \
                  ..\fsdrptgt.cpp  \
                  ..\fsmenu.cpp    \
                  ..\fstree.cpp    \
                  ..\folderthumb.cpp \
                  ..\ftaction.cpp  \
                  ..\ftadv.cpp     \
                  ..\ftascstr.cpp  \
                  ..\ftassoc.cpp   \
                  ..\ftdlg.cpp     \
                  ..\ftedit.cpp    \
                  ..\ftenum.cpp    \
                  ..\ftprop.cpp    \
                  ..\hwcmmn.cpp    \
                  ..\hwshlexc.cpp  \
                  ..\idldata.cpp   \
                  ..\idldrop.cpp   \
                  ..\idltree.cpp   \
                  ..\idlist.cpp    \
                  ..\infotip.cpp   \
                  ..\inistg.cpp    \
                  ..\isproc.cpp    \
                  ..\item.cpp      \
                  ..\itemhelp.cpp  \
                  ..\limitinput.cpp   \
                  ..\linkwnd.cpp   \
                  ..\linkprop.cpp  \
                  ..\lowdisk.cpp   \
                  ..\mergfldr.cpp  \
                  ..\mixctnt.cpp   \
                  ..\mkhelp.cpp    \
                  ..\mountvol.cpp  \
                  ..\mtpt2.cpp     \
                  ..\mtptarun2.cpp \
                  ..\mtptevnt.cpp  \
                  ..\mtptis2.cpp   \
                  ..\mtptl2.cpp    \
                  ..\mtptlis.cpp   \
                  ..\mtptr2.cpp    \
                  ..\mtptris.cpp   \
                  ..\mtptmgmt2.cpp \
                  ..\mulprsht.cpp  \
                  ..\mydocsfldr.cpp \
                  ..\nametrans.cpp \
                  ..\netapi.cpp    \
                  ..\netcrawl.cpp  \
                  ..\netfind.cpp   \
                  ..\netfldr.cpp   \
                  ..\nswalk.cpp    \
                  ..\openwith.cpp  \
                  ..\ovrlaymn.cpp  \
                  ..\prndrop.cpp   \
                  ..\prnfldr.cpp   \
                  ..\prop.cpp	   \
                  ..\prshtcpp.cpp  \
                  ..\recclean.cpp  \
                  ..\recdocs.cpp   \
                  ..\regfldr.cpp   \
                  ..\regsprtb.cpp  \
                  ..\regsuprt.cpp  \
                  ..\regtreeitems.cpp \
                  ..\reminder.cpp  \
                  ..\rgsprtc.cpp   \
                  ..\rscchvr.cpp   \
                  ..\rssubdat.cpp  \
                  ..\rundlg.cpp    \
                  ..\scffile.cpp   \
                  ..\scnotify.cpp  \
                  ..\securent.cpp  \
                  ..\security.cpp  \
                  ..\sencrypt.cpp  \
                  ..\sfstorage.cpp \
                  ..\sfvcmpt.cpp   \
                  ..\sfvext.cpp    \
                  ..\shapi.cpp     \
                  ..\sharedfldr.cpp \
                  ..\shcombox.cpp  \
                  ..\shelllnk.cpp  \
                  ..\shlnot.cpp    \
                  ..\shlobjs.cpp   \
                  ..\startpin.cpp  \
                  ..\stgenum.cpp   \
                  ..\stgfldr.cpp   \
                  ..\stgutil.cpp   \
                  ..\stg2stgx.cpp  \
                  ..\storage.cpp   \
                  ..\subdata.cpp   \
                  ..\SwitchUserDialog.cpp \
                  ..\thumbnailgen.cpp \
                  ..\thumbutil.cpp \
                  ..\Tooltip.cpp \
                  ..\tracker.cpp   \
                  ..\treewalk.cpp  \
                  ..\treewkcb.cpp  \
                  ..\uevttmr.cpp   \
                  ..\userpict.cpp  \
                  ..\util.cpp      \
                  ..\viewstate.cpp \
                  ..\websvc.cpp    \
                  ..\xiconwrap.cpp \


PRECOMPILED_INCLUDE = ..\shellprv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\srcc.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

BUILD_PRIVLIB   = 1
SELFREGNAME     = $(O)\selfreg_shell32.inf
MISCFILES       = $(MISCFILES) $(SELFREGNAME)

MSC_WARNING_LEVEL=/W4

!include $(CCSHELL_DIR)\shell32\shell32.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\shell32\shell32.inc

SYNCHRONIZE_DRAIN=1

TARGETNAME      = shell32
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

PASS1_PUBLISH= \
    {$(O)\shell32.lib=$(SDK_LIB_PATH)\shell32.lib}  \
    {$(O)\shell32p.lib=$(SHELL_LIB_PATH)\shell32p.lib}

TARGETLIBS      = $(LIBRARY_PLATFORM_PATH)\*\gdi32.lib          \
                  $(LIBRARY_PLATFORM_PATH)\*\user32.lib         \
                  $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib       \
                  ..\sdspatch\$(O)\sdspatch.lib                 \
                  ..\tngen\$(O)\tngen.lib                       \
                  ..\menuband\$(O)\menuband.lib                 \
                  $(SDK_LIB_PATH)\advapip.lib                  \
                  $(SDK_LIB_PATH)\adsiid.lib                    \
                  $(SHELL_LIB_PATH)\shlwapip.lib                \
                  $(SDK_LIB_PATH)\winmm.lib                     \
                  $(SDK_LIB_PATH)\msi.lib                       \
                  $(SDK_LIB_PATH)\devmgr.lib                    \
                  $(SDK_LIB_PATH)\urlmon.lib                    \
                  $(SDK_LIB_PATH)\wininet.lib                   \
                  $(SDK_LIB_PATH)\secur32.lib                   \
                  $(SDK_LIB_PATH)\winspool.lib                  \
                  $(SDK_LIB_PATH)\userenv.lib                   \
                  $(SDK_LIB_PATH)\ole32.lib                     \
                  $(SDK_LIB_PATH)\oleaut32.lib                  \
                  $(SDK_LIB_PATH)\oleacc.lib                    \
                  $(SDK_LIB_PATH)\version.lib                   \
                  $(NET_LIB_PATH)\mprp.lib                      \
                  $(SDK_LIB_PATH)\mprapi.lib                    \
                  $(SDK_LIB_PATH)\netapi32.lib                  \
                  $(SDK_LIB_PATH)\cscdll.lib                    \
                  $(SDK_LIB_PATH)\ntdsapi.lib                   \
                  $(SDK_LIB_PATH)\activeds.lib                  \
                  $(SDK_LIB_PATH)\msdasc.lib                    \
                  $(SHELL_LIB_PATH)\uxthemep.lib                \
                  $(DS_LIB_PATH)\creduip.lib                    \
                  $(SDK_LIB_PATH)\rasapi32.lib                  \
                  $(DS_LIB_PATH)\msgina.lib                     \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib            \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib           \
                  $(CCSHELL_DIR)\lib\$(O)\ieguidp.lib           \
                  $(SDK_LIB_PATH)\uuid.lib                      \
                  $(SDK_LIB_PATH)\wiaguid.lib                   \
                  $(SDK_LIB_PATH)\powrprof.lib                  \
                  $(PROJECT_ROOT)\lib\$(O)\shdocvwp.lib         \
                  $(PROJECT_ROOT)\lib\$(O)\browseui.lib         \
                  $(PROJECT_LIB_PATH)\shdocvw.lib               \
                  $(PROJECT_ROOT)\lib\$(O)\secutil.lib          \
                  $(SHELL_LIB_PATH)\efsadu.lib                  \
                  $(SHELL_LIB_PATH)\linkinfo.lib                \
                  $(CCSHELL_DIR)\lib\$(O)\xml.lib               \
                  $(CCSHELL_DIR)\lib\$(O)\inetutil.lib          \
                  $(CCSHELL_DIR)\lib\$(O)\shfusion.lib          \
                  $(SDK_LIB_PATH)\msimg32.lib                   \
                  $(WINDOWS_LIB_PATH)\obj\duser.lib             \
!if $(FREEBUILD)
                  $(WINDOWS_LIB_PATH)\directui.lib              \
!else
                  $(WINDOWS_LIB_PATH)\directuid.lib             \
!endif
                  $(PRINTSCAN_LIB_PATH)\printui.lib             \
                  $(SDK_LIB_PATH)\htmlhelp.lib                  \
                  $(CCSHELL_DIR)\ext\cdfview\dll\$(O)\cdfview.lib \
                  $(SDK_LIB_PATH)\setupapi.lib                  \
                  $(SDK_LIB_PATH)\d3dx.lib

# Remember - only things that are listed in the DEF file go into LINKLIBS
LINKLIBS        = ..\ntcpp\$(O)\srccpp.lib                      \
                  ..\unicpp\ntcpp\$(O)\unicpp.lib               \
                  $(PROJECT_ROOT)\lib\$(O)\stock.lib

TARGETLIBS      = $(TARGETLIBS)                                 \
                  $(SDK_LIB_PATH)\ntdll.lib                     \
                  $(SDK_LIB_PATH)\rpcrt4.lib                    \
                  $(SDK_LIB_PATH)\query.lib                     \
                  $(WINDOWS_LIB_PATH)\user32p.lib               \
                  $(CCSHELL_DIR)\lib\$(O)\badappsu.lib          \
                  $(SDK_LIB_PATH)\imm32.lib

# shlwapip.lib is weird.
#
# We want to put shlwapip.lib into the LINKLIBS because we have old
# exports from shell32.lib that have moved to shlwapi (which we forward to)
# and we can't remove them since people link to them by ordinal.
#
# However, LINKLIBS are linked before TARGETLIBS, which is a problem
# because shlwapip contains overrides for standard Win32 functions
# which we do not want to use.  (The overrides come from the Trident
# people, who apparently rely on them.)
#
# The secret is IMPLIB_OBJS.  We list shlwapip.lib there to indicate
# that we need it built in order to link, and also list it in TARGETLIBS
# to indicate the link order.

IMPLIB_OBJS     = $(IMPLIB_OBJS)                                \
                  $(SHELL_LIB_PATH)\shlwapip.lib


DELAYLOAD       = query.dll;winmm.dll;msi.dll;\
                  urlmon.dll;wininet.dll;devmgr.dll;winspool.drv;userenv.dll;\
                  ole32.dll;oleaut32.dll;secur32.dll;oleacc.dll;\
                  version.dll;mpr.dll;netapi32.dll;cscdll.dll;linkinfo.dll;\
                  shdocvw.dll;browseui.dll;uxtheme.dll;\
                  credui.dll;msgina.dll;efsadu.dll;powrprof.dll;rasapi32.dll;\
                  printui.dll;cdfview.dll;msimg32.dll;duser.dll;setupapi.dll;\
                  imm32.dll

DLOAD_ERROR_HANDLER = kernel32

DLLDEF          = $(O)\shell32.def

PRIVDEFSRC      = ..\shell32.src
PRIVDEF         = $(O)\shell32p.def
PRIVLIB         = shell32p.lib

INCLUDES        = $(INCLUDES);$(PROJECT_ROOT)\lib\$(O);$(O);$(TERMSRV_INC_PATH)

USE_MSVCRT      = 1

DLLENTRY        = _DllMainCRTStartup

NTTARGETFILES   =

# for historical reasons we include some GUIDs in the shell32 import library
DLLLIBOBJECTS   = $(CCSHELL_DIR)\lib\$(O)\shguid.lib

SOURCES         = \
                  ..\shell32.rc  \
                  ..\about.c     \
                  ..\bitbuck.c   \
                  ..\bookmk.c    \
                  ..\cabstate.c  \
                  ..\clsobj.c    \
                  ..\control1.c  \
                  ..\copy.c      \
                  ..\copyhook.c  \
                  ..\cplobj.c    \
                  ..\cstrings.c  \
                  ..\debug.c     \
                  ..\defclsf.c   \
                  ..\drawpie.c   \
                  ..\exec.c      \
                  ..\extract.c   \
                  ..\expenv.c    \
                  ..\futil.c     \
                  ..\hash.c      \
                  ..\help.c      \
                  ..\init.c      \
                  ..\lvutil.c    \
                  ..\malloc.c    \
                  ..\msgbox.c    \
                  ..\ole2def.c   \
                  ..\ole2dup.c   \
                  ..\ole2dup2.c  \
                  ..\os.c        \
                  ..\path.c      \
                  ..\fldsets.c   \
                  ..\pickicon.c  \
                  ..\printer1.c  \
                  ..\prtprop.c   \
                  ..\psxa.c      \
                  ..\rdrag.c     \
                  ..\reglist.c   \
                  ..\restart.c   \
                  ..\rundll32.c  \
                  ..\shared.c    \
                  ..\shlexec2.c  \
                  ..\shprsht.c   \
                  ..\shtdndlg.c  \
                  ..\stream.c    \
                  ..\undo.c      \
                  ..\version.c   \
                  ..\viewcomm.c  \
                  ..\ynlist.c    \
                  ..\exec2nt.c   \
                  ..\argvw.c     \
                  ..\lstrfns.c   \
                  ..\psdocurd.c  \
                  ..\regenv.c    \
                  ..\nothunk.c   \
                  ..\thunktxt.c  \
                  ..\pifdat.c    \
                  ..\piffnt.c    \
                  ..\pifhot.c    \
                  ..\pifinf.c    \
                  ..\piflib.c    \
                  ..\pifmem.c    \
                  ..\pifmgr.c    \
                  ..\pifmsc.c    \
                  ..\pifprg.c    \
                  ..\pifsub.c    \
                  ..\pifvid.c    \
                  ..\lnkcon.c    \
                  ..\lnkfnt.c    \
                  ..\lnkprev.c   \
                  ..\lnkmisc.c   \
                  ..\dbcs.c      \
                  ..\proxynt.c   \
                  ..\apithk.c    \
                  ..\utilnt.c

PRECOMPILED_INCLUDE = ..\shellprv.h

#
#
# Con-fusion
#
# we can't use 123 because rundll32 will activate it, rendering all CPLs manifested	
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\stgenum.h ===
#ifndef __STGENUM_H__
#define __STGENUM_H__


// IEnumSTATSTG for CFSFolder's IStorage implementation.

class CFSFolderEnumSTATSTG : public IEnumSTATSTG
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IEnumSTATSTG
    STDMETHOD(Skip)(ULONG celt)
        { return E_NOTIMPL; };
    STDMETHOD(Clone)(IEnumSTATSTG **ppenum)
        { return E_NOTIMPL; };
    STDMETHOD(Next)(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched);
    STDMETHOD(Reset)();

protected:
    CFSFolderEnumSTATSTG(CFSFolder* psf);
    ~CFSFolderEnumSTATSTG();

private:
    LONG         _cRef;
    CFSFolder*   _pfsf;          // fs folder

    int          _cIndex;
    TCHAR        _szSearch[MAX_PATH];
    HANDLE       _hFindFile;

    friend CFSFolder;
};


#endif // __STGENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\startpin.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "datautil.h"

#include "resource.h"       // main symbols
#include "cowsite.h"        // CObjectWithSite
#include "dpa.h"            // CDPA

class CStartMenuPin;

//
//  PINENTRY - A single entry in the pin list
//
//  The _liPos/_cbLink point back into the CPinList._pstmLink
//
class PINENTRY {
public:
    LPITEMIDLIST    _pidl;
    IShellLink *    _psl;           // a live IShellLink
    LARGE_INTEGER   _liPos;         // location of the shell link inside the stream
    DWORD           _cbSize;        // size of the buffer pointed to by _liPos

    HRESULT UpdateShellLink();

    void FreeShellLink()
    {
        _cbSize = 0;
        ATOMICRELEASE(_psl);
    }

    void Destruct()
    {
        ILFree(_pidl);
        FreeShellLink();
    }

    static BOOL DestroyCallback(PINENTRY *self, LPVOID)
    {
        self->Destruct();
        return TRUE;
    }
};

//
//  CPinList
//

class CPinList
{
public:
    CPinList() : _dsaEntries(NULL), _pstmLink(NULL) { }

    ~CPinList()
    {
        ATOMICRELEASE(_pstmLink);
        if (_dsaEntries)
        {
            _dsaEntries.DestroyCallbackEx(PINENTRY::DestroyCallback, (void *)NULL);
        }
    }

    BOOL    Initialize() { return _dsaEntries.Create(4); }
    HRESULT Load(CStartMenuPin *psmpin);
    HRESULT Save(CStartMenuPin *psmpin);

    int AppendPidl(LPITEMIDLIST pidl)
    {
        PINENTRY entry = { pidl };
        return _dsaEntries.AppendItem(&entry);
    }

    PINENTRY *GetItemPtr(int i) { return _dsaEntries.GetItemPtr(i); }


    HRESULT SaveShellLink(PINENTRY *pentry, IStream *pstm);
    HRESULT LoadShellLink(PINENTRY *pentry, IShellLink **ppsl);
    HRESULT UpdateShellLink(PINENTRY *pentry) { return pentry->UpdateShellLink(); }

    PINENTRY *FindPidl(LPCITEMIDLIST pidl, int *pi);
    HRESULT ReplacePidl(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew);

private:
    struct ILWRITEINFO {
        IStream *pstmPidlWrite;
        IStream *pstmLinkWrite;
        CPinList *ppl;
        HRESULT hr;
        LPITEMIDLIST rgpidl[20];    // Must match ARRAYSIZE(c_rgcsidlRelative)
    };
    static BOOL ILWriteCallback(PINENTRY *pentry, ILWRITEINFO *pwi);

    CDSA<PINENTRY>  _dsaEntries;    // The items themselves
    IStream *       _pstmLink;      // PINENTRY._liPos points into this stream

};

class ATL_NO_VTABLE CStartMenuPin
    : public IShellExtInit
    , public IContextMenu
    , public IStartMenuPin
    , public CObjectWithSite
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CStartMenuPin, &CLSID_StartMenuPin>
{
public:
    ~CStartMenuPin();

BEGIN_COM_MAP(CStartMenuPin)
    COM_INTERFACE_ENTRY(IShellExtInit)
    // Need to use COM_INTERFACE_ENTRY_IID for the interfaces
    // that don't have an idl
    COM_INTERFACE_ENTRY_IID(IID_IContextMenu, IContextMenu)
    COM_INTERFACE_ENTRY(IStartMenuPin)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

DECLARE_NO_REGISTRY()

    // *** IShellExtInit ***
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdto, HKEY hkProgID);

    // *** IContextMenu ***
    STDMETHODIMP  QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax);

    // *** IStartMenuPin ***
    STDMETHODIMP EnumObjects(IEnumIDList **ppenum);
    STDMETHODIMP Modify(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo);
    STDMETHODIMP GetChangeCount(ULONG *pulOut);
    STDMETHODIMP IsPinnable(IDataObject *pdtobj, DWORD dwFlags, OPTIONAL LPITEMIDLIST *ppidl);
    STDMETHODIMP Resolve(HWND hwnd, DWORD dwFlags, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlResolved);

    // *** IObjectWithSite ***
    // Inherited from CObjectWithSite

public:
    HRESULT SetChangeCount(ULONG ul);

protected:

    BOOL _IsAcceptableTarget(LPCTSTR pszPath, DWORD dwAttrib, DWORD dwFlags);

    enum {
        IDM_PIN =   0,
        IDM_UNPIN = 1,
        IDM_MAX,
    };

    // These "seem" backwards, but remember: If the item is pinned,
    // then the command is "unpin".  If the item is unpinned, then
    // the command is "pin".
    inline void _SetPinned() { _idmPinCmd = IDM_UNPIN; }
    inline void _SetUnpinned() { _idmPinCmd = IDM_PIN; }
    inline BOOL _IsPinned() const { return _idmPinCmd != IDM_PIN; }
    inline BOOL _DoPin() const { return _idmPinCmd == IDM_PIN; }
    inline BOOL _DoUnpin() const { return _idmPinCmd != IDM_PIN; }
    inline UINT _GetMenuStringID() const
    {
        COMPILETIME_ASSERT(IDS_STARTPIN_UNPINME == IDS_STARTPIN_PINME + IDM_UNPIN);
        return IDS_STARTPIN_PINME + _idmPinCmd;
    }

    static BOOL ILFreeCallback(LPITEMIDLIST pidl, void *)
        { ILFree(pidl); return TRUE; }

    HRESULT _ShouldAddMenu(UINT uFlags);
    HRESULT _InitPinRegStream();

protected:
    IDataObject *_pdtobj;
    UINT        _idmPinCmd;         // Which command did we add?

    LPITEMIDLIST _pidl;             // IContextMenu identity
};

#define REGSTR_PATH_STARTFAVS       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartPage")
#define REGSTR_VAL_STARTFAVS        TEXT("Favorites")
#define REGSTR_VAL_STARTFAVCHANGES  TEXT("FavoritesChanges")
#define REGSTR_VAL_STARTFAVLINKS    TEXT("FavoritesResolve")

IStream *_OpenPinRegStream(DWORD grfMode)
{
    return SHOpenRegStream2(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS, REGSTR_VAL_STARTFAVS, grfMode);
}

IStream *_OpenLinksRegStream(DWORD grfMode)
{
    return SHOpenRegStream2(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS, REGSTR_VAL_STARTFAVLINKS, grfMode);
}

const LARGE_INTEGER c_li0 = { 0, 0 };
const ULARGE_INTEGER& c_uli0 = (ULARGE_INTEGER&)c_li0;

HRESULT IStream_GetPos(IStream *pstm, LARGE_INTEGER *pliPos)
{
    return pstm->Seek(c_li0, STREAM_SEEK_CUR, (ULARGE_INTEGER*)pliPos);
}

HRESULT IStream_Copy(IStream *pstmFrom, IStream *pstmTo, DWORD cb)
{
    ULARGE_INTEGER uliToCopy, uliCopied;
    uliToCopy.QuadPart = cb;
    HRESULT hr = pstmFrom->CopyTo(pstmTo, uliToCopy, NULL, &uliCopied);
    if (SUCCEEDED(hr) && uliToCopy.QuadPart != uliCopied.QuadPart)
    {
        hr = E_FAIL;
    }
    return hr;
}

class ATL_NO_VTABLE CStartMenuPinEnum
    : public IEnumIDList
    , public CComObjectRootEx<CComSingleThreadModel>
    , public CComCoClass<CStartMenuPinEnum>
{
public:
    ~CStartMenuPinEnum()
    {
        ATOMICRELEASE(_pstm);
    }

BEGIN_COM_MAP(CStartMenuPinEnum)
    COM_INTERFACE_ENTRY(IEnumIDList)
END_COM_MAP()

    /// *** IEnumIDList ***
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

private:
    HRESULT _NextPidlFromStream(LPITEMIDLIST *ppidl);
    HRESULT _InitPinRegStream();

private:
    HRESULT     _hrLastEnum;        // Result of last IEnumIDList::Next
    IStream *   _pstm;
};

CStartMenuPin::~CStartMenuPin()
{
    ILFree(_pidl);
    if (_pdtobj)
        _pdtobj->Release();
}

BOOL _IsLocalHardDisk(LPCTSTR pszPath)
{
    //  Reject CDs, floppies, network drives, etc.
    //
    int iDrive = PathGetDriveNumber(pszPath);
    if (iDrive < 0 ||                   // reject UNCs
        RealDriveType(iDrive, /* fOkToHitNet = */ FALSE) != DRIVE_FIXED) // reject slow media
    {
        return FALSE;
    }
    return TRUE;
}

BOOL CStartMenuPin::_IsAcceptableTarget(LPCTSTR pszPath, DWORD dwAttrib, DWORD dwFlags)
{
    //  Regitems ("Internet" or "Email" for example) are acceptable
    //  provided we aren't restricted to EXEs only.
    if (!(dwAttrib & SFGAO_FILESYSTEM))
    {
        return !(dwFlags & SMPINNABLE_EXEONLY);
    }

    //  Otherwise, it's a file.

    //  If requested, reject non-EXEs.
    //  (Like the Start Menu, we treat MSC files as if they were EXEs)
    if (dwFlags & SMPINNABLE_EXEONLY)
    {
        LPCTSTR pszExt = PathFindExtension(pszPath);
        if (StrCmpIC(pszExt, TEXT(".EXE")) != 0 &&
            StrCmpIC(pszExt, TEXT(".MSC")) != 0)
        {
            return FALSE;
        }
    }

    //  If requested, reject slow media
    if (dwFlags & SMPINNABLE_REJECTSLOWMEDIA)
    {
        if (!_IsLocalHardDisk(pszPath))
        {
            return FALSE;
        }

        // If it's a shortcut, then apply the same rule to the shortcut.
        if (PathIsLnk(pszPath))
        {
            BOOL fLocal = TRUE;
            IShellLink *psl;
            if (SUCCEEDED(LoadFromFile(CLSID_ShellLink, pszPath, IID_PPV_ARG(IShellLink, &psl))))
            {
                // IShellLink::GetPath returns S_FALSE if target is not a path
                TCHAR szPath[MAX_PATH];
                if (S_OK == psl->GetPath(szPath, ARRAYSIZE(szPath), NULL, 0))
                {
                    fLocal = _IsLocalHardDisk(szPath);
                }
                psl->Release();
            }
            if (!fLocal)
            {
                return FALSE;
            }
        }
    }

    //  All tests pass!

    return TRUE;

}

BOOL IsStartPanelOn()
{
    SHELLSTATE ss = { 0 };
    SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);

    return ss.fStartPanelOn;
}

HRESULT CStartMenuPin::IsPinnable(IDataObject *pdtobj, DWORD dwFlags, OPTIONAL LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_FALSE;

    LPITEMIDLIST pidlRet = NULL;

    if (pdtobj &&                                   // must have a data object
        !SHRestricted(REST_NOSMPINNEDLIST) &&       // cannot be restricted
        IsStartPanelOn())                           // start panel must be on
    {
        STGMEDIUM medium = {0};
        LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
        if (pida)
        {
            if (pida->cidl == 1)
            {
                pidlRet = IDA_FullIDList(pida, 0);
                if (pidlRet)
                {
                    DWORD dwAttr = SFGAO_FILESYSTEM;            // only SFGAO_FILESYSTEM is valid
                    TCHAR szPath[MAX_PATH];

                    if (SUCCEEDED(SHGetNameAndFlags(pidlRet, SHGDN_FORPARSING,
                                        szPath, ARRAYSIZE(szPath), &dwAttr)) &&
                        _IsAcceptableTarget(szPath, dwAttr, dwFlags))
                    {
                        hr = S_OK;
                    }
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }

    // Return pidlRet only if the call succeeded and the caller requested it
    if (hr != S_OK || !ppidl)
    {
        ILFree(pidlRet);
        pidlRet = NULL;
    }

    if (ppidl)
    {
        *ppidl = pidlRet;
    }

    return hr;

}

// Returns S_OK if should add, S_FALSE if not

HRESULT CStartMenuPin::_ShouldAddMenu(UINT uFlags)
{
    // "Pin" is never a default verb
    if (uFlags & CMF_DEFAULTONLY)
        return S_FALSE;

    HRESULT hr;

    // The context menu appears only for fast media
    //
    // If extended verbs are disabled, then show the menu only for EXEs

    DWORD dwFlags = SMPINNABLE_REJECTSLOWMEDIA;
    if (!(uFlags & CMF_EXTENDEDVERBS))
    {
        dwFlags |= SMPINNABLE_EXEONLY;
    }

    hr = IsPinnable(_pdtobj, dwFlags, &_pidl);

    if (S_OK == hr)
    {
        //  If we are enclosed inside a shortcut, change our identity to the
        //  enclosing shortcut.

        IPersistFile *ppf;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_LinkSite, IID_PPV_ARG(IPersistFile, &ppf))))
        {
            LPOLESTR pszFile = NULL;
            if (ppf->GetCurFile(&pszFile) == S_OK && pszFile)
            {
                // ILCreateFromPathEx turns %USERPROFILE%\Desktop\foo.lnk
                // into CSIDL_DESKTOP\foo.lnk for us.
                LPITEMIDLIST pidl;
                if (SUCCEEDED(ILCreateFromPathEx(pszFile, NULL, ILCFP_FLAG_NORMAL, &pidl, NULL)))
                if (pidl)
                {
                    ILFree(_pidl);
                    _pidl = pidl;
                    hr = S_OK;
                }
                CoTaskMemFree(pszFile);
            }
            ppf->Release();
        }
    }

    return hr;
}

// IShellExtInit::Initialize
HRESULT CStartMenuPin::Initialize(LPCITEMIDLIST, IDataObject *pdtobj, HKEY)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);    // just grab this guy
    return S_OK;
}

// IContextMenu::QueryContextMenu

HRESULT CStartMenuPin::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = _ShouldAddMenu(uFlags);
    if (S_OK == hr)
    {
        _SetUnpinned();

        //  Determine whether this item is already on the Start Page or not.
        IEnumIDList *penum;
        hr = EnumObjects(&penum);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            while (penum->Next(1, &pidl, NULL) == S_OK)
            {
                BOOL bSame = ILIsEqual(pidl, _pidl);
                ILFree(pidl);
                if (bSame)
                {
                    _SetPinned();
                    break;
                }
            }
            penum->Release();

            TCHAR szCommand[MAX_PATH];
            if (LoadString(g_hinst, _GetMenuStringID(), szCommand, ARRAYSIZE(szCommand)))
            {
                InsertMenu(hmenu, indexMenu, MF_STRING | MF_BYPOSITION,
                           idCmdFirst + _idmPinCmd, szCommand);
            }

            hr = ResultFromShort(IDM_MAX);
        }
    }
    return hr;
}

const LPCTSTR c_rgpszVerb[] =
{
    TEXT("pin"),                    // IDM_PIN
    TEXT("unpin"),                  // IDM_UNPIN
};

// *** IContextMenu::InvokeCommand

HRESULT CStartMenuPin::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    LPCMINVOKECOMMANDINFOEX picix = reinterpret_cast<LPCMINVOKECOMMANDINFOEX>(pici);
    HRESULT hr = E_INVALIDARG;
    UINT idmCmd;

    if (IS_INTRESOURCE(pici->lpVerb))
    {
        idmCmd = PtrToInt(pici->lpVerb);
    }
    else
    {
        // Convert the string to an ID (or out of range if invalid)
        LPCTSTR pszVerb;
#ifdef UNICODE
        WCHAR szVerb[MAX_PATH];
        if (pici->cbSize >= CMICEXSIZE_NT4 &&
            (pici->fMask & CMIC_MASK_UNICODE) &&
            picix->lpVerbW)
        {
            pszVerb = picix->lpVerbW;
        }
        else
        {
            SHAnsiToTChar(pici->lpVerb, szVerb, ARRAYSIZE(szVerb));
            pszVerb = szVerb;
        }
#else
        pszVerb = pici->lpVerb;
#endif
        for (idmCmd = 0; idmCmd < ARRAYSIZE(c_rgpszVerb); idmCmd++)
        {
            if (lstrcmpi(pszVerb, c_rgpszVerb[idmCmd]) == 0)
            {
                break;
            }
        }
    }

    if (idmCmd == _idmPinCmd)
    {
        if (_idmPinCmd == IDM_PIN)
        {
            hr = Modify(NULL, _pidl);
        }
        else
        {
            hr = Modify(_pidl, NULL);
        }
    }

    return hr;
}

// *** IContextMenu::GetCommandString

HRESULT CStartMenuPin::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax)
{
    TCHAR szBuf[MAX_PATH];
    LPCTSTR pszResult = NULL;

    switch (uType & ~GCS_UNICODE)
    {
    case GCS_VERBA:
        if (idCmd < ARRAYSIZE(c_rgpszVerb))
        {
            pszResult = c_rgpszVerb[idCmd];
        }
        break;

    case GCS_HELPTEXTA:
        if (idCmd < ARRAYSIZE(c_rgpszVerb))
        {
            COMPILETIME_ASSERT(IDS_STARTPIN_PINME_HELP + IDM_UNPIN == IDS_STARTPIN_UNPINME_HELP);
            if (LoadString(g_hinst, IDS_STARTPIN_PINME_HELP + (UINT)idCmd, szBuf, ARRAYSIZE(szBuf)))
            {
                pszResult = szBuf;
            }
        }
        break;
    }

    if (pszResult)
    {
        if (uType & GCS_UNICODE)
        {
            SHTCharToUnicode(pszResult, (LPWSTR)pszName, cchMax);
        }
        else
        {
            SHTCharToAnsi(pszResult, pszName, cchMax);
        }
        return S_OK;
    }

    return E_NOTIMPL;
}

PINENTRY *CPinList::FindPidl(LPCITEMIDLIST pidl, int *pi)
{
    for (int i = _dsaEntries.GetItemCount() - 1; i >= 0; i--)
    {
        PINENTRY *pentry = _dsaEntries.GetItemPtr(i);
        if (ILIsEqual(pentry->_pidl, pidl))
        {
            if (pi)
            {
                *pi = i;
            }
            return pentry;
        }
    }
    return NULL;
}

HRESULT CPinList::ReplacePidl(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew)
{
    int i;
    PINENTRY *pentry = FindPidl(pidlOld, &i);
    if (pentry)
    {
        if (pidlNew == NULL)            // Delete
        {
            pentry->Destruct();
            _dsaEntries.DeleteItem(i);
            return S_OK;
        }
        else
        if (IS_INTRESOURCE(pidlNew))    // Move
        {
            // Move the pidl from i to iPos
            PINENTRY entry = *pentry;
            int iPos = ((int)(INT_PTR)pidlNew) - 1;
            if (i < iPos)
            {
                // Moving down; others move up
                iPos--;
                // Must use MoveMemory because the memory blocks overlap
                MoveMemory(_dsaEntries.GetItemPtr(i),
                           _dsaEntries.GetItemPtr(i+1),
                           sizeof(PINENTRY) * (iPos-i));
            }
            else if (i > iPos)
            {
                // Moving up; others move down
                // Must use MoveMemory because the memory blocks overlap
                MoveMemory(_dsaEntries.GetItemPtr(iPos+1),
                           _dsaEntries.GetItemPtr(iPos),
                           sizeof(PINENTRY) * (i-iPos));
            }
            _dsaEntries.SetItem(iPos, &entry);
            return S_OK;
        }
        else                            // Replace
        {
            if (Pidl_Set(&pentry->_pidl, pidlNew))
            {
                // Failure to update the shell link is not fatal;
                // it just means we won't be able to repair the
                // shortcut if it breaks.
                pentry->UpdateShellLink();
                return S_OK;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
    }
    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

HRESULT CStartMenuPin::Modify(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo)
{
    HRESULT hr;

    if(SHRestricted(REST_NOSMPINNEDLIST))
        return E_ACCESSDENIED;

    // Remap pidls to logical pidls (change CSIDL_DESKTOPDIRECTORY
    // to CSIDL_DESKTOP, etc.) so we don't get faked out when people
    // access objects sometimes directly on the desktop and sometimes
    // via their full filesystem name.

    LPITEMIDLIST pidlFromFree = NULL;
    LPITEMIDLIST pidlToFree = NULL;

    if (!IS_INTRESOURCE(pidlFrom))
    {
        pidlFromFree = SHLogILFromFSIL(pidlFrom);
        if (pidlFromFree) {
            pidlFrom = pidlFromFree;
        }
    }

    if (!IS_INTRESOURCE(pidlTo))
    {
        pidlToFree = SHLogILFromFSIL(pidlTo);
        if (pidlToFree) {
            pidlTo = pidlToFree;
        }
    }

    CPinList pl;
    hr = pl.Load(this);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            if (pidlFrom)
            {
                hr = pl.ReplacePidl(pidlFrom, pidlTo);
            }
            else if (pidlTo)
            {
                LPITEMIDLIST pidl = ILClone(pidlTo);
                if (pidl)
                {
                    int iPos = pl.AppendPidl(pidl);
                    if (iPos >= 0)
                    {
                        // Failure to update the shell link is not fatal;
                        // it just means we won't be able to repair the
                        // shortcut if it breaks.
                        pl.GetItemPtr(iPos)->UpdateShellLink();
                    }
                    else
                    {
                        ILFree(pidl);
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // pidlFrom == pidlTo == NULL?  What does that mean?
                hr = E_INVALIDARG;
            }

            if (SUCCEEDED(hr))
            {
                hr = pl.Save(this);
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;             // could not create dpa
    }

    ILFree(pidlFromFree);
    ILFree(pidlToFree);

    return hr;
}

//
//  Find the pidl on the pin list and resolve the shortcut that
//  tracks it.
//
//  Returns S_OK if the pidl changed and was resolved.
//  Returns S_FALSE if the pidl did not change.
//  Returns an error if the Resolve failed.
//

HRESULT CStartMenuPin::Resolve(HWND hwnd, DWORD dwFlags, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlResolved)
{
    *ppidlResolved = NULL;

    if(SHRestricted(REST_NOSMPINNEDLIST))
        return E_ACCESSDENIED;

    // Remap pidls to logical pidls (change CSIDL_DESKTOPDIRECTORY
    // to CSIDL_DESKTOP, etc.) so we don't get faked out when people
    // access objects sometimes directly on the desktop and sometimes
    // via their full filesystem name.

    LPITEMIDLIST pidlFree = SHLogILFromFSIL(pidl);
    if (pidlFree) {
        pidl = pidlFree;
    }

    CPinList pl;
    HRESULT hr = pl.Load(this);
    if (SUCCEEDED(hr))
    {
        PINENTRY *pentry = pl.FindPidl(pidl, NULL);
        if (pentry)
        {
            IShellLink *psl;
            hr =  pl.LoadShellLink(pentry, &psl);
            if (SUCCEEDED(hr))
            {
                hr = psl->Resolve(hwnd, dwFlags);
                if (hr == S_OK)
                {
                    IPersistStream *pps;
                    hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
                    if (SUCCEEDED(hr))
                    {
                        if (pps->IsDirty() == S_OK)
                        {
                            LPITEMIDLIST pidlNew;
                            hr = psl->GetIDList(&pidlNew);
                            if (SUCCEEDED(hr) && hr != S_OK)
                            {
                                // GetIDList returns S_FALSE on failure...
                                hr = E_FAIL;
                            }
                            if (SUCCEEDED(hr))
                            {
                                ILFree(pentry->_pidl);
                                pentry->_pidl = pidlNew;
                                hr = SHILClone(pidlNew, ppidlResolved);
                            }
                        }
                        pps->Release();
                    }
                }
                else if (SUCCEEDED(hr))
                {
                    // S_FALSE means "cancelled by user"
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }
                psl->Release();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }

        if (hr == S_OK)
        {
            pl.Save(this); // if this fails, tough
        }

    }

    ILFree(pidlFree);

    return hr;
}

//
//  The target pidl has changed (or it's brand new).  Create an IShellLink
//  around it so we can resolve it later.
//
HRESULT PINENTRY::UpdateShellLink()
{
    ASSERT(_pidl);

    // Pitch the old link; it's useless now.
    FreeShellLink();

    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &_psl));
    if (SUCCEEDED(hr))
    {
        hr = _psl->SetIDList(_pidl);
        if (FAILED(hr))
        {
            FreeShellLink();        // pitch it; it's no good
        }
    }
    return hr;
}

HRESULT CPinList::SaveShellLink(PINENTRY *pentry, IStream *pstm)
{
    HRESULT hr;
    if (pentry->_psl)
    {
        // It's still in the form of an IShellLink.
        // Save it to the stream, then go back and update the size information.
        LARGE_INTEGER liPos, liPosAfter;
        DWORD cbSize = 0;
        IPersistStream *pps = NULL;
        if (SUCCEEDED(hr = IStream_GetPos(pstm, &liPos)) &&
            // Write a dummy DWORD; we will come back and patch it up later
            SUCCEEDED(hr = IStream_Write(pstm, &cbSize, sizeof(cbSize))) &&
            SUCCEEDED(hr = pentry->_psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps))))
        {
            if (SUCCEEDED(hr = pps->Save(pstm, TRUE)) &&
                SUCCEEDED(hr = IStream_GetPos(pstm, &liPosAfter)) &&
                SUCCEEDED(hr = pstm->Seek(liPos, STREAM_SEEK_SET, NULL)))
            {
                cbSize = liPosAfter.LowPart - liPos.LowPart - sizeof(DWORD);
                if (SUCCEEDED(hr = IStream_Write(pstm, &cbSize, sizeof(cbSize))) &&
                    SUCCEEDED(hr = pstm->Seek(liPosAfter, STREAM_SEEK_SET, NULL)))
                {
                    // Hooray!  All got saved okay
                }
            }
            pps->Release();
        }
    }
    else
    {
        // It's just a reference back into our parent stream; copy it
        if (SUCCEEDED(hr = IStream_Write(pstm, &pentry->_cbSize, sizeof(pentry->_cbSize))))
        {
            // If _cbSize == 0 then _pstmLink might be NULL, so guard against it
            if (pentry->_cbSize)
            {
                if (SUCCEEDED(hr = _pstmLink->Seek(pentry->_liPos, STREAM_SEEK_SET, NULL)) &&
                    SUCCEEDED(hr = IStream_Copy(_pstmLink, pstm, pentry->_cbSize)))
                {
                    // Hooray! All got saved okay
                }
            }
            else
            {
                // Entry was blank - nothing to do, vacuous success
            }
        }
    }
    return hr;
}

HRESULT CPinList::LoadShellLink(PINENTRY *pentry, IShellLink **ppsl)
{
    HRESULT hr;
    if (pentry->_psl)
    {
        hr = S_OK;              // We already have the link
    }
    else if (pentry->_cbSize == 0)
    {
        hr = E_FAIL;            // no link available
    }
    else
    {                           // gotta make it
        IPersistStream *pps;
        hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IPersistStream, &pps));
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr = _pstmLink->Seek(pentry->_liPos, STREAM_SEEK_SET, NULL)) &&
                SUCCEEDED(hr = pps->Load(_pstmLink)) &&
                SUCCEEDED(hr = pps->QueryInterface(IID_PPV_ARG(IShellLink, &pentry->_psl))))
            {
                // woo-hoo! All got loaded okay
            }
            pps->Release();
        }
    }

    *ppsl = pentry->_psl;

    if (SUCCEEDED(hr))
    {
        pentry->_psl->AddRef();
        hr = S_OK;
    }

    return hr;
}


HRESULT CStartMenuPin::GetChangeCount(ULONG *pulOut)
{
    DWORD cb = sizeof(*pulOut);
    if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS,
                   REGSTR_VAL_STARTFAVCHANGES, NULL, pulOut, &cb) != ERROR_SUCCESS)
    {
        *pulOut = 0;
    }

    return S_OK;
}

HRESULT CStartMenuPin::SetChangeCount(ULONG ulChange)
{
    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS,
               REGSTR_VAL_STARTFAVCHANGES, REG_DWORD, &ulChange,
               sizeof(ulChange));

    return S_OK;
}

//
//  We scan this list in order, so if there is a CSIDL that is a subdirectory
//  of another CSIDL, we must put the subdirectory first.  For example,
//  CSIDL_PROGRAMS is typically a subdirectory of CSIDL_STARTMENU, so we
//  must put CSIDL_PROGRAMS first so we get the best match.
//
//  Furthermore, directories pinned items are more likely to be found in
//  should come before less popular directories.
//
const int c_rgcsidlRelative[] = {
    // Most common: Start Menu stuff
    CSIDL_PROGRAMS,                 // Programs must come before StartMenu
    CSIDL_STARTMENU,                // Programs must come before StartMenu

    // Next most common: My Documents stuff
    CSIDL_MYPICTURES,               // MyXxx must come before Personal
    CSIDL_MYMUSIC,                  // MyXxx must come before Personal
    CSIDL_MYVIDEO,                  // MyXxx must come before Personal
    CSIDL_PERSONAL,                 // MyXxx must come before Personal
    CSIDL_COMMON_PROGRAMS,          // Programs must come before StartMenu
    CSIDL_COMMON_STARTMENU,         // Programs must come before StartMenu

    // Next most common: Desktop stuff
    CSIDL_DESKTOPDIRECTORY,
    CSIDL_COMMON_DESKTOPDIRECTORY,

    // Next most common: Program files stuff
    CSIDL_PROGRAM_FILES_COMMON,     // ProgramFilesCommon must come before ProgramFiles
    CSIDL_PROGRAM_FILES,            // ProgramFilesCommon must come before ProgramFiles
    CSIDL_PROGRAM_FILES_COMMONX86,  // ProgramFilesCommon must come before ProgramFiles
    CSIDL_PROGRAM_FILESX86,         // ProgramFilesCommon must come before ProgramFiles

    // Other stuff (less common)
    CSIDL_APPDATA,
    CSIDL_COMMON_APPDATA,
    CSIDL_SYSTEM,
    CSIDL_SYSTEMX86,
    CSIDL_WINDOWS,
    CSIDL_PROFILE,                  // Must come after all other profile-relative directories
};

BOOL CPinList::ILWriteCallback(PINENTRY *pentry, ILWRITEINFO *pwi)
{
    BYTE csidl = CSIDL_DESKTOP;     // Assume nothing interesting
    LPITEMIDLIST pidlWrite = pentry->_pidl;  // Assume nothing interesting

    for (int i = 0; i < ARRAYSIZE(pwi->rgpidl); i++)
    {
        LPITEMIDLIST pidlT;
        if (pwi->rgpidl[i] &&
            (pidlT = ILFindChild(pwi->rgpidl[i], pentry->_pidl)))
        {
            csidl = (BYTE)c_rgcsidlRelative[i];
            pidlWrite = pidlT;
            break;
        }
    }

    if (SUCCEEDED(pwi->hr = IStream_Write(pwi->pstmPidlWrite, &csidl, sizeof(csidl))) &&
        SUCCEEDED(pwi->hr = IStream_WritePidl(pwi->pstmPidlWrite, pidlWrite)) &&
        SUCCEEDED(pwi->hr = pwi->ppl->SaveShellLink(pentry, pwi->pstmLinkWrite)))
    {
        // woo-hoo, all written successfully
    }

    return SUCCEEDED(pwi->hr);
}

#define CSIDL_END ((BYTE)0xFF)

HRESULT CPinList::Save(CStartMenuPin *psmpin)
{
    ILWRITEINFO wi;

    COMPILETIME_ASSERT(ARRAYSIZE(c_rgcsidlRelative) == ARRAYSIZE(wi.rgpidl));

    for (int i = 0; i < ARRAYSIZE(c_rgcsidlRelative); i++)
    {
        SHGetSpecialFolderLocation(NULL, c_rgcsidlRelative[i], &wi.rgpidl[i]);
    }

    wi.pstmPidlWrite = _OpenPinRegStream(STGM_WRITE);
    if (wi.pstmPidlWrite)
    {
        wi.pstmLinkWrite = _OpenLinksRegStream(STGM_WRITE);
        if (wi.pstmLinkWrite)
        {
            wi.hr = S_OK;
            wi.ppl = this;
            _dsaEntries.EnumCallbackEx(ILWriteCallback, &wi);

            if (SUCCEEDED(wi.hr))
            {
                BYTE csidlEnd = CSIDL_END;
                wi.hr = IStream_Write(wi.pstmPidlWrite, &csidlEnd, sizeof(csidlEnd));
            }

            if (FAILED(wi.hr))
            {
                wi.pstmPidlWrite->SetSize(c_uli0);
                wi.pstmLinkWrite->SetSize(c_uli0);
            }
            wi.pstmLinkWrite->Release();
        }
        wi.pstmPidlWrite->Release();
    }
    else
    {
        wi.hr = E_ACCESSDENIED; // Most common reason is lack of write permission
    }

    for (i = 0; i < ARRAYSIZE(c_rgcsidlRelative); i++)
    {
        ILFree(wi.rgpidl[i]);
    }

    // Bump the change count so people can detect and refresh
    ULONG ulChange;
    psmpin->GetChangeCount(&ulChange);
    psmpin->SetChangeCount(ulChange + 1);

    // Notify everyone that the pin list changed
    SHChangeDWORDAsIDList dwidl;
    dwidl.cb      = SIZEOF(dwidl) - SIZEOF(dwidl.cbZero);
    dwidl.dwItem1 = SHCNEE_PINLISTCHANGED;
    dwidl.dwItem2 = 0;
    dwidl.cbZero  = 0;

    SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH, (LPCITEMIDLIST)&dwidl, NULL);

    return wi.hr;
}

HRESULT CPinList::Load(CStartMenuPin *psmpin)
{
    HRESULT hr;

    if (Initialize())
    {
        IEnumIDList *penum;

        hr = psmpin->EnumObjects(&penum);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            while (penum->Next(1, &pidl, NULL) == S_OK)
            {
                if (AppendPidl(pidl) < 0)
                {
                    ILFree(pidl);
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            penum->Release();
        }

        if (SUCCEEDED(hr))
        {
            //
            //  Now read the persisted shortcuts.
            //
            _pstmLink = _OpenLinksRegStream(STGM_READ);
            if (_pstmLink)
            {
                for (int i = 0; i < _dsaEntries.GetItemCount(); i++)
                {
                    PINENTRY *pentry = _dsaEntries.GetItemPtr(i);
                    LARGE_INTEGER liSeek = { 0, 0 };
                    if (SUCCEEDED(hr = IStream_Read(_pstmLink, &liSeek.LowPart, sizeof(liSeek.LowPart))) && // read size
                        SUCCEEDED(hr = IStream_GetPos(_pstmLink, &pentry->_liPos)) &&  // read current pos
                        SUCCEEDED(hr = _pstmLink->Seek(liSeek, STREAM_SEEK_CUR, NULL))) // skip over link
                    {
                        pentry->_cbSize = liSeek.LowPart; // set this only on success
                    }
                    else
                    {
                        break;
                    }
                }
            }

            // If we encountered an error,
            // then throw all the shortcuts away because they are
            // probably corrupted.
            if (FAILED(hr))
            {
                for (int i = 0; i < _dsaEntries.GetItemCount(); i++)
                {
                    _dsaEntries.GetItemPtr(i)->FreeShellLink();
                }
            }

            // Problems reading the persisted shortcuts are ignored
            // since they are merely advisory.
            hr = S_OK;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//
//  Reading a pidl from a stream is a dangerous proposition because
//  a corrupted pidl can cause a shell extension to go haywire.
//
//  A pinned item is stored in the stream in the form
//
//  [byte:csidl] [dword:cbPidl] [size_is(cbPidl):pidl]
//
//  With the special csidl = -1 indicating the end of the list.
//
//  We use a byte for the csidl so a corrupted stream won't accidentally
//  pass "CSIDL_FLAG_CREATE" as a csidl to SHGetSpecialFolderLocation.

HRESULT CStartMenuPinEnum::_NextPidlFromStream(LPITEMIDLIST *ppidl)
{
    BYTE csidl;
    HRESULT hr = IStream_Read(_pstm, &csidl, sizeof(csidl));
    if (SUCCEEDED(hr))
    {
        if (csidl == CSIDL_END)
        {
            hr = S_FALSE;     // end of enumeration
        }
        else
        {
            LPITEMIDLIST pidlRoot;
            hr = SHGetSpecialFolderLocation(NULL, csidl, &pidlRoot);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = IStream_ReadPidl(_pstm, &pidl);
                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidlRoot, pidl, ppidl);
                    ILFree(pidl);
                }
                ILFree(pidlRoot);
            }
        }
    }

    return hr;
}

// *** IEnumIDList::Next

HRESULT CStartMenuPinEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr;

    ASSERT(celt > 0);

    // If there was an error or EOF on the last call to IEnumIDList::Next,
    // then that result is sticky.  Once an enumeration has errored, it stays
    // in the error state; once it has reached EOF, it stays at EOF.  The
    // only way to clear the state is to perform a Reset().

    if (_hrLastEnum != S_OK)
    {
        return _hrLastEnum;
    }

    if (!_pstm)
    {
        _pstm = _OpenPinRegStream(STGM_READ);
    }

    if (_pstm)
    {
        rgelt[0] = NULL;
        hr = _NextPidlFromStream(rgelt);
    }
    else
    {
        hr = S_FALSE;   // No stream therefore no items
    }

    if (pceltFetched)
    {
        *pceltFetched = hr == S_OK ? 1 : 0;
    }

    // Remember the return code for next time.  If an error occured or EOF,
    // then free the memory used for enumeration.
    _hrLastEnum = hr;
    if (_hrLastEnum != S_OK)
    {
        ATOMICRELEASE(_pstm);
    }
    return hr;
}

// *** IEnumIDList::Skip

HRESULT CStartMenuPinEnum::Skip(ULONG)
{
    return E_NOTIMPL;
}

// *** IEnumIDList::Reset

HRESULT CStartMenuPinEnum::Reset()
{
    _hrLastEnum = S_OK;
    ATOMICRELEASE(_pstm);
    return S_OK;
}


// *** IEnumIDList::Clone

STDMETHODIMP CStartMenuPinEnum::Clone(IEnumIDList **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

// *** IStartMenuPin::EnumObjects

STDMETHODIMP CStartMenuPin::EnumObjects(IEnumIDList **ppenum)
{
    _InitPinRegStream();

    *ppenum = NULL;
    return CStartMenuPinEnum::CreateInstance(ppenum);
}

STDAPI CStartMenuPin_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppunk)
{
    return CStartMenuPin::_CreatorClass::CreateInstance(punkOuter, riid, ppunk);
}

// *** IStartMenuPin::_InitPinRegStream
//
// If the pin list has not yet been created, then create a default one.
//

static LPCTSTR c_rgszDefaultPin[] = {
    TEXT("shell:::{2559a1f4-21d7-11d4-bdaf-00c04f60b9f0}"), // CLSID_AutoCMClientInet
    TEXT("shell:::{2559a1f5-21d7-11d4-bdaf-00c04f60b9f0}"), // CLSID_AutoCMClientMail
#ifdef NOTYET
    // NOTE!  Before you turn this on, make sure wmp is installed on ia64
    TEXT("shell:::{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}"), // CLSID_AutoCMClientMedia
#endif
};

HRESULT CStartMenuPin::_InitPinRegStream()
{
    HRESULT hr = S_OK;

    if(SHRestricted(REST_NOSMPINNEDLIST))
        return hr;  //Nothing to initialize.

    IStream *pstm = _OpenPinRegStream(STGM_READ);

    BOOL fEmpty = pstm == NULL || SHIsEmptyStream(pstm);
    ATOMICRELEASE(pstm);

    if (fEmpty)
    {
        //  Create a default pin list
        CPinList pl;

        // Do not call pl.Load() because that will recurse back into us!

        if (pl.Initialize())
        {
            for (int i = 0; i < ARRAYSIZE(c_rgszDefaultPin); i++)
            {
                LPITEMIDLIST pidl = ILCreateFromPath(c_rgszDefaultPin[i]);
                if (pidl && pl.AppendPidl(pidl) < 0)
                {
                    ILFree(pidl);
                }
            }

            hr = pl.Save(this);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\stgenum.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "filefldr.h"
#include "stgenum.h"

// Construction / Destruction

CFSFolderEnumSTATSTG::CFSFolderEnumSTATSTG(CFSFolder* psf) :
    _cRef(1),
    _pfsf(psf),
    _cIndex(0)
{
    _pfsf->AddRef();

    _pfsf->_GetPath(_szSearch);
    PathAppend(_szSearch, TEXT("*"));  // we're looking for everything.
    _hFindFile = INVALID_HANDLE_VALUE;

    DllAddRef();
}

CFSFolderEnumSTATSTG::~CFSFolderEnumSTATSTG()
{
    _pfsf->Release();

    if (_hFindFile != INVALID_HANDLE_VALUE)
        FindClose(_hFindFile);

    DllRelease();
}

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFSFolderEnumSTATSTG::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFSFolderEnumSTATSTG::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CFSFolderEnumSTATSTG::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CFSFolderEnumSTATSTG, IEnumSTATSTG), // IEnumSTATSTG
        { 0 },
    };    
    return QISearch(this, qit, riid, ppv);
}

// IEnumSTATSTG
STDMETHODIMP CFSFolderEnumSTATSTG::Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;   // assume end of the enum
    
    ASSERT(rgelt);

    ZeroMemory(rgelt, sizeof(STATSTG));  // per COM conventions

    if (pceltFetched)
        *pceltFetched = 0;

    WIN32_FIND_DATA fd;
    BOOL fFound = FALSE;
    BOOL fGotFD = FALSE;

    do
    { 
        if (_cIndex == 0)
        {
            // this is the first file we look at.
            fGotFD = S_OK == SHFindFirstFile(_szSearch, &fd, &_hFindFile);
        }
        else
        {
            fGotFD = FindNextFile(_hFindFile, &fd);
        }
        _cIndex++;

        if (fGotFD)
        {
            ASSERT(fd.cFileName[0]);
            if (!PathIsDotOrDotDot(fd.cFileName))
                fFound = TRUE;
        }
    } while (fGotFD && !fFound);

    if (fFound)
    {
        hr = StatStgFromFindData(&fd, STATFLAG_DEFAULT, rgelt);
        if (SUCCEEDED(hr))
        {
            if (pceltFetched)
                *pceltFetched = 1;
        }
    }
    else if (_hFindFile != INVALID_HANDLE_VALUE)
    {
        // we'll be nice and close the handle as early as possible.
        FindClose(_hFindFile);
        _hFindFile = INVALID_HANDLE_VALUE;
    }

    return hr;
}

STDMETHODIMP CFSFolderEnumSTATSTG::Reset()
{
    HRESULT hr = S_OK;

    _cIndex = 0;

    if (_hFindFile != INVALID_HANDLE_VALUE)
    {
        FindClose(_hFindFile);
        _hFindFile = INVALID_HANDLE_VALUE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\stgutil.cpp ===
#include "shellprv.h"
#include "util.h"
#include "datautil.h"
#include "idlcomm.h"
#include "stgutil.h"
#include "ole2dup.h"


// determines if a string pszChild refers to a stream/storage that exists
// in the parent storage pStorageParent.
STDAPI_(BOOL) StgExists(IStorage * pStorageParent, LPCTSTR pszChild)
{
    BOOL fResult = FALSE;
    WCHAR wszChild[MAX_PATH];
    HRESULT hr;
    DWORD grfModeOpen = STGM_READ;
    IStream * pStreamOpened;

    RIPMSG(pszChild && IS_VALID_STRING_PTR(pszChild, -1), "StgExists: caller passed bad pszPath");

    SHTCharToUnicode(pszChild, wszChild, ARRAYSIZE(wszChild));

    hr = pStorageParent->OpenStream(wszChild, NULL, grfModeOpen, 0, &pStreamOpened);

    if (SUCCEEDED(hr))
    {
        pStreamOpened->Release();
        fResult = TRUE;
    }
    else
    {
        IStorage * pStorageOpened;
        hr = pStorageParent->OpenStorage(wszChild, NULL, grfModeOpen, NULL, 0, &pStorageOpened);

        if (SUCCEEDED(hr))
        {
            pStorageOpened->Release();
            fResult = TRUE;
        }
    }

    return fResult;
}


STDAPI StgCopyFileToStream(LPCTSTR pszSrc, IStream *pStream)
{
    IStream *pStreamSrc;
    DWORD grfModeSrc = STGM_READ | STGM_DIRECT | STGM_SHARE_DENY_WRITE;
    HRESULT hr = SHCreateStreamOnFileEx(pszSrc, grfModeSrc, 0, FALSE, NULL, &pStreamSrc);

    if (SUCCEEDED(hr))
    {
        ULARGE_INTEGER ulMax = {-1, -1};
        hr = pStreamSrc->CopyTo(pStream, ulMax, NULL, NULL);
        pStreamSrc->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = pStream->Commit(STGC_DEFAULT);
    }

    return hr;
}


STDAPI StgDeleteUsingDataObject(HWND hwnd, UINT uFlags, IDataObject *pdtobj)
{
    // TODO: stick this into aidan's pidl storage and delete via dave's engine

    HRESULT hr = E_FAIL;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        IStorage *pstg;
        LPCITEMIDLIST pidlFolder = IDA_GetIDListPtr(pida, -1);
        hr = StgBindToObject(pidlFolder, STGM_READWRITE, IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            hr = pstg->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                for (UINT i = 0; (i < pida->cidl) && SUCCEEDED(hr); i++)
                {
                    LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, i);
                    WCHAR wzName[MAX_PATH];
                    hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, wzName, ARRAYSIZE(wzName));
                    if (SUCCEEDED(hr))
                    {
                        hr = pstg->DestroyElement(wzName);
                    }
                }

                if (SUCCEEDED(hr))
                    hr = pstg->Commit(STGC_DEFAULT);
                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, pidlFolder, NULL);
                psf->Release();
            }
            pstg->Release();
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }

    return hr;
}



STDAPI StgBindToObject(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv)
{
    IBindCtx *pbc;
    HRESULT hr = BindCtx_CreateWithMode(grfMode, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObjectEx(NULL, pidl, pbc, riid, ppv);

        pbc->Release();
    }
    return hr;
}


typedef HRESULT (WINAPI * PSTGOPENSTORAGEONHANDLE)(HANDLE,DWORD,void*,void*,REFIID,void**);

STDAPI SHStgOpenStorageOnHandle(HANDLE h, DWORD grfMode, void *res1, void *res2, REFIID riid, void **ppv)
{
    static PSTGOPENSTORAGEONHANDLE pfn = NULL;
    
    if (pfn == NULL)
    {
        HMODULE hmodOle32 = LoadLibraryA("ole32.dll");

        if (hmodOle32)
        {
            pfn = (PSTGOPENSTORAGEONHANDLE)GetProcAddress(hmodOle32, "StgOpenStorageOnHandle");
        }
    }

    if (pfn)
    {
        return pfn(h, grfMode, res1, res2, riid, ppv);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


STDAPI StgOpenStorageOnFolder(LPCTSTR pszFolder, DWORD grfFlags, REFIID riid, void **ppv)
{
    *ppv = NULL;

    DWORD dwDesiredAccess, dwShareMode, dwCreationDisposition;
    HRESULT hr = ModeToCreateFileFlags(grfFlags, FALSE, &dwDesiredAccess, &dwShareMode, &dwCreationDisposition);
    if (SUCCEEDED(hr))
    {
		// For IPropertySetStorage, we don't want to unnecessarily tie up access to the folder, if all
		// we're doing is dealing with property sets. The implementation of IPropertySetStorage for
		// NTFS files is defined so that the sharing/access only applies to the property set stream, not
		// it's other streams. So it makes sense to do a CreateFile on a folder with full sharing, while perhaps specifying
		// STGM_SHARE_EXCLUSIVE for the property set storage.
        if (riid == IID_IPropertySetStorage)
            dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        HANDLE h = CreateFile(pszFolder, dwDesiredAccess, dwShareMode, NULL, 
            dwCreationDisposition, FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE);
        if (INVALID_HANDLE_VALUE != h)
        {
            hr = SHStgOpenStorageOnHandle(h, grfFlags, NULL, NULL, riid, ppv);
            CloseHandle(h);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}


class CDocWrapperStorage : public IStorage
{
public:
    CDocWrapperStorage(LPCTSTR szPath, CDocWrapperStorage *pstgParent, IStorage *pstg);
    ~CDocWrapperStorage();

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IStorage
    STDMETHODIMP Revert()
        { return _pstgInner->Revert(); }
    STDMETHODIMP DestroyElement(LPCWSTR pszRel)
        { return _pstgInner->DestroyElement(pszRel); }
    STDMETHODIMP RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName)
        { return _pstgInner->RenameElement(pwcsOldName, pwcsNewName); }
    STDMETHODIMP SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
        { return _pstgInner->SetElementTimes(pszRel, pctime, patime, pmtime); }
    STDMETHODIMP SetClass(REFCLSID clsid)
        { return _pstgInner->SetClass(clsid); }
    STDMETHODIMP SetStateBits(DWORD grfStateBits, DWORD grfMask)
        { return _pstgInner->SetStateBits(grfStateBits, grfMask); }
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag)
        { return _pstgInner->Stat(pstatstg, grfStatFlag); }
    STDMETHODIMP CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
        { return _pstgInner->CopyTo(ciidExclude, rgiidExclude, snbExclude, pstgDest); }
    STDMETHODIMP MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
        { return _pstgInner->MoveElementTo(pszRel, pstgDest, pwcsNewName, grfFlags); }
    STDMETHODIMP EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum)
        { return _pstgInner->EnumElements(reserved1, reserved2, reserved3, ppenum); }

    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm);
    STDMETHODIMP OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);                
    STDMETHODIMP CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg);
    STDMETHODIMP OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg);

protected:
    LONG _cRef;

    IStorage *_pstgInner;
    CDocWrapperStorage *_pstgParent;
    TCHAR _szPath[MAX_PATH];

    STDMETHODIMP _MakeNewStorage(DWORD grfMode, CDocWrapperStorage **ppwstg);
    STDMETHODIMP _GetRelPath(LPTSTR pszRelPath);
    STDMETHODIMP _GetNewRootStorage(DWORD grfMode, CDocWrapperStorage **ppwstgRoot);
    STDMETHODIMP _ReOpen(LPCTSTR pszRelPath, DWORD grfMode, CDocWrapperStorage **ppwstg);
    STDMETHODIMP _OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, CDocWrapperStorage **ppwstg);
};



class CDocWrapperStream : public IStream
{
public:
    CDocWrapperStream(CDocWrapperStorage *pstgParent, IStream *pstm);
    ~CDocWrapperStream();

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IStream
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead)
        { return _pstmInner->Read(pv, cb, pcbRead); }
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten)
        { return _pstmInner->Write(pv, cb, pcbWritten); }
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
        { return _pstmInner->Seek(dlibMove, dwOrigin, plibNewPosition); }
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize)
        { return _pstmInner->SetSize(libNewSize); }
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
        { return _pstmInner->CopyTo(pstm, cb, pcbRead, pcbWritten); }
    STDMETHODIMP Commit(DWORD grfCommitFlags)
        { return _pstmInner->Commit(grfCommitFlags); }
    STDMETHODIMP Revert()
        { return _pstmInner->Revert(); }
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return _pstmInner->LockRegion(libOffset, cb, dwLockType); }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return _pstmInner->UnlockRegion(libOffset, cb, dwLockType); }
    STDMETHODIMP Clone(IStream **ppstm)
        { return _pstmInner->Clone(ppstm); }
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag)
        { return _pstmInner->Stat(pstatstg, grfStatFlag); }

protected:
    LONG _cRef;

    IStream  *_pstmInner;
    CDocWrapperStorage *_pstgParent;
};


// this switches up the grfMode for elements in a docfile.
// docfiles are limited to ALWAYS opening elements in exclusive mode, so we
// enforce that here.
DWORD _MungeModeForElements(DWORD grfMode)
{
    grfMode &= ~(STGM_TRANSACTED | STGM_SHARE_DENY_NONE | STGM_SHARE_DENY_WRITE | STGM_SHARE_DENY_READ);
    grfMode |= STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    return grfMode;
}


// this switches up the grfMode for the root storage for a docfile.
// if we open the root in exclusive mode, then we're in trouble for sure since
// nobody else can get to any of the elements.
// the root is the only guy that docfiles can share too so we take advantage
// of that by enforcing STGM_TRANSACTED and STGM_SHARE_DENY_NONE.
DWORD _MungeModeForRoot(DWORD grfMode)
{
    grfMode &= ~(STGM_DIRECT | STGM_SHARE_DENY_READ | STGM_SHARE_DENY_WRITE | STGM_SHARE_EXCLUSIVE);
    grfMode |= STGM_TRANSACTED | STGM_SHARE_DENY_NONE;

    return grfMode;
}


STDAPI StgGetStorageFromFile(LPCWSTR wzPath, DWORD grfMode, IStorage **ppstg)
{
    IStorage *pstgUnwrapped;
    HRESULT hr = StgOpenStorageEx(wzPath, _MungeModeForRoot(grfMode), STGFMT_ANY, 0, NULL, NULL, IID_PPV_ARG(IStorage, &pstgUnwrapped));

    if (SUCCEEDED(hr))
    {
        // wrap the docfile storage.
        CDocWrapperStorage *pwstg = new CDocWrapperStorage(wzPath, NULL, pstgUnwrapped);
        if (pwstg)
        {
            hr = pwstg->QueryInterface(IID_PPV_ARG(IStorage, ppstg));
            pwstg->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pstgUnwrapped->Release();
    }
    return hr;
}


// CDocWrapperStorage

CDocWrapperStorage::CDocWrapperStorage(LPCTSTR pszPath, CDocWrapperStorage *pstgParent, IStorage *pstg) :
    _cRef(1)
{
    _pstgParent = pstgParent;
    if (_pstgParent)
        _pstgParent->AddRef();

    _pstgInner = pstg;
    _pstgInner->AddRef();

    // if this is the root docfile storage, keep track of the fs path that was used to
    // open it (since we might need to open it again).
    lstrcpyn(_szPath, pszPath, ARRAYSIZE(_szPath));

    DllAddRef();
}

CDocWrapperStorage::~CDocWrapperStorage()
{
    ATOMICRELEASE(_pstgParent);
    ATOMICRELEASE(_pstgInner);

    DllRelease();
}

// IUnknown

STDMETHODIMP_(ULONG) CDocWrapperStorage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDocWrapperStorage::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDocWrapperStorage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDocWrapperStorage, IStorage),     // IID_IStorage
        { 0 },
    };
    // NOTE: this will fail on IPropertySetStorage.
    // can the docfile storage be aggregated?
    // in any case the IPropertySetStorage routines don't need to use this
    // wrapper for any lifetime issues.
    return QISearch(this, qit, riid, ppv);
}


// IStorage

STDMETHODIMP CDocWrapperStorage::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = _pstgInner->Commit(grfCommitFlags);
    if (_pstgParent && SUCCEEDED(hr))
        hr = _pstgParent->Commit(grfCommitFlags);
    return hr;
}


STDMETHODIMP CDocWrapperStorage::CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm)
{
    IStream *pstm;
    HRESULT hr = _pstgInner->CreateStream(pwcsName, _MungeModeForElements(grfMode), res1, res2, &pstm);
    if (SUCCEEDED(hr))
    {
        CDocWrapperStream *pwstm = new CDocWrapperStream(this, pstm);
        if (pwstm)
        {
            hr = pwstm->QueryInterface(IID_PPV_ARG(IStream, ppstm));
            pwstm->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pstm->Release();
    }
    return hr;
}


STDMETHODIMP CDocWrapperStorage::CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg)
{
    IStorage *pstg;
    HRESULT hr = _pstgInner->CreateStorage(pwcsName, _MungeModeForElements(grfMode), res1, res2, &pstg);
    if (SUCCEEDED(hr))
    {
        CDocWrapperStorage *pwstg = new CDocWrapperStorage(NULL, this, pstg);
        if (pwstg)
        {
            hr = pwstg->QueryInterface(IID_PPV_ARG(IStorage, ppstg));
            pwstg->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pstg->Release();
    }
    return hr;
}


// TODO: move this away from a MAX_PATH total length restriction

// gets a "path" relative from the root storage down to this element.
// see comments for _MakeNewStorage.
STDMETHODIMP CDocWrapperStorage::_GetRelPath(LPTSTR pszRelPath)
{
    HRESULT hr = S_OK;
    if (_pstgParent)
    {
        // first get the path up to here from the root.
        hr = _pstgParent->_GetRelPath(pszRelPath);
        if (SUCCEEDED(hr))
        {
            STATSTG stat;
            hr = Stat(&stat, STATFLAG_DEFAULT);
            if (SUCCEEDED(hr))
            {
                // now append the name of this element.
                if (!PathAppend(pszRelPath, stat.pwcsName))
                    hr = E_FAIL;
                CoTaskMemFree(stat.pwcsName);
            }
        }
    }
    else
    {
        // we are the root, so init the string.
        pszRelPath[0] = 0;
    }
    return hr;
}


// opens another instance of the root storage.
// see comments for _MakeNewStorage.
STDMETHODIMP CDocWrapperStorage::_GetNewRootStorage(DWORD grfMode, CDocWrapperStorage **ppwstgRoot)
{
    HRESULT hr = S_OK;
    if (_pstgParent)
    {
        // get it from our parent.
        hr = _pstgParent->_GetNewRootStorage(grfMode, ppwstgRoot);
    }
    else
    {
        // we are the root.
        IStorage *pstgUnwrapped;
        hr = StgOpenStorageEx(_szPath, _MungeModeForRoot(grfMode), STGFMT_ANY, 0, NULL, NULL, IID_PPV_ARG(IStorage, &pstgUnwrapped));
        if (SUCCEEDED(hr))
        {
            *ppwstgRoot = new CDocWrapperStorage(_szPath, NULL, pstgUnwrapped);
            if (!*ppwstgRoot)
                hr = E_OUTOFMEMORY;
            pstgUnwrapped->Release();
        }
    }
    return hr;
}


// opens storages using the "path" in pszRelPath.
// see comments for _MakeNewStorage.
STDMETHODIMP CDocWrapperStorage::_ReOpen(LPCTSTR pszRelPath, DWORD grfMode, CDocWrapperStorage **ppwstg)
{
    HRESULT hr = S_OK;
    // no relative path signifies that we want this storage itself
    if (!pszRelPath || !pszRelPath[0])
    {
        *ppwstg = this;
        AddRef();
    }
    else
    {
        TCHAR szElementName[MAX_PATH];
        hr = _NextSegment(&pszRelPath, szElementName, ARRAYSIZE(szElementName), TRUE);
        if (SUCCEEDED(hr))
        {
            CDocWrapperStorage *pwstg;
            hr = _OpenStorage(szElementName, NULL, grfMode, NULL, 0, &pwstg);
            if (SUCCEEDED(hr))
            {
                hr = pwstg->_ReOpen(pszRelPath, grfMode, ppwstg);
                pwstg->Release();
            }
        }
    }
    return hr;
}


// NOTE: this is needed if we want to open an element of the docfile in non-exclusive mode.
// to do that we need to get back to the root, open another copy of the root in
// non-exclusive mode, and then come back down.
STDMETHODIMP CDocWrapperStorage::_MakeNewStorage(DWORD grfMode, CDocWrapperStorage **ppwstg)
{
    TCHAR szRelPath[MAX_PATH];
    HRESULT hr = _GetRelPath(szRelPath);
    if (SUCCEEDED(hr))
    {
        CDocWrapperStorage *pwstgRoot;
        hr = _GetNewRootStorage(grfMode, &pwstgRoot);
        if (SUCCEEDED(hr))
        {
            hr = pwstgRoot->_ReOpen(szRelPath, grfMode, ppwstg);
            pwstgRoot->Release();
        }
    }
    return hr;
}


STDMETHODIMP CDocWrapperStorage::OpenStream(LPCWSTR pwcsName, void *res1, DWORD grfMode, DWORD res2, IStream **ppstm)
{
    IStream *pstm;
    HRESULT hr = _pstgInner->OpenStream(pwcsName, res1, _MungeModeForElements(grfMode), res2, &pstm);

    if (hr == STG_E_ACCESSDENIED)
    {
        // we're in trouble -- the stream has been opened with SHARE_EXCLUSIVE already
        // so we need to back up to the root storage, open another instance of that,
        // and come back down here.
        CDocWrapperStorage *pstgNew;
        hr = _MakeNewStorage(grfMode, &pstgNew);
        if (SUCCEEDED(hr))
        {
            hr = pstgNew->OpenStream(pwcsName, res1, grfMode, res2, ppstm);
            pstgNew->Release();
        }
    }
    else if (SUCCEEDED(hr))
    {
        CDocWrapperStream *pwstm = new CDocWrapperStream(this, pstm);
        if (pwstm)
        {
            hr = pwstm->QueryInterface(IID_PPV_ARG(IStream, ppstm));
            pwstm->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pstm->Release();
    }

    return hr;
}


STDMETHODIMP CDocWrapperStorage::_OpenStorage(LPCWSTR pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD res, CDocWrapperStorage **ppwstg)
{
    IStorage *pstg;
    HRESULT hr = _pstgInner->OpenStorage(pwcsName, pstgPriority, _MungeModeForElements(grfMode), snbExclude, res, &pstg);
    if (hr == STG_E_ACCESSDENIED)
    {
        // we're in trouble -- the storage has been opened with SHARE_EXCLUSIVE already
        // so we need to back up to the root storage, open another instance of that,
        // and come back down here.
        CDocWrapperStorage *pstgNew;
        hr = _MakeNewStorage(grfMode, &pstgNew);
        if (SUCCEEDED(hr))
        {
            hr = pstgNew->_OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude, res, ppwstg);
            pstgNew->Release();
        }
    }
    else if (SUCCEEDED(hr))
    {
        *ppwstg = new CDocWrapperStorage(NULL, this, pstg);
        if (!*ppwstg)
            hr = E_OUTOFMEMORY;
        pstg->Release();
    }
    return hr;
}


STDMETHODIMP CDocWrapperStorage::OpenStorage(LPCWSTR pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD res, IStorage **ppstg)
{
    CDocWrapperStorage *pwstg;
    HRESULT hr = _OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude, res, &pwstg);
    if (SUCCEEDED(hr))
    {
        hr = pwstg->QueryInterface(IID_PPV_ARG(IStorage, ppstg));
        pwstg->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


// CDocWrapperStream



CDocWrapperStream::CDocWrapperStream(CDocWrapperStorage *pstgParent, IStream *pstm) :
    _cRef(1)
{
    _pstgParent = pstgParent;
    _pstgParent->AddRef();

    _pstmInner = pstm;
    _pstmInner->AddRef();

    DllAddRef();
}

CDocWrapperStream::~CDocWrapperStream()
{
    ATOMICRELEASE(_pstgParent);
    ATOMICRELEASE(_pstmInner);

    DllRelease();
}

// IUnknown

STDMETHODIMP_(ULONG) CDocWrapperStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDocWrapperStream::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDocWrapperStream::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDocWrapperStream, IStream),       // IID_IStream
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}



// CShortcutStorage

class CShortcutStorage : public IStorage
{
public:
    CShortcutStorage(IStorage *pstg);
    ~CShortcutStorage();

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IStorage
    STDMETHODIMP CreateStream(LPCWSTR pszRel, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream **ppstm)
        { return _pstgInner->CreateStream(pszRel, grfMode, reserved1, reserved2, ppstm); }
    STDMETHODIMP CreateStorage(LPCWSTR pszRel, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage **ppstg)
        { return _pstgInner->CreateStorage(pszRel, grfMode, reserved1, reserved2, ppstg); }
    STDMETHODIMP Commit(DWORD grfCommitFlags)
        { return _pstgInner->Commit(grfCommitFlags); }
    STDMETHODIMP Revert()
        { return _pstgInner->Revert(); }
    STDMETHODIMP DestroyElement(LPCWSTR pszRel)
        { return _pstgInner->DestroyElement(pszRel); }
    STDMETHODIMP RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName)
        { return _pstgInner->RenameElement(pwcsOldName, pwcsNewName); }
    STDMETHODIMP SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
        { return _pstgInner->SetElementTimes(pszRel, pctime, patime, pmtime); }
    STDMETHODIMP SetClass(REFCLSID clsid)
        { return _pstgInner->SetClass(clsid); }
    STDMETHODIMP SetStateBits(DWORD grfStateBits, DWORD grfMask)
        { return _pstgInner->SetStateBits(grfStateBits, grfMask); }
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag)
        { return _pstgInner->Stat(pstatstg, grfStatFlag); }

    STDMETHODIMP OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);                
    STDMETHODIMP OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg);
    STDMETHODIMP CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)        
        { return E_NOTIMPL; };
    STDMETHODIMP MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
        { return E_NOTIMPL; };
    STDMETHODIMP EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum);        

protected:
    LONG _cRef;
    IStorage *_pstgInner;
};

class CShortcutStream : public IStream
{
public:
    CShortcutStream(LPCWSTR pwzRealName, IStream *pstm);
    ~CShortcutStream();

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IStream
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead)
        { return _pstmInner->Read(pv, cb, pcbRead); }
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten)
        { return _pstmInner->Write(pv, cb, pcbWritten); }
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
        { return _pstmInner->Seek(dlibMove, dwOrigin, plibNewPosition); }
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize)
        { return _pstmInner->SetSize(libNewSize); }
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
        { return _pstmInner->CopyTo(pstm, cb, pcbRead, pcbWritten); }
    STDMETHODIMP Commit(DWORD grfCommitFlags)
        { return _pstmInner->Commit(grfCommitFlags); }
    STDMETHODIMP Revert()
        { return _pstmInner->Revert(); }
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return _pstmInner->LockRegion(libOffset, cb, dwLockType); }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return _pstmInner->UnlockRegion(libOffset, cb, dwLockType); }
    STDMETHODIMP Clone(IStream **ppstm)
        { return _pstmInner->Clone(ppstm); }

    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);

protected:
    LONG _cRef;
    WCHAR _wzName[MAX_PATH];
    IStream *_pstmInner;
};


class CShortcutStorageEnumSTATSTG : public IEnumSTATSTG
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumSTATSTG
    STDMETHODIMP Skip(ULONG celt)
        { return _penumInner->Skip(celt); };
    STDMETHODIMP Reset()
        { return _penumInner->Reset(); };
    STDMETHODIMP Clone(IEnumSTATSTG **ppenum)
        { return _penumInner->Clone(ppenum); };

    STDMETHODIMP Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched);

protected:
    CShortcutStorageEnumSTATSTG(CShortcutStorage *psstg, IEnumSTATSTG *penum);
    ~CShortcutStorageEnumSTATSTG();

private:
    LONG _cRef;
    CShortcutStorage *_psstg;
    IEnumSTATSTG *_penumInner;
    friend CShortcutStorage;
};

CShortcutStorage::CShortcutStorage(IStorage *pstg) :
    _cRef(1),
    _pstgInner(pstg)
{
    _pstgInner->AddRef();
    DllAddRef();
}

CShortcutStorage::~CShortcutStorage()
{
    ATOMICRELEASE(_pstgInner);
    DllRelease();
}


// IUnknown

STDMETHODIMP_(ULONG) CShortcutStorage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShortcutStorage::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CShortcutStorage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShortcutStorage, IStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IStorage

STDMETHODIMP CShortcutStorage::OpenStream(LPCWSTR pwcsName, void *res1, DWORD grfMode, DWORD res2, IStream **ppstm)
{
    IStream *pstmLink;
    HRESULT hr = _pstgInner->OpenStream(pwcsName, res1, grfMode, res2, &pstmLink);
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;
        hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IPersistStream, &pps));
        if (SUCCEEDED(hr))
        {
            hr = pps->Load(pstmLink);
            IShellLink *psl;
            if (SUCCEEDED(hr))
                hr = pps->QueryInterface(IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = psl->GetIDList(&pidl);
                if (hr == S_OK)
                {
                    IStream *pstmReal;
                    hr = SHBindToObject(NULL, IID_X_PPV_ARG(IStream, pidl, &pstmReal));
                    if (SUCCEEDED(hr))
                    {
                        CShortcutStream *psstm = new CShortcutStream(pwcsName, pstmReal);
                        if (psstm)
                        {
                            hr = psstm->QueryInterface(IID_PPV_ARG(IStream, ppstm));
                            psstm->Release();
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        pstmReal->Release();
                    }
                    ILFree(pidl);
                }
                else
                {
                    // munge S_FALSE into E_FAIL (initialization must have failed for the link)
                    hr = SUCCEEDED(hr) ? E_FAIL : hr;
                }
                psl->Release();
            }
            pps->Release();
        }

        // fall back to the non-link stream
        if (FAILED(hr))
        {
            hr = pstmLink->QueryInterface(IID_PPV_ARG(IStream, ppstm));
        }

        pstmLink->Release();
    }
    return hr;
}

STDMETHODIMP CShortcutStorage::OpenStorage(LPCWSTR pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD res, IStorage **ppstg)
{
    IStorage *pstg;
    HRESULT hr = _pstgInner->OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude, res, &pstg);
    if (SUCCEEDED(hr))
    {
        CShortcutStorage *psstg = new CShortcutStorage(pstg);
        if (psstg)
        {
            hr = psstg->QueryInterface(IID_PPV_ARG(IStorage, ppstg));
            psstg->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pstg->Release();
    }
    return hr;
}

STDMETHODIMP CShortcutStorage::EnumElements(DWORD res1, void *res2, DWORD res3, IEnumSTATSTG **ppenum)
{
    IEnumSTATSTG *penum;
    HRESULT hr = _pstgInner->EnumElements(res1, res2, res3, &penum);
    if (SUCCEEDED(hr))
    {
        CShortcutStorageEnumSTATSTG *pssenum = new CShortcutStorageEnumSTATSTG(this, penum);
        if (pssenum)
        {
            *ppenum = (IEnumSTATSTG *) pssenum;
            hr = S_OK;
        }
        else
        {
            *ppenum = NULL;
            hr = E_OUTOFMEMORY;
        }
        penum->Release();
    }
    return hr;
}


// CShortcutStorageEnumSTATSTG

CShortcutStorageEnumSTATSTG::CShortcutStorageEnumSTATSTG(CShortcutStorage *psstg, IEnumSTATSTG *penum) :
    _cRef(1)
{
    _psstg = psstg;
    _psstg->AddRef();

    _penumInner = penum;
    _penumInner->AddRef();

    DllAddRef();
}

CShortcutStorageEnumSTATSTG::~CShortcutStorageEnumSTATSTG()
{
    ATOMICRELEASE(_psstg);
    ATOMICRELEASE(_penumInner);

    DllRelease();
}

// IUnknown

STDMETHODIMP_(ULONG) CShortcutStorageEnumSTATSTG::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShortcutStorageEnumSTATSTG::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CShortcutStorageEnumSTATSTG::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShortcutStorageEnumSTATSTG, IEnumSTATSTG),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IStorage

HRESULT CShortcutStorageEnumSTATSTG::Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched)
{
    ASSERTMSG((rgelt != NULL), "bad input parameter rgelt in CShortcutStorageEnumSTATSTG::Next");

    ZeroMemory(rgelt, sizeof(STATSTG));  // per COM conventions

    STATSTG stat;
    // we just get the next element from the inner enumeration so that we can
    // get the name of it and keep our ordering.  all the other data is useless.
    HRESULT hr = _penumInner->Next(1, &stat, NULL);
    if (hr == S_OK)
    {
        switch (stat.type)
        {
        case STGTY_STORAGE:
            // if it's a storage, the data is good enough.
            memcpy(rgelt, &stat, sizeof(STATSTG));
            break;
        
        case STGTY_STREAM:
            // we need to dereference the link and get the real data.
            IStream *pstm;
            // TODO: make sure that nobody else has this guy open in exclusive mode.
            hr = _psstg->OpenStream(stat.pwcsName, NULL, STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pstm);
            if (SUCCEEDED(hr))
            {
                hr = pstm->Stat(rgelt, STATFLAG_DEFAULT);

                pstm->Release();
            }
            CoTaskMemFree(stat.pwcsName);
            break;

        default:
            ASSERTMSG(FALSE, "Unknown type in storage.");
            break;
        }
        if (SUCCEEDED(hr) && pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}


// CShortcutStream

CShortcutStream::CShortcutStream(LPCWSTR pwzRealName, IStream *pstm) :
    _cRef(1),
    _pstmInner(pstm)
{
    _pstmInner->AddRef();
    lstrcpyn(_wzName, pwzRealName, ARRAYSIZE(_wzName));
    DllAddRef();
}

CShortcutStream::~CShortcutStream()
{
    ATOMICRELEASE(_pstmInner);
    DllRelease();
}


// IUnknown

STDMETHODIMP_(ULONG) CShortcutStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShortcutStream::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CShortcutStream::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShortcutStream, IStream),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IStream

HRESULT CShortcutStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    ASSERTMSG((pstatstg != NULL), "bad input parameter pstatstg in CShortcutStream::Stat");

    STATSTG stat;
    HRESULT hr = _pstmInner->Stat(&stat, grfStatFlag);
    if (SUCCEEDED(hr))
    {
        // move all the fields over (we won't change most of em)
        memcpy(pstatstg, &stat, sizeof(STATSTG));

        // overwrite the name field with what we have
        if (grfStatFlag == STATFLAG_DEFAULT)
        {
            hr = SHStrDup(_wzName, &pstatstg->pwcsName);

            CoTaskMemFree(stat.pwcsName);
        }
    }
    return hr;
}

STDAPI CShortcutStorage_CreateInstance(IStorage *pstg, REFIID riid, void **ppv)
{
    if (!pstg)
        return E_INVALIDARG;    

    CShortcutStorage *pscstg = new CShortcutStorage(pstg);
    if (!pscstg)
        return E_OUTOFMEMORY;

    HRESULT hr = pscstg->QueryInterface(riid, ppv);
    pscstg->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\stg2stgx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File: Stg2StgX.cpp
//
//  Contents: Wrapper object that takes an IStorage and makes it act like and ITransferDest
//
//  History:  18-July-2000 ToddB
//
//--------------------------------------------------------------------------

#include "shellprv.h"
#include "ids.h"
#pragma hdrstop

#include "isproc.h"
#include "ConfirmationUI.h"
#include "clsobj.h"

class CShellItem2TransferDest : public ITransferDest
{
public:
    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);

    // ITransferDest
    STDMETHOD(Advise)(ITransferAdviseSink *pAdvise, DWORD *pdwCookie);

    STDMETHOD(Unadvise)(DWORD dwCookie);

    STDMETHOD(OpenElement)(
        const WCHAR *pwcsName,
        STGXMODE      grfMode,
        DWORD       *pdwType,
        REFIID        riid,
        void       **ppunk);

    STDMETHOD(CreateElement)(
        const WCHAR *pwcsName,
        IShellItem *psiTemplate,
        STGXMODE      grfMode,
        DWORD         dwType,
        REFIID        riid,
        void       **ppunk);

    STDMETHOD(MoveElement)(
        IShellItem *psiItem,
        WCHAR       *pwcsNewName,    // Pointer to new name of element in destination
        STGXMOVE      grfOptions);    // Options (STGMOVEEX_ enum)

    STDMETHOD(DestroyElement)(
        const WCHAR *pwcsName,
        STGXDESTROY grfOptions);

    // commented out in the interface declaration
    STDMETHOD(RenameElement)(
        const WCHAR *pwcsOldName,
        const WCHAR *pwcsNewName);

    // CShellItem2TransferDest
    CShellItem2TransferDest();
    STDMETHOD(Init)(IShellItem *psi, IStorageProcessor *pEngine);

protected:
    ULONG _cRef;
    IShellItem *_psi;
    ITransferAdviseSink  *_ptas;
    IStorageProcessor   *_pEngine;
    BOOL _fWebFolders;
    
    ~CShellItem2TransferDest();
    HRESULT _OpenHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD *pdwType, REFIID riid, void **ppunk);
    HRESULT _CreateHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD dwType, REFIID riid, void **ppunk);
    HRESULT _GetItemType(IShellItem *psi, DWORD *pdwType);
    HRESULT _BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv);
    BOOL _CanHardLink(LPCWSTR pszSourceName, LPCWSTR pszDestName);
    HRESULT _CopyStreamHardLink(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName);
    HRESULT _CopyStreamBits(IShellItem *psiSource, IShellItem *psiDest);
    HRESULT _CopyStreamWithOptions(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName, STGXMOVE grfOptions);
    BOOL _HasMultipleStreams(IShellItem *psiItem);
};

STDAPI CreateStg2StgExWrapper(IShellItem *psi, IStorageProcessor *pEngine, ITransferDest **pptd)
{
    if (!psi || !pptd)
        return E_INVALIDARG;

    *pptd = NULL;

    CShellItem2TransferDest *pobj = new CShellItem2TransferDest();
    if (!pobj)
        return E_OUTOFMEMORY;

    HRESULT hr = pobj->Init(psi, pEngine);
    if (SUCCEEDED(hr))
    {
        hr = pobj->QueryInterface(IID_PPV_ARG(ITransferDest, pptd));
    }

    pobj->Release();

    return hr;
}

CShellItem2TransferDest::CShellItem2TransferDest() : _cRef(1)
{
}

CShellItem2TransferDest::~CShellItem2TransferDest()
{
    if (_psi)
        _psi->Release();
        
    if (_pEngine)
        _pEngine->Release();
    
    if (_ptas)
        _ptas->Release();
}

HRESULT CShellItem2TransferDest::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CShellItem2TransferDest, ITransferDest),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItem2TransferDest::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CShellItem2TransferDest::Release()
{
    if (InterlockedDecrement((LONG *)&_cRef))
        return _cRef;

    delete this;
    return 0;
}

BOOL _IsWebfolders(IShellItem *psi);

STDMETHODIMP CShellItem2TransferDest::Init(IShellItem *psi, IStorageProcessor *pEngine)
{
    if (!psi)
        return E_INVALIDARG;

    if (_psi)
        return E_FAIL;

    _psi = psi;
    _psi->AddRef();
    _fWebFolders = _IsWebfolders(_psi);

    if (pEngine)
    {
        _pEngine = pEngine;
        _pEngine->AddRef();
    }

    return S_OK;
}

// ITransferDest
STDMETHODIMP CShellItem2TransferDest::Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie)
{
    if (!pAdvise || !pdwCookie)
        return E_INVALIDARG;

    if (_ptas)
        return E_FAIL;

    _ptas = pAdvise;
    *pdwCookie = 1;
    _ptas->AddRef();

    return S_OK;
}

STDMETHODIMP CShellItem2TransferDest::Unadvise(DWORD dwCookie)
{
    if (dwCookie != 1)
        return E_INVALIDARG;

    ATOMICRELEASE(_ptas);

    return S_OK;
}

HRESULT CShellItem2TransferDest::_GetItemType(IShellItem *psi, DWORD *pdwType)
{
    *pdwType = STGX_TYPE_ANY;
    
    SFGAOF flags = SFGAO_STORAGE | SFGAO_STREAM;
    if (SUCCEEDED(psi->GetAttributes(flags, &flags)) && (flags & (SFGAO_STORAGE | SFGAO_STREAM)))
        *pdwType = flags & SFGAO_STREAM ? STGX_TYPE_STREAM : STGX_TYPE_STORAGE;

    return S_OK;
}

HRESULT CShellItem2TransferDest::_OpenHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD *pdwType, REFIID riid, void **ppunk)
{
    *ppunk = NULL;

    IShellItem *psiTemp = NULL;
    HRESULT hr = SHCreateShellItemFromParent(_psi, pwcsName, &psiTemp);
    if (SUCCEEDED(hr))
    {
        // make sure this actually exists

        SFGAOF flags = SFGAO_VALIDATE;
        hr = psiTemp->GetAttributes(flags, &flags);
    }
    
    if (SUCCEEDED(hr))
    {
        DWORD dwTemp;
        if (!pdwType)
            pdwType = &dwTemp;
        
        _GetItemType(psiTemp, pdwType);

        hr = psiTemp->QueryInterface(riid, ppunk);
        if (FAILED(hr))
        {
            hr = _BindToHandlerWithMode(psiTemp, grfMode, riid, ppunk);
            if (FAILED(hr) && IsEqualIID(riid, IID_ITransferDest) && *pdwType == STGX_TYPE_STORAGE)
                hr = CreateStg2StgExWrapper(psiTemp, _pEngine, (ITransferDest**)ppunk);
        }
    }

    if (psiTemp)
        psiTemp->Release();
    
    return hr;
}

HRESULT CShellItem2TransferDest::_CreateHelper(const WCHAR *pwcsName, DWORD grfMode, DWORD dwType, REFIID riid, void **ppunk)
{ 
    *ppunk = NULL;

    IStorage *pstg;
    HRESULT hr = _BindToHandlerWithMode(_psi, grfMode, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        if (STGX_TYPE_STORAGE == dwType)
        {
            IStorage *pstgTemp;
            hr = pstg->CreateStorage(pwcsName, grfMode, 0, 0, &pstgTemp);
            if (SUCCEEDED(hr))
            {
                hr = pstgTemp->Commit(STGC_DEFAULT);
                if (SUCCEEDED(hr))
                {
                    hr = pstgTemp->QueryInterface(riid, ppunk);
                    ATOMICRELEASE(pstgTemp); //need to close first in case someone has exclusive lock.  Do we need to worry about delete on release?
                    if (FAILED(hr))
                        hr = _OpenHelper(pwcsName, grfMode, &dwType, riid, ppunk);
                }

                if (pstgTemp)
                    pstgTemp->Release();
            }
        }
        else if (STGX_TYPE_STREAM == dwType)
        {
            IStream *pstm;
            hr = pstg->CreateStream(pwcsName, grfMode, 0, 0, &pstm);
            if (SUCCEEDED(hr))
            {
                hr = pstm->Commit(STGC_DEFAULT);
                if (SUCCEEDED(hr))
                {
                    hr = pstm->QueryInterface(riid, ppunk);
                    ATOMICRELEASE(pstm); //need to close first in case someone has exclusive lock.  Do we need to worry about delete on release?
                    if (FAILED(hr))
                        hr = _OpenHelper(pwcsName, grfMode, &dwType, riid, ppunk);
                }

                if (pstm)
                    pstm->Release();
            }
        }
        pstg->Release();
    }

    return hr;
}

STDMETHODIMP CShellItem2TransferDest::OpenElement(const WCHAR *pwcsName, STGXMODE grfMode, DWORD *pdwType, REFIID riid, void **ppunk)
{
    if (!pwcsName || !pdwType || !ppunk)
        return E_INVALIDARG;

    if (!_psi)
        return E_FAIL;

    DWORD dwFlags = grfMode & ~(STGX_MODE_CREATIONMASK);
    return _OpenHelper(pwcsName, dwFlags, pdwType, riid, ppunk);
}

STDMETHODIMP CShellItem2TransferDest::CreateElement(const WCHAR *pwcsName, IShellItem *psiTemplate, STGXMODE grfMode, DWORD dwType, REFIID riid, void **ppunk)
{
    if (!ppunk)
        return E_INVALIDARG;

    *ppunk = NULL;
    
    if (!pwcsName)
        return E_INVALIDARG;

    if (!_psi)
        return E_FAIL;
    
    DWORD dwFlags = grfMode & ~(STGX_MODE_CREATIONMASK);
    DWORD dwExistingType = STGX_TYPE_ANY;
    IShellItem *psi;
    HRESULT hr = _OpenHelper(pwcsName, dwFlags, &dwExistingType, IID_PPV_ARG(IShellItem, &psi));
    
    if (grfMode & STGX_MODE_FAILIFTHERE)
        dwFlags |= STGM_FAILIFTHERE;
    else
        dwFlags |= STGM_CREATE;

    if (SUCCEEDED(hr))
    {
        if (grfMode & STGX_MODE_OPENEXISTING)
        {
            ATOMICRELEASE(psi);
            hr = _OpenHelper(pwcsName, dwFlags, &dwType, riid, ppunk);
            if (FAILED(hr))
                hr = STGX_E_INCORRECTTYPE;
        }
        else if (grfMode & STGX_MODE_FAILIFTHERE)
        {
            hr = STG_E_FILEALREADYEXISTS;
        }
        else
        {
            // release the open handle on the element
            ATOMICRELEASE(psi);
            // destroy the element
            DestroyElement(pwcsName, grfMode & STGX_MODE_FORCE ? STGX_DESTROY_FORCE : 0);
            // dont keep hr from destroyelement because in certain storages (mergedfolder
            // for cd burning) the destroy will try to delete the one on the cd, that'll
            // fail, but the create will still succeed in the staging area.  at this point
            // we're already committed to overwriting the element so if _CreateHelper can
            // succeed with the STGM_CREATE flag if destroy fails, then more power to it.
            hr = _CreateHelper(pwcsName, dwFlags, dwType, riid, ppunk);
        }

        if (psi)
            psi->Release();
    }
    else
    {
        hr = _CreateHelper(pwcsName, dwFlags, dwType, riid, ppunk);
    }

    return hr;
}

HRESULT CShellItem2TransferDest::_BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv)
{
    IBindCtx *pbc;
    HRESULT hr = BindCtx_CreateWithMode(grfMode, &pbc); // need to translate mode flags?
    if (SUCCEEDED(hr))
    {
        GUID bhid;

        if (IsEqualGUID(riid, IID_IStorage))
            bhid = BHID_Storage;
        else if (IsEqualGUID(riid, IID_IStream))
            bhid = BHID_Stream;
        else
            bhid = BHID_SFObject;
        
        hr = psi->BindToHandler(pbc, bhid, riid, ppv);
        pbc->Release();
    }

    return hr;
}

#define NT_FAILED(x) NT_ERROR(x)   // More consistent name for this macro

BOOL CShellItem2TransferDest::_HasMultipleStreams(IShellItem *psiItem)
{
    BOOL fReturn = FALSE;
    LPWSTR pszPath;
    if (SUCCEEDED(psiItem->GetDisplayName(SIGDN_FILESYSPATH, &pszPath)))
    {
        DWORD dwType;
        _GetItemType(psiItem, &dwType);

        BOOL fIsADir = (STGX_TYPE_STORAGE == dwType);

        // Covert the conventional paths to UnicodePath descriptors
        
        UNICODE_STRING UnicodeSrcObject;
        RtlInitUnicodeString(&UnicodeSrcObject, pszPath);
        if (RtlDosPathNameToNtPathName_U(pszPath, &UnicodeSrcObject, NULL, NULL))
        {
            // Build an NT object descriptor from the UnicodeSrcObject

            OBJECT_ATTRIBUTES SrcObjectAttributes;
            InitializeObjectAttributes(&SrcObjectAttributes,  &UnicodeSrcObject, OBJ_CASE_INSENSITIVE, NULL, NULL);

            // Open the file for generic read, and the dest path for attribute read

            IO_STATUS_BLOCK IoStatusBlock;
            HANDLE SrcObjectHandle = INVALID_HANDLE_VALUE;
            NTSTATUS NtStatus = NtOpenFile(&SrcObjectHandle, FILE_GENERIC_READ, &SrcObjectAttributes,
                                  &IoStatusBlock, FILE_SHARE_READ, (fIsADir ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE));
            if (NT_SUCCESS(NtStatus))
            {
                // pAttributeInfo will point to enough stack to hold the
                // FILE_FS_ATTRIBUTE_INFORMATION and worst-case filesystem name

                size_t cbAttributeInfo = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + MAX_PATH * sizeof(TCHAR);
                PFILE_FS_ATTRIBUTE_INFORMATION  pAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION) _alloca(cbAttributeInfo);

                NtStatus = NtQueryVolumeInformationFile(
                                SrcObjectHandle,
                                &IoStatusBlock,
                                (BYTE *) pAttributeInfo,
                                cbAttributeInfo,
                                FileFsAttributeInformation
                               );

                if (NT_SUCCESS(NtStatus))
                {
                    // If the source filesystem isn't NTFS, we can just bail now

                    pAttributeInfo->FileSystemName[ (pAttributeInfo->FileSystemNameLength / sizeof(WCHAR)) ] = L'\0';
                    if (0 != StrStrIW(pAttributeInfo->FileSystemName, L"NTFS"))
                    {
                        // Incrementally try allocation sizes for the ObjectStreamInformation,
                        // then retrieve the actual stream info

                        size_t cbBuffer = sizeof(FILE_STREAM_INFORMATION) + MAX_PATH * sizeof(WCHAR);
                        BYTE *pBuffer = (BYTE *) LocalAlloc(LPTR, cbBuffer);
                        if (pBuffer)
                        {
                            NtStatus = STATUS_BUFFER_OVERFLOW;
                    	    
                            while (STATUS_BUFFER_OVERFLOW == NtStatus)
                            {
                                BYTE * pOldBuffer = pBuffer;
                                pBuffer = (BYTE *) LocalReAlloc(pBuffer, cbBuffer, LMEM_MOVEABLE);
                                if (NULL == pBuffer)
                                {
                                    pBuffer = pOldBuffer;  //we will free it at the end of the function
                                    break;
                                }

                                NtStatus = NtQueryInformationFile(SrcObjectHandle, &IoStatusBlock, pBuffer, cbBuffer, FileStreamInformation);
                                cbBuffer *= 2;
                            }
                            
                            if (NT_SUCCESS(NtStatus))
                            {
                                FILE_STREAM_INFORMATION * pStreamInfo = (FILE_STREAM_INFORMATION *) pBuffer;
                                
                                if (fIsADir)
                                {
                                    // From experimentation, it seems that if there's only one stream on a directory and
                                    // it has a zero-length name, its a vanilla directory

                                    fReturn = ((0 != pStreamInfo->NextEntryOffset) && (0 == pStreamInfo->StreamNameLength));
                                }
                                else // File
                                {
                                    // Single stream only if first stream has no next offset

                                    fReturn = ((0 != pStreamInfo->NextEntryOffset) && (pBuffer == (BYTE *) pStreamInfo));
                                }
                            }
                            LocalFree(pBuffer);
                        }
                    }
                }

                NtClose(SrcObjectHandle);
            }
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        }
        CoTaskMemFree(pszPath);
    }
    
    return fReturn;
}

// needs to implement new name functionality
STDMETHODIMP CShellItem2TransferDest::MoveElement(IShellItem *psiItem, WCHAR *pwcsNewName, STGXMOVE grfOptions)
{
    if (!psiItem)
        return E_INVALIDARG;

    if (!_psi)
        return E_FAIL;

    HRESULT hr = STRESPONSE_CONTINUE;
    DWORD dwType;
    _GetItemType(psiItem, &dwType);

    if (_HasMultipleStreams(psiItem) && _ptas)
    {
        hr = _ptas->ConfirmOperation(psiItem, NULL, (STGX_TYPE_STORAGE == dwType) ? STCONFIRM_STREAM_LOSS_STORAGE : STCONFIRM_STREAM_LOSS_STREAM, NULL);
    }

    if (STRESPONSE_CONTINUE == hr)
    {
        LPWSTR pszOldName;
        hr = psiItem->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszOldName);
        if (SUCCEEDED(hr))
        {
            // we want to merge folders and replace files
            STGXMODE grfMode = STGX_TYPE_STORAGE == dwType ? STGX_MODE_WRITE | STGX_MODE_OPENEXISTING : STGX_MODE_WRITE | STGX_MODE_FAILIFTHERE;
            LPWSTR pszName = pwcsNewName ? pwcsNewName : pszOldName;
            BOOL fRepeat;
            do
            {
                fRepeat = FALSE;
                
                IShellItem *psiTarget;
                hr = CreateElement(pszName, psiItem, grfMode, dwType, IID_PPV_ARG(IShellItem, &psiTarget));
                if (SUCCEEDED(hr))
                {
                    if (STGX_TYPE_STORAGE == dwType)
                    {
                        if (!(grfOptions & STGX_MOVE_NORECURSION))
                        {
                            if (_pEngine)
                            {
                                IEnumShellItems *penum;
                                hr = psiItem->BindToHandler(NULL, BHID_StorageEnum, IID_PPV_ARG(IEnumShellItems, &penum));
                                if (SUCCEEDED(hr))
                                {
                                    STGOP stgop;
                                    if (grfOptions & STGX_MOVE_PREFERHARDLINK)
                                    {
                                        stgop = STGOP_COPY_PREFERHARDLINK;
                                    }
                                    else
                                    {
                                        stgop = (grfOptions & STGX_MOVE_COPY) ? STGOP_COPY : STGOP_MOVE;
                                    }
                                    hr = _pEngine->Run(penum, psiTarget, stgop, STOPT_NOSTATS);
                                    penum->Release();
                                }
                            }
                            else
                            {
                                hr = STGX_E_CANNOTRECURSE;
                            }
                        }
                    }
                    else if (STGX_TYPE_STREAM == dwType)
                    {
                        // this one is easy, create the destination stream and then call our stream copy helper function
                        // Use the stream copy helper that gives us progress
                        hr = _CopyStreamWithOptions(psiItem, psiTarget, pszName, grfOptions);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }

                if (SUCCEEDED(hr) && !(grfOptions & STGX_MOVE_COPY))
                {
                    // in order to do a move we "copy" and then "delete"
                    IShellItem *psiSource;
                    hr = psiItem->GetParent(&psiSource);
                    if (SUCCEEDED(hr))
                    {
                        IStorage *pstgSource;
                        hr = _BindToHandlerWithMode(psiSource, STGX_MODE_WRITE, IID_PPV_ARG(IStorage, &pstgSource));
                        if (SUCCEEDED(hr))
                        {
                            hr = pstgSource->DestroyElement(pszName);
                            pstgSource->Release();
                        }
                        psiSource->Release();
                    }
                }

                if (FAILED(hr) && _ptas)
                {
                    HRESULT hrConfirm = E_FAIL;
                    CUSTOMCONFIRMATION cc = {sizeof(cc)};
                    STGTRANSCONFIRMATION stc = GUID_NULL;
                    UINT idDesc = 0, idTitle = 0;
                    BOOL fConfirm = FALSE;
                    
                    switch (hr)
                    {
                    case STG_E_FILEALREADYEXISTS:
                        ASSERT(STGX_TYPE_STREAM == dwType);
                        hrConfirm = _OpenHelper(pszName, STGX_MODE_READ, NULL, IID_PPV_ARG(IShellItem, &psiTarget));
                        if (SUCCEEDED(hrConfirm))
                        {
                            hrConfirm = _ptas->ConfirmOperation(psiItem, psiTarget, STCONFIRM_REPLACE_STREAM, NULL);
                        }
                        break;

                    case STRESPONSE_CANCEL:
                        break;

                    case STG_E_MEDIUMFULL:
                        fConfirm = TRUE;
                        cc.dwButtons = CCB_OK;
                        idDesc = IDS_REASONS_NODISKSPACE;
                        break;

                    // this is just for CD burning case
                    case HRESULT_FROM_WIN32(E_ACCESSDENIED):
                    case STG_E_ACCESSDENIED:
                        stc = STCONFIRM_ACCESS_DENIED;
                        // fall through, so that we can have some kind of error in non CD case
                    default:
                        fConfirm = TRUE;
                        cc.dwFlags |= CCF_SHOW_SOURCE_INFO;
                        cc.dwButtons = CCB_RETRY_SKIP_CANCEL;
                        idTitle = (grfOptions & STGX_MOVE_COPY ? IDS_UNKNOWN_COPY_TITLE : IDS_UNKNOWN_MOVE_TITLE);
                        if (STGX_TYPE_STORAGE == dwType)
                        {
                            if (grfOptions & STGX_MOVE_COPY)
                            {
                                idDesc = IDS_UNKNOWN_COPY_FOLDER;
                            }
                            else
                            {
                                idDesc = IDS_UNKNOWN_MOVE_FOLDER;
                            }
                        }
                        else
                        {
                            if (grfOptions & STGX_MOVE_COPY)
                            {
                                idDesc = IDS_UNKNOWN_COPY_FILE;
                            }
                            else
                            {
                                idDesc = IDS_UNKNOWN_MOVE_FILE;
                            }
                        }
                        break;
                    }

                    if (fConfirm)
                    {
                        if (idTitle == 0)
                            idTitle = IDS_DEFAULTTITLE;
                            
                        ASSERT(idDesc != 0);
                        cc.pwszDescription = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idDesc);
                        if (cc.pwszDescription)
                        {
                            cc.pwszTitle = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idTitle);
                            if (cc.pwszTitle)
                            {
                                cc.dwFlags |= CCF_USE_DEFAULT_ICON;
                                hrConfirm = _ptas->ConfirmOperation(psiItem, psiTarget, stc, &cc);
                                LocalFree(cc.pwszTitle);
                            }
                            LocalFree(cc.pwszDescription);
                        }
                    }

                    switch (hrConfirm)
                    {
                    case STRESPONSE_CONTINUE:
                    case STRESPONSE_RETRY:
                        if (STRESPONSE_RETRY == hrConfirm || STG_E_FILEALREADYEXISTS == hr)
                        {
                            grfMode = STGX_MODE_WRITE | STGX_MODE_FORCE;
                            fRepeat = TRUE;
                        }
                        break;

                    case STRESPONSE_SKIP:
                        hr = S_FALSE;
                        break;

                    default:
                        // let hr propagate out of the function
                        break;
                    }
                }

                if (psiTarget)
                    psiTarget->Release();
            }
            while (fRepeat);

            CoTaskMemFree(pszOldName);
        }
    }

    return hr;
}

STDMETHODIMP CShellItem2TransferDest::DestroyElement(const WCHAR *pwcsName, STGXDESTROY grfOptions)
{
    if (!_psi)
        return E_FAIL;

    // TODO: Pre and post op, confirmations
    HRESULT hr = STRESPONSE_CONTINUE;
    
    if (!(grfOptions & STGX_DESTROY_FORCE) && _ptas)
    {
        DWORD dwType = STGX_TYPE_ANY;
        IShellItem *psi;
        hr = _OpenHelper(pwcsName, STGX_MODE_READ, &dwType, IID_PPV_ARG(IShellItem, &psi));
        if (SUCCEEDED(hr))
        {
            hr = _ptas->ConfirmOperation(psi, NULL,
                                      (STGX_TYPE_STORAGE == dwType) ? STCONFIRM_DELETE_STORAGE : STCONFIRM_DELETE_STREAM,
                                      NULL);
            psi->Release();
        }
    }

    if (STRESPONSE_CONTINUE == hr)
    {
        IStorage *pstg;
        hr = _BindToHandlerWithMode(_psi, STGX_MODE_WRITE, IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            hr = pstg->DestroyElement(pwcsName);
            pstg->Release();
        }
    }

    return hr;
}

STDMETHODIMP CShellItem2TransferDest::RenameElement(const WCHAR *pwcsOldName, const WCHAR *pwcsNewName)
{
    if (!_psi)
        return E_FAIL;

    // TODO: Pre and post op, confirmations
    IStorage *pstg;
    HRESULT hr = _BindToHandlerWithMode(_psi, STGX_MODE_WRITE, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        hr = pstg->RenameElement(pwcsOldName, pwcsNewName);
        pstg->Release();
    }

    return hr;
}

STDAPI_(BOOL) IsFileDeletable(LPCTSTR pszFile); // bitbuck.c

BOOL CShellItem2TransferDest::_CanHardLink(LPCWSTR pszSourceName, LPCWSTR pszDestName)
{
    // this is not intended to catch invalid situations where we could be hard linking --
    // CreateHardLink already takes care of all removable media, non-NTFS, etc.
    // this is just to do a quick check before taking the cost of destroying and
    // recreating the file.
    // unfortunately due to architecture cleanliness we can't keep state of whether hard
    // links are possible for the whole copy, so we check on each element.
    BOOL fRet = FALSE;
    if (PathGetDriveNumber(pszSourceName) == PathGetDriveNumber(pszDestName))
    {
        TCHAR szRoot[MAX_PATH];
        lstrcpyn(szRoot, pszSourceName, ARRAYSIZE(szRoot));
        TCHAR szFileSystem[20];
        if (PathStripToRoot(szRoot) &&
            GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, NULL, szFileSystem, ARRAYSIZE(szFileSystem)))
        {
            if (lstrcmpi(szFileSystem, TEXT("NTFS")) == 0)
            {
                // check if we have delete access on the file.  this will aid the user later
                // if they want to manage the files in the staging area for cd burning.
                // if not, then make a normal copy.
                if (IsFileDeletable(pszSourceName))
                {
                    fRet = TRUE;
                }
            }
        }
    }
    return fRet;
}

HRESULT CShellItem2TransferDest::_CopyStreamHardLink(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName)
{
    // sell out and go to filesystem
    LPWSTR pszSourceName;
    HRESULT hr = psiSource->GetDisplayName(SIGDN_FILESYSPATH, &pszSourceName);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszDestName;
        hr = psiDest->GetDisplayName(SIGDN_FILESYSPATH, &pszDestName);
        if (SUCCEEDED(hr))
        {
            if (_CanHardLink(pszSourceName, pszDestName))
            {
                // need to destroy the 0-byte file we created during our confirm overwrite probing
                DestroyElement(pszName, STGX_DESTROY_FORCE);        
                hr = CreateHardLink(pszDestName, pszSourceName, NULL) ? S_OK : E_FAIL;
                if (SUCCEEDED(hr))
                {
                    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszDestName, NULL);
                    _ptas->OperationProgress(STGOP_COPY, psiSource, psiDest, 1, 1);
                }
                else
                {
                    // we deleted it above and need to recreate it for the fallback of doing a normal copy
                    IUnknown *punkDummy;
                    if (SUCCEEDED(_CreateHelper(pszName, STGX_MODE_WRITE | STGX_MODE_FORCE, STGX_TYPE_STREAM, IID_PPV_ARG(IUnknown, &punkDummy))))
                    {
                        punkDummy->Release();
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
            CoTaskMemFree(pszDestName);
        }
        CoTaskMemFree(pszSourceName);
    }
    return hr;
}

HRESULT CShellItem2TransferDest::_CopyStreamWithOptions(IShellItem *psiSource, IShellItem *psiDest, LPCWSTR pszName, STGXMOVE grfOptions)
{
    HRESULT hr = E_FAIL;
    if (grfOptions & STGX_MOVE_PREFERHARDLINK)
    {
        hr = _CopyStreamHardLink(psiSource, psiDest, pszName);
    }

    if (FAILED(hr))
    {
        hr = _CopyStreamBits(psiSource, psiDest);
    }
    return hr;
}

HRESULT CShellItem2TransferDest::_CopyStreamBits(IShellItem *psiSource, IShellItem *psiDest)
{
    const ULONG maxbuf  = 1024*1024;    // max size we will ever use for a buffer
    const ULONG minbuf  = 1024;         // smallest buffer we will use

    void *pv = LocalAlloc(LPTR, minbuf);
    if (!pv)
        return E_OUTOFMEMORY;

    IStream *pstrmSource;
    HRESULT hr = _BindToHandlerWithMode(psiSource, STGM_READ | STGM_SHARE_DENY_WRITE, IID_PPV_ARG(IStream, &pstrmSource));
    if (SUCCEEDED(hr))
    {
        IStream *pstrmDest;
        hr = _BindToHandlerWithMode(psiDest, STGM_READWRITE, IID_PPV_ARG(IStream, &pstrmDest));
        if (SUCCEEDED(hr))
        {
            // we need the source size info so we can show progress
            STATSTG statsrc;
            hr = pstrmSource->Stat(&statsrc, STATFLAG_NONAME);
            if (SUCCEEDED(hr))
            {
                ULONG cbSizeToAlloc = minbuf;
                ULONG cbSizeAlloced = 0;
                ULONG cbToRead      = 0;
                ULONGLONG ullCurr   = 0;
                const ULONG maxms   = 2500;         // max time, in ms, we'd like between progress updates
                const ULONG minms   = 750;          // min time we'd like to be doing work between updates


                cbSizeAlloced       = cbSizeToAlloc;
                cbToRead            = cbSizeAlloced;
                DWORD dwmsBefore    = GetTickCount();

                // Read from source, write to dest, and update progress.  We start doing 1K at a time, and
                // so long as its taking us less than (minms) milliseconds per pass, we'll double the buffer
                // size.  If we go longer than (maxms) milliseconds, we'll cut our work in half.

                ULONG cbRead;
                ULONGLONG ullCur = 0;
                while (SUCCEEDED(hr = pstrmSource->Read(pv, cbToRead, &cbRead)) && cbRead)
                {
                    // Update the progress based on the bytes read so far

                    ullCur += cbRead;
                    hr = _ptas->OperationProgress(STGOP_COPY, psiSource, psiDest, statsrc.cbSize.QuadPart, ullCur);
                    if (FAILED(hr))
                        break;

                    // Write the bytes to the output stream

                    ULONG cbWritten = 0;
                    hr = pstrmDest->Write(pv, cbRead, &cbWritten);
                    if (FAILED(hr))
                        break;

                    DWORD dwmsAfter = GetTickCount();

                    // If we're going to fast or too slow, adjust the size of the buffer.  If we paused for user
                    // intervention we'll think we're slow, but we'll correct next pass

                    if (dwmsAfter - dwmsBefore < minms && cbSizeAlloced < maxbuf)
                    {
                        // We completed really quickly, so we should try to do more work next time.
                        // Try to grow the buffer.  If it fails, just go with the existing buffer.

                        if (cbToRead < cbSizeAlloced)
                        {
                            // Buffer already larger than work we're doing, so just bump up scheduled work

                            cbToRead = __min(cbToRead *2, cbSizeAlloced);
                        }
                        else
                        {
                            // Buffer maxed by current scheduled work, so increase its size

                            void *pvOld = pv;
                            cbSizeToAlloc = __min(cbSizeAlloced *2, maxbuf);
                            pv = LocalReAlloc((HLOCAL)pv, cbSizeToAlloc, LPTR);
                            if (!pv)
                                pv = pvOld; // Old pointer still valid
                            else
                                cbSizeAlloced = cbSizeToAlloc;
                            cbToRead = cbSizeAlloced;
                        }
                    }
                    else if (dwmsAfter - dwmsBefore > maxms && cbToRead > minbuf)
                    {   
                        cbToRead = __max(cbToRead / 2, minbuf);
                    }

                    dwmsBefore = GetTickCount();
                }
            }

            if (SUCCEEDED(hr))
                hr = pstrmDest->Commit(STGC_DEFAULT);
            
            pstrmDest->Release();
        }    
        pstrmSource->Release();
    }
    LocalFree(pv);
    
    // eventually we will read to the end of the file and get an S_FALSE, return S_OK
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\stgfldr.cpp ===
#include "shellprv.h"
#include <caggunk.h>
#include "ids.h"
#include "datautil.h"
#include "idlcomm.h"
#include "idldata.h"
#include "views.h"
#include "stgutil.h"
#pragma hdrstop

typedef struct
{
    WORD wSize;
    DWORD dwMagic;
    DWORD dwType;
    ULARGE_INTEGER cbFileSize;
    union 
    {
        FILETIME ftModified;
        ULARGE_INTEGER ulModified;
    };
    WCHAR szName[MAX_PATH];
    WORD wZero;
} STGITEM;

typedef UNALIGNED STGITEM * LPSTGITEM;
typedef const UNALIGNED STGITEM * LPCSTGITEM;

// this sets stgfldr pidls apart from others
#define STGITEM_MAGIC 0x08311978


static const struct
{
    UINT iTitle;
    UINT cchCol;
    UINT iFmt;
} 
g_aStgColumns[] = 
{
    {IDS_NAME_COL,     20, LVCFMT_LEFT},
    {IDS_SIZE_COL,     10, LVCFMT_RIGHT},
    {IDS_TYPE_COL,     20, LVCFMT_LEFT},
    {IDS_MODIFIED_COL, 20, LVCFMT_LEFT},
};

enum
{
    STG_COL_NAME,
    STG_COL_SIZE,
    STG_COL_TYPE,
    STG_COL_MODIFIED,
};


// folder object

class CStgFolder;
class CStgEnum;
class CStgDropTarget;

STDAPI CStgEnum_CreateInstance(CStgFolder *pstgf, DWORD grfFlags, IEnumIDList **ppenum);
STDAPI CStgDropTarget_CreateInstance(CStgFolder *pstgf, HWND hwnd, IDropTarget **ppdt);
STDAPI CStgFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);


class CStgFolder : public CAggregatedUnknown, IShellFolder2, IPersistFolder3, IShellFolderViewCB, IStorage, IPersistStorage
{
public:
    CStgFolder(IUnknown *punkAgg, CStgFolder *pstgfParent);
    ~CStgFolder();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return CAggregatedUnknown::QueryInterface(riid,ppv);};
    STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID)
            { *pClassID = CLSID_StgFolder; return S_OK; }
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IPersistFolder3
    STDMETHODIMP GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *ppfti)
            { return E_NOTIMPL; }
    STDMETHODIMP InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
            { return CStgEnum_CreateInstance(this, grfFlags, ppenumIDList); };
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
            { return BindToObject(pidl, pbc, riid, ppv); };
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid)
            { return E_NOTIMPL; };
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum)
            { return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
            { return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState)
            { return E_NOTIMPL; }
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
            { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
            { return E_NOTIMPL; };

    // IShellFolderViewCB
    STDMETHODIMP MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IStorage
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP SetClass(REFCLSID clsid);
    STDMETHODIMP SetStateBits(DWORD grfStateBits, DWORD grfMask);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum);
    STDMETHODIMP OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);
    STDMETHODIMP OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg);
    STDMETHODIMP DestroyElement(LPCWSTR pszRel);
    STDMETHODIMP RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName);
    STDMETHODIMP SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime);
    STDMETHODIMP CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest);
    STDMETHODIMP MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags);
    STDMETHODIMP CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm);
    STDMETHODIMP CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg);

    // IPersistStorage
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP InitNew(IStorage *pStg);
    STDMETHODIMP Load(IStorage *pStg);
    STDMETHODIMP Save(IStorage *pStgSave, BOOL fSameAsLoad);
    STDMETHODIMP SaveCompleted(IStorage *pStgNew);
    STDMETHODIMP HandsOffStorage(void);

private:
    LONG _cRef;             
    CStgFolder *_pstgfParent;
    IStorage *_pstg;
    IStorage *_pstgLoad;
    LPITEMIDLIST _pidl;
    DWORD _dwMode;

    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppv);

    HRESULT _BindToStorageObject(LPCITEMIDLIST pidl, DWORD grfMode, IStorage **ppstg);
    BOOL _OkayWithCurrentMode(DWORD grfMode);
    HRESULT _EnsureStorage(DWORD grfMode);
    void _CloseStorage();
    HRESULT _InitNewStgFolder(CStgFolder *pstgf, DWORD grfMode, LPCITEMIDLIST pidlNew);
    HRESULT _AllocIDList(STATSTG stat, LPITEMIDLIST *ppidl, BOOL *pfFolder);
    HRESULT _AllocIDList(LPCTSTR pszName, LPITEMIDLIST *ppidl, BOOL *pfFolder);
    HRESULT _SetShortcutStorage(IStorage *pstgLink);
    HRESULT _GetTypeOf(LPCSTGITEM pistg, LPTSTR pszBuffer, INT cchBuffer);
    ULONG _GetAttributesOf(LPCSTGITEM pistg, ULONG rgfIn);
    BOOL _ShowExtension();
    static HRESULT CALLBACK _ItemsMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // folder view callback handlers
    HRESULT _OnBackgroundEnum(DWORD pv)
            { return S_OK; };
    HRESULT _OnGetNotify(DWORD pv, LPITEMIDLIST *ppidl, LONG *plEvents);

    LPCSTGITEM _IsStgItem(LPCITEMIDLIST pidl);
    DWORD _IsFolder(LPCSTGITEM psitem);

    friend CStgEnum;
    friend CStgDropTarget;
    friend HRESULT CStgFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
};


// Construction and IUnknown for folder root

CStgFolder::CStgFolder(IUnknown *punkAgg, CStgFolder *pstgfParent) : CAggregatedUnknown(punkAgg),
    _dwMode(STGM_READ), _cRef(1)
{
    ASSERT(NULL == _pidl);
    ASSERT(NULL == _pstg);
    ASSERT(NULL == _pstgLoad);

    _pstgfParent = pstgfParent;
    if (_pstgfParent)
        _pstgfParent->AddRef();

    DllAddRef();
}

CStgFolder::~CStgFolder()
{
    ILFree(_pidl);

    if (_pstg)
        _pstg->Commit(STGC_DEFAULT);

    ATOMICRELEASE(_pstg);
    ATOMICRELEASE(_pstgfParent);
    ATOMICRELEASE(_pstgLoad);

    DllRelease();
}

HRESULT CStgFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENTMULTI(CStgFolder, IShellFolder,      IShellFolder2),    // IID_IShellFolder
        QITABENT     (CStgFolder, IShellFolder2),                       // IID_IShellFolder2
        QITABENTMULTI(CStgFolder, IPersist,          IPersistFolder3),  // IID_IPersist
        QITABENTMULTI(CStgFolder, IPersistFolder,    IPersistFolder3),  // IID_IPersistFolder
        QITABENTMULTI(CStgFolder, IPersistFolder2,   IPersistFolder3),  // IID_IPersistFolder2
        QITABENT     (CStgFolder, IPersistStorage),                     // IID_IPersistStorage
        QITABENT     (CStgFolder, IPersistFolder3),                     // IID_IPersistFolder3
        QITABENT     (CStgFolder, IShellFolderViewCB),                  // IID_IShellFolderViewCB
        QITABENT     (CStgFolder, IStorage),                            // IID_IStorage
        { 0 },
    };
    
    if (IsEqualIID(CLSID_StgFolder, riid))
    {
        *ppv = this;                    // not ref counted
        return S_OK;
    }
    return QISearch(this, qit, riid, ppv);
}


STDAPI CStgFolder_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    CStgFolder *pstgf = new CStgFolder(punkOuter, NULL);
    if (!pstgf)
        return E_OUTOFMEMORY;

    HRESULT hr = pstgf->_GetInner()->QueryInterface(riid, ppv);
    pstgf->_GetInner()->Release();
    return hr;
}


LPCSTGITEM CStgFolder::_IsStgItem(LPCITEMIDLIST pidl)
{
    if (pidl && ((LPCSTGITEM) pidl)->dwMagic == STGITEM_MAGIC)
        return (LPCSTGITEM)pidl;
    return NULL;
}

// BOOL, but returns FILE_ATTRIBUTE_DIRECTORY for convience

DWORD CStgFolder::_IsFolder(LPCSTGITEM pistg)
{
    return pistg->dwType == STGTY_STORAGE ? FILE_ATTRIBUTE_DIRECTORY : 0;
}

// Creates an item identifier list for the objects in the namespace

HRESULT CStgFolder::_AllocIDList(STATSTG stat, LPITEMIDLIST *ppidl, BOOL *pfFolder)
{
    // Note the terminating NULL is already in the sizeof(STGITEM)
    STGITEM sitem = {0};
    UINT uNameLen = lstrlen(stat.pwcsName);

    if (uNameLen >= MAX_PATH)
    {
        return E_INVALIDARG;
    }
    
    sitem.wSize = (WORD)(FIELD_OFFSET(STGITEM, szName[uNameLen + 1]));
    sitem.dwMagic = STGITEM_MAGIC;
    sitem.dwType = stat.type;
    sitem.cbFileSize = stat.cbSize;
    sitem.ftModified = stat.mtime;
    lstrcpyn(sitem.szName, stat.pwcsName, uNameLen + 1);

    if (pfFolder)
    {
        *pfFolder = _IsFolder(&sitem);
    }
        
    return SHILClone((LPCITEMIDLIST)&sitem, ppidl);
}

HRESULT CStgFolder::_AllocIDList(LPCTSTR pszName, LPITEMIDLIST *ppidl, BOOL *pfFolder)
{
    // given a name, look it up in the current storage object we have and
    // compute the STATSTG which we can then build an IDLIST from.

    DWORD grfMode = STGM_READ;
    HRESULT hr = _EnsureStorage(grfMode);
    if (SUCCEEDED(hr))
    {
        STATSTG stat;

        // is it a stream or a storage? 

        IStream *pstrm;
        hr = _pstg->OpenStream(pszName, NULL, grfMode, 0, &pstrm);
        if (SUCCEEDED(hr))
        {
            hr = pstrm->Stat(&stat, STATFLAG_DEFAULT);
            pstrm->Release();
        }
        else
        {
            IStorage *pstg;
            hr = _pstg->OpenStorage(pszName, NULL, grfMode, NULL, 0, &pstg);
            if (SUCCEEDED(hr))
            {
                hr = pstg->Stat(&stat, STATFLAG_DEFAULT);
                pstg->Release();
            }
        }

        // if that worked then lets allocate the object, 
        // nb: release the name returned in the STATSTG

        if (SUCCEEDED(hr))
        {
            hr = _AllocIDList(stat, ppidl, pfFolder);
            CoTaskMemFree(stat.pwcsName);
        }
    }
    return hr;
}


void CStgFolder::_CloseStorage()
{
    if (_pstg)
    {
        _pstg->Commit(STGC_DEFAULT);
        ATOMICRELEASE(_pstg);
    }
}


HRESULT CStgFolder::_BindToStorageObject(LPCITEMIDLIST pidl, DWORD grfMode, IStorage **ppstg)
{
    IBindCtx *pbc;
    HRESULT hr = SHCreateSkipBindCtx(NULL, &pbc); // NULL to mean we skip all CLSIDs
    if (SUCCEEDED(hr))
    {
        BIND_OPTS bo = {sizeof(bo)};
        hr = pbc->GetBindOptions(&bo);
        if (SUCCEEDED(hr))
        {
            bo.grfMode = grfMode;
            hr = pbc->SetBindOptions(&bo);
            if (SUCCEEDED(hr))
            {
                hr = SHBindToObjectEx(NULL, pidl, pbc, IID_PPV_ARG(IStorage, ppstg));
            }
        }
        pbc->Release();
    }
    return hr;
}


HRESULT CStgFolder::_SetShortcutStorage(IStorage *pstgLink)
{
#if 1
    return CShortcutStorage_CreateInstance(pstgLink, IID_PPV_ARG(IStorage, &_pstg));
#else
    IUnknown_Set((IUnknown **)&_pstg, (IUnknown *)pstgLink);
    return S_OK;
#endif
}


BOOL CStgFolder::_OkayWithCurrentMode(DWORD grfMode)
{
    DWORD dwNewBits = grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE);
    DWORD dwOldBits = _dwMode & (STGM_READ | STGM_WRITE | STGM_READWRITE);
    return (dwOldBits == STGM_READWRITE) || (dwOldBits == dwNewBits);
}


HRESULT CStgFolder::_EnsureStorage(DWORD grfMode)
{
    // if we have a storage and its mode encompasses the grfMode we need then we
    // can skip the whole thing.

    HRESULT hr = S_OK;
    if (!_pstg || !_OkayWithCurrentMode(grfMode))
    {
        _dwMode = grfMode;

        _CloseStorage();

        if (_pstgfParent)
        {
            hr = _pstgfParent->_EnsureStorage(grfMode);

            if (SUCCEEDED(hr))
            {
                LPCWSTR pwszName;
                LPCSTGITEM pit = _IsStgItem(ILFindLastID(_pidl));
                WSTR_ALIGNED_STACK_COPY(&pwszName, pit->szName);

                hr = _pstgfParent->_pstg->OpenStorage(pwszName, NULL, grfMode, NULL, 0, &_pstg);
            }
        }
        else if (_pstgLoad)
        {
            hr = _pstgLoad->QueryInterface(IID_PPV_ARG(IStorage, &_pstg));
        }
        else
        {
            IStorage *pstgLink;
            hr = _BindToStorageObject(_pidl, grfMode, &pstgLink);
            if (hr == STG_E_FILENOTFOUND)
                hr = _BindToStorageObject(_pidl, grfMode | STGM_CREATE, &pstgLink);

            if (SUCCEEDED(hr))
            {
                hr = _SetShortcutStorage(pstgLink);
                pstgLink->Release();
            }
        }
    }
    return hr;
}


BOOL CStgFolder::_ShowExtension()
{
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
    return ss.fShowExtensions;
}

HRESULT CStgFolder::_GetTypeOf(LPCSTGITEM pistg, LPTSTR pszBuffer, INT cchBuffer)
{
    *pszBuffer = TEXT('\0');                // null out the return buffer

    LPCWSTR pwszName;
    WSTR_ALIGNED_STACK_COPY(&pwszName, pistg->szName);

    LPTSTR pszExt = PathFindExtension(pwszName);
    if (pszExt)
    {
        StrCpyN(pszBuffer, pszExt, cchBuffer);
    }

    return S_OK;
}

CStgFolder* _GetStgFolder(IShellFolder *psf)
{
    CStgFolder *pstgf;
    return SUCCEEDED(psf->QueryInterface(CLSID_StgFolder, (void**)&pstgf)) ? pstgf : NULL;
}

// IPersist / IPersistFolder etc

STDMETHODIMP CStgFolder::Initialize(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    return SHILClone(pidl, &_pidl); 
}

HRESULT CStgFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);

    *ppidl = NULL;
    return S_FALSE;
}


HRESULT CStgFolder::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti)
{
    ASSERTMSG(_pstg == NULL, "shouldn't initialize again if we already have a storage");

    HRESULT hr = Initialize(pidlRoot);
    if (SUCCEEDED(hr) && pbc)
    {
        // we don't care if these don't succeed so don't propagate the hr here
        BIND_OPTS bo = {sizeof(bo)};
        if (SUCCEEDED(pbc->GetBindOptions(&bo)))
        {
            _dwMode = bo.grfMode;
        }

        IUnknown *punk;
        if (SUCCEEDED(pbc->GetObjectParam(STGSTR_STGTOBIND, &punk)))
        {
            IStorage *pstgLink;
            hr = punk->QueryInterface(IID_PPV_ARG(IStorage, &pstgLink));
            if (SUCCEEDED(hr))
            {
                hr = _SetShortcutStorage(pstgLink);
                if (SUCCEEDED(hr))
                {
                    STATSTG stat;
                    hr = _pstg->Stat(&stat, STATFLAG_NONAME);
                    if (SUCCEEDED(hr))
                    {
                        // we want to know what mode we're opened in, so we will only
                        // have to re-open if necessary
                        _dwMode = stat.grfMode;
                    }
                }
                pstgLink->Release();
            }
            punk->Release();
        }
    }

    return hr;
}


// IShellFolder(2)

HRESULT CStgFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr;

    if (!ppidl)
        return E_INVALIDARG;
    *ppidl = NULL;
    if (!pszName)
        return E_INVALIDARG;

    TCHAR szName[MAX_PATH];
    hr = _NextSegment((LPCWSTR*)&pszName, szName, ARRAYSIZE(szName), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = _AllocIDList(szName, ppidl, NULL);
        if (SUCCEEDED(hr) && pszName)
        {
            IShellFolder *psf;
            hr = BindToObject(*ppidl, pbc, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                ULONG chEaten;
                LPITEMIDLIST pidlNext;
                hr = psf->ParseDisplayName(hwnd, pbc, pszName, &chEaten, &pidlNext, pdwAttributes);
                if (SUCCEEDED(hr))
                    hr = SHILAppend(pidlNext, ppidl);
                psf->Release();
            }
        }
        else if (SUCCEEDED(hr) && pdwAttributes && *pdwAttributes)
        {
            GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
        }
    }

    // clean up if the parse failed.

    if (FAILED(hr))
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    return hr;
}


HRESULT CStgFolder::_InitNewStgFolder(CStgFolder *pstgf, DWORD grfMode, LPCITEMIDLIST pidlNew)
{
    HRESULT hr = pstgf->Initialize(pidlNew);
    if (SUCCEEDED(hr))
    {
        pstgf->_dwMode = grfMode;
    }
    return hr;
}



HRESULT CStgFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPCSTGITEM pistg = _IsStgItem(pidl);
    if (!pistg)
        return E_FAIL;

    DWORD grfMode = BindCtx_GetMode(pbc, STGM_READ);
    HRESULT hr;
    if (IsEqualIID(riid, IID_IStream))
    {       
        // they are requesting a stream on the current
        // item, therefore lets return it to them.

        hr = _EnsureStorage(grfMode);        
        if (SUCCEEDED(hr))
        {
            LPCWSTR pwszName;
            WSTR_ALIGNED_STACK_COPY(&pwszName, pistg->szName);

            IStream *pstrm;
            hr = _pstg->OpenStream(pwszName, NULL, grfMode, 0, &pstrm);
            if (SUCCEEDED(hr))
            {
                hr = pstrm->QueryInterface(riid, ppv);
                pstrm->Release();
            }
        }
    }
    else
    {
        // its not an IStream request, so lets bind to the shell folder
        // and get the interface that the caller requested.

        LPCITEMIDLIST pidlNext = _ILNext(pidl);
        LPITEMIDLIST pidlSubFolder = ILCombineParentAndFirst(_pidl, pidl, pidlNext);
        if (pidlSubFolder)
        {
            CStgFolder *pstgf = new CStgFolder(NULL, this);
            if (pstgf)
            {
                hr = _InitNewStgFolder(pstgf, grfMode, pidlSubFolder);
                if (SUCCEEDED(hr))
                {
                    // if there's nothing left in the pidl, get the interface on this one.
                    if (ILIsEmpty(pidlNext))
                        hr = pstgf->QueryInterface(riid, ppv);
                    else
                    {
                        // otherwise, hand the rest of it off to the new shellfolder.
                        hr = pstgf->BindToObject(pidlNext, pbc, riid, ppv);
                    }
                }
                pstgf->Release();
            }
            else
                hr = E_OUTOFMEMORY;

            ILFree(pidlSubFolder);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && (NULL == *ppv)));   // Assert hr is consistent w/out param.
    return hr;
}


HRESULT CStgFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCSTGITEM pistg1 = _IsStgItem(pidl1);
    LPCSTGITEM pistg2 = _IsStgItem(pidl2);
    INT nCmp = 0;

    if (!pistg1 || !pistg2)
        return E_INVALIDARG;

    // folders always sort to the top of the list, if either of these items
    // are folders then compare on the folderness
    
    if (_IsFolder(pistg1) || _IsFolder(pistg2))
    {
        if (_IsFolder(pistg1) && !_IsFolder(pistg2))
            nCmp = -1;
        else if (!_IsFolder(pistg1) && _IsFolder(pistg2))
            nCmp = 1;
    }

    // if they match (or are not folders, then lets compare based on the column ID.

    if (nCmp == 0)
    {
        switch (lParam & SHCIDS_COLUMNMASK)
        {
            case STG_COL_NAME:          // caught later on
                break;

            case STG_COL_SIZE:
            {
                if (pistg1->cbFileSize.QuadPart < pistg2->cbFileSize.QuadPart)
                    nCmp = -1;
                else if (pistg1->cbFileSize.QuadPart > pistg2->cbFileSize.QuadPart)
                    nCmp = 1;
                break;
            }

            case STG_COL_TYPE:
            {
                TCHAR szType1[MAX_PATH], szType2[MAX_PATH];
                _GetTypeOf(pistg1, szType1, ARRAYSIZE(szType1));
                _GetTypeOf(pistg2, szType2, ARRAYSIZE(szType2));
                nCmp = StrCmpI(szType1, szType2);
                break;
            }

            case STG_COL_MODIFIED:
            {
                if (pistg1->ulModified.QuadPart < pistg2->ulModified.QuadPart)
                    nCmp = -1;
                else if (pistg1->ulModified.QuadPart > pistg2->ulModified.QuadPart)
                    nCmp = 1;
                break;
            }
        }

        if (nCmp == 0)
        {
            nCmp = ualstrcmpi(pistg1->szName, pistg2->szName);
        }
    }
    
    return ResultFromShort(nCmp);
}


HRESULT CStgFolder::_OnGetNotify(DWORD pv, LPITEMIDLIST *ppidl, LONG *plEvents)
{
    *ppidl = _pidl;
    *plEvents = SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER | \
                SHCNE_CREATE | SHCNE_DELETE | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | \
                SHCNE_MKDIR | SHCNE_RMDIR;
    return S_OK;
}


STDMETHODIMP CStgFolder::MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    switch (uMsg)
    {
        HANDLE_MSG(0, SFVM_BACKGROUNDENUM, _OnBackgroundEnum);
        HANDLE_MSG(0, SFVM_GETNOTIFY, _OnGetNotify);
    }
    return hr;
}

HRESULT CStgFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV = { 0 };
        sSFV.cbSize = sizeof(sSFV);
        sSFV.psfvcb = this;
        sSFV.pshf = this;
        hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        HKEY hkNoFiles = NULL;
        
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory\\Background"), &hkNoFiles);

        hr = CDefFolderMenu_Create2(_pidl, hwnd,
                                    0, NULL,
                                    this, NULL,
                                    1, &hkNoFiles, 
                                    (IContextMenu **)ppv);
        if (hkNoFiles)
            RegCloseKey(hkNoFiles);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = CStgDropTarget_CreateInstance(this, hwnd, (IDropTarget **)ppv);
    }

    return hr;
}


ULONG CStgFolder::_GetAttributesOf(LPCSTGITEM pistg, ULONG rgfIn)
{
    ULONG dwResult = rgfIn & (SFGAO_CANCOPY | SFGAO_CANDELETE | 
                              SFGAO_CANLINK | SFGAO_CANMOVE |
                              SFGAO_CANRENAME | SFGAO_HASPROPSHEET | 
                              SFGAO_DROPTARGET);

    // if the items is a folder then lets check to see if it has sub folders etc...

    if (pistg && _IsFolder(pistg) && (rgfIn & (SFGAO_FOLDER | SFGAO_HASSUBFOLDER)))
    {
        dwResult |= rgfIn & SFGAO_FOLDER;
        if (rgfIn & SFGAO_HASSUBFOLDER)
        {
            IShellFolder *psf = NULL;
            if (SUCCEEDED(BindToObject((LPITEMIDLIST)pistg, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                IEnumIDList * pei;
                if (S_OK == psf->EnumObjects(NULL, SHCONTF_FOLDERS, &pei))
                {
                    LPITEMIDLIST pidl;
                    if (S_OK == pei->Next(1, &pidl, NULL))
                    {
                        dwResult |= rgfIn & SFGAO_HASSUBFOLDER;
                        ILFree(pidl);
                    }
                    pei->Release();
                }
                psf->Release();
            }
        }
    }

    return dwResult;
}

HRESULT CStgFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    UINT rgfOut = *prgfInOut;

    // return attributes of the namespace root?

    if ( !cidl || !apidl )
    {
        rgfOut &= SFGAO_FOLDER | SFGAO_FILESYSTEM | 
                  SFGAO_LINK | SFGAO_DROPTARGET |
                  SFGAO_CANRENAME | SFGAO_CANDELETE |
                  SFGAO_CANLINK | SFGAO_CANCOPY | 
                  SFGAO_CANMOVE | SFGAO_HASSUBFOLDER;
    }
    else
    {
        for (UINT i = 0; i < cidl; i++)
            rgfOut &= _GetAttributesOf(_IsStgItem(apidl[i]), *prgfInOut);
    }

    *prgfInOut = rgfOut;
    return S_OK;
}


HRESULT CALLBACK CStgFolder::_ItemsMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU:
        break;

    case DFM_INVOKECOMMANDEX:
    {
        DFMICS *pdfmics = (DFMICS *)lParam;
        switch (wParam)
        {
        case DFM_CMD_DELETE:
            hr = StgDeleteUsingDataObject(hwnd, pdfmics->fMask, pdtobj);
            break;

        case DFM_CMD_PROPERTIES:
            break;

        default:
            // This is common menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;
    }

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

HRESULT CStgFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, 
                                  REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCSTGITEM pistg = cidl ? _IsStgItem(apidl[0]) : NULL;

    if (pistg &&
        (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)))
    {
        LPCWSTR pwszName;
        WSTR_ALIGNED_STACK_COPY(&pwszName, pistg->szName);

        hr = SHCreateFileExtractIconW(pwszName, _IsFolder(pistg), riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IDataObject) && cidl)
    {
        hr = CIDLData_CreateInstance(_pidl, cidl, apidl, NULL, (IDataObject **)ppv);
    }
#if 0    
    else if (IsEqualIID(riid, IID_IContextMenu) && pistg)
    {
        // get the association for these files and lets attempt to 
        // build the context menu for the selection.   

        IQueryAssociations *pqa;
        hr = GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pistg, IID_PPV_ARG_NULL(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            HKEY ahk[3];
            // this is broken for docfiles (shell\ext\stgfldr's keys work though)
            // maybe because GetClassFile punts when it's not fs?
            DWORD cKeys = SHGetAssocKeys(pqa, ahk, ARRAYSIZE(ahk));
            hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, 
                                        this, _ItemsMenuCB, cKeys, ahk, 
                                        (IContextMenu **)ppv);
            
            SHRegCloseKeys(ahk, cKeys);
            pqa->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations) && pistg)
    {
        //  need to create a valid Assoc obj here
    }
#endif    
    else if (IsEqualIID(riid, IID_IDropTarget) && pistg)
    {
        // If a directory is selected in the view, the drop is going to a folder,
        // so we need to bind to that folder and ask it to create a drop target

        if (_IsFolder(pistg))
        {
            IShellFolder *psf;
            hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->CreateViewObject(hwnd, IID_IDropTarget, ppv);
                psf->Release();
            }
        }
        else
        {
            hr = CreateViewObject(hwnd, IID_IDropTarget, ppv);
        }
    }

    return hr;
}


HRESULT CStgFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *pStrRet)
{
    HRESULT hr = E_INVALIDARG;
    LPCSTGITEM pistg = _IsStgItem(pidl);
    if (pistg)
    {
        LPCWSTR pwszName;
        WSTR_ALIGNED_STACK_COPY(&pwszName, pistg->szName);

        if (dwFlags & SHGDN_FORPARSING)
        {
            if (dwFlags & SHGDN_INFOLDER)
            {
                hr = StringToStrRet(pwszName, pStrRet);          // relative name
            }
            else
            {
                // compute the for parsing name based on the path to the storage object
                // and then the in folder name of the object

                TCHAR szTemp[MAX_PATH];
                SHGetNameAndFlags(_pidl, dwFlags, szTemp, ARRAYSIZE(szTemp), NULL);
                PathAppend(szTemp, pwszName);
                hr = StringToStrRet(szTemp, pStrRet);
            }
        }
        else
        {
            SHFILEINFO sfi;
            if (SHGetFileInfo(pwszName, _IsFolder(pistg), &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
                hr = StringToStrRet(sfi.szDisplayName, pStrRet);
            else
                hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CStgFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD dwFlags, LPITEMIDLIST *ppidlOut)
{
    LPCSTGITEM pistg = _IsStgItem(pidl);
    if (!pistg)
        return E_INVALIDARG;

    HRESULT hr = _EnsureStorage(STGM_READWRITE);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pwszName;
        WSTR_ALIGNED_STACK_COPY(&pwszName, pistg->szName);
        
        // format up the new name before we attempt to perform the rename

        TCHAR szNewName[MAX_PATH];
        StrCpyN(szNewName, pszName, ARRAYSIZE(szNewName));
        if (!_ShowExtension())
        {
            StrCatBuff(szNewName, PathFindExtension(pwszName), ARRAYSIZE(szNewName));
        }

        hr = _pstg->RenameElement(pwszName, szNewName);            
        if (SUCCEEDED(hr))
        {
            hr = _pstg->Commit(STGC_DEFAULT);
        }

        // if that was successful lets return the
        // new IDLIST we generated.

        if (SUCCEEDED(hr) && ppidlOut)
            hr = _AllocIDList(szNewName, ppidlOut, NULL);
    }
    return hr;
}


HRESULT CStgFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetail)
{
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];

    // is this a valid column?

    if (iColumn >= ARRAYSIZE(g_aStgColumns))
        return E_NOTIMPL;
   
    pDetail->str.uType = STRRET_CSTR;
    pDetail->str.cStr[0] = 0;
    
    LPCSTGITEM pistg = _IsStgItem(pidl);
    if (!pistg)
    {
        // when the IDLIST is not a storage item then we return the column information
        // back to the caller.

        pDetail->fmt = g_aStgColumns[iColumn].iFmt;
        pDetail->cxChar = g_aStgColumns[iColumn].cchCol;
        LoadString(HINST_THISDLL, g_aStgColumns[iColumn].iTitle, szTemp, ARRAYSIZE(szTemp));
        hr = StringToStrRet(szTemp, &(pDetail->str));
    }
    else
    {
        // return the property to the caller that is being requested, this is based on the
        // list of columns we gave out when the view was created.
        LPCWSTR pwszName;
        WSTR_ALIGNED_STACK_COPY(&pwszName, pistg->szName);

        switch (iColumn)
        {
            case STG_COL_NAME:
                hr = StringToStrRet(pwszName, &(pDetail->str));
                break;
        
            case STG_COL_SIZE:
                if (!_IsFolder(pistg))
                {
                    ULARGE_INTEGER ullSize = pistg->cbFileSize;
                    StrFormatKBSize(ullSize.QuadPart, szTemp, ARRAYSIZE(szTemp));
                    hr = StringToStrRet(szTemp, &(pDetail->str));
                }
                break;
        
            case STG_COL_TYPE:
            {
                SHFILEINFO sfi;
                if (SHGetFileInfo(pwszName, _IsFolder(pistg), &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME))
                    hr =  StringToStrRet(sfi.szTypeName, &(pDetail->str));
                break;
            }

            case STG_COL_MODIFIED:
                SHFormatDateTime(&pistg->ftModified, NULL, szTemp, ARRAYSIZE(szTemp));
                hr = StringToStrRet(szTemp, &(pDetail->str));
                break;
        }             
    }    
    return hr;
}


// IStorage

HRESULT CStgFolder::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in Commit");
        hr = _pstg->Commit(grfCommitFlags);
    }
    return hr;
}

HRESULT CStgFolder::Revert()
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in Revert");
        hr = _pstg->Revert();
    }
    return hr;
}

HRESULT CStgFolder::SetClass(REFCLSID clsid)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in SetClass");
        hr = _pstg->SetClass(clsid);
    }
    return hr;
}

HRESULT CStgFolder::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in SetStateBits");
        hr = _pstg->SetStateBits(grfStateBits, grfMask);
    }
    return hr;
}

HRESULT CStgFolder::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in Stat");
        hr = _pstg->Stat(pstatstg, grfStatFlag);
    }
    return hr;
}

HRESULT CStgFolder::EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in EnumElements");
        hr = _pstg->EnumElements(reserved1, reserved2, reserved3, ppenum);
    }
    return hr;
}

HRESULT CStgFolder::OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm)
{
    HRESULT hr = _EnsureStorage(grfMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in OpenStream");
        hr = _pstg->OpenStream(pszRel, reserved1, grfMode, reserved2, ppstm);
    }
    return hr;
}

HRESULT CStgFolder::OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg)
{
    HRESULT hr = _EnsureStorage(grfMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in OpenStorage");
        hr = _pstg->OpenStorage(pszRel, pstgPriority, grfMode, snbExclude, reserved, ppstg);
    }
    return hr;
}

HRESULT CStgFolder::DestroyElement(LPCWSTR pszRel)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in DestroyElement"); 

        LPITEMIDLIST pidl;
        BOOL fFolder;
        hr = _AllocIDList(pszRel, &pidl, &fFolder);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlAbs;
            hr = SHILCombine(_pidl, pidl, &pidlAbs);
            if (SUCCEEDED(hr))
            {
                hr = _pstg->DestroyElement(pszRel);
                if (SUCCEEDED(hr))
                    SHChangeNotify(fFolder ? SHCNE_RMDIR : SHCNE_DELETE, SHCNF_IDLIST, pidlAbs, NULL);
                ILFree(pidlAbs);
            }
            ILFree(pidl);
        }
    }
    return hr;
}


HRESULT CStgFolder::RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in RenameElement"); 

        LPITEMIDLIST pidlOld;
        BOOL fFolder;
        hr = _AllocIDList(pwcsOldName, &pidlOld, &fFolder);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlAbsOld;
            hr = SHILCombine(_pidl, pidlOld, &pidlAbsOld);
            if (SUCCEEDED(hr))
            {
                hr = _pstg->RenameElement(pwcsOldName, pwcsNewName);
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidlNew;
                    hr = _AllocIDList(pwcsNewName, &pidlNew, NULL);
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlAbsNew;
                        hr = SHILCombine(_pidl, pidlNew, &pidlAbsNew);
                        if (SUCCEEDED(hr))
                        {
                            SHChangeNotify(fFolder ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM, SHCNF_IDLIST, pidlAbsOld, pidlAbsNew);
                            ILFree(pidlAbsNew);
                        }
                        ILFree(pidlNew);
                    }
                }
                ILFree(pidlAbsOld);
            }
            ILFree(pidlOld);
        }
    }
    return hr;
}


HRESULT CStgFolder::SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in SetElementTimes"); 

        hr = _pstg->SetElementTimes(pszRel, pctime, patime, pmtime);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            BOOL fFolder;
            hr = _AllocIDList(pszRel, &pidl, &fFolder);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlAbs;
                hr = SHILCombine(_pidl, pidl, &pidlAbs);
                if (SUCCEEDED(hr))
                {
                    SHChangeNotify(fFolder ? SHCNE_UPDATEDIR : SHCNE_UPDATEITEM, SHCNF_IDLIST, pidlAbs, NULL);
                    ILFree(pidlAbs);
                }
                ILFree(pidl);
            }
        }
    }
    return hr;
}


HRESULT CStgFolder::CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in CopyTo"); 

        hr = _pstg->CopyTo(ciidExclude, rgiidExclude, snbExclude, pstgDest);
    }
    return hr;
}


HRESULT CStgFolder::MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
{
    HRESULT hr = _EnsureStorage(_dwMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in MoveElementTo"); 

        hr = _pstg->MoveElementTo(pszRel, pstgDest, pwcsNewName, grfFlags);
    }
    return hr;
}


HRESULT CStgFolder::CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm)
{
    HRESULT hr = _EnsureStorage(grfMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in CreateStream"); 

        hr = _pstg->CreateStream(pwcsName, grfMode, res1, res2, ppstm);
        if (SUCCEEDED(hr))
            hr = _pstg->Commit(STGC_DEFAULT);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = _AllocIDList(pwcsName, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlAbs;
                hr = SHILCombine(_pidl, pidl, &pidlAbs);
                if (SUCCEEDED(hr))
                {
                    SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST, pidlAbs, NULL);
                    ILFree(pidlAbs);
                }
                ILFree(pidl);
            }
        }
    }
    return hr;
}


HRESULT CStgFolder::CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg)
{
    HRESULT hr = _EnsureStorage(grfMode);
    if (SUCCEEDED(hr))
    {
        ASSERTMSG(_pstg != NULL, "no _pstg in CreateStorage"); 

        hr = _pstg->CreateStorage(pwcsName, grfMode, res1, res2, ppstg);
        if (SUCCEEDED(hr))
            hr = _pstg->Commit(STGC_DEFAULT);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = _AllocIDList(pwcsName, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlAbs;
                hr = SHILCombine(_pidl, pidl, &pidlAbs);
                if (SUCCEEDED(hr))
                {
                    SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, pidlAbs, NULL);
                    ILFree(pidlAbs);
                }
                ILFree(pidl);
            }
        }
    }
    return hr;
}

// IPersistStorage
HRESULT CStgFolder::IsDirty(void)
{
    return E_NOTIMPL;
}

HRESULT CStgFolder::InitNew(IStorage *pStg)
{
    return E_NOTIMPL;
}

HRESULT CStgFolder::Load(IStorage *pStg)
{
    IUnknown_Set((IUnknown **)&_pstgLoad, (IUnknown *)pStg);
    return S_OK;
}

HRESULT CStgFolder::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    return E_NOTIMPL;
}

HRESULT CStgFolder::SaveCompleted(IStorage *pStgNew)
{
    return E_NOTIMPL;
}

HRESULT CStgFolder::HandsOffStorage(void)
{
    return E_NOTIMPL;
}

    
// Enumerator object for storages

class CStgEnum : public IEnumIDList
{
public:
    CStgEnum(CStgFolder* prf, DWORD grfFlags);
    ~CStgEnum();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) 
        { return E_NOTIMPL; };
    STDMETHODIMP Reset()
        { ATOMICRELEASE(_pEnum); return S_OK; };
    STDMETHODIMP Clone(IEnumIDList **ppenum) 
        { return E_NOTIMPL; };

private:
    LONG _cRef;
    CStgFolder* _pstgf;
    DWORD _grfFlags;
    IEnumSTATSTG *_pEnum;
};


STDAPI CStgEnum_CreateInstance(CStgFolder *pstgf, DWORD grfFlags, IEnumIDList **ppenum)
{
    CStgEnum *penum = new CStgEnum(pstgf, grfFlags);
    if (!penum)
        return E_OUTOFMEMORY;

    HRESULT hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
    penum->Release();
    return hr;
}

CStgEnum::CStgEnum(CStgFolder *pstgf, DWORD grfFlags) :
    _cRef(1), _pstgf(pstgf), _grfFlags(grfFlags)
{
    _pstgf->AddRef();
}

CStgEnum::~CStgEnum()
{
    ATOMICRELEASE(_pEnum);
    _pstgf->Release();
}


STDMETHODIMP_(ULONG) CStgEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_(ULONG) CStgEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CStgEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CStgEnum, IEnumIDList),                    // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


HRESULT CStgEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;

    // do we have an enumerator, if not then lets get one from the 
    // storage object

    if (!_pEnum)
    {
        // we need to reopen docfile storages to get a new enumerator
        // because they keep giving us a stale one.
        // if we don't close to get a new enumerator, when we delete a file
        // the SHCNE_UPDATEDIR wont work because we'll spit out the same
        // pidls that should have been deleted.
        // can we get around this?
        _pstgf->_CloseStorage();

        hr = _pstgf->_EnsureStorage(STGM_READ);
        if (SUCCEEDED(hr))
            hr = _pstgf->_pstg->EnumElements(0, NULL, 0, &_pEnum);
    }

    // now return items, if all is good and we have stuff to pass back.
    
    for (UINT cItems = 0; (cItems != celt) && SUCCEEDED(hr) && (hr != S_FALSE) ; )
    {
        STATSTG statstg = { 0 };
        hr = _pEnum->Next(1, &statstg, NULL);
        if (SUCCEEDED(hr) && (hr != S_FALSE))
        {
            BOOL fFolder;
            LPITEMIDLIST pidl;

            hr = _pstgf->_AllocIDList(statstg, &pidl, &fFolder);
            CoTaskMemFree(statstg.pwcsName);

            if (SUCCEEDED(hr))
            {
                if (fFolder)
                {
                    if (!(_grfFlags & SHCONTF_FOLDERS))
                    {
                        ILFree(pidl);
                        continue;
                    }
                }
                else if (!(_grfFlags & SHCONTF_NONFOLDERS))
                {
                    ILFree(pidl);
                    continue;
                }

                rgelt[cItems++] = pidl;         // return the idlist
            }
        }
    }

    if (hr == S_FALSE)
        ATOMICRELEASE(_pEnum);

    if (pceltFetched)
        *pceltFetched = cItems;

    return hr;
}


// Drop target object


class CStgDropTarget : public IDropTarget
{
public:
    CStgDropTarget(CStgFolder *pstgf, HWND hwnd);
    ~CStgDropTarget();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    LONG _cRef;

    CStgFolder *_pstgf;
    HWND _hwnd;                     // EVIL: used as a site and UI host
    IDataObject *_pdtobj;           // used durring DragOver() and DoDrop(), don't use on background thread

    UINT _idCmd;
    DWORD _grfKeyStateLast;         // for previous DragOver/Enter
    DWORD _dwEffectLastReturned;    // stashed effect that's returned by base class's dragover
    DWORD _dwEffectPreferred;       // if dwData & DTID_PREFERREDEFFECT

    DWORD _GetDropEffect(DWORD *pdwEffect, DWORD grfKeyState);
    HRESULT _Transfer(IDataObject *pdtobj, UINT uiCmd);
};

CStgDropTarget::CStgDropTarget(CStgFolder *pstgf, HWND hwnd) :
    _cRef(1),
    _pstgf(pstgf),
    _hwnd(hwnd),
    _grfKeyStateLast(-1)
{
    _pstgf->AddRef();
}

CStgDropTarget::~CStgDropTarget()
{
    DragLeave();
    ATOMICRELEASE(_pstgf);
}

STDMETHODIMP_(ULONG) CStgDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CStgDropTarget::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CStgDropTarget::QueryInterface(REFIID riid, void**ppv)
{
    static const QITAB qit[] = {
        QITABENT(CStgDropTarget, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid,ppv);
}

STDAPI CStgDropTarget_CreateInstance(CStgFolder *pstgf, HWND hwnd, IDropTarget **ppdt)
{
    CStgDropTarget *psdt = new CStgDropTarget(pstgf, hwnd);
    if (!psdt)
        return E_OUTOFMEMORY;

    HRESULT hr = psdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdt));
    psdt->Release();
    return hr;
}

#if 0
HRESULT StorageFromDataObj(IDataObject *pdtobj, IShellFolder **ppsf, IStorage **ppstg)
{
    *ppsf = NULL;
    *ppstg = NULL;

    HRESULT hr = E_FAIL;
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, IDA_GetIDListPtr(pida, (UINT)-1), ppsf))))
        {
            // for (UINT i = 0; i < pida->cidl; i++) 
            for (UINT i = 0; i < 1; i++) 
            {
                hr = (*ppsf)->BindToObject(IDA_GetIDListPtr(pida, i), NULL, IID_PPV_ARG(IStorage, ppstg));
                if (FAILED(hr))
                {
                    (*ppsf)->Release();
                    *ppsf = NULL;
                }
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return hr;
}
#endif

HRESULT CStgDropTarget::_Transfer(IDataObject *pdtobj, UINT uiCmd)
{
#if 0
    IShellFolder *psf;
    IStorage *pstg;
    HRESULT hr = StorageFromDataObj(pdtobj, &psf, &pstg);
    if (SUCCEEDED(hr))
    {
        DWORD grfModeCreated = STGM_READWRITE;
        HRESULT hr = _pstgf->_EnsureStorage(grfModeCreated);
        if (SUCCEEDED(hr))
        {
            hr = pstg->CopyTo(0, NULL, 0, _pstgf->_pstg);
            if (SUCCEEDED(hr))
            {
                hr = _pstgf->_pstg->Commit(STGC_DEFAULT);
            }
            SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST|SHCNF_FLUSH|SHCNF_FLUSHNOWAIT, _pstgf->_pidl, NULL);
        }
        pstg->Release();
        psf->Release();
    }
#else
    HRESULT hr;
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        IShellFolder *psf;
        hr = SHBindToObjectEx(NULL, IDA_GetIDListPtr(pida, (UINT)-1), NULL, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            IStorage *pstgSrc;
            hr = psf->QueryInterface(IID_PPV_ARG(IStorage, &pstgSrc));
            if (SUCCEEDED(hr))
            {
                hr = _pstgf->_EnsureStorage(STGM_READWRITE);
                if (SUCCEEDED(hr))
                {
                    for (UINT i = 0; i < pida->cidl; i++) 
                    {
                        WCHAR szName[MAX_PATH];
                        hr = DisplayNameOf(psf, IDA_GetIDListPtr(pida, i), SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
                        if (SUCCEEDED(hr))
                        {
                            DWORD grfFlags = (uiCmd == DDIDM_COPY) ? STGMOVE_COPY : STGMOVE_MOVE;
                            hr = pstgSrc->MoveElementTo(szName, _pstgf->_pstg, szName, grfFlags);
                            if (SUCCEEDED(hr))
                                hr = _pstgf->_pstg->Commit(STGC_DEFAULT);
                        }
                    }
                }
                pstgSrc->Release();
            }
            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST|SHCNF_FLUSH|SHCNF_FLUSHNOWAIT, _pstgf->_pidl, NULL);
    }
    else
        hr = E_FAIL;
#endif
    return hr;
}

DWORD CStgDropTarget::_GetDropEffect(DWORD *pdwEffect, DWORD grfKeyState)
{
    DWORD dwEffectReturned = DROPEFFECT_NONE;
    switch (grfKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT))
    {
    case MK_CONTROL:            dwEffectReturned = DROPEFFECT_COPY; break;
    case MK_SHIFT:              dwEffectReturned = DROPEFFECT_MOVE; break;
    case MK_SHIFT | MK_CONTROL: dwEffectReturned = DROPEFFECT_LINK; break;
    case MK_ALT:                dwEffectReturned = DROPEFFECT_LINK; break;
    
    default:
        {
            // no modifier keys:
            // if the data object contains a preferred drop effect, try to use it
            DWORD dwPreferred = DataObj_GetDWORD(_pdtobj, g_cfPreferredDropEffect, DROPEFFECT_NONE) & *pdwEffect;
            if (dwPreferred)
            {
                if (dwPreferred & DROPEFFECT_MOVE)
                {
                    dwEffectReturned = DROPEFFECT_MOVE;
                }
                else if (dwPreferred & DROPEFFECT_COPY)
                {
                    dwEffectReturned = DROPEFFECT_COPY;
                }
                else if (dwPreferred & DROPEFFECT_LINK)
                {
                    dwEffectReturned = DROPEFFECT_LINK;
                }
            }
            else
            {
                dwEffectReturned = DROPEFFECT_COPY;
            }
        }
        break;
    }
    return dwEffectReturned;
}


STDMETHODIMP CStgDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    _grfKeyStateLast = grfKeyState;

    if (pdwEffect)
        *pdwEffect = _dwEffectLastReturned = _GetDropEffect(pdwEffect, grfKeyState);

    return S_OK;
}


STDMETHODIMP CStgDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // has the key state changed?  if not then lets return the previously cached 
    // version, otherwise recompute.

    if (_grfKeyStateLast == grfKeyState)
    {
        if (*pdwEffect)
            *pdwEffect = _dwEffectLastReturned;
    }
    else if (*pdwEffect)
    {
        *pdwEffect = _GetDropEffect(pdwEffect, grfKeyState);
    }

    _dwEffectLastReturned = *pdwEffect;
    _grfKeyStateLast = grfKeyState;

    return S_OK;
}

 
STDMETHODIMP CStgDropTarget::DragLeave()
{
    ATOMICRELEASE(_pdtobj);
    return S_OK;
}

STDMETHODIMP CStgDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_NONE;           // incase of failure

    // determine the type of operation to performed, if the right button is down
    // then lets display the menu, otherwise base it on the drop effect

    UINT idCmd = 0;                             // Choice from drop popup menu
    if (!(_grfKeyStateLast & MK_LBUTTON))
    {
        HMENU hMenu = SHLoadPopupMenu(HINST_THISDLL, POPUP_NONDEFAULTDD);
        if (!hMenu)
        {
            DragLeave();
            return E_FAIL;
        }
        
        SetMenuDefaultItem(hMenu, POPUP_NONDEFAULTDD, FALSE);
        idCmd = TrackPopupMenu(hMenu, 
                               TPM_RETURNCMD|TPM_RIGHTBUTTON|TPM_LEFTALIGN,
                               pt.x, pt.y, 0, _hwnd, NULL);
        DestroyMenu(hMenu);
    }
    else
    {
        switch (_GetDropEffect(pdwEffect, grfKeyState))
        {
        case DROPEFFECT_COPY:   idCmd = DDIDM_COPY; break;
        case DROPEFFECT_MOVE:   idCmd = DDIDM_MOVE; break;
        case DROPEFFECT_LINK:   idCmd = DDIDM_LINK; break;
        }
    }

    // now perform the operation, based on the command ID we have.

    HRESULT hr = E_FAIL;
    switch (idCmd)
    {
    case DDIDM_COPY:
    case DDIDM_MOVE:
        hr = _Transfer(pdtobj, idCmd);
        if (SUCCEEDED(hr))
            *pdwEffect = (idCmd == DDIDM_COPY) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;
        else
            *pdwEffect = 0;
        break;

    case DDIDM_LINK:
    {
        WCHAR wzPath[MAX_PATH];
        SHGetNameAndFlags(_pstgf->_pidl, SHGDN_FORPARSING, wzPath, ARRAYSIZE(wzPath), NULL);

        hr = SHCreateLinks(_hwnd, wzPath, pdtobj, 0, NULL);
        break;
    }
    }
    
    // success so lets populate the new changes to the effect

    if (SUCCEEDED(hr) && *pdwEffect)
    {
        DataObj_SetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, *pdwEffect);
        DataObj_SetDWORD(pdtobj, g_cfPerformedDropEffect, *pdwEffect);
    }

    DragLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\stgutil.h ===
#ifndef _STGUTIL_H_
#define _STGUTIL_H_

#define STGSTR_STGTOBIND TEXT("StgToBind")

HRESULT _NextSegment(LPCWSTR *ppszIn, LPTSTR pszSegment, UINT cchSegment, BOOL bValidate);

STDAPI_(BOOL) StgExists(IStorage * pStorageParent, LPCTSTR pszPath);
STDAPI StgCopyFileToStream(LPCTSTR pszSrc, IStream *pStream);
STDAPI StgDeleteUsingDataObject(HWND hwnd, UINT uFlags, IDataObject *pdtobj);
STDAPI StgBindToObject(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv);
STDAPI StgGetStorageFromFile(LPCWSTR wzPath, DWORD grfMode, IStorage **ppstg);
STDAPI StgOpenStorageOnFolder(LPCTSTR pszFolder, DWORD grfFlags, REFIID riid, void **ppv);

STDAPI CShortcutStorage_CreateInstance(IStorage *pstg, REFIID riid, void **ppv);

#endif // _STGUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\stream.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: stream.c
//
//  This file contains some of the stream support code that is used by
// the shell.  It also contains the shells implementation of a memory
// stream that is used by the cabinet to allow views to be serialized.
//
// History:
//  08-20-93 KurtE      Added header block and memory stream.
//
//---------------------------------------------------------------------------
#include "shellprv.h"


STDAPI_(IStream *) 
OpenRegStream(
    HKEY hkey, 
    LPCTSTR pszSubkey, 
    LPCTSTR pszValue, 
    DWORD grfMode)
{
    return SHOpenRegStream(hkey, pszSubkey, pszValue, grfMode);
}


STDAPI_(IStream *)
CreateMemStream(
    LPBYTE pInit, 
    UINT cbInit)
{
    return SHCreateMemStream(pInit, cbInit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\storage.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include "debug.h"
#include "stgutil.h"
#include "ids.h"
#include "tngen\ctngen.h"
#include "tlist.h"
#include "thumbutil.h"

void SHGetThumbnailSizeForThumbsDB(SIZE *psize);

STDAPI CThumbStore_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);

class CThumbStore : public IShellImageStore,
                    public IPersistFolder,
                    public IPersistFile,
                    public CComObjectRootEx<CComMultiThreadModel>,
                    public CComCoClass< CThumbStore,&CLSID_ShellThumbnailDiskCache >
{
    struct CATALOG_ENTRY
    {
        DWORD     cbSize;
        DWORD     dwIndex;
        FILETIME  ftTimeStamp;
        WCHAR     szName[1];
    };

    struct CATALOG_HEADER
    {
        WORD      cbSize;
        WORD      wVersion;
        DWORD     dwEntryCount;
        SIZE      szThumbnailExtent;
    };

public:
    BEGIN_COM_MAP(CThumbStore)
        COM_INTERFACE_ENTRY_IID(IID_IShellImageStore,IShellImageStore)
        COM_INTERFACE_ENTRY(IPersistFolder)
        COM_INTERFACE_ENTRY(IPersistFile)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CThumbStore)

    CThumbStore();
    ~CThumbStore();

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFile
    STDMETHOD (IsDirty)(void);
    STDMETHOD (Load)(LPCWSTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCWSTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCWSTR pszFileName);
    STDMETHOD (GetCurFile)(LPWSTR *ppszFileName);

    // IImageCache
    STDMETHOD (Open)(DWORD dwMode, DWORD *pdwLock);
    STDMETHOD (Create)(DWORD dwMode, DWORD *pdwLock);
    STDMETHOD (Close)(DWORD const *pdwLock);
    STDMETHOD (Commit)(DWORD const *pdwLock);
    STDMETHOD (ReleaseLock)(DWORD const *pdwLock);
    STDMETHOD (IsLocked)(THIS);
    
    STDMETHOD (GetMode)(DWORD *pdwMode);
    STDMETHOD (GetCapabilities)(DWORD *pdwCapMask);

    STDMETHOD (AddEntry)(LPCWSTR pszName, const FILETIME *pftTimeStamp, DWORD dwMode, HBITMAP hImage);
    STDMETHOD (GetEntry)(LPCWSTR pszName, DWORD dwMode, HBITMAP *phImage);
    STDMETHOD (DeleteEntry)(LPCWSTR pszName);
    STDMETHOD (IsEntryInStore)(LPCWSTR pszName, FILETIME *pftTimeStamp);

    STDMETHOD (Enum)(IEnumShellImageStore ** ppEnum);
   
protected:
    friend class CEnumThumbStore;
    
    HRESULT LoadCatalog(void);
    HRESULT SaveCatalog(void);
    
    HRESULT FindStreamID(LPCWSTR pszName, DWORD *pdwStream, CATALOG_ENTRY **ppEntry);
    HRESULT GetEntryStream(DWORD dwStream, DWORD dwMode, IStream **ppStream);
    DWORD GetAccessMode(DWORD dwMode, BOOL fStream);

    DWORD AcquireLock(void);
    void ReleaseLock(DWORD dwLock);

    BOOL InitCodec(void);

    HRESULT PrepImage(HBITMAP *phBmp, SIZE * prgSize, void ** ppBits);
    BOOL DecompressImage(void * pvInBuffer, ULONG ulBufferSize, HBITMAP *phBmp);
    BOOL CompressImage(HBITMAP hBmp, void ** ppvOutBuffer, ULONG * plBufSize);

    HRESULT WriteImage(IStream *pStream, HBITMAP hBmp);
    HRESULT ReadImage(IStream *pStream, HBITMAP *phBmp);
    BOOL _MatchNodeName(CATALOG_ENTRY *pNode, LPCWSTR pszName);

    HRESULT _InitFromPath(LPCTSTR pszPath, DWORD dwMode);
    void _SetAttribs(BOOL bForce);

    CATALOG_HEADER m_rgHeader;
    CList<CATALOG_ENTRY> m_rgCatalog;
    IStorage *_pStorageThumb;
    DWORD _dwModeStorage;

    DWORD m_dwModeAllow;
    WCHAR m_szPath[MAX_PATH];
    DWORD m_dwMaxIndex;
    DWORD m_dwCatalogChange;

    // Crit section used to protect the internals
    CRITICAL_SECTION m_csInternals;
    
    // needed for this object to be free-threaded... so that 
    // we can query the catalog from the main thread whilst icons are
    // being read and written from the main thread.
    CRITICAL_SECTION m_csLock;

    DWORD m_dwLock;
    int m_fLocked;
    CThumbnailFCNContainer * m_pJPEGCodec;
};

HRESULT CEnumThumbStore_Create(CThumbStore * pThis, IEnumShellImageStore ** ppEnum);

class CEnumThumbStore : public IEnumShellImageStore,
                        public CComObjectRoot
{
public:
    BEGIN_COM_MAP(CEnumThumbStore)
        COM_INTERFACE_ENTRY_IID(IID_IEnumShellImageStore,IEnumShellImageStore)
    END_COM_MAP()

    CEnumThumbStore();
    ~CEnumThumbStore();

    STDMETHOD (Reset)(void);
    STDMETHOD (Next)(ULONG celt, PENUMSHELLIMAGESTOREDATA *prgElt, ULONG *pceltFetched);
    STDMETHOD (Skip)(ULONG celt);
    STDMETHOD (Clone)(IEnumShellImageStore ** pEnum);
    
protected:
    friend HRESULT CEnumThumbStore_Create(CThumbStore *pThis, IEnumShellImageStore **ppEnum);

    CThumbStore * m_pStore;
    CLISTPOS m_pPos;
    DWORD m_dwCatalogChange;
};


#define THUMB_FILENAME      L"Thumbs.db"
#define CATALOG_STREAM      L"Catalog"

#define CATALOG_VERSION     0x0006
#define CATALOG_VERSION_XPGOLD 0x0005
#define STREAMFLAGS_JPEG    0x0001
#define STREAMFLAGS_DIB     0x0002

struct STREAM_HEADER
{
    DWORD cbSize;
    DWORD dwFlags;
    ULONG ulSize;
};

void GenerateStreamName(LPWSTR pszBuffer, DWORD cbSize, DWORD dwNumber);
HRESULT ReadImage(IStream *pStream, HBITMAP *phImage);
HRESULT WriteImage(IStream *pStream, HBITMAP hImage);
BITMAPINFO *BitmapToDIB(HBITMAP hBmp);

CThumbStore::CThumbStore()
{
    m_szPath[0] = 0;
    m_rgHeader.dwEntryCount = 0;
    m_rgHeader.wVersion = CATALOG_VERSION;
    m_rgHeader.cbSize = sizeof(m_rgHeader);
    SHGetThumbnailSizeForThumbsDB(&m_rgHeader.szThumbnailExtent);

    m_dwMaxIndex = 0;
    m_dwModeAllow = STGM_READWRITE;

    // this counter is inc'd everytime the catalog changes so that we know when it
    // must be committed and so enumerators can detect the list has changed...
    m_dwCatalogChange = 0;

    m_fLocked = 0;
    InitializeCriticalSection(&m_csLock);
    InitializeCriticalSection(&m_csInternals);
}

CThumbStore::~CThumbStore()
{
    CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
    while (pCur != NULL)
    {
        CATALOG_ENTRY *pNode = m_rgCatalog.GetNext(pCur);
        ASSERT(pNode != NULL);

        LocalFree((void *) pNode);
    }

    m_rgCatalog.RemoveAll();

    if (_pStorageThumb)
    {
        _pStorageThumb->Release();
    }

    if (m_pJPEGCodec)
    {
        delete m_pJPEGCodec;
    }

    // assume these are free, we are at ref count zero, no one should still be calling us...
    DeleteCriticalSection(&m_csLock);
    DeleteCriticalSection(&m_csInternals);
}

STDAPI CThumbStore_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    return CComCreator< CComObject< CThumbStore > >::CreateInstance((void *)punkOuter, riid, (void **)ppv);
}

DWORD CThumbStore::AcquireLock(void)
{
    EnterCriticalSection(&m_csLock);

    // inc the lock (we use a counter because we may reenter this on the same thread)
    m_fLocked++;

    // Never return a lock signature of zero, because that means "not locked".
    if (++m_dwLock == 0)
        ++m_dwLock;
    return m_dwLock;
}

void CThumbStore::ReleaseLock(DWORD dwLock)
{
    if (dwLock) 
    {
        ASSERT(m_fLocked);
        m_fLocked--;
        LeaveCriticalSection(&m_csLock);
    }
}

// the structure of the catalog is simple, it is a just a header stream
HRESULT CThumbStore::LoadCatalog()
{
    HRESULT hr;
    if (_pStorageThumb == NULL)
    {
        hr = E_UNEXPECTED;
    } 
    else if (m_rgHeader.dwEntryCount != 0)
    {
        // it is already loaded....
        hr = S_OK;
    }
    else
    {
        // open the catalog stream...
        IStream *pCatalog;
        hr = _pStorageThumb->OpenStream(CATALOG_STREAM, NULL, GetAccessMode(STGM_READ, TRUE), NULL, &pCatalog);
        if (SUCCEEDED(hr))
        {
            EnterCriticalSection(&m_csInternals);

            // now read in the catalog from the stream ...
            hr = IStream_Read(pCatalog, &m_rgHeader, sizeof(m_rgHeader));
            if (SUCCEEDED(hr))
            {
                SIZE szCurrentSize;
                SHGetThumbnailSizeForThumbsDB(&szCurrentSize);
                if ((m_rgHeader.cbSize != sizeof(m_rgHeader)) || (m_rgHeader.wVersion != CATALOG_VERSION) ||
                    (m_rgHeader.szThumbnailExtent.cx != szCurrentSize.cx) || (m_rgHeader.szThumbnailExtent.cy != szCurrentSize.cy))
                {
                    if (m_rgHeader.wVersion == CATALOG_VERSION_XPGOLD)
                    {
                        hr = STG_E_DOCFILECORRUPT; // SECURITY: Many issues encrypting XPGOLD thumbnail databases, just delete it
                        _pStorageThumb->Release();
                        _pStorageThumb = NULL;
                    }
                    else
                    {
                        _SetAttribs(TRUE); // SECURITY: Old formats can't be encrypted
                        hr = STG_E_OLDFORMAT;
                    }
                }
                else
                {
                    for (UINT iEntry = 0; (iEntry < m_rgHeader.dwEntryCount) && SUCCEEDED(hr); iEntry++)
                    {
                        DWORD cbSize;
                        hr = IStream_Read(pCatalog, &cbSize, sizeof(cbSize));
                        if (SUCCEEDED(hr))
                        {
                            ASSERT(cbSize <= sizeof(CATALOG_ENTRY) + sizeof(WCHAR) * MAX_PATH);

                            CATALOG_ENTRY *pEntry = (CATALOG_ENTRY *)LocalAlloc(LPTR, cbSize);
                            if (pEntry)
                            {
                                pEntry->cbSize = cbSize;

                                // read the rest with out the size on the front...
                                hr = IStream_Read(pCatalog, ((BYTE *)pEntry + sizeof(cbSize)), cbSize - sizeof(cbSize));
                                if (SUCCEEDED(hr))
                                {
                                    CLISTPOS pCur = m_rgCatalog.AddTail(pEntry);
                                    if (pCur)
                                    {
                                        if (m_dwMaxIndex < pEntry->dwIndex)
                                        {
                                            m_dwMaxIndex = pEntry->dwIndex;
                                        }
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
            }

            if (FAILED(hr))
            {
                // reset the catalog header...
                m_rgHeader.wVersion = CATALOG_VERSION;
                m_rgHeader.cbSize = sizeof(m_rgHeader);
                SHGetThumbnailSizeForThumbsDB(&m_rgHeader.szThumbnailExtent);
                m_rgHeader.dwEntryCount = 0;
            }

            m_dwCatalogChange = 0;
            LeaveCriticalSection(&m_csInternals);

            pCatalog->Release();
        }
    }

    return hr;
}

HRESULT CThumbStore::SaveCatalog()
{
    _pStorageThumb->DestroyElement(CATALOG_STREAM);

    IStream *pCatalog;
    HRESULT hr = _pStorageThumb->CreateStream(CATALOG_STREAM, GetAccessMode(STGM_WRITE, TRUE), NULL, NULL, &pCatalog);
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_csInternals);

        // now write the catalog to the stream ...
        hr = IStream_Write(pCatalog, &m_rgHeader, sizeof(m_rgHeader));
        if (SUCCEEDED(hr))
        {
            CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
            while (pCur && SUCCEEDED(hr))
            {
                CATALOG_ENTRY *pEntry = m_rgCatalog.GetNext(pCur);
                if (pEntry)
                {
                    hr = IStream_Write(pCatalog, pEntry, pEntry->cbSize);
                }
            }
        }

        if (SUCCEEDED(hr))
            m_dwCatalogChange = 0;

        LeaveCriticalSection(&m_csInternals);
        pCatalog->Release();
    }
    return hr;
}

void GenerateStreamName(LPWSTR pszBuffer, DWORD cbSize, DWORD dwNumber)
{
    UINT cPos = 0;
    while (dwNumber > 0)
    {
        DWORD dwRem = dwNumber % 10;

        // based the fact that UNICODE chars 0-9 are the same as the ANSI chars 0 - 9
        pszBuffer[cPos++] = (WCHAR)(dwRem + '0');
        dwNumber /= 10;
    }
    pszBuffer[cPos] = 0;
}

// IPersist methods

STDMETHODIMP CThumbStore::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_ShellThumbnailDiskCache;
    return S_OK;
}

// IPersistFolder

STDMETHODIMP CThumbStore::Initialize(LPCITEMIDLIST pidl)
{
    WCHAR szPath[MAX_PATH];

    HRESULT hr = SHGetPathFromIDList(pidl, szPath) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (PathAppend(szPath, THUMB_FILENAME))
            hr = _InitFromPath(szPath, STGM_READWRITE);
        else
            hr = E_INVALIDARG;
    }

    return hr;
}

// IPersistFile

STDMETHODIMP CThumbStore::IsDirty(void)
{
    return m_dwCatalogChange ? S_OK : S_FALSE;
}

HRESULT CThumbStore::_InitFromPath(LPCTSTR pszPath, DWORD dwMode)
{
    if (PathIsRemovable(pszPath))
        dwMode = STGM_READ;

    m_dwModeAllow = dwMode;
    StrCpyN(m_szPath, pszPath, ARRAYSIZE(m_szPath));
    return S_OK;
}

STDMETHODIMP CThumbStore::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    TCHAR szPath[MAX_PATH];
    PathCombine(szPath, pszFileName, THUMB_FILENAME);
    return _InitFromPath(szPath, dwMode);
}

STDMETHODIMP CThumbStore::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CThumbStore::SaveCompleted(LPCWSTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CThumbStore::GetCurFile(LPWSTR *ppszFileName)
{
    return SHStrDupW(m_szPath, ppszFileName);
}

// IShellImageStore methods
void CThumbStore::_SetAttribs(BOOL bForce)
{
    // reduce spurious changenotifies by checking file attribs first
    DWORD dwAttrib = GetFileAttributes(m_szPath);
    if (bForce || 
        ((dwAttrib != 0xFFFFFFFF) &&
         (dwAttrib & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)))
    {
        SetFileAttributes(m_szPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        
        WCHAR szStream[MAX_PATH + 13];

        StrCpyNW(szStream, m_szPath, ARRAYSIZE(szStream));
        StrCatW(szStream, TEXT(":encryptable"));
        
        HANDLE hStream = CreateFile(szStream, GENERIC_WRITE, NULL, NULL, CREATE_NEW, NULL, NULL);
        if (hStream != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hStream);
        }

        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, m_szPath, NULL);   // suppress the update dir        
    }
}

STDMETHODIMP CThumbStore::Open(DWORD dwMode, DWORD *pdwLock)
{
    if (m_szPath[0] == 0)
    {
        return E_UNEXPECTED;
    }

    if ((m_dwModeAllow == STGM_READ) && (dwMode != STGM_READ))
        return STG_E_ACCESSDENIED;

    // at this point we have the lock if we need it, so we can close and reopen if we
    // don't have it open with the right permissions...
    if (_pStorageThumb)
    {
        if (_dwModeStorage == dwMode)
        {
            // we already have it open in this mode...
            *pdwLock = AcquireLock();
            return S_FALSE;
        }
        else
        {
            // we are open and the mode is different, so close it. Note, no lock is passed, we already
            // have it
            HRESULT hr = Close(NULL);
            if (FAILED(hr))
            {
                return hr;
            }
        }
    }

    DWORD dwLock = AcquireLock();

    DWORD dwFlags = GetAccessMode(dwMode, FALSE);

    // now open the DocFile
    HRESULT hr = StgOpenStorage(m_szPath, NULL, dwFlags, NULL, NULL, &_pStorageThumb);
    if (SUCCEEDED(hr))
    {
        _dwModeStorage = dwMode & (STGM_READ | STGM_WRITE | STGM_READWRITE);
        _SetAttribs(FALSE);
        hr = LoadCatalog();
        *pdwLock = dwLock;
    }
    
    if (STG_E_DOCFILECORRUPT == hr)
    {
        DeleteFile(m_szPath);
    }

    if (FAILED(hr))
    {
        ReleaseLock(dwLock);
    }

    return hr;
}

STDMETHODIMP CThumbStore::Create(DWORD dwMode, DWORD *pdwLock)
{
    if (m_szPath[0] == 0)
    {
        return E_UNEXPECTED;
    }

    if (_pStorageThumb)
    {
        // we already have it open, so we can't create it ...
        return STG_E_ACCESSDENIED;
    }

    if ((m_dwModeAllow == STGM_READ) && (dwMode != STGM_READ))
        return STG_E_ACCESSDENIED;

    DWORD dwLock = AcquireLock();

    DWORD dwFlags = GetAccessMode(dwMode, FALSE);
    
    HRESULT hr = StgCreateDocfile(m_szPath, dwFlags, NULL, &_pStorageThumb);
    if (SUCCEEDED(hr))
    {
        _dwModeStorage = dwMode & (STGM_READ | STGM_WRITE | STGM_READWRITE);
        _SetAttribs(FALSE);
        *pdwLock = dwLock;
    }

    if (FAILED(hr))
    {
        ReleaseLock(dwLock);
    }
    return hr;
}

STDMETHODIMP CThumbStore::ReleaseLock(DWORD const *pdwLock)
{
    ReleaseLock(*pdwLock);
    return S_OK;
}

STDMETHODIMP CThumbStore::IsLocked()
{
    return (m_fLocked > 0 ? S_OK : S_FALSE);
}

// pdwLock can be NULL indicating close the last opened lock

STDMETHODIMP CThumbStore::Close(DWORD const *pdwLock)
{
    DWORD dwLock;
    DWORD const *pdwRel = pdwLock;

    if (!pdwLock)
    {
        dwLock = AcquireLock();
        pdwRel = &dwLock;
    }

    HRESULT hr = S_FALSE;
    if (_pStorageThumb)
    {
        if (_dwModeStorage != STGM_READ)
        {
            // write out the new catalog...
            hr = Commit(pdwLock);
            _pStorageThumb->Commit(0);

            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, m_szPath, NULL);   // suppress the update dir
        }

        _pStorageThumb->Release();
        _pStorageThumb = NULL;
    }

    ReleaseLock(*pdwRel);

    return hr;
}

// pdwLock can be NULL meaning use the current lock

STDMETHODIMP CThumbStore::Commit(DWORD const *pdwLock)
{
    DWORD dwLock;
    if (!pdwLock)
    {
        dwLock = AcquireLock();
        pdwLock = &dwLock;
    }

    HRESULT hr = S_FALSE;

    if (_pStorageThumb && _dwModeStorage != STGM_READ)
    {
        if (m_dwCatalogChange)
        {
            SaveCatalog();
        }
        hr = S_OK;
    }

    ReleaseLock(*pdwLock);

    return hr;
}

STDMETHODIMP CThumbStore::GetMode(DWORD *pdwMode)
{
    if (!pdwMode)
    {
        return E_INVALIDARG;
    }

    if (_pStorageThumb)
    {
        *pdwMode = _dwModeStorage;
        return S_OK;
    }

    *pdwMode = 0;
    return S_FALSE;
}


STDMETHODIMP CThumbStore::GetCapabilities(DWORD *pdwMode)
{
    ASSERT(pdwMode);

    // right now, both are needed/supported for thumbs.db
    *pdwMode = SHIMSTCAPFLAG_LOCKABLE | SHIMSTCAPFLAG_PURGEABLE;

    return S_OK;
}

STDMETHODIMP CThumbStore::AddEntry(LPCWSTR pszName, const FILETIME *pftTimeStamp, DWORD dwMode, HBITMAP hImage)
{
    ASSERT(pszName);

    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    if (_dwModeStorage == STGM_READ)
    {
        // can't modify in this mode...
        return E_ACCESSDENIED;
    }

    // this will block unless we already have the lock on this thread...
    DWORD dwLock = AcquireLock();

    DWORD dwStream = 0;
    CLISTPOS pCur = NULL;
    CATALOG_ENTRY *pNode = NULL;

    EnterCriticalSection(&m_csInternals);

    if (FindStreamID(pszName, &dwStream, &pNode) != S_OK)
    {
        // needs adding to the catalog...
        UINT cbSize = sizeof(*pNode) + lstrlenW(pszName) * sizeof(WCHAR);

        pNode = (CATALOG_ENTRY *)LocalAlloc(LPTR, cbSize);
        if (pNode == NULL)
        {
            LeaveCriticalSection(&m_csInternals);
            ReleaseLock(dwLock);
            return E_OUTOFMEMORY;
        }

        pNode->cbSize = cbSize;
        if (pftTimeStamp)
        {
            pNode->ftTimeStamp = *pftTimeStamp;
        }
        dwStream = pNode->dwIndex = ++m_dwMaxIndex;
        StrCpyW(pNode->szName, pszName);

        pCur = m_rgCatalog.AddTail(pNode);
        if (pCur == NULL)
        {
            LocalFree(pNode);
            LeaveCriticalSection(&m_csInternals);
            ReleaseLock(dwLock);
            return E_OUTOFMEMORY;
        }

        m_rgHeader.dwEntryCount++;
    }
    else if (pftTimeStamp)
    {
        // update the timestamp .....
        pNode->ftTimeStamp = *pftTimeStamp;
    }

    LeaveCriticalSection(&m_csInternals);

    IStream *pStream = NULL;
    HRESULT hr = THR(GetEntryStream(dwStream, dwMode, &pStream));
    if (SUCCEEDED(hr))
    {
        hr = THR(WriteImage(pStream, hImage));
        pStream->Release();
    }

    if (FAILED(hr) && pCur)
    {
        // take it back out of the list if we added it...
        EnterCriticalSection(&m_csInternals);
        m_rgCatalog.RemoveAt(pCur);
        m_rgHeader.dwEntryCount--;
        LeaveCriticalSection(&m_csInternals);
        LocalFree(pNode);
    }

    if (SUCCEEDED(hr))
    {
        // catalog change....
        m_dwCatalogChange++;
    }

    ReleaseLock(dwLock);

    return hr;
}

STDMETHODIMP CThumbStore::GetEntry(LPCWSTR pszName, DWORD dwMode, HBITMAP *phImage)
{
    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr;
    DWORD dwStream;
    if (FindStreamID(pszName, &dwStream, NULL) != S_OK)
    {
        hr = E_FAIL;
    }
    else
    {
        IStream *pStream;
        hr = GetEntryStream(dwStream, dwMode, &pStream);
        if (SUCCEEDED(hr))
        {
            hr = ReadImage(pStream, phImage);
            pStream->Release();
        }
    }

    return hr;
}

BOOL CThumbStore::_MatchNodeName(CATALOG_ENTRY *pNode, LPCWSTR pszName)
{
    return (StrCmpIW(pNode->szName, pszName) == 0) || 
           (StrCmpIW(PathFindFileName(pNode->szName), pszName) == 0);   // match old thumbs.db files
}

STDMETHODIMP CThumbStore::DeleteEntry(LPCWSTR pszName)
{
    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    if (_dwModeStorage == STGM_READ)
    {
        // can't modify in this mode...
        return E_ACCESSDENIED;
    }

    DWORD dwLock = AcquireLock();

    EnterCriticalSection(&m_csInternals);

    // check to see if it already exists.....
    CATALOG_ENTRY *pNode = NULL;

    CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
    while (pCur != NULL)
    {
        CLISTPOS pDel = pCur;
        pNode = m_rgCatalog.GetNext(pCur);
        ASSERT(pNode != NULL);

        if (_MatchNodeName(pNode, pszName))
        {
            m_rgCatalog.RemoveAt(pDel);
            m_rgHeader.dwEntryCount--;
            m_dwCatalogChange++;
            if (pNode->dwIndex == m_dwMaxIndex)
            {
                m_dwMaxIndex--;
            }
            LeaveCriticalSection(&m_csInternals);

            WCHAR szStream[30];
            GenerateStreamName(szStream, ARRAYSIZE(szStream), pNode->dwIndex);
            _pStorageThumb->DestroyElement(szStream);

            LocalFree(pNode);
            ReleaseLock(dwLock);
            return S_OK;
        }
    }

    LeaveCriticalSection(&m_csInternals);
    ReleaseLock(dwLock);

    return E_INVALIDARG;
}


STDMETHODIMP CThumbStore::IsEntryInStore(LPCWSTR pszName, FILETIME *pftTimeStamp)
{
    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    DWORD dwStream = 0;
    CATALOG_ENTRY *pNode = NULL;
    EnterCriticalSection(&m_csInternals);
    HRESULT hr = FindStreamID(pszName, &dwStream, &pNode);
    if (pftTimeStamp && SUCCEEDED(hr))
    {
        ASSERT(pNode);
        *pftTimeStamp = pNode->ftTimeStamp;
    }
    LeaveCriticalSection(&m_csInternals);

    return (hr == S_OK) ? S_OK : S_FALSE;
}

STDMETHODIMP CThumbStore::Enum(IEnumShellImageStore **ppEnum)
{
    return CEnumThumbStore_Create(this, ppEnum);
}

HRESULT CThumbStore::FindStreamID(LPCWSTR pszName, DWORD *pdwStream, CATALOG_ENTRY ** ppNode)
{
    // check to see if it already exists in the catalog.....
    CATALOG_ENTRY *pNode = NULL;

    CLISTPOS pCur = m_rgCatalog.GetHeadPosition();
    while (pCur != NULL)
    {
        pNode = m_rgCatalog.GetNext(pCur);
        ASSERT(pNode != NULL);

        if (_MatchNodeName(pNode, pszName))
        {
            *pdwStream = pNode->dwIndex;

            if (ppNode != NULL)
            {
                *ppNode = pNode;
            }
            return S_OK;
        }
    }

    return E_FAIL;
}

CEnumThumbStore::CEnumThumbStore()
{
    m_pStore = NULL;
    m_pPos = 0;
    m_dwCatalogChange = 0;
}

CEnumThumbStore::~CEnumThumbStore()
{
    if (m_pStore)
    {
        SAFECAST(m_pStore, IPersistFile *)->Release();
    }
}


STDMETHODIMP CEnumThumbStore::Reset(void)
{
    m_pPos = m_pStore->m_rgCatalog.GetHeadPosition();
    m_dwCatalogChange = m_pStore->m_dwCatalogChange;
    return S_OK;
}

STDMETHODIMP CEnumThumbStore::Next(ULONG celt, PENUMSHELLIMAGESTOREDATA * prgElt, ULONG * pceltFetched)
{
    if ((celt > 1 && !pceltFetched) || !celt)
    {
        return E_INVALIDARG;
    }

    if (m_dwCatalogChange != m_pStore->m_dwCatalogChange)
    {
        return E_UNEXPECTED;
    }

    ULONG celtFetched = 0;

    while (celtFetched < celt &&m_pPos)
    {
        CThumbStore::CATALOG_ENTRY *pNode = m_pStore->m_rgCatalog.GetNext(m_pPos);

        ASSERT(pNode);
        PENUMSHELLIMAGESTOREDATA pElt = (PENUMSHELLIMAGESTOREDATA) CoTaskMemAlloc(sizeof(ENUMSHELLIMAGESTOREDATA));
        if (!pElt)
        {
            // cleanup others...
            for (ULONG celtCleanup = 0; celtCleanup < celtFetched; celtCleanup++)
            {
                CoTaskMemFree(prgElt[celtCleanup]);
                prgElt[celtCleanup] = NULL;
            }

            return E_OUTOFMEMORY;
        }

        StrCpyN(pElt->szPath, pNode->szName, MAX_PATH);
        pElt->ftTimeStamp = pNode->ftTimeStamp;

        ASSERT(!IsBadWritePtr((void *) (prgElt + celtFetched), sizeof(PENUMSHELLIMAGESTOREDATA)));
        prgElt[celtFetched] = pElt;

        celtFetched++;
    }

    if (pceltFetched)
    {
        *pceltFetched = celtFetched;
    }

    if (!celtFetched)
    {
        return E_FAIL;
    }
    return (celtFetched < celt) ? S_FALSE : S_OK;
}

STDMETHODIMP CEnumThumbStore::Skip(ULONG celt)
{
    if (!celt)
    {
        return E_INVALIDARG;
    }

    if (m_dwCatalogChange != m_pStore->m_dwCatalogChange)
    {
        return E_UNEXPECTED;
    }

    ULONG celtSkipped = 0;
    while (celtSkipped < celt &&m_pPos)
    {
        m_pStore->m_rgCatalog.GetNext(m_pPos);
    }

    if (!celtSkipped)
    {
        return E_FAIL;
    }

    return (celtSkipped < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CEnumThumbStore::Clone(IEnumShellImageStore ** ppEnum)
{
    CEnumThumbStore * pEnum = new CComObject<CEnumThumbStore>;
    if (!pEnum)
    {
        return E_OUTOFMEMORY;
    }

    ((IPersistFile *)m_pStore)->AddRef();

    pEnum->m_pStore = m_pStore;
    pEnum->m_dwCatalogChange = m_dwCatalogChange;

    // created with zero ref count....
    pEnum->AddRef();

    *ppEnum = SAFECAST(pEnum, IEnumShellImageStore *);

    return S_OK;
}

HRESULT CEnumThumbStore_Create(CThumbStore * pThis, IEnumShellImageStore ** ppEnum)
{
    CEnumThumbStore * pEnum = new CComObject<CEnumThumbStore>;
    if (!pEnum)
    {
        return E_OUTOFMEMORY;
    }

    ((IPersistFile *)pThis)->AddRef();

    pEnum->m_pStore = pThis;

    // created with zero ref count....
    pEnum->AddRef();

    *ppEnum = SAFECAST(pEnum, IEnumShellImageStore *);

    return S_OK;
}

HRESULT Version1ReadImage(IStream *pStream, DWORD cbSize, HBITMAP *phImage)
{
    *phImage = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    BITMAPINFO *pbi = (BITMAPINFO *) LocalAlloc(LPTR, cbSize);
    if (pbi)
    {
        hr = IStream_Read(pStream, pbi, cbSize);
        if (SUCCEEDED(hr))
        {
            HDC hdc = GetDC(NULL);
            if (hdc)
            {
                *phImage = CreateDIBitmap(hdc, &(pbi->bmiHeader), CBM_INIT, CalcBitsOffsetInDIB(pbi), pbi, DIB_RGB_COLORS);
                ReleaseDC(NULL, hdc);
                hr = S_OK;
            }
        }
        LocalFree(pbi);
    }
    return hr;
}

HRESULT CThumbStore::ReadImage(IStream *pStream, HBITMAP *phImage)
{
    STREAM_HEADER rgHead;
    HRESULT hr = IStream_Read(pStream, &rgHead, sizeof(rgHead));
    if (SUCCEEDED(hr))
    {
        if (rgHead.cbSize == sizeof(rgHead))
        {
            if (rgHead.dwFlags == STREAMFLAGS_DIB)
            {
                hr = Version1ReadImage(pStream, rgHead.ulSize, phImage);
            }
            else if (rgHead.dwFlags == STREAMFLAGS_JPEG)
            {
                void *pBits = LocalAlloc(LPTR, rgHead.ulSize);
                if (pBits)
                {
                    hr = IStream_Read(pStream, pBits, rgHead.ulSize);
                    if (SUCCEEDED(hr))
                    {
                        if (!DecompressImage(pBits, rgHead.ulSize, phImage))
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    LocalFree(pBits);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                return E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT Version1WriteImage(IStream *pStream, HBITMAP hImage)
{
    HRESULT hr;

    BITMAPINFO *pBitmap = BitmapToDIB(hImage);
    if (pBitmap)
    {
        int ncolors = pBitmap->bmiHeader.biClrUsed;
        if (ncolors == 0 && pBitmap->bmiHeader.biBitCount <= 8)
            ncolors = 1 << pBitmap->bmiHeader.biBitCount;

        if (pBitmap->bmiHeader.biBitCount == 16 ||
            pBitmap->bmiHeader.biBitCount == 32)
        {
            if (pBitmap->bmiHeader.biCompression == BI_BITFIELDS)
            {
                ncolors = 3;
            }
        }

        int iOffset = ncolors * sizeof(RGBQUAD);

        STREAM_HEADER rgHead;
        rgHead.cbSize = sizeof(rgHead);
        rgHead.dwFlags = STREAMFLAGS_DIB;
        rgHead.ulSize = pBitmap->bmiHeader.biSize + iOffset + pBitmap->bmiHeader.biSizeImage;

        hr = IStream_Write(pStream, &rgHead, sizeof(rgHead));
        if (SUCCEEDED(hr))
        {
            hr = IStream_Write(pStream, pBitmap, rgHead.ulSize);
        }
        LocalFree(pBitmap);
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    return hr;
}

HRESULT CThumbStore::WriteImage(IStream *pStream, HBITMAP hImage)
{
    void *pBits;
    ULONG ulBuffer;

    HRESULT hr;
    if (CompressImage(hImage, &pBits, &ulBuffer))
    {
        STREAM_HEADER rgHead;
        rgHead.cbSize = sizeof(rgHead);
        rgHead.dwFlags = STREAMFLAGS_JPEG;
        rgHead.ulSize = ulBuffer;

        hr = IStream_Write(pStream, &rgHead, sizeof(rgHead));
        if (SUCCEEDED(hr))
        {
            hr = IStream_Write(pStream, pBits, ulBuffer);
        }
        CoTaskMemFree(pBits);
    }
    else
        hr = E_FAIL;
    return hr;
}

HRESULT CThumbStore::GetEntryStream(DWORD dwStream, DWORD dwMode, IStream **ppStream)
{
    WCHAR szStream[30];

    GenerateStreamName(szStream, ARRAYSIZE(szStream), dwStream);

    // leave only the STG_READ | STGM_READWRITE | STGM_WRITE modes
    dwMode &= STGM_READ | STGM_WRITE | STGM_READWRITE;

    if (!_pStorageThumb)
    {
        return E_UNEXPECTED;
    }

    if (_dwModeStorage != STGM_READWRITE && dwMode != _dwModeStorage)
    {
        return E_ACCESSDENIED;
    }

    DWORD dwFlags = GetAccessMode(dwMode, TRUE);
    if (dwFlags & STGM_WRITE)
    {
        _pStorageThumb->DestroyElement(szStream);
        return _pStorageThumb->CreateStream(szStream, dwFlags, NULL, NULL, ppStream);
    }
    else
    {
        return _pStorageThumb->OpenStream(szStream, NULL, dwFlags, NULL, ppStream);
    }
}

DWORD CThumbStore::GetAccessMode(DWORD dwMode, BOOL fStream)
{
    dwMode &= STGM_READ | STGM_WRITE | STGM_READWRITE;

    DWORD dwFlags = dwMode;

    // the root only needs Deny_Write, streams need exclusive....
    if (dwMode == STGM_READ && !fStream)
    {
        dwFlags |= STGM_SHARE_DENY_WRITE;
    }
    else
    {
        dwFlags |= STGM_SHARE_EXCLUSIVE;
    }

    return dwFlags;
}

BITMAPINFO *BitmapToDIB(HBITMAP hBmp)
{
    HDC hdcWnd = GetDC(NULL);
    HDC hMemDC = CreateCompatibleDC(hdcWnd);
    BITMAPINFO bi;
    BITMAP Bitmap;

    GetObject(hBmp, sizeof(Bitmap), (LPSTR)&Bitmap);

    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biBitCount = 0;
    int iVal = GetDIBits(hMemDC, hBmp, 0, Bitmap.bmHeight, NULL, &bi, DIB_RGB_COLORS);

    int ncolors = bi.bmiHeader.biClrUsed;
    if (ncolors == 0 && bi.bmiHeader.biBitCount <= 8)
        ncolors = 1 << bi.bmiHeader.biBitCount;

    if (bi.bmiHeader.biBitCount == 16 ||
        bi.bmiHeader.biBitCount == 32)
    {
        if (bi.bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }

    int iOffset = ncolors * sizeof(RGBQUAD);

    void *pBuffer = LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + iOffset + bi.bmiHeader.biSizeImage);
    if (pBuffer)
    {
        BITMAPINFO * pbi = (BITMAPINFO *)pBuffer;

        void *lpBits = (BYTE *)pBuffer + iOffset + sizeof(BITMAPINFOHEADER);

        // copy members of what was returned in last GetDIBits call.
        CopyMemory(&pbi->bmiHeader, &bi.bmiHeader, sizeof(BITMAPINFOHEADER));
        iVal = GetDIBits(hMemDC, hBmp, 0, Bitmap.bmHeight, lpBits,
                          pbi, DIB_RGB_COLORS);
    }

    DeleteDC(hMemDC);
    ReleaseDC(NULL, hdcWnd);
    return (BITMAPINFO *)pBuffer;
}

BOOL CThumbStore::InitCodec(void)
{
    if (NULL == m_pJPEGCodec)
    {
        m_pJPEGCodec = new CThumbnailFCNContainer();
    }

    return (NULL != m_pJPEGCodec);
}

BOOL CThumbStore::CompressImage(HBITMAP hBmp, void **ppvOutBuffer, ULONG *plBufSize)
{
    // given an HBITMAP, get its data....
    HBITMAP hBmpOut = hBmp;
    void *pBits;
    SIZE rgBmpSize;

    *ppvOutBuffer = NULL;

    if (!InitCodec())
    {
        return FALSE;
    }

    HRESULT hr = PrepImage(&hBmpOut, &rgBmpSize, &pBits);
    if (SUCCEEDED(hr))
    {
        ASSERT(pBits);

        hr = E_FAIL;
        if (pBits)
        {
            hr = m_pJPEGCodec->EncodeThumbnail(pBits, rgBmpSize.cx, rgBmpSize.cy,
                                    ppvOutBuffer, plBufSize);
        }

        if (hBmpOut != hBmp)
        {
            // free the DIBSECTION we were passed back...
            DeleteObject(hBmpOut);
        }
    }

    return SUCCEEDED(hr);
}

BOOL CThumbStore::DecompressImage(void *pvInBuffer, ULONG ulBufferSize, HBITMAP *phBmp)
{
    if (!InitCodec())
    {
        return FALSE;
    }

    ULONG ulWidth;
    ULONG ulHeight;

    HRESULT hr = m_pJPEGCodec->DecodeThumbnail(phBmp, &ulWidth, &ulHeight, pvInBuffer, ulBufferSize);
    return SUCCEEDED(hr);
}


HRESULT CThumbStore::PrepImage(HBITMAP *phBmp, SIZE * prgSize, void ** ppBits)
{
    ASSERT(phBmp && &phBmp);
    ASSERT(prgSize);
    ASSERT(ppBits);

    DIBSECTION rgDIB;

    *ppBits = NULL;

    HRESULT hr = E_FAIL;

    // is the image the wrong colour depth or not a DIBSECTION
    if (!GetObject(*phBmp, sizeof(rgDIB), &rgDIB) || (rgDIB.dsBmih.biBitCount != 32))
    {
        HBITMAP hBmp;
        BITMAP rgBmp;

        GetObject(*phBmp, sizeof(rgBmp), &rgBmp);

        prgSize->cx = rgBmp.bmWidth;
        prgSize->cy = rgBmp.bmHeight;

        // generate a 32 bit DIB of the right size
        if (!CreateSizedDIBSECTION(prgSize, 32, NULL, NULL, &hBmp, NULL, ppBits))
        {
            return E_OUTOFMEMORY;
        }

        HDC hDCMem1 = CreateCompatibleDC(NULL);
        if (hDCMem1)
        {
            HDC hDCMem2 = CreateCompatibleDC(NULL);
            if (hDCMem2)
            {
                HBITMAP hBmpOld1 = (HBITMAP) SelectObject(hDCMem1, *phBmp);
                HBITMAP hBmpOld2 = (HBITMAP) SelectObject(hDCMem2, hBmp);

                // copy the image accross to generate the right sized DIB
                BitBlt(hDCMem2, 0, 0, prgSize->cx, prgSize->cy, hDCMem1, 0, 0, SRCCOPY);

                SelectObject(hDCMem1, hBmpOld1);
                SelectObject(hDCMem2, hBmpOld2);

                DeleteDC(hDCMem2);
            }
            DeleteDC(hDCMem1);
        }

        // pass back the BMP so it can be destroyed later...
        *phBmp = hBmp;
        return S_OK;
    }
    else
    {
        // HOUSTON, we have a DIBSECTION, this is quicker.....
        *ppBits = rgDIB.dsBm.bmBits;

        prgSize->cx = rgDIB.dsBm.bmWidth;
        prgSize->cy = rgDIB.dsBm.bmHeight;

        return S_OK;
    }
}

HRESULT DeleteFileThumbnail(LPCWSTR szFilePath)
{
    WCHAR szFolder[MAX_PATH];
    WCHAR *szFile;
    HRESULT hr = S_OK;

    StrCpyNW(szFolder, szFilePath, ARRAYSIZE(szFolder));
    if (SUCCEEDED(hr))
    {
        szFile = PathFindFileName(szFolder);
        if (szFile != szFolder)
        {
            *(szFile - 1) = 0; // NULL terminates folder
            
            IShellImageStore *pDiskCache = NULL;
            hr = LoadFromFile(CLSID_ShellThumbnailDiskCache, szFolder, IID_PPV_ARG(IShellImageStore, &pDiskCache));
            if (SUCCEEDED(hr))
            {
                IPersistFile *pPersist = NULL;
                hr = pDiskCache->QueryInterface(IID_PPV_ARG(IPersistFile, &pPersist));
                if (SUCCEEDED(hr))
                {
                    hr = pPersist->Load(szFolder, STGM_READWRITE);
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwLock;
                        hr = pDiskCache->Open(STGM_READWRITE, &dwLock);
                        if (SUCCEEDED(hr))
                        {
                            hr = pDiskCache->DeleteEntry(szFile);
                            pDiskCache->ReleaseLock(&dwLock);
                            pDiskCache->Close(NULL);
                        }
                    }
                    pPersist->Release();
                }
                pDiskCache->Release();
            }      
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\subdata.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "subdata.h"

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
BOOL CSubData::Init(CSubDataProvider* pSDProv, SUBDATACB fctCB, PVOID pvData)
{
    _pSDProv = pSDProv;
    _fctCB = fctCB;

    _pvData = pvData;

#ifdef DEBUG
    ASSERT(!_fInited);
    _fInited = TRUE;
#endif

    return TRUE;
}

BOOL CSubData::InitStatic(STATICSUBDATACB fctStaticCB, PVOID pvData)
{
    _fStatic = TRUE;

    _fctStaticCB = fctStaticCB;

    _pvData = pvData;

#ifdef DEBUG
    ASSERT(!_fInited);
    _fInited = TRUE;
#endif
    
    return TRUE;
}

BOOL CSubData::InitExpiration(DWORD cTick)
{
    ASSERT(_fInited);

    _cTickExpiration = cTick;

    return TRUE;
}

BOOL CSubData::Update()
{
    ASSERT(_fInited);

    BOOL fNeedUpdate = FALSE;
    BOOL fRet = TRUE;

    if (!_fHoldUpdate)
    {
        // Check if we need to update the info?

        if (_IsValid())
        {
            // Did we at least update once?
            if (!_GetTickLastUpdate())
            {
                // No
                fNeedUpdate = TRUE;
            }
            else
            {
                // Is the information expired?
                if (_IsExpired())
                {
                    // Yes
                    fNeedUpdate = TRUE;
                }
            }
        }

        if (!_IsValid() || fNeedUpdate)
        {
            _fInvalid = FALSE;

            fRet = _Call();
        }

        // TBDTBD: in DEBUG_PARANOID do call anyway to see if accurate
    }

    return fRet;
}

void CSubData::HoldUpdates()
{
    ASSERT(_fInited);

    _fHoldUpdate = TRUE;
}

void CSubData::ResumeUpdates()
{
    ASSERT(_fInited);

    _fHoldUpdate = FALSE;
}

void CSubData::Invalidate()
{
    _fInvalid = TRUE;
}

CSubData::CSubData() : _cTickExpiration(EXPIRATION_NEVER)
{}
///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////
BOOL CSubData::_Call()
{
    // TBDTBD: Getsystemtime for stats

    BOOL fRet = TRUE;

    if (!_fStatic)
    {
        if (_fctCB)
        {
            // Calling with the CSubDataProvider ptr the passed in
            // CSubDataProvider's member fct
            fRet = (_pSDProv->*_fctCB)(_GetDataPtr());
        }
    }
    else
    {
        if (_fctStaticCB)
        {
            fRet = _fctStaticCB(_GetDataPtr());
        }
    }

    _SetTickLastUpdate(GetTickCount());

    return fRet;
}

void CSubData::_SetTickLastUpdate(DWORD dwTick)
{
    _dwTickLast = dwTick;
}

DWORD CSubData::_GetTickLastUpdate()
{
    return _dwTickLast;
}

DWORD* CSubData::_GetTickLastUpdatePtr()
{
    return &_dwTickLast;
}

PVOID CSubData::_GetDataPtr()
{
    ASSERT(_pvData);

    return _pvData;
}

void CSubData::_SetDataPtr(PVOID pvData)
{
    _pvData = pvData;
}

BOOL CSubData::_IsExpired()
{
    BOOL fExpired = FALSE;
    DWORD dwTickCurrent = GetTickCount();

    // Is the information expired?  Check also for the wrapping case.
    if ((EXPIRATION_NEVER != _cTickExpiration) && ((_GetTickLastUpdate() > dwTickCurrent) || 
        ((dwTickCurrent - _GetTickLastUpdate()) > _cTickExpiration)))
    {
        // Yes
        fExpired = TRUE;
    }

    return fExpired;
}

BOOL CSubData::_IsValid()
{
    return !_fInvalid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\switchuserdialog.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: SwitchUserDialog.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements presentation of the Switch User dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

#include "shellprv.h"
#include "SwitchUserDialog.h"

#include <msginaexports.h>
#include <shlwapi.h>

#include "ids.h"
#include "tooltip.h"

#define DISPLAYMSG(x)   ASSERTMSG(false, x)

EXTERN_C    HINSTANCE   g_hinst;

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::CSwitchUserDialog
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process/DLL.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CSwitchUserDialog. This initializes member
//              variables and loads resources used by the dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

CSwitchUserDialog::CSwitchUserDialog (HINSTANCE hInstance) :
    _hInstance(hInstance),
    _hbmBackground(NULL),
    _hbmFlag(NULL),
    _hbmButtons(NULL),
    _hfntTitle(NULL),
    _hfntButton(NULL),
    _hpltShell(NULL),
    _lButtonHeight(0),
    _uiHoverID(0),
    _uiFocusID(0),
    _fSuccessfulInitialization(false),
    _fDialogEnded(false),
    _pTooltip(NULL)

{
    bool        fUse8BitDepth;
    HDC         hdcScreen;
    LOGFONT     logFont;
    char        szPixelSize[10];
    BITMAP      bitmap;

    TBOOL(SetRect(&_rcBackground, 0, 0, 0, 0));
    TBOOL(SetRect(&_rcFlag, 0, 0, 0, 0));
    TBOOL(SetRect(&_rcButtons, 0, 0, 0, 0));

    hdcScreen = GetDC(NULL);

    //  8-bit color?

    fUse8BitDepth = (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8);

    //  Load the bitmaps.

    _hbmBackground = static_cast<HBITMAP>(LoadImage(_hInstance,
                                                    MAKEINTRESOURCE(fUse8BitDepth ? IDB_BACKGROUND_8 : IDB_BACKGROUND_24),
                                                    IMAGE_BITMAP,
                                                    0,
                                                    0,
                                                    LR_CREATEDIBSECTION));
    if ((_hbmBackground != NULL) && (GetObject(_hbmBackground, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcBackground, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
    }
    _hbmFlag = static_cast<HBITMAP>(LoadImage(_hInstance,
                                              MAKEINTRESOURCE(fUse8BitDepth ? IDB_FLAG_8 : IDB_FLAG_24),
                                              IMAGE_BITMAP,
                                              0,
                                              0,
                                              LR_CREATEDIBSECTION));
    if ((_hbmFlag != NULL) && (GetObject(_hbmFlag, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcFlag, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
    }
    _hbmButtons = static_cast<HBITMAP>(LoadImage(_hInstance,
                                                 MAKEINTRESOURCE(IDB_BUTTONS),
                                                 IMAGE_BITMAP,
                                                 0,
                                                 0,
                                                 LR_CREATEDIBSECTION));
    if ((_hbmButtons != NULL) && (GetObject(_hbmButtons, sizeof(bitmap), &bitmap) >= sizeof(bitmap)))
    {
        TBOOL(SetRect(&_rcButtons, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
        _lButtonHeight = bitmap.bmHeight / (BUTTON_GROUP_MAX * BUTTON_STATE_MAX);
    }

    //  Create fonts. Load the font name and size from resources.

    ZeroMemory(&logFont, sizeof(logFont));
    if (LoadStringA(_hInstance,
                    IDS_SWITCHUSER_TITLE_FACESIZE,
                    szPixelSize,
                    ARRAYSIZE(szPixelSize)) != 0)
    {
        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdcScreen, LOGPIXELSY), 72);
        if (LoadString(_hInstance,
                       IDS_SWITCHUSER_TITLE_FACENAME,
                       logFont.lfFaceName,
                       LF_FACESIZE) != 0)
        {
            logFont.lfWeight = FW_MEDIUM;
            logFont.lfQuality = DEFAULT_QUALITY;
            _hfntTitle = CreateFontIndirect(&logFont);
        }
    }
    ZeroMemory(&logFont, sizeof(logFont));
    if (LoadStringA(_hInstance,
                    IDS_SWITCHUSER_BUTTON_FACESIZE,
                    szPixelSize,
                    ARRAYSIZE(szPixelSize)) != 0)
    {
        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdcScreen, LOGPIXELSY), 72);
        if (LoadString(_hInstance,
                       IDS_SWITCHUSER_BUTTON_FACENAME,
                       logFont.lfFaceName,
                       LF_FACESIZE) != 0)
        {
            logFont.lfWeight = FW_BOLD;
            logFont.lfQuality = DEFAULT_QUALITY;
            _hfntButton = CreateFontIndirect(&logFont);
        }
    }

    //  Load the shell palette.

    _hpltShell = SHCreateShellPalette(hdcScreen);

    TBOOL(ReleaseDC(NULL, hdcScreen));

    //  Check for presence of all required resources.

    _fSuccessfulInitialization = ((_hfntTitle != NULL) &&
                                  (_hfntButton != NULL) &&
                                  (_hpltShell != NULL) &&
                                  (_hbmButtons != NULL) &&
                                  (_hbmFlag != NULL) &&
                                  (_hbmBackground != NULL));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::~CSwitchUserDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CSwitchUserDialog. Release used resources and
//              unregister the window class.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

CSwitchUserDialog::~CSwitchUserDialog (void)

{
    ASSERTMSG(_pTooltip == NULL, "_pTooltip not released in CSwitchUserDialog::~CSwitchUserDialog");

    //  Release everything we allocated/loaded.

    if (_hpltShell != NULL)
    {
        TBOOL(DeleteObject(_hpltShell));
        _hpltShell = NULL;
    }
    if (_hfntButton != NULL)
    {
        TBOOL(DeleteObject(_hfntButton));
        _hfntButton = NULL;
    }
    if (_hfntTitle != NULL)
    {
        TBOOL(DeleteObject(_hfntTitle));
        _hfntTitle = NULL;
    }
    if (_hbmButtons != NULL)
    {
        TBOOL(DeleteObject(_hbmButtons));
        _hbmButtons = NULL;
    }
    if (_hbmFlag != NULL)
    {
        TBOOL(DeleteObject(_hbmFlag));
        _hbmFlag = NULL;
    }
    if (_hbmBackground != NULL)
    {
        TBOOL(DeleteObject(_hbmBackground));
        _hbmBackground = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Show
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Presents the "Switch User" dialog to the user and returns the
//              result of the dialog back to the caller.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

DWORD   CSwitchUserDialog::Show (HWND hwndParent)

{
    INT_PTR     iResult;

    if (_fSuccessfulInitialization)
    {
        IUnknown    *pIUnknown;

        //  If no parent was given the create our own dimmed window.

        if (hwndParent == NULL)
        {
            if (FAILED(ShellDimScreen(&pIUnknown, &hwndParent)))
            {
                pIUnknown = NULL;
                hwndParent = NULL;
            }
        }
        else
        {
            pIUnknown = NULL;
        }

        //  Show the dialog and get a result.

        iResult = DialogBoxParam(_hInstance,
                                 MAKEINTRESOURCE(DLG_SWITCHUSER),
                                 hwndParent,
                                 CB_DialogProc,
                                 reinterpret_cast<LPARAM>(this));
        if (pIUnknown != NULL)
        {
            pIUnknown->Release();
        }
    }
    else
    {
        iResult = 0;
    }
    return(static_cast<DWORD>(iResult));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::PaintBitmap
//
//  Arguments:  hdcDestination  =   HDC to paint into.
//              prcDestination  =   RECT in HDC to paint into.
//              hbmSource       =   HBITMAP to paint.
//              prcSource       =   RECT from HBITMAP to paint from.
//
//  Returns:    <none>
//
//  Purpose:    Wraps blitting a bitmap.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//              2001-03-17  vtan        added source RECT for strip blitting
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::PaintBitmap (HDC hdcDestination, const RECT *prcDestination, HBITMAP hbmSource, const RECT *prcSource)

{
    HDC     hdcBitmap;

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap != NULL)
    {
        bool        fEqualWidthAndHeight;
        int         iWidthSource, iHeightSource, iWidthDestination, iHeightDestination;
        int         iStretchBltMode;
        DWORD       dwLayout;
        HBITMAP     hbmSelected;
        RECT        rcSource;
        BITMAP      bitmap;

        if (prcSource == NULL)
        {
            if (GetObject(hbmSource, sizeof(bitmap), &bitmap) == 0)
            {
                bitmap.bmWidth = prcDestination->right - prcDestination->left;
                bitmap.bmHeight = prcDestination->bottom - prcDestination->top;
            }
            TBOOL(SetRect(&rcSource, 0, 0, bitmap.bmWidth, bitmap.bmHeight));
            prcSource = &rcSource;
        }
        hbmSelected = static_cast<HBITMAP>(SelectObject(hdcBitmap, hbmSource));
        iWidthSource = prcSource->right - prcSource->left;
        iHeightSource = prcSource->bottom - prcSource->top;
        iWidthDestination = prcDestination->right - prcDestination->left;
        iHeightDestination = prcDestination->bottom - prcDestination->top;
        fEqualWidthAndHeight = (iWidthSource == iWidthDestination) && (iHeightSource == iHeightDestination);
        if (!fEqualWidthAndHeight)
        {
            iStretchBltMode = SetStretchBltMode(hdcDestination, HALFTONE);
        }
        else
        {
            iStretchBltMode = 0;
        }
        dwLayout = SetLayout(hdcDestination, LAYOUT_BITMAPORIENTATIONPRESERVED);
        TBOOL(TransparentBlt(hdcDestination,
                             prcDestination->left,
                             prcDestination->top,
                             iWidthDestination,
                             iHeightDestination,
                             hdcBitmap,
                             prcSource->left,
                             prcSource->top,
                             iWidthSource,
                             iHeightSource,
                             RGB(255, 0, 255)));
        (DWORD)SetLayout(hdcDestination, dwLayout);
        if (!fEqualWidthAndHeight)
        {
            (int)SetStretchBltMode(hdcDestination, iStretchBltMode);
        }
        (HGDIOBJ)SelectObject(hdcBitmap, hbmSelected);
        TBOOL(DeleteDC(hdcBitmap));
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::RemoveTooltip
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Removes the tooltip if present. This can be accessed from two
//              different threads so make sure that it's serialized.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::RemoveTooltip (void)

{
    CTooltip    *pTooltip;

    pTooltip = static_cast<CTooltip*>(InterlockedExchangePointer(reinterpret_cast<void**>(&_pTooltip), NULL));
    if (pTooltip != NULL)
    {
        delete pTooltip;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::FilterMetaCharacters
//
//  Arguments:  pszText     =   String to filter.
//
//  Returns:    <none>
//
//  Purpose:    Filters meta-characters from the given string.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::FilterMetaCharacters (TCHAR *pszText)

{
    TCHAR   *pTC;

    pTC = pszText;
    while (*pTC != TEXT('\0'))
    {
        if (*pTC == TEXT('&'))
        {
            (TCHAR*)lstrcpy(pTC, pTC + 1);
        }
        else
        {
            ++pTC;
        }
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::EndDialog
//
//  Arguments:  hwnd        =   HWND of dialog.
//              iResult     =   Result to end dialog with.
//
//  Returns:    <none>
//
//  Purpose:    Removes the tool tip if present. Ends the dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::EndDialog (HWND hwnd, INT_PTR iResult)

{
    RemoveTooltip();

    //  Set the dialog end member variable here. This will cause the WM_ACTIVATE
    //  handler to ignore the deactivation associated with ending the dialog. If
    //  it doesn't ignore it then it thinks the dialog is being deactivated
    //  because another dialog is activating and ends the dialog with SHTDN_NONE.

    _fDialogEnded = true;
    TBOOL(::EndDialog(hwnd, iResult));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_BN_CLICKED
//
//  Arguments:  hwnd    =   HWND of dialog.
//              wID     =   ID of control.
//
//  Returns:    <none>
//
//  Purpose:    Handles clicks in the bitmap buttons and sets the return
//              result according to the button pressed.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_BN_CLICKED (HWND hwnd, WORD wID)

{
    switch (wID)
    {
        case IDCANCEL:
            EndDialog(hwnd, SHTDN_NONE);
            break;
        case IDC_BUTTON_SWITCHUSER:
            EndDialog(hwnd, SHTDN_DISCONNECT);
            break;
        case IDC_BUTTON_LOGOFF:
            EndDialog(hwnd, SHTDN_LOGOFF);
            break;
        default:
            break;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_INITDIALOG
//
//  Arguments:  hwnd    =   HWND of this window.
//
//  Returns:    <none>
//
//  Purpose:    Handles WM_INITDIALOG message. Centre the dialog on the main
//              monitor. Subclass the buttons so that we can get hover state
//              correctly implemented.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_INITDIALOG (HWND hwnd)

{
    RECT    rc;

    //  Center the dialog on the main monitor.

    TBOOL(GetClientRect(hwnd, &rc));
    TBOOL(SetWindowPos(hwnd,
                       HWND_TOP,
                       (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2,
                       (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 3,
                       0,
                       0,
                       SWP_NOSIZE));

    //  Subclass buttons for tooltips and cursor control.

    TBOOL(SetWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_SWITCHUSER), ButtonSubClassProc, IDC_BUTTON_SWITCHUSER, reinterpret_cast<DWORD_PTR>(this)));
    TBOOL(SetWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_LOGOFF), ButtonSubClassProc, IDC_BUTTON_LOGOFF, reinterpret_cast<DWORD_PTR>(this)));

    //  Set the focus to the "Switch User" button.

    (HWND)SetFocus(GetDlgItem(hwnd, IDC_BUTTON_SWITCHUSER));
    _uiFocusID = IDC_BUTTON_SWITCHUSER;
    (LRESULT)SendMessage(hwnd, DM_SETDEFID, _uiFocusID, 0);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_DESTROY
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Removes the subclassing of the button windows and can do any
//              other clean up required in WM_DESTROY.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_DESTROY (HWND hwnd)

{
    TBOOL(RemoveWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_LOGOFF), ButtonSubClassProc, IDC_BUTTON_LOGOFF));
    TBOOL(RemoveWindowSubclass(GetDlgItem(hwnd, IDC_BUTTON_SWITCHUSER), ButtonSubClassProc, IDC_BUTTON_SWITCHUSER));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_ERASEBKGND
//
//  Arguments:  hwnd        =   HWND to erase.
//              hdcErase    =   HDC to paint.
//
//  Returns:    <none>
//
//  Purpose:    Erases the background.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_ERASEBKGND (HWND hwnd, HDC hdcErase)

{
    RECT    rc;

    TBOOL(GetClientRect(hwnd, &rc));
    PaintBitmap(hdcErase, &rc, _hbmBackground, &_rcBackground);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_PRINTCLIENT
//
//  Arguments:  hwnd        =   HWND to erase.
//              hdcErase    =   HDC to paint.
//              dwOptions   =   Options for drawing.
//
//  Returns:    <none>
//
//  Purpose:    Handles painting the client area for WM_PRINTCLIENT.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_PRINTCLIENT (HWND hwnd, HDC hdcPrint, DWORD dwOptions)

{
    if ((dwOptions & (PRF_ERASEBKGND | PRF_CLIENT)) != 0)
    {
        Handle_WM_ERASEBKGND(hwnd, hdcPrint);
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_ACTIVATE
//
//  Arguments:  hwnd        =   HWND to erase.
//              dwState     =   Activate state.
//
//  Returns:    <none>
//
//  Purpose:    Detects if this window is becoming inactive. In this case
//              end the dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_ACTIVATE (HWND hwnd, DWORD dwState)

{
    if ((WA_INACTIVE == dwState) && !_fDialogEnded)
    {
        EndDialog(hwnd, SHTDN_NONE);
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_DRAWITEM
//
//  Arguments:  hwnd    =   HWND of the parent window.
//              pDIS    =   DRAWITEMSTRUCT defining what to draw.
//
//  Returns:    <none>
//
//  Purpose:    Draws several aspects of the turn off dialog. It handles the
//              title text, the owner draw bitmap buttons, the text for the
//              bitmap buttons and the separator line.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_DRAWITEM (HWND hwnd, const DRAWITEMSTRUCT *pDIS)

{
    HPALETTE    hPaletteOld;
    HFONT       hfntSelected;
    int         iBkMode;
    COLORREF    colorText;
    RECT        rc;
    SIZE        size;
    TCHAR       szText[256];

    hPaletteOld = SelectPalette(pDIS->hDC, _hpltShell, FALSE);
    (UINT)RealizePalette(pDIS->hDC);
    switch (pDIS->CtlID)
    {
        case IDC_BUTTON_SWITCHUSER:
        case IDC_BUTTON_LOGOFF:
        {
            int     iState, iGroup;

            //  Select the correct state index to use. Check for ODS_SELECTED first.
            //  Then check for hover or ODS_FOCUS. Otherwise use the rest state.

            if ((pDIS->itemState & ODS_SELECTED) != 0)
            {
                iState = BUTTON_STATE_DOWN;
            }
            else if ((_uiHoverID == pDIS->CtlID) || ((pDIS->itemState & ODS_FOCUS) != 0))
            {
                iState = BUTTON_STATE_HOVER;
            }
            else
            {
                iState = BUTTON_STATE_REST;
            }

            //  Now select the correct bitmap based on the state index.

            switch (pDIS->CtlID)
            {
                case IDC_BUTTON_SWITCHUSER:
                    iGroup = BUTTON_GROUP_SWITCHUSER;
                    break;
                case IDC_BUTTON_LOGOFF:
                    iGroup = BUTTON_GROUP_LOGOFF;
                    break;
                default:
                    iGroup = -1;
                    DISPLAYMSG("This should never be executed");
                    break;
            }
            if (iGroup >= 0)
            {
                RECT    rc;

                //  Calculate which part of the background to blit into the DC.
                //  Only blit the amount that's necessary to avoid excessive
                //  blitting. Once blitted then blit the button BMP. The blit
                //  uses msimg32!TransparentBlt with the magical magenta color.

                TBOOL(CopyRect(&rc, &_rcBackground));
                (int)MapWindowPoints(pDIS->hwndItem, hwnd, reinterpret_cast<POINT*>(&rc), sizeof(RECT) / sizeof(POINT));
                rc.right = rc.left + (_rcButtons.right - _rcButtons.left);
                rc.bottom = rc.top + _lButtonHeight;
                PaintBitmap(pDIS->hDC, &pDIS->rcItem, _hbmBackground, &rc);
                TBOOL(CopyRect(&rc, &_rcButtons));
                rc.top = ((iGroup * BUTTON_STATE_MAX) + iState) * _lButtonHeight;
                rc.bottom = rc.top + _lButtonHeight;
                PaintBitmap(pDIS->hDC, &pDIS->rcItem, _hbmButtons, &rc);
            }
            break;
        }
        case IDC_TITLE_FLAG:
        {
            BITMAP      bitmap;

            TBOOL(GetClientRect(pDIS->hwndItem, &rc));
            if (GetObject(_hbmFlag, sizeof(bitmap), &bitmap) != 0)
            {
                rc.left += ((rc.right - rc.left) - bitmap.bmWidth) / 2;
                rc.right = rc.left + bitmap.bmWidth;
                rc.top += ((rc.bottom - rc.top) - bitmap.bmHeight) / 2;
                rc.bottom = rc.top + bitmap.bmHeight;
            }
            PaintBitmap(pDIS->hDC, &rc, _hbmFlag, &_rcFlag);
            break;
        }
        case IDC_TITLE_SWITCHUSER:
        {

            //  Draw the title of the dialog "Log Off Windows".

            hfntSelected = static_cast<HFONT>(SelectObject(pDIS->hDC, _hfntTitle));
            colorText = SetTextColor(pDIS->hDC, 0x00FFFFFF);
            iBkMode = SetBkMode(pDIS->hDC, TRANSPARENT);
            (int)GetWindowText(GetDlgItem(hwnd, pDIS->CtlID), szText, ARRAYSIZE(szText));
            TBOOL(GetTextExtentPoint(pDIS->hDC, szText, lstrlen(szText), &size));
            TBOOL(CopyRect(&rc, &pDIS->rcItem));
            TBOOL(InflateRect(&rc, 0, -((rc.bottom - rc.top - size.cy) / 2)));
            (int)DrawText(pDIS->hDC, szText, -1, &rc, 0);
            (int)SetBkMode(pDIS->hDC, iBkMode);
            (COLORREF)SetTextColor(pDIS->hDC, colorText);
            (HGDIOBJ)SelectObject(pDIS->hDC, hfntSelected);
            break;
        }
        case IDC_TEXT_SWITCHUSER:
        case IDC_TEXT_LOGOFF:
        {
            int     iPixelHeight, iButtonID;
            RECT    rcText;

            //  The text to display is based on the button title. Map the static
            //  text ID to a "parent" button ID. Special case IDC_TEXT_STANDBY.

            switch (pDIS->CtlID)
            {
                case IDC_TEXT_SWITCHUSER:
                    iButtonID = IDC_BUTTON_SWITCHUSER;
                    break;
                case IDC_TEXT_LOGOFF:
                    iButtonID = IDC_BUTTON_LOGOFF;
                    break;
                default:
                    iButtonID = 0;
                    DISPLAYMSG("This should never be executed");
                    break;
            }
            hfntSelected = static_cast<HFONT>(SelectObject(pDIS->hDC, _hfntButton));
            colorText = SetTextColor(pDIS->hDC, RGB(255, 255, 255));
            iBkMode = SetBkMode(pDIS->hDC, TRANSPARENT);
            (int)GetWindowText(GetDlgItem(hwnd, iButtonID), szText, ARRAYSIZE(szText));
            TBOOL(CopyRect(&rcText, &pDIS->rcItem));
            iPixelHeight = DrawText(pDIS->hDC, szText, -1, &rcText, DT_CALCRECT);
            TBOOL(CopyRect(&rc, &pDIS->rcItem));
            TBOOL(InflateRect(&rc, -((rc.right - rc.left - (rcText.right - rcText.left)) / 2), -((rc.bottom - rc.top - iPixelHeight) / 2)));
            (int)DrawText(pDIS->hDC, szText, -1, &rc, ((pDIS->itemState & ODS_NOACCEL ) != 0) ? DT_HIDEPREFIX : 0);
            (int)SetBkMode(pDIS->hDC, iBkMode);
            (COLORREF)SetTextColor(pDIS->hDC, colorText);
            (HGDIOBJ)SelectObject(pDIS->hDC, hfntSelected);
            break;
        }
        default:
        {
            DISPLAYMSG("Unknown control ID passed to CSwitchUserDialog::Handle_WM_DRAWITEM");
            break;
        }
    }
    (HGDIOBJ)SelectPalette(pDIS->hDC, hPaletteOld, FALSE);
    (UINT)RealizePalette(pDIS->hDC);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_COMMAND
//
//  Arguments:  hwnd    =   HWND of dialog.
//              wParam  =   WPARAM (see platform SDK under WM_COMMAND).
//
//  Returns:    <none>
//
//  Purpose:    Handles clicks in the bitmap buttons and sets the return
//              result according to the button pressed.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_COMMAND (HWND hwnd, WPARAM wParam)

{
    switch (HIWORD(wParam))
    {
        case BN_CLICKED:
            Handle_BN_CLICKED(hwnd, LOWORD(wParam));
            break;
        default:
            break;
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_MOUSEMOVE
//
//  Arguments:  hwnd    =   HWND of the control.
//              uiID    =   ID of the control.
//
//  Returns:    <none>
//
//  Purpose:    Sets the cursor to a hand and tracks mouse movement in the
//              control. Refresh the control to show the hover state.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_MOUSEMOVE (HWND hwnd, UINT uiID)

{
    (HCURSOR)SetCursor(LoadCursor(NULL, IDC_HAND));
    if (uiID != _uiHoverID)
    {
        TRACKMOUSEEVENT     tme;

        _uiHoverID = uiID;
        tme.cbSize = sizeof(tme);
        tme.dwFlags = TME_HOVER | TME_LEAVE;
        tme.hwndTrack = hwnd;
        tme.dwHoverTime = HOVER_DEFAULT;
        TBOOL(TrackMouseEvent(&tme));
        TBOOL(InvalidateRect(hwnd, NULL, FALSE));
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_MOUSEHOVER
//
//  Arguments:  hwnd    =   HWND of the control.
//              uiID    =   ID of the control.
//
//  Returns:    <none>
//
//  Purpose:    Handles hovering over the control. Determine which tooltip to
//              bring up and show it.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_MOUSEHOVER (HWND hwnd, UINT uiID)

{
    int     iTextID;

    switch (uiID)
    {
        case IDC_BUTTON_SWITCHUSER:
            iTextID = IDS_SWITCHUSER_TOOLTIP_TEXT_SWITCHUSER;
            break;
        case IDC_BUTTON_LOGOFF:
            iTextID = IDS_SWITCHUSER_TOOLTIP_TEXT_LOGOFF;
            break;
        default:
            iTextID = 0;
            break;
    }

    //  Construct the tooltip and show it.

    if (iTextID != 0)
    {
        int     iCaptionLength;
        TCHAR   *pszCaption;

        iCaptionLength = GetWindowTextLength(hwnd) + sizeof('\0');
        pszCaption = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, iCaptionLength * sizeof(TCHAR)));
        if (pszCaption != NULL)
        {
            if (GetWindowText(hwnd, pszCaption, iCaptionLength) != 0)
            {
                _pTooltip = new CTooltip(_hInstance, hwnd);
                if (_pTooltip != NULL)
                {
                    TCHAR   szText[256];

                    if (LoadString(_hInstance, iTextID, szText + sizeof('\r') + sizeof('\n'), ARRAYSIZE(szText) - sizeof('\r') - sizeof('\n')) != 0)
                    {
                        FilterMetaCharacters(pszCaption);
                        szText[0] = TEXT('\r');
                        szText[1] = TEXT('\n');
                        _pTooltip->SetPosition();
                        _pTooltip->SetCaption(0, pszCaption);
                        _pTooltip->SetText(szText);
                        _pTooltip->Show();
                    }
                }
            }
            (HLOCAL)LocalFree(pszCaption);
        }
    }
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::Handle_WM_MOUSELEAVE
//
//  Arguments:  hwnd    =   HWND of the control.
//
//  Returns:    <none>
//
//  Purpose:    Removes the tooltip and clears the hover ID.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

void    CSwitchUserDialog::Handle_WM_MOUSELEAVE (HWND hwnd)

{
    RemoveTooltip();
    _uiHoverID = 0;
    TBOOL(InvalidateRect(hwnd, NULL, FALSE));
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::CB_DialogProc
//
//  Arguments:  See the platform SDK under DialogProc.
//
//  Returns:    See the platform SDK under DialogProc.
//
//  Purpose:    Main DialogProc dispatch entry point for the turn off dialog.
//              To keep this simple it calls member functions.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CSwitchUserDialog::CB_DialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    INT_PTR             iResult;
    CSwitchUserDialog   *pThis;

    pThis = reinterpret_cast<CSwitchUserDialog*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CSwitchUserDialog*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pThis));
            pThis->Handle_WM_INITDIALOG(hwnd);
            iResult = FALSE;
            break;
        case WM_DESTROY:
            pThis->Handle_WM_DESTROY(hwnd);
            iResult = 0;
            break;
        case WM_ERASEBKGND:
            pThis->Handle_WM_ERASEBKGND(hwnd, reinterpret_cast<HDC>(wParam));
            iResult = 1;
            break;
        case WM_PRINTCLIENT:
            pThis->Handle_WM_PRINTCLIENT(hwnd, reinterpret_cast<HDC>(wParam), static_cast<DWORD>(lParam));
            iResult = 1;        //  This tells the button that it was handled.
            break;
        case WM_ACTIVATE:
            pThis->Handle_WM_ACTIVATE(hwnd, static_cast<DWORD>(wParam));
            iResult = 1;
            break;
        case WM_DRAWITEM:
            pThis->Handle_WM_DRAWITEM(hwnd, reinterpret_cast<DRAWITEMSTRUCT*>(lParam));
            iResult = TRUE;
            break;
        case WM_COMMAND:
            pThis->Handle_WM_COMMAND(hwnd, wParam);
            iResult = 0;
            break;
        default:
            iResult = 0;
            break;
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::ButtonSubClassProc
//
//  Arguments:  hwnd        =   See the platform SDK under WindowProc.
//              uMsg        =   See the platform SDK under WindowProc.
//              wParam      =   See the platform SDK under WindowProc.
//              lParam      =   See the platform SDK under WindowProc.
//              uiID        =   ID assigned at subclass time.
//              dwRefData   =   reference data assigned at subclass time.
//
//  Returns:    LRESULT
//
//  Purpose:    comctl32 subclass callback function. This allows the bitmap
//              buttons to hover and track accordingly. This also allows our
//              BS_OWNERDRAW buttons to be pushed when the keyboard is used.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    CSwitchUserDialog::ButtonSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData)

{
    LRESULT             lResult;
    CSwitchUserDialog   *pThis;

    pThis = reinterpret_cast<CSwitchUserDialog*>(dwRefData);
    switch (uMsg)
    {

        //  Do NOT allow BM_SETSTYLE to go thru to the default handler. This is
        //  because DLGC_UNDEFPUSHBUTTON is returned for WM_GETDLGCODE. When the
        //  dialog manager sees this it tries to set the focus style on the button.
        //  Even though it's owner drawn the button window proc still draws the
        //  focus state (because we returned DLGC_UNDEFPUSHBUTTON). Therefore to
        //  ensure the bitmap isn't over-painted by the button window proc blow off
        //  the BM_SETSTYLE and don't let it get to the button window proc.

        case BM_SETSTYLE:
            if (wParam == BS_DEFPUSHBUTTON)
            {
                pThis->_uiFocusID = static_cast<UINT>(uiID);
            }
            if (uiID != IDCANCEL)
            {
                lResult = 0;
                break;
            }
            //  Fall thru
        default:

            //  Otherwise in the default case let the default handler at the message
            //  first. This implements tail-patching.

            lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            switch (uMsg)
            {
                case DM_GETDEFID:
                    lResult = (DC_HASDEFID << 16) | static_cast<WORD>(pThis->_uiFocusID);
                    break;
                case WM_GETDLGCODE:
                    if (uiID == pThis->_uiFocusID)
                    {
                        lResult |= DLGC_DEFPUSHBUTTON;
                    }
                    else
                    {
                        lResult |= DLGC_UNDEFPUSHBUTTON;
                    }
                    break;
                case WM_MOUSEMOVE:
                    pThis->Handle_WM_MOUSEMOVE(hwnd, static_cast<UINT>(uiID));
                    break;
                case WM_MOUSEHOVER:
                    pThis->Handle_WM_MOUSEHOVER(hwnd, static_cast<UINT>(uiID));
                    break;
                case WM_MOUSELEAVE:
                    pThis->Handle_WM_MOUSELEAVE(hwnd);
                    break;
                default:
                    break;
            }
    }
    return(lResult);
}

EXTERN_C    DWORD   SwitchUserDialog_Show (HWND hwndParent)

{
    CSwitchUserDialog   switchUserDialog(g_hinst);

    return(switchUserDialog.Show(hwndParent));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\syreclen.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <regstr.h>
#include <olectl.h>
#include <tlhelp32.h>

class CSystemRestoreCleaner : public IFileSystemRestoreDialog
{
private:
	LONG _cRef;
	
public:
	CSystemRestoreCleaner(void);
	~CSystemRestoreCleaner(void);
	STDMETHODIMP ShowProperties(HWND hwnd);
	
	// IUnknown
	STDMETHODIMP QueryInterface (REFIID, void **);
	STDMETHODIMP_(ULONG)    AddRef (void);
	STDMETHODIMP_(ULONG)    Release (void);
	
	// IFileSystemRestoreDialog interface members
	STDMETHODIMP CanShowFileSystemRestoreDialog(void);
	STDMETHODIMP ShowFileSystemRestoreDialog(HWND hwnd);  //hwnd points to the parent window.
};


CSystemRestoreCleaner::CSystemRestoreCleaner(void)
{
    _cRef = 1;
}

CSystemRestoreCleaner::~CSystemRestoreCleaner(void)
{
}

STDMETHODIMP CSystemRestoreCleaner::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSystemRestoreCleaner, IFileSystemRestoreDialog),
        QITABENT(CSystemRestoreCleaner, IUnknown), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSystemRestoreCleaner::AddRef (void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSystemRestoreCleaner::Release (void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CSystemRestoreCleaner::CanShowFileSystemRestoreDialog(void)
{
    typedef BOOL (* PFNISSRENABLED)(void);
    
    HRESULT hr = E_FAIL;    

    HMODULE hMod = LoadLibrary(TEXT("sfc.dll"));
    if (hMod)
    {
	    PFNISSRENABLED pfnIsSREnabled = (PFNISSRENABLED)GetProcAddress(hMod, "IsSREnabled");
        if (pfnIsSREnabled)
        {        
            if (pfnIsSREnabled())
                hr = S_OK;
            else
                hr = S_FALSE;
        }

        FreeLibrary(hMod);
    }
    return hr;
}

STDMETHODIMP CSystemRestoreCleaner::ShowFileSystemRestoreDialog(HWND hwnd)
{
    HRESULT hr = E_FAIL;
    if ((hwnd != NULL) && (CanShowFileSystemRestoreDialog() == S_OK))
    {
        hr = ShowProperties(hwnd);
    }
    return hr;
}
  
typedef struct
{
    int icon;
    TCHAR cpl[ CCHPATHMAX ];
    TCHAR applet[ MAX_PATH ];
    TCHAR *params;
} CPLEXECINFO;

typedef struct
{
    ATOM aCPL;     // CPL name atom (so we can match requests)
    ATOM aApplet;  // applet name atom (so we can match requests, may be zero)
    HWND hwndStub; // window for this dude (so we can switch to it)
    UINT flags;    // see PCPLIF_ flags below
} CPLAPPLETID;

STDAPI_(void) CPL_ParseCommandLine(CPLEXECINFO *info, LPTSTR pszCmdLine, BOOL extract_icon);
STDAPI_(BOOL) SHRunDLLThread(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow);
STDAPI_(BOOL) CPL_Identify( CPLAPPLETID *identity, CPLEXECINFO *info, HWND stub );
STDAPI_(void) CPL_UnIdentify( CPLAPPLETID *identity );
STDAPI_(HWND) FindCPLWindowByStubWindowClassName(LPTSTR pszWndClassName, CPLAPPLETID *target);

                                   
STDMETHODIMP CSystemRestoreCleaner::ShowProperties(HWND hwnd)
{
    HRESULT hr = E_FAIL;

    CPLEXECINFO info;
    CPL_ParseCommandLine( &info, TEXT("sysdm.cpl"), FALSE );
    if (PathFindOnPath( info.cpl, NULL ))
    {
        CPLAPPLETID identity;
        if (CPL_Identify( &identity, &info, NULL ))
        {
            //explorer launches sysdm.cpl control panel on a new process Rundll32 with window name as RunDLL.
            HWND hwndTarget = FindCPLWindowByStubWindowClassName(TEXT("RunDLL"), &identity);
            if (hwndTarget == NULL)
            {
                if (SHRunDLLThread(hwnd, TEXT("shell32.dll,Control_RunDLL sysdm.cpl"), SW_SHOWNORMAL))
                {
                    //HACK - We need to wait till the new thread SetProp's the atom to the newly created
                    //window. Other wise the FindCPLWindowByStubWindowClassName will not find the window.
                    //Ideally we need to synchronize with the new created thread when it is done SetProp's the 
                    //atom for this Control panel - Look in 
                    int nRetryCount = 0;
                    while ((NULL == hwndTarget) && nRetryCount < 10)
                    {
                        hwndTarget = FindCPLWindowByStubWindowClassName((LPTSTR) c_szStubWindowClass, &identity);
                        Sleep(50);
                        ++nRetryCount;
                    }
                }
            }
            //Even if we don't get the Control's panels hwnd, we would have atleast launched the Property sheet
            //for the control panel.
            if (hwndTarget && IsWindow(hwndTarget))
            {
                //If we get the window handle, we switch to the correct tab for the Performance Page and 
                //emulate File System button click.
                
                // try to find a CPL window on top of it
                HWND hDialogWnd = GetLastActivePopup(hwndTarget);
                if (hDialogWnd && IsWindow(hDialogWnd))
                {
                    SetForegroundWindow(hDialogWnd);
                    PropSheet_SetCurSel(hDialogWnd, NULL, 3);
                    //HACK - Need to simulate a button click on the CPL Dialog. Since it is a 16bit code, we 
                    //can't call the do this hack. 2603 is the ID For the FileSystem button in sysdm.cpl.

                    PostMessage(hDialogWnd, WM_COMMAND, BN_CLICKED<<16 | 2603, 0 );
                    hr = S_OK;
                }                         
            }
            CPL_UnIdentify(&identity);
        }      
    }

    return hr;
}

STDAPI CSystemRestoreCleaner_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CSystemRestoreCleaner* pdt = new CSystemRestoreCleaner();
    if (pdt)
    {
        hr = pdt->QueryInterface(riid, ppv);
        pdt->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\subdata.h ===
#include "shellprv.h"
#pragma  hdrstop

#define EXPIRATION_NEVER    0xFFFFFFFF

class CSubDataProvider;

typedef BOOL (CSubDataProvider::*SUBDATACB)(PVOID pvData);
typedef BOOL (*STATICSUBDATACB)(PVOID pvData);

class CSubData
{
///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    // Only one of the following two fcts should be called
    BOOL Init(CSubDataProvider* pSDProv, SUBDATACB fctCB, PVOID pvData);
    BOOL InitStatic(STATICSUBDATACB fctStaticCB, PVOID pvData);

    BOOL InitExpiration(DWORD cTick);

    virtual BOOL Update();
    virtual void Invalidate();

    void HoldUpdates();
    void ResumeUpdates();

    CSubData();

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
private:
    BOOL _Call();

protected:
    void _SetTickLastUpdate(DWORD dwTick);
    DWORD _GetTickLastUpdate();
    DWORD* _GetTickLastUpdatePtr();

    PVOID _GetDataPtr();
    void _SetDataPtr(PVOID pvData);

    BOOL _IsExpired();
    BOOL _IsValid();

///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
protected:

    CSubDataProvider*   _pSDProv;

    union
    {
        SUBDATACB           _fctCB;
        STATICSUBDATACB     _fctStaticCB;
    };

    DWORD               _dwTickLast;
    PVOID               _pvData;

    DWORD               _cTickExpiration;

    BOOL                _fHoldUpdate;
    BOOL                _fStatic;

    BOOL                _fInvalid;

private:
#ifdef DEBUG
    BOOL                _fInited;
#endif
};

class CSubDataProvider
{
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\thumbutil.cpp ===
#include "shellprv.h"
#include "ocmm.h"
#include "thumbutil.h"

typedef UCHAR BGR3[3];

class CThumbnailMaker
{
public:
    CThumbnailMaker();
    ~CThumbnailMaker();

    void Scale(BGR3 *pDst, UINT uiDstWidth, int iDstStep, const BGR3 *pSrc, UINT uiSrcWidth, int iSrcStep);
    HRESULT Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight);
    HRESULT AddScanline(UCHAR *pucSrc, UINT uiY);
    HRESULT AddDIB(BITMAPINFO *pBMI);
    HRESULT AddDIBSECTION(BITMAPINFO *pBMI, void *pBits);
    HRESULT GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize);
    HRESULT GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize);

private:
    UINT _uiDstWidth, _uiDstHeight;
    UINT _uiSrcWidth, _uiSrcHeight;
    BGR3 *_pImH;
};

CThumbnailMaker::CThumbnailMaker()
{
    _pImH = NULL;
}

CThumbnailMaker::~CThumbnailMaker()
{
    if (_pImH)
        delete[] _pImH;
}

HRESULT CThumbnailMaker::Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight)
{
    _uiDstWidth = uiDstWidth;
    _uiDstHeight = uiDstHeight;
    _uiSrcWidth = uiSrcWidth;
    _uiSrcHeight = uiSrcHeight;

    if (_uiDstWidth < 1 || _uiDstHeight < 1 ||
        _uiSrcWidth < 1 || _uiSrcHeight < 1)
        return E_INVALIDARG;

    if (_pImH)
        delete[] _pImH;

    _pImH = new BGR3[_uiDstWidth * _uiSrcHeight];
    if (_pImH == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

void CThumbnailMaker::Scale(      BGR3 *pDst, UINT dxDst, int iDstBytStep, 
                            const BGR3 *pSrc, UINT dxSrc, int iSrcBytStep)
{
    int mnum = dxSrc;
    int mden = dxDst;

    // Scaling up, use a triangle filter.
    if (mden >= mnum)
    {
        int frac = 0;

        // Adjust the slope so that we calculate the fraction of the
        // "next" pixel to use (i.e. should be 0 for the first and
        // last dst pixel).
        --mnum;
        if (--mden == 0)
            mden = 0; // avoid div by 0

        BGR3 *pSrc1 = (BGR3 *)(((UCHAR *)pSrc) + iSrcBytStep);

        for (UINT x = 0; x < dxDst; x++)
        {
            if (frac == 0)
            {
                (*pDst)[0] = (*pSrc)[0];
                (*pDst)[1] = (*pSrc)[1];
                (*pDst)[2] = (*pSrc)[2];
            }
            else
            {
                (*pDst)[0] = ((mden - frac) * (*pSrc)[0] + frac * (*pSrc1)[0]) / mden;
                (*pDst)[1] = ((mden - frac) * (*pSrc)[1] + frac * (*pSrc1)[1]) / mden;
                (*pDst)[2] = ((mden - frac) * (*pSrc)[2] + frac * (*pSrc1)[2]) / mden;
            }

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);

            frac += mnum;
            if (frac >= mden)
            {
                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
                pSrc1 = (BGR3 *)((UCHAR *)pSrc1 + iSrcBytStep);
            }
        }
    }
    // Scaling down, use a box filter.
    else
    {
        int frac = 0;

        for (UINT x = 0; x < dxDst; x++)
        {
            UINT uiSum[3] = {0, 0, 0};
            UINT uiCnt = 0;

            frac += mnum;
            while (frac >= mden)
            {
                uiSum[0] += (*pSrc)[0];
                uiSum[1] += (*pSrc)[1];
                uiSum[2] += (*pSrc)[2];
                uiCnt++;

                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
            }

            (*pDst)[0] = uiSum[0] / uiCnt;
            (*pDst)[1] = uiSum[1] / uiCnt;
            (*pDst)[2] = uiSum[2] / uiCnt;

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);
        }
    }
}

//
// For AddScanline, we scale the input horizontally into our temporary
// image buffer.
//
HRESULT CThumbnailMaker::AddScanline(UCHAR *pSrc, UINT uiY)
{
    if (pSrc == NULL || uiY >= _uiSrcHeight)
        return E_INVALIDARG;

    Scale(_pImH + uiY * _uiDstWidth, _uiDstWidth, sizeof(BGR3), (BGR3 *)pSrc, _uiSrcWidth, sizeof(BGR3));

    return S_OK;
}

// For GetBITMAPINFO, we complete the scaling vertically and return the
// result as a DIB.
HRESULT CThumbnailMaker::GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
    *ppBMInfo = NULL;

    DWORD dwBPL = (((_uiDstWidth * 24) + 31) >> 3) & ~3;
    DWORD dwTotSize = sizeof(BITMAPINFOHEADER) + dwBPL * _uiDstHeight;

    BITMAPINFO *pBMI = (BITMAPINFO *)CoTaskMemAlloc(dwTotSize);
    if (pBMI == NULL)
        return E_OUTOFMEMORY;

    BITMAPINFOHEADER *pBMIH = &pBMI->bmiHeader;
    pBMIH->biSize = sizeof(*pBMIH);
    pBMIH->biWidth = _uiDstWidth;
    pBMIH->biHeight = _uiDstHeight;
    pBMIH->biPlanes = 1;
    pBMIH->biBitCount = 24;
    pBMIH->biCompression = BI_RGB;
    pBMIH->biXPelsPerMeter = 0;
    pBMIH->biYPelsPerMeter = 0;
    pBMIH->biSizeImage = dwBPL * _uiDstHeight;
    pBMIH->biClrUsed = 0;
    pBMIH->biClrImportant = 0;

    UCHAR *pDst = (UCHAR *)pBMIH + pBMIH->biSize + (_uiDstHeight - 1) * dwBPL;

    for (UINT x = 0; x < _uiDstWidth; x++)
    {
        Scale((BGR3 *)pDst + x, _uiDstHeight, -(int)dwBPL,
              _pImH + x, _uiSrcHeight, _uiDstWidth * sizeof(BGR3));
    }

    *ppBMInfo = pBMI;
    *pdwSize = dwTotSize;

    return S_OK;
}

HRESULT CThumbnailMaker::GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
#define SCALE 10000

    if (uiSharpPct > 100)
        return E_INVALIDARG;

    // Get the unsharpened bitmap.
    DWORD dwSize;
    HRESULT hr = GetBITMAPINFO(ppBMInfo, &dwSize);
    if (FAILED(hr))
        return hr;

    *pdwSize = dwSize;

    // Create a duplicate to serve as the original.
    BITMAPINFO *pBMISrc = (BITMAPINFO *)new UCHAR[dwSize];
    if (pBMISrc == NULL)
    {
        delete *ppBMInfo;
        return E_OUTOFMEMORY;
    }
    memcpy(pBMISrc, *ppBMInfo, dwSize);

    int bpl = (pBMISrc->bmiHeader.biWidth * 3 + 3) & ~3;

    //
    // Sharpen inside a 1 pixel border
    //
    UCHAR *pucDst = (UCHAR *)*ppBMInfo + sizeof(BITMAPINFOHEADER);
    UCHAR *pucSrc[3];
    pucSrc[0] = (UCHAR *)pBMISrc + sizeof(BITMAPINFOHEADER);
    pucSrc[1] = pucSrc[0] + bpl;
    pucSrc[2] = pucSrc[1] + bpl;

    int wdiag = (10355 * uiSharpPct) / 100;
    int wadj = (14645 * uiSharpPct) / 100;
    int wcent = 4 * (wdiag + wadj);

    for (int y = 1; y < pBMISrc->bmiHeader.biHeight-1; ++y)
    {
        for (int x = 3*(pBMISrc->bmiHeader.biWidth-2); x >= 3; --x)
        {
            int v = pucDst[x] +
                (pucSrc[1][x] * wcent -
                 ((pucSrc[0][x - 3] +
                   pucSrc[0][x + 3] +
                   pucSrc[2][x - 3] +
                   pucSrc[2][x + 3]) * wdiag +
                  (pucSrc[0][x] +
                   pucSrc[1][x - 3] +
                   pucSrc[1][x + 3] +
                   pucSrc[2][x]) * wadj)) / SCALE;

            pucDst[x] = v < 0 ? 0 : v > 255 ? 255 : v;
        }

        pucDst += bpl;
        pucSrc[0] = pucSrc[1];
        pucSrc[1] = pucSrc[2];
        pucSrc[2] += bpl;
    }

    delete[] pBMISrc;

    return S_OK;
#undef SCALE
}

HRESULT ThumbnailMaker_Create(CThumbnailMaker **ppThumbMaker)
{
    *ppThumbMaker  = new CThumbnailMaker;
    return *ppThumbMaker ? S_OK : E_OUTOFMEMORY;
}

HRESULT CThumbnailMaker::AddDIB(BITMAPINFO *pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }

    UCHAR *pBits = (UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD);

    return AddDIBSECTION(pBMI, (void *) pBits);
}

HRESULT CThumbnailMaker::AddDIBSECTION(BITMAPINFO *pBMI, void *pBits)
{
    RGBQUAD *pRGBQ, *pQ;
    UCHAR *pucBits0, *pucBits, *pB, *pucBits240, *pucBits24, *pB24;
    int bpl;
    int x, y, ncolors;
    ULONG rmask, gmask, bmask;
    int rshift, gshift, bshift;
    HRESULT hr;

    //
    // Make sure that thumbnail maker has been properly initialized.
    //
    if (pBMI == NULL)
        return E_INVALIDARG;

    if (pBMI->bmiHeader.biWidth != (LONG)_uiSrcWidth ||
        pBMI->bmiHeader.biHeight != (LONG)_uiSrcHeight)
        return E_INVALIDARG;

    //
    // Don't handle RLE.
    //
    if (pBMI->bmiHeader.biCompression != BI_RGB &&
        pBMI->bmiHeader.biCompression != BI_BITFIELDS)
        return E_INVALIDARG;

    pRGBQ = (RGBQUAD *)&pBMI->bmiColors[0];

    ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;

    //
    // Decode 16/32bpp with masks.
    //
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            rmask = ((ULONG *)pRGBQ)[0];
            gmask = ((ULONG *)pRGBQ)[1];
            bmask = ((ULONG *)pRGBQ)[2];
            ncolors = 3;
        }
        else if (pBMI->bmiHeader.biBitCount == 16)
        {
            rmask = 0x7c00;
            gmask = 0x03e0;
            bmask = 0x001f;
        }
        else /* 32 */
        {
            rmask = 0xff0000;
            gmask = 0x00ff00;
            bmask = 0x0000ff;
        }

        for (rshift = 0; (rmask & 1) == 0; rmask >>= 1, ++rshift);
        if (rmask == 0)
            rmask = 1;
        for (gshift = 0; (gmask & 1) == 0; gmask >>= 1, ++gshift);
        if (gmask == 0)
            gmask = 1;
        for (bshift = 0; (bmask & 1) == 0; bmask >>= 1, ++bshift);
        if (bmask == 0)
            bmask = 1;
    }

    bpl = ((pBMI->bmiHeader.biBitCount * _uiSrcWidth + 31) >> 3) & ~3;

    pucBits0 = (UCHAR *) pBits;
    pucBits = pucBits0;

    if (pBMI->bmiHeader.biBitCount == 24)
        pucBits240 = pucBits;
    else
    {
        int bpl24 = (_uiSrcWidth * 3 + 3) & ~3;

        pucBits240 = new UCHAR[bpl24];
        if (pucBits240 == NULL)
            return E_OUTOFMEMORY;
    }
    pucBits24 = pucBits240;

    hr = S_OK;

    for (y = 0; y < (int)_uiSrcHeight; ++y)
    {
        pB = pucBits;
        pB24 = pucBits24;

        switch (pBMI->bmiHeader.biBitCount)
        {
        case 1:
            for (x = _uiSrcWidth; x >= 8; x -= 8)
            {
                pQ = &pRGBQ[(*pB >> 7) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 6) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 5) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 4) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 3) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 2) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 1) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB++) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                int shf = 8;

                do
                {
                    pQ = &pRGBQ[(*pB >> --shf) & 1];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
                while (--x);
            }

            break;

        case 4:
            for (x = _uiSrcWidth; x >= 2; x -= 2)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[*pB++ & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                if (x > 1)
                {
                    pQ = &pRGBQ[*pB & 0xf];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
            }

            break;

        case 8:
            for (x = _uiSrcWidth; x--;)
            {
                pQ = &pRGBQ[*pB++];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            break;

        case 16:
        {
            USHORT *pW = (USHORT *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG w = *pW++;

                *pB24++ = (UCHAR)
                     ((((w >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((w >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((w >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        case 24:
            pucBits24 = pucBits;
            break;

        case 32:
        {
            ULONG *pD;

            pD = (ULONG *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG d = *pD++;

                *pB24++ = (UCHAR)
                     ((((d >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((d >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((d >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        default:
            delete[] pucBits24;
            return E_INVALIDARG;
        }

        hr = AddScanline(pucBits24, (_uiSrcHeight-1) - y);
        if (FAILED(hr))
            break;

        pucBits += bpl;
    }

    if (pucBits240 != pucBits0)
        delete[] pucBits240;

    return hr;
}

UINT CalcImageSize(const SIZE *prgSize, DWORD dwClrDepth)
{
    UINT uSize = prgSize->cx * dwClrDepth;
    
    uSize *= (prgSize->cy < 0) ? (- prgSize->cy) : prgSize->cy;
    // divide by 8
    UINT uRetVal = uSize >> 3;

    if (uSize & 7)
    {
        uRetVal++;
    }

    return uRetVal;
}

BOOL ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                  HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                  DWORD dwRecClrDepth, HPALETTE hpal, UINT uiSharpPct, BOOL fOrigSize)
{
    BITMAPINFO *pbiScaled = pbi, *pbiUsed = pbi;
    BITMAPINFOHEADER *pbih = (BITMAPINFOHEADER *)pbi;
    BOOL bRetVal = FALSE, bInverted = FALSE;
    RECT rect;
    HRESULT hr;
    void *pScaledBits = pBits;

    // the scaling code doesn't handle inverted bitmaps, so we treat
    // them as if they were normal, by inverting the height here and
    // then setting it back before doing a paint.
    if (pbi->bmiHeader.biHeight < 0)
    {
        pbi->bmiHeader.biHeight *= -1;
        bInverted = TRUE;
    }

    rect.left = 0;
    rect.top = 0;
    rect.right = pbih->biWidth;
    rect.bottom = pbih->biHeight;
    
    CalculateAspectRatio(prgSize, &rect);

    // only bother with the scaling and sharpening if we are messing with the size...
    if ((rect.right - rect.left != pbih->biWidth) || (rect.bottom - rect.top != pbih->biHeight))
    {
        CThumbnailMaker *pThumbMaker;
        hr = ThumbnailMaker_Create(&pThumbMaker);
        if (SUCCEEDED(hr))
        {
            // initialize thumbnail maker. 
            hr = pThumbMaker->Init(rect.right - rect.left, rect.bottom - rect.top, 
                                    pbi->bmiHeader.biWidth, abs(pbi->bmiHeader.biHeight));
            if (SUCCEEDED(hr))
            {
                // scale image.
                hr = pThumbMaker->AddDIBSECTION(pbiUsed, pBits);
                if (SUCCEEDED(hr))
                {
                    DWORD dwSize;
                    hr = pThumbMaker->GetSharpenedBITMAPINFO(uiSharpPct, &pbiScaled, &dwSize);
                    if (SUCCEEDED(hr))
                    {
                        pScaledBits = (LPBYTE)pbiScaled + sizeof(BITMAPINFOHEADER);
                    }
                }
            }
            delete pThumbMaker;
        }

        if (FAILED(hr))
        {
            return FALSE;
        }
    }

    // set the height back to negative if that's the way it was before.
    if (bInverted == TRUE)
        pbiScaled->bmiHeader.biHeight *= -1;

    // now if they have asked for origsize rather than the boxed one, and the colour depth is OK, then 
    // return it...
    if (fOrigSize && pbiScaled->bmiHeader.biBitCount <= dwRecClrDepth)
    {
        SIZE rgCreateSize = { pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight };
        void *pNewBits;
        
        // turn the PbiScaled DIB into a HBITMAP...., note we pass the old biInfo so that it can get the palette form
        // it if need be.
        bRetVal = CreateSizedDIBSECTION(&rgCreateSize, pbiScaled->bmiHeader.biBitCount, NULL, pbiScaled, phBmpThumbnail, NULL, &pNewBits);

        if (bRetVal)
        {
            // copy the image data accross...
            CopyMemory(pNewBits, pScaledBits, CalcImageSize(&rgCreateSize, pbiScaled->bmiHeader.biBitCount)); 
        }
        
        return bRetVal;
    }
    
    bRetVal = FactorAspectRatio(pbiScaled, pScaledBits, prgSize, rect,
                                 dwRecClrDepth, hpal, fOrigSize, GetSysColor(COLOR_WINDOW), phBmpThumbnail);

    if (pbiScaled != pbi)
    {
        // free the allocated image...
        CoTaskMemFree(pbiScaled);
    }

    return bRetVal;
}

// This function makes no assumption about whether the thumbnail is square, so 
// it calculates the scaling ratio for both dimensions and the uses that as
// the scaling to maintain the aspect ratio.
//
void CalcAspectScaledRect(const SIZE *prgSize, RECT *pRect)
{
    ASSERT(pRect->left == 0);
    ASSERT(pRect->top == 0);

    int iWidth = pRect->right;
    int iHeight = pRect->bottom;
    int iXRatio = MulDiv(iWidth, 1000, prgSize->cx);
    int iYRatio = MulDiv(iHeight, 1000, prgSize->cy);

    if (iXRatio > iYRatio)
    {
        pRect->right = prgSize->cx;
        
        // work out the blank space and split it evenly between the top and the bottom...
        int iNewHeight = MulDiv(iHeight, 1000, iXRatio); 
        if (iNewHeight == 0)
        {
            iNewHeight = 1;
        }
        
        int iRemainder = prgSize->cy - iNewHeight;

        pRect->top = iRemainder / 2;
        pRect->bottom = iNewHeight + pRect->top;
    }
    else
    {
        pRect->bottom = prgSize->cy;

        // work out the blank space and split it evenly between the left and the right...
        int iNewWidth = MulDiv(iWidth, 1000, iYRatio);
        if (iNewWidth == 0)
        {
            iNewWidth = 1;
        }
        int iRemainder = prgSize->cx - iNewWidth;
        
        pRect->left = iRemainder / 2;
        pRect->right = iNewWidth + pRect->left;
    }
}
    
void CalculateAspectRatio(const SIZE *prgSize, RECT *pRect)
{
    int iHeight = abs(pRect->bottom - pRect->top);
    int iWidth = abs(pRect->right - pRect->left);

    // check if the initial bitmap is larger than the size of the thumbnail.
    if (iWidth > prgSize->cx || iHeight > prgSize->cy)
    {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = iWidth;
        pRect->bottom = iHeight;

        CalcAspectScaledRect(prgSize, pRect);
    }
    else
    {
        // if the bitmap was smaller than the thumbnail, just center it.
        pRect->left = (prgSize->cx - iWidth) / 2;
        pRect->top = (prgSize->cy- iHeight) / 2;
        pRect->right = pRect->left + iWidth;
        pRect->bottom = pRect->top + iHeight;
    }
}

LPBYTE g_pbCMAP = NULL;

STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits, 
                                const SIZE *prgSize, RECT rect, DWORD dwClrDepth, 
                                HPALETTE hpal, BOOL fOrigSize, COLORREF clrBk, HBITMAP *phBmpThumbnail)
{
    HDC                 hdc = CreateCompatibleDC(NULL);
    BITMAPINFOHEADER    *pbih = (BITMAPINFOHEADER *)pbiScaled;
    BOOL                bRetVal = FALSE;
    int                 iRetVal = GDI_ERROR;
    BITMAPINFO *        pDitheredInfo = NULL;
    void *              pDitheredBits = NULL;
    HBITMAP             hbmpDithered = NULL;
    
    if (hdc)
    {
        if (dwClrDepth == 8)
        {
            RGBQUAD *pSrcColors = NULL;
            LONG nSrcPitch = pbiScaled->bmiHeader.biWidth;
            
            // we are going to 8 bits per pixel, we had better dither everything 
            // to the same palette.
            GUID guidType = CLSID_NULL;
            switch(pbiScaled->bmiHeader.biBitCount)
            {
            case 32:
                guidType = BFID_RGB_32;
                nSrcPitch *= sizeof(DWORD);
                break;
                
            case 24:
                guidType = BFID_RGB_24;
                nSrcPitch *= 3;
                break;
                
            case 16:
                // default is 555
                guidType = BFID_RGB_555;
                
                // 5-6-5 bitfields has the second DWORD (the green component) as 0x7e00
                if (pbiScaled->bmiHeader.biCompression == BI_BITFIELDS && 
                    pbiScaled->bmiColors[1].rgbGreen == 0x7E)
                {
                    guidType = BFID_RGB_565;
                }
                nSrcPitch *= sizeof(WORD);
                break;
                
            case 8:
                guidType = BFID_RGB_8;
                pSrcColors = pbiScaled->bmiColors;
                
                // nSrcPitch is already in bytes...
                break;
            };
            
            if (nSrcPitch % 4)
            {
                // round up to the nearest DWORD...
                nSrcPitch = nSrcPitch + 4 - (nSrcPitch %4);
            }
            
            // we are going to 8bpp
            LONG nDestPitch = pbiScaled->bmiHeader.biWidth;
            if (nDestPitch % 4)
            {
                // round up to the nearest DWORD...
                nDestPitch = nDestPitch + 4 - (nDestPitch % 4);
            }
            
            if (guidType != CLSID_NULL)
            {
                if (g_pbCMAP == NULL)
                {
                    // we are always going to the shell halftone palette right now, otherwise
                    // computing this inverse colour map consumes a lot of time (approx 2 seconds on
                    // a p200)
                    if (FAILED(SHGetInverseCMAP((BYTE *)&g_pbCMAP, sizeof(g_pbCMAP))))
                    {
                        return FALSE;
                    }
                }   
                
                SIZE rgDithered = {pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight};
                if (rgDithered.cy < 0)
                {
                    // invert it
                    rgDithered.cy = -rgDithered.cy;
                }
                
                if (CreateSizedDIBSECTION(&rgDithered, dwClrDepth, hpal, NULL, &hbmpDithered, &pDitheredInfo, &pDitheredBits))
                {
                    ASSERT(pDitheredInfo && pDitheredBits);
                    
                    // dither....
                    IIntDitherer *pDither;
                    HRESULT hr = CoCreateInstance(CLSID_IntDitherer, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IIntDitherer, &pDither));
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = pDither->DitherTo8bpp((LPBYTE) pDitheredBits, nDestPitch, 
                            (LPBYTE) pScaledBits, nSrcPitch, guidType, 
                            pDitheredInfo->bmiColors, pSrcColors,
                            g_pbCMAP, 0, 0, rgDithered.cx, rgDithered.cy,
                            -1, -1);
                        
                        pDither->Release();
                    }
                    if (SUCCEEDED(hr))
                    {
                        // if the height was inverted, then invert it in the destination bitmap
                        if (rgDithered.cy != pbiScaled->bmiHeader.biHeight)
                        {
                            pDitheredInfo->bmiHeader.biHeight = - rgDithered.cy;
                        }
                        
                        // switch to the new image .....
                        pbiScaled = pDitheredInfo;
                        pScaledBits = pDitheredBits;
                    }
                }
            }
        }
        
        // create thumbnail bitmap and copy image into it.
        if (CreateSizedDIBSECTION(prgSize, dwClrDepth, hpal, NULL, phBmpThumbnail, NULL, NULL))
        {
            HBITMAP hBmpOld = (HBITMAP) SelectObject(hdc, *phBmpThumbnail);
            
            SetStretchBltMode(hdc, COLORONCOLOR);
            
            HGDIOBJ hBrush = CreateSolidBrush(clrBk);
            HGDIOBJ hPen = GetStockObject(WHITE_PEN);
            
            HGDIOBJ hOldBrush = SelectObject(hdc, hBrush);
            HGDIOBJ hOldPen = SelectObject(hdc, hPen);
            
            HPALETTE hpalOld;
            if (hpal)
            {
                hpalOld = SelectPalette(hdc, hpal, TRUE);
                RealizePalette(hdc);
            }
            
            SetMapMode(hdc, MM_TEXT);
            
            Rectangle(hdc, 0, 0, prgSize->cx, prgSize->cy);
            
            int iDstHt = rect.bottom - rect.top;
            int iDstTop = rect.top, iSrcTop = 0;
            if (pbih->biHeight < 0)
            {
                iDstHt *= -1;
                iDstTop = rect.bottom;
                iSrcTop = abs(pbih->biHeight);
            }
            
            iRetVal = StretchDIBits(hdc, rect.left, iDstTop, rect.right - rect.left, iDstHt, 
                0, iSrcTop, pbih->biWidth, pbih->biHeight, 
                pScaledBits, pbiScaled, DIB_RGB_COLORS,  SRCCOPY);
            
            SelectObject(hdc, hOldBrush);
            DeleteObject(hBrush);
            SelectObject(hdc, hOldPen);
            if (hpal)
            {
                SelectPalette(hdc, hpalOld, TRUE);
                RealizePalette(hdc);
            }
            
            SelectObject(hdc, hBmpOld);
        }
        
        DeleteDC(hdc);
    }
    
    if (hbmpDithered)
    {
        DeleteObject(hbmpDithered);
    }
    if (pDitheredInfo)
    {
        LocalFree(pDitheredInfo);
    }
    
    return (iRetVal != GDI_ERROR);
}


STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal, 
                                    const BITMAPINFO *pCurInfo, HBITMAP *phBmp, BITMAPINFO **ppBMI, void **ppBits)
{
    *phBmp = NULL;
    
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HDC hdcBmp = CreateCompatibleDC(hdc);
        if (hdcBmp)
        {
            struct {
                BITMAPINFOHEADER bi;
                DWORD            ct[256];
            } dib;

            dib.bi.biSize            = sizeof(dib.bi);
            dib.bi.biWidth           = prgSize->cx;
            dib.bi.biHeight          = prgSize->cy;
            dib.bi.biPlanes          = 1;
            dib.bi.biBitCount        = (WORD) dwClrDepth;
            dib.bi.biCompression     = BI_RGB;
            dib.bi.biSizeImage       = CalcImageSize(prgSize, dwClrDepth);
            dib.bi.biXPelsPerMeter   = 0;
            dib.bi.biYPelsPerMeter   = 0;
            dib.bi.biClrUsed         = (dwClrDepth <= 8) ? (1 << dwClrDepth) : 0;
            dib.bi.biClrImportant    = 0;

            HPALETTE hpalOld = NULL;
        
            if (dwClrDepth <= 8)
            {
                // if they passed us the old structure with colour info, and we are the same bit depth, then copy it...
                if (pCurInfo && pCurInfo->bmiHeader.biBitCount == dwClrDepth)
                {
                    // use the passed in colour info to generate the DIBSECTION
                    int iColours = pCurInfo->bmiHeader.biClrUsed;

                    if (!iColours)
                    {
                        iColours = dib.bi.biClrUsed;
                    }

                    // copy the data accross...
                    CopyMemory(dib.ct, pCurInfo->bmiColors, sizeof(RGBQUAD) * iColours);
                }
                else
                {
                    // need to get the right palette....
                    hpalOld = SelectPalette(hdcBmp, hpal, TRUE);
                    RealizePalette(hdcBmp);
            
                    int n = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);

                    ASSERT(n >= (int) dib.bi.biClrUsed);

                    // now convert the PALETTEENTRY to RGBQUAD
                    for (int i = 0; i < (int)dib.bi.biClrUsed; i ++)
                    {
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                    }
                }
            }
 
            void *pbits;
            *phBmp = CreateDIBSection(hdcBmp, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &pbits, NULL, 0);
            if (*phBmp)
            {
                if (ppBMI)
                {
                    *ppBMI = (BITMAPINFO *)LocalAlloc(LPTR, sizeof(dib));
                    if (*ppBMI)
                    {
                        CopyMemory(*ppBMI, &dib, sizeof(dib));
                    }
                }
                if (ppBits)
                {
                    *ppBits = pbits;
                }
            }
            DeleteDC(hdcBmp);
        }
        ReleaseDC(NULL, hdc);
    }
    return (*phBmp != NULL);
}

STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }
    return (void *)((UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\thumbutil.h ===
STDAPI_(void) CalculateAspectRatio(const SIZE *prgSize, RECT *pRect);
STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits,
                                const SIZE *prgSize, RECT rect,
                                DWORD dwClrDepth, HPALETTE hPal, BOOL fOrigSize,
                                COLORREF clrBk, HBITMAP *phBmpThumbnail);
STDAPI_(BOOL) ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                           HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                           DWORD dwClrDepth, HPALETTE hpal, UINT uiSharpPct, BOOL fOrigImage);
STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal,
                                    const BITMAPINFO *pCurInfo, HBITMAP *phbmp, BITMAPINFO **pBMI, void **ppBits);
STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\switchuserdialog.h ===
//  --------------------------------------------------------------------------
//  Module Name: SwitchUserDialog.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements presentation of the Switch User dialog.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

#ifndef     _SwitchUserDialog_
#define     _SwitchUserDialog_

#ifdef      __cplusplus

#include "Tooltip.h"

//  --------------------------------------------------------------------------
//  CSwitchUserDialog::CSwitchUserDialog
//
//  Purpose:    Implements the "Switch User Dialog" feature.
//
//  History:    2001-01-23  vtan        created (form Turn Off Dialog)
//  --------------------------------------------------------------------------

class   CSwitchUserDialog
{
    private:
        enum
        {
            BUTTON_STATE_REST           =   0,
            BUTTON_STATE_DOWN,
            BUTTON_STATE_HOVER,
            BUTTON_STATE_MAX,

            BUTTON_GROUP_SWITCHUSER     =   0,
            BUTTON_GROUP_LOGOFF,
            BUTTON_GROUP_MAX
        };
        static  const int   MAGIC_NUMBER    =   48517;
    private:
                                            CSwitchUserDialog (void);
                                            CSwitchUserDialog (const CSwitchUserDialog& copyObject);
                const CSwitchUserDialog&    operator = (const CSwitchUserDialog& assignObject);
    public:
                                            CSwitchUserDialog (HINSTANCE hInstance);
                                            ~CSwitchUserDialog (void);

                DWORD                       Show (HWND hwndParent);
    private:
                void                        PaintBitmap (HDC hdcDestination, const RECT *prcDestination, HBITMAP hbmSource, const RECT *prcSource);
                void                        RemoveTooltip (void);
                void                        FilterMetaCharacters (TCHAR *pszText);
                void                        EndDialog (HWND hwnd, INT_PTR iResult);
                void                        Handle_BN_CLICKED (HWND hwnd, WORD wID);
                void                        Handle_WM_INITDIALOG (HWND hwnd);
                void                        Handle_WM_DESTROY (HWND hwnd);
                void                        Handle_WM_ERASEBKGND (HWND hwnd, HDC hdcErase);
                void                        Handle_WM_PRINTCLIENT (HWND hwnd, HDC hdcPrint, DWORD dwOptions);
                void                        Handle_WM_ACTIVATE (HWND hwnd, DWORD dwState);
                void                        Handle_WM_DRAWITEM (HWND hwnd, const DRAWITEMSTRUCT *pDIS);
                void                        Handle_WM_COMMAND (HWND hwnd, WPARAM wParam);
                void                        Handle_WM_MOUSEMOVE (HWND hwnd, UINT uiID);
                void                        Handle_WM_MOUSEHOVER (HWND hwnd, UINT uiID);
                void                        Handle_WM_MOUSELEAVE (HWND hwnd);
        static  INT_PTR     CALLBACK        CB_DialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  LRESULT     CALLBACK        ButtonSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData);
    private:
                const HINSTANCE             _hInstance;
                HBITMAP                     _hbmBackground;
                HBITMAP                     _hbmFlag;
                HBITMAP                     _hbmButtons;
                HFONT                       _hfntTitle;
                HFONT                       _hfntButton;
                HPALETTE                    _hpltShell;
                RECT                        _rcBackground;
                RECT                        _rcFlag;
                RECT                        _rcButtons;
                LONG                        _lButtonHeight;
                UINT                        _uiHoverID;
                UINT                        _uiFocusID;
                bool                        _fSuccessfulInitialization;
                bool                        _fDialogEnded;
                CTooltip*                   _pTooltip;
};

#endif  /*  __cplusplus     */

EXTERN_C    DWORD   SwitchUserDialog_Show (HWND hwndParent);

#endif  /*  _SwitchUserDialog_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\thumbnailgen.cpp ===
#include "shellprv.h"
#include "runtask.h"
#include "prop.h"
#include "thumbutil.h"
#include <cowsite.h>

static const GUID TOID_Thumbnail = { 0xadec3450, 0xe907, 0x11d0, {0xa5, 0x7b, 0x00, 0xc0, 0x4f, 0xc2, 0xf7, 0x6a} };

class CThumbnail : public IThumbnail2, public IParentAndItem, public CObjectWithSite
{
public:
    CThumbnail(void);

    // IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);

    // IThumbnail
    STDMETHODIMP Init(HWND hwnd, UINT uMsg);
    STDMETHODIMP GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight);

    // IThumbnail2
    STDMETHODIMP GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

private:
    ~CThumbnail(void);
    HRESULT _CreateTask(IShellFolder *psf, LPCITEMIDLIST pidlLast, DWORD dwItem, SIZE rgSize, IExtractImage *pei, IRunnableTask **pprt);
    HRESULT _BitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight);
    HRESULT _InitTaskCancelItems();

    LONG _cRef;
    HWND _hwnd;
    UINT _uMsg;
    IShellTaskScheduler *_pScheduler;
    IShellFolder *_psf;
    LPITEMIDLIST _pidl;
};

class CGetThumbnailTask : public CRunnableTask
{
public:
    CGetThumbnailTask(IShellFolder *psf, LPCITEMIDLIST pidl, IExtractImage *pei, HWND hwnd, UINT uMsg, DWORD dwItem, SIZE rgSize);
    STDMETHODIMP RunInitRT(void);

private:
    ~CGetThumbnailTask();
    HRESULT _PrepImage(HBITMAP *phBmp);
    HRESULT _BitmapReady(HBITMAP hImage);
    
    IShellFolder *_psf;
    IExtractImage *_pei;
    HWND _hwnd;
    UINT _uMsg;
    DWORD _dwItem;
    SIZE _rgSize;
    LPITEMIDLIST _pidlFolder;   // folder where we test the cache
    LPITEMIDLIST _pidlLast;
    WCHAR _szPath[MAX_PATH];    // the item in that in folder parsing name for cache test
};

CThumbnail::CThumbnail(void) : _cRef(1)
{
    DllAddRef();
}

CThumbnail::~CThumbnail(void)
{
    if (_pScheduler)
    {
        _pScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
        _pScheduler->Release();
        _pScheduler = NULL;
    }

    if (_psf)
        _psf->Release();

    ILFree(_pidl);

    DllRelease();
}

STDAPI CThumbnail_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CThumbnail *pThumb = new CThumbnail();
    if (pThumb)
    {
        hr = pThumb->QueryInterface(riid, ppv);
        pThumb->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT CThumbnail::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CThumbnail, IThumbnail2), 
        QITABENTMULTI(CThumbnail, IThumbnail, IThumbnail2), 
        QITABENT(CThumbnail, IParentAndItem),
        QITABENT(CThumbnail, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CThumbnail::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CThumbnail::Release(void)
{
    if (InterlockedDecrement(&_cRef) > 0)
        return _cRef;

    delete this;
    return 0;
}

// IThumbnail
HRESULT CThumbnail::Init(HWND hwnd, UINT uMsg)
{
    _hwnd = hwnd;
    _uMsg = uMsg;
    ASSERT(NULL == _pScheduler);

    return S_OK;
}

HRESULT CThumbnail::_InitTaskCancelItems()
{
    if (!_pScheduler)
    {
        if (!_punkSite || FAILED(IUnknown_QueryService(_punkSite, SID_ShellTaskScheduler,
                    IID_PPV_ARG(IShellTaskScheduler, &_pScheduler))))
        {
            CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IShellTaskScheduler, &_pScheduler));
        }
        
        if (_pScheduler)
        {
            // make sure RemoveTasks() actually kills old tasks even if they're not done yet
            _pScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, ITSS_THREAD_TIMEOUT_NO_CHANGE);
        }
    }

    if (_pScheduler)
    {
        // Kill any old tasks in the scheduler.
        _pScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
    }
    return _pScheduler ? S_OK : E_FAIL;
}

HRESULT CThumbnail::_CreateTask(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwItem, SIZE rgSize, IExtractImage *pei, IRunnableTask **pprt)
{
    *pprt = new CGetThumbnailTask(psf, pidl, pei, _hwnd, _uMsg, dwItem, rgSize);
    return *pprt ? S_OK : E_OUTOFMEMORY;
}

HRESULT CThumbnail::_BitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    LPCITEMIDLIST pidlLast;
    IShellFolder *psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        IExtractImage *pei;
        hr = psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_PPV_ARG_NULL(IExtractImage, &pei));
        if (SUCCEEDED(hr))
        {
            DWORD dwPriority = 0;
            DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_SCREEN | IEIFLAG_OFFLINE;
            SIZEL rgSize = {lWidth, lHeight};

            WCHAR szLocation[MAX_PATH];
            hr = pei->GetLocation(szLocation, ARRAYSIZE(szLocation), &dwPriority, &rgSize, SHGetCurColorRes(), &dwFlags);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    HBITMAP hbm;
                    hr = pei->Extract(&hbm);
                    if (SUCCEEDED(hr))
                    {
                        if (!PostMessage(_hwnd, _uMsg, dwItem, (LPARAM)hbm))
                        {
                            DeleteObject(hbm);
                        }
                    }
                }
                else
                    hr = E_FAIL;
            }
            else if (E_PENDING == hr)
            {
                IRunnableTask *prt;
                hr = _CreateTask(psf, pidlLast, dwItem, rgSize, pei, &prt);
                if (SUCCEEDED(hr))
                {
                    // Add the task to the scheduler.
                    hr = _pScheduler->AddTask(prt, TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, dwPriority);
                    prt->Release();
                }
            }
            pei->Release();
        }
        psf->Release();
    }
    return hr;
}

STDMETHODIMP CThumbnail::GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();
    if (pszFile)
    {
        LPITEMIDLIST pidl = ILCreateFromPathW(pszFile);
        if (pidl)
        {
            hr = _BitmapFromIDList(pidl, dwItem, lWidth, lHeight);
            ILFree(pidl);
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

// IThumbnail2
STDMETHODIMP CThumbnail::GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();
    if (pidl)
    {
        hr = _BitmapFromIDList(pidl, dwItem, lWidth, lHeight);
    }
    return hr;
}

// IParentAndItem
STDMETHODIMP CThumbnail::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf, LPCITEMIDLIST pidlChild) 
{ 
    return E_NOTIMPL;
}

STDMETHODIMP CThumbnail::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    return E_NOTIMPL;
}

CGetThumbnailTask::CGetThumbnailTask(IShellFolder *psf, LPCITEMIDLIST pidl, IExtractImage *pei, HWND hwnd, UINT uMsg, DWORD dwItem, SIZE rgSize)
    : CRunnableTask(RTF_DEFAULT), _pei(pei), _hwnd(hwnd), _uMsg(uMsg), _dwItem(dwItem), _psf(psf), _rgSize(rgSize)
{
    SHGetIDListFromUnk(psf, &_pidlFolder);  // failure handled later
    _pidlLast = ILClone(pidl);  // failure handled later
    DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, _szPath, ARRAYSIZE(_szPath));
    _pei->AddRef();
    _psf->AddRef();
}

CGetThumbnailTask::~CGetThumbnailTask()
{
    ILFree(_pidlLast);
    ILFree(_pidlFolder);
    _pei->Release();
    _psf->Release();
}

HRESULT CGetThumbnailTask::_PrepImage(HBITMAP *phBmp)
{
    HRESULT hr = E_FAIL;
    DIBSECTION ds;
    if (GetObject(*phBmp, sizeof(ds), &ds))
    {
        // the disk cache only supports 32 Bpp DIBS now, so we can ignore the palette issue...
        ASSERT(ds.dsBm.bmBitsPixel == 32);
    
        HPALETTE hPal = (SHGetCurColorRes() == 8) ? SHCreateShellPalette(NULL) : NULL;

        HBITMAP hBmpNew;
        if (ConvertDIBSECTIONToThumbnail((BITMAPINFO *)&ds.dsBmih, ds.dsBm.bmBits, &hBmpNew, &_rgSize, 
                                         SHGetCurColorRes(), hPal, 0, FALSE))
        {
            DeleteObject(*phBmp);
            *phBmp = hBmpNew;
        }

        if (hPal)
            DeletePalette(hPal);
    }
    return hr;
}

HRESULT CGetThumbnailTask::_BitmapReady(HBITMAP hImage)
{
    if (!PostMessage(_hwnd, _uMsg, _dwItem, (LPARAM)hImage))
    {
        DeleteObject(hImage);
    }
    return S_OK;
}

STDMETHODIMP CGetThumbnailTask::RunInitRT()
{
    HRESULT hr = E_FAIL;
    
    // now get the date stamp and check the disk cache....
    FILETIME ftImageTimeStamp = {0,0};

    // do they support date stamps....
    IExtractImage2 *pei2;
    if (SUCCEEDED(_pei->QueryInterface(IID_PPV_ARG(IExtractImage2, &pei2))))
    {
        pei2->GetDateStamp(&ftImageTimeStamp);
        pei2->Release();
    }

    IShellFolder2 *psf2;
    if (IsNullTime(&ftImageTimeStamp) && _pidlLast && SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        // fall back to this (most common case)
        GetDateProperty(psf2, _pidlLast, &SCID_WRITETIME, &ftImageTimeStamp);
        psf2->Release();
    }

    IShellImageStore *pStore;
    if (_pidlFolder &&
        SUCCEEDED(LoadFromIDList(CLSID_ShellThumbnailDiskCache, _pidlFolder, IID_PPV_ARG(IShellImageStore, &pStore))))
    {
        DWORD dwStoreLock;
        if (SUCCEEDED(pStore->Open(STGM_READ, &dwStoreLock)))
        {
            FILETIME ftCacheDateStamp;
            if ((S_OK == pStore->IsEntryInStore(_szPath, &ftCacheDateStamp)) && 
                ((0 == CompareFileTime(&ftCacheDateStamp, &ftImageTimeStamp)) || IsNullTime(&ftImageTimeStamp)))
            {
                HBITMAP hBmp;
                if (SUCCEEDED(pStore->GetEntry(_szPath, STGM_READ, &hBmp)))
                {
                    _PrepImage(&hBmp);
                    hr = _BitmapReady(hBmp);
                }
            }
            pStore->Close(&dwStoreLock);
        }
        pStore->Release();
    }

    if (FAILED(hr))
    {
        HBITMAP hbm;
        if (SUCCEEDED(_pei->Extract(&hbm)))
        {
            hr = _BitmapReady(hbm);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\thunktxt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       thunktxt.c
//
//  Contents:   Support routines to thunk API parameters ANSI <-> UNICODE
//
//  Functions:  ConvertStrings()
//
//  History:    2-03-95   davepl   Created
//
//--------------------------------------------------------------------------

#include <shellprv.h>
#pragma  hdrstop

//+-------------------------------------------------------------------------
//
//  Function:   ConvertStrings
//
//  Synopsis:   Converts a series of XCHAR strings into TCHAR strings,
//              packed as a series of pointers followed by a contiguous
//              block of memory where the output strings are stored.
//
//              Eg: ConvertStrings(4, "Hello", "", NULL, "World");
//
//              Returns a pointer to a block of memory as follows:
//
//              4  bytes         <address of L"Hello">
//              4  bytes         <address of L"">
//              4  bytes         NULL
//              4  bytes         <address of L"World">
//              12 bytes         L"Hello\0"
//              2  bytes         L"\0"
//              12 bytes         L"World\0"
//              ---------------------------------------------------
//              42 bytes
//
//              The strings may then be referenced as ThunkText.m_pStr[0],
//              [1], [2], and [3], where [2] is a NULL pointer.
//
//              When the caller is finished with the strings, the entire
//              block should be freed via LocalAlloc().
//
//  Arguments:  [cCount]            -- Number of strings passed, incl NULs
//              [pszOriginalString] -- The strings to convert
//              (... etc ...)
//
//  Returns:    Pointer to a ThunkText structure
//
//  History:    2-03-95   davepl   Created
//
//  Notes:      In UNICODE builds, converts ANSI to UNICODE.  In ANSI
//              builds, converts to UNICODE (if present).
//
//--------------------------------------------------------------------------

#ifdef UNICODE

ThunkText * ConvertStrings(UINT cCount, ...)
{
    ThunkText *  pThunkText   = NULL;
    UINT         cTmp;
    LPXSTR       pXChar;

    va_list     vaListMarker;

    //
    // Byte count is size of fixed members plus cCount pointers.  cbOffset
    // is the offset at which we will begin dumping strings into the struct
    //

    UINT cbStructSize =  SIZEOF(ThunkText) + (cCount - 1) * SIZEOF(LPTSTR);
    UINT cbOffset     =  cbStructSize;

    //
    // Scan the list of input strings, and add their lengths (in bytes, once
    // converted to TCHARs, incl NUL) to the output structure size
    //

    cTmp = 0;
    va_start(vaListMarker, cCount);
    do
    {
        pXChar = va_arg(vaListMarker, LPXSTR);
        if (pXChar)
        {
            cbStructSize += (lstrlenX(pXChar) + 1) * SIZEOF(TCHAR);
        }
        cTmp++;
    }
    while (cTmp < cCount);

    //
    // Allocate the output structure.
    //

    pThunkText = (ThunkText *) LocalAlloc(LMEM_FIXED, cbStructSize);
    if (NULL == pThunkText)
    {
        SetLastError((DWORD)E_OUTOFMEMORY);
        return NULL;
    }

    //
    // Convert each of the input strings into the allocated output
    // buffer.
    //

    cTmp = 0;
    va_start(vaListMarker, cCount);
    do
    {
        INT cchResult;
        
        pXChar = va_arg(vaListMarker, LPXSTR);      // grab next src XSTR

        if (NULL == pXChar)
        {
            pThunkText->m_pStr[cTmp] = NULL;
        }
        else
        {
            pThunkText->m_pStr[cTmp] = (LPTSTR)(((LPBYTE)pThunkText) + cbOffset);

        

            #ifdef UNICODE

            cchResult = MultiByteToWideChar(CP_ACP,      // code page
                                            0,           // flags
                                            pXChar,      // source XCHAR
                                            -1,          // assume NUL term
                                            pThunkText->m_pStr[cTmp],  //outbuf
                                            (cbStructSize - cbOffset) / sizeof(WCHAR) ); //buflen
            #else

            cchResult = WideCharToMultiByte(CP_ACP,      // code page
                                            0,           // flags
                                            pXChar,      // source XCHAR
                                            -1,          // assume NUL term
                                            pThunkText->m_pStr[cTmp], //outbuf
                                            (cbStructSize - cbOffset) / sizeof(CHAR),  //buflen
                                            NULL,        // default char
                                            NULL);       // &fDefUsed
            #endif

            //
            // Even a NUL string returns a 1 character conversion, so 0 means
            // the conversion failed.  Cleanup and bail.
            //

            if (0 == cchResult)
            {
                LocalFree(pThunkText);
                SetLastError((DWORD)E_FAIL);
                return NULL;
            }

            cbOffset += cchResult * SIZEOF(TCHAR);
         }
         cTmp++;
    } while (cTmp < cCount);

    return pThunkText;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\tooltip.h ===
//  --------------------------------------------------------------------------
//  Module Name: Tooltip.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements displaying a tooltip balloon.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _Tooltip_
#define     _Tooltip_

#include <limits.h>

//  --------------------------------------------------------------------------
//  CTooltip
//
//  Purpose:    A class that displays a tool tip balloon. It does all the
//              creation and positioning work if required. Control the life
//              span of the balloon with the object's life span.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

class   CTooltip
{
    private:
                        CTooltip (void);
    public:
                        CTooltip (HINSTANCE hInstance, HWND hwndParent);
                        ~CTooltip (void);

                void    SetPosition (LONG lPosX = LONG_MIN, LONG lPosY = LONG_MIN)  const;
                void    SetCaption (DWORD dwIcon, const TCHAR *pszCaption)          const;
                void    SetText (const TCHAR *pszText)                              const;
                void    Show (void)                                                 const;
    private:
                HWND    _hwnd;
                HWND    _hwndParent;
};

#endif  /*  _Tooltip_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\treewalk.h ===
/*
 * TREEWALK.h -- Shell Icon Overlay Manager
 */

#ifndef _TREEWALK_H_
#define _TREEWALK_H_

//
// Prototypes for all modules
//
#ifdef __cplusplus
extern "C" {
#endif
    
STDAPI CShellTreeWalker_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID *  ppvOut);
#ifdef __cplusplus
};
#endif

BOOL   BeenThereDoneThat(LPCTSTR pszOriginal, LPCTSTR pszPath);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\tlist.h ===
/* Template class for doing a simple linked list ...
 */
 
#ifndef _TLIST_H
#define _TLIST_H

// the enum marker that remembers the current position
typedef void * CLISTPOS;

// template class for providing a doubly linked of pointers to nodes
template< class NODETYPE >
class CList
{
    protected:
        struct CNode
        {
            NODETYPE * m_pData;
            CNode * m_pPrev;
            CNode * m_pNext;
        };
        
    public:
    CList();
    ~CList();


    CLISTPOS GetHeadPosition();
    NODETYPE * GetNext( CLISTPOS & rpCurPos );
    int GetCount();
    void RemoveAt( CLISTPOS pPos );
    void RemoveAll( void );
    CLISTPOS FindIndex( int iIndex );
    CLISTPOS AddTail( NODETYPE * pData );
    CLISTPOS AddBefore( CLISTPOS pPos, NODETYPE * pData );

#ifdef DEBUG
    void ValidateList();
#define VALIDATELIST()    ValidateList()
#else
#define VALIDATELIST()
#endif
    
    protected:
        CNode * m_pHead;
        CNode * m_pTail;
};

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CList<NODETYPE>::CList()
{
    m_pHead = NULL;
    m_pTail = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CList<NODETYPE>::~CList()
{
    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::GetHeadPosition( )
{
    return (CLISTPOS) m_pHead;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
NODETYPE * CList<NODETYPE>::GetNext( CLISTPOS & rpCurPos )
{
    ASSERT( rpCurPos != NULL );
    CNode * pCur = (CNode *) rpCurPos;

    NODETYPE * pData = pCur->m_pData;
    rpCurPos = (CLISTPOS) pCur->m_pNext;
        
    return pData;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
int CList<NODETYPE>::GetCount()
{
    int iLength = 0;
    CNode * pCur = m_pHead;

    while ( pCur != NULL )
    {
        pCur = pCur->m_pNext;
        iLength ++;
    }

    return iLength;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
void CList<NODETYPE>::RemoveAt( CLISTPOS pPos )
{
    ASSERT( pPos != NULL );
    
#ifdef _DEBUG
    // scan the list to ensure the marker is valid....
    CNode * pCur = m_pHead;

    while ( pCur != NULL )
    {
        if ( pCur == (CNode *) pPos )
        {
            break;
        }
        pCur = pCur->m_pNext;
    }
    ASSERT( pCur != NULL )
#endif

    CNode * pRealPos = (CNode *) pPos;
    if ( pRealPos->m_pPrev == NULL )
    {
        // we are at the start of the list
        m_pHead = pRealPos->m_pNext;
    }
    else
    {
        // link the prev one to the next one (bypassing this one)
        pRealPos->m_pPrev->m_pNext = pRealPos->m_pNext;
    }
    
    if ( pRealPos->m_pNext == NULL )
    {
        // we are at the end of the list
        m_pTail = pRealPos->m_pPrev;
    }
    else
    {
        // link the next to the prev (bypassing this one)
        pRealPos->m_pNext->m_pPrev = pRealPos->m_pPrev;
    }

    LocalFree( pRealPos );

    VALIDATELIST();
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::FindIndex( int iIndex )
{
    ASSERT( iIndex >= 0 );

    CNode * pCur = m_pHead;
    while ( iIndex > 0 && pCur != NULL )
    {
        pCur = pCur->m_pNext;
        iIndex --;
    }

    return (CLISTPOS)(iIndex == 0 ? pCur : NULL );
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
void CList<NODETYPE>::RemoveAll( void )
{
    // note we will not free the data elements, the client must do this...
    CNode * pCur = m_pHead;

    while (pCur != NULL )
    {
        CNode * pTmp = pCur->m_pNext;

        LocalFree( pCur );
        pCur = pTmp;
    }

    m_pHead = m_pTail = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::AddTail( NODETYPE * pData )
{
    CNode * pCurTail = m_pTail;
    CNode * pNewNode = (CNode * ) LocalAlloc( GPTR, sizeof( CNode ));

    if ( pNewNode == NULL )
    {
        return NULL;
    }

    pNewNode->m_pData = pData;
    pNewNode->m_pPrev = pCurTail;
    pNewNode->m_pNext = NULL;
    
    m_pTail = pNewNode;
    
    if ( pCurTail != NULL )
    {
        // we are not an empty list
        pCurTail->m_pNext = pNewNode;
    }
    else
    {
        m_pHead = pNewNode;
    }

    VALIDATELIST();
    
    return (CLISTPOS) pNewNode;
}


/////////////////////////////////////////////////////////////////////////////////////////
template< class NODETYPE >
CLISTPOS CList<NODETYPE>::AddBefore( CLISTPOS pPos, NODETYPE * pData )
{
    if ( !pPos )
    {
        return NULL;
    }

    CNode * pPrev = (CNode *) pPos;
    CNode * pNewNode = (CNode * ) LocalAlloc( GPTR, sizeof( CNode ));
    if ( pNewNode == NULL )
    {
        return NULL;
    }

    pNewNode->m_pData = pData;
    pNewNode->m_pPrev = pPrev->m_pPrev;
    pNewNode->m_pNext = pPrev;

    if ( pPrev->m_pPrev != NULL )
    {
        pPrev->m_pPrev->m_pNext = pNewNode;
    }
    else
    {
        // must be at the start of the list...
        m_pHead = pNewNode;
    }
    
    pPrev->m_pPrev = pNewNode;

    VALIDATELIST();
    
    return (CLISTPOS) pNewNode;
}

/////////////////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
template< class NODETYPE >
void CList<NODETYPE>::ValidateList( )
{
    CNode * pPos = m_pHead;
    while ( pPos )
    {
        ASSERT( pPos->m_pData );
        if ( pPos != m_pHead )
        {
            ASSERT( pPos->m_pPrev );
        }
        pPos = pPos->m_pNext;
    }

    pPos = m_pTail;
    while ( pPos )
    {
        ASSERT( pPos->m_pData );
        if ( pPos != m_pTail )
        {
            ASSERT( pPos->m_pNext );
        }
        pPos = pPos->m_pPrev;
    }
    if ( m_pHead || m_pTail )
    {
        ASSERT( !m_pHead->m_pPrev );
        ASSERT( m_pTail );
        ASSERT( m_pHead );
        ASSERT( !m_pTail->m_pNext );
    }
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\tracker.cpp ===
//
//  History:    1-Mar-95   BillMo      Created.
//              ...
//              01-Dec-96  MikeHill    Converted to new NT5 implementation.
#include "shellprv.h"
#pragma hdrstop

#define LINKDATA_AS_CLASS
#include <linkdata.hxx>
#include "shelllnk.h"

// NTRAID95363-2000-03-19:  These four inlines are copied from private\net\svcdlls\trksvcs\common\trklib.hxx
// They should be moved to linkdata.hxx

inline
CDomainRelativeObjId::operator == (const CDomainRelativeObjId &Other) const
{
    return(_volume == Other._volume && _object == Other._object);
}

inline
CDomainRelativeObjId::operator != (const CDomainRelativeObjId &Other) const
{
    return !(*this == Other);
}

inline
CVolumeId:: operator == (const CVolumeId & Other) const
{
    return(0 == memcmp(&_volume, &Other._volume, sizeof(_volume)));
}

inline
CVolumeId:: operator != (const CVolumeId & Other) const
{
    return ! (Other == *this);
}

//+----------------------------------------------------------------------------
//
//  Function:   RPC free/alloc routines
//
//  Synopsis:   CTracker uses MIDL-generated code to call an RPC server,
//              and MIDL-generated code assumes that the following routines
//              be provided.
//
//+----------------------------------------------------------------------------

void __RPC_USER MIDL_user_free(void __RPC_FAR *pv) 
{ 
    LocalFree(pv); 
}


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t s) 
{ 
    return (void __RPC_FAR *) LocalAlloc(LMEM_FIXED, s); 
}

//+----------------------------------------------------------------------------
//
//  Method:     IUnknown methods
//
//  Synopsis:   IUnknown methods for the ISLTracker interface.
//
//+----------------------------------------------------------------------------

STDMETHODIMP CTracker::QueryInterface(REFIID riid, void **ppvObj)
{
    return _psl->QueryInterface(riid, ppvObj);
}

STDMETHODIMP_(ULONG) CTracker::AddRef()
{
    return _psl->AddRef();
}

STDMETHODIMP_(ULONG) CTracker::Release()
{
    return _psl->Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     ISLTracker custom methods
//
//  Synopsis:   This interface is private and is only used for testing.
//              This provides test programs the ability to specify the
//              TrackerRestrictions (from the TrkMendRestrictions enum)
//              and the ability to get the internal IDs.
//
//+----------------------------------------------------------------------------

HRESULT CTracker::Resolve(HWND hwnd, DWORD dwResolveFlags, DWORD dwTracker)
{
    return _psl->_Resolve(hwnd, dwResolveFlags, dwTracker);
}

HRESULT CTracker::GetIDs(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid)
{
    if (!_fLoaded)
        return E_UNEXPECTED;

    *pdroidBirth = _droidBirth;
    *pdroidLast = _droidLast;
    *pmcid = _mcidLast;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  Synopsis:   Initializes the data members used for RPC.  This should be
//              called either by InitNew or Load.
//
//  Arguments:  None
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------


HRESULT CTracker::InitRPC()
{
    HRESULT hr = S_OK;

    if (!_fCritsecInitialized)
    {
        InitializeCriticalSection(&_cs);
        _fCritsecInitialized = TRUE;
    }

    if (NULL == _pRpcAsyncState)
    {
        _pRpcAsyncState = reinterpret_cast<PRPC_ASYNC_STATE>(new BYTE[ sizeof(RPC_ASYNC_STATE) ]);
        if (NULL == _pRpcAsyncState)
        {
            hr = HRESULT_FROM_WIN32(E_OUTOFMEMORY);
            goto Exit;
        }
    }

    if (NULL == _hEvent)
    {
        _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); // Auto-reset, not initially signaled
        if (NULL == _hEvent)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

Exit:

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Synopsis:   Initializes the CTracker object.  This method may be called
//              repeatedly, i.e. it may be called to clear/reinit the object.
//              This method need not be called before calling the Load method.
//
//  Arguments:  None
//
//  Returns:    [HRESULT]
//
//+----------------------------------------------------------------------------

HRESULT CTracker::InitNew()
{
    HRESULT hr = InitRPC();
    if (SUCCEEDED(hr)) 
    {
        _mcidLast = CMachineId();
        _droidLast = CDomainRelativeObjId();
        _droidBirth = CDomainRelativeObjId();

        _fDirty = FALSE;
        _fLoaded = FALSE;
        _fMendInProgress = FALSE;
        _fUserCancelled = FALSE;
    }
    return hr;
}   // CTracker::InitNew()


//+----------------------------------------------------------------------------
//
//  Synopsis:   Get tracking state from the given file handle.  Note that this
//              is expected to fail if the referrent file isn't on an
//              NTFS5 volume.
//          
//
//  Arguments:  [hFile]
//                  The file to track
//              [ptszFile]
//                  The name of the file
//
//  Returns:    [HRESULT]
//
//-----------------------------------------------------------------------------

HRESULT CTracker::InitFromHandle(const HANDLE hFile, const TCHAR* ptszFile)
{
    NTSTATUS status = STATUS_SUCCESS;

    FILE_OBJECTID_BUFFER fobOID;
    DWORD cbReturned;

    CDomainRelativeObjId droidLast;
    CDomainRelativeObjId droidBirth;
    CMachineId           mcidLast;

    // Initialize the RPC members

    HRESULT hr = InitRPC();
    if (FAILED(hr)) 
        goto Exit;

    //  -----------------------------------
    //  Get the Object ID Buffer (64 bytes)
    //  -----------------------------------

    // Use the file handle to get the file's Object ID.  Tell the filesystem to give us the
    // existing object ID if the file already has one, or to create a new one otherwise.

    memset(&fobOID, 0, sizeof(fobOID));

    if (!DeviceIoControl(hFile, FSCTL_CREATE_OR_GET_OBJECT_ID,
                          NULL, 0,                      // No input buffer
                          &fobOID, sizeof(fobOID),      // Output buffer
                          &cbReturned, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //  ----------------------
    //  Load the Droids & MCID
    //  ----------------------

    status = droidLast.InitFromFile(hFile, fobOID);
    if (!NT_SUCCESS(status))
    {
        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(status));
        goto Exit;
    }

    droidBirth.InitFromFOB(fobOID);
    droidBirth.GetVolumeId().Normalize();

    if (FAILED(mcidLast.InitFromPath(ptszFile, hFile)))
        mcidLast = CMachineId();

    //  ----
    //  Exit
    //  ----

    if (_mcidLast   != mcidLast
        ||
        _droidLast  != droidLast
        ||
        _droidBirth != droidBirth
     )
    {
        _mcidLast   = mcidLast;
        _droidLast  = droidLast;
        _droidBirth = droidBirth;
        _fDirty = TRUE;
    }

    _fLoaded = TRUE;            // Cleared in InitNew
    _fLoadedAtLeastOnce = TRUE; // Not cleared in InitNew

    hr = S_OK;

Exit:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Synopsis:   Load the tracker from the memory buffer.  The InitNew
//              method need not be called before calling this method.
//
//  Arguments:  [pb] -- buffer to load from
//              [cb] -- size of pb buffer
//
//  Returns:    [HRESULT]
//
//--------------------------------------------------------------------

#define CTRACKER_VERSION    0

HRESULT CTracker::Load(BYTE *pb, ULONG cb)
{
    DWORD dwLength;

    // Initialize RPC if it hasn't been already.

    HRESULT hr = InitRPC();
    if (FAILED(hr)) 
        goto Exit;

    // Check the length

    dwLength = *reinterpret_cast<DWORD*>(pb);
    if (dwLength < GetSize())
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    pb += sizeof(dwLength);

    // Check the version number

    if (CTRACKER_VERSION != *reinterpret_cast<DWORD*>(pb))
    {
        hr = HRESULT_FROM_WIN32(ERROR_REVISION_MISMATCH);
        goto Exit;
    }

    pb += sizeof(DWORD);    // Skip past the version

    // Get the machine ID & droids

    _mcidLast = *reinterpret_cast<CMachineId*>(pb);
    pb += sizeof(_mcidLast);

    _droidLast = *reinterpret_cast<CDomainRelativeObjId*>(pb);
    pb += sizeof(_droidLast);

    _droidBirth = *reinterpret_cast<CDomainRelativeObjId*>(pb);
    pb += sizeof(_droidBirth);

    _fLoaded = TRUE;            // Cleared in InitNew
    _fLoadedAtLeastOnce = TRUE; // Not cleared in InitNew


    hr = S_OK;

Exit:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CTracker::Save
//
//  Synopsis:   Save tracker to the given buffer.
//
//  Arguments:  [pb]     -- buffer for tracker.
//              [cbSize] -- size of buffer in pb
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID CTracker::Save(BYTE *pb, ULONG cbSize)
{
    // Save the length
    *reinterpret_cast<DWORD*>(pb) = GetSize();
    pb += sizeof(DWORD);

    // Save a version number
    *reinterpret_cast<DWORD*>(pb) = CTRACKER_VERSION;
    pb += sizeof(DWORD);

    // Save the machine & DROIDs

    *reinterpret_cast<CMachineId*>(pb) = _mcidLast;
    pb += sizeof(_mcidLast);

    *reinterpret_cast<CDomainRelativeObjId*>(pb) = _droidLast;
    pb += sizeof(_droidLast);

    *reinterpret_cast<CDomainRelativeObjId*>(pb) = _droidBirth;
    pb += sizeof(_droidBirth);

    _fDirty = FALSE;

}   // CTracker::Save()


//+-------------------------------------------------------------------
//
//  Synopsis:   Search for the object referred to by the tracker.
//
//  Arguments:  [dwTickCountDeadline] -- absolute tick count for deadline
//              [pfdIn]               -- may not be NULL
//              [pfdOut]              -- may not be NULL
//                                       will contain updated data on success
//              [uShlinkFlags]       -- SLR_ flags
//              [TrackerRestrictions] -- TrkMendRestrictions enumeration
//
//  Returns:    [HRESULT]
//               S_OK
//                  found (pfdOut contains new info)
//              E_UNEXPECTED
//                  CTracker::InitNew hasn't bee called.
//              HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED)
//                  Restrictions (set in registry) are set such that
//                  this operation isn't to be performed.
//
//--------------------------------------------------------------------


HRESULT CTracker::Search(const DWORD dwTickCountDeadline,
                         const WIN32_FIND_DATA *pfdIn,
                         WIN32_FIND_DATA *pfdOut,
                         UINT  uShlinkFlags,
                         DWORD TrackerRestrictions)
{
    HRESULT hr = S_OK;
    TCHAR ptszError = NULL;
    WIN32_FILE_ATTRIBUTE_DATA fadNew;
    WIN32_FIND_DATA fdNew = *pfdIn;
    DWORD cbFileName;
    BOOL fPotentialFileFound = FALSE;
    BOOL fLocked = FALSE;
    DWORD dwCurrentTickCount = 0;

    RPC_TCHAR          *ptszStringBinding = NULL;
    RPC_BINDING_HANDLE  BindingHandle;
    RPC_STATUS          rpcstatus;

    CDomainRelativeObjId droidBirth, droidLast, droidCurrent;
    CMachineId mcidCurrent;

    // Initialize the output

    memset(pfdOut, 0, sizeof(*pfdOut));

    // Abort if restrictions don't allow this operation

    if (SHRestricted(REST_NORESOLVETRACK) ||
        (SLR_NOTRACK & uShlinkFlags))
    {
        hr = HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED);
        goto Exit;
    }

    // Ensure that we've been loaded first

    else if (!_fLoaded)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Capture the current tick count

    dwCurrentTickCount = GetTickCount();

    if ((long) dwTickCountDeadline <= (long) dwCurrentTickCount)
    {
        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
        goto Exit;
    }


    //
    // Create an RPC binding
    //

    rpcstatus = RpcStringBindingCompose(NULL,
                                        TEXT("ncalrpc"),
                                        NULL,
                                        TRKWKS_LRPC_ENDPOINT_NAME,
                                        NULL,
                                        &ptszStringBinding);

    if (RPC_S_OK == rpcstatus)
        rpcstatus = RpcBindingFromStringBinding(ptszStringBinding, &BindingHandle);

    if (RPC_S_OK != rpcstatus)
    {
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    //
    // Initialize an RPC Async handle
    //

    //  Take the lock
    EnterCriticalSection(&_cs);  fLocked = TRUE;

    // Verify that we were initialized properly
    if (NULL == _hEvent || NULL == _pRpcAsyncState)
    {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }
    
    rpcstatus = RpcAsyncInitializeHandle(_pRpcAsyncState, RPC_ASYNC_VERSION_1_0);
    if (RPC_S_OK != rpcstatus)
    {
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    _pRpcAsyncState->NotificationType = RpcNotificationTypeEvent;
    _pRpcAsyncState->u.hEvent = _hEvent;
    _pRpcAsyncState->UserInfo = NULL;


    //
    // Call the tracking service to find the file
    //

    __try
    {
        SYSTEMTIME stNow;
        FILETIME ftDeadline;
        DWORD dwDeltaMillisecToDeadline;

        // NOTE:  The following four assignments used to be above the
        // __try.  But that appears to trigger a compiler problem, where
        // some of the assignments do not make it to the .obj in an optimized
        // build (bug 265255).

        droidLast = _droidLast;
        droidBirth = _droidBirth;
        mcidCurrent = _mcidLast;

        cbFileName = sizeof(fdNew.cFileName);

        // Convert the tick-count deadline into a UTC filetime.

        dwDeltaMillisecToDeadline = (DWORD)((long)dwTickCountDeadline - (long)dwCurrentTickCount);
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &ftDeadline);
        *reinterpret_cast<LONGLONG*>(&ftDeadline) += (dwDeltaMillisecToDeadline * 10*1000);

        // Start the async RPC call to the tracking service

        _fMendInProgress = TRUE;
        LnkMendLink(_pRpcAsyncState,
                     BindingHandle,
                     ftDeadline,
                     TrackerRestrictions,
                     const_cast<CDomainRelativeObjId*>(&droidBirth),
                     const_cast<CDomainRelativeObjId*>(&droidLast),
                     const_cast<CMachineId*>(&_mcidLast),
                     &droidCurrent,
                     &mcidCurrent,
                     &cbFileName,
                     fdNew.cFileName);

        // Wait for the call to return.  Release the lock first, though, so that
        // the UI thread can come in and cancel.

        LeaveCriticalSection(&_cs); fLocked = FALSE;
        
        DWORD dwWaitReturn = WaitForSingleObject(_hEvent, dwDeltaMillisecToDeadline);

        // Now take the lock back and see what happenned.

        EnterCriticalSection(&_cs); fLocked = TRUE;
        _fMendInProgress = FALSE;

        if ((WAIT_TIMEOUT == dwWaitReturn) || _fUserCancelled)
        {
            // We timed out waiting for a response.  Cancel the call.
            // If the call should complete between the time
            // we exited the WaitForSingleObject and the cancel call below,
            // then the cancel will be ignored by RPC.
            
            rpcstatus = RpcAsyncCancelCall(_pRpcAsyncState, TRUE); // fAbort

            if (_fUserCancelled)
            {
                _fUserCancelled = FALSE;
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                __leave;
            }
            else if (RPC_S_OK != rpcstatus)
            {
                hr = HRESULT_FROM_WIN32(rpcstatus);
                __leave;
            }
        }
        else if (WAIT_OBJECT_0 != dwWaitReturn)
        {
            // There was an error of some kind.
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        // Now we find out how the LnkMendLink call completed.  If we get
        // RPC_S_OK, then it completed normally, and the result is
        // in hr.

        rpcstatus = RpcAsyncCompleteCall(_pRpcAsyncState, &hr);
        if (RPC_S_OK != rpcstatus)
        {
            // The call either failed or was cancelled (the reason for the
            // cancel would be that the UI thread called CTracker::CancelSearch,
            // or because we timed out above and called RpcAsyncCancelCall).

            hr = HRESULT_FROM_WIN32(rpcstatus);
            __leave;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _fMendInProgress = FALSE;
        _fUserCancelled = FALSE;
        hr = HRESULT_FROM_WIN32(RpcExceptionCode());
    }


    // free the binding
    RpcBindingFree(&BindingHandle);

    if (HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND) == hr)
    {
        fPotentialFileFound = TRUE;
        hr = S_OK;
    }

    if (FAILED(hr)) goto Exit;

    //
    // See if this is in the recycle bin
    //

    if (IsFileInBitBucket(fdNew.cFileName))
    {
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Now that we know what the new filename is, let's get all
    // the FindData info.
    //

    if (!GetFileAttributesEx(fdNew.cFileName, GetFileExInfoStandard, &fadNew))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Ensure that the file we found has the same "directory-ness"
    // as the last known link source (either they're both a directory
    // or they're both a file).  Also ensure that the file we found
    // isn't itself a link client (a shell shortcut).

    if (((fadNew.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
          ^
          (pfdIn->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
       )
        ||
        PathIsLnk(fdNew.cFileName)
     )
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    // Copy the file attributes into the WIN32_FIND_DATA structure.

    fdNew.dwFileAttributes = fadNew.dwFileAttributes;
    fdNew.ftCreationTime = fadNew.ftCreationTime;
    fdNew.ftLastAccessTime = fadNew.ftLastAccessTime;
    fdNew.ftLastWriteTime = fadNew.ftLastWriteTime;
    fdNew.nFileSizeLow = fadNew.nFileSizeLow;

    // Return the new finddata to the caller.

    *pfdOut = fdNew;

    // Update our local state

    if (_droidLast != droidCurrent
        ||
        _droidBirth != droidBirth
        ||
        _mcidLast != mcidCurrent
     )
    {
        _droidLast = droidCurrent;
        _droidBirth = droidBirth;
        _mcidLast = mcidCurrent;

        _fDirty = TRUE;
    }

Exit:

    if (fLocked)
        LeaveCriticalSection(&_cs);

    if (ptszStringBinding)
        RpcStringFree(&ptszStringBinding);

    if (FAILED(hr))
        DebugMsg(DM_TRACE, TEXT("CTracker::Search failed (hr=0x%08X)"), hr);
    else if (fPotentialFileFound)
        hr = HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND);

    return(hr);

}   // CTracker::Search()

//+----------------------------------------------------------------------------
//
//  Synopsis:   This method is called on a thread signal another thread
//              which is in CTracker::Search to abort the LnkMendLink
//              call.
//
//  Returns:    [HRESULT]
//
//-----------------------------------------------------------------------------

STDMETHODIMP CTracker::CancelSearch()
{
    EnterCriticalSection(&_cs);
    
    // If a search is in progress, cancel it.

    if (_fMendInProgress && NULL != _pRpcAsyncState)
    {
        _fUserCancelled = TRUE;
        SetEvent(_hEvent);  // SetEvent so as to unblock the Tracker Worker thread.         
    }

    LeaveCriticalSection(&_cs);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Look at a path and determine the computer name of the host machine.
//  In the future, we should remove this code, and add the capbility to query
//  handles for their computer name.
//
//  GetServerComputer name uses ScanForComputerName and ConvertDfsPath
//  as helper functions.
//
//  The name can only be obtained for NetBios paths - if the path is IP or DNS
//  an error is returned.  (If the NetBios name has a "." in it, it will
//  cause an error because it will be misinterpreted as a DNS path.  This case
//  becomes less and less likely as the NT5 UI doesn't allow such computer names.)
//  For DFS paths, the leaf server's name is returned, as long as it wasn't
//  joined to its parent with an IP or DNS path name.
//
//+----------------------------------------------------------------------------

const UNICODE_STRING NtUncPathNamePrefix = { 16, 18, L"\\??\\UNC\\"};
#define cchNtUncPathNamePrefix  8

const UNICODE_STRING NtDrivePathNamePrefix = { 8, 10, L"\\??\\" };
#define cchNtDrivePathNamePrefix  4

const WCHAR RedirectorMappingPrefix[] = { L"\\Device\\LanmanRedirector\\;" };
const WCHAR LocalVolumeMappingPrefix[] = { L"\\Device\\Volume" };
const WCHAR CDRomMappingPrefix[] = { L"\\Device\\CDRom" };
const WCHAR FloppyMappingPrefix[] = { L"\\Device\\Floppy" };
const WCHAR DfsMappingPrefix[] = { L"\\Device\\WinDfs\\" };


//
//  ScanForComputerName:
//
//  Scan the path in ServerFileName (which is a UNICODE_STRING with
//  a full NT path name), searching for the computer name.  If it's
//  found, point to it with UnicodeComputerName.Buffer, and set
//  *AvailableLength to show how much readable memory is after that
//  point.
//

HRESULT ScanForComputerName(HANDLE hFile, const UNICODE_STRING &ServerFileName,
                            UNICODE_STRING *UnicodeComputerName, ULONG *AvailableLength,
                            WCHAR *DosDeviceMapping, ULONG cchDosDeviceMapping,
                            PFILE_NAME_INFORMATION FileNameInfo, ULONG cbFileNameInfo,
                            BOOL *CheckForDfs)
{

    HRESULT hr = S_OK;

    // Is this a UNC path?

    if (RtlPrefixString((PSTRING)&NtUncPathNamePrefix, (PSTRING)&ServerFileName, TRUE)) 
    {
        // Make sure there's some more to this path than just the prefix
        if (ServerFileName.Length <= NtUncPathNamePrefix.Length)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

        // It appears to be a valid UNC path.  Point to the beginning of the computer
        // name, and calculate how much room is left in ServerFileName after that.

        UnicodeComputerName->Buffer = &ServerFileName.Buffer[ NtUncPathNamePrefix.Length/sizeof(WCHAR) ];
        *AvailableLength = ServerFileName.Length - NtUncPathNamePrefix.Length;
    }
    else if (RtlPrefixString((PSTRING)&NtDrivePathNamePrefix, (PSTRING)&ServerFileName, TRUE)
             &&
             ServerFileName.Buffer[ cchNtDrivePathNamePrefix + 1 ] == L':') 
    {
        // Get the correct, upper-cased, drive letter into DosDevice.

        WCHAR DosDevice[3] = { L"A:" };

        DosDevice[0] = ServerFileName.Buffer[ cchNtDrivePathNamePrefix ];
        if (L'a' <= DosDevice[0] && DosDevice[0] <= L'z')
            DosDevice[0] = L'A' + (DosDevice[0] - L'a');

        // Map the drive letter to its symbolic link under \??.  E.g., say D: & R:
        // are DFS/rdr drives, you would then see something like:
        //
        //   D: => \Device\WinDfs\G
        //   R: => \Device\LanmanRedirector\;R:0\scratch\scratch

        if (!QueryDosDevice(DosDevice, DosDeviceMapping, cchDosDeviceMapping))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        // Now that we have the DosDeviceMapping, we can check ... Is this a rdr drive?

        if (// Does it begin with "\Device\LanmanRedirector\;" ?
            0 == wcsncmp(DosDeviceMapping, RedirectorMappingPrefix, lstrlenW(RedirectorMappingPrefix))
            &&
            // Are the next letters the correct drive letter, a colon, and a whack?
            (DosDevice[0] == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) - 1 ]
              &&
              L':' == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) ]
              &&
              (UnicodeComputerName->Buffer = StrChrW(&DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) + 1 ], L'\\'))
           ))
        {
            // We have a valid rdr drive.  Point to the beginning of the computer
            // name, and calculate how much room is availble in DosDeviceMapping after that.

            UnicodeComputerName->Buffer += 1;
            *AvailableLength = sizeof(DosDeviceMapping) - sizeof(DosDeviceMapping[0]) * (ULONG)(UnicodeComputerName->Buffer - DosDeviceMapping);

            // We know now that it's not a DFS path
            *CheckForDfs = FALSE;
        }
        else if (0 == wcsncmp(DosDeviceMapping, DfsMappingPrefix, lstrlenW(DfsMappingPrefix)))
        {

            // Get the full UNC name of this DFS path.  Later, we'll call the DFS
            // driver to find out what the actual server name is.

            IO_STATUS_BLOCK IoStatusBlock;
            NTSTATUS NtStatus = NtQueryInformationFile(hFile,
                        &IoStatusBlock, FileNameInfo, cbFileNameInfo,  FileNameInformation);
            if (!NT_SUCCESS(NtStatus)) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
                goto Exit;
            }

            UnicodeComputerName->Buffer = FileNameInfo->FileName + 1;
            *AvailableLength = FileNameInfo->FileNameLength;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

    }   // else if (RtlPrefixString((PSTRING)&NtDrivePathNamePrefix, (PSTRING)&ServerFileName, TRUE) ...
    else 
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }
Exit:
    return hr;
}


//
//  Try to convert the path name pointed to by UnicodeComputerName.Buffer
//  into a DFS path name.  The caller provides DfsServerPathName as a buffer
//  for the converted name.  If it's a DFS path, then update UnicodeComputerName.Buffer
//  to point to the conversion, otherwise leave it unchanged.
//

HRESULT ConvertDfsPath(HANDLE hFile, UNICODE_STRING *UnicodeComputerName, 
                       ULONG *AvailableLength, WCHAR *DfsServerPathName, ULONG cbDfsServerPathName)
{
    HRESULT hr = S_OK;
    HANDLE hDFS = INVALID_HANDLE_VALUE;
    UNICODE_STRING DfsDriverName;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;

    WCHAR *DfsPathName = UnicodeComputerName->Buffer - 1;    // Back up to the whack
    ULONG DfsPathNameLength = *AvailableLength + sizeof(WCHAR);

    // Open the DFS driver

    RtlInitUnicodeString(&DfsDriverName, L"\\Dfs");
    InitializeObjectAttributes(&ObjectAttributes,
                                &DfsDriverName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                           );

    NtStatus = NtCreateFile(
                    &hDFS,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
               );

    if (!NT_SUCCESS(NtStatus)) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    // Query DFS's cache for the server name.  The name is guaranteed to
    // remain in the cache as long as the file is open.

    if (L'\\' != DfsPathName[0]) 
    {
        NtClose(hDFS);
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    NtStatus = NtFsControlFile(
                    hDFS,
                    NULL,       // Event,
                    NULL,       // ApcRoutine,
                    NULL,       // ApcContext,
                    &IoStatusBlock,
                    FSCTL_DFS_GET_SERVER_NAME,
                    DfsPathName,
                    DfsPathNameLength,
                    DfsServerPathName,
                    cbDfsServerPathName);
    NtClose(hDFS);

    // STATUS_OBJECT_NAME_NOT_FOUND means that it's not a DFS path
    if (!NT_SUCCESS(NtStatus)) 
    {

        if (STATUS_OBJECT_NAME_NOT_FOUND != NtStatus ) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }
    }
    else if (L'\0' != DfsServerPathName[0]) 
    {

        // The previous DFS call returns the server-specific path to the file in UNC form.
        // Point UnicodeComputerName to just past the two whacks.

        *AvailableLength = lstrlenW(DfsServerPathName) * sizeof(WCHAR);
        if (3*sizeof(WCHAR) > *AvailableLength
            ||
            L'\\' != DfsServerPathName[0]
            ||
            L'\\' != DfsServerPathName[1])
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

        UnicodeComputerName->Buffer = DfsServerPathName + 2;
        *AvailableLength -= 2 * sizeof(WCHAR);
    }

Exit:
    return hr;
}

//  Take pwszFile, which is a path to a remote machine, and get the 
//  server machine's computer name.

HRESULT GetRemoteServerComputerName(LPCWSTR pwszFile, HANDLE hFile, WCHAR *pwszComputer)
{
    HRESULT hr = S_OK;
    ULONG cbComputer = 0;
    ULONG AvailableLength = 0;
    PWCHAR PathCharacter = NULL;
    BOOL CheckForDfs = TRUE;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    WCHAR FileNameInfoBuffer[MAX_PATH+sizeof(FILE_NAME_INFORMATION)];
    PFILE_NAME_INFORMATION FileNameInfo = (PFILE_NAME_INFORMATION)FileNameInfoBuffer;
    WCHAR DfsServerPathName[ MAX_PATH + 1 ];
    WCHAR DosDeviceMapping[ MAX_PATH + 1 ];

    UNICODE_STRING UnicodeComputerName;
    UNICODE_STRING ServerFileName;

    // Canonicalize the file name into the NT object directory namespace.

    RtlInitUnicodeString(&UnicodeComputerName, NULL);
    RtlInitUnicodeString(&ServerFileName, NULL);
    if (!RtlDosPathNameToNtPathName_U(pwszFile, &ServerFileName, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    // Point UnicodeComputerName.Buffer at the beginning of the computer name.

    hr = ScanForComputerName(hFile, ServerFileName, &UnicodeComputerName, &AvailableLength,
                              DosDeviceMapping, ARRAYSIZE(DosDeviceMapping),
                              FileNameInfo, sizeof(FileNameInfoBuffer), &CheckForDfs);
    if (FAILED(hr)) 
        goto Exit;

    // If there was no error but we don't have a computer name, then the file is on 
    // the local computer.

    if (NULL == UnicodeComputerName.Buffer)
    {
        DWORD cchName = MAX_COMPUTERNAME_LENGTH + 1;
        hr = S_OK;

        if (!GetComputerNameW(pwszComputer, &cchName))
            hr = HRESULT_FROM_WIN32(GetLastError());

        goto Exit;
    }

    // If we couldn't determine above whether or not this is a DFS path, let the
    // DFS driver decide now.

    if (CheckForDfs && INVALID_HANDLE_VALUE != hFile) 
    {
        // On return, UnicodeComputerName.Buffer points to the leaf machine's
        // UNC name if it's a DFS path.  If it's not a DFS path, 
        // .Buffer is left unchanged.

        hr = ConvertDfsPath(hFile, &UnicodeComputerName, &AvailableLength,
                             DfsServerPathName, sizeof(DfsServerPathName));
        if (FAILED(hr))
            goto Exit;
    }

    // If we get here, then the computer name\share is pointed to by UnicodeComputerName.Buffer.
    // But the Length is currently zero, so we search for the whack that separates
    // the computer name from the share, and set the Length to include just the computer name.

    PathCharacter = UnicodeComputerName.Buffer;

    while(((ULONG) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer) < AvailableLength)
           &&
           *PathCharacter != L'\\') 
    {
        // If we found a '.', we fail because this is probably a DNS or IP name.
        if (L'.' == *PathCharacter) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto Exit;
        }

        PathCharacter++;
    }

    // Set the computer name length

    UnicodeComputerName.Length = UnicodeComputerName.MaximumLength
        = (USHORT) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer);

    // Fail if the computer name exceeded the length of the input ServerFileName,
    // or if the length exceeds that allowed.

    if (UnicodeComputerName.Length >= AvailableLength
        ||
        UnicodeComputerName.Length > MAX_COMPUTERNAME_LENGTH*sizeof(WCHAR)) 
    {
        goto Exit;
    }

    // Copy the computer name into the caller's buffer, as long as there's enough
    // room for the name & a terminating '\0'.

    if (UnicodeComputerName.Length + sizeof(WCHAR) > (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR)) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto Exit;
    }

    RtlCopyMemory(pwszComputer, UnicodeComputerName.Buffer, UnicodeComputerName.Length);
    pwszComputer[ UnicodeComputerName.Length / sizeof(WCHAR) ] = L'\0';

    hr = S_OK;

Exit:

    RtlFreeHeap(RtlProcessHeap(), 0, ServerFileName.Buffer);
    return hr;
}

//  Give a file's path & handle, determine the computer name of the server
//  on which that file resides (which could just be this machine).

HRESULT GetServerComputerName(LPCWSTR pwszFile, HANDLE hFile, WCHAR *pwszComputer)
{
    // pwszFile may be a local path name. Convert it into an absolute name.
    HRESULT hr;
    WCHAR wszAbsoluteName[ MAX_PATH + 1 ], *pwszFilePart;
    if (GetFullPathName(pwszFile, ARRAYSIZE(wszAbsoluteName), wszAbsoluteName, &pwszFilePart))
    {
        if (pwszFilePart)
            *pwszFilePart = 0;
        // Check to see if this points to a local or remote drive.  Terminate
        // the path at the beginning of the file name, so that the path ends in
        // a whack.  This allows GetDriveType to determine the type without being
        // give a root path.

        UINT DriveType = GetDriveType(wszAbsoluteName);

        if (DRIVE_REMOTE == DriveType)
        {
            // We have a remote drive (could be a UNC path or a redirected drive).
            hr = GetRemoteServerComputerName(wszAbsoluteName, hFile, pwszComputer);
        }
        else if (DRIVE_UNKNOWN == DriveType ||
                 DRIVE_NO_ROOT_DIR == DriveType)
        {
            // We have an unsupported type
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        }
        else
        {
            // We have a path to the local machine.

            DWORD cchName = MAX_COMPUTERNAME_LENGTH + 1;
            if (!GetComputerNameW(pwszComputer, &cchName))
                hr = HRESULT_FROM_WIN32(GetLastError());
            else
                hr = S_OK;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\treewalk.cpp ===
// This file contains the implementation of CShellTreeWalker, a COM object
// that inherits IShellTreeWalker, and it will recursively enumerate all the
// files (or directories or both) starting from a root directory that match a
// certain spec. 
// 1. The tree walker is reparse point aware, it does not traverse into reparse 
// point folders by default, but will if specified
// 2. It keeps track of the number of files, directories, depth, and total
// size of all files encountered.
// 3. It will stop the traversal right away if any error message is returned
// from the callback functions except for E_NOTIMPL
// 4. It will jump out of the current working directory if S_FALSE is returned from callback
// functions.
//
// History:
//         12-5-97  by dli

#include "shellprv.h"
#include "validate.h"

#define IS_FILE_DIRECTORY(pwfd)     ((pwfd)->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
#define IS_FILE_REPARSE_POINT(pwfd) ((pwfd)->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

// Call back flags for _CallCallBack
#define STWCB_FILE     1
#define STWCB_ERROR    2
#define STWCB_ENTERDIR 3
#define STWCB_LEAVEDIR 4

#define TF_TREEWALKER 0

STDAPI_(DWORD) PathGetClusterSize(LPCTSTR pszPath);

class CShellTreeWalker : public IShellTreeWalker
{
public:
    CShellTreeWalker();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellTreeWalker
    STDMETHODIMP WalkTree(DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxPath, IShellTreeWalkerCallBack * pstwcb);

private:
    LONG _cRef;
    
    DWORD _dwFlags;     // Flags indicating the search status
    UINT _nMaxDepth;    // Maximum depth we walk into
    UINT _nDepth;       // Current depth
    UINT _nFiles;       // Number of files we have seen so far
    UINT _nDirs;        // Number of directories we have seen

    BOOL _bFolderFirst; // Do the folders first
    DWORD _dwClusterSize;    // the size of a cluster
    ULONGLONG _ulTotalSize;  // total size of all files we have seen
    ULONGLONG _ulActualSize; // total size on disk, taking into account compression, sparse files, and cluster slop

    TCHAR _szWalkBuf[MAX_PATH];         // The path buffer used in the walk
    LPCTSTR _pszWalkSpec;               // The spec we use in FindFirstFile and FindNextFile

    IShellTreeWalkerCallBack * _pstwcb; // The call back interface pointer
    
    WIN32_FIND_DATA  _wfd;              // The temp storage of WIN32_FIND_DATA 

    WIN32_FIND_DATA _fdTopLevelFolder;  // The top level folder info
    
    HRESULT _CallCallBacks(DWORD dwCallReason, WIN32_FIND_DATA * pwfd);
    HRESULT _ProcessAndRecurse(WIN32_FIND_DATA * pwfd);
    HRESULT _TreeWalkerHelper();
}; 

CShellTreeWalker::CShellTreeWalker() : _cRef(1) 
{
    ASSERT(_dwFlags == 0);
    ASSERT(_bFolderFirst == FALSE);
    ASSERT(_nMaxDepth == 0);
    ASSERT(_nDepth == 0);
    ASSERT(_nDirs == 0);
    ASSERT(_ulTotalSize == 0);
    ASSERT(_ulActualSize == 0);
    ASSERT(_pszWalkSpec == NULL);
    ASSERT(_pstwcb == NULL);
    ASSERT(_szWalkBuf[0] == 0);
}

// _CallCallBack: convert the TCHARs to WCHARs and call the callback functions
HRESULT CShellTreeWalker::_CallCallBacks(DWORD dwReason, WIN32_FIND_DATA * pwfd)
{
    HRESULT hr;
    WCHAR wszDir[MAX_PATH];
    WCHAR wszFileName[MAX_PATH];
#ifndef UNICODE
    CHAR szTemp[MAX_PATH];
#endif
    WIN32_FIND_DATAW wfdw = {0};
    WIN32_FIND_DATAW* pwfdw = NULL;
    TREEWALKERSTATS tws = {0};

    tws.nFiles = _nFiles;
    tws.nFolders     = _nDirs;
    tws.nDepth       = _nDepth;
    tws.ulTotalSize  = _ulTotalSize;
    tws.ulActualSize = _ulActualSize;
    tws.dwClusterSize = _dwClusterSize;

    // _szWalkBuf to wszDir
#ifdef UNICODE
    lstrcpy(wszDir, _szWalkBuf);
    lstrcpy(wszFileName, wszDir);
    PathCombine(wszFileName, wszFileName, pwfd->cFileName);
#else
    SHAnsiToUnicode(_szWalkBuf, wszDir, ARRAYSIZE(wszDir));
    lstrcpy(szTemp, _szWalkBuf);
    PathCombine(szTemp, szTemp, pwfd->cFileName);
    SHAnsiToUnicode(szTemp, wszFileName, ARRAYSIZE(wszFileName));
#endif

    if (pwfd && ((dwReason == STWCB_FILE) || (dwReason == STWCB_ENTERDIR)))
    {
        // WIN32_FIND_DATAA to WIN32_FIND_DATAW
        memcpy(&wfdw, pwfd, sizeof(*pwfd));
#ifndef UNICODE
        SHAnsiToUnicode(pwfd->cFileName, wfdw.cFileName, ARRAYSIZE(wfdw.cFileName));
        SHAnsiToUnicode(pwfd->cAlternateFileName, wfdw.cAlternateFileName, ARRAYSIZE(wfdw.cAlternateFileName));
#endif
        pwfdw = &wfdw;
    }

    switch (dwReason) 
    {
    case STWCB_FILE:
        hr = _pstwcb->FoundFile(wszFileName, &tws, pwfdw);
        TraceMsg(TF_TREEWALKER, "TreeWalker Callback FoundFile: %s\\%s dwReason: %x  nFiles: %d  nDepth: %d  nDirs: %d",
                 _szWalkBuf, pwfd->cFileName, dwReason, _nFiles, _nDepth, _nDirs);
        break;

    case STWCB_ENTERDIR:
        hr = _pstwcb->EnterFolder(wszDir, &tws, pwfdw);
        TraceMsg(TF_TREEWALKER, "TreeWalker Callback EnterFolder: %s dwReason: %x  nFiles: %d  nDepth: %d  nDirs: %d",
                 _szWalkBuf, dwReason, _nFiles, _nDepth, _nDirs);
        break;

    case STWCB_LEAVEDIR:
        hr = _pstwcb->LeaveFolder(wszDir, &tws);
        break;

//  case STWCB_ERROR:
//      hr = _pstwcb->HandleError(S_OK, wszDir, &tws);
//      break;

    default:
        hr = S_OK;
        break;
    }

    // Error messages are significant to us, all E_ messages are interpreted as "Stop right now!!"
    if (hr == E_NOTIMPL)
        hr = S_OK;
    
    return hr;
}


// Call call back funtions on directories and files, recurse on directories if there is no objection
// from the callback object
HRESULT CShellTreeWalker::_ProcessAndRecurse(WIN32_FIND_DATA * pwfd)
{
    HRESULT hr = S_OK;

    // Don't recurse on reparse points by default
    if (IS_FILE_DIRECTORY(pwfd) && (!IS_FILE_REPARSE_POINT(pwfd) || (_dwFlags & WT_GOINTOREPARSEPOINT)))
    {
        // NTRAID94635 15mar00: If we are in a symbolic link, we need to detect cycles, 
        // the common prefix method in BeenThereDoneThat will work as long as we
        // keep track of all junction point targets we ran into. 

        // use _szWalkBuf since we dont want any stack variables, because we are a recursive function
        if (PathCombine(_szWalkBuf, _szWalkBuf, pwfd->cFileName))
        {
            // We remember the total number of sub directories we have seen
            // doesn't matter if the client approves or not(call back returns S_OK or S_FALSE or E_FAIL)
            _nDirs++;

            // Let the CallBack object know that we are about to enter a directory 
            if (_dwFlags & WT_NOTIFYFOLDERENTER)
                hr = _CallCallBacks(STWCB_ENTERDIR, pwfd);

            if ((hr == S_OK) && (_nDepth < _nMaxDepth))
            {
                _nDepth++;
                hr = _TreeWalkerHelper();
                _nDepth--;
            }
            else if (hr == S_FALSE)
                hr = S_OK;

            // Let the CallBack object know that we are about to leave a directory 
            if (_dwFlags & WT_NOTIFYFOLDERLEAVE)
                _CallCallBacks(STWCB_LEAVEDIR, NULL);
            
            // Peel off the subdirectory we tagged on in the above PathCombine Ex:"c:\bin\fun --> c:\bin" 
            PathRemoveFileSpec(_szWalkBuf);
        }
    }
    else
    {
        // Count the number of files and compute the total size before calling the
        // call back object. 
        ULARGE_INTEGER ulTemp;
        _nFiles++;

        ulTemp.LowPart  = pwfd->nFileSizeLow;
        ulTemp.HighPart = pwfd->nFileSizeHigh;
        _ulTotalSize += ulTemp.QuadPart;

        // when calculating the total size, we need to find out if the file is compressed or sparse (NTFS only case)
        if (pwfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE))
        {
            // use _szWalkBuf since we dont want any stack variables, because we are a recursive function
            PathCombine(_szWalkBuf, _szWalkBuf, pwfd->cFileName);

            // eithe the file is compressed or sparse, we need to call GetCompressedFileSize to get the real
            // size on disk for this file (NOTE: GetCompressedFileSize takes into account cluster slop, except
            // for files < 1 cluster, and we take care of that below)
            ulTemp.LowPart = SHGetCompressedFileSize(_szWalkBuf, &ulTemp.HighPart);

            _ulActualSize += ulTemp.QuadPart;

            // Peel off the filename we tagged on above
            PathRemoveFileSpec(_szWalkBuf);
        }
        else
        {
            // (reinerf) the cluster size could change if we started on one volume and have now
            // walked onto another mounted volume
            //
            // PathGetClusterSize caches the last request, so this check will be fast in the common case
            //
            PathCombine(_szWalkBuf, _szWalkBuf, pwfd->cFileName);
            _dwClusterSize = PathGetClusterSize(_szWalkBuf);
            PathRemoveFileSpec(_szWalkBuf);

            // if its not compressed, we just round up to the drive's cluster size. ulTemp was setup
            // already for us above, so just round it to the cluster and add it in
            _ulActualSize += ROUND_TO_CLUSTER(ulTemp.QuadPart, _dwClusterSize);
        }
        
        hr = _CallCallBacks(STWCB_FILE, pwfd);
    }

    return hr;
}

#define DELAY_ARRAY_GROW  32

// Recursive function that does the real work on the traversal,
HRESULT CShellTreeWalker::_TreeWalkerHelper()
{
    HRESULT hr = S_OK;
    TraceMsg(TF_TREEWALKER, "TreeWalkerHelper started on: %s flags: %x  nFiles: %d  nDepth: %d  nDirs: %d",
             _szWalkBuf, _dwFlags, _nFiles, _nDepth, _nDirs);

    // Let the CallBack object know that we are about to start the walk
    // provided he cares about the root
    if (_nDepth == 0 && !(_dwFlags & WT_EXCLUDEWALKROOT) &&
        (_dwFlags & WT_NOTIFYFOLDERENTER))
    {
        // Get the info for the TopLevelFolder
        HANDLE hTopLevelFolder = FindFirstFile(_szWalkBuf, &_fdTopLevelFolder);

        if (hTopLevelFolder == INVALID_HANDLE_VALUE)
        {
            LPTSTR pszFileName;
            DWORD dwAttribs = -1; // assume failure

            // We could have failed if we tried to do a FindFirstFile on the root (c:\)
            // or if something is really wrong, to test for this we do a GetFileAttributes (GetFileAttributesEx on NT)
            // on NT we can use GetFileAttributesEx to get both the attribs and part of the win32fd
            if (GetFileAttributesEx(_szWalkBuf, GetFileExInfoStandard, (LPVOID)&_fdTopLevelFolder))
            {
                // success!
                dwAttribs = _fdTopLevelFolder.dwFileAttributes;
                pszFileName = PathFindFileName(_szWalkBuf);
                lstrcpyn(_fdTopLevelFolder.cFileName, pszFileName, ARRAYSIZE(_fdTopLevelFolder.cFileName));
                lstrcpyn(_fdTopLevelFolder.cAlternateFileName, pszFileName, ARRAYSIZE(_fdTopLevelFolder.cAlternateFileName));
            }
            else
            {
                // fall back to the ole GetFileAttrbutes
                dwAttribs = GetFileAttributes(_szWalkBuf);

                if (dwAttribs != -1)
                {
                    // success!

                    // On win95 we steal a bunch of the find data from our first child, and fake the rest.
                    // Its the best we can do.
                    memcpy(&_fdTopLevelFolder, &_wfd, sizeof(_fdTopLevelFolder));

                    _fdTopLevelFolder.dwFileAttributes = dwAttribs;

                    pszFileName = PathFindFileName(_szWalkBuf);
                    lstrcpyn(_fdTopLevelFolder.cFileName, pszFileName, ARRAYSIZE(_fdTopLevelFolder.cFileName));
                    lstrcpyn(_fdTopLevelFolder.cAlternateFileName, pszFileName, ARRAYSIZE(_fdTopLevelFolder.cAlternateFileName));
                }
            }

            if (dwAttribs == -1)
            {
                // this is very bad, so we bail
                TraceMsg(TF_TREEWALKER, "Tree Walker: GetFileAttributes/Ex(%s) failed. Stopping the walk.", _szWalkBuf);
                return E_FAIL;
            }

        }
        else
        {
            // We sucessfully got the find data, good.
            FindClose(hTopLevelFolder);
        }

        // call the callback for the first enterdir
        hr = _CallCallBacks(STWCB_ENTERDIR, &_fdTopLevelFolder);
    }

    // Do the real tree walk here
    if (hr == S_OK)
    {
        // always use *.* to search when we are not at our maximum level because
        // we need the sub directories
        // PERF: this can be changed on NT by using FindFirstFileEx if WT_FOLDERONLY
        LPCTSTR pszSpec = (_pszWalkSpec && (_nDepth == _nMaxDepth)) ? _pszWalkSpec : c_szStarDotStar;
        if (PathCombine(_szWalkBuf, _szWalkBuf, pszSpec))
        {
            HDSA hdsaDelayed = NULL;  // array of found items that will be delayed and processed later
            HANDLE hFind;

            // Start finding the sub folders and files 
            hFind = FindFirstFile(_szWalkBuf, &_wfd);

            // Peel off the find spec Ex:"c:\bin\*.* --> c:\bin" 
            PathRemoveFileSpec(_szWalkBuf);

            if (hFind != INVALID_HANDLE_VALUE)
            {
                BOOL bDir = FALSE;

                do
                {
                    //  Skip over the . and .. entries.
                    if (PathIsDotOrDotDot(_wfd.cFileName))
                        continue;

                    bDir = BOOLIFY(IS_FILE_DIRECTORY(&_wfd));

                    // If this is a file, and we are not interested in files or this file spec does not match the one we were
                    // looking for. 
                    if ((!bDir) && ((_dwFlags & WT_FOLDERONLY) ||
                                    (_pszWalkSpec && (_nDepth < _nMaxDepth) && !PathMatchSpec(_wfd.cFileName, _pszWalkSpec))))
                        continue;

                    //  The following EQUAL determines whether we want to process
                    //  the data found or save it in the HDSA array and process them later. 

                    // Enumerate the folder or file now? (determined by the WT_FOLDERFIRST flag)
                    if (bDir == BOOLIFY(_bFolderFirst))
                    {
                        // Yes
                        hr = _ProcessAndRecurse(&_wfd);

                        // if hr is failure code someone said "stop right now"
                        // if hr is S_FALSE some one said "quit this directory and start with next one"
                        if (hr != S_OK)
                            break;
                    }
                    else 
                    {
                        // No; enumerate it once we're finished with the opposite.
                        if (!hdsaDelayed)
                            hdsaDelayed = DSA_Create(sizeof(WIN32_FIND_DATA), DELAY_ARRAY_GROW);
                        if (!hdsaDelayed)
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        DSA_AppendItem(hdsaDelayed, &_wfd);

                    }
                } while (FindNextFile(hFind, &_wfd));

                FindClose(hFind);
            }
            else
            {
               // find first file failed, this is a good place to report error 
               DWORD dwErr = GetLastError();
               TraceMsg(TF_TREEWALKER, "***WARNING***: FindFirstFile faied on %s%s with error = %d", _szWalkBuf, _pszWalkSpec, dwErr);
            }

            // Process the delayed items, these are either directories or files
            if (hdsaDelayed)
            {
                // we should have finished everything in the above do while loop in folderonly case
                ASSERT(!(_dwFlags & WT_FOLDERONLY));

                // if hr is failure code someone said "stop right now"
                // if hr is S_FALSE some one said "quit this directory and start with next one"
                if (hr == S_OK)   
                {
                    int ihdsa;
                    for (ihdsa = 0; ihdsa < DSA_GetItemCount(hdsaDelayed); ihdsa++)
                    {
                        WIN32_FIND_DATA * pwfd = (WIN32_FIND_DATA *)DSA_GetItemPtr(hdsaDelayed, ihdsa);
                        hr = _ProcessAndRecurse(pwfd);
                        if (hr != S_OK)
                            break;
                    }
                }
                DSA_Destroy(hdsaDelayed);
            }

            // Let the CallBack object know that we are finishing the walk
            if (_nDepth == 0 && !(_dwFlags & WT_EXCLUDEWALKROOT) &&
                (_dwFlags & WT_NOTIFYFOLDERLEAVE) && (S_OK == hr))
                hr = _CallCallBacks(STWCB_LEAVEDIR, &_fdTopLevelFolder);

            // hr was S_FALSE because someone wanted us to jump out of this current directory
            // but don't pass it back to our parent directory  
            if (hr == S_FALSE)
                hr = S_OK;
        }
        else
            TraceMsg(TF_TREEWALKER, "***WARNING***: PathCombine failed!!!!");
    }
    
    return hr;
}

// IShellTreeWalker::WalkTree is the main function for the IShellTreeWalker interface 
HRESULT CShellTreeWalker::WalkTree(DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxDepth, IShellTreeWalkerCallBack * pstwcb)
{
    HRESULT hr = E_FAIL;
    TCHAR szWalkSpec[64];

    // must have a call back object to talk to
    ASSERT(IS_VALID_CODE_PTR(pstwcb, IShellTreeWalkerCackBack));
    if (pstwcb == NULL)
        return E_INVALIDARG;

    // make sure we have a valid directory to start with
    ASSERT(IS_VALID_STRING_PTRW(pwszWalkRoot, -1));
    if ((pwszWalkRoot != NULL) && (pwszWalkRoot[0] != L'\0'))
    {
        SHUnicodeToTChar(pwszWalkRoot, _szWalkBuf, ARRAYSIZE(_szWalkBuf));
        // call back 
        _pstwcb = pstwcb;

        // copy the search flags and fix it up  
        _dwFlags = dwFlags & WT_ALL;
        
        // this will save us from using the hdsa array to hold the directories
        if (_dwFlags & WT_FOLDERONLY)
        {
            _dwFlags |= WT_FOLDERFIRST;

            // It will be pretty meanless if the below flags are not set, because
            // we don't call FoundFile in the FolderOnly case. 
            ASSERT(_dwFlags & (WT_NOTIFYFOLDERENTER | WT_NOTIFYFOLDERLEAVE));
        }

        if (_dwFlags & WT_FOLDERFIRST)
            _bFolderFirst = TRUE;
        
        if ((pwszWalkSpec != NULL) && (pwszWalkSpec[0] != L'\0'))
        {
            SHUnicodeToTChar(pwszWalkSpec, szWalkSpec, ARRAYSIZE(szWalkSpec));
            _pszWalkSpec = szWalkSpec;
        }
        
        _nMaxDepth = (dwFlags & WT_MAXDEPTH) ? iMaxDepth : 256;
        _dwClusterSize = PathGetClusterSize(_szWalkBuf);
        hr = _TreeWalkerHelper();
    }
    else
        TraceMsg(TF_WARNING, "CShellTreeWalker::WalkTree Failed! due to bad _szWalkBuf");
    
    return hr;
}

// IShellTreeWalker::QueryInterface
HRESULT CShellTreeWalker::QueryInterface(REFIID riid, void ** ppv)
{ 
    static const QITAB qit[] = {
        QITABENT(CShellTreeWalker, IShellTreeWalker),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// IShellTreeWalker::AddRef
ULONG CShellTreeWalker::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

// IShellTreeWalker::Release
ULONG CShellTreeWalker::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDAPI CShellTreeWalker_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT void **ppvOut)
{
    HRESULT hr;
    
    *ppvOut = NULL;                     

    CShellTreeWalker *pstw = new CShellTreeWalker;
    if (!pstw)
        return E_OUTOFMEMORY;
    
    hr = pstw->QueryInterface(riid, ppvOut);
    pstw->Release();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\tooltip.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Tooltip.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements displaying a tooltip balloon.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

#include "shellprv.h"
#include "Tooltip.h"

BOOL IsBiDiLocalizedSystem( void );

//  --------------------------------------------------------------------------
//  CTooltip::CTooltip
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process/DLL.
//              hwndParent  =   HWND of the parenting window.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CTooltip. Creates a tooltip window and
//              prepares it for display.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

CTooltip::CTooltip (HINSTANCE hInstance, HWND hwndParent) :
    _hwnd(NULL),
    _hwndParent(hwndParent)

{
    DWORD   dwExStyle;

    if (((GetWindowLongA(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) != 0) || IsBiDiLocalizedSystem())
    {
        dwExStyle = WS_EX_LAYOUTRTL;
    }
    else
    {
        dwExStyle = 0;
    }
    _hwnd = CreateWindowEx(dwExStyle,
                           TOOLTIPS_CLASS,
                           NULL,
                           WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           hwndParent,
                           NULL,
                           hInstance,
                           NULL);
    if (_hwnd != NULL)
    {
        TOOLINFO    toolInfo;

        TBOOL(SetWindowPos(_hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE));
        (LRESULT)SendMessage(_hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);
        ZeroMemory(&toolInfo, sizeof(toolInfo));
        toolInfo.cbSize = sizeof(toolInfo);
        toolInfo.uFlags = TTF_TRANSPARENT | TTF_TRACK;
        toolInfo.uId = PtrToUint(_hwnd);
        (LRESULT)SendMessage(_hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(&toolInfo));
        (LRESULT)SendMessage(_hwnd, TTM_SETMAXTIPWIDTH, 0, 300);
    }
}

//  --------------------------------------------------------------------------
//  CTooltip::~CTooltip
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CTooltip class. This destroys the tooltip
//              window created. If the parent of the tooltip window is
//              destroyed before this is invoked user32!DestroyWindow will
//              cause the trace to fire. The object's lifetime must be
//              carefully managed by the user of this class.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

CTooltip::~CTooltip (void)

{
    if (_hwnd != NULL)
    {
        TBOOL(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CTooltip::SetPosition
//
//  Arguments:  lPosX   =   X position of the balloon tip window (screen).
//              lPosY   =   Y position of the balloon tip window (screen).
//
//  Returns:    <none>
//
//  Purpose:    Positions the tooltip window at the given screen co-ordinates.
//              If the parameters are defaulted then this positions the
//              tooltip relative to the parent.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetPosition (LONG lPosX, LONG lPosY)  const

{
    if ((lPosX == LONG_MIN) && (lPosY == LONG_MIN))
    {
        RECT    rc;

        TBOOL(GetWindowRect(_hwndParent, &rc));
        lPosX = (rc.left + rc.right) / 2;
        lPosY = rc.bottom;
    }
    (LRESULT)SendMessage(_hwnd, TTM_TRACKPOSITION, 0, MAKELONG(lPosX, lPosY));
}

//  --------------------------------------------------------------------------
//  CTooltip::SetCaption
//
//  Arguments:  dwIcon      =   Icon type to set for the tooltip caption.
//              pszCaption  =   Caption of the tooltip.
//
//  Returns:    <none>
//
//  Purpose:    Sets the tooltip caption.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetCaption (DWORD dwIcon, const TCHAR *pszCaption)          const

{
    (LRESULT)SendMessage(_hwnd, TTM_SETTITLE, dwIcon, reinterpret_cast<LPARAM>(pszCaption));
}

//  --------------------------------------------------------------------------
//  CTooltip::SetText
//
//  Arguments:  pszText     =   Content of the actual tooltip.
//
//  Returns:    <none>
//
//  Purpose:    Sets the tooltip text.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::SetText (const TCHAR *pszText)                              const

{
    TOOLINFO    toolInfo;

    ZeroMemory(&toolInfo, sizeof(toolInfo));
    toolInfo.cbSize = sizeof(toolInfo);
    toolInfo.uId = PtrToUint(_hwnd);
    toolInfo.lpszText = const_cast<TCHAR*>(pszText);
    (LRESULT)SendMessage(_hwnd, TTM_UPDATETIPTEXT, 0, reinterpret_cast<LPARAM>(&toolInfo));
}

//  --------------------------------------------------------------------------
//  CTooltip::Show
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Shows the tooltip window.
//
//  History:    2000-06-12  vtan        created
//  --------------------------------------------------------------------------

void    CTooltip::Show (void)                                                 const

{
    TOOLINFO    toolInfo;

    ZeroMemory(&toolInfo, sizeof(toolInfo));
    toolInfo.cbSize = sizeof(toolInfo);
    toolInfo.uId = PtrToUint(_hwnd);
    (LRESULT)SendMessage(_hwnd, TTM_TRACKACTIVATE, TRUE, reinterpret_cast<LPARAM>(&toolInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\treewkcb.h ===
#include "treewalk.h" // for IShellTreeWalkerCallBack

class CBaseTreeWalkerCB : public IShellTreeWalkerCallBack
{
public:
    CBaseTreeWalkerCB();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd); 
    STDMETHODIMP LeaveFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws);
    STDMETHODIMP HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT hrError);

protected:
    virtual ~CBaseTreeWalkerCB();
    LONG _cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\treewkcb.cpp ===
#include "shellprv.h"
#include "treewkcb.h"
#include "propsht.h"

CBaseTreeWalkerCB::CBaseTreeWalkerCB(): _cRef(1)
{
}

CBaseTreeWalkerCB::~CBaseTreeWalkerCB()
{
}

HRESULT CBaseTreeWalkerCB::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBaseTreeWalkerCB, IShellTreeWalkerCallBack),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CBaseTreeWalkerCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CBaseTreeWalkerCB::Release()
{
    if (InterlockedDecrement(&_cRef))
       return _cRef;

    delete this;
    return 0;
}

HRESULT CBaseTreeWalkerCB::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    return E_NOTIMPL;
}

HRESULT CBaseTreeWalkerCB::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    return E_NOTIMPL;
}

HRESULT CBaseTreeWalkerCB::LeaveFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws)
{
    return E_NOTIMPL;
}

HRESULT CBaseTreeWalkerCB::HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT ErrorCode)
{
    return E_NOTIMPL;
}

//
// Folder size computation tree walker callback class
//
class CFolderSizeTreeWalkerCB : public CBaseTreeWalkerCB
{
public:
    CFolderSizeTreeWalkerCB(FOLDERCONTENTSINFO * pfci);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

protected:
    FOLDERCONTENTSINFO * _pfci;
    TREEWALKERSTATS _twsInitial;
}; 

CFolderSizeTreeWalkerCB::CFolderSizeTreeWalkerCB(FOLDERCONTENTSINFO * pfci): _pfci(pfci)
{
    // set the starting values for the twsInitial so we can have cumulative results
    _twsInitial.nFiles = _pfci->cFiles;
    _twsInitial.nFolders = _pfci->cFolders;
    _twsInitial.ulTotalSize = _pfci->cbSize;
    _twsInitial.ulActualSize = _pfci->cbActualSize;
}

HRESULT CFolderSizeTreeWalkerCB::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (_pfci->bContinue)
    {
        _pfci->cbSize = _twsInitial.ulTotalSize + ptws->ulTotalSize;
        _pfci->cbActualSize = _twsInitial.ulActualSize + ptws->ulActualSize;
        _pfci->cFiles = _twsInitial.nFiles + ptws->nFiles;
    }
    return _pfci->bContinue ? S_OK : E_FAIL;
}

HRESULT CFolderSizeTreeWalkerCB::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (_pfci->bContinue)
    {
        _pfci->cFolders = _twsInitial.nFolders + ptws->nFolders;
    }
    return _pfci->bContinue ? S_OK : E_FAIL;
}

//
//  Main function for folder size computation
//
STDAPI FolderSize(LPCTSTR pszDir, FOLDERCONTENTSINFO *pfci)
{
    HRESULT hrInit = SHCoInitialize();  // in case our caller did not do this

    HRESULT hr = E_FAIL;
    CFolderSizeTreeWalkerCB *pfstwcb = new CFolderSizeTreeWalkerCB(pfci);
    if (pfstwcb)
    {
        IShellTreeWalker *pstw;
        hr = CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &pstw));
        if (SUCCEEDED(hr))
        {
            hr = pstw->WalkTree(WT_NOTIFYFOLDERENTER, pszDir, NULL, 0, SAFECAST(pfstwcb, IShellTreeWalkerCallBack *));
            pstw->Release();
        }
        pfstwcb->Release();
    }

    SHCoUninitialize(hrInit);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\undo.c ===
#include "shellprv.h"
#pragma  hdrstop
#include <shellp.h>

// use a linked list because we're going to be pulling things off the top
// and bottom all the time.
HDPA s_hdpaUndo = NULL;
BOOL s_fUndoSuspended = FALSE;

#define MAX_UNDO  10

void NukeUndoAtom(LPUNDOATOM lpua)
{
    lpua->Release( lpua );
    LocalFree( lpua );
}

void SuspendUndo(BOOL f)
{
    if (f)
        s_fUndoSuspended++;
    else
        s_fUndoSuspended--;
    
    ASSERT(s_fUndoSuspended >= 0);
    // sanity check
    if (s_fUndoSuspended < 0)
        s_fUndoSuspended = 0;
}


void AddUndoAtom(LPUNDOATOM lpua)
{
    int i;

    ENTERCRITICAL;
    ASSERT(lpua);
    if (!s_hdpaUndo) {
        s_hdpaUndo = DPA_Create(MAX_UNDO + 1);
    }

    if (s_hdpaUndo) {
        i = DPA_AppendPtr(s_hdpaUndo, lpua);
        if (i != -1) {
            if (i >= MAX_UNDO) {
                lpua = DPA_FastGetPtr(s_hdpaUndo, 0);
                NukeUndoAtom(lpua);
                DPA_DeletePtr(s_hdpaUndo, 0);
            }
        } else {
            NukeUndoAtom(lpua);
        }
    }
    LEAVECRITICAL;
}

LPUNDOATOM _PeekUndoAtom(LPINT lpi)
{
    int i = -1;
    LPUNDOATOM lpua = NULL;

    ASSERTCRITICAL;

    if (s_hdpaUndo) {
        i = DPA_GetPtrCount(s_hdpaUndo) - 1;
        if (i >= 0) {
            lpua = DPA_FastGetPtr(s_hdpaUndo, i);

        }
    }
    if (lpi)
        *lpi = i;
    return lpua;
}

void EnumUndoAtoms(int (CALLBACK* lpfn)(LPUNDOATOM lpua, LPARAM lParam), LPARAM lParam)
{
    int i;

    if (!s_hdpaUndo) {
        return;
    }

    ENTERCRITICAL;
    for (i = DPA_GetPtrCount(s_hdpaUndo) - 1; i >= 0; i--) {
        LPUNDOATOM lpua;
        int iRet;
        lpua = DPA_FastGetPtr(s_hdpaUndo, i);
        iRet = lpfn(lpua, lParam);

        if (iRet &  EUA_DELETE) {
            DPA_DeletePtr(s_hdpaUndo, i);
            NukeUndoAtom(lpua);
        }

        if (iRet & EUA_ABORT) {
            break;
        }
    }

    LEAVECRITICAL;
}

#define DoUndoAtom(lpua) ((lpua)->Invoke((lpua)))

void Undo(HWND hwnd)
{
    int i;
    LPUNDOATOM lpua;
    DECLAREWAITCURSOR;

    if (!IsUndoAvailable()) {
        MessageBeep(0);
        return;
    }
    
    SetWaitCursor();

    ENTERCRITICAL;
    ASSERT(s_hdpaUndo);
    lpua = _PeekUndoAtom(&i);
    if (lpua)
        DPA_DeletePtr(s_hdpaUndo, i);
    LEAVECRITICAL;

    if (lpua) {
        lpua->hwnd = hwnd;
        DoUndoAtom(lpua);
    }
    ResetWaitCursor();
}

BOOL IsUndoAvailable()
{
    return s_hdpaUndo && !s_fUndoSuspended &&
        DPA_GetPtrCount(s_hdpaUndo);
}

#define _GetUndoText(lpua, buffer, type) (lpua)->GetText((lpua), buffer, type)

// Gets undo information for the first item in the undo buffer
//
void GetUndoText(LPTSTR lpszBuffer, UINT cchBuffer, int type)
{
    TCHAR szTemp[MAX_PATH * 2 + 80];
    TCHAR lpszFormat[MAX_PATH];     // (MAX_PATH is overkill, oh well...)

    ASSERT(cchBuffer > 0);
    lpszBuffer[0] = 0;  // assume failure
    szTemp[0] = 0;

    // While holding onto lpua's from the hdpa, we need to be inside the critical section
    {
        LPUNDOATOM lpua;
        
        ENTERCRITICAL;
        lpua = _PeekUndoAtom(NULL);

        if (lpua)
            _GetUndoText(lpua, szTemp, type);

        LEAVECRITICAL;
    }

    if (LoadString(HINST_THISDLL, (type == UNDO_MENUTEXT)  ? IDS_UNDOACCEL : IDS_UNDO, lpszFormat, ARRAYSIZE(lpszFormat)) != 0)
    {
        if (type == UNDO_STATUSTEXT)
        {
            // Status text shouldn't have ampersand or tab
            ASSERT(StrChr(lpszFormat, TEXT('&')) == NULL);
            ASSERT(StrChr(lpszFormat, TEXT('\t')) == NULL);
        }
        wnsprintf(lpszBuffer, cchBuffer, lpszFormat, szTemp);
    }
}

void FreeUndoList()
{
    HDPA hdpa;
    int i;
    
    ENTERCRITICAL;
    hdpa = s_hdpaUndo;
    s_hdpaUndo = NULL;
    LEAVECRITICAL;

    if (hdpa)
    {
        for (i = DPA_GetPtrCount(hdpa) - 1; i >= 0; i--)
        {
            NukeUndoAtom(DPA_FastGetPtr(hdpa, i));
        }
        DPA_DeleteAllPtrs(hdpa);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\userpict.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: UserPict.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Functions that implement user picture manipulation.
//
//  History:    2000-03-24  vtan        created
//              2000-05-03  jeffreys    reworked using DIB sections
//              2000-10-26  jeffreys    switched from %ALLUSERSPROFILE%\Pictures
//                                      to CSIDL_COMMON_APPDATA\User Account Pictures
//  --------------------------------------------------------------------------

#include "shellprv.h"

#include <lmcons.h>
#include <shimgdata.h>
#include <aclapi.h>     // for SetNamedSecurityInfo
#include <shgina.h>     // for ILogonUser

#pragma warning(push,4)

//  --------------------------------------------------------------------------
//  SaveDIBSectionToFile
//
//  Arguments:  hbm             =   Source image (DIB section) to save
//              hdc             =   Device Context containing hbm. May be NULL
//                                    if hbm is not selected in any DC or hbm
//                                    is known to have no color table.
//              pszFile         =   Target image file.
//
//  Returns:    BOOL
//
//  Purpose:    Write a DIB to disk in the proper format
//
//  History:    2000-05-03  jeffreys    created
//  --------------------------------------------------------------------------

#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

BOOL SaveDIBSectionToFile(HBITMAP hbm, HDC hdc, LPCTSTR pszFile)
{
    BOOL bResult;
    DIBSECTION ds;
    HANDLE hFile;
    BITMAPFILEHEADER bf;
    DWORD cbWritten;

    bResult = FALSE;

    // Get the details about the bitmap. This also validates hbm.

    if (GetObject(hbm, sizeof(ds), &ds) == 0)
        return FALSE;

    // Fill in a couple of optional fields if necessary

    if (ds.dsBmih.biSizeImage == 0)
        ds.dsBmih.biSizeImage = ds.dsBmih.biHeight * ds.dsBm.bmWidthBytes;

    if (ds.dsBmih.biBitCount <= 8 && ds.dsBmih.biClrUsed == 0)
        ds.dsBmih.biClrUsed = 1 << ds.dsBmih.biBitCount;

    // Open the target file. This also validates pszFile.

    hFile = CreateFile(pszFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile)
        return FALSE;

    // Prepare the BITMAPFILEHEADER for writing

    bf.bfType = DIB_HEADER_MARKER;
    bf.bfReserved1 = 0;
    bf.bfReserved2 = 0;

    // The bit offset is the cumulative size of all of the header stuff

    bf.bfOffBits = sizeof(bf) + sizeof(ds.dsBmih) + (ds.dsBmih.biClrUsed*sizeof(RGBQUAD));
    if (ds.dsBmih.biCompression == BI_BITFIELDS)
        bf.bfOffBits += sizeof(ds.dsBitfields);

    // Round up to the next 16-byte boundary. This isn't strictly necessary,
    // but it makes the file layout cleaner. (You can create a file mapping
    // and pass it to CreateDIBSection this way.)

    bf.bfOffBits = ((bf.bfOffBits + 15) & ~15);

    // The file size is the bit offset + the size of the bits

    bf.bfSize = bf.bfOffBits + ds.dsBmih.biSizeImage;

    // Write the BITMAPFILEHEADER first

    bResult = WriteFile(hFile, &bf, sizeof(bf), &cbWritten, NULL);

    if (bResult)
    {
        // Next is the BITMAPINFOHEADER

        bResult = WriteFile(hFile, &ds.dsBmih, sizeof(ds.dsBmih), &cbWritten, NULL);
        if (bResult)
        {
            // Then the 3 bitfields, if necessary

            if (ds.dsBmih.biCompression == BI_BITFIELDS)
            {
                bResult = WriteFile(hFile, &ds.dsBitfields, sizeof(ds.dsBitfields), &cbWritten, NULL);
            }

            if (bResult)
            {
                // Now the color table, if any

                if (ds.dsBmih.biClrUsed != 0)
                {
                    RGBQUAD argb[256];
                    HDC hdcDelete;
                    HBITMAP hbmOld;

                    // Assume failure here
                    bResult = FALSE;

                    hdcDelete = NULL;
                    if (!hdc)
                    {
                        hdcDelete = CreateCompatibleDC(NULL);
                        if (hdcDelete)
                        {
                            hbmOld = (HBITMAP)SelectObject(hdcDelete, hbm);
                            hdc = hdcDelete;
                        }
                    }

                    if (hdc &&
                        GetDIBColorTable(hdc, 0, ARRAYSIZE(argb), argb) == ds.dsBmih.biClrUsed)
                    {
                        bResult = WriteFile(hFile, argb, ds.dsBmih.biClrUsed*sizeof(RGBQUAD), &cbWritten, NULL);
                    }

                    if (hdcDelete)
                    {
                        SelectObject(hdcDelete, hbmOld);
                        DeleteDC(hdcDelete);
                    }
                }

                // Finally, write the bits

                if (bResult)
                {
                    SetFilePointer(hFile, bf.bfOffBits, NULL, FILE_BEGIN);
                    bResult = WriteFile(hFile, ds.dsBm.bmBits, ds.dsBmih.biSizeImage, &cbWritten, NULL);
                    SetEndOfFile(hFile);
                }
            }
        }
    }

    CloseHandle(hFile);

    if (!bResult)
    {
        // Something failed, clean up
        DeleteFile(pszFile);
    }

    return bResult;
}


//  --------------------------------------------------------------------------
//  MakeDIBSection
//
//  Arguments:  pImage          =   Source image
//
//  Returns:    HBITMAP
//
//  Purpose:    Create a DIB section containing the given image
//              on a white background
//
//  History:    2000-05-03  jeffreys    created
//  --------------------------------------------------------------------------

HBITMAP MakeDIBSection(IShellImageData *pImage, ULONG cx, ULONG cy)
{
    HBITMAP hbm;
    HDC hdc;
    BITMAPINFO dib;

    hdc = CreateCompatibleDC(NULL);
    if (hdc == NULL)
        return NULL;

    dib.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    dib.bmiHeader.biWidth           = cx;
    dib.bmiHeader.biHeight          = cy;
    dib.bmiHeader.biPlanes          = 1;
    dib.bmiHeader.biBitCount        = 24;
    dib.bmiHeader.biCompression     = BI_RGB;
    dib.bmiHeader.biSizeImage       = 0;
    dib.bmiHeader.biXPelsPerMeter   = 0;
    dib.bmiHeader.biYPelsPerMeter   = 0;
    dib.bmiHeader.biClrUsed         = 0;
    dib.bmiHeader.biClrImportant    = 0;

    hbm = CreateDIBSection(hdc, &dib, DIB_RGB_COLORS, NULL, NULL, 0);

    if (hbm)
    {
        HBITMAP hbmOld;
        RECT rc;

        hbmOld = (HBITMAP)SelectObject(hdc, hbm);

        // Initialize the entire image with white

        PatBlt(hdc, 0, 0, cx, cy, WHITENESS);

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        // Draw the source image into the DIB section

        HRESULT hr = pImage->Draw(hdc, &rc, NULL);

        SelectObject(hdc, hbmOld);

        if (FAILED(hr))
        {
            DeleteObject(hbm);
            hbm = NULL;
            SetLastError(hr);
        }
    }

    DeleteDC(hdc);

    return hbm;
}


//  --------------------------------------------------------------------------
//  ConvertAndResizeImage
//
//  Arguments:  pszFileSource   =   Source image file.
//              pszFileTarget   =   Target image file (resized).
//
//  Returns:    HRESULT
//
//  Purpose:    Uses GDI+ via COM interfaces to convert the given image file
//              to a bmp sized at 96x96.
//
//  History:    2000-03-24  vtan        created
//              2000-05-03  jeffreys    reworked using DIB sections
//  --------------------------------------------------------------------------

HRESULT ConvertAndResizeImage (LPCTSTR pszFileSource, LPCTSTR pszFileTarget)

{
    HRESULT hr;
    IShellImageDataFactory *pImagingFactory;

    hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &pImagingFactory));
    if (SUCCEEDED(hr))
    {
        IShellImageData *pImage;

        hr = pImagingFactory->CreateImageFromFile(pszFileSource, &pImage);
        if (SUCCEEDED(hr))
        {
            hr = pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);

            if (SUCCEEDED(hr))
            {
                SIZE    sizeImg;
                ULONG   cxDest, cyDest;
                HDC     hdc;
                HBITMAP hbm;
                DWORD   dwErr;

                // The default dimensions are based on the screen resolution

                hdc = GetDC(NULL);
                if (hdc != NULL)
                {
                    // Make it 1/2 inch square by default
                    cxDest = GetDeviceCaps(hdc, LOGPIXELSX) / 2;
                    cyDest = GetDeviceCaps(hdc, LOGPIXELSY) / 2;
                    ReleaseDC(NULL, hdc);
                }
                else
                {
                    // Most common display modes run at 96dpi ("small fonts")
                    cxDest = cyDest = 48;
                }

                // Get the current image dimensions so we can maintain aspect ratio
                if ( SUCCEEDED(pImage->GetSize(&sizeImg)) )
                {
                    // Don't want to make small images bigger
                    cxDest = min(cxDest, (ULONG)sizeImg.cx);
                    cyDest = min(cyDest, (ULONG)sizeImg.cy);

                    // If it's not square, scale the smaller dimension
                    // to maintain the aspect ratio.
                    if (sizeImg.cx > sizeImg.cy)
                    {
                        cyDest = MulDiv(cxDest, sizeImg.cy, sizeImg.cx);
                    }
                    else if (sizeImg.cx < sizeImg.cy)
                    {
                        cxDest = MulDiv(cyDest, sizeImg.cx, sizeImg.cy);
                    }
                }

                // Resize the image

                // Note that this gives better results than scaling while drawing
                // into the DIB section (see MakeDIBSection).
                //
                // However, it doesn't always work. For example, animated images
                // result in E_NOTVALIDFORANIMATEDIMAGE.  So ignore the return
                // value and the scaling will be done in MakeDIBSection if necessary.

                pImage->Scale(cxDest, cyDest, 0);

                hbm = MakeDIBSection(pImage, cxDest, cyDest);

                if (hbm)
                {
                    // Save the DIB section to disk
                    if (!SaveDIBSectionToFile(hbm, NULL, pszFileTarget))
                    {
                        dwErr = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwErr);
                    }

                    DeleteObject(hbm);
                }
                else
                {
                    dwErr = GetLastError();
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }

            pImage->Release();
        }

        pImagingFactory->Release();
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  SetExplicitAccessToObject
//
//  Arguments:  pszTarget   =   Target object
//              seType      =   Type of object
//              pszUser     =   User to grant access to
//              dwMask      =   Permissions granted
//              dwFlags     =   Inheritance flags
//
//  Returns:    BOOL
//
//  Purpose:    Grants Read/Write/Execute/Delete access to the 
//              specified user on the specified file.
//
//              Note that this stomps existing explicit entries in the DACL.
//              Multiple calls are not cumulative.
//
//  History:    2000-05-19  jeffreys    created
//  --------------------------------------------------------------------------

DWORD SetExplicitAccessToObject(LPTSTR pszTarget, SE_OBJECT_TYPE seType, LPCTSTR pszUser, DWORD dwMask, DWORD dwFlags)
{
    BOOL bResult;

    // 84 bytes
    BYTE rgAclBuffer[sizeof(ACL)
                        + (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))
                        + (sizeof(SID) + (SID_MAX_SUB_AUTHORITIES-1)*sizeof(ULONG))];

    PACL pDacl = (PACL)rgAclBuffer;
    if (!InitializeAcl(pDacl, sizeof(rgAclBuffer), ACL_REVISION)) return FALSE;
    pDacl->AceCount = 1;

    PACCESS_ALLOWED_ACE pAce = (PACCESS_ALLOWED_ACE)(pDacl+1);
    pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags = (UCHAR)(dwFlags & 0xFF);
    pAce->Mask = dwMask;

    SID_NAME_USE snu;
    TCHAR szDomainName[MAX_PATH];
    DWORD cbDomainName = ARRAYSIZE(szDomainName);
    DWORD cbSid = sizeof(SID) + (SID_MAX_SUB_AUTHORITIES-1)*sizeof(ULONG);

    bResult = LookupAccountName(
                    NULL,
                    pszUser,
                    (PSID)&(pAce->SidStart),
                    &cbSid,
                    szDomainName,
                    &cbDomainName,
                    &snu);
    if (bResult)
    {
        DWORD dwErr;

        // LookupAccountName doesn't return the SID length on success
        cbSid = GetLengthSid((PSID)&(pAce->SidStart));

        // Update the ACE size
        pAce->Header.AceSize = (USHORT)(sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) + cbSid);

        dwErr = SetNamedSecurityInfo(
                    pszTarget,
                    seType,
                    DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pDacl,
                    NULL);

        if (ERROR_SUCCESS != dwErr)
        {
            SetLastError(dwErr);
            bResult = FALSE;
        }
    }

    return bResult;
}


//  --------------------------------------------------------------------------
//  SetDefaultUserPicture
//
//  Arguments:  pszUsername     =   Desired user (NULL for current user).
//
//  Returns:    HRESULT
//
//  Purpose:    Picks one of the default user pictures at random and
//              assigns it to the specified user.
//
//  History:    2001-03-27  reinerf    created
//  --------------------------------------------------------------------------

HRESULT SetDefaultUserPicture(LPCTSTR pszUsername)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];

    hr = SHGetUserPicturePath(NULL, SHGUPP_FLAG_DEFAULTPICSPATH, szPath);
    if (SUCCEEDED(hr))
    {
        BOOL bFound = FALSE;    // assume we won't find a picture

        // Assume everything in the dir is a vaild image file
        if (PathAppend(szPath, TEXT("*.*")))
        {
            static DWORD dwSeed = 0;
            WIN32_FIND_DATA fd;
            HANDLE hFind = FindFirstFile(szPath, &fd);

            if (dwSeed == 0)
            {
                dwSeed = GetTickCount();
            }

            if (hFind != INVALID_HANDLE_VALUE)
            {
                DWORD dwCount = 0;
                
                // use a probability collector algorithim (with a limit of 100 files)
                do
                {
                    if (!PathIsDotOrDotDot(fd.cFileName))
                    {
                        dwCount++;

                        // although RtlRandom returns a ULONG it is distributed from 0...MAXLONG
                        if (RtlRandomEx(&dwSeed) <= (MAXLONG / dwCount))
                        {
                            bFound = TRUE;
                            PathRemoveFileSpec(szPath);
                            PathAppend(szPath, fd.cFileName);
                        }
                    }

                } while (FindNextFile(hFind, &fd) && (dwCount < 100));

                FindClose(hFind);
            }
        }
        
        if (bFound)
        {
            hr = SHSetUserPicturePath(pszUsername, 0, szPath);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    
    return hr;
}


//  --------------------------------------------------------------------------
//  ::SHGetUserPicturePath
//
//  Arguments:  pszUsername     =   Desired user (NULL for current user).
//              dwFlags         =   Flags.
//              pszPath         =   Path to user picture.
//
//  Returns:    HRESULT
//
//  Purpose:    Returns the user's picture path (absolute). Does parameter
//              validation as well. This function only supports .bmp files.
//
//              Use SHGUPP_FLAG_BASEPATH to return the base to the pictures
//              directory.
//
//              Use SHGUPP_FLAG_DEFAULTPICSPATH to return the path to the
//              default pictures directory.
//
//              Use SHGUPP_FLAG_CREATE to create the user picture directory.
//
//              If neither SHGUPP_FLAG_BASEPATH or SHGUPP_FLAG_DEFAULTPICSPATH
//              is specified, and the user has no picture, SHGUPP_FLAG_CREATE
//              will select one of the default pictures at random.
//
//  History:    2000-02-22  vtan        created
//              2000-03-24  vtan        moved from folder.cpp
//  --------------------------------------------------------------------------

#define UASTR_PATH_PICTURES     TEXT("Microsoft\\User Account Pictures")
#define UASTR_PATH_DEFPICS      UASTR_PATH_PICTURES TEXT("\\Default Pictures")

STDAPI SHGetUserPicturePath (LPCTSTR pszUsername, DWORD dwFlags, LPTSTR pszPath)

{
    HRESULT     hr;
    TCHAR       szPath[MAX_PATH];

    //  Validate dwFlags.

    if ((dwFlags & SHGUPP_FLAG_INVALID_MASK) != 0)
    {
        return(E_INVALIDARG);
    }

    //  Validate pszPath. This must not be NULL.

    if ((pszPath == NULL) || IsBadWritePtr(pszPath, MAX_PATH * sizeof(TCHAR)))
    {
        return(E_INVALIDARG);
    }

    //  Start by getting the base picture path

    hr = SHGetFolderPathAndSubDir(NULL,
                                  (dwFlags & SHGUPP_FLAG_CREATE) ? (CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE) : CSIDL_COMMON_APPDATA,
                                  NULL,
                                  SHGFP_TYPE_CURRENT,
                                  (dwFlags & SHGUPP_FLAG_DEFAULTPICSPATH) ? UASTR_PATH_DEFPICS : UASTR_PATH_PICTURES,
                                  szPath);

    //  If the base path is requested this function is done.

    if (S_OK == hr && 0 == (dwFlags & (SHGUPP_FLAG_BASEPATH | SHGUPP_FLAG_DEFAULTPICSPATH)))
    {
        TCHAR szUsername[UNLEN + sizeof('\0')];

        if (pszUsername == NULL)
        {
            DWORD dwUsernameSize;

            dwUsernameSize = ARRAYSIZE(szUsername);
            if (GetUserName(szUsername, &dwUsernameSize) != FALSE)
            {
                pszUsername = szUsername;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        if (pszUsername != NULL)
        {
            //  Append the user name to the picture path. Then look for
            //  <username>.bmp. This function only supports bmp.

            PathAppend(szPath, pszUsername);
            lstrcatn(szPath, TEXT(".bmp"), ARRAYSIZE(szPath));
            if (PathFileExistsAndAttributes(szPath, NULL) != FALSE)
            {
                hr = S_OK;
            }
            else if (dwFlags & SHGUPP_FLAG_CREATE)
            {
                // No picture has been set for this user. Select one
                // of the default pictures at random.
                hr = SetDefaultUserPicture(pszUsername);
                ASSERT(FAILED(hr) || PathFileExistsAndAttributes(szPath, NULL));
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
        }
    }

    if (S_OK == hr)
    {
        lstrcpyn(pszPath, szPath, MAX_PATH);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  ::SHSetUserPicturePath
//
//  Arguments:  pszUsername     =   Desired user (NULL for current user).
//              dwFlags         =   Flags.
//              pszPath         =   Path to NEW user picture.
//
//  Returns:    HRESULT
//
//  Purpose:    Sets the specified user's picture as a copy of the given
//              image file. The image file may be any supported standard image
//              file (.gif / .jpg / .bmp). The file is converted to a 96x96
//              .bmp file in the user picture directory.
//
//  History:    2000-02-22  vtan        created
//              2000-03-24  vtan        moved from folder.cpp
//              2000-04-27  jeffreys    restore old image on conversion failure
//  --------------------------------------------------------------------------

STDAPI SHSetUserPicturePath (LPCTSTR pszUsername, DWORD dwFlags, LPCTSTR pszPath)

{
    HRESULT     hr;
    TCHAR       szPath[MAX_PATH];
    TCHAR       szUsername[UNLEN + sizeof('\0')];
    DWORD       dwUsernameSize;

    hr = E_FAIL;

    //  Validate dwFlags. Currently no valid flags so this must be 0x00000000.

    if ((dwFlags & SHSUPP_FLAG_INVALID_MASK) != 0)
    {
        return(E_INVALIDARG);
    }

    dwUsernameSize = ARRAYSIZE(szUsername);
    if (GetUserName(szUsername, &dwUsernameSize) == FALSE)
    {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    if (pszUsername != NULL)
    {
        //  Privilege check. Must be an administrator to use this function when
        //  pszUsername is not NULL (i.e. for somebody else).
        if ((lstrcmpi(pszUsername, szUsername) != 0) &&
            (SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS) == FALSE))
        {
            static const SID c_SystemSid = {SID_REVISION,1,SECURITY_NT_AUTHORITY,{SECURITY_LOCAL_SYSTEM_RID}};
            BOOL bSystem = FALSE;

            // One more check.  Allow local system through since we may
            // get called from the logon screen.

            if (!CheckTokenMembership(NULL, (PSID)&c_SystemSid, &bSystem) || !bSystem)
            {
                return(E_ACCESSDENIED);
            }
        }
    }
    else
    {
        pszUsername = szUsername;
    }

    //  Start by getting the base picture path

    hr = SHGetFolderPathAndSubDir(NULL,
                                  CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE,
                                  NULL,
                                  SHGFP_TYPE_CURRENT,
                                  UASTR_PATH_PICTURES,
                                  szPath);
    if (S_OK == hr)
    {
        //  Before attempt to delete what's there try to access the
        //  new file. If this fails deleting what's currently installed
        //  could leave the user without a picture. Fail the API before
        //  anything is lost.

        if ((pszPath == NULL) || (PathFileExistsAndAttributes(pszPath, NULL) != FALSE))
        {
            TCHAR szTemp[MAX_PATH];

            PathAppend(szPath, pszUsername);
            lstrcpyn(szTemp, szPath, ARRAYSIZE(szTemp));
            lstrcatn(szPath, TEXT(".bmp"), ARRAYSIZE(szPath));
            lstrcatn(szTemp, TEXT(".tmp"), ARRAYSIZE(szTemp));

            if ((pszPath == NULL) || lstrcmpi(pszPath, szPath) != 0)
            {
                //  If present, rename <username>.Bmp to <username>.Tmp.
                //  First reset the attributes so file ops work. Don't use
                //  trace macros because failure is expected.

                (BOOL)SetFileAttributes(szPath, 0);
                (BOOL)SetFileAttributes(szTemp, 0);
                (BOOL)MoveFileEx(szPath, szTemp, MOVEFILE_REPLACE_EXISTING);

                //  Convert the given image to a bmp and resize it
                //  using the helper function which does all the goo.

                if (pszPath != NULL)
                {
                    hr = ConvertAndResizeImage(pszPath, szPath);

                    if (SUCCEEDED(hr))
                    {
                        // Since this may be an admin setting someone else's
                        // picture, we need to grant that person access to
                        // modify/delete the file so they can change it
                        // themselves later.

                        (BOOL)SetExplicitAccessToObject(szPath,
                                                        SE_FILE_OBJECT,
                                                        pszUsername,
                                                        GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE | DELETE,
                                                        0);
                    }
                }
                else
                {
                    hr = S_OK;
                }

                if (SUCCEEDED(hr))
                {
                    // Delete the old picture
                    (BOOL)DeleteFile(szTemp);
                }
                else
                {
                    // Restore the old picture
                    (BOOL)MoveFileEx(szTemp, szPath, MOVEFILE_REPLACE_EXISTING);
                }
                // Notify everyone that a user picture has changed
                SHChangeDWORDAsIDList dwidl;
                dwidl.cb      = SIZEOF(dwidl) - SIZEOF(dwidl.cbZero);
                dwidl.dwItem1 = SHCNEE_USERINFOCHANGED;
                dwidl.dwItem2 = 0;
                dwidl.cbZero  = 0;

                SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH, (LPCITEMIDLIST)&dwidl, NULL);
            }
            else
            {
                // Source and destination are the same, nothing to do.
                hr = S_FALSE;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

    return(hr);
}

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\undo.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1994
//
// File: undo.h
//
// History:
//  There is no history.  This file doesn't exist
//
//---------------------------------------------------------------------------

#ifndef _UNDO_INC
#define _UNDO_INC
typedef struct _UNDOATOM * LPUNDOATOM;              
              
typedef struct _UNDOATOM {
    UINT uType;
    HWND hwnd;
    LPVOID lpData;
    FILEOP_FLAGS  foFlags;  //Misc flags.
    
    void (CALLBACK* GetText)(LPUNDOATOM lpua, TCHAR * buffer, int type);
    void (CALLBACK* Release)(LPUNDOATOM lpua);
    void (CALLBACK* Invoke)(LPUNDOATOM lpua);
    
} UNDOATOM;

EXTERN_C LPUNDOATOM s_lpuaUndoHistory;

#define UNDO_MENUTEXT    1
#define UNDO_STATUSTEXT  2

STDAPI_(void) GetUndoText(LPTSTR lpszBuffer, UINT cchBuffer, int type);
void FreeUndoList();

STDAPI_(void) AddUndoAtom(LPUNDOATOM lpua);
STDAPI_(void) Undo(HWND hwnd);
STDAPI_(void) NukeUndoAtom(LPUNDOATOM lpua);
STDAPI_(BOOL) IsUndoAvailable();

STDAPI_(void) EnumUndoAtoms(int (CALLBACK* lpfn)(LPUNDOATOM lpua, LPARAM lParam), LPARAM lParam);
#define EUA_DONOTHING   0x00 
#define EUA_DELETE      0x01
#define EUA_ABORT       0x02
#define EUA_DELETEABORT 0x03  // or of abort and delete

STDAPI_(void) SuspendUndo(BOOL f);

#endif // _UNDO_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\uevttmr.h ===
#ifndef _UEVTTMR_H
#define _UEVTTMR_H

#include "dpa.h"

typedef struct
{
    HWND                        hWnd;
    UINT                        uCallbackMessage;
    ULONG                       uUserEventTimerID;
    UINT                        uTimerElapse;
    UINT                        uIntervalCountdown;
    IUserEventTimerCallback *   pUserEventTimerCallback;
    BOOL                        bFirstTime;
} 
USEREVENTINFO;

#define         MIN_TIMER_THRESHOLD         0.1
#define         MAX_TIMER_THRESHOLD         0.01
    
class CUserEventTimer : public IUserEventTimer
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    // *** IUserEventTimer ***
    STDMETHODIMP SetUserEventTimer( HWND hWnd, 
        UINT uCallbackMessage, 
        UINT uTimerElapse,
        IUserEventTimerCallback * pUserEventTimerCallback, 
        ULONG * puUserEventTimerID);

    STDMETHODIMP KillUserEventTimer(HWND hWnd, ULONG uUserEventTimerID);

    STDMETHODIMP GetUserEventTimerElapsed(HWND hWnd, ULONG uUserEventTimerID, UINT * puTimerElapsed);

    STDMETHODIMP InitTimerTickInterval(UINT uTimerTickIntervalMs);

    CUserEventTimer();
    virtual ~CUserEventTimer();
    HRESULT Init();
    static STDMETHODIMP_(int) s_DeleteCB(LPVOID pData1, LPVOID pData2);

    LRESULT v_WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    static const UINT_PTR   TIMER_ID            = 1000;
    static const UINT       TIMER_ELAPSE        = 5000;        // 5 seconds

    static const ULONG      MIN_TIMER_ID        = 0x00001000;
    static const ULONG      MAX_TIMER_ID        = 0xDDDD1000;

    // static const DWORD      MIN_TIMER_LENGTH     = 4500;     // 4.5 seconds
    // static const DWORD      MAX_TIMER_LENGTH     = 5002;     // 5 seconds + 2 milliseconds

    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    _CreateWindow();
    void    _Destroy();
    void    _OnTimer();
    void    _KillIntervalTimer();
    int     _GetTimerDetailsIndex(HWND hWnd, ULONG uUserEventTimerID);
    HRESULT  _SetUserEventTimer( HWND hWnd, UINT uCallbackMessage, 
        UINT uNumIntervals, IUserEventTimerCallback * pUserEventTimerCallback, 
        ULONG * puUserEventTimerID);
    HRESULT _ResetUserEventTimer(HWND hWnd, UINT uCallbackMessage, UINT uNumIntervals,
        int nIndex);

    ULONG   _GetNextInternalTimerID(HWND hWnd);
    inline BOOL _IsAssignedTimerID(HWND hWnd, ULONG uUserEventTimerID)
    {
        return (_GetTimerDetailsIndex(hWnd, uUserEventTimerID) >= 0);
    }

    inline UINT _CalcNumIntervals(UINT uTimerElapse)
    {
        return (UINT)(uTimerElapse/m_uTimerTickInterval);
    }

    inline UINT _CalcMilliSeconds(UINT uIntervalCountdown)
    {
        return (UINT) (uIntervalCountdown*m_uTimerTickInterval);
    }

    LONG                    m_cRef;

    CDPA<USEREVENTINFO>     _dpaUserEventInfo;

    UINT_PTR                _uUserTimerID;
    HWND                    m_hWnd;
    DWORD                   m_dwUserStartTime;
    UINT                    m_uTimerTickInterval;
};

#endif  // _UEVTTMR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\uevttmr.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include <shguidp.h>
#include "uevttmr.h"

// 1. Use dpa callback system to delete the entire hdpa array

EXTERN_C const TCHAR c_szUserEventWindow[] = TEXT("UserEventWindow");

// *** IUnknown methods ***
STDMETHODIMP CUserEventTimer::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CUserEventTimer, IUserEventTimer),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CUserEventTimer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CUserEventTimer::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
//    _Destroy();
    return 0;
}


// *** Constructor and Destructor ***

CUserEventTimer::CUserEventTimer() : m_cRef(1)
{
}

CUserEventTimer::~CUserEventTimer()
{
    _Destroy();
}

// *** IUserEventTimer methods ***
HRESULT CUserEventTimer::SetUserEventTimer( 
    HWND hWnd,
    UINT uCallbackMessage,
    UINT uTimerElapse, 
    IUserEventTimerCallback * pUserEventTimerCallback,
    ULONG * puUserEventTimerID
)
{
    RIP(puUserEventTimerID != NULL);

    HRESULT hr;

    // Argument Validation
    if (!m_hWnd)
        hr = E_FAIL; 
    else if (!_dpaUserEventInfo)
        hr = E_OUTOFMEMORY;
    else if (!hWnd && !pUserEventTimerCallback)
        hr = E_INVALIDARG;
    else if (!puUserEventTimerID || uTimerElapse <= 0)
        hr = E_INVALIDARG;
    else if (hWnd)
    {
        int nIndex = _GetTimerDetailsIndex(hWnd, *puUserEventTimerID);
        if (nIndex >= 0)
            hr = _ResetUserEventTimer(hWnd, uCallbackMessage, uTimerElapse, nIndex);
        else
            hr = _SetUserEventTimer(hWnd, uCallbackMessage, uTimerElapse, pUserEventTimerCallback, puUserEventTimerID);
    }
    else 
    {
        ASSERT(pUserEventTimerCallback != NULL);
        hr = _SetUserEventTimer(hWnd, uCallbackMessage, uTimerElapse, pUserEventTimerCallback, puUserEventTimerID);
    }
    
    return hr;
}

HRESULT CUserEventTimer::InitTimerTickInterval(UINT uTimerTickIntervalMs)
{
    // If there is more than one registered client to the user event timer,
    // then we cannot change the timer tick interval
    if (_dpaUserEventInfo.GetPtrCount() > 0)
        return E_FAIL;
    
    if (uTimerTickIntervalMs > 0)
        m_uTimerTickInterval = uTimerTickIntervalMs;
    else
        m_uTimerTickInterval = TIMER_ELAPSE;

    return S_OK;
}

HRESULT CUserEventTimer::_SetUserEventTimer( 
    HWND hWnd,
    UINT uCallbackMessage,
    UINT uTimerElapse, 
    IUserEventTimerCallback * pUserEventTimerCallback,
    ULONG * puUserEventTimerID
)
{
    ASSERT(puUserEventTimerID);
    ASSERT(m_uTimerTickInterval > 0);

    HRESULT hr = E_OUTOFMEMORY;
    
    USEREVENTINFO * pUserEventInfo = new USEREVENTINFO;

    if (pUserEventInfo)
    {
        pUserEventInfo->hWnd = hWnd;
        if (hWnd)
        {
            pUserEventInfo->uCallbackMessage = uCallbackMessage;
            pUserEventInfo->uUserEventTimerID = *puUserEventTimerID;
        }
        else
        {
            pUserEventInfo->pUserEventTimerCallback = pUserEventTimerCallback;
        }

        // Timer ID cannot be zero..
        if (!pUserEventInfo->uUserEventTimerID)
        {
            ULONG uTimerID = _GetNextInternalTimerID(hWnd);
            if (uTimerID != -1)
                pUserEventInfo->uUserEventTimerID = uTimerID;
        }

        int nRetInsert = -1;
        if (pUserEventInfo->uUserEventTimerID)
        {
            pUserEventInfo->uTimerElapse = uTimerElapse;
            pUserEventInfo->uIntervalCountdown = _CalcNumIntervals(uTimerElapse);
            pUserEventInfo->bFirstTime = TRUE;

            nRetInsert = _dpaUserEventInfo.AppendPtr(pUserEventInfo);

            if (nRetInsert != -1)
            {
                *puUserEventTimerID = pUserEventInfo->uUserEventTimerID;
                if (!_uUserTimerID)
                {
                    _uUserTimerID = SetTimer(m_hWnd, TIMER_ID, m_uTimerTickInterval, NULL);
                }
            
                if (!_uUserTimerID)
                {
                    _dpaUserEventInfo.DeletePtr(_dpaUserEventInfo.GetPtrCount()-1);
                }
            }
        }

        hr = S_OK;
        if (nRetInsert == -1 || _uUserTimerID == 0)
        {
            *puUserEventTimerID = 0;
            delete (pUserEventInfo);
            hr = E_FAIL;
        }
        else if (NULL == hWnd)
        {
            IUnknown_SetSite(pUserEventTimerCallback, this);
            pUserEventTimerCallback->AddRef();
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!m_dwUserStartTime && _dpaUserEventInfo.GetPtrCount() == 1)
            m_dwUserStartTime = GetTickCount();
    }
        
    return hr;
}

HRESULT CUserEventTimer::_ResetUserEventTimer(
    HWND hWnd,
    UINT uCallbackMessage,
    UINT uTimerElapse, 
    int nIndex
)
{
    ASSERT(m_hWnd != NULL);
    ASSERT(_dpaUserEventInfo != NULL);
    ASSERT(hWnd != NULL);
    ASSERT(nIndex >= 0);

    USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(nIndex);

    ASSERT(pUserEventInfo);
    ASSERT(pUserEventInfo->hWnd == hWnd);

    pUserEventInfo->uTimerElapse = uTimerElapse;
    pUserEventInfo->uIntervalCountdown = _CalcNumIntervals(uTimerElapse);
    pUserEventInfo->bFirstTime = TRUE;

    return S_OK;
}

int DeleteCB(USEREVENTINFO * lpData1, LPVOID lpData2)
{
    USEREVENTINFO * pUserEventInfo = lpData1;
    ASSERT(pUserEventInfo);

#ifdef DEBUG
    BOOL bErrorCheck = (lpData2 ? (*(BOOL *)lpData2) : FALSE);
    if (bErrorCheck)
        TraceMsg(TF_WARNING, "CUserEventTimer::s_DeleteCB App hasnt killed timer hwnd = %u, timerID = %u",
            pUserEventInfo->hWnd, pUserEventInfo->uUserEventTimerID);
#endif

    IUserEventTimerCallback * pUserEventTimerCallback = 
        (pUserEventInfo->hWnd == NULL) ? pUserEventInfo->pUserEventTimerCallback : NULL;
    ASSERT(pUserEventInfo->hWnd || pUserEventTimerCallback);

    // _dpaUserEventInfo.DeletePtr(nIndex);
    delete pUserEventInfo;

    if (pUserEventTimerCallback)
    {
        IUnknown_SetSite(pUserEventTimerCallback, NULL);
        pUserEventTimerCallback->Release();
    }

    return TRUE;
}

HRESULT CUserEventTimer::GetUserEventTimerElapsed(
    HWND hWnd, 
    ULONG uUserEventTimerID, 
    UINT * puTimerElapsed)
{
    HRESULT hr = E_FAIL;

    if (!puTimerElapsed || !hWnd || !m_hWnd || !_dpaUserEventInfo)
        return hr;

    int nIndex = _GetTimerDetailsIndex(hWnd, uUserEventTimerID);
    if (nIndex >= 0)
    {
        USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(nIndex);

        *puTimerElapsed = _CalcMilliSeconds(
            _CalcNumIntervals(pUserEventInfo->uTimerElapse) - pUserEventInfo->uIntervalCountdown
        );
        hr = S_OK;
    }
    else
        *puTimerElapsed = 0;

    return hr;
}

HRESULT CUserEventTimer::KillUserEventTimer(HWND hWnd, ULONG uUserEventTimerID)
{
    HRESULT hr = E_FAIL;
    
    if (!m_hWnd || !_dpaUserEventInfo)
        return hr;

    int nIndex = _GetTimerDetailsIndex(hWnd, uUserEventTimerID);
    if (nIndex >= 0)
    {
        DeleteCB(_dpaUserEventInfo.GetPtr(nIndex), NULL);
        _dpaUserEventInfo.DeletePtr(nIndex);
        _KillIntervalTimer();
        
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    if (0 == _dpaUserEventInfo.GetPtrCount())
        m_dwUserStartTime = 0;

    return hr;
}

// Private helpers
HRESULT CUserEventTimer::Init()
{
    if (!_CreateWindow())
        return E_FAIL;

    if (!_dpaUserEventInfo.Create(4))
        return E_OUTOFMEMORY;

    m_uTimerTickInterval = TIMER_ELAPSE;

    ASSERT(!_uUserTimerID);
    ASSERT(!m_dwUserStartTime);

    return S_OK;
}

BOOL CUserEventTimer::_CreateWindow()
{
    if (!m_hWnd)
    {
        WNDCLASSEX wc;
        DWORD dwExStyle = WS_EX_STATICEDGE;

        ZeroMemory(&wc, sizeof(wc));
        wc.cbSize = sizeof(WNDCLASSEX);

        if (!GetClassInfoEx(HINST_THISDLL, c_szUserEventWindow, &wc))
        {
            wc.lpszClassName = c_szUserEventWindow;
            wc.style = CS_DBLCLKS;
            wc.lpfnWndProc = s_WndProc;
            wc.hInstance = HINST_THISDLL;
            wc.hCursor = LoadCursor(NULL, IDC_ARROW);
            wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
            wc.cbWndExtra = sizeof(CUserEventTimer *);

            if (!RegisterClassEx(&wc))
            {
                return FALSE;
            }
        }

        m_hWnd = CreateWindowEx(dwExStyle, c_szUserEventWindow,
                NULL, WS_POPUP, 0, 0, 0, 0,
                HWND_MESSAGE, NULL, HINST_THISDLL, (void *)this);

        if (!m_hWnd)
            return FALSE;
    }
    
    return TRUE;
}

void CUserEventTimer::_Destroy()
{   
    if (_dpaUserEventInfo)
    {
        BOOL bErrorCheck = TRUE;
        _dpaUserEventInfo.DestroyCallback(DeleteCB, &bErrorCheck);
    }
    
    _KillIntervalTimer();

    DestroyWindow(m_hWnd);
}

void CUserEventTimer::_KillIntervalTimer()
{
    if (_uUserTimerID)
    {
        if (_dpaUserEventInfo && _dpaUserEventInfo.GetPtrCount() == 0)
        {
            KillTimer(m_hWnd, _uUserTimerID);
            _uUserTimerID = 0;
        }
    }
}

ULONG CUserEventTimer::_GetNextInternalTimerID(HWND hWnd)
{
    ULONG uStartTimerID = MIN_TIMER_ID;

    for (; uStartTimerID <= MAX_TIMER_ID; uStartTimerID++)
    {
        if (!_IsAssignedTimerID(hWnd, uStartTimerID))
            break;
    }

    if (uStartTimerID > MAX_TIMER_ID)
        uStartTimerID = -1;
        
    return uStartTimerID;
}

int CUserEventTimer::_GetTimerDetailsIndex(HWND hWnd, ULONG uUserEventTimerID)
{
    if (!_dpaUserEventInfo || !uUserEventTimerID)
        return -1;

    for (int i = _dpaUserEventInfo.GetPtrCount()-1; i >= 0; i--)
    {
        USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(i);
        ASSERT(pUserEventInfo);

        if (pUserEventInfo->hWnd == hWnd && pUserEventInfo->uUserEventTimerID == uUserEventTimerID)
        {
            return i;
        }
    }

    return -1;
}

LRESULT CALLBACK CUserEventTimer::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUserEventTimer *puet = (CUserEventTimer *)GetWindowLongPtr(hwnd, 0);

    if (WM_CREATE == uMsg)
    {
        CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
        puet = (CUserEventTimer *)pcs->lpCreateParams;
        puet->m_hWnd = hwnd;
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)puet);
    }

    return puet ? puet->v_WndProc(uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CUserEventTimer::v_WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_TIMER:
        ASSERT(wParam == TIMER_ID);
        _OnTimer();
        return 0;
        
    default:
        return (DefWindowProc(m_hWnd, uMsg, wParam, lParam));
    }
}

void CUserEventTimer::_OnTimer()
{
    ASSERT(m_hWnd);

    if (_dpaUserEventInfo)
    {
        LONG uTimerDifference = -1;
        LASTINPUTINFO lii = {0};

        lii.cbSize = sizeof(LASTINPUTINFO);
        if (GetLastInputInfo(&lii))
        {
            if (lii.dwTime < m_dwUserStartTime)
                uTimerDifference = 0;
            else
                uTimerDifference = lii.dwTime - m_dwUserStartTime;
        }

        LONG uMinTimerDifferenceThreshold = (LONG) (m_uTimerTickInterval * (float)(1-MIN_TIMER_THRESHOLD));
        LONG uMaxTimerDifferenceThreshold = (LONG) (m_uTimerTickInterval * (float)(1+MAX_TIMER_THRESHOLD));

        for (int i = _dpaUserEventInfo.GetPtrCount()-1; i >= 0; i--)
        {
            USEREVENTINFO * pUserEventInfo = _dpaUserEventInfo.GetPtr(i);

            ASSERT(pUserEventInfo);

            if (uTimerDifference != 0)
            {
                if ( (uTimerDifference == -1) || 
                     (pUserEventInfo->bFirstTime && uTimerDifference > uMinTimerDifferenceThreshold && 
                                uTimerDifference <= uMaxTimerDifferenceThreshold) || 
                     (!pUserEventInfo->bFirstTime && uTimerDifference <= uMaxTimerDifferenceThreshold)
                )
                {
                    pUserEventInfo->uIntervalCountdown --;
                    if (pUserEventInfo->uIntervalCountdown == 0)
                    {
                        // Reset the countdown
                        pUserEventInfo->uIntervalCountdown = _CalcNumIntervals(pUserEventInfo->uTimerElapse);
                    
                        if (pUserEventInfo->hWnd)
                        {
                            PostMessage(pUserEventInfo->hWnd, 
                                pUserEventInfo->uCallbackMessage, 
                                (WPARAM) pUserEventInfo->uTimerElapse, 
                                (LPARAM) pUserEventInfo->uUserEventTimerID);
                        }
                        else
                        {
                            pUserEventInfo->pUserEventTimerCallback->UserEventTimerProc(
                                pUserEventInfo->uUserEventTimerID,
                                pUserEventInfo->uTimerElapse); 
                        }
                    }
                }
            }
            
            pUserEventInfo->bFirstTime = FALSE;
        }
        
        m_dwUserStartTime = GetTickCount();
    }
}


STDAPI CUserEventTimer_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CUserEventTimer * pUserEventTimer = new CUserEventTimer();
    if (!pUserEventTimer || FAILED(hr = pUserEventTimer->Init()))
    {
        *ppv = NULL;
    }
    else
    {
        hr = pUserEventTimer->QueryInterface(riid, ppv);
        pUserEventTimer->Release();  // Already have a ref count from new
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\util.cpp ===
#include "shellprv.h"
#include "guids.h"      // for PRINTER_BIND_INFO
#include "printer.h"    // for IPrintersBindInfo
#include "util.h"

#include <advpub.h>     // For REGINSTALL
#include <ntverp.h>
#include <urlmon.h>
#include <shlwapi.h>
#include "shldisp.h"
#include <malloc.h>
#include "shitemid.h"
#include "datautil.h"
#include <perhist.h>    // IPersistHistory is defined here.

#include "ids.h"
#include "views.h"
#include "ole2dup.h"
#include <vdate.h>
#include <regstr.h>
#include "unicpp\dutil.h"
#include <stdlib.h>

#include "prop.h"
#include "ftascstr.h"   // for CFTAssocStore
#include "ftcmmn.h"     // for MAX_APPFRIENDLYNAME
#include "ascstr.h"     // for IAssocInfo class
#include "fstreex.h"    // for CFSFolder_CreateFolder
#include "deskfldr.h"
#include "cscuiext.h"
#include "netview.h"    // SHGetNetJoinInformation
#include "mtpt.h"
#include <cscapi.h>     // for CSCQueryFileStatus
#include <winsta.h>
#include <dsgetdc.h>
#include <uxtheme.h>

#include <duithread.h>

//The following is defined in shell32\unicpp\dutil.cpp
void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme);

#define DM_STRICT       TF_WARNING  // audit menus, etc.
#define DM_STRICT2      0           // verbose

//
// We need to put this one in per-instance data section because during log-off
// and log-on, this info needs to be re-read from the registry.
//
// REGSHELLSTATE is the version of the SHELLSTATE that goes into the
// registry.  When loading a REGSHELLSTATE, you have to study the
// cbSize to see if it's a downlevel structure and upgrade it accordingly.
//

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE;

#define REGSHELLSTATE_SIZE_WIN95 (sizeof(UINT)+SHELLSTATE_SIZE_WIN95)  // Win95 Gold
#define REGSHELLSTATE_SIZE_NT4   (sizeof(UINT)+SHELLSTATE_SIZE_NT4)    // Win95 OSR / NT 4
#define REGSHELLSTATE_SIZE_IE4   (sizeof(UINT)+SHELLSTATE_SIZE_IE4)    // IE 4, 4.01
#define REGSHELLSTATE_SIZE_WIN2K (sizeof(UINT)+SHELLSTATE_SIZE_WIN2K)  // ie5, win2k, millennium, whistler

// If the SHELLSTATE size changes, we need to add a new define
// above and new upgrade code in SHRefreshSettings
#ifdef DEBUG
void snafu () {COMPILETIME_ASSERT(REGSHELLSTATE_SIZE_WIN2K == sizeof(REGSHELLSTATE));}
#endif DEBUG

REGSHELLSTATE * g_pShellState = 0;

// detect an "empty" sound scheme key. this deals with the NULL case that returns
// "2" as that is enough space for a NULL char

BOOL NonEmptySoundKey(HKEY, LPCTSTR pszKey)
{
    LONG cb = 0; // in/out
    return (ERROR_SUCCESS == SHRegQueryValue(HKEY_CURRENT_USER, pszKey, NULL, &cb)) && (cb > sizeof(TCHAR));
}

STDAPI_(void) SHPlaySound(LPCTSTR pszSound)
{
    TCHAR szKey[CCH_KEYMAX];

    // to avoid loading all of the MM system DLLs we check the registry first
    // if there's nothing registered, we blow off the play,

    wsprintf(szKey, TEXT("AppEvents\\Schemes\\Apps\\Explorer\\%s\\.current"), pszSound);
    if (NonEmptySoundKey(HKEY_CURRENT_USER, szKey))
    {
        PlaySound(pszSound, NULL, SND_ALIAS | SND_APPLICATION | SND_ASYNC | SND_NODEFAULT | SND_NOSTOP);
    }
    else
    {
        // support system sounds too
        wsprintf(szKey, TEXT("AppEvents\\Schemes\\Apps\\.Default\\%s\\.current"), pszSound);
        if (NonEmptySoundKey(HKEY_CURRENT_USER, szKey))
        {
            PlaySound(pszSound, NULL, SND_ALIAS | SND_APPLICATION | SND_ASYNC | SND_NODEFAULT | SND_NOSTOP);
        }
    }
}


// helper function to set whether shift or control is down at the start of the invoke
// operation, so others down the line can check this instead of calling GetAsyncKeyState themselves
STDAPI_(void) SetICIKeyModifiers(DWORD* pfMask)
{
    ASSERT(pfMask);

    if (GetKeyState(VK_SHIFT) < 0)
    {
        *pfMask |= CMIC_MASK_SHIFT_DOWN;
    }

    if (GetKeyState(VK_CONTROL) < 0)
    {
        *pfMask |= CMIC_MASK_CONTROL_DOWN;
    }
}


// sane way to get the msg pos into a point, mostly needed for win32
void GetMsgPos(POINT *ppt)
{
    DWORD dw = GetMessagePos();

    ppt->x = GET_X_LPARAM(dw);
    ppt->y = GET_Y_LPARAM(dw);
}

/*  This gets the number of consecutive chrs of the same kind.  This is used
 *  to parse the time picture.  Returns 0 on error.
 */

int GetPict(WCHAR ch, LPWSTR wszStr)
{
    int count = 0;
    while (ch == *wszStr++)
        count++;

    return count;
}

DWORD CALLBACK _PropSheetThreadProc(void *ppv)
{
    PROPSTUFF * pps = (PROPSTUFF *)ppv;

    // CoInitializeEx(0, COINIT_MULTITHREADED); // to test stuff in multithread case

    HRESULT hrInit = SHOleInitialize(0);

    DWORD dwRet = pps->lpStartAddress(pps);

    // cleanup
    if (pps->pdtobj)
        pps->pdtobj->Release();

    if (pps->pidlParent)
        ILFree(pps->pidlParent);

    if (pps->psf)
        pps->psf->Release();

    LocalFree(pps);

    SHOleUninitialize(hrInit);

    return dwRet;
}

// reinerf: alpha cpp compiler confused by the type "LPITEMIDLIST", so to work
// around this we pass the last param as an void *instead of a LPITEMIDLIST
//
HRESULT SHLaunchPropSheet(LPTHREAD_START_ROUTINE pStartAddress, IDataObject *pdtobj, LPCTSTR pStartPage, IShellFolder *psf, void *pidl)
{
    LPITEMIDLIST pidlParent = (LPITEMIDLIST)pidl;
    UINT cbStartPage = !IS_INTRESOURCE(pStartPage) ? ((lstrlen(pStartPage) + 1) * sizeof(*pStartPage)) : 0 ;
    PROPSTUFF * pps = (PROPSTUFF *)LocalAlloc(LPTR, sizeof(PROPSTUFF) + cbStartPage);
    if (pps)
    {
        pps->lpStartAddress = pStartAddress;

        if (pdtobj)
        {
            pps->pdtobj = pdtobj;
            pdtobj->AddRef();
        }

        if (pidlParent)
            pps->pidlParent = ILClone(pidlParent);

        if (psf)
        {
            pps->psf = psf;
            psf->AddRef();
        }

        pps->pStartPage = pStartPage;
        if (!IS_INTRESOURCE(pStartPage))
        {
            pps->pStartPage = (LPTSTR)(pps + 1);
            lstrcpy((LPTSTR)(pps->pStartPage), pStartPage);
        }

        // _PropSheetThreadProc does not do any modality stuff, so we can't CTF_INSIST
        if (SHCreateThread(_PropSheetThreadProc, pps, CTF_PROCESS_REF, NULL))
            return S_OK;
    }
    return E_OUTOFMEMORY;
}

/*  This picks up the values in wValArray, converts them
 *  in a string containing the formatted date.
 *  wValArray should contain Month-Day-Year (in that order).
 */

int CreateDate(WORD *wValArray, LPWSTR wszOutStr)
{
    int     cchPictPart;
    WORD    wDigit;
    WORD    wIndex;
    WORD    wTempVal;
    LPWSTR  pwszPict, pwszInStr;
    WCHAR   wszShortDate[30];      // need more room for LOCALE_SSHORTDATE
    
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, wszShortDate, ARRAYSIZE(wszShortDate));
    pwszPict = wszShortDate;
    pwszInStr = wszOutStr;
    
    for (int i = 0; (i < 5) && (*pwszPict); i++)
    {
        cchPictPart = GetPict(*pwszPict, pwszPict);
        switch (*pwszPict)
        {
        case TEXT('M'):
        case TEXT('m'):
            {
                wIndex = 0;
                break;
            }
            
        case TEXT('D'):
        case TEXT('d'):
            {
                //
                // if short date style && *pszPict is 'd' &&
                // cchPictPart is more than equal 3,
                // then it is the day of the week.
                //
                if (cchPictPart >= 3)
                {
                    pwszPict += cchPictPart;
                    continue;
                }
                wIndex = 1;
                break;
            }
            
        case TEXT('Y'):
        case TEXT('y'):
            {
                wIndex = 2;
                if (cchPictPart == 4)
                {
                    if (wValArray[2] >=100)
                    {
                        *pwszInStr++ = TEXT('2');
                        *pwszInStr++ = TEXT('0');
                        wValArray[2]-= 100;
                    }
                    else
                    {
                        *pwszInStr++ = TEXT('1');
                        *pwszInStr++ = TEXT('9');
                    }
                }
                else if (wValArray[2] >=100)  // handle year 2000
                    wValArray[2]-= 100;
                
                break;
            }
            
        case TEXT('g'):
            {
                // era string
                pwszPict += cchPictPart;
                while (*pwszPict == TEXT(' ')) pwszPict++;
                continue;
            }
            
        case TEXT('\''):
            {
                while (*pwszPict && *++pwszPict != TEXT('\'')) ;
                continue;
            }
            
        default:
            {
                goto CDFillIn;
                break;
            }
        }
        
        /* This assumes that the values are of two digits only. */
        wTempVal = wValArray[wIndex];
        
        wDigit = wTempVal / 10;
        if (wDigit)
            *pwszInStr++ = (TCHAR)(wDigit + TEXT('0'));
        else if (cchPictPart > 1)
            *pwszInStr++ = TEXT('0');
        
        *pwszInStr++ = (TCHAR)((wTempVal % 10) + TEXT('0'));
        
        pwszPict += cchPictPart;
        
CDFillIn:
        /* Add the separator. */
        while ((*pwszPict) &&
            (*pwszPict != TEXT('\'')) &&
            (*pwszPict != TEXT('M')) && (*pwszPict != TEXT('m')) &&
            (*pwszPict != TEXT('D')) && (*pwszPict != TEXT('d')) &&
            (*pwszPict != TEXT('Y')) && (*pwszPict != TEXT('y')))
        {
            *pwszInStr++ = *pwszPict++;
        }
    }
    
    *pwszInStr = 0;
    
    return lstrlenW(wszOutStr);
}


#define DATEMASK        0x001F
#define MONTHMASK       0x01E0
#define MINUTEMASK      0x07E0
#define SECONDSMASK     0x001F

STDAPI_(int) GetDateString(WORD wDate, LPWSTR wszStr)
{
    WORD  wValArray[3];
    
    wValArray[0] = (wDate & MONTHMASK) >> 5;              /* Month */
    wValArray[1] = (wDate & DATEMASK);                    /* Date  */
    wValArray[2] = (wDate >> 9) + 80;                     /* Year  */
    
    return CreateDate(wValArray, wszStr);
}

//
// We need to loop through the string and extract off the month/day/year
// We will do it in the order of the NlS definition...
//
STDAPI_(WORD) ParseDateString(LPCWSTR pszStr)
{
    WORD    wParts[3];
    int     cchPictPart;
    WORD    wIndex;
    WORD    wTempVal;
    WCHAR   szShortDate[30];    // need more room for LOCALE_SSHORTDATE
    
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, szShortDate, ARRAYSIZE(szShortDate));
    LPWSTR pszPict = szShortDate;
    
    while (*pszPict && (*pszPict == *pszStr))
    {
        pszPict++;
        pszStr++;
    }
    
    for (int i = 0; (i < 5) && (*pszPict); i++)
    {
        cchPictPart = GetPict(*pszPict, pszPict);
        switch (*pszPict)
        {
        case TEXT('M'):
        case TEXT('m'):
            wIndex = 0;
            break;
            
        case TEXT('D'):
        case TEXT('d'):
            //
            // if short date style && *pszPict is 'd' &&
            // cchPictPart is more than equal 3,
            // then it is the day of the week.
            if (cchPictPart >= 3)
            {
                pszPict += cchPictPart;
                continue;
            }
            wIndex = 1;
            break;
            
        case TEXT('Y'):
        case TEXT('y'):
            wIndex = 2;
            break;
            
        case TEXT('g'):
            {
                // era string
                pszPict += cchPictPart;
                while (*pszPict == TEXT(' ')) pszPict++;
                continue;
            }
            
        case TEXT('\''):
            {
                while (*pszPict && *++pszPict != TEXT('\'')) ;
                continue;
            }
            
        default:
            return 0;
        }
        
        // We now want to loop through each of the characters while
        // they are numbers and build the number;
        //
        wTempVal = 0;
        while ((*pszStr >= TEXT('0')) && (*pszStr <= TEXT('9')))
        {
            wTempVal = wTempVal * 10 + (WORD)(*pszStr - TEXT('0'));
            pszStr++;
        }
        wParts[wIndex] = wTempVal;
        
        // Now make sure we have the correct separator
        pszPict += cchPictPart;
        if (*pszPict != *pszStr)
        {
            return 0;
        }
        while (*pszPict && (*pszPict == *pszStr))
        {
            //
            //  The separator can actually be more than one character
            //  in length.
            //
            pszPict++;  // align to the next field
            pszStr++;   // Align to next field
        }
    }
    
    //
    // Do some simple checks to see if the date looks half way reasonable.
    //
    if (wParts[2] < 80)
        wParts[2] += (2000 - 1900);  // Wrap to next century but leave as two digits...
    if (wParts[2] >= 1900)
        wParts[2] -= 1900;  // Get rid of Century
    if ((wParts[0] == 0) || (wParts[0] > 12) ||
        (wParts[1] == 0) || (wParts[1] > 31) ||
        (wParts[2] >= 200))
    {
        return 0;
    }
    
    // We now have the three parts so lets construct the date value
    
    // Now construct the date number
    return ((wParts[2] - 80) << 9) + (wParts[0] << 5) + wParts[1];
}


STDAPI_(BOOL) IsNullTime(const FILETIME *pft)
{
    FILETIME ftNull = {0, 0};
    return CompareFileTime(&ftNull, pft) == 0;
}


STDAPI_(BOOL) TouchFile(LPCTSTR pszFile)
{
    BOOL bRet = FALSE;
    HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_FLAG_NO_BUFFERING | FILE_FLAG_OPEN_NO_RECALL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME st;
        FILETIME ft;

        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        bRet = SetFileTime(hFile, &ft, &ft, &ft);
        CloseHandle(hFile);
    }
    return bRet;
}

void Int64ToStr(LONGLONG n, LPTSTR lpBuffer)
{
    TCHAR szTemp[40];
    LONGLONG iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
UINT GetNLSGrouping(void)
{
    TCHAR szGrouping[32];
    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    UINT grouping = 0;
    LPTSTR psz = szGrouping;
    for (;;)
    {
        if (*psz == '0') break;             // zero - stop

        else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - '0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }
    return grouping;
}

// takes a DWORD add commas etc to it and puts the result in the buffer
STDAPI_(LPTSTR) AddCommas64(LONGLONG n, LPTSTR pszResult, UINT cchResult)
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    nfmt.Grouping = GetNLSGrouping();
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, cchResult) == 0)
        StrCpyN(pszResult, szTemp, cchResult);

    return pszResult;
}

// takes a DWORD add commas etc to it and puts the result in the buffer
STDAPI_(LPTSTR) AddCommas(DWORD n, LPTSTR pszResult, UINT cchResult)
{
    return AddCommas64(n, pszResult, cchResult);
}


STDAPI_(LPTSTR) ShortSizeFormat64(LONGLONG n, LPTSTR szBuf, UINT cchBuf)
{
    return StrFormatByteSize64(n, szBuf, cchBuf);
}

STDAPI_(LPTSTR) ShortSizeFormat(DWORD n, LPTSTR szBuf, UINT cchBuf)
{
    return StrFormatByteSize64(n, szBuf, cchBuf);
}

// exported w/o cch, so assume it'll fit
STDAPI_(LPWSTR) AddCommasExportW(DWORD n, LPWSTR pszResult)
{
    return AddCommas(n, pszResult, 0x8FFF);
}

STDAPI_(LPTSTR) ShortSizeFormatExportW(DWORD n, LPWSTR szBuf)
{
    return StrFormatByteSize64(n, szBuf, 0x8FFF);
}

//
//    Converts the numeric value of a LONGLONG to a text string.
//    The string may optionally be formatted to include decimal places
//    and commas according to current user locale settings.
//
// ARGUMENTS:
//    n
//       The 64-bit integer to format.
//
//    szOutStr
//       Address of the destination buffer.
//
//    nSize
//       Number of characters in the destination buffer.
//
//    bFormat
//       TRUE  = Format per locale settings.
//       FALSE = Leave number unformatted.
//
//    pFmt
//       Address of a number format structure of type NUMBERFMT.
//       If NULL, the function automatically provides this information
//       based on the user's default locale settings.
//
//    dwNumFmtFlags
//       Encoded flag word indicating which members of *pFmt to use in
//       formatting the number.  If a bit is clear, the user's default
//       locale setting is used for the corresponding format value.  These
//       constants can be OR'd together.
//
//          NUMFMT_IDIGITS
//          NUMFMT_ILZERO
//          NUMFMT_SGROUPING
//          NUMFMT_SDECIMAL
//          NUMFMT_STHOUSAND
//          NUMFMT_INEGNUMBER
//
///////////////////////////////////////////////////////////////////////////////
STDAPI_(int) Int64ToString(LONGLONG n, LPTSTR szOutStr, UINT nSize, BOOL bFormat,
                           NUMBERFMT *pFmt, DWORD dwNumFmtFlags)
{
    INT nResultSize;
    TCHAR szBuffer[_MAX_PATH + 1];
    NUMBERFMT NumFmt;
    TCHAR szDecimalSep[5];
    TCHAR szThousandSep[5];

    ASSERT(NULL != szOutStr);

    //
    // Use only those fields in caller-provided NUMBERFMT structure
    // that correspond to bits set in dwNumFmtFlags.  If a bit is clear,
    // get format value from locale info.
    //
    if (bFormat)
    {
        TCHAR szInfo[20];

        if (NULL == pFmt)
            dwNumFmtFlags = 0;  // Get all format data from locale info.

        if (dwNumFmtFlags & NUMFMT_IDIGITS)
        {
            NumFmt.NumDigits = pFmt->NumDigits;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDIGITS, szInfo, ARRAYSIZE(szInfo));
            NumFmt.NumDigits = StrToLong(szInfo);
        }

        if (dwNumFmtFlags & NUMFMT_ILZERO)
        {
            NumFmt.LeadingZero = pFmt->LeadingZero;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szInfo, ARRAYSIZE(szInfo));
            NumFmt.LeadingZero = StrToLong(szInfo);
        }

        if (dwNumFmtFlags & NUMFMT_SGROUPING)
        {
            NumFmt.Grouping = pFmt->Grouping;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szInfo, ARRAYSIZE(szInfo));
            NumFmt.Grouping = StrToLong(szInfo);
        }

        if (dwNumFmtFlags & NUMFMT_SDECIMAL)
        {
            NumFmt.lpDecimalSep = pFmt->lpDecimalSep;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecimalSep, ARRAYSIZE(szDecimalSep));
            NumFmt.lpDecimalSep = szDecimalSep;
        }

        if (dwNumFmtFlags & NUMFMT_STHOUSAND)
        {
            NumFmt.lpThousandSep = pFmt->lpThousandSep;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandSep, ARRAYSIZE(szThousandSep));
            NumFmt.lpThousandSep = szThousandSep;
        }

        if (dwNumFmtFlags & NUMFMT_INEGNUMBER)
        {
            NumFmt.NegativeOrder = pFmt->NegativeOrder;
        }
        else
        {
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_INEGNUMBER, szInfo, ARRAYSIZE(szInfo));
            NumFmt.NegativeOrder  = StrToLong(szInfo);
        }

        pFmt = &NumFmt;
    }

    Int64ToStr(n, szBuffer);

    //  Format the number string for the locale if the caller wants a
    //  formatted number string.
    if (bFormat)
    {
        nResultSize = GetNumberFormat(LOCALE_USER_DEFAULT, 0, szBuffer, pFmt, szOutStr, nSize);
        if (0 != nResultSize)                      // Chars in output buffer.
        {
            //  Remove nul terminator char from return size count.
            --nResultSize;
        }
    }
    else
    {
        //  GetNumberFormat call failed, so just return the number string
        //  unformatted.
        lstrcpyn(szOutStr, szBuffer, nSize);
        nResultSize = lstrlen(szOutStr);
    }

    return nResultSize;
}

///////////////////////////////////////////////////////////////////////////////
//
//    Converts the numeric value of a LARGE_INTEGER to a text string.
//    The string may optionally be formatted to include decimal places
//    and commas according to current user locale settings.
//
// ARGUMENTS:
//    pN
//       Address of the large integer to format.
//
//    See description of Int64ToString for remaining arguments.
//
///////////////////////////////////////////////////////////////////////////////
STDAPI_(int) LargeIntegerToString(LARGE_INTEGER *pN, LPTSTR szOutStr, UINT nSize,
                                  BOOL bFormat, NUMBERFMT *pFmt,
                                  DWORD dwNumFmtFlags)
{
    ASSERT(NULL != pN);
    return Int64ToString(pN->QuadPart, szOutStr, nSize, bFormat, pFmt, dwNumFmtFlags);
}



#define ISSEP(c)   ((c) == TEXT('=')  || (c) == TEXT(','))
#define ISWHITE(c) ((c) == TEXT(' ')  || (c) == TEXT('\t') || (c) == TEXT('\n') || (c) == TEXT('\r'))
#define ISNOISE(c) ((c) == TEXT('"'))
#define EOF     26

#define QUOTE   TEXT('"')
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')
#define EQUAL   TEXT('=')

/*
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. (1 based)
 *             0 is field before a '=' sign
 * szDataStr : pointer to buffer to hold extracted field
 * iBufLen   : size of buffer to receive extracted field.
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 */
STDAPI_(BOOL) ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen)
{
    BOOL  fQuote = FALSE;
    LPCTSTR pszInf = szData;
    LPTSTR ptr;
    int   iLen = 1;

    if (!szData || !szBuf)
        return FALSE;

        /*
        * find the first separator
    */
    while (*pszInf && !ISSEP(*pszInf))
    {
        if (*pszInf == QUOTE)
            fQuote = !fQuote;
        pszInf = CharNext(pszInf);
    }

    if (n == 0 && *pszInf != TEXT('='))
        return FALSE;

    if (n > 0 && *pszInf == TEXT('=') && !fQuote)
        // Change szData to point to first field
        szData = ++pszInf; // Ok for DBCS

                           /*
                           *   locate the nth comma, that is not inside of quotes
    */
    fQuote = FALSE;
    while (n > 1)
    {
        while (*szData)
        {
            if (!fQuote && ISSEP(*szData))
                break;

            if (*szData == QUOTE)
                fQuote = !fQuote;

            szData = CharNext(szData);
        }

        if (!*szData)
        {
            szBuf[0] = 0;      // make szBuf empty
            return FALSE;
        }

        szData = CharNext(szData); // we could do ++ here since we got here
        // after finding comma or equal
        n--;
    }

    /*
    * now copy the field to szBuf
    */
    while (ISWHITE(*szData))
        szData = CharNext(szData); // we could do ++ here since white space can
    // NOT be a lead byte
    fQuote = FALSE;
    ptr = szBuf;      // fill output buffer with this
    while (*szData)
    {
        if (*szData == QUOTE)
        {
            //
            // If we're in quotes already, maybe this
            // is a double quote as in: "He said ""Hello"" to me"
            //
            if (fQuote && *(szData+1) == QUOTE)    // Yep, double-quoting - QUOTE is non-DBCS
            {
                if (iLen < iBufLen)
                {
                    *ptr++ = QUOTE;
                    ++iLen;
                }
                szData++;                   // now skip past 1st quote
            }
            else
                fQuote = !fQuote;
        }
        else if (!fQuote && ISSEP(*szData))
            break;
        else
        {
            if (iLen < iBufLen)
            {
                *ptr++ = *szData;                  // Thank you, Dave
                ++iLen;
            }

            if (IsDBCSLeadByte(*szData) && (iLen < iBufLen))
            {
                *ptr++ = szData[1];
                ++iLen;
            }
        }
        szData = CharNext(szData);
    }
    /*
    * remove trailing spaces
    */
    while (ptr > szBuf)
    {
        ptr = CharPrev(szBuf, ptr);
        if (!ISWHITE(*ptr))
        {
            ptr = CharNext(ptr);
            break;
        }
    }
    *ptr = 0;
    return TRUE;
}


// Sets and clears the "wait" cursor.
// REVIEW UNDONE - wait a specific period of time before actually bothering
// to change the cursor.
// REVIEW UNDONE - support for SetWaitPercent();
//    BOOL bSet   TRUE if you want to change to the wait cursor, FALSE if
//                you want to change it back.
STDAPI_(void) SetAppStartingCursor(HWND hwnd, BOOL bSet)
{
    if (hwnd && IsWindow(hwnd)) 
    {
        DWORD dwTargetProcID;
        HWND hwndOwner;
        while((NULL != (hwndOwner = GetParent(hwnd))) || (NULL != (hwndOwner = GetWindow(hwnd, GW_OWNER)))) 
        {
            hwnd = hwndOwner;
        }

        // SendNotify is documented to only work in-process (and can
        // crash if we pass the pnmhdr across process boundaries on
        // NT, because DLLs aren't all shared in one address space).
        // So, if this SendNotify would go cross-process, blow it off.

        GetWindowThreadProcessId(hwnd, &dwTargetProcID);

        if (GetCurrentProcessId() == dwTargetProcID)
            SendNotify(hwnd, NULL, bSet ? NM_STARTWAIT : NM_ENDWAIT, NULL);
    }
}

#ifdef DEBUG // {

//***   IS_* -- character classification routines
// ENTRY/EXIT
//  ch      TCHAR to be checked
//  return  TRUE if in range, FALSE if not
#define IS_LOWER(ch)    InRange(ch, TEXT('a'), TEXT('z'))
#define IS_UPPER(ch)    InRange(ch, TEXT('A'), TEXT('Z'))
#define IS_ALPHA(ch)    (IS_LOWER(ch) || IS_UPPER(ch))
#define IS_DIGIT(ch)    InRange(ch, TEXT('0'), TEXT('9'))
#define TO_UPPER(ch)    ((ch) - TEXT('a') + TEXT('A'))

//***   BMAP_* -- bitmap routines
// ENTRY/EXIT
//  pBits       ptr to bitmap (array of bytes)
//  iBit        bit# to be manipulated
//  return      various...
// DESCRIPTION
//  BMAP_TEST   check bit #iBit of bitmap pBits
//  BMAP_SET    set   bit #iBit of bitmap pBits
// NOTES
//  warning: no overflow checks
#define BMAP_INDEX(iBit)        ((iBit) / 8)
#define BMAP_MASK(iBit)         (1 << ((iBit) % 8))
#define BMAP_BYTE(pBits, iBit)  (((char *)pBits)[BMAP_INDEX(iBit)])

#define BMAP_TEST(pBits, iBit)  (BMAP_BYTE(pBits, iBit) & BMAP_MASK(iBit))
#define BMAP_SET(pBits, iBit)   (BMAP_BYTE(pBits, iBit) |= BMAP_MASK(iBit))

//***   DBGetMnemonic -- get menu mnemonic
// ENTRY/EXIT
//  return  mnemonic if found, o.w. 0
// NOTES
//  we handle and skip escaped-& ('&&')
//
TCHAR DBGetMnemonic(LPTSTR pszName)
{
    for (; *pszName != 0; pszName = CharNext(pszName)) 
    {
        if (*pszName == TEXT('&')) 
        {
            pszName = CharNext(pszName);    // skip '&'
            if (*pszName != TEXT('&'))
                return *pszName;
            ASSERT(0);  // untested! (but should work...)
            pszName = CharNext(pszName);    // skip 2nd '&'
        }
    }
    // this one happens a lot w/ weird things like "", "..", "..."
    return 0;
}

//***   DBCheckMenu -- check menu for 'style' conformance
// DESCRIPTION
//  currently we just check for mnemonic collisions (and only a-z,0-9)
void DBCheckMenu(HMENU hmChk)
{
    long bfAlpha = 0;
    long bfDigit = 0;
    long *pbfMne;
    int nItem;
    int iMne;
    TCHAR chMne;
    TCHAR szName[256]; // 256 characters of the menu name should be plenty...
    MENUITEMINFO miiChk;

    if (!DM_STRICT)
        return;

    for (nItem = GetMenuItemCount(hmChk) - 1; nItem >= 0; nItem--) 
    {
        miiChk.cbSize = sizeof(MENUITEMINFO);
        miiChk.fMask = MIIM_TYPE|MIIM_DATA;
        // We need to reset this every time through the loop in case
        // menus DON'T have IDs
        miiChk.fType = MFT_STRING;
        miiChk.dwTypeData = szName;
        szName[0] = 0;
        miiChk.dwItemData = 0;
        miiChk.cch        = ARRAYSIZE(szName);

        if (!GetMenuItemInfo(hmChk, nItem, TRUE, &miiChk)) 
        {
            TraceMsg(TF_WARNING, "dbcm: fail iMenu=%d (skip)", nItem);
            continue;
        }

        if (! (miiChk.fType & MFT_STRING)) 
        {
            // skip separators, etc.
            continue;
        }

        chMne = DBGetMnemonic(szName);
        if (chMne == 0 || ! (IS_ALPHA(chMne) || IS_DIGIT(chMne))) 
        {
            // this one actually happens a lot w/ chMne==0
            if (DM_STRICT2)
                TraceMsg(TF_WARNING, "dbcm: skip iMenu=%d mne=%c", nItem, chMne ? chMne : TEXT('0'));
            continue;
        }

        if (IS_LOWER(chMne)) 
        {
            chMne = TO_UPPER(chMne);
        }

        if (IS_UPPER(chMne)) 
        {
            iMne = chMne - TEXT('A');
            pbfMne = &bfAlpha;
        }
        else if (IS_DIGIT(chMne)) 
        {
            iMne = chMne - TEXT('0');
            pbfMne = &bfDigit;
        }
        else 
        {
            ASSERT(0);
            continue;
        }

        if (BMAP_TEST(pbfMne, iMne)) 
        {
            TraceMsg(TF_ERROR, "dbcm: mnemonic collision hm=%x iM=%d szMen=%s",
                hmChk, nItem, szName);
        }

        BMAP_SET(pbfMne, iMne);
    }

    return;
}

#else // }{
#define DBCheckMenu(hmChk)  0
#endif // }

// Copy a menu onto the beginning or end of another menu
// Adds uIDAdjust to each menu ID (pass in 0 for no adjustment)
// Will not add any item whose adjusted ID is greater than uMaxIDAdjust
// (pass in 0xffff to allow everything)
// Returns one more than the maximum adjusted ID that is used
//

UINT WINAPI Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags)
{
    int nItem;
    HMENU hmSubMenu;
    BOOL bAlreadySeparated;
    MENUITEMINFO miiSrc;
    TCHAR szName[256];
    UINT uTemp, uIDMax = uIDAdjust;

    if (!hmDst || !hmSrc)
    {
        goto MM_Exit;
    }

    nItem = GetMenuItemCount(hmDst);
    if (uInsert >= (UINT)nItem)
    {
        uInsert = (UINT)nItem;
        bAlreadySeparated = TRUE;
    }
    else
    {
        bAlreadySeparated = _SHIsMenuSeparator(hmDst, uInsert);
    }

    if ((uFlags & MM_ADDSEPARATOR) && !bAlreadySeparated)
    {
        // Add a separator between the menus
        InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        bAlreadySeparated = TRUE;
    }


    // Go through the menu items and clone them
    for (nItem = GetMenuItemCount(hmSrc) - 1; nItem >= 0; nItem--)
    {
        miiSrc.cbSize = sizeof(MENUITEMINFO);
        miiSrc.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;
        // We need to reset this every time through the loop in case
        // menus DON'T have IDs
        miiSrc.fType = MFT_STRING;
        miiSrc.dwTypeData = szName;
        miiSrc.dwItemData = 0;
        miiSrc.cch        = ARRAYSIZE(szName);

        if (!GetMenuItemInfo(hmSrc, nItem, TRUE, &miiSrc))
        {
            continue;
        }

        // If it's a separator, then add it.  If the separator has a
        // submenu, then the caller is smoking crash and needs their butt kicked.
        if ((miiSrc.fType & MFT_SEPARATOR) && EVAL(!miiSrc.hSubMenu))
        {
            // This is a separator; don't put two of them in a row
            if (bAlreadySeparated && miiSrc.wID == -1 && !(uFlags & MM_DONTREMOVESEPS))
            {
                continue;
            }

            bAlreadySeparated = TRUE;
        }
        else if (miiSrc.hSubMenu)
        {
            if (uFlags & MM_SUBMENUSHAVEIDS)
            {
                // Adjust the ID and check it
                miiSrc.wID += uIDAdjust;
                if (miiSrc.wID > uIDAdjustMax)
                {
                    continue;
                }

                if (uIDMax <= miiSrc.wID)
                {
                    uIDMax = miiSrc.wID + 1;
                }
            }
            else
            {
                // Don't set IDs for submenus that didn't have
                // them already
                miiSrc.fMask &= ~MIIM_ID;
            }

            hmSubMenu = miiSrc.hSubMenu;
            miiSrc.hSubMenu = CreatePopupMenu();
            if (!miiSrc.hSubMenu)
            {
                goto MM_Exit;
            }

            uTemp = Shell_MergeMenus(miiSrc.hSubMenu, hmSubMenu, 0, uIDAdjust,
                uIDAdjustMax, uFlags&MM_SUBMENUSHAVEIDS);
            if (uIDMax <= uTemp)
            {
                uIDMax = uTemp;
            }

            bAlreadySeparated = FALSE;
        }
        else
        {
            // Adjust the ID and check it
            miiSrc.wID += uIDAdjust;
            if (miiSrc.wID > uIDAdjustMax)
            {
                continue;
            }

            if (uIDMax <= miiSrc.wID)
            {
                uIDMax = miiSrc.wID + 1;
            }

            bAlreadySeparated = FALSE;
        }

        if (!InsertMenuItem(hmDst, uInsert, TRUE, &miiSrc))
        {
            goto MM_Exit;
        }
    }

    // Ensure the correct number of separators at the beginning of the
    // inserted menu items
    if (uInsert == 0)
    {
        if (bAlreadySeparated && !(uFlags & MM_DONTREMOVESEPS))
        {
            DeleteMenu(hmDst, uInsert, MF_BYPOSITION);
        }
    }
    else
    {
        if (_SHIsMenuSeparator(hmDst, uInsert-1))
        {
            if (bAlreadySeparated && !(uFlags & MM_DONTREMOVESEPS))
            {
                DeleteMenu(hmDst, uInsert, MF_BYPOSITION);
            }
        }
        else
        {
            if ((uFlags & MM_ADDSEPARATOR) && !bAlreadySeparated)
            {
                // Add a separator between the menus
                InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            }
        }
    }

MM_Exit:
#ifdef DEBUG
    DBCheckMenu(hmDst);
#endif
    return uIDMax;
}

#define REG_WINLOGON_KEY     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define REG_PREV_OS_VERSION  TEXT("PrevOsVersion")
#define REG_VAL_PLATFORM_ID  TEXT("PlatformId")
#define REG_VAL_MINORVERSION TEXT("MinorVersion")

//
// The following function is called, when we detect that IE4 was installed in this machine earlier.
// We want to see if that IE4 was there because of Win98 (if so, the ActiveDesktop is OFF by default)
//

BOOL    WasPrevOsWin98()
{
    BOOL    fWin98;
    HKEY    hkeyWinlogon;

    // 99/10/26 Millennium #94983 vtan: When upgrading Win98 to Millennium this
    // will incorrectly detect the system as NT4/IE4 which has Active Desktop
    // set to default to on. Because Windows 2000 setup when upgrading from
    // Windows 98 writes out the previous OS key and Windows Millennium setup
    // when upgrading from Windows 98 does NOT and some Windows NT specific
    // keys and values have never been present on a Windows 98 system it
    // should be adequate to check their presence to determine whether this is
    // an NT4/IE4 upgrade or a Windows 98 upgrade to Millennium.

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_WINLOGON_KEY, 0, KEY_READ, &hkeyWinlogon))
    {
        HKEY    hk;
        DWORD   dwType;
        DWORD   dwPlatformId, dwMinorVersion;
        DWORD   dwDataLength;

        // 99/04/09 #319056 vtan: We'll assume that previous OS is known on
        // a Win9x upgrade from keys written by setup. If no keys are present
        // we'll assume NT4 upgrade where with IE4 integrated shell the default
        // was ON.

        fWin98 = FALSE;

        // See it the prev OS info is available. Caution: This info gets written in registry by
        // NT setup at the far end of the setup process (after all our DLLs are already registered).
        // So, we use extra care here to see of that key and values really exist or not!
        if (RegOpenKeyEx(hkeyWinlogon, REG_PREV_OS_VERSION, 0, KEY_READ, &hk) == ERROR_SUCCESS)
        {
            dwType = 0;
            dwDataLength = sizeof(dwPlatformId);
            if (RegQueryValueEx(hk, REG_VAL_PLATFORM_ID, NULL, &dwType, (LPBYTE)(&dwPlatformId), &dwDataLength) == ERROR_SUCCESS)
            {
                dwType = 0;
                dwDataLength = sizeof(dwMinorVersion);
                if (RegQueryValueEx(hk, REG_VAL_MINORVERSION, NULL, &dwType, (LPBYTE)(&dwMinorVersion), &dwDataLength) == ERROR_SUCCESS)
                {
                    if ((dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (dwMinorVersion > 0))
                        fWin98 = TRUE;   //This is Win98 for sure!
                    else
                        fWin98 = FALSE;  //The prev OS is NOT win98 for sure!
                }
            }
            RegCloseKey(hk);
        }
        RegCloseKey(hkeyWinlogon);
    }
    else
    {
        fWin98 = TRUE;
    }

    return fWin98;
}


void _SetIE4DefaultShellState(SHELLSTATE *pss)
{
    pss->fDoubleClickInWebView = TRUE;
    pss->fShowInfoTip = TRUE;
    pss->fWebView = TRUE;
    pss->fDesktopHTML = FALSE;

    // IE4 defaulted to fDesktopHTML on, and on NT5 upgrade we don't
    // want to override that (and probably not on Win98 upgrade, but
    // it's too late for that).  To determine this here, check a
    // uniquely IE4 reg-key.  (Note, this will catch the case if the
    // user *modified* their desktop.  If they just went with the
    // defaults, this key won't be there and we'll remove AD.)
    TCHAR   szDeskcomp[MAX_PATH];
    DWORD   dwType = 0, dwDeskHtmlVersion = 0;
    DWORD   dwDataLength = sizeof(dwDeskHtmlVersion);

    GetRegLocation(szDeskcomp, SIZECHARS(szDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

    SHGetValue(HKEY_CURRENT_USER, szDeskcomp, REG_VAL_COMP_VERSION, &dwType, (LPBYTE)(&dwDeskHtmlVersion), &dwDataLength);

    // 99/05/03 #292269: Notice the difference in the order of the
    // bits. The current structure (IE4 and later) has fShowSysFiles
    // between fNoConfirmRecycle and fShowCompColor. Move the bit
    // based on the size of the struct and reset fShowSysFiles to TRUE.

    // WIN95 SHELLSTATE struct bit fields
    //  BOOL fShowAllObjects : 1;
    //  BOOL fShowExtensions : 1;
    //  BOOL fNoConfirmRecycle : 1;
    //  BOOL fShowCompColor  : 1;
    //  UINT fRestFlags : 13;

    // IE4 SHELLSTATE struct bit fields
    //  BOOL fShowAllObjects : 1;
    //  BOOL fShowExtensions : 1;
    //  BOOL fNoConfirmRecycle : 1;
    //  BOOL fShowSysFiles : 1;
    //  BOOL fShowCompColor : 1;
    //  BOOL fDoubleClickInWebView : 1;
    //  BOOL fDesktopHTML : 1;
    //  BOOL fWin95Classic : 1;
    //  BOOL fDontPrettyPath : 1;
    //  BOOL fShowAttribCol : 1;
    //  BOOL fMapNetDrvBtn : 1;
    //  BOOL fShowInfoTip : 1;
    //  BOOL fHideIcons : 1;
    //  BOOL fWebView : 1;
    //  BOOL fFilter : 1;
    //  BOOL fShowSuperHidden : 1;

    // Millennium SHELLSTATE struct bit fields
    //  BOOL fNoNetCrawling : 1;

    // Whistler SHELLSTATE struct bit fields
    //  BOOL fStartPanelOn : 1;
    //  BOOL fShowStartPage : 1;

    if ((g_pShellState->cbSize == REGSHELLSTATE_SIZE_WIN95) || (g_pShellState->cbSize == REGSHELLSTATE_SIZE_NT4))
    {
        pss->fShowCompColor = TRUE;
        pss->fShowSysFiles = TRUE;
    }
    if (dwDeskHtmlVersion == IE4_DESKHTML_VERSION)
        pss->fDesktopHTML = !WasPrevOsWin98();   //This is an upgrade from IE4; but, the registry is not updated yet.
    else
    {
        if (dwDeskHtmlVersion > IE4_DESKHTML_VERSION)
        {
            DWORD   dwOldHtmlVersion = 0;
            dwDataLength = sizeof(dwOldHtmlVersion);
            // This is NT5 or above! Check to see if we have "UpgradedFrom" value.
            // NOTE: The "UpgradedFrom" value is at "...\Desktop" and NOT at "..\Desktop\Components"
            // This is because the "Components" key gets destroyed very often.
            SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP, REG_VAL_COMP_UPGRADED_FROM, &dwType, (LPBYTE)&dwOldHtmlVersion, &dwDataLength);

            // 99/05/17 #333384 vtan: Check for IE5 as an old version too. The current version
            // is now 0x0110 (from 0x010F) and this causes the HKCU\Software\Microsoft\Internet
            // Explorer\Desktop\UpgradedFrom value to get created in CDeskHtmlProp_RegUnReg().
            // This is executed by IE4UINIT.EXE as well as REGSVR32.EXE with the "/U" parameter
            // so this field should be present at the time this executes. Note this only
            // executes the once on upgrade because the ShellState will get written.

            if ((dwOldHtmlVersion == IE4_DESKHTML_VERSION) || (dwOldHtmlVersion == IE5_DESKHTML_VERSION))
                pss->fDesktopHTML = !WasPrevOsWin98();   //This is an upgrade from IE4;
        }
    }
}


//
// This function checks if the caller is running in an explorer process.
//
STDAPI_(BOOL) IsProcessAnExplorer()
{
    return BOOLFROMPTR(GetModuleHandle(TEXT("EXPLORER.EXE")));
}


//
// Is this the main shell process? (eg the one that owns the desktop window)
//
// NOTE: if the desktop window has not been created, we assume that this is NOT the
//       main shell process and return FALSE;
//
STDAPI_(BOOL) IsMainShellProcess()
{
    static int s_fIsMainShellProcess = -1;

    if (s_fIsMainShellProcess == -1)
    {
        HWND hwndDesktop = GetShellWindow();

        if (hwndDesktop)
        {
            s_fIsMainShellProcess = (int)IsWindowInProcess(hwndDesktop);

            if ((s_fIsMainShellProcess != 0) && !IsProcessAnExplorer())
            {
                TraceMsg(TF_WARNING, "IsMainShellProcess: the main shell process (owner of the desktop) is NOT an explorer window?!?");
            }
        }
        else
        {
#ifdef FULL_DEBUG
            // only spew on FULL_DEBUG to cut down on chattyness in normal debug builds
            TraceMsg(TF_WARNING, "IsMainShellProcess: hwndDesktop does not exist, assuming we are NOT the main shell process");
#endif // FULL_DEBUG

            return FALSE;
        }
    }

    return s_fIsMainShellProcess ? TRUE : FALSE;
}

BOOL _ShouldStartPanelBeEnabledByDefault()
{
    DWORD dwDefaultPanelOff;
    DWORD cbSize;

    cbSize = sizeof(dwDefaultPanelOff);
    // We respect a regkey that can be set by an unattend file to default to the classic start menu
    if ((SHRegGetUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartMenu\\StartPanel"),
                         TEXT("DefaultStartPanelOff"),
                         NULL,
                         &dwDefaultPanelOff,
                         &cbSize,
                         FALSE,
                         NULL,
                         0) == ERROR_SUCCESS) && dwDefaultPanelOff)
    {
        return FALSE;
    }
                   
    // Start Panel needs to be enabled by default only for the "Personal" and "Professional" versions.
    return (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL));
}


DWORD GetCurrentSessionID(void)
{
    DWORD dwProcessID = (DWORD) -1;
    ProcessIdToSessionId(GetCurrentProcessId(), &dwProcessID);

    return dwProcessID;
}

typedef struct
{
    LPCWSTR pszRegKey;
    LPCWSTR pszRegValue;
} TSPERFFLAG_ITEM;

const TSPERFFLAG_ITEM s_TSPerfFlagItems[] =
{
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote\\%d", L"ActiveDesktop"},              // TSPerFlag_NoADWallpaper
    {L"Control Panel\\Desktop\\Remote\\%d", L"Wallpaper"},                                                  // TSPerFlag_NoWallpaper
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager\\Remote\\%d", L"ThemeActive"},            // TSPerFlag_NoVisualStyles
    {L"Control Panel\\Desktop\\Remote\\%d", L"DragFullWindows"},                                            // TSPerFlag_NoWindowDrag
    {L"Control Panel\\Desktop\\Remote\\%d", L"SmoothScroll"},                                               // TSPerFlag_NoAnimation
};


BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag)
{
    BOOL fIsTSFlagEnabled = FALSE;

    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        TCHAR szTemp[MAX_PATH];
        DWORD dwType;
        DWORD cbSize = sizeof(szTemp);
        TCHAR szRegKey[MAX_PATH];

        wnsprintf(szRegKey, ARRAYSIZE(szRegKey), s_TSPerfFlagItems[eTSFlag].pszRegKey, GetCurrentSessionID());

        if (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szRegKey, s_TSPerfFlagItems[eTSFlag].pszRegValue, &dwType, (void *)szTemp, &cbSize))
        {
            fIsTSFlagEnabled = TRUE;
        }
    }

    return fIsTSFlagEnabled;
}


BOOL PolicyNoActiveDesktop(void)
{
    BOOL fNoActiveDesktop = SHRestricted(REST_NOACTIVEDESKTOP);

    if (!fNoActiveDesktop)
    {
        fNoActiveDesktop = (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper) || IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper));
    }

    return fNoActiveDesktop;
}


BOOL _RefreshSettingsFromReg()
{
    BOOL fNeedToUpdateReg = FALSE;
    static REGSHELLSTATE ShellStateBuf = {0,};
    DWORD cbSize;

    ASSERTCRITICAL;

    if (g_pShellState)
    {
        //  reuse the buffer if possible
        cbSize = g_pShellState->cbSize;
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("ShellState"), NULL, g_pShellState, &cbSize)))
        {
            if (&ShellStateBuf != g_pShellState)
            {
                LocalFree(g_pShellState);
            }
            g_pShellState = NULL;
        }
    }

    if (!g_pShellState)
    {
        if (FAILED(SKAllocValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("ShellState"), NULL, (void **)&g_pShellState, NULL)))
        {
            g_pShellState = &ShellStateBuf;
        }
        else
        {
            cbSize = LocalSize(g_pShellState);

            // if we read out an smaller size from the registry, then copy it into our stack buffer and use that.
            // we need a struct at least as big as the current size
            if (cbSize <= sizeof(ShellStateBuf))
            {
                CopyMemory(&ShellStateBuf, g_pShellState, cbSize);
                LocalFree(g_pShellState);
                g_pShellState = &ShellStateBuf;

                // g_pShellState->cbSize will be updated in the below
                fNeedToUpdateReg = TRUE;
            }
        }
    }

    // Upgrade what we read out of the registry

    if ((g_pShellState->cbSize == REGSHELLSTATE_SIZE_WIN95) ||
        (g_pShellState->cbSize == REGSHELLSTATE_SIZE_NT4))
    {
        // Upgrade Win95 bits.  Too bad our defaults weren't
        // FALSE for everything, because whacking these bits
        // breaks roaming.  Of course, if you ever roam to
        // a Win95 machine, it whacks all bits to zero...

        _SetIE4DefaultShellState(&g_pShellState->ss);

        //New bits added for Whistler
        //g_pShellState->ss.fNoNetCrawling = FALSE;
        g_pShellState->ss.fStartPanelOn = _ShouldStartPanelBeEnabledByDefault();
        //g_pShellState->ss.fShowStartPage = FALSE;           // Off by default for now!

        g_pShellState->ss.version = SHELLSTATEVERSION;
        g_pShellState->cbSize = sizeof(REGSHELLSTATE);

        fNeedToUpdateReg = TRUE;
    }
    else if (g_pShellState->cbSize >= REGSHELLSTATE_SIZE_IE4)
    {
        // Since the version field was new to IE4, this should be true:
        ASSERT(g_pShellState->ss.version >= SHELLSTATEVERSION_IE4);

        if (g_pShellState->ss.version < SHELLSTATEVERSION)
        {
            //Since the version # read from the registry is old!
            fNeedToUpdateReg = TRUE;
        }

        // Upgrade to current version here - make sure we don't
        // stomp on bits unnecessarily, as that will break roaming...
        if (g_pShellState->ss.version == SHELLSTATEVERSION_IE4)
        {
            // IE4.0 shipped with verion = 9; The SHELLSTATEVERSION was changed to 10 later.
            // But the structure size or defaults have not changed since IE4.0 shipped. So,
            // the following code treats version 9 as the same as version 10. If we do not do this,
            // the IE4.0 users who upgrade to Memphis or IE4.01 will lose all their settings
            // (Bug #62389).
            g_pShellState->ss.version = SHELLSTATEVERSION_WIN2K;
        }

        // Since this could be an upgrade from Win98, the fWebView bit, which was not used in win98
        // could be zero; We must set the default value of fWebView = ON here and later in
        // _RefreshSettings() functions we read from Advanced\WebView value and reset it (if it is there).
        // If Advanced\WebView is not there, then this must be an upgrade from Win98 and WebView should be
        // turned ON.
        g_pShellState->ss.fWebView = TRUE;

        // Upgrade from Win2K to Millennium/Whistler installs
        if (g_pShellState->ss.version == SHELLSTATEVERSION_WIN2K)
        {
            //g_pShellState->ss.fNoNetCrawling = FALSE;
            //g_pShellState->ss.fShowStartPage = FALSE;
            g_pShellState->ss.version = 11;
        }

        if (g_pShellState->ss.version < 13)
        {
            //This is the new bit added between versions 11 and 12. The default changed for 13.
            g_pShellState->ss.fStartPanelOn = _ShouldStartPanelBeEnabledByDefault();//Turn it ON by default only for "Personal" or "Professional".
            g_pShellState->ss.version = 13;
        }
        
        // Ensure that the CB reflects the current size of the structure
        if (fNeedToUpdateReg)
        {
            g_pShellState->cbSize = sizeof(REGSHELLSTATE);
        }

        // Must be saved state from this or an uplevel platform.  Don't touch the bits.
        ASSERT(g_pShellState->ss.version >= SHELLSTATEVERSION);
    }
    else
    {
        // We could not read anything from reg. Initialize all fields.
        // 0 should be the default for *most* everything
        g_pShellState->cbSize = sizeof(REGSHELLSTATE);

        g_pShellState->ss.iSortDirection = 1;

        _SetIE4DefaultShellState(&g_pShellState->ss);

        // New bits added for Whistler.
        // g_pShellState->ss.fNoNetCrawling = FALSE;
        g_pShellState->ss.fStartPanelOn = _ShouldStartPanelBeEnabledByDefault(); //Turn it ON by default only for "Personal".
        //g_pShellState->ss.fShowStartPage = FALSE;
        
        // New defaults for Whistler.
        g_pShellState->ss.fShowCompColor = TRUE;

        g_pShellState->ss.version = SHELLSTATEVERSION;

        fNeedToUpdateReg = TRUE;
    }

    // Apply restrictions
    //Note: This restriction supercedes the NOACTIVEDESKTOP!
    if (SHRestricted(REST_FORCEACTIVEDESKTOPON))
    {
        g_pShellState->ss.fDesktopHTML = TRUE;
    }
    else
    {
        if (PolicyNoActiveDesktop())
        {
            //Note this restriction is superceded by FORCEACTIVEDESKTOPON!
            g_pShellState->ss.fDesktopHTML = FALSE;
        }
    }

    if (SHRestricted(REST_NOWEBVIEW))
    {
        g_pShellState->ss.fWebView = FALSE;
    }

    // ClassicShell restriction makes all web view off and forces even more win95 behaviours
    // so we still need to fDoubleClickInWebView off.
    if (SHRestricted(REST_CLASSICSHELL))
    {
        g_pShellState->ss.fWin95Classic = TRUE;
        g_pShellState->ss.fDoubleClickInWebView = FALSE;
        g_pShellState->ss.fWebView = FALSE;
        g_pShellState->ss.fDesktopHTML = FALSE;
    }

    if (SHRestricted(REST_DONTSHOWSUPERHIDDEN))
    {
        g_pShellState->ss.fShowSuperHidden = FALSE;
    }

    if (SHRestricted(REST_SEPARATEDESKTOPPROCESS))
    {
        g_pShellState->ss.fSepProcess = TRUE;
    }

    if (SHRestricted(REST_NONETCRAWL))
    {
        g_pShellState->ss.fNoNetCrawling = FALSE;
    }

    if (SHRestricted(REST_NOSTARTPANEL))
    {
        g_pShellState->ss.fStartPanelOn = FALSE;
    }

    if (SHRestricted(REST_NOSTARTPAGE))
    {
        g_pShellState->ss.fShowStartPage = FALSE;
    }
    
    if (fNeedToUpdateReg)
    {
        // There is a need to update ShellState in registry. Do it only if current procees is
        // an Explorer process.
        //
        // Because, only when the explorer process is running, we can be
        // assured that the NT5 setup is complete and all the PrevOsVersion info is available and
        // _SetIE4DefaultShellState() and WasPrevOsWin98() etc, would have set the proper value
        // for fDesktopHHTML. If we don't do the following check, we will end-up updating the
        // registry the first time someone (like setup) called SHGetSettings() and that would be
        // too early to update the ShellState since we don't have all the info needed to decide if
        // fDesktopHTML needs to be ON or OFF based on previous OS, previous IE version etc.,
        fNeedToUpdateReg = IsProcessAnExplorer();
    }

    return (fNeedToUpdateReg);
}

EXTERN_C HANDLE g_hSettings = NULL;     //  global shell settings counter
LONG g_lProcessSettingsCount = -1;      //  current process's count
const GUID GUID_ShellSettingsChanged = { 0x7cb834f0, 0x527b, 0x11d2, {0x9d, 0x1f, 0x00, 0x00, 0xf8, 0x05, 0xca, 0x57}}; // 7cb834f0-527b-11d2-9d1f-0000f805ca57

HANDLE _GetSettingsCounter()
{
    return SHGetCachedGlobalCounter(&g_hSettings, &GUID_ShellSettingsChanged);
}

BOOL _QuerySettingsChanged(void)
{
    long lGlobalCount = SHGlobalCounterGetValue(_GetSettingsCounter());
    if (g_lProcessSettingsCount != lGlobalCount)
    {
        g_lProcessSettingsCount = lGlobalCount;
        return TRUE;
    }
    return FALSE;
}

//
//  SHRefreshSettings now just invalidates the settings cache.
//  so that the next time that SHGetSetSettings() is called
//  it will reread all the settings
//
STDAPI_(void) SHRefreshSettings(void)
{
    SHGlobalCounterIncrement(_GetSettingsCounter());
}

// this needs to get called periodically to re-fetch the settings from the
// registry as we no longer store them in a share data segment
BOOL _RefreshSettings(void)
{
    BOOL    fNeedToUpdateReg = FALSE;

    ENTERCRITICAL;

    fNeedToUpdateReg = _RefreshSettingsFromReg();

    // get the advanced options.
    // they are stored as individual values so that policy editor can change it.
    HKEY hkeyAdv = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("Advanced"), FALSE);
    if (hkeyAdv)
    {
        DWORD dwData;
        DWORD dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("Hidden"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            // Map the obsolete value of 0 to 2.
            if (dwData == 0)
                dwData = 2;
            g_pShellState->ss.fShowAllObjects = (dwData == 1);
            g_pShellState->ss.fShowSysFiles = (dwData == 2);
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("ShowCompColor"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowCompColor = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("HideFileExt"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowExtensions = (BOOL)dwData ? FALSE : TRUE;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("DontPrettyPath"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fDontPrettyPath = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("ShowInfoTip"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowInfoTip = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("HideIcons"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fHideIcons = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("MapNetDrvBtn"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fMapNetDrvBtn = (BOOL)dwData;
        }

        dwSize = sizeof(dwData);

        if (!SHRestricted(REST_CLASSICSHELL))
        {
            if (SHQueryValueEx(hkeyAdv, TEXT("WebView"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
            {
                g_pShellState->ss.fWebView = (BOOL)dwData;
            }
            else
            {
                //If Advanced/WebView value is not there, then this could be an upgrade from win98/IE4
                // where we stored this info in DEFFOLDERSETTINGS in Explorer\Streams\Settings.
                // See if that info is there; If so, use it!
                DEFFOLDERSETTINGS dfs;
                DWORD dwType, cbData = sizeof(dfs);
                if (SUCCEEDED(SKGetValue(SHELLKEY_HKCU_EXPLORER, TEXT("Streams"), TEXT("Settings"), &dwType, &dfs, &cbData))
                && (dwType == REG_BINARY))
                {
                    //DefFolderSettings is there; Check if this is the correct struct.
                    //Note:In Win98/IE4, we wrongly initialized dwStructVersion to zero.
                    if ((cbData == sizeof(dfs)) &&
                        ((dfs.dwStructVersion == 0) || (dfs.dwStructVersion == DFS_NASH_VER)))
                    {
                        g_pShellState->ss.fWebView = ((dfs.bUseVID) && (dfs.vid == VID_WebView));
                    }
                }
            }
        }

        dwSize = sizeof(dwData);

        if (SHQueryValueEx(hkeyAdv, TEXT("Filter"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fFilter = (BOOL)dwData;
        }

        if (SHQueryValueEx(hkeyAdv, TEXT("ShowSuperHidden"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fShowSuperHidden = (BOOL)dwData;
        }

        if (SHQueryValueEx(hkeyAdv, TEXT("SeparateProcess"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fSepProcess = (BOOL)dwData;
        }

        if (SHQueryValueEx(hkeyAdv, TEXT("NoNetCrawling"), NULL, NULL, (LPBYTE)&dwData, &dwSize) == ERROR_SUCCESS)
        {
            g_pShellState->ss.fNoNetCrawling = (BOOL)dwData;
        }

        RegCloseKey(hkeyAdv);
    }
    else
    {
        // Hey, if the advanced key is not there, this must be a Win9x upgrade...
        // Fortunately the SHELLSTATE defaults and the not-in-registry defaults
        // are the same, so we don't need any auto-propogate code here.
    }

    //  this process is now in sync
    g_lProcessSettingsCount = SHGlobalCounterGetValue(_GetSettingsCounter());

    LEAVECRITICAL;

    return fNeedToUpdateReg;
}

// This function moves SHELLSTATE settings into the Advanced Settings
// portion of the registry.  If no SHELLSTATE is passed in, it uses
// the current state stored in the registry.
//
void Install_AdvancedShellSettings(SHELLSTATE * pss)
{
    DWORD dw;
    BOOL fCrit = FALSE;

    if (NULL == pss)
    {
        // Get the current values in the registry or the default values
        // as determined by the following function.
        //
        // we'll be partying on g_pShellState, so grab the critical section here
        //
        ENTERCRITICALNOASSERT;
        fCrit = TRUE;

        // Win95 and NT5 kept the SHELLSTATE bits in the registry up to date,
        // but apparently IE4 only kept the ADVANCED section up to date.
        // It would be nice to call _RefreshSettingsFromReg(); here, but
        // that won't keep IE4 happy.  Call _RefreshSettings() instead.
        _RefreshSettings();

        pss = &g_pShellState->ss;
    }

    HKEY hkeyAdv = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("Advanced"), TRUE);
    if (hkeyAdv)
    {
        DWORD dwData;

        dw = sizeof(dwData);
        dwData = (DWORD)(pss->fShowAllObjects ? 1 : 2);
        RegSetValueEx(hkeyAdv, TEXT("Hidden") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowCompColor ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("ShowCompColor") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowExtensions ? 0 : 1;
        RegSetValueEx(hkeyAdv, TEXT("HideFileExt") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fDontPrettyPath ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("DontPrettyPath") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowInfoTip ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("ShowInfoTip") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fHideIcons ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("HideIcons") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fMapNetDrvBtn ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("MapNetDrvBtn") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fWebView ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("WebView") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fFilter ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("Filter") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fShowSuperHidden ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("SuperHidden") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        dwData = (DWORD)pss->fSepProcess ? 1 : 0;
        RegSetValueEx(hkeyAdv, TEXT("SeparateProcess") ,0, REG_DWORD, (LPBYTE)&dwData, dw);

        RegCloseKey(hkeyAdv);
    }

    if (fCrit)
    {
        LEAVECRITICALNOASSERT;
    }
}

STDAPI_(void) SHGetSetSettings(LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet)
{
    //Does the ShellState in Reg is old? If so, we need to update it!
    BOOL    fUpdateShellStateInReg = FALSE;  //Assume, no need to update it!

    if (!lpss && !dwMask && bSet)
    {
        // this was a special way to call
        // SHRefreshSettings() from an external module.
        // special case it out now.
        SHRefreshSettings();
        return;
    }

    if (!g_pShellState || _QuerySettingsChanged())
    {
        // if it hasn't been init'd or we are setting the values. We must do it
        // on the save case because it may have changed in the registry since
        // we last fetched it..
        fUpdateShellStateInReg = _RefreshSettings();
    }
    else if (g_pShellState)
    {
        // _RefreshSettingsFromReg sets g_pShellState to non null value
        // and then starts stuffing values into it and all within our
        // glorious critsec, but unless we check for the critsec here,
        // we will start partying on g_pShellState before it is finished
        // loading.
        ENTERCRITICAL;
        LEAVECRITICAL;
    }

    BOOL fSave = FALSE;
    BOOL fSaveAdvanced = FALSE;

    if (bSet)
    {
        if ((dwMask & SSF_SHOWALLOBJECTS) && (g_pShellState->ss.fShowAllObjects != lpss->fShowAllObjects))
        {
            g_pShellState->ss.fShowAllObjects = lpss->fShowAllObjects;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWSYSFILES) && (g_pShellState->ss.fShowSysFiles != lpss->fShowSysFiles))
        {
            g_pShellState->ss.fShowSysFiles = lpss->fShowSysFiles;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWEXTENSIONS) && (g_pShellState->ss.fShowExtensions != lpss->fShowExtensions))
        {
            g_pShellState->ss.fShowExtensions = lpss->fShowExtensions;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWCOMPCOLOR) && (g_pShellState->ss.fShowCompColor != lpss->fShowCompColor))
        {
            g_pShellState->ss.fShowCompColor = lpss->fShowCompColor;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_NOCONFIRMRECYCLE) && (g_pShellState->ss.fNoConfirmRecycle != lpss->fNoConfirmRecycle))
        {
            if (!SHRestricted(REST_BITBUCKCONFIRMDELETE))
            {
                g_pShellState->ss.fNoConfirmRecycle = lpss->fNoConfirmRecycle;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_DOUBLECLICKINWEBVIEW) && (g_pShellState->ss.fDoubleClickInWebView != lpss->fDoubleClickInWebView))
        {
            if (!SHRestricted(REST_CLASSICSHELL))
            {
                g_pShellState->ss.fDoubleClickInWebView = lpss->fDoubleClickInWebView;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_DESKTOPHTML) && (g_pShellState->ss.fDesktopHTML != lpss->fDesktopHTML))
        {
            if (!SHRestricted(REST_NOACTIVEDESKTOP) && !SHRestricted(REST_CLASSICSHELL)
                                                    && !SHRestricted(REST_FORCEACTIVEDESKTOPON))
            {
                g_pShellState->ss.fDesktopHTML = lpss->fDesktopHTML;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_WIN95CLASSIC) && (g_pShellState->ss.fWin95Classic != lpss->fWin95Classic))
        {
            if (!SHRestricted(REST_CLASSICSHELL))
            {
                g_pShellState->ss.fWin95Classic = lpss->fWin95Classic;
                fSave = TRUE;
            }
        }

        if ((dwMask & SSF_WEBVIEW) && (g_pShellState->ss.fWebView != lpss->fWebView))
        {
            if (!SHRestricted(REST_NOWEBVIEW) && !SHRestricted(REST_CLASSICSHELL))
            {
                g_pShellState->ss.fWebView = lpss->fWebView;
                fSaveAdvanced = TRUE;
            }
        }

        if ((dwMask & SSF_DONTPRETTYPATH) && (g_pShellState->ss.fDontPrettyPath != lpss->fDontPrettyPath))
        {
            g_pShellState->ss.fDontPrettyPath = lpss->fDontPrettyPath;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWINFOTIP) && (g_pShellState->ss.fShowInfoTip != lpss->fShowInfoTip))
        {
            g_pShellState->ss.fShowInfoTip = lpss->fShowInfoTip;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_HIDEICONS) && (g_pShellState->ss.fHideIcons != lpss->fHideIcons))
        {
            g_pShellState->ss.fHideIcons = lpss->fHideIcons;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_MAPNETDRVBUTTON) && (g_pShellState->ss.fMapNetDrvBtn != lpss->fMapNetDrvBtn))
        {
            g_pShellState->ss.fMapNetDrvBtn = lpss->fMapNetDrvBtn;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SORTCOLUMNS) &&
            ((g_pShellState->ss.lParamSort != lpss->lParamSort) || (g_pShellState->ss.iSortDirection != lpss->iSortDirection)))
        {
            g_pShellState->ss.iSortDirection = lpss->iSortDirection;
            g_pShellState->ss.lParamSort = lpss->lParamSort;
            fSave = TRUE;
        }

        if (dwMask & SSF_HIDDENFILEEXTS)
        {
            // Setting hidden extensions is not supported
        }

        if ((dwMask & SSF_FILTER) && (g_pShellState->ss.fFilter != lpss->fFilter))
        {
            g_pShellState->ss.fFilter = lpss->fFilter;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SHOWSUPERHIDDEN) && (g_pShellState->ss.fShowSuperHidden != lpss->fShowSuperHidden))
        {
            g_pShellState->ss.fShowSuperHidden = lpss->fShowSuperHidden;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_SEPPROCESS) && (g_pShellState->ss.fSepProcess != lpss->fSepProcess))
        {
            g_pShellState->ss.fSepProcess = lpss->fSepProcess;
            fSaveAdvanced = TRUE;
        }

        if ((dwMask & SSF_NONETCRAWLING) && (g_pShellState->ss.fNoNetCrawling != lpss->fNoNetCrawling))
        {
            g_pShellState->ss.fNoNetCrawling = lpss->fNoNetCrawling;
            fSaveAdvanced = TRUE;
        }
        
        if ((dwMask & SSF_STARTPANELON) && (g_pShellState->ss.fStartPanelOn != lpss->fStartPanelOn))
        {
            g_pShellState->ss.fStartPanelOn = lpss->fStartPanelOn;
            fSaveAdvanced = TRUE;
        }
        
        if ((dwMask & SSF_SHOWSTARTPAGE) && (g_pShellState->ss.fShowStartPage != lpss->fShowStartPage))
        {
            g_pShellState->ss.fShowStartPage = lpss->fShowStartPage;
            fSaveAdvanced = TRUE;
        }
    }

    if (fUpdateShellStateInReg || fSave || fSaveAdvanced)
    {
        // Write out the SHELLSTATE even if only fSaveAdvanced just to
        // make sure everything stays in sync.
        // We save 8 extra bytes for the ExcludeFileExts stuff.
        // Oh well.
        SKSetValue(SHELLKEY_HKCU_EXPLORER, NULL, TEXT("ShellState"), REG_BINARY, g_pShellState, g_pShellState->cbSize);
    }

    if (fUpdateShellStateInReg || fSaveAdvanced)
    {
        // SHRefreshSettingsPriv overwrites the SHELLSTATE values with whatever
        // the user specifies in View.FolderOptions.View.AdvancedSettings dialog.
        // These values are stored elsewhere in the registry, so we
        // better migrate SHELLSTATE to that part of the registry now.
        //
        // Might as well only do this if the registry settings we care about change.
        Install_AdvancedShellSettings(&g_pShellState->ss);
    }

    if (fSave || fSaveAdvanced)
    {
        // Let apps know the state has changed.
        SHRefreshSettings();
        SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("ShellState"));
    }

    if (!bSet)
    {
        if (dwMask & SSF_SHOWEXTENSIONS)
        {
            lpss->fShowExtensions = g_pShellState->ss.fShowExtensions;
        }
        
        if (dwMask & SSF_SHOWALLOBJECTS)
        {
            lpss->fShowAllObjects = g_pShellState->ss.fShowAllObjects;  // users "show hidden" setting
        }

        if (dwMask & SSF_SHOWSYSFILES)
        {
            lpss->fShowSysFiles = g_pShellState->ss.fShowSysFiles;  // this is ignored
        }

        if (dwMask & SSF_SHOWCOMPCOLOR)
        {
            lpss->fShowCompColor = g_pShellState->ss.fShowCompColor;
        }

        if (dwMask & SSF_NOCONFIRMRECYCLE)
        {
            lpss->fNoConfirmRecycle = SHRestricted(REST_BITBUCKCONFIRMDELETE) ? FALSE : g_pShellState->ss.fNoConfirmRecycle;
        }

        if (dwMask & SSF_DOUBLECLICKINWEBVIEW)
        {
            lpss->fDoubleClickInWebView = g_pShellState->ss.fDoubleClickInWebView;
        }

        if (dwMask & SSF_DESKTOPHTML)
        {
            lpss->fDesktopHTML = g_pShellState->ss.fDesktopHTML;
        }

        if (dwMask & SSF_WIN95CLASSIC)
        {
            lpss->fWin95Classic = g_pShellState->ss.fWin95Classic;
        }
        if (dwMask & SSF_WEBVIEW)
        {
            lpss->fWebView = g_pShellState->ss.fWebView;
        }

        if (dwMask & SSF_DONTPRETTYPATH)
        {
            lpss->fDontPrettyPath = g_pShellState->ss.fDontPrettyPath;
        }

        if (dwMask & SSF_SHOWINFOTIP)
        {
            lpss->fShowInfoTip = g_pShellState->ss.fShowInfoTip;
        }

        if (dwMask & SSF_HIDEICONS)
        {
            lpss->fHideIcons = g_pShellState->ss.fHideIcons;
        }

        if (dwMask & SSF_MAPNETDRVBUTTON)
        {
            lpss->fMapNetDrvBtn = g_pShellState->ss.fMapNetDrvBtn;
        }

        if (dwMask & SSF_SORTCOLUMNS)
        {
            lpss->iSortDirection = g_pShellState->ss.iSortDirection;
            lpss->lParamSort = g_pShellState->ss.lParamSort;
        }

        if (dwMask & SSF_FILTER)
        {
            lpss->fFilter = g_pShellState->ss.fFilter;
        }

        if (dwMask & SSF_SHOWSUPERHIDDEN)
        {
            lpss->fShowSuperHidden = g_pShellState->ss.fShowSuperHidden;
        }

        if (dwMask & SSF_SEPPROCESS)
        {
            lpss->fSepProcess = g_pShellState->ss.fSepProcess;
        }

        if (dwMask & SSF_NONETCRAWLING)
        {
            lpss->fNoNetCrawling = g_pShellState->ss.fNoNetCrawling;
        }
        
        if (dwMask & SSF_STARTPANELON)
        {
            lpss->fStartPanelOn = g_pShellState->ss.fStartPanelOn;
        }

        if (dwMask & SSF_SHOWSTARTPAGE)
        {
            lpss->fShowStartPage = g_pShellState->ss.fShowStartPage;
        }
    }
}

// A public version of the Get function so ISVs can track the shell flag state
//
STDAPI_(void) SHGetSettings(LPSHELLFLAGSTATE lpsfs, DWORD dwMask)
{
    if (lpsfs)
    {
        SHELLSTATE ss={0};

        // SSF_HIDDENFILEEXTS and SSF_SORTCOLUMNS don't work with
        // the SHELLFLAGSTATE struct, make sure they are off
        // (because the corresponding SHELLSTATE fields don't
        // exist in SHELLFLAGSTATE.)
        //
        dwMask &= ~(SSF_HIDDENFILEEXTS | SSF_SORTCOLUMNS);

        SHGetSetSettings(&ss, dwMask, FALSE);

        // copy the dword of flags out
        *((DWORD *)lpsfs) = *((DWORD *)(&ss));
    }
}


// app compatibility HACK stuff. the following stuff including CheckWinIniForAssocs()
// is used by the new version of SHDOCVW
// and EXPLORER.EXE to patch the registry for old win31 apps.


BOOL _PathIsExe(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];

    lstrcpy(szPath, pszPath);
    PathRemoveBlanks(szPath);

    return PathIsExe(szPath);
}

// tests to see if pszSubFolder is the same as or a sub folder of pszParent
// in:
//      pszFolder       parent folder to test against
//                      this may be a CSIDL value if the HIWORD() is 0
//      pszSubFolder    possible sub folder
//
// example:
//      TRUE    pszFolder = c:\windows, pszSubFolder = c:\windows\system
//      TRUE    pszFolder = c:\windows, pszSubFolder = c:\windows
//      FALSE   pszFolder = c:\windows, pszSubFolder = c:\winnt
//

SHSTDAPI_(BOOL) PathIsEqualOrSubFolder(LPCTSTR pszFolder, LPCTSTR pszSubFolder)
{
    TCHAR szParent[MAX_PATH], szCommon[MAX_PATH];

    if (!IS_INTRESOURCE(pszFolder))
        lstrcpyn(szParent, pszFolder, ARRAYSIZE(szParent));
    else
        SHGetFolderPath(NULL, PtrToUlong((void *) pszFolder) | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szParent);

    //  PathCommonPrefix() always removes the slash on common
    return szParent[0] && PathRemoveBackslash(szParent)
        && PathCommonPrefix(szParent, pszSubFolder, szCommon)
        && lstrcmpi(szParent, szCommon) == 0;
}

// pass an array of CSIDL values (-1 terminated)

STDAPI_(BOOL) PathIsEqualOrSubFolderOf(LPCTSTR pszSubFolder, const UINT rgFolders[], DWORD crgFolders)
{
    for (DWORD i = 0; i < crgFolders; i++)
    {
        if (PathIsEqualOrSubFolder(MAKEINTRESOURCE(rgFolders[i]), pszSubFolder))
            return TRUE;
    }
    return FALSE;
}

// pass an array of CSIDL values (-1 terminated)

STDAPI_(BOOL) PathIsOneOf(LPCTSTR pszFolder, const UINT rgFolders[], DWORD crgFolders)
{
    for (DWORD i = 0; i < crgFolders; i++)
    {
        TCHAR szParent[MAX_PATH];
        SHGetFolderPath(NULL, rgFolders[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szParent);

        // the trailing slashes are assumed to match
        if (lstrcmpi(szParent, pszFolder) == 0)
            return TRUE;
    }
    return FALSE;
}

// test pszChild against pszParent to see if
// pszChild is a direct child (one level) of pszParent

STDAPI_(BOOL) PathIsDirectChildOf(LPCTSTR pszParent, LPCTSTR pszChild)
{
    BOOL bDirectChild = FALSE;

    TCHAR szParent[MAX_PATH];

    if (!IS_INTRESOURCE(pszParent))
        lstrcpyn(szParent, pszParent, ARRAYSIZE(szParent));
    else
        SHGetFolderPath(NULL, PtrToUlong((void *)pszParent) | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szParent);

    if (PathIsRoot(szParent) && (-1 != PathGetDriveNumber(szParent)))
    {
        szParent[2] = 0;    // trip D:\ -> D: to make code below work
    }

    INT cchParent = lstrlen(szParent);
    INT cchChild = lstrlen(pszChild);

    if (cchParent <= cchChild)
    {
        TCHAR szChild[MAX_PATH];
        lstrcpyn(szChild, pszChild, ARRAYSIZE(szChild));

        LPTSTR pszChildSlice = szChild + cchParent;
        if (TEXT('\\') == *pszChildSlice)
        {
            *pszChildSlice = 0;
        }

        if (lstrcmpi(szChild, szParent) == 0)
        {
            if (cchParent < cchChild)
            {
                LPTSTR pTmp = pszChildSlice + 1;

                while (*pTmp && *pTmp != TEXT('\\'))
                {
                    pTmp++; // find second level path segments
                }

                if (!(*pTmp))
                {
                    bDirectChild = TRUE;
                }
            }
        }
    }

    return bDirectChild;
}


// many net providers (Vines and PCNFS) don't
// like "C:\" frormat volumes names, this code returns "C:" format
// for use with WNet calls

STDAPI_(LPTSTR) PathBuildSimpleRoot(int iDrive, LPTSTR pszDrive)
{
    pszDrive[0] = iDrive + TEXT('A');
    pszDrive[1] = TEXT(':');
    pszDrive[2] = 0;
    return pszDrive;
}


// Return TRUE for exe, com, bat, pif and lnk.
BOOL ReservedExtension(LPCTSTR pszExt)
{
    TCHAR szExt[5];  // Dot+ext+null.

    lstrcpyn(szExt, pszExt, ARRAYSIZE(szExt));
    PathRemoveBlanks(szExt);
    if (PathIsExe(szExt) || (lstrcmpi(szExt, TEXT(".lnk")) == 0))
    {
        return TRUE;
    }

    return FALSE;
}

TCHAR const c_szRegPathIniExtensions[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Extensions");

STDAPI_(LONG) RegSetString(HKEY hk, LPCTSTR pszSubKey, LPCTSTR pszValue)
{
    return RegSetValue(hk, pszSubKey, REG_SZ, pszValue, (lstrlen(pszValue) + 1) * sizeof(TCHAR));
}


STDAPI_(BOOL) RegSetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPCTSTR psz)
{
    return (S_OK == SHSetValue(hkey, pszSubKey, pszValue, REG_SZ, psz, CbFromCch(lstrlen(psz) + 1)));
}


STDAPI_(BOOL) RegGetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPTSTR psz, DWORD cb)
{
    return (!GetSystemMetrics(SM_CLEANBOOT)
    &&  (S_OK == SHGetValue(hkey, pszSubKey, pszValue, NULL, psz, &cb)));
}


// Returns TRUE if there is a proper shell\open\command for the given
// extension that matches the given command line.
// NB This is for MGX Designer which registers an extension and commands for
// printing but relies on win.ini extensions for Open. We need to detect that
// there's no open command and add the appropriate entries to the registry.
// If the given extension maps to a type name we return that in pszTypeName
// otherwise it will be null.
// FMH This also affects Asymetric Compel which makes a new .CPL association.
// We need to merge it up into our Control Panel .CPL association.  We depend
// on Control Panels NOT having a proper Open so users can see both verb sets.
// NB pszLine is the original line from win.ini eg foo.exe /bar ^.fred, see
// comments below...
BOOL Reg_ShellOpenForExtension(LPCTSTR pszExt, LPTSTR pszCmdLine,
    LPTSTR pszTypeName, int cchTypeName, LPCTSTR pszLine)
{
    TCHAR sz[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    LONG cb;

    if (pszTypeName)
        pszTypeName[0] = 0;

    // Is the extension registed at all?
    cb = sizeof(sz);
    sz[0] = 0;
    if (SHRegQueryValue(HKEY_CLASSES_ROOT, pszExt, sz, &cb) == ERROR_SUCCESS)
    {
        // Is there a file type?
        if (*sz)
        {
            // Yep, check there.
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension has a file type name %s.", sz);
            lstrcpy(szExt, sz);
            if (pszTypeName)
                lstrcpyn(pszTypeName, sz, cchTypeName);
        }
        else
        {
            // No, check old style associations.
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension has no file type name.", pszExt);
            lstrcpy(szExt, pszExt);
        }

        // See if there's an open command.
        lstrcat(szExt, TEXT("\\shell\\open\\command"));
        cb = sizeof(sz);
        if (SHRegQueryValue(HKEY_CLASSES_ROOT, szExt, sz, &cb) == ERROR_SUCCESS)
        {
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension %s already registed with an open command.", pszExt);
            // NB We want to compare the paths only, not the %1 stuff.
            if (PathIsRelative(pszCmdLine))
            {
                int cch;
                // If a relative path was passed in, we may have a fully qualifed
                // one that is now in the registry... In that case we should
                // say that it matches...
                LPTSTR pszT = PathGetArgs(sz);

                if (pszT)
                {
                    *(pszT-1) = 0;
                }

                PathUnquoteSpaces(sz);

                PathRemoveBlanks(pszCmdLine);

                cch = lstrlen(sz) - lstrlen(pszCmdLine);

                if ((cch >= 0) && (lstrcmpi(sz+cch, pszCmdLine) == 0))
                {
                    // DebugMsg(DM_TRACE, "c.r_rofe: Open commands match.");
                    return TRUE;
                }

                lstrcat(pszCmdLine, TEXT(" "));    // Append blank back on...
            }
            else
            {
                // If absolute path we can cheat for matches
                *(sz+lstrlen(pszCmdLine)) = 0;
                if (lstrcmpi(sz, pszCmdLine) == 0)
                {
                    // DebugMsg(DM_TRACE, "c.r_rofe: Open commands match.");
                    return TRUE;
                }
            }

            // DebugMsg(DM_TRACE, "c.r_rofe: Open commands don't match.");

            // Open commands don't match, check to see if it's because the ini
            // changed (return FALSE so the change is reflected in the registry) or
            // if the registry changed (return TRUE so we keep the registry the way
            // it is.
            if (RegGetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, pszExt, sz, ARRAYSIZE(sz)))
            {
                if (lstrcmpi(sz, pszLine) == 0)
                    return TRUE;
            }

            return FALSE;
        }
        else
        {
            // DebugMsg(DM_TRACE, "c.r_rofe: Extension %s already registed but with no open command.", pszExt);
            return FALSE;
        }
    }

    // DebugMsg(DM_TRACE, "c.r_rofe: No open command for %s.", pszExt);

    return FALSE;
}


// This function will read in the extensions section of win.ini to see if
// there are any old style associations that we have not accounted for.
// NB Some apps mess up if their extensions magically disappear from the
// extensions section so DON'T DELETE the old entries from win.ini.
//
// Since this is for win3.1 compat, CWIFA_SIZE should be enough (it has been so far...)
//
#define CWIFA_SIZE  4096

STDAPI_(void) CheckWinIniForAssocs(void)
{
    LPTSTR pszBuf;
    int cbRet;
    LPTSTR pszLine;
    TCHAR szExtension[MAX_PATH];
    TCHAR szTypeName[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
    LPTSTR pszExt;
    LPTSTR pszT;
    BOOL fAssocsMade = FALSE;
        
    szExtension[0]=TEXT('.');
    szExtension[1]=0;
        
    pszBuf = (LPTSTR)LocalAlloc(LPTR, CWIFA_SIZE*sizeof(TCHAR));
    if (!pszBuf)
        return; // Could not allocate the memory
    cbRet = (int)GetProfileSection(TEXT("Extensions"), pszBuf, CWIFA_SIZE);
        
    //
    // We now walk through the list to find any items that is not
    // in the registry.
    //
    for (pszLine = pszBuf; *pszLine; pszLine += lstrlen(pszLine)+1)
    {
                // Get the extension for this file into a buffer.
                pszExt = StrChr(pszLine, TEXT('='));
                if (pszExt == NULL)
                        continue;   // skip this line
                
                szExtension[0]=TEXT('.');
                // lstrcpyn will put the null terminator for us.
                // We should now have something like .xls in szExtension.
                lstrcpyn(szExtension+1, pszLine, (int)(pszExt-pszLine)+1);
                
                // Ignore extensions bigger than dot + 3 chars.
                if (lstrlen(szExtension) > 4)
                {
                        DebugMsg(DM_ERROR, TEXT("CheckWinIniForAssocs: Invalid extension, skipped."));
                        continue;
                }
                
                pszLine = pszExt+1;     // Points to after the =;
                while (*pszLine == TEXT(' '))
                        pszLine++;  // skip blanks
                
                // Now find the ^ in the command line.
                pszExt = StrChr(pszLine, TEXT('^'));
                if (pszExt == NULL)
                        continue;       // dont process
                
                // Now setup  the command line
                // WARNING: This assumes only 1 ^ and it assumes the extension...
                lstrcpyn(szCmdLine, pszLine, (int)(pszExt-pszLine)+1);
                
                // Don't bother moving over invalid entries (like the busted .hlp
                // entry VB 3.0 creates).
                if (!_PathIsExe(szCmdLine))
                {
                        DebugMsg(DM_ERROR, TEXT("c.cwia: Invalid app, skipped."));
                        continue;
                }
                
                if (ReservedExtension(szExtension))
                {
                        DebugMsg(DM_ERROR, TEXT("c.cwia: Invalid extension (%s), skipped."), szExtension);
                        continue;
                }
                
                // Now see if there is already a mapping for this extension.
                if (Reg_ShellOpenForExtension(szExtension, szCmdLine, szTypeName, ARRAYSIZE(szTypeName), pszLine))
                {
                        // Yep, Setup the initial list of ini extensions in the registry if they are
                        // not there already.
                        if (!RegGetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, szExtension, szTypeName, sizeof(szTypeName)))
                        {
                                RegSetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, szExtension, pszLine);
                        }
                        continue;
                }
                
                // No mapping.
                
                // HACK for Expert Home Design. They put an association in win.ini
                // (which we propagate as typeless) but then register a type and a
                // print command the first time they run - stomping on our propagated
                // Open command. The fix is to put their open command under the proper
                // type instead of leaving it typeless.
                if (lstrcmpi(szExtension, TEXT(".dgw")) == 0)
                {
                        if (lstrcmpi(PathFindFileName(szCmdLine), TEXT("designw.exe ")) == 0)
                        {
                                // Put in a ProgID for them.
                                RegSetValue(HKEY_CLASSES_ROOT, szExtension, REG_SZ, TEXT("HDesign"), 0L);
                                // Force Open command under their ProgID.
                                TraceMsg(DM_TRACE, "c.cwifa: Expert Home Design special case hit.");
                                lstrcpy(szTypeName, TEXT("HDesign"));
                        }
                }
                
                //
                // HACK for Windows OrgChart which does not register OLE1 class
                // if ".WOC" is registered in the registry.
                //
                if (lstrcmpi(szExtension, TEXT(".WOC")) == 0)
                {
                        if (lstrcmpi(PathFindFileName(szCmdLine), TEXT("WINORG.EXE ")) == 0)
                        {
                                DebugMsg(DM_ERROR, TEXT("c.cwia: HACK: Found WINORG (%s, %s), skipped."), szExtension, pszLine);
                                continue;
                        }
                }
                
                // Record that we're about to move things over in the registry so we won't keep
                // doing it all the time.
                RegSetValueString(HKEY_LOCAL_MACHINE, c_szRegPathIniExtensions, szExtension, pszLine);
                
                lstrcat(szCmdLine, TEXT("%1"));
                
                // see if there are anything else to copy out...
                pszExt++;    // get beyond the ^
                pszT = szExtension;
                while (*pszExt && (CharLowerChar(*pszExt) == CharLowerChar(*pszT)))
                {
                        // Look for the next character...
                        pszExt++;
                        pszT++;
                }
                if (*pszExt)
                        lstrcat(szCmdLine, pszExt); // add the rest onto the command line
                
                // Now lets make the actual association.
                // We need to add on the right stuff onto the key...
                if (*szTypeName)
                        lstrcpy(szExtension, szTypeName);
                
        lstrcat(szExtension, TEXT("\\shell\\open\\command"));
        RegSetValue(HKEY_CLASSES_ROOT, szExtension, REG_SZ, szCmdLine, 0L);
        // DebugMsg(DM_TRACE, "c.cwifa: %s %s", szExtension, szCmdLine);
                
        fAssocsMade = TRUE;
    }
        
    // If we made any associations we should let the cabinet know.
    //
    // Now call off to the notify function.
    if (fAssocsMade)
        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
        
    // And cleanup our allocation
    LocalFree((HLOCAL)pszBuf);
}

typedef struct
{
    INT     iFlag;
    LPCTSTR pszKey;
    LPCTSTR pszValue;
} RESTRICTIONITEMS;

#define SZ_RESTRICTED_ACTIVEDESKTOP             L"ActiveDesktop"
#define REGSTR_VAL_RESTRICTRUNW                 L"RestrictRun"
#define REGSTR_VAL_PRINTERS_HIDETABSW           L"NoPrinterTabs"
#define REGSTR_VAL_PRINTERS_NODELETEW           L"NoDeletePrinter"
#define REGSTR_VAL_PRINTERS_NOADDW              L"NoAddPrinter"

const SHRESTRICTIONITEMS c_rgRestrictionItems[] =
{
    {REST_NORUN,                   L"Explorer", L"NoRun"},
    {REST_NOCLOSE,                 L"Explorer", L"NoClose"},
    {REST_NOSAVESET ,              L"Explorer", L"NoSaveSettings"},
    {REST_NOFILEMENU,              L"Explorer", L"NoFileMenu"},
    {REST_NOSETFOLDERS,            L"Explorer", L"NoSetFolders"},
    {REST_NOSETTASKBAR,            L"Explorer", L"NoSetTaskbar"},
    {REST_NODESKTOP,               L"Explorer", L"NoDesktop"},
    {REST_NOFIND,                  L"Explorer", L"NoFind"},
    {REST_NODRIVES,                L"Explorer", L"NoDrives"},
    {REST_NODRIVEAUTORUN,          L"Explorer", L"NoDriveAutoRun"},
    {REST_NODRIVETYPEAUTORUN,      L"Explorer", L"NoDriveTypeAutoRun"},
    {REST_NONETHOOD,               L"Explorer", L"NoNetHood"},
    {REST_STARTBANNER,             L"Explorer", L"NoStartBanner"},
    {REST_RESTRICTRUN,             L"Explorer", REGSTR_VAL_RESTRICTRUNW},
    {REST_NOPRINTERTABS,           L"Explorer", REGSTR_VAL_PRINTERS_HIDETABSW},
    {REST_NOPRINTERDELETE,         L"Explorer", REGSTR_VAL_PRINTERS_NODELETEW},
    {REST_NOPRINTERADD,            L"Explorer", REGSTR_VAL_PRINTERS_NOADDW},
    {REST_NOSTARTMENUSUBFOLDERS,   L"Explorer", L"NoStartMenuSubFolders"},
    {REST_MYDOCSONNET,             L"Explorer", L"MyDocsOnNet"},
    {REST_NOEXITTODOS,             L"WinOldApp", L"NoRealMode"},
    {REST_ENFORCESHELLEXTSECURITY, L"Explorer", L"EnforceShellExtensionSecurity"},
    {REST_NOCOMMONGROUPS,          L"Explorer", L"NoCommonGroups"},
    {REST_LINKRESOLVEIGNORELINKINFO,L"Explorer", L"LinkResolveIgnoreLinkInfo"},
    {REST_NOWEB,                   L"Explorer", L"NoWebMenu"},
    {REST_NOTRAYCONTEXTMENU,       L"Explorer", L"NoTrayContextMenu"},
    {REST_NOVIEWCONTEXTMENU,       L"Explorer", L"NoViewContextMenu"},
    {REST_NONETCONNECTDISCONNECT,  L"Explorer", L"NoNetConnectDisconnect"},
    {REST_STARTMENULOGOFF,         L"Explorer", L"StartMenuLogoff"},
    {REST_NOSETTINGSASSIST,        L"Explorer", L"NoSettingsWizards"},

    {REST_NODISCONNECT,           L"Explorer", L"NoDisconnect"},
    {REST_NOSECURITY,             L"Explorer", L"NoNTSecurity"  },
    {REST_NOFILEASSOCIATE,        L"Explorer", L"NoFileAssociate"  },

    // New for IE4
    {REST_NOINTERNETICON,          L"Explorer", L"NoInternetIcon"},
    {REST_NORECENTDOCSHISTORY,     L"Explorer", L"NoRecentDocsHistory"},
    {REST_NORECENTDOCSMENU,        L"Explorer", L"NoRecentDocsMenu"},
    {REST_NOACTIVEDESKTOP,         L"Explorer", L"NoActiveDesktop"},
    {REST_NOACTIVEDESKTOPCHANGES,  L"Explorer", L"NoActiveDesktopChanges"},
    {REST_NOFAVORITESMENU,         L"Explorer", L"NoFavoritesMenu"},
    {REST_CLEARRECENTDOCSONEXIT,   L"Explorer", L"ClearRecentDocsOnExit"},
    {REST_CLASSICSHELL,            L"Explorer", L"ClassicShell"},
    {REST_NOCUSTOMIZEWEBVIEW,      L"Explorer", L"NoCustomizeWebView"},
    {REST_NOHTMLWALLPAPER,         SZ_RESTRICTED_ACTIVEDESKTOP, L"NoHTMLWallPaper"},
    {REST_NOCHANGINGWALLPAPER,     SZ_RESTRICTED_ACTIVEDESKTOP, L"NoChangingWallPaper"},
    {REST_NODESKCOMP,              SZ_RESTRICTED_ACTIVEDESKTOP, L"NoComponents"},
    {REST_NOADDDESKCOMP,           SZ_RESTRICTED_ACTIVEDESKTOP, L"NoAddingComponents"},
    {REST_NODELDESKCOMP,           SZ_RESTRICTED_ACTIVEDESKTOP, L"NoDeletingComponents"},
    {REST_NOCLOSEDESKCOMP,         SZ_RESTRICTED_ACTIVEDESKTOP, L"NoClosingComponents"},
    {REST_NOCLOSE_DRAGDROPBAND,    L"Explorer", L"NoCloseDragDropBands"},
    {REST_NOMOVINGBAND,            L"Explorer", L"NoMovingBands"},
    {REST_NOEDITDESKCOMP,          SZ_RESTRICTED_ACTIVEDESKTOP, L"NoEditingComponents"},
    {REST_NORESOLVESEARCH,         L"Explorer", L"NoResolveSearch"},
    {REST_NORESOLVETRACK,          L"Explorer", L"NoResolveTrack"},
    {REST_FORCECOPYACLWITHFILE,    L"Explorer", L"ForceCopyACLWithFile"},
    {REST_NOLOGO3CHANNELNOTIFY,    L"Explorer", L"NoMSAppLogo5ChannelNotify"},
    {REST_NOFORGETSOFTWAREUPDATE,  L"Explorer", L"NoForgetSoftwareUpdate"},
    {REST_GREYMSIADS,              L"Explorer", L"GreyMSIAds"},

    // More start menu Restritions for 4.01
    {REST_NOSETACTIVEDESKTOP,      L"Explorer", L"NoSetActiveDesktop"},
    {REST_NOUPDATEWINDOWS,         L"Explorer", L"NoWindowsUpdate"},
    {REST_NOCHANGESTARMENU,        L"Explorer", L"NoChangeStartMenu"},
    {REST_NOFOLDEROPTIONS,         L"Explorer", L"NoFolderOptions"},
    {REST_NOCSC,                   L"Explorer", L"NoSyncAll"},

    // NT5 shell restrictions
    {REST_HASFINDCOMPUTERS,        L"Explorer", L"FindComputers"},
    {REST_RUNDLGMEMCHECKBOX,       L"Explorer", L"MemCheckBoxInRunDlg"},
    {REST_INTELLIMENUS,            L"Explorer", L"IntelliMenus"},
    {REST_SEPARATEDESKTOPPROCESS,  L"Explorer", L"SeparateProcess"}, // this one was actually checked in IE4 in shdocvw, but not here. Duh.
    {REST_MaxRecentDocs,           L"Explorer", L"MaxRecentDocs"},
    {REST_NOCONTROLPANEL,          L"Explorer", L"NoControlPanel"},     // Remove only the control panel from the Settings menu
    {REST_ENUMWORKGROUP,           L"Explorer", L"EnumWorkgroup"},
    {REST_ARP_ShowPostSetup,       L"Uninstall", L"ShowPostSetup"},
    {REST_ARP_NOARP,               L"Uninstall", L"NoAddRemovePrograms"},
    {REST_ARP_NOREMOVEPAGE,        L"Uninstall", L"NoRemovePage"},
    {REST_ARP_NOADDPAGE,           L"Uninstall", L"NoAddPage"},
    {REST_ARP_NOWINSETUPPAGE,      L"Uninstall", L"NoWindowsSetupPage"},
    {REST_NOCHANGEMAPPEDDRIVELABEL, L"Explorer", L"NoChangeMappedDriveLabel"},
    {REST_NOCHANGEMAPPEDDRIVECOMMENT, L"Explorer", L"NoChangeMappedDriveComment"},
    {REST_NONETWORKCONNECTIONS,    L"Explorer", L"NoNetworkConnections"},
    {REST_FORCESTARTMENULOGOFF,    L"Explorer", L"ForceStartMenuLogoff"},
    {REST_NOWEBVIEW,               L"Explorer", L"NoWebView"},
    {REST_NOCUSTOMIZETHISFOLDER,   L"Explorer", L"NoCustomizeThisFolder"},
    {REST_NOENCRYPTION,            L"Explorer", L"NoEncryption"},
    {REST_DONTSHOWSUPERHIDDEN,     L"Explorer", L"DontShowSuperHidden"},
    {REST_NOSHELLSEARCHBUTTON,     L"Explorer", L"NoShellSearchButton"},
    {REST_NOHARDWARETAB,           L"Explorer", L"NoHardwareTab"},
    {REST_NORUNASINSTALLPROMPT,    L"Explorer", L"NoRunasInstallPrompt"},
    {REST_PROMPTRUNASINSTALLNETPATH, L"Explorer", L"PromptRunasInstallNetPath"},
    {REST_NOMANAGEMYCOMPUTERVERB,  L"Explorer", L"NoManageMyComputerVerb"},
    {REST_NORECENTDOCSNETHOOD,     L"Explorer", L"NoRecentDocsNetHood"},
    {REST_DISALLOWRUN,             L"Explorer", L"DisallowRun"},
    {REST_NOWELCOMESCREEN,         L"Explorer", L"NoWelcomeScreen"},
    {REST_RESTRICTCPL,             L"Explorer", L"RestrictCpl"},
    {REST_DISALLOWCPL,             L"Explorer", L"DisallowCpl"},
    {REST_NOSMBALLOONTIP,          L"Explorer", L"NoSMBalloonTip"},
    {REST_NOSMHELP,                L"Explorer", L"NoSMHelp"},
    {REST_NOWINKEYS,               L"Explorer", L"NoWinKeys"},
    {REST_NOENCRYPTONMOVE,         L"Explorer", L"NoEncryptOnMove"},
    {REST_NOLOCALMACHINERUN,       L"Explorer", L"DisableLocalMachineRun"},
    {REST_NOCURRENTUSERRUN,        L"Explorer", L"DisableCurrentUserRun"},
    {REST_NOLOCALMACHINERUNONCE,   L"Explorer", L"DisableLocalMachineRunOnce"},
    {REST_NOCURRENTUSERRUNONCE,    L"Explorer", L"DisableCurrentUserRunOnce"},
    {REST_FORCEACTIVEDESKTOPON,    L"Explorer", L"ForceActiveDesktopOn"},
    {REST_NOCOMPUTERSNEARME,       L"Explorer", L"NoComputersNearMe"},
    {REST_NOVIEWONDRIVE,           L"Explorer", L"NoViewOnDrive"},

    // Millennium shell restrictions
    // Exception: REST_NOSMMYDOCS is also supported on NT5.

    {REST_NONETCRAWL,              L"Explorer", L"NoNetCrawling"},
    {REST_NOSHAREDDOCUMENTS,       L"Explorer", L"NoSharedDocuments"},
    {REST_NOSMMYDOCS,              L"Explorer", L"NoSMMyDocs"},
    {REST_NOSMMYPICS,              L"Explorer", L"NoSMMyPictures"},
    {REST_ALLOWBITBUCKDRIVES,      L"Explorer", L"RecycleBinDrives"},

    // These next few restrictions are mixed between Neptune and Millennium
    // (Isn't simultaneous development fun?)
    {REST_NONLEGACYSHELLMODE,     L"Explorer", L"NoneLegacyShellMode"},         // Neptune
    {REST_NOCONTROLPANELBARRICADE, L"Explorer", L"NoControlPanelBarricade"},    // Millennium

    {REST_NOAUTOTRAYNOTIFY,        L"Explorer", L"NoAutoTrayNotify"},   // traynot.h
    {REST_NOTASKGROUPING,          L"Explorer", L"NoTaskGrouping"},
    {REST_NOCDBURNING,             L"Explorer", L"NoCDBurning"},
    {REST_MYCOMPNOPROP,            L"Explorer", L"NoPropertiesMyComputer"},
    {REST_MYDOCSNOPROP,            L"Explorer", L"NoPropertiesMyDocuments"},

    {REST_NODISPLAYAPPEARANCEPAGE, L"System",   L"NoDispAppearancePage"},
    {REST_NOTHEMESTAB,             L"Explorer", L"NoThemesTab"},
    {REST_NOVISUALSTYLECHOICE,     L"System",   L"NoVisualStyleChoice"},
    {REST_NOSIZECHOICE,            L"System",   L"NoSizeChoice"},
    {REST_NOCOLORCHOICE,           L"System",   L"NoColorChoice"},
    {REST_SETVISUALSTYLE,          L"System",   L"SetVisualStyle"},

    {REST_STARTRUNNOHOMEPATH,      L"Explorer", L"StartRunNoHOMEPATH"},
    {REST_NOSTARTPANEL,            L"Explorer", L"NoSimpleStartMenu"},
    {REST_NOUSERNAMEINSTARTPANEL,  L"Explorer", L"NoUserNameInStartMenu"},
    {REST_NOMYCOMPUTERICON,        L"NonEnum",  L"{20D04FE0-3AEA-1069-A2D8-08002B30309D}"},
    {REST_NOSMNETWORKPLACES,       L"Explorer", L"NoStartMenuNetworkPlaces"},
    {REST_NOSMPINNEDLIST,          L"Explorer", L"NoStartMenuPinnedList"},
    {REST_NOSMMYMUSIC,             L"Explorer", L"NoStartMenuMyMusic"},
    {REST_NOSMEJECTPC,             L"Explorer", L"NoStartMenuEjectPC"},
    {REST_NOSMMOREPROGRAMS,        L"Explorer", L"NoStartMenuMorePrograms"},
    {REST_NOSMMFUPROGRAMS,         L"Explorer", L"NoStartMenuMFUprogramsList"},

    {REST_HIDECLOCK,               L"Explorer", L"HideClock"},
    {REST_NOLOWDISKSPACECHECKS,    L"Explorer", L"NoLowDiskSpaceChecks"},
    {REST_NODESKTOPCLEANUP,        L"Explorer", L"NoDesktopCleanupWizard"},

    // NT6 shell restrictions (Whistler)
    {REST_NOENTIRENETWORK,         L"Network",  L"NoEntireNetwork"}, // Note WNet stores it's policy in "Network".

    {REST_BITBUCKNUKEONDELETE,     L"Explorer", L"NoRecycleFiles"},
    {REST_BITBUCKCONFIRMDELETE,    L"Explorer", L"ConfirmFileDelete"},
    {REST_BITBUCKNOPROP,           L"Explorer", L"NoPropertiesRecycleBin"},
    {REST_NOTRAYITEMSDISPLAY,      L"Explorer", L"NoTrayItemsDisplay"}, // traynot.h
    {REST_NOTOOLBARSONTASKBAR,     L"Explorer", L"NoToolbarsOnTaskbar"},

    {REST_NODISPBACKGROUND,        L"System",   L"NoDispBackgroundPage"},
    {REST_NODISPSCREENSAVEPG,      L"System",   L"NoDispScrSavPage"},
    {REST_NODISPSETTINGSPG,        L"System",   L"NoDispSettingsPage"},
    {REST_NODISPSCREENSAVEPREVIEW, L"System",   L"NoScreenSavePreview"},    // Do not show screen saver previews
    {REST_NODISPLAYCPL,            L"System",   L"NoDispCPL"},              // Do not show the Display Control Panel at all.
    {REST_HIDERUNASVERB,           L"Explorer", L"HideRunAsVerb"},
    {REST_NOTHUMBNAILCACHE,        L"Explorer", L"NoThumbnailCache"},       // Do not use a thumbnail cache
    {REST_NOSTRCMPLOGICAL,         L"Explorer", L"NoStrCmpLogical"},        // Do not use a logical sorting in the namespace

    // Windows 2000 SP3 shell restriction
    {REST_NOSMCONFIGUREPROGRAMS,   L"Explorer", L"NoSMConfigurePrograms"},

    {REST_ALLOWUNHASHEDWEBVIEW,    L"Explorer", L"AllowUnhashedWebView"},
    {REST_ALLOWLEGACYWEBVIEW,      L"Explorer", L"AllowLegacyWebView"},
    {REST_REVERTWEBVIEWSECURITY,   L"Explorer", L"RevertWebViewSecurity"},
    {REST_INHERITCONSOLEHANDLES,   L"Explorer", L"InheritConsoleHandles"},

    {0, NULL, NULL},
};

DWORD g_rgRestrictionItemValues[ARRAYSIZE(c_rgRestrictionItems) - 1 ] = { 0 };

EXTERN_C HANDLE g_hRestrictions = NULL;
LONG g_lProcessRestrictionsCount = -1; //  current process's count

HANDLE _GetRestrictionsCounter()
{
    return SHGetCachedGlobalCounter(&g_hRestrictions, &GUID_Restrictions);
}

BOOL _QueryRestrictionsChanged(void)
{
    long lGlobalCount = SHGlobalCounterGetValue(_GetRestrictionsCounter());
    if (g_lProcessRestrictionsCount != lGlobalCount)
    {
        g_lProcessRestrictionsCount = lGlobalCount;
        return TRUE;
    }
    return FALSE;
}


// Returns DWORD vaolue if any of the specified restrictions are in place.
// 0 otherwise.

STDAPI_(DWORD) SHRestricted(RESTRICTIONS rest)
{
    // The cache may be invalid. Check first! We have to use
    // a global named semaphore in case this function is called
    // from a process other than the shell process. (And we're
    // sharing the same count between shell32 and shdocvw.)
    if (_QueryRestrictionsChanged())
    {
        memset(g_rgRestrictionItemValues, (BYTE)-1, sizeof(g_rgRestrictionItemValues));
    }

    return SHRestrictionLookup(rest, NULL, c_rgRestrictionItems, g_rgRestrictionItemValues);
}

STDAPI_(BOOL) SHIsRestricted(HWND hwnd, RESTRICTIONS rest)
{
    if (SHRestricted(rest))
    {
        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RESTRICTIONS),
            MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK|MB_ICONSTOP);
        return TRUE;
    }
    return FALSE;
}


BOOL UpdateScreenSaver(BOOL bActive, LPCTSTR pszNewSSName, int iNewSSTimeout)
{
    BOOL bUpdatedSS = FALSE;
    BOOL bCurrentActive;
    TCHAR szCurrentSSPath[MAX_PATH];
    int iCurrentSSTimeout;
    HKEY hk;

    // check the screen saver path

    // first find out what the users screensaver path is set to
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk) == ERROR_SUCCESS)
    {
        DWORD cbSize;

        cbSize = sizeof(szCurrentSSPath);
        if (RegQueryValueEx(hk, TEXT("SCRNSAVE.EXE"), NULL, NULL, (LPBYTE)szCurrentSSPath, &cbSize) == ERROR_SUCCESS)
        {
            // if we have a new name, then we might need to override the users current value
            if (pszNewSSName)
            {
                BOOL bTestExpandedPath;
                TCHAR szExpandedSSPath[MAX_PATH];

                // even though SCRNSAVE.EXE is of type REG_SZ, it can contain env variables (sigh)
                bTestExpandedPath = SHExpandEnvironmentStrings(szCurrentSSPath, szExpandedSSPath, ARRAYSIZE(szExpandedSSPath));

                // see if the new string matches the current
                if ((lstrcmpi(pszNewSSName, szCurrentSSPath) != 0)  &&
                    (!bTestExpandedPath || (lstrcmpi(pszNewSSName, szExpandedSSPath) != 0)))
                {
                    // new screensaver string is different from the old, so update the users value w/ the policy setting
                    if (RegSetValueEx(hk,
                                      TEXT("SCRNSAVE.EXE"),
                                      0,
                                      REG_SZ,
                                      (LPBYTE)pszNewSSName,
                                      (lstrlen(pszNewSSName) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                    {
                        bUpdatedSS = TRUE;
                    }
                }
            }
            else
            {
                // we do not have a screensaver set via policy. if the user does not have one set, then
                // there is going to be nothing to run! In this case, don't ever activate it
                if ((szCurrentSSPath[0] == TEXT('\0'))              ||    
                    (lstrcmpi(szCurrentSSPath, TEXT("\"\"")) == 0)  ||
                    (lstrcmpi(szCurrentSSPath, TEXT("none")) == 0)  ||
                    (lstrcmpi(szCurrentSSPath, TEXT("(none)")) == 0))
                {
                    // policy does not specify a screensaver and the user doesn't have one, so do
                    // not make the screensaver active.
                    bActive = FALSE;
                }
            }
        }
        else
        {
            // user did not have a screensaver registry value
            if (pszNewSSName)
            {
                // update the users value w/ the policy setting
                if (RegSetValueEx(hk,
                                  TEXT("SCRNSAVE.EXE"),
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pszNewSSName,
                                  (lstrlen(pszNewSSName) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                {
                    bUpdatedSS = TRUE;
                }
                else
                {
                    // if we failed to set the screensaver then do not make it active
                    bActive = FALSE;
                }
            }
            else
            {
                // policy does not specify a screensaver and the user doesn't have one, so do
                // not make the screensaver active.
                bActive = FALSE;
            }
        }

        RegCloseKey(hk);
    }

    // check the timeout value
    if (iNewSSTimeout && SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT, 0, (void*)&iCurrentSSTimeout, 0))
    {
        if (iNewSSTimeout != iCurrentSSTimeout)
        {
            if (SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT, iNewSSTimeout, NULL, SPIF_UPDATEINIFILE))
            {
                bUpdatedSS = TRUE;
            }
        }
    }

    // check to see if we need to change our active status
    if (SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, (void*)&bCurrentActive, 0) && 
        (bActive != bCurrentActive))
    {
        if (SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bActive, NULL, SPIF_UPDATEINIFILE))
        {
            bUpdatedSS = TRUE;
        }
    }

    return bUpdatedSS;
}


// Called by Explorer.exe when things change so that we can zero our global
// data on ini changed status. Wparam and lparam are from a WM_SETTINGSCHANGED/WM_WININICHANGE
// message.

STDAPI_(void) SHSettingsChanged(WPARAM wParam, LPARAM lParam)
{
    BOOL bPolicyChanged = FALSE;

    if (lstrcmpi(TEXT("Policy"), (LPCTSTR)lParam) == 0)
    {
        bPolicyChanged = TRUE;
    }

    if (!lParam ||
        bPolicyChanged ||
        lstrcmpi(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"), (LPCTSTR)lParam) == 0)
    {
        SHGlobalCounterIncrement(_GetRestrictionsCounter());
    }
}

LONG SHRegQueryValueExA(HKEY hKey, LPCSTR lpValueName, DWORD *pRes, DWORD *lpType, LPBYTE lpData, DWORD *lpcbData)
{
    return SHQueryValueExA(hKey, lpValueName, pRes, lpType, lpData, lpcbData);
}

LONG SHRegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD *pRes, DWORD *lpType, LPBYTE lpData, DWORD *lpcbData)
{
    return SHQueryValueExW(hKey, lpValueName, pRes, lpType, lpData, lpcbData);
}

STDAPI_(LONG) SHRegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpValue, LONG *lpcbValue)
{
    LONG l;
    HKEY ChildKey;

    if ((lpSubKey == NULL) || (*lpSubKey == 0))
    {
        ChildKey = hKey;
    }
    else
    {
        l = RegOpenKeyExA(hKey, lpSubKey, 0, KEY_QUERY_VALUE, &ChildKey);
        if (l != ERROR_SUCCESS)
            return l;
    }

    l = SHQueryValueExA(ChildKey, NULL, NULL, NULL, (LPBYTE)lpValue, (DWORD *)lpcbValue);

    if (ChildKey != hKey)
        RegCloseKey(ChildKey);

    if (l == ERROR_FILE_NOT_FOUND)
    {
        if (lpValue)
            *lpValue = 0;
        if (lpcbValue)
            *lpcbValue = sizeof(CHAR);
        l = ERROR_SUCCESS;
    }
    return l;
}

STDAPI_(LONG) SHRegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpValue, LONG *lpcbValue)
{
    LONG l;
    HKEY ChildKey;

    if ((lpSubKey == NULL) || (*lpSubKey == 0))
    {
        ChildKey = hKey;
    }
    else
    {
        l = RegOpenKeyExW(hKey, lpSubKey, 0, KEY_QUERY_VALUE, &ChildKey);
        if (l != ERROR_SUCCESS)
            return l;
    }

    l = SHQueryValueExW(ChildKey, NULL, NULL, NULL, (LPBYTE)lpValue, (DWORD *)lpcbValue);

    if (ChildKey != hKey)
        RegCloseKey(ChildKey);

    if (l == ERROR_FILE_NOT_FOUND)
    {
        if (lpValue)
            *lpValue = 0;
        if (lpcbValue)
            *lpcbValue = sizeof(WCHAR);
        l = ERROR_SUCCESS;
    }
    return l;
}


void SHRegCloseKeys(HKEY ahkeys[], UINT ckeys)
{
    UINT ikeys;
    for (ikeys = 0; ikeys < ckeys; ikeys++)
    {
        if (ahkeys[ikeys])
        {
            RegCloseKey(ahkeys[ikeys]);
            ahkeys[ikeys] = NULL;
        }
    }
}

STDAPI_(BOOL) SHWinHelp(HWND hwndMain, LPCTSTR lpszHelp, UINT usCommand, ULONG_PTR ulData)
{
    // Try to show help
    if (!WinHelp(hwndMain, lpszHelp, usCommand, ulData))
    {
        // Problem.
        ShellMessageBox(HINST_THISDLL, hwndMain,
                MAKEINTRESOURCE(IDS_WINHELPERROR),
                MAKEINTRESOURCE(IDS_WINHELPTITLE),
                MB_ICONHAND | MB_OK);
        return FALSE;
    }
    return TRUE;
}

STDAPI StringToStrRet(LPCTSTR pszName, LPSTRRET pStrRet)
{
    pStrRet->uType = STRRET_WSTR;
    return SHStrDup(pszName, &pStrRet->pOleStr);
}

STDAPI ResToStrRet(UINT id, STRRET *pStrRet)
{
    TCHAR szTemp[MAX_PATH];

    pStrRet->uType = STRRET_WSTR;
    LoadString(HINST_THISDLL, id, szTemp, ARRAYSIZE(szTemp));
    return SHStrDup(szTemp, &pStrRet->pOleStr);
}

UINT g_uCodePage = 0;

LPCTSTR SkipLeadingSlashes(LPCTSTR pszURL)
{
    LPCTSTR pszURLStart;

    ASSERT(IS_VALID_STRING_PTR(pszURL, -1));

    pszURLStart = pszURL;

    // Skip two leading slashes.

    if (pszURL[0] == TEXT('/') && pszURL[1] == TEXT('/'))
        pszURLStart += 2;

    ASSERT(IS_VALID_STRING_PTR(pszURL, -1) &&
           IsStringContained(pszURL, pszURLStart));

    return pszURLStart;
}


#undef PropVariantClear

STDAPI PropVariantClearLazy(PROPVARIANT *pvar)
{
    switch(pvar->vt)
    {
    case VT_I4:
    case VT_UI4:
    case VT_EMPTY:
    case VT_FILETIME:
        // No operation
        break;

    // SHAlloc matches the CoTaskMemFree functions and will init OLE if it must be
    // loaded.
    case VT_LPSTR:
        SHFree(pvar->pszVal);
        break;
    case VT_LPWSTR:
        SHFree(pvar->pwszVal);
        break;

    default:
        return PropVariantClear(pvar);  // real version in OLE32
    }
    return S_OK;

}


// Return S_OK if all of the items are HTML or CDF references.
//     Otherwise, return S_FALSE.

HRESULT IsDeskCompHDrop(IDataObject * pido)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    // asking for CF_HDROP
    HRESULT hr = pido->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        HDROP hDrop = (HDROP)medium.hGlobal;
        DRAGINFO di;

        di.uSize = sizeof(di);
        if (DragQueryInfo(hDrop, &di))  // di.lpFileList will be in TCHAR format -- see DragQueryInfo impl
        {
            if (di.lpFileList)
            {
                LPTSTR pszCurrPath = di.lpFileList;

                while (pszCurrPath && pszCurrPath[0])
                {
                    // Is this file not acceptable to create a Desktop Component?
                    if (!PathIsContentType(pszCurrPath, SZ_CONTENTTYPE_HTML) &&
                        !PathIsContentType(pszCurrPath, SZ_CONTENTTYPE_CDF))
                    {
                        // Yes, I don't recognize this file as being acceptable.
                        hr = S_FALSE;
                        break;
                    }
                    pszCurrPath += lstrlen(pszCurrPath) + 1;
                }

                SHFree(di.lpFileList);
            }
        }
        else
        {
            // NOTE: Win95/NT4 dont have this fix, you will fault if you hit this case!
            AssertMsg(FALSE, TEXT("hDrop contains the opposite TCHAR (UNICODE when on ANSI)"));
        }
        ReleaseStgMedium(&medium);
    }

    return hr;
}

HRESULT _LocalAddDTI(LPCSTR pszUrl, HWND hwnd, int x, int y, int nType)
{
    IActiveDesktop * pad;
    HRESULT hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pad));
    if (SUCCEEDED(hr))
    {
        COMPONENT comp = {
            sizeof(COMPONENT),              //Size of this structure
            0,                              //For Internal Use: Set it always to zero.
            nType,              //One of COMP_TYPE_*
            TRUE,           // Is this component enabled?
            FALSE,             // Had the component been modified and not yet saved to disk?
            FALSE,          // Is the component scrollable?
            {
                sizeof(COMPPOS),             //Size of this structure
                x - GetSystemMetrics(SM_XVIRTUALSCREEN),    //Left of top-left corner in screen co-ordinates.
                y - GetSystemMetrics(SM_YVIRTUALSCREEN),    //Top of top-left corner in screen co-ordinates.
                -1,            // Width in pixels.
                -1,           // Height in pixels.
                10000,            // Indicates the Z-order of the component.
                TRUE,         // Is the component resizeable?
                TRUE,        // Resizeable in X-direction?
                TRUE,        // Resizeable in Y-direction?
                -1,    //Left of top-left corner as percent of screen width
                -1     //Top of top-left corner as percent of screen height
            },              // Width, height etc.,
            L"\0",          // Friendly name of component.
            L"\0",          // URL of the component.
            L"\0",          // Subscrined URL.
            IS_NORMAL       // ItemState
        };
        SHAnsiToUnicodeCP(CP_UTF8, pszUrl, comp.wszSource, ARRAYSIZE(comp.wszSource));
        SHAnsiToUnicodeCP(CP_UTF8, pszUrl, comp.wszFriendlyName, ARRAYSIZE(comp.wszFriendlyName));
        SHAnsiToUnicodeCP(CP_UTF8, pszUrl, comp.wszSubscribedURL, ARRAYSIZE(comp.wszSubscribedURL));

        hr = pad->AddDesktopItemWithUI(hwnd, &comp, DTI_ADDUI_DISPSUBWIZARD);
        pad->Release();
    }
    return hr;
}

// Create Desktop Components for each item.

HRESULT ExecuteDeskCompHDrop(LPTSTR pszMultipleUrls, HWND hwnd, int x, int y)
{
    IActiveDesktop * pad;
    HRESULT hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pad));
    if (SUCCEEDED(hr))
    {
        COMPONENT comp = {
            sizeof(COMPONENT),              //Size of this structure
            0,                              //For Internal Use: Set it always to zero.
            COMP_TYPE_WEBSITE,              //One of COMP_TYPE_*
            TRUE,           // Is this component enabled?
            FALSE,             // Had the component been modified and not yet saved to disk?
            FALSE,          // Is the component scrollable?
            {
                sizeof(COMPPOS),             //Size of this structure
                x - GetSystemMetrics(SM_XVIRTUALSCREEN),    //Left of top-left corner in screen co-ordinates.
                y - GetSystemMetrics(SM_YVIRTUALSCREEN),    //Top of top-left corner in screen co-ordinates.
                -1,            // Width in pixels.
                -1,           // Height in pixels.
                10000,            // Indicates the Z-order of the component.
                TRUE,         // Is the component resizeable?
                TRUE,        // Resizeable in X-direction?
                TRUE,        // Resizeable in Y-direction?
                -1,    //Left of top-left corner as percent of screen width
                -1     //Top of top-left corner as percent of screen height
            },              // Width, height etc.,
            L"\0",          // Friendly name of component.
            L"\0",          // URL of the component.
            L"\0",          // Subscrined URL.
            IS_NORMAL       // ItemState
        };
        while (pszMultipleUrls[0])
        {
            SHTCharToUnicode(pszMultipleUrls, comp.wszSource, ARRAYSIZE(comp.wszSource));
            SHTCharToUnicode(pszMultipleUrls, comp.wszFriendlyName, ARRAYSIZE(comp.wszFriendlyName));
            SHTCharToUnicode(pszMultipleUrls, comp.wszSubscribedURL, ARRAYSIZE(comp.wszSubscribedURL));

            hr = pad->AddDesktopItemWithUI(hwnd, &comp, DTI_ADDUI_DISPSUBWIZARD);
            pszMultipleUrls += lstrlen(pszMultipleUrls) + 1;
        }

        pad->Release();
    }

    return hr;
}

typedef struct {
    LPSTR pszUrl;
    LPTSTR pszMultipleUrls;
    BOOL fMultiString;
    HWND hwnd;
    DWORD dwFlags;
    int x;
    int y;
} CREATEDESKCOMP;


// Create Desktop Components for one or mowe items.  We need to start
//    a thread to do this because it may take a while and we don't want
//    to block the UI thread because dialogs may be displayed.

DWORD CALLBACK _CreateDeskComp_ThreadProc(void *pvCreateDeskComp)
{
    CREATEDESKCOMP * pcdc = (CREATEDESKCOMP *) pvCreateDeskComp;

    HRESULT hr = OleInitialize(0);
    if (EVAL(SUCCEEDED(hr)))
    {
        if (pcdc->fMultiString)
        {
            hr = ExecuteDeskCompHDrop(pcdc->pszMultipleUrls, pcdc->hwnd, pcdc->x, pcdc->y);
            SHFree(pcdc->pszMultipleUrls);
        }
        else if (pcdc->dwFlags & DESKCOMP_URL)
        {
            hr = _LocalAddDTI(pcdc->pszUrl, pcdc->hwnd, pcdc->x, pcdc->y, COMP_TYPE_WEBSITE);
            Str_SetPtrA(&(pcdc->pszUrl), NULL);
        }
        else if (pcdc->dwFlags & DESKCOMP_IMAGE)
        {
            hr = _LocalAddDTI(pcdc->pszUrl, pcdc->hwnd, pcdc->x, pcdc->y, COMP_TYPE_PICTURE);
        }
        OleUninitialize();
    }

    LocalFree(pcdc);
    return 0;
}


/*********************************************************************\
        Create Desktop Components for one or mowe items.  We need to start
    a thread to do this because it may take a while and we don't want
    to block the UI thread because dialogs may be displayed.
\*********************************************************************/
HRESULT CreateDesktopComponents(LPCSTR pszUrl, IDataObject* pido, HWND hwnd, DWORD dwFlags, int x, int y)
{
    CREATEDESKCOMP *pcdc;
    HRESULT hr = SHLocalAlloc(sizeof(CREATEDESKCOMP), &pcdc);
    // Create Thread....
    if (SUCCEEDED(hr))
    {
        pcdc->pszUrl = NULL; // In case of failure.
        pcdc->pszMultipleUrls = NULL; // In case of failure.
        pcdc->fMultiString = (pido ? TRUE : FALSE);
        pcdc->hwnd = hwnd;
        pcdc->dwFlags = dwFlags;
        pcdc->x = x;
        pcdc->y = y;

        if (!pcdc->fMultiString)
        {
            Str_SetPtrA(&(pcdc->pszUrl), pszUrl);
        }
        else
        {
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;

            // asking for CF_HDROP
            hr = pido->GetData(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                HDROP hDrop = (HDROP)medium.hGlobal;
                DRAGINFO di;

                di.uSize = sizeof(di);
                if (DragQueryInfo(hDrop, &di))
                {
                    // di.lpFileList will be in TCHAR format -- see DragQueryInfo impl
                    pcdc->pszMultipleUrls = di.lpFileList;
                }
                else
                {
                    // NOTE: Win95/NT4 dont have this fix, you will fault if you hit this case!
                    AssertMsg(FALSE, TEXT("hDrop contains the opposite TCHAR (UNICODE when on ANSI)"));
                }
                ReleaseStgMedium(&medium);
            }
        }

        if (pcdc->pszUrl || pcdc->pszMultipleUrls)
        {
            if (SHCreateThread(_CreateDeskComp_ThreadProc, pcdc, CTF_INSIST | CTF_PROCESS_REF, NULL))
            {
                hr = S_OK;
            }
            else
            {
                hr = ResultFromLastError();
                LocalFree(pcdc);        
            }
        }
        else
        {
            hr = E_FAIL;
            LocalFree(pcdc);
        }
    }

    return hr;
}


// This is exported, as ordinal 184.  It was in shell32\smrttile.c, but no-one was using it
// internally, and it does not appear that anyone external is using it (verified that taskman
// on NT and W95 uses the win32 api's CascadeWindows and TileWindows.  This could probably be
// removed altogether.                                                    (t-saml, 12/97)
STDAPI_(WORD) ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND *ahwnd)
{
    ASSERT(0);
    return 0;
}

/*
    GetFileDescription retrieves the friendly name from a file's verion rsource.
    The first language we try will be the first item in the
    "\VarFileInfo\Translations" section;  if there's nothing there,
    we try the one coded into the IDS_VN_FILEVERSIONKEY resource string.
    If we can't even load that, we just use English (040904E4).  We
    also try English with a null codepage (04090000) since many apps
    were stamped according to an old spec which specified this as
    the required language instead of 040904E4.

    If there is no FileDescription in version resource, return the file name.

    Parameters:
        LPCTSTR pszPath: full path of the file
        LPTSTR pszDesc: pointer to the buffer to receive friendly name. If NULL,
                        *pcchDesc will be set to the length of friendly name in
                        characters, including ending NULL, on successful return.
        UINT *pcchDesc: length of the buffer in characters. On successful return,
                        it contains number of characters copied to the buffer,
                        including ending NULL.

    Return:
        TRUE on success, and FALSE otherwise
*/
STDAPI_(BOOL) GetFileDescription(LPCTSTR pszPath, LPTSTR pszDesc, UINT *pcchDesc)
{
    TCHAR szVersionKey[60];         /* big enough for anything we need */
    LPTSTR pszVersionKey = NULL;

    // Try same language as this program
    if (LoadString(HINST_THISDLL, IDS_VN_FILEVERSIONKEY, szVersionKey, ARRAYSIZE(szVersionKey)))
    {
        StrCatBuff(szVersionKey, TEXT("FileDescription"), SIZECHARS(szVersionKey));
        pszVersionKey = szVersionKey;
    }

    //  just use the default cut list
    return SHGetFileDescription(pszPath, pszVersionKey, NULL, pszDesc, pcchDesc);
}

STDAPI_(int) SHOutOfMemoryMessageBox(HWND hwnd, LPTSTR pszTitle, UINT fuStyle)
{
    TCHAR szOutOfMemory[128], szTitle[128];

    szTitle[0] = 0;

    if (pszTitle==NULL)
    {
        GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle));
        pszTitle = szTitle;
    }

    szOutOfMemory[0] = 0;

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ERROR_OUTOFMEMORY, 0, szOutOfMemory,
                          ARRAYSIZE(szOutOfMemory), NULL);
    int ret = MessageBox(hwnd, szOutOfMemory, pszTitle, fuStyle | MB_SETFOREGROUND);
    if (ret == -1)
    {
       DebugMsg(DM_TRACE, TEXT("regular message box failed, trying sysmodal"));
       ret = MessageBox(hwnd, szOutOfMemory, pszTitle, fuStyle | MB_SYSTEMMODAL);
    }

    return ret;
}


#define SZ_PATHLIST_SEPARATOR          TEXT(";")

BOOL SafePathListAppend(LPTSTR pszDestPath, DWORD cchDestSize, LPCTSTR pszPathToAdd)
{
    BOOL fResult = FALSE;

    if ((lstrlen(pszDestPath) + lstrlen(pszPathToAdd) + 1) < (long) cchDestSize)
    {
        // Do we need to add a ";" between pszDestPath and pszPathToAdd?
        if (pszDestPath[0] &&
            (SZ_PATHLIST_SEPARATOR[0] != pszDestPath[lstrlen(pszDestPath)-1]))
        {
            StrCat(pszDestPath, SZ_PATHLIST_SEPARATOR);
        }

        StrCat(pszDestPath, pszPathToAdd);
        fResult = TRUE;
    }

    return fResult;
}

bool IsDiscardablePropertySet(const FMTID & fmtid)
{
    if (IsEqualGUID(fmtid, FMTID_DiscardableInformation))
        return true;

    return false;
}

bool IsDiscardableStream(LPCTSTR pszStreamName)
{
    static const LPCTSTR _apszDiscardableStreams[] =
    {
        // Mike Hillberg claims this stream is discardable, and is used to
        //  hold a few state bytes for property set information

        TEXT(":{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}:$DATA")
    };

    for (int i = 0; i < ARRAYSIZE(_apszDiscardableStreams); i++)
    {
        if (0 == lstrcmpi(_apszDiscardableStreams[i], pszStreamName))
            return TRUE;
    }

    return FALSE;
}

LPTSTR NTFSPropSetMsg(LPCWSTR pszSrcObject, LPTSTR pszUserMessage)
{
    // Now look for native property NTFS sets
    IPropertySetStorage *pPropSetStorage;
    if (SUCCEEDED(StgOpenStorageEx(pszSrcObject,
                                   STGM_READ | STGM_DIRECT | STGM_SHARE_DENY_WRITE,
                                   STGFMT_FILE,
                                   0,0,0,
                                   IID_PPV_ARG(IPropertySetStorage, &pPropSetStorage))))
    {
        // Enum the property set storages available for this file

        IEnumSTATPROPSETSTG *pEnumSetStorage;
        if (SUCCEEDED(pPropSetStorage->Enum(&pEnumSetStorage)))
        {
            STATPROPSETSTG statPropSet[10];
            ULONG cSets;

            // Enum the property sets available in this property set storage

            while (SUCCEEDED(pEnumSetStorage->Next(ARRAYSIZE(statPropSet), statPropSet, &cSets)) && cSets > 0)
            {
                // For each property set we receive, open it and enumerate the
                // properties contained withing it

                for (ULONG iSet = 0; iSet < cSets; iSet++)
                {
                    if (FALSE == IsDiscardablePropertySet(statPropSet[iSet].fmtid))
                    {
                        TCHAR szText[MAX_PATH];
                        size_t cch = 0;

                        static const struct
                        {
                            const FMTID * m_pFMTID;
                            UINT          m_idTextID;
                        }
                        _aKnownPsets[] =
                        {
                            { &FMTID_SummaryInformation,          IDS_DOCSUMINFOSTREAM        },
                            { &FMTID_DocSummaryInformation,       IDS_SUMINFOSTREAM           },
                            { &FMTID_UserDefinedProperties,       IDS_USERDEFPROP             },
                            { &FMTID_ImageSummaryInformation,     IDS_IMAGEINFO               },
                            { &FMTID_AudioSummaryInformation,     IDS_AUDIOSUMINFO            },
                            { &FMTID_VideoSummaryInformation,     IDS_VIDEOSUMINFO            },
                            { &FMTID_MediaFileSummaryInformation, IDS_MEDIASUMINFO            }
                        };

                        // First try to map the fmtid to a better name than what the api gave us

                        for (int i = 0; i < ARRAYSIZE(_aKnownPsets); i++)
                        {
                            if (IsEqualGUID(*(_aKnownPsets[i].m_pFMTID), statPropSet[iSet].fmtid))
                            {
                                cch = LoadString(HINST_THISDLL, _aKnownPsets[i].m_idTextID, szText, ARRAYSIZE(szText));
                                break;
                            }
                        }

                        // No useful name... use Unidentied User Properties

                        if (0 == cch)
                            cch = LoadString(HINST_THISDLL,
                                                 IDS_UNKNOWNPROPSET,
                                                 szText, ARRAYSIZE(szText));

                        if (cch)
                        {
                            LPTSTR pszOldMessage = pszUserMessage;
                            if (pszOldMessage)
                            {
                                pszUserMessage = (TCHAR *) LocalReAlloc(pszOldMessage,
                                                                        (lstrlen(pszUserMessage) + cch + 3) * sizeof(TCHAR),
                                                                        LMEM_MOVEABLE);
                                if (pszUserMessage)
                                    lstrcat(pszUserMessage, TEXT("\r\n"));
                            }
                            else
                                pszUserMessage = (TCHAR *) LocalAlloc(LPTR, (cch + 1) * sizeof(TCHAR));

                            if (NULL == pszUserMessage)
                                pszUserMessage = pszOldMessage; // Can't grow it, but at least keep what we know so far
                            else
                                lstrcat(pszUserMessage, szText); // Index 1 to skip the \005
                        }
                    }
                }
            }
            pEnumSetStorage->Release();
        }
        pPropSetStorage->Release();
    }
    return pszUserMessage;
}

// GetDownlevelCopyDataLossText
//
// If data will be lost on a downlevel copy from NTFS to FAT, we return
// a string containing a description of the data that will be lost,
// suitable for display to the user.  String must be freed by the caller.
//
// If nothing will be lost, a NULL is returned.
//
// pbDirIsSafe points to a BOOL passed in by the caller.  On return, if
// *pbDirIsSafe has been set to TRUE, no further data loss could occur
// in this directory
//
// Davepl 01-Mar-98

#define NT_FAILED(x) NT_ERROR(x)   // More consistent name for this macro

LPWSTR GetDownlevelCopyDataLossText(LPCWSTR pszSrcObject, LPCWSTR pszDestDir, BOOL bIsADir, BOOL *pbDirIsSafe)
{
    OBJECT_ATTRIBUTES               SrcObjectAttributes;
    OBJECT_ATTRIBUTES               DestObjectAttributes;
    IO_STATUS_BLOCK                 IoStatusBlock;
    HANDLE SrcObjectHandle            = INVALID_HANDLE_VALUE;
    HANDLE DestPathHandle           = INVALID_HANDLE_VALUE;
    UNICODE_STRING                  UnicodeSrcObject;
    UNICODE_STRING                  UnicodeDestPath;

    *pbDirIsSafe = FALSE;

    // pAttributeInfo will point to enough stack to hold the
    // FILE_FS_ATTRIBUTE_INFORMATION and worst-case filesystem name

    size_t cbAttributeInfo          = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) +
                                         MAX_PATH * sizeof(TCHAR);
    PFILE_FS_ATTRIBUTE_INFORMATION  pAttributeInfo =
                                      (PFILE_FS_ATTRIBUTE_INFORMATION) _alloca(cbAttributeInfo);

    // Covert the conventional paths to UnicodePath descriptors

    RtlInitUnicodeString(&UnicodeSrcObject, pszSrcObject);
    if (!RtlDosPathNameToNtPathName_U(pszSrcObject, &UnicodeSrcObject, NULL, NULL))
    {
        AssertMsg(FALSE, TEXT("RtlDosPathNameToNtPathName_U failed for source."));
        return NULL;
    }

    RtlInitUnicodeString(&UnicodeDestPath, pszDestDir);
    if (!RtlDosPathNameToNtPathName_U(pszDestDir, &UnicodeDestPath, NULL, NULL))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        AssertMsg(FALSE, TEXT("RtlDosPathNameToNtPathName_U failed for dest."));
        return NULL;
    }

    // Build an NT object descriptor from the UnicodeSrcObject

    InitializeObjectAttributes(&SrcObjectAttributes,  &UnicodeSrcObject, OBJ_CASE_INSENSITIVE, NULL, NULL);
    InitializeObjectAttributes(&DestObjectAttributes, &UnicodeDestPath,  OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Open the file for generic read, and the dest path for attribute read

    NTSTATUS NtStatus = NtOpenFile(&SrcObjectHandle, FILE_GENERIC_READ, &SrcObjectAttributes,
                          &IoStatusBlock, FILE_SHARE_READ, (bIsADir ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE));
    if (NT_FAILED(NtStatus))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDestPath.Buffer);
        return NULL;
    }

    NtStatus = NtOpenFile(&DestPathHandle, FILE_READ_ATTRIBUTES, &DestObjectAttributes,
                          &IoStatusBlock, FILE_SHARE_READ, FILE_DIRECTORY_FILE);
    if (NT_FAILED(NtStatus))
    {
        NtClose(SrcObjectHandle);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDestPath.Buffer);
        return NULL;
    }

    // Incrementally try allocation sizes for the ObjectStreamInformation,
    // then retrieve the actual stream info

    BYTE * pBuffer = NULL;

    __try   // Current and future allocations and handles free'd by __finally block
    {
        size_t cbBuffer;
        LPTSTR pszUserMessage = NULL;

        // Quick check of filesystem type for this file

        NtStatus = NtQueryVolumeInformationFile(
                    SrcObjectHandle,
                    &IoStatusBlock,
                    (BYTE *) pAttributeInfo,
                    cbAttributeInfo,
                    FileFsAttributeInformation
                   );

        if (NT_FAILED(NtStatus))
            return NULL;

        // If the source filesystem isn't NTFS, we can just bail now

        pAttributeInfo->FileSystemName[
            (pAttributeInfo->FileSystemNameLength / sizeof(WCHAR)) ] = L'\0';

        if (0 == StrStrIW(pAttributeInfo->FileSystemName, L"NTFS"))
        {
            *pbDirIsSafe = TRUE;
            return NULL;
        }

        NtStatus = NtQueryVolumeInformationFile(
                    DestPathHandle,
                    &IoStatusBlock,
                    (BYTE *) pAttributeInfo,
                    cbAttributeInfo,
                    FileFsAttributeInformation
                   );

        if (NT_FAILED(NtStatus))
            return NULL;

        // If the target filesystem is NTFS, no stream loss will happen

        pAttributeInfo->FileSystemName[
            (pAttributeInfo->FileSystemNameLength / sizeof(WCHAR)) ] = L'\0';
        if (StrStrIW(pAttributeInfo->FileSystemName, L"NTFS"))
        {
            *pbDirIsSafe = TRUE;
            return NULL;
        }

        // At this point we know we're doing an NTFS->FAT copy, so we need
        // to find out whether or not the source file has multiple streams

        // pBuffer will point to enough memory to hold the worst case for
        // a single stream.

        cbBuffer = sizeof(FILE_STREAM_INFORMATION) + MAX_PATH * sizeof(WCHAR);
        if (NULL == (pBuffer = (BYTE *) LocalAlloc(LPTR, cbBuffer)))
            return NULL;
        do
        {
            BYTE * pOldBuffer = pBuffer;
            if (NULL == (pBuffer = (BYTE *) LocalReAlloc(pBuffer, cbBuffer, LMEM_MOVEABLE)))
            {
                LocalFree(pOldBuffer);
                return NULL;
            }

            NtStatus = NtQueryInformationFile(SrcObjectHandle, &IoStatusBlock, pBuffer, cbBuffer,
                                            FileStreamInformation);
            cbBuffer *= 2;
        } while (STATUS_BUFFER_OVERFLOW == NtStatus);

        if (NT_SUCCESS(NtStatus))
        {
            FILE_STREAM_INFORMATION * pStreamInfo = (FILE_STREAM_INFORMATION *) pBuffer;
            BOOL bLastPass = (0 == pStreamInfo->NextEntryOffset);

            if (bIsADir)
            {
                // From experimentation, it seems that if there's only one stream on a directory and
                // it has a zero-length name, its a vanilla directory

                if ((0 == pStreamInfo->NextEntryOffset) && (0 == pStreamInfo->StreamNameLength))
                    return NULL;
            }
            else // File
            {
                // Single stream only if first stream has no next offset

                if ((0 == pStreamInfo->NextEntryOffset) && (pBuffer == (BYTE *) pStreamInfo))
                    return NULL;
            }

            for(;;)
            {
                int i;
                TCHAR szText[MAX_PATH];

                // Table of known stream names and the string IDs that we actually want to show
                // to the user instead of the raw stream name.

                static const struct _ADATATYPES
                {
                    LPCTSTR m_pszStreamName;
                    UINT    m_idTextID;
                }
                _aDataTypes[] =
                {
                    { TEXT("::"),                               0                    },
                    { TEXT(":AFP_AfpInfo:"),                    IDS_MACINFOSTREAM    },
                    { TEXT(":AFP_Resource:"),                   IDS_MACRESSTREAM     }
                };

                if (FALSE == IsDiscardableStream(pStreamInfo->StreamName))
                {
                    for (i = 0; i < ARRAYSIZE(_aDataTypes); i++)
                    {

                        // Can't use string compare since they choke on the \005 character
                        // used in property storage streams
                        int cbComp = min(lstrlen(pStreamInfo->StreamName) * sizeof(TCHAR),
                                         lstrlen(_aDataTypes[i].m_pszStreamName) * sizeof(TCHAR));
                        if (0 == memcmp(_aDataTypes[i].m_pszStreamName,
                                        pStreamInfo->StreamName,
                                        cbComp))
                        {
                            break;
                        }
                    }

                    size_t cch = 0;
                    if (i == ARRAYSIZE(_aDataTypes))
                    {
                        // Not found, so use the actual stream name, unless it has a \005
                        // at the beginning of its name, in which case we'll pick this one
                        // up when we check for property sets.

                        if (pStreamInfo->StreamName[1] ==  TEXT('\005'))
                            cch = 0;
                        else
                        {
                            lstrcpy(szText, pStreamInfo->StreamName);
                            cch = lstrlen(szText);
                        }
                    }
                    else
                    {
                        // We found this stream in our table of well-known streams, so
                        // load the string which the user will see describing this stream,
                        // as we likely have a more useful name than the stream itself.

                        cch = _aDataTypes[i].m_idTextID ?
                                  LoadString(HINST_THISDLL, _aDataTypes[i].m_idTextID, szText, ARRAYSIZE(szText))
                                  : 0;
                    }

                    // Reallocate the overall buffer to be large enough to add this new
                    // stream description, plus 2 chars for the crlf

                    if (cch)
                    {
                        LPTSTR pszOldMessage = pszUserMessage;
                        if (pszOldMessage)
                        {
                            pszUserMessage = (TCHAR *) LocalReAlloc(pszOldMessage,
                                                                    (lstrlen(pszUserMessage) + cch + 3) * sizeof(TCHAR),
                                                                    LMEM_MOVEABLE);
                            if (pszUserMessage)
                                lstrcat(pszUserMessage, TEXT("\r\n"));
                        }
                        else
                            pszUserMessage = (TCHAR *) LocalAlloc(LPTR, (cch + 1) * sizeof(TCHAR));


                        if (NULL == pszUserMessage)
                            return pszOldMessage; // Can't grow it, but at least return what we know so far

                        lstrcat(pszUserMessage, szText);
                    }
                }

                if (bLastPass)
                    break;

                pStreamInfo = (FILE_STREAM_INFORMATION *) (((BYTE *) pStreamInfo) + pStreamInfo->NextEntryOffset);
                bLastPass = (0 == pStreamInfo->NextEntryOffset);
            }
        }

        pszUserMessage = NTFSPropSetMsg(pszSrcObject, pszUserMessage);

        return pszUserMessage;
    }
    __finally   // Cleanup
    {
        if (pBuffer)
            LocalFree(pBuffer);

        NtClose(SrcObjectHandle);
        NtClose(DestPathHandle);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeSrcObject.Buffer);
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDestPath.Buffer);
    }

    return NULL;
}

// lstrcmp? uses thread lcid.  but in UI visual sorting, we need
// to use the user's choice. (thus the u in ustrcmp)
int _ustrcmp(LPCTSTR psz1, LPCTSTR psz2, BOOL fCaseInsensitive)
{
    COMPILETIME_ASSERT(CSTR_LESS_THAN == 1);
    COMPILETIME_ASSERT(CSTR_EQUAL  == 2);
    COMPILETIME_ASSERT(CSTR_GREATER_THAN  == 3);
    return (CompareString(LOCALE_USER_DEFAULT,
                         fCaseInsensitive ? NORM_IGNORECASE : 0,
                         psz1, -1, psz2, -1) - CSTR_EQUAL);
}

void HWNDWSPrintf(HWND hwnd, LPCTSTR psz)
{
    TCHAR szTemp[2048];
    TCHAR szTemp1[2048];

    GetWindowText(hwnd, szTemp, ARRAYSIZE(szTemp));
    wnsprintf(szTemp1, ARRAYSIZE(szTemp1), szTemp, psz);
    SetWindowText(hwnd, szTemp1);
}

STDAPI_(BOOL) Priv_Str_SetPtrW(WCHAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew)
{
    LPWSTR pwzOld;
    LPWSTR pwzNewCopy = NULL;

    if (pwzNew)
    {
        int cchLength = lstrlenW(pwzNew);

        // alloc a new buffer w/ room for the null terminator
        pwzNewCopy = (LPWSTR) LocalAlloc(LPTR, (cchLength + 1) * sizeof(WCHAR));

        if (!pwzNewCopy)
            return FALSE;

        StrCpyNW(pwzNewCopy, pwzNew, cchLength + 1);
    }

    pwzOld = (LPWSTR) InterlockedExchangePointer((void * *)ppwzCurrent, pwzNewCopy);

    if (pwzOld)
        LocalFree(pwzOld);

    return TRUE;
}

// combines pidlParent with part of pidl, upto pidlNext, example:
//
// in:
//      pidlParent      [c:] [windows]
//      pidl                           [system] [foo.txt]
//      pidlNext                              --^
//
// returns:
//                      [c:] [windows] [system]
//

STDAPI_(LPITEMIDLIST) ILCombineParentAndFirst(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNext)
{
    ULONG cbParent = ILGetSize(pidlParent);
    ULONG cbRest   = (ULONG)((ULONG_PTR)pidlNext - (ULONG_PTR)pidl);
    LPITEMIDLIST pidlNew = _ILCreate(cbParent + cbRest);
    if (pidlNew)
    {
        cbParent -= sizeof(pidlParent->mkid.cb);
        memcpy(pidlNew, pidlParent, cbParent);
        memcpy((BYTE *)pidlNew + cbParent, pidl, cbRest);
        ASSERT(_ILSkip(pidlNew, cbParent + cbRest)->mkid.cb == 0);
    }
    return pidlNew;
}


STDAPI_(LPTSTR) DumpPidl(LPCITEMIDLIST pidl)
{
#ifdef DEBUG
    static TCHAR szBuf[MAX_PATH];
    TCHAR szTmp[MAX_PATH];
    USHORT cb;
    LPTSTR pszT;

    szBuf[0] = 0;

    if (NULL == pidl)
    {
        lstrcatn(szBuf, TEXT("Empty pidl"), ARRAYSIZE(szBuf));
        return szBuf;
    }

    while (!ILIsEmpty(pidl))
    {
        cb = pidl->mkid.cb;
        wsprintf(szTmp, TEXT("cb:%x id:"), cb);
        lstrcatn(szBuf, szTmp, ARRAYSIZE(szBuf));

        switch (SIL_GetType(pidl) & SHID_TYPEMASK)
        {
        case SHID_ROOT:                pszT = TEXT("SHID_ROOT"); break;
        case SHID_ROOT_REGITEM:        pszT = TEXT("SHID_ROOT_REGITEM"); break;
        case SHID_COMPUTER:            pszT = TEXT("SHID_COMPUTER"); break;
        case SHID_COMPUTER_1:          pszT = TEXT("SHID_COMPUTER_1"); break;
        case SHID_COMPUTER_REMOVABLE:  pszT = TEXT("SHID_COMPUTER_REMOVABLE"); break;
        case SHID_COMPUTER_FIXED:      pszT = TEXT("SHID_COMPUTER_FIXED"); break;
        case SHID_COMPUTER_REMOTE:     pszT = TEXT("SHID_COMPUTER_REMOTE"); break;
        case SHID_COMPUTER_CDROM:      pszT = TEXT("SHID_COMPUTER_CDROM"); break;
        case SHID_COMPUTER_RAMDISK:    pszT = TEXT("SHID_COMPUTER_RAMDISK"); break;
        case SHID_COMPUTER_7:          pszT = TEXT("SHID_COMPUTER_7"); break;
        case SHID_COMPUTER_DRIVE525:   pszT = TEXT("SHID_COMPUTER_DRIVE525"); break;
        case SHID_COMPUTER_DRIVE35:    pszT = TEXT("SHID_COMPUTER_DRIVE35"); break;
        case SHID_COMPUTER_NETDRIVE:   pszT = TEXT("SHID_COMPUTER_NETDRIVE"); break;
        case SHID_COMPUTER_NETUNAVAIL: pszT = TEXT("SHID_COMPUTER_NETUNAVAIL"); break;
        case SHID_COMPUTER_C:          pszT = TEXT("SHID_COMPUTER_C"); break;
        case SHID_COMPUTER_D:          pszT = TEXT("SHID_COMPUTER_D"); break;
        case SHID_COMPUTER_REGITEM:    pszT = TEXT("SHID_COMPUTER_REGITEM"); break;
        case SHID_COMPUTER_MISC:       pszT = TEXT("SHID_COMPUTER_MISC"); break;
        case SHID_FS:                  pszT = TEXT("SHID_FS"); break;
        case SHID_FS_TYPEMASK:         pszT = TEXT("SHID_FS_TYPEMASK"); break;
        case SHID_FS_DIRECTORY:        pszT = TEXT("SHID_FS_DIRECTORY"); break;
        case SHID_FS_FILE:             pszT = TEXT("SHID_FS_FILE"); break;
        case SHID_FS_UNICODE:          pszT = TEXT("SHID_FS_UNICODE"); break;
        case SHID_FS_DIRUNICODE:       pszT = TEXT("SHID_FS_DIRUNICODE"); break;
        case SHID_FS_FILEUNICODE:      pszT = TEXT("SHID_FS_FILEUNICODE"); break;
        case SHID_NET:                 pszT = TEXT("SHID_NET"); break;
        case SHID_NET_DOMAIN:          pszT = TEXT("SHID_NET_DOMAIN"); break;
        case SHID_NET_SERVER:          pszT = TEXT("SHID_NET_SERVER"); break;
        case SHID_NET_SHARE:           pszT = TEXT("SHID_NET_SHARE"); break;
        case SHID_NET_FILE:            pszT = TEXT("SHID_NET_FILE"); break;
        case SHID_NET_GROUP:           pszT = TEXT("SHID_NET_GROUP"); break;
        case SHID_NET_NETWORK:         pszT = TEXT("SHID_NET_NETWORK"); break;
        case SHID_NET_RESTOFNET:       pszT = TEXT("SHID_NET_RESTOFNET"); break;
        case SHID_NET_SHAREADMIN:      pszT = TEXT("SHID_NET_SHAREADMIN"); break;
        case SHID_NET_DIRECTORY:       pszT = TEXT("SHID_NET_DIRECTORY"); break;
        case SHID_NET_TREE:            pszT = TEXT("SHID_NET_TREE"); break;
        case SHID_NET_REGITEM:         pszT = TEXT("SHID_NET_REGITEM"); break;
        case SHID_NET_PRINTER:         pszT = TEXT("SHID_NET_PRINTER"); break;
        default:                       pszT = TEXT("unknown"); break;
        }
        lstrcatn(szBuf, pszT, ARRAYSIZE(szBuf));

        if (SIL_GetType(pidl) & SHID_JUNCTION)
        {
            lstrcatn(szBuf, TEXT(", junction"), ARRAYSIZE(szBuf));
        }

        pidl = _ILNext(pidl);

        if (!ILIsEmpty(pidl))
        {
            lstrcatn(szBuf, TEXT("; "), ARRAYSIZE(szBuf));
        }
    }

    return szBuf;
#else
    return TEXT("");
#endif // DEBUG
}

STDAPI SaveShortcutInFolder(int csidl, LPTSTR pszName, IShellLink *psl)
{
    TCHAR szPath[MAX_PATH];

    HRESULT hr = SHGetFolderPath(NULL, csidl | CSIDL_FLAG_CREATE, NULL, 0, szPath);
    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;

        hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            PathAppend(szPath, pszName);

            WCHAR wszPath[MAX_PATH];
            SHTCharToUnicode(szPath, wszPath, ARRAYSIZE(wszPath));

            hr = ppf->Save(wszPath, TRUE);
            ppf->Release();
        }
    }
    return hr;
}


// TrackPopupMenu does not work, if the hwnd does not have
// the input focus. We believe this is a bug in USER

STDAPI_(BOOL) SHTrackPopupMenu(HMENU hmenu, UINT wFlags, int x, int y,
                                 int wReserved, HWND hwndOwner, LPCRECT lprc)
{
    int iRet = FALSE;
    DWORD dwExStyle = 0L;
    if (IS_WINDOW_RTL_MIRRORED(hwndOwner))
    {
        dwExStyle |= RTL_MIRRORED_WINDOW;
    }
    HWND hwndDummy = CreateWindowEx(dwExStyle, TEXT("Static"), NULL,
                           0, x, y, 1, 1, HWND_DESKTOP,
                           NULL, HINST_THISDLL, NULL);
    if (hwndDummy)
    {
        HWND hwndPrev = GetForegroundWindow();  // to restore

        SetForegroundWindow(hwndDummy);
        SetFocus(hwndDummy);
        iRet = TrackPopupMenu(hmenu, wFlags, x, y, wReserved, hwndDummy, lprc);

        //
        // We MUST unlock the destination window before changing its Z-order.
        //
        DAD_DragLeave();

        if (iRet && hwndOwner)
        {
            // non-cancel item is selected. Make the hwndOwner foreground.
            SetForegroundWindow(hwndOwner);
            SetFocus(hwndOwner);
        }
        else
        {
            // The user canceled the menu.
            // Restore the previous foreground window (before destroying hwndDummy).
            if (hwndPrev)
                SetForegroundWindow(hwndPrev);
        }

        DestroyWindow(hwndDummy);
    }

    return iRet;
}

//
// user does not support pop-up only menu.
//
STDAPI_(HMENU) SHLoadPopupMenu(HINSTANCE hinst, UINT id)
{
    HMENU hmenuParent = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (hmenuParent)
    {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }
    return NULL;
}

STDAPI_(void) PathToAppPathKeyBase(LPCTSTR pszBase, LPCTSTR pszPath, LPTSTR pszKey, int cchKey)
{
    // Use the szTemp variable of pseem to build key to the programs specific
    // key in the registry as well as other things...
    StrCpyN(pszKey, pszBase, cchKey);
    lstrcatn(pszKey, TEXT("\\"), cchKey);
    lstrcatn(pszKey, PathFindFileName(pszPath), cchKey);

    // Currently we will only look up .EXE if an extension is not
    // specified
    if (*PathFindExtension(pszKey) == 0)
    {
        lstrcatn(pszKey, c_szDotExe, cchKey);
    }
}

STDAPI_(void) PathToAppPathKey(LPCTSTR pszPath, LPTSTR pszKey, int cchKey)
{
    PathToAppPathKeyBase(REGSTR_PATH_APPPATHS, pszPath, pszKey, cchKey);

#ifdef _WIN64
    //
    //  If the app isn't registered under Win64's AppPath,
    //  then try the 32-bit version.
    //
#define REGSTR_PATH_APPPATHS32 TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\App Paths")
    LONG cb;
    if (RegQueryValue(HKEY_LOCAL_MACHINE, pszKey, 0, &cb) == ERROR_FILE_NOT_FOUND)
    {
        PathToAppPathKeyBase(REGSTR_PATH_APPPATHS32, pszPath, pszKey, cchKey);
    }
#endif
}

// out:
//      pszResultPath   assumed to be MAX_PATH in length

STDAPI_(BOOL) PathToAppPath(LPCTSTR pszPath, LPTSTR pszResultPath)
{
    TCHAR szRegKey[MAX_PATH];
    LONG cbData = MAX_PATH * sizeof(TCHAR);

    VDATEINPUTBUF(pszResultPath, TCHAR, MAX_PATH);

    PathToAppPathKey(pszPath, szRegKey, ARRAYSIZE(szRegKey));

    return SHRegQueryValue(HKEY_LOCAL_MACHINE, szRegKey, pszResultPath, &cbData) == ERROR_SUCCESS;
}

HWND GetTopParentWindow(HWND hwnd)
{
    if (IsWindow(hwnd))
    {
        HWND hwndParent;
        while (NULL != (hwndParent = GetWindow(hwnd, GW_OWNER)))
            hwnd = hwndParent;
    }
    else
        hwnd = NULL;

    return hwnd;
}


BOOL _IsLink(LPCTSTR pszPath, DWORD dwAttributes)
{
    SHFILEINFO sfi = {0};
    DWORD dwFlags = SHGFI_ATTRIBUTES | SHGFI_ATTR_SPECIFIED;

    sfi.dwAttributes = SFGAO_LINK;  // setup in param (SHGFI_ATTR_SPECIFIED requires this)

    if (-1 != dwAttributes)
        dwFlags |= SHGFI_USEFILEATTRIBUTES;

    return SHGetFileInfo(pszPath, dwAttributes, &sfi, sizeof(sfi), dwFlags) &&
        (sfi.dwAttributes & SFGAO_LINK);
}

STDAPI_(BOOL) PathIsShortcut(LPCTSTR pszPath, DWORD dwAttributes)
{
    BOOL bRet = FALSE;
    BOOL bMightBeFile;

    if (-1 == dwAttributes)
        bMightBeFile = TRUE;      // optmistically assume it is (to get shortcircut cases)
    else
        bMightBeFile = !(FILE_ATTRIBUTE_DIRECTORY & dwAttributes);

    // optimistic shortcurcut. if we don't know it is a folder for sure use the extension test
    if (bMightBeFile)
    {
        if (PathIsLnk(pszPath))
        {
            bRet = TRUE;    // quick short-circut for perf
        }
        else if (PathIsExe(pszPath))
        {
            bRet = FALSE;   // quick short-cut to avoid blowing stack on Win16
        }
        else
        {
            bRet = _IsLink(pszPath, dwAttributes);
        }
    }
    else
    {
        bRet = _IsLink(pszPath, dwAttributes);
    }
    return bRet;
}

HRESULT _UIObject_AssocCreate(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    //  this means that the folder doesnt support
    //  the IQueryAssociations.  so we will
    //  just check to see if this is a folder.
    //
    //  some shellextensions mask the FILE system
    //  and want the file system associations to show
    //  up for their items.  so we will try a simple pidl
    //
    HRESULT hr = E_NOTIMPL;
    DWORD rgfAttrs = SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_FILESYSTEM);
    if (rgfAttrs & SFGAO_FILESYSTEM)
    {
        TCHAR sz[MAX_PATH];
        hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, sz, ARRAYSIZE(sz));
        if (SUCCEEDED(hr))
        {
            WIN32_FIND_DATA fd = {0};
            LPITEMIDLIST pidlSimple;

            if (rgfAttrs & SFGAO_FOLDER)
                fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;

            hr = SHSimpleIDListFromFindData(sz, &fd, &pidlSimple);
            if (SUCCEEDED(hr))
            {
                //  need to avoid recursion, so we cant call SHGetUIObjectOf()
                hr = SHGetUIObjectFromFullPIDL(pidlSimple, NULL, riid, ppv);
                ILFree(pidlSimple);
            }
        }
    }

    if (FAILED(hr) && (rgfAttrs & (SFGAO_FOLDER | SFGAO_BROWSABLE)))
    {
        IAssociationArrayInitialize *paa;
        //  make sure at least folders work.
        hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IAssociationArrayInitialize, &paa));
        if (SUCCEEDED(hr))
        {
            hr = paa->InitClassElements(0, L"Folder");
            if (SUCCEEDED(hr))
            {
                hr = paa->QueryInterface(riid, ppv);
            }
            paa->Release();
        }
    }
        
    return hr;
}

typedef HRESULT (* PFNUIOBJECTHELPER)(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

typedef struct
{
    const IID *piidDesired;
    const IID *piidAlternate;
    PFNUIOBJECTHELPER pfn;
} UIOBJECTMAP;

static const UIOBJECTMAP c_rgUIObjectMap[] = 
{
    {&IID_IQueryAssociations, NULL, _UIObject_AssocCreate},
    {&IID_IAssociationArray, &IID_IQueryAssociations, _UIObject_AssocCreate},
//    {&IID_IContextMenu2, &IID_IContextMenu, NULL},
};

const UIOBJECTMAP *_GetUiObjectMap(REFIID riid)
{
    for (int i = 0; i < ARRAYSIZE(c_rgUIObjectMap); i++)
    {
        if (riid == *(c_rgUIObjectMap[i].piidDesired))
            return &c_rgUIObjectMap[i];
    }
    return NULL;
}

STDAPI UIObjectOf(IShellFolder *psf, LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = psf->GetUIObjectOf(hwnd, 1, &pidl, riid, NULL, ppv);
    if (FAILED(hr))
    {
        const UIOBJECTMAP *pmap = _GetUiObjectMap(riid);
        if (pmap)
        {
            if (pmap->piidAlternate)
            {
                IUnknown *punk;
                hr = psf->GetUIObjectOf(hwnd, 1, &pidl, *(pmap->piidAlternate), NULL, (void **)&punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(riid, ppv);
                    punk->Release();
                }
            }

            //  let the fallback code run
            if (FAILED(hr) && pmap->pfn)
            {
                hr = pmap->pfn(psf, pidl, riid, ppv);
            }
        }
    }
    return hr;
}

STDAPI AssocGetDetailsOfSCID(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv, BOOL *pfFoundScid)
{
    *pfFoundScid = FALSE;
    HRESULT hr = E_NOTIMPL;
    static const struct 
    {
        const SHCOLUMNID *pscid;
        ASSOCQUERY query;
        LPCWSTR pszCue;
    } s_rgAssocSCIDs[] = 
    {
        { &SCID_DetailsProperties, AQN_NAMED_VALUE, L"Details"},
    };

    for (int i = 0; i < ARRAYSIZE(s_rgAssocSCIDs); i++)
    {
        if (IsEqualSCID(*pscid, *(s_rgAssocSCIDs[i].pscid)))
        {
            IAssociationArray *paa;
            hr = UIObjectOf(psf, pidl, NULL, IID_PPV_ARG(IAssociationArray, &paa));
            if (SUCCEEDED(hr))
            {
                CSmartCoTaskMem<WCHAR> spsz;
                hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, s_rgAssocSCIDs[i].query, s_rgAssocSCIDs[i].pszCue, &spsz);
                if (SUCCEEDED(hr))
                {
                    hr = InitVariantFromStr(pv, spsz);
                }
                paa->Release();
            }
            break;
        }
    }
    return hr;
}

//
// retrieves the UIObject interface for the specified full pidl.
//
STDAPI SHGetUIObjectOf(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = UIObjectOf(psf, pidlChild, hwnd, riid, ppv);
        psf->Release();
    }

    return hr;
}


STDAPI SHGetAssociations(LPCITEMIDLIST pidl, void **ppv)
{
    return SHGetUIObjectOf(pidl, NULL, IID_IQueryAssociations, ppv);
}

//
//  SHGetAssocKeys() retrieves an array of class keys
//  from a pqa.
//
//  if the caller is just interested in the primary class key,
//  call with cKeys == 1.  the return value is the number of keys
//  inserted into the array.
//

STDAPI AssocKeyFromElement(IAssociationElement *pae, HKEY *phk)
{
    IObjectWithQuerySource *powqs;
    HRESULT hr = pae->QueryInterface(IID_PPV_ARG(IObjectWithQuerySource, &powqs));
    if (SUCCEEDED(hr))
    {
        IObjectWithRegistryKey *powrk;
        hr = powqs->GetSource(IID_PPV_ARG(IObjectWithRegistryKey, &powrk));
        if (SUCCEEDED(hr))
        {
            hr = powrk->GetKey(phk);
            powrk->Release();
        }
        powqs->Release();
    }
    return hr;
}

HRESULT AssocElemCreateForClass(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae)
{
    IPersistString2 *pips;
    HRESULT hr = AssocCreate(*pclsid, IID_PPV_ARG(IPersistString2, &pips));
    if (SUCCEEDED(hr))
    {
        hr = pips->SetString(pszClass);
        if (SUCCEEDED(hr))
        {
            hr = pips->QueryInterface(IID_PPV_ARG(IAssociationElement, ppae));
        }
        pips->Release();
    }
    return hr;
}

HRESULT AssocElemCreateForKey(const CLSID *pclsid, HKEY hk, IAssociationElement **ppae)
{
    IObjectWithQuerySource *powqs;
    HRESULT hr = AssocCreate(*pclsid, IID_PPV_ARG(IObjectWithQuerySource, &powqs));
    if (SUCCEEDED(hr))
    {
        IQuerySource *pqs;
        hr = QuerySourceCreateFromKey(hk, NULL, FALSE, IID_PPV_ARG(IQuerySource, &pqs));
        if (SUCCEEDED(hr))
        {
            hr = powqs->SetSource(pqs);
            if (SUCCEEDED(hr))
            {
                hr = powqs->QueryInterface(IID_PPV_ARG(IAssociationElement, ppae));
            }
            pqs->Release();
        }
        powqs->Release();
    }
    return hr;
}


STDAPI_(DWORD) SHGetAssocKeysEx(IAssociationArray *paa, ASSOCELEM_MASK mask, HKEY *rgKeys, DWORD cKeys)
{
    DWORD cRet = 0;
    IEnumAssociationElements *penum;
    HRESULT hr = paa->EnumElements(mask, &penum);
    if (SUCCEEDED(hr))
    {
        IAssociationElement *pae;
        ULONG c;
        while (cRet < cKeys && S_OK == penum->Next(1, &pae, &c))
        {
            if (SUCCEEDED(AssocKeyFromElement(pae, &rgKeys[cRet])))
                cRet++;
                
            pae->Release();
        }
        penum->Release();
    }
    return cRet;
}

DWORD SHGetAssocKeys(IQueryAssociations *pqa, HKEY *rgKeys, DWORD cKeys)
{
    IAssociationArray *paa;
    if (SUCCEEDED(pqa->QueryInterface(IID_PPV_ARG(IAssociationArray, &paa))))
    {
        cKeys = SHGetAssocKeysEx(paa, ASSOCELEM_MASK_ENUMCONTEXTMENU, rgKeys, cKeys);
        paa->Release();
    }
    else
        cKeys = 0;

    return cKeys;
}

STDAPI_(DWORD) SHGetAssocKeysForIDList(LPCITEMIDLIST pidl, HKEY *rghk, DWORD ck)
{
    IQueryAssociations *pqa;
    if (SUCCEEDED(SHGetAssociations(pidl, (void **)&pqa)))
    {
        ck = SHGetAssocKeys(pqa, rghk, ck);
        pqa->Release();
    }
    else
        ck = 0;

    return ck;
}


// NOTE:
//  this API returns a win32 file system path for the item in the name space
//  and has a few special cases that include returning UNC printer names too!

STDAPI_(BOOL) SHGetPathFromIDListEx(LPCITEMIDLIST pidl, LPTSTR pszPath, UINT uOpts)
{
    VDATEINPUTBUF(pszPath, TCHAR, MAX_PATH);
    HRESULT hr;

    *pszPath = 0;    // zero output buffer

    if (!pidl)
        return FALSE;   // bad params

    if (ILIsEmpty(pidl))
    {
        // desktop special case because we can not depend on the desktop
        // returning a file system path (APP compat)
        hr = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, pszPath);
        if (hr == S_FALSE)
            hr = E_FAIL;
    }
    else
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            hr = DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING, pszPath, MAX_PATH);
            if (SUCCEEDED(hr))
            {
                DWORD dwAttributes = SFGAO_FILESYSTEM;
                hr = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlLast, &dwAttributes);
                if (SUCCEEDED(hr) && !(dwAttributes & SFGAO_FILESYSTEM))
                {
                    // special case for UNC printer names. this is an app
                    // compat issue (HP LaserJet 2100 setup) & some Semantic apps
                    if (uOpts & GPFIDL_UNCPRINTER)
                    {
                        CLSID clsid;
                        hr = IUnknown_GetClassID(psf, &clsid);
                        if (FAILED(hr) || (clsid != CLSID_NetworkServer))
                        {
                            hr = E_FAIL;
                            *pszPath = 0;
                        }
                    }
                    else
                    {
                        hr = E_FAIL;    // not a file system guy, slam it
                        *pszPath = 0;
                    }
                }
            }
            psf->Release();
        }
    }

    if (SUCCEEDED(hr) && (uOpts & GPFIDL_ALTNAME))
    {
        TCHAR szShort[MAX_PATH];
        if (GetShortPathName(pszPath, szShort, ARRAYSIZE(szShort)))
        {
            lstrcpy(pszPath, szShort);
        }
    }
    return SUCCEEDED(hr);
}

STDAPI_(BOOL) SHGetPathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    // NOTE: we pass GPFIDL_UNCPRINTER to get UNC printer names too
    return SHGetPathFromIDListEx(pidl, pszPath, GPFIDL_UNCPRINTER);
}

#define CBHUMHEADER     14
inline BOOL _DoHummingbirdHack(LPCITEMIDLIST pidl)
{
    static const char rgchHum[] = {(char)0xe8, (char)0x03, 0,0,0,0,0,0,(char)0x10,0};

    return (pidl && pidl->mkid.cb > CBHUMHEADER) && ILIsEmpty(_ILNext(pidl))
    && (0 == memcmp(_ILSkip(pidl, 4), rgchHum, sizeof(rgchHum)))
    && GetModuleHandle(TEXT("heshell"));
}

STDAPI_(BOOL) SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath)
{
    WCHAR wszPath[MAX_PATH];

    *pszPath = 0;  // Assume error

    if (SHGetPathFromIDListW(pidl, wszPath))
    {
        // Thunk the output result string back to ANSI.  If the conversion fails,
        // or if the default char is used, we fail the API call.

        if (0 == WideCharToMultiByte(CP_ACP, 0, wszPath, -1, pszPath, MAX_PATH, NULL, NULL))
        {
            return FALSE;  // (DavePl) Note failure only due to text thunking
        }
        return TRUE;        // warning, word perfect tests explictly for TRUE (== TRUE)
    }
    else if (_DoHummingbirdHack(pidl))
    {
        //
        //  HACKHACK - hummingbird isn't very good here because we used be even worse - Zekel 7-OCT-99
        //  hummingbird's shell extension passes us a pidl that is relative to
        //  itself.  however SHGetPathFromIDList() used to try some weird stuff
        //  when it didnt recognize the pidl.  in this case it would combine the
        //  relative pidl with the CSIDL_DESKTOPDIRECTORY pidl, and then ask for
        //  the path.  due to crappy parameter validation we would actually return
        //  back a path with a string from inside their relative pidl.  the path
        //  of course doesnt exist at all, but hummingbird fails to initialize its
        //  subfolders if we fail here.  they dont do anything with the path except
        //  look for a slash.  (if the slash is missing they will fault.)
        //
        SHGetFolderPathA(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, pszPath);
        PathAppendA(pszPath, (LPCSTR)_ILSkip(pidl, CBHUMHEADER));
        return TRUE;
    }

    return FALSE;
}

//
//  Race-condition-free version.
//
STDAPI_(HANDLE) SHGetCachedGlobalCounter(HANDLE *phCache, const GUID *pguid)
{
    if (!*phCache)
    {
        HANDLE h = SHGlobalCounterCreate(*pguid);
        if (SHInterlockedCompareExchange(phCache, h, 0))
        {
            // some other thread raced with us, throw away our copy
            SHGlobalCounterDestroy(h);
        }
    }
    return *phCache;
}

//
//  Race-condition-free version.
//
STDAPI_(void) SHDestroyCachedGlobalCounter(HANDLE *phCache)
{
    HANDLE h = InterlockedExchangePointer(phCache, NULL);
    if (h)
    {
        SHGlobalCounterDestroy(h);
    }
}

//
//  Use this function when you want to lazy-create and cache some object.
//  It's safe in the multithreaded case where two people lazy-create the
//  object and both try to put it into the cache.
//
STDAPI_(void) SetUnknownOnSuccess(HRESULT hr, IUnknown *punk, IUnknown **ppunkToSet)
{
    if (SUCCEEDED(hr))
    {
        if (SHInterlockedCompareExchange((void **)ppunkToSet, punk, 0))
            punk->Release();  // race, someone did this already
    }
}

//
//  Create and cache a tracking folder.
//
//  pidlRoot    = where the folder should reside; can be MAKEINTIDLIST(csidl).
//  csidlTarget = the csidl we should track, CSIDL_FLAG_CREATE is allowed
//  ppsfOut     = Receives the cached folder
//
//  If there is already a folder in the cache, succeeds vacuously.
//
STDAPI SHCacheTrackingFolder(LPCITEMIDLIST pidlRoot, int csidlTarget, IShellFolder2 **ppsfCache)
{
    HRESULT hr = S_OK;

    if (!*ppsfCache)
    {
        PERSIST_FOLDER_TARGET_INFO pfti = {0};
        IShellFolder2 *psf;
        LPITEMIDLIST pidl;

        // add FILE_ATTRIBUTE_SYSTEM to allow MUI stuff underneath this folder.
        // since its just for these tracking folders it isnt a perf hit to enable this.
        pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_SYSTEM;
        pfti.csidl = csidlTarget | CSIDL_FLAG_PFTI_TRACKTARGET;

        if (IS_INTRESOURCE(pidlRoot))
        {
            hr = SHGetFolderLocation(NULL, PtrToInt(pidlRoot), NULL, 0, &pidl);
        }
        else
        {
            pidl = const_cast<LPITEMIDLIST>(pidlRoot);
        }

        if (SUCCEEDED(hr))
        {
            hr = CFSFolder_CreateFolder(NULL, NULL, pidl, &pfti, IID_PPV_ARG(IShellFolder2, &psf));
            SetUnknownOnSuccess(hr, psf, (IUnknown **)ppsfCache);
        }

        if (pidl != pidlRoot)
            ILFree(pidl);

    }
    return hr;
}

STDAPI DefaultSearchGUID(GUID *pGuid)
{
    if (SHRestricted(REST_NOFIND))
    {
        *pGuid = GUID_NULL;
        return E_NOTIMPL;
    }

    *pGuid = SRCID_SFileSearch;
    return S_OK;
}


// Helper function to save IPersistHistory stream for you
//
HRESULT SavePersistHistory(IUnknown* punk, IStream* pstm)
{
    IPersistHistory* pPH;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IPersistHistory, &pPH));
    if (SUCCEEDED(hr))
    {
        CLSID clsid;
        hr = pPH->GetClassID(&clsid);
        if (SUCCEEDED(hr))
        {
            hr = IStream_Write(pstm, &clsid, sizeof(clsid));
            if (SUCCEEDED(hr))
            {
                hr = pPH->SaveHistory(pstm);
            }
        }
        pPH->Release();
    }
    return hr;
}

STDAPI Stream_WriteStringA(IStream *pstm, LPCSTR psz)
{
    SHORT cch = (SHORT)lstrlenA(psz);
    HRESULT hr = pstm->Write(&cch, sizeof(cch), NULL);
    if (SUCCEEDED(hr))
        hr = pstm->Write(psz, cch * sizeof(*psz), NULL);

    return hr;
}

STDAPI Stream_WriteStringW(IStream *pstm, LPCWSTR psz)
{
    SHORT cch = (SHORT)lstrlenW(psz);
    HRESULT hr = pstm->Write(&cch, sizeof(cch), NULL);
    if (SUCCEEDED(hr))
        hr = pstm->Write(psz, cch * sizeof(*psz), NULL);

    return hr;
}

STDAPI Stream_WriteString(IStream *pstm, LPCWSTR psz, BOOL bWideInStream)
{
    HRESULT hr;
    if (bWideInStream)
    {
        hr = Stream_WriteStringW(pstm, psz);
    }
    else
    {
        CHAR szBuf[MAX_PATH];
        SHUnicodeToAnsi(psz, szBuf, ARRAYSIZE(szBuf));
        hr = Stream_WriteStringA(pstm, szBuf);
    }
    return hr;
}

STDAPI Stream_ReadStringA(IStream *pstm, LPSTR pszBuf, UINT cchBuf)
{
    *pszBuf = 0;

    USHORT cch;
    HRESULT hr = pstm->Read(&cch, sizeof(cch), NULL);   // size of data
    if (SUCCEEDED(hr))
    {
        if (cch >= (USHORT)cchBuf)
        {
            DebugMsg(DM_TRACE, TEXT("truncating string read(%d to %d)"), cch, cchBuf);
            cch = (USHORT)cchBuf - 1;   // leave room for null terminator
        }

        hr = pstm->Read(pszBuf, cch, NULL);
        if (SUCCEEDED(hr))
            pszBuf[cch] = 0;      // add NULL terminator
    }
    return hr;
}

STDAPI Stream_ReadStringW(IStream *pstm, LPWSTR pwszBuf, UINT cchBuf)
{
    *pwszBuf = 0;

    USHORT cch;
    HRESULT hr = pstm->Read(&cch, sizeof(cch), NULL);   // size of data
    if (SUCCEEDED(hr))
    {
        if (cch >= (USHORT)cchBuf)
        {
            DebugMsg(DM_TRACE, TEXT("truncating string read(%d to %d)"), cch, cchBuf);
            cch = (USHORT)cchBuf - 1;   // leave room for null terminator
        }

        hr = pstm->Read(pwszBuf, cch * sizeof(*pwszBuf), NULL);
        if (SUCCEEDED(hr))
            pwszBuf[cch] = 0;      // add NULL terminator
    }
    return hr;
}

STDAPI Stream_ReadString(IStream *pstm, LPTSTR psz, UINT cchBuf, BOOL bWideInStream)
{
    HRESULT hr;
    if (bWideInStream)
    {
        hr = Stream_ReadStringW(pstm, psz, cchBuf);
    }
    else
    {
        CHAR szAnsiBuf[MAX_PATH];
        hr = Stream_ReadStringA(pstm, szAnsiBuf, ARRAYSIZE(szAnsiBuf));
        if (SUCCEEDED(hr))
            SHAnsiToUnicode(szAnsiBuf, psz, cchBuf);
    }
    return hr;
}

STDAPI Str_SetFromStream(IStream *pstm, LPTSTR *ppsz, BOOL bWideInStream)
{
    TCHAR szBuf[MAX_PATH];
    HRESULT hr = Stream_ReadString(pstm, szBuf, ARRAYSIZE(szBuf), bWideInStream);
    if (SUCCEEDED(hr))
        if (!Str_SetPtr(ppsz, szBuf))
            hr = E_OUTOFMEMORY;
    return hr;
}

LPSTR ThunkStrToAnsi(LPCWSTR pszW, CHAR *pszA, UINT cchA)
{
    if (pszW)
    {
        SHUnicodeToAnsi(pszW, pszA, cchA);
        return pszA;
    }
    return NULL;
}

LPWSTR ThunkStrToWide(LPCSTR pszA, LPWSTR pszW, DWORD cchW)
{
    if (pszA)
    {
        SHAnsiToUnicode(pszA, pszW, cchW);
        return pszW;
    }
    return NULL;
}

#define ThunkSizeAnsi(pwsz)       WideCharToMultiByte(CP_ACP,0,(pwsz),-1,NULL,0,NULL,NULL)
#define ThunkSizeWide(psz)       MultiByteToWideChar(CP_ACP,0,(psz),-1,NULL,0)

STDAPI SEI2ICIX(LPSHELLEXECUTEINFO pei, LPCMINVOKECOMMANDINFOEX pici, void **ppvFree)
{
    HRESULT hr = S_OK;

    *ppvFree = NULL;
    ZeroMemory(pici, sizeof(CMINVOKECOMMANDINFOEX));

    pici->cbSize = sizeof(CMINVOKECOMMANDINFOEX);
    pici->fMask = (pei->fMask & SEE_VALID_CMIC_BITS);
    pici->hwnd = pei->hwnd;
    pici->nShow = pei->nShow;
    pici->dwHotKey = pei->dwHotKey;
    pici->lpTitle = NULL;

    //  the pei->hIcon can have multiple meanings...
    if ((pei->fMask & SEE_MASK_HMONITOR) && pei->hIcon)
    {
        //  in this case we want the hMonitor to
        //  make it through to where the pcm calls shellexec
        //  again.
        RECT rc;
        if (GetMonitorRect((HMONITOR)pei->hIcon, &rc))
        {
            //  default to the top left corner of
            //  the monitor.  it is just the monitor
            //  that is relevant here.
            pici->ptInvoke.x = rc.left;
            pici->ptInvoke.y = rc.top;
            pici->fMask |= CMIC_MASK_PTINVOKE;
        }
    }
    else
    {
        pici->hIcon = pei->hIcon;
    }

    // again, pei->lpClass can have multiple meanings...
    if (pei->fMask & (SEE_MASK_HASTITLE | SEE_MASK_HASLINKNAME))
    {
        pici->lpTitleW = pei->lpClass;
    }

    pici->lpVerbW       = pei->lpVerb;
    pici->lpParametersW = pei->lpParameters;
    pici->lpDirectoryW  = pei->lpDirectory;

    //  we need to thunk the strings down.  first get the length of all the buffers
    DWORD cbVerb = ThunkSizeAnsi(pei->lpVerb);
    DWORD cbParameters = ThunkSizeAnsi(pei->lpParameters);
    DWORD cbDirectory = ThunkSizeAnsi(pei->lpDirectory);
    DWORD cbTotal = cbVerb + cbParameters + cbDirectory;

    if (cbTotal)
    {
        hr = SHLocalAlloc(cbVerb + cbParameters + cbDirectory, ppvFree);
        if (SUCCEEDED(hr))
        {
            LPSTR pch = (LPSTR) *ppvFree;

            pici->lpVerb = ThunkStrToAnsi(pei->lpVerb, pch, cbVerb);
            pch += cbVerb;
            pici->lpParameters  = ThunkStrToAnsi(pei->lpParameters, pch, cbParameters);
            pch += cbParameters;
            pici->lpDirectory   = ThunkStrToAnsi(pei->lpDirectory, pch, cbDirectory);
        }
    }

    pici->fMask |= CMIC_MASK_UNICODE;

    return hr;
}

STDAPI ICIX2SEI(LPCMINVOKECOMMANDINFOEX pici, LPSHELLEXECUTEINFO pei)
{
    //  perhaps we should allow just plain ici's, and do the thunk in here, but
    //  it looks like all the callers want to do the thunk themselves...
    //  HRESULT hr = S_OK;

    ZeroMemory(pei, sizeof(SHELLEXECUTEINFO));
    pei->cbSize = sizeof(SHELLEXECUTEINFO);
    pei->fMask = pici->fMask & SEE_VALID_CMIC_BITS;

    // if we are doing this async, then we will abort this thread
    // as soon as the shellexecute completes.  If the app holds open
    // a dde conversation, this may hang them.  This happens on W95 base
    // with winword95
    IUnknown *punk;
    HRESULT hr = TBCGetObjectParam(TBCDIDASYNC, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        pei->fMask |= SEE_MASK_FLAG_DDEWAIT;
        punk->Release();
    }

    pei->hwnd = pici->hwnd;
    pei->nShow = pici->nShow;
    pei->dwHotKey = pici->dwHotKey;

    if (pici->fMask & CMIC_MASK_ICON)
    {
        pei->hIcon = pici->hIcon;
    }
    else if (pici->fMask & CMIC_MASK_PTINVOKE)
    {
        pei->hIcon = (HANDLE)MonitorFromPoint(pici->ptInvoke, MONITOR_DEFAULTTONEAREST);
        pei->fMask |= SEE_MASK_HMONITOR;
    }

    ASSERT(pici->fMask & CMIC_MASK_UNICODE);

    pei->lpParameters = pici->lpParametersW;
    pei->lpDirectory  = pici->lpDirectoryW;

    if (!IS_INTRESOURCE(pici->lpVerbW))
    {
        pei->lpVerb = pici->lpVerbW;
    }

    // both the title and linkname can be stored the lpClass field
    if (pici->fMask & (CMIC_MASK_HASTITLE | CMIC_MASK_HASLINKNAME))
    {
            pei->lpClass = pici->lpTitleW;
    }

    //  if we have to do any thunking in here, we
    //  will have a real return hr.
    return S_OK;
}

STDAPI ICI2ICIX(LPCMINVOKECOMMANDINFO piciIn, LPCMINVOKECOMMANDINFOEX piciOut, void **ppvFree)
{
    ASSERT(piciIn->cbSize >= sizeof(CMINVOKECOMMANDINFO));

    HRESULT hr = S_OK;
    *ppvFree = NULL;

    ZeroMemory(piciOut, sizeof(*piciOut));
    memcpy(piciOut, piciIn, min(sizeof(*piciOut), piciIn->cbSize));
    piciOut->cbSize = sizeof(*piciOut);
    
    //  if the UNICODE params arent there, we must put them there
    if (!(piciIn->cbSize >= CMICEXSIZE_NT4) || !(piciIn->fMask & CMIC_MASK_UNICODE))
    {
        DWORD cchDirectory = ThunkSizeWide(piciOut->lpDirectory);
        DWORD cchTitle = ThunkSizeWide(piciOut->lpTitle);
        DWORD cchParameters = ThunkSizeWide(piciOut->lpParameters);
        DWORD cchVerb = 0;
        if (!IS_INTRESOURCE(piciOut->lpVerb))
            cchVerb = ThunkSizeWide(piciOut->lpVerb);

        DWORD cchTotal = (cchDirectory + cchTitle + cchVerb + cchParameters);

        if (cchTotal)
        {
            hr = SHLocalAlloc(sizeof(WCHAR) * cchTotal, ppvFree);
            if (SUCCEEDED(hr))
            {
                LPWSTR pch = (LPWSTR) *ppvFree;
                piciOut->lpDirectoryW = ThunkStrToWide(piciOut->lpDirectory, pch, cchDirectory);
                pch += cchDirectory;
                piciOut->lpTitleW = ThunkStrToWide(piciOut->lpTitle, pch, cchTitle);
                pch += cchTitle;
                piciOut->lpParametersW = ThunkStrToWide(piciOut->lpParameters, pch, cchParameters);
                pch += cchParameters;

                //only thunk if it is a string...
                if (!IS_INTRESOURCE(piciOut->lpVerb))
                {
                    piciOut->lpVerbW = ThunkStrToWide(piciOut->lpVerb, pch, cchVerb);
                }
                else
                {
                    piciOut->lpVerbW = (LPCWSTR)piciOut->lpVerb;
                }
            }
        }

        piciOut->fMask |= CMIC_MASK_UNICODE;
    }

    return hr;
}


IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation, HINSTANCE hAnimationInst)
{
    IProgressDialog * ppd;

    if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IProgressDialog, &ppd))))
    {
        WCHAR wzTitle[MAX_PATH];

        EVAL(SUCCEEDED(ppd->SetAnimation(hAnimationInst, idAnimation)));
        if (EVAL(LoadStringW(HINST_THISDLL, idTitle, wzTitle, ARRAYSIZE(wzTitle))))
            EVAL(SUCCEEDED(ppd->SetTitle(wzTitle)));
    }

    return ppd;
}

STDAPI GetCurFolderImpl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    if (pidl)
        return SHILClone(pidl, ppidl);

    *ppidl = NULL;
    return S_FALSE; // success but empty
}


//
// converts a simple PIDL to a real PIDL by converting to display name and then
// reparsing the name
//
STDAPI SHGetRealIDL(IShellFolder *psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST *ppidlReal)
{
    *ppidlReal = NULL;      // clear output

    STRRET str;
    HRESULT hr = IShellFolder_GetDisplayNameOf(psf, pidlSimple, SHGDN_FORPARSING | SHGDN_INFOLDER, &str, 0);
    if (SUCCEEDED(hr))
    {
        WCHAR szPath[MAX_PATH];
        hr = StrRetToBufW(&str, pidlSimple, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            DWORD dwAttrib = SFGAO_FILESYSTEM;
            if (SUCCEEDED(psf->GetAttributesOf(1, &pidlSimple, &dwAttrib)) && !(dwAttrib & SFGAO_FILESYSTEM))
            {
                // not a file sys object, some name spaces (WinCE) support
                // parse, but don't do a good job, in this case
                // return the input as the output
                hr = SHILClone(pidlSimple, ppidlReal);
            }
            else
            {
                hr = IShellFolder_ParseDisplayName(psf, NULL, NULL, szPath, NULL, ppidlReal, NULL);
                if (E_INVALIDARG == hr || E_NOTIMPL == hr)
                {
                    // name space does not support parse, assume pidlSimple is OK
                    hr = SHILClone(pidlSimple, ppidlReal);
                }
            }
        }
    }
    return hr;
}

//  trial and error has shown that
//  16k is a good number for FTP,
//  thus we will use that as our default buffer
#define CBOPTIMAL    (16 * 1024)

STDAPI CopyStreamUI(IStream *pstmSrc, IStream *pstmDest, IProgressDialog *pdlg, ULONGLONG ullMaxBytes)
{
    HRESULT hr = E_FAIL;
    ULONGLONG ullMax;

    if (ullMaxBytes != 0)
    {
        ullMax = ullMaxBytes;
    }
    else if (pdlg)
    {
        STATSTG stat = {0};
        if (FAILED(pstmSrc->Stat(&stat, STATFLAG_NONAME)))
            pdlg = NULL;
        else
            ullMax = stat.cbSize.QuadPart;
    }

    if (!pdlg)
    {
        ULARGE_INTEGER ulMax = {-1, -1};
        // If ullMaxBytes was passed in as non-zero, don't write more bytes than we were told to:
        if (0 != ullMaxBytes)
        {
            ulMax.QuadPart = ullMaxBytes;
        }
        hr = pstmSrc->CopyTo(pstmDest, ulMax, NULL, NULL);

        //  BUBBUGREMOVE - URLMON has bug which breaks CopyTo() - Zekel
        //  fix URLMON and then we can remove this garbage.
        //  so we will fake it here
    }

    if (FAILED(hr))
    {
        // try doing it by hand
        void *pv = LocalAlloc(LPTR, CBOPTIMAL);
        BYTE buf[1024];
        ULONG cbBuf, cbRead, cbBufReal;
        ULONGLONG ullCurr = 0;

        //  need to reset the streams,
        //  because CopyTo() doesnt guarantee any kind
        //  of state
        IStream_Reset(pstmSrc);
        IStream_Reset(pstmDest);

        //  if we werent able to get the
        //  best size, just use a little stack space :)
        if (pv)
            cbBufReal = CBOPTIMAL;
        else
        {
            pv = buf;
            cbBufReal = sizeof(buf);
        }

        cbBuf = cbBufReal;
        while (SUCCEEDED(pstmSrc->Read(pv, cbBuf, &cbRead)))
        {
            ullCurr += cbBuf;

            if (pdlg)
            {
                if (pdlg->HasUserCancelled())
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }


                //  Note: urlmon doesnt always fill in the correct value for cbBuf returned
                //  so we need to make sure we dont pass bigger curr than max
                pdlg->SetProgress64(min(ullCurr, ullMax), ullMax);
            }

            // If ullMaxBytes was passed in as non-zero, don't write more bytes than we were told to:
            ULONG ulBytesToWrite = (0 != ullMaxBytes) ?
                                         (ULONG) min(cbRead, ullMaxBytes - (ullCurr - cbBuf)) :
                                         cbRead;

            if (!ulBytesToWrite)
            {
                hr = S_OK;
                break;
            }

            hr = IStream_Write(pstmDest, pv, ulBytesToWrite);
            if (S_OK != hr)
                break;  // failure!

            cbBuf = cbBufReal;
        }

        if (pv != buf)
            LocalFree(pv);
    }

    return hr;

}

STDAPI CopyStream(IStream *pstmSrc, IStream *pstmDest)
{
    return CopyStreamUI(pstmSrc, pstmDest, NULL, 0);
}

STDAPI_(BOOL) IsWindowInProcess(HWND hwnd)
{
    DWORD idProcess;

    GetWindowThreadProcessId(hwnd, &idProcess);
    return idProcess == GetCurrentProcessId();
}

class CFileSysBindData: public IFileSystemBindData
{
public:
    CFileSysBindData();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IFileSystemBindData
    STDMETHODIMP SetFindData(const WIN32_FIND_DATAW *pfd);
    STDMETHODIMP GetFindData(WIN32_FIND_DATAW *pfd);

private:
    ~CFileSysBindData();

    LONG  _cRef;
    WIN32_FIND_DATAW _fd;
};


CFileSysBindData::CFileSysBindData() : _cRef(1)
{
    ZeroMemory(&_fd, sizeof(_fd));
}

CFileSysBindData::~CFileSysBindData()
{
}

HRESULT CFileSysBindData::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFileSysBindData, IFileSystemBindData), // IID_IFileSystemBindData
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileSysBindData::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileSysBindData::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CFileSysBindData::SetFindData(const WIN32_FIND_DATAW *pfd)
{
    _fd = *pfd;
    return S_OK;
}

HRESULT CFileSysBindData::GetFindData(WIN32_FIND_DATAW *pfd)
{
    *pfd = _fd;
    return S_OK;
}

STDAPI SHCreateFileSysBindCtx(const WIN32_FIND_DATA *pfd, IBindCtx **ppbc)
{
    HRESULT hr;
    IFileSystemBindData *pfsbd = new CFileSysBindData();
    if (pfsbd)
    {
        if (pfd)
        {
            pfsbd->SetFindData(pfd);
        }

        hr = CreateBindCtx(0, ppbc);
        if (SUCCEEDED(hr))
        {
            BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
            bo.grfMode = STGM_CREATE;
            (*ppbc)->SetBindOptions(&bo);
            (*ppbc)->RegisterObjectParam(STR_FILE_SYS_BIND_DATA, pfsbd);
        }
        pfsbd->Release();
    }
    else
    {
        *ppbc = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI SHCreateFileSysBindCtxEx(const WIN32_FIND_DATA *pfd, DWORD grfMode, DWORD grfFlags, IBindCtx **ppbc)
{
    HRESULT hr = SHCreateFileSysBindCtx(pfd, ppbc);
    if (SUCCEEDED(hr))
    {
        BIND_OPTS bo = {sizeof(bo)};
        hr = (*ppbc)->GetBindOptions(&bo);
        if (SUCCEEDED(hr))
        {
            bo.grfMode =  grfMode;
            bo.grfFlags = grfFlags;
            hr = (*ppbc)->SetBindOptions(&bo);
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppbc);
        }
    }
    return hr;
}


// returns S_OK if this is a simple bind ctx
// out:
//      optional (may be NULL) pfd
//
STDAPI SHIsFileSysBindCtx(IBindCtx *pbc, WIN32_FIND_DATA **ppfd)
{
    HRESULT hr = S_FALSE; // default to no
    IUnknown *punk;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_FILE_SYS_BIND_DATA, &punk)))
    {
        IFileSystemBindData *pfsbd;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IFileSystemBindData, &pfsbd))))
        {
            hr = S_OK;    // yes
            if (ppfd)
            {
                hr = SHLocalAlloc(sizeof(WIN32_FIND_DATA), ppfd);
                if (SUCCEEDED(hr))
                    pfsbd->GetFindData(*ppfd);
            }
            pfsbd->Release();
        }
        punk->Release();
    }
    return hr;
}


STDAPI SHCreateSkipBindCtx(IUnknown *punkToSkip, IBindCtx **ppbc)
{
    HRESULT hr = CreateBindCtx(0, ppbc);
    if (SUCCEEDED(hr))
    {
        // NULL clsid means bind context that skips all junction points
        if (punkToSkip)
        {
            (*ppbc)->RegisterObjectParam(STR_SKIP_BINDING_CLSID, punkToSkip);
        }
        else
        {
            BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
            bo.grfFlags = BIND_JUSTTESTEXISTENCE;
            (*ppbc)->SetBindOptions(&bo);
        }
    }
    return hr;
}

// We've overloaded the meaning of the BIND_OPTS flag
// BIND_JUSTTESTEXISTENCE to mean don't bind to junctions
// when evaluating paths...so check it here...
//
//  pbc         optional bind context (can be NULL)
//  pclsidSkip  optional CLSID to test. if null we test for skiping all
//              junction binding, not just on this specific CLSID
//
STDAPI_(BOOL) SHSkipJunctionBinding(IBindCtx *pbc, const CLSID *pclsidSkip)
{
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(BIND_OPTS), 0};  // Requires size filled in.
        return (SUCCEEDED(pbc->GetBindOptions(&bo)) &&
                bo.grfFlags == BIND_JUSTTESTEXISTENCE) ||
                (pclsidSkip && SHSkipJunction(pbc, pclsidSkip));     // should we skip this specific CLSID?
    }
    return FALSE;   // do junction binding, no context provided
}

// Bind file system object to storage.
// in:
//      dwFileAttributes    optional (-1)
//
STDAPI SHFileSysBindToStorage(LPCWSTR pszPath, DWORD dwFileAttributes, DWORD grfMode, DWORD grfFlags,
                              REFIID riid, void **ppv)
{
    if (-1 == dwFileAttributes)
    {
        TCHAR szPath[MAX_PATH];
        SHUnicodeToTChar(pszPath, szPath, ARRAYSIZE(szPath));
        dwFileAttributes = GetFileAttributes(szPath);
        if (-1 == dwFileAttributes)
            return STG_E_FILENOTFOUND;
    }

    WIN32_FIND_DATA wfd = {0};
    wfd.dwFileAttributes = dwFileAttributes;

    IBindCtx *pbc;
    HRESULT hr = SHCreateFileSysBindCtxEx(&wfd, grfMode, grfFlags, &pbc);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;

            hr = psfDesktop->ParseDisplayName(NULL, pbc, (LPWSTR)pszPath, NULL, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlLast;

                hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
                if (SUCCEEDED(hr))
                {
                    hr = psf->BindToStorage(pidlLast, pbc, riid, ppv);
                    psf->Release();
                }
                ILFree(pidl);
            }
            psfDesktop->Release();
        }
        pbc->Release();
    }
    return hr;
}


// return a relative IDList to pszFolder given the find data for that item

STDAPI SHCreateFSIDList(LPCTSTR pszFolder, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    LPITEMIDLIST pidl;

    *ppidl = NULL;

    if (PathCombine(szPath, pszFolder, pfd->cFileName))
    {
        hr = SHSimpleIDListFromFindData(szPath, pfd, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = SHILClone(ILFindLastID(pidl), ppidl);
            ILFree(pidl);
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDAPI SHSimulateDropWithSite(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                              const POINTL *ppt, DWORD *pdwEffect, IUnknown *punkSite)
{
    if (punkSite)
        IUnknown_SetSite(pdrop, punkSite);

    HRESULT hr = SHSimulateDrop(pdrop, pdtobj, grfKeyState, ppt, pdwEffect);

    if (punkSite)
        IUnknown_SetSite(pdrop, NULL);

    return hr;
}

STDAPI SimulateDropWithPasteSucceeded(IDropTarget * pdrop, IDataObject * pdtobj,
                                      DWORD grfKeyState, const POINTL *ppt, DWORD dwEffect,
                                      IUnknown * punkSite, BOOL fClearClipboard)
{
    // simulate the drag drop protocol
    HRESULT hr = SHSimulateDropWithSite(pdrop, pdtobj, grfKeyState, ppt, &dwEffect, punkSite);

    if (SUCCEEDED(hr))
    {
        // these formats are put into the data object by the drop target code. this
        // requires the data object support ::SetData() for arbitrary data formats
        //
        // g_cfPerformedDropEffect effect is the reliable version of dwEffect (some targets
        // return dwEffect == DROPEFFECT_MOVE always)
        //
        // g_cfLogicalPerformedDropEffect indicates the logical action so we can tell the
        // difference between optmized and non optimized move

        DWORD dwPerformedEffect        = DataObj_GetDWORD(pdtobj, g_cfPerformedDropEffect, DROPEFFECT_NONE);
        DWORD dwLogicalPerformedEffect = DataObj_GetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, DROPEFFECT_NONE);

        if ((DROPEFFECT_MOVE == dwLogicalPerformedEffect) ||
            (DROPEFFECT_MOVE == dwEffect && DROPEFFECT_MOVE == dwPerformedEffect))
        {
            // communicate back the source data object
            // so they can complete the "move" if necessary

            DataObj_SetDWORD(pdtobj, g_cfPasteSucceeded, dwEffect);

            // if we just did a paste and we moved the files we cant paste
            // them again (because they moved!) so empty the clipboard

            if (fClearClipboard)
            {
                OleSetClipboard(NULL);
            }
        }
    }

    return hr;
}


STDAPI TransferDelete(HWND hwnd, HDROP hDrop, UINT fOptions)
{
    HRESULT hr = E_OUTOFMEMORY;
    DRAGINFO di = { sizeof(DRAGINFO), 0 };
    if (DragQueryInfo(hDrop, &di)) // di.lpFileList will be in TCHAR format -- see DragQueryInfo impl
    {
        FILEOP_FLAGS fFileop;
        if (fOptions & SD_SILENT)
        {
            fFileop = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_ALLOWUNDO;
        }
        else
        {
            fFileop = ((fOptions & SD_NOUNDO) || (GetAsyncKeyState(VK_SHIFT) < 0)) ? 0 : FOF_ALLOWUNDO;

            if (fOptions & SD_WARNONNUKE)
            {
                // we pass this so the user is warned that they will loose
                // data during a move-to-recycle bin operation
                fFileop |= FOF_WANTNUKEWARNING;
            }

            if (!(fOptions & SD_USERCONFIRMATION))
                fFileop |= FOF_NOCONFIRMATION;
        }

        SHFILEOPSTRUCT fo = {
            hwnd,
            FO_DELETE,
            di.lpFileList,
            NULL,
            fFileop,
        };

        int iErr = SHFileOperation(&fo);
        if ((0 == iErr) && fo.fAnyOperationsAborted)
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user canceled (at least something was canceled)
        }
        else
        {
            hr = HRESULT_FROM_WIN32(iErr);
        }
        SHFree(di.lpFileList);
    }
    return hr;
}


STDAPI DeleteFilesInDataObject(HWND hwnd, UINT uFlags, IDataObject *pdtobj, UINT fOptions)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        fOptions |= (uFlags & CMIC_MASK_FLAG_NO_UI) ? SD_SILENT : SD_USERCONFIRMATION;

        if ((uFlags & CMIC_MASK_SHIFT_DOWN) || (GetKeyState(VK_SHIFT) < 0))
        {
            fOptions |= SD_NOUNDO;
        }

        hr = TransferDelete(hwnd, (HDROP)medium.hGlobal, fOptions);

        ReleaseStgMedium(&medium);

        SHChangeNotifyHandleEvents();
    }
    return hr;
}

STDAPI GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidlLast, CLSID *pclsid)
{
    VARIANT var;
    HRESULT hr = psf->GetDetailsEx(pidlLast, &SCID_DESCRIPTIONID, &var);
    if (SUCCEEDED(hr))
    {
        SHDESCRIPTIONID did;
        hr = VariantToBuffer(&var, (void *)&did, sizeof(did));
        if (SUCCEEDED(hr))
        {
            *pclsid = did.clsid;
        }

        VariantClear(&var);
    }
    return hr;
}

// in:
//      pidl    fully qualified IDList to test. we will bind to the
//              parent of this and ask it for the CLSID
// out:
//      pclsid  return the CLSID of the item

STDAPI GetCLSIDFromIDList(LPCITEMIDLIST pidl, CLSID *pclsid)
{
    IShellFolder2 *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        hr = GetItemCLSID(psf, pidlLast, pclsid);
        psf->Release();
    }
    return hr;
}

STDAPI _IsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid)
{
    HRESULT hr;
    LPITEMIDLIST pidlFirst = ILCloneFirst(pidl);
    if (pidlFirst)
    {
        CLSID clsid;

        hr = GetCLSIDFromIDList(pidlFirst, &clsid);

        if (SUCCEEDED(hr))
        {
            hr = (IsEqualCLSID(clsid, *pclsid) ? S_OK : S_FALSE);
        }
            
        ILFree(pidlFirst);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

#ifdef DEBUG
// We do not want to use IsIDListInNameSpace in ASSERTs since this fct can fail.
// Instead, if we fail, we return TRUE.  This will mainly happen because of low memory
// conditions.
STDAPI_(BOOL) AssertIsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid)
{
    // We return FALSE only if we succeeded and determined that the pidl is NOT in
    // the namespace.
    return (S_FALSE != _IsIDListInNameSpace(pidl, pclsid));
}
#endif

// test to see if this IDList is in the net hood name space scoped by clsid
// for example pass CLSID_NetworkPlaces or CLSID_MyComputer

STDAPI_(BOOL) IsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid)
{
    return (S_OK == _IsIDListInNameSpace(pidl, pclsid));
}

#define FILE_ATTRIBUTE_SH (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)

struct {
    LPCTSTR pszFile;
    BOOL bDeleteIfEmpty;
    DWORD dwAttributes;
} const c_aFilesToFix[] = {
    // autoexec.bat and config.sys are not in this list because hiding them
    // breaks some 16 bit apps (yes, lame). but we deal with hiding those
    // files in the file system enumerator (it special cases such files)

    { TEXT("X:\\autoexec.000"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.old"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.bak"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.dos"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\autoexec.win"), TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\config.dos"),   TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\config.win"),   TRUE,   FILE_ATTRIBUTE_SH },
    { TEXT("X:\\command.com"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\command.dos"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\logo.sys"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\msdos.---"),    FALSE,  FILE_ATTRIBUTE_SH },    // Win9x backup of msdos.*
    { TEXT("X:\\boot.ini"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\boot.bak"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\boot.---"),     FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\bootsect.dos"), FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\bootlog.txt"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x first boot log
    { TEXT("X:\\bootlog.prv"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffastun.ffa"),  FALSE,  FILE_ATTRIBUTE_SH },    // Office 97 only used hidden, O2K uses SH
    { TEXT("X:\\ffastun.ffl"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffastun.ffx"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffastun0.ffx"), FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\ffstunt.ffl"),  FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\sms.ini"),      FALSE,  FILE_ATTRIBUTE_SH },    // SMS
    { TEXT("X:\\sms.new"),      FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\sms_time.dat"), FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\smsdel.dat"),   FALSE,  FILE_ATTRIBUTE_SH },
    { TEXT("X:\\mpcsetup.log"), FALSE,  FILE_ATTRIBUTE_HIDDEN },// Microsoft Proxy Server
    { TEXT("X:\\detlog.txt"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win9x PNP detection log
    { TEXT("X:\\detlog.old"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win9x PNP detection log
    { TEXT("X:\\setuplog.txt"), FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\setuplog.old"), FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\suhdlog.dat"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\suhdlog.---"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\suhdlog.bak"),  FALSE,  FILE_ATTRIBUTE_SH },    // Win9x setup log
    { TEXT("X:\\system.1st"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win95 system.dat backup
    { TEXT("X:\\netlog.txt"),   FALSE,  FILE_ATTRIBUTE_SH },    // Win9x network setup log file
    { TEXT("X:\\setup.aif"),    FALSE,  FILE_ATTRIBUTE_SH },    // NT4 unattended setup script
    { TEXT("X:\\catlog.wci"),   FALSE,  FILE_ATTRIBUTE_HIDDEN },// index server folder
    { TEXT("X:\\cmsstorage.lst"), FALSE,  FILE_ATTRIBUTE_SH },  // Microsoft Media Manager
};

void PathSetSystemDrive(TCHAR *pszPath)
{
    TCHAR szWin[MAX_PATH];
    
    if (GetWindowsDirectory(szWin, ARRAYSIZE(szWin)))
        *pszPath = szWin[0];
    else
        *pszPath = TEXT('C');   // try this in failure
}

void PrettyPath(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];

    lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));
    PathSetSystemDrive(szPath);
    PathMakePretty(PathFindFileName(szPath));  // fix up the file spec part

    MoveFile(pszPath, szPath);      // rename to the good name.
}

void DeleteEmptyFile(LPCTSTR pszPath)
{
    WIN32_FIND_DATA fd;
    HANDLE hfind = FindFirstFile(pszPath, &fd);
    if (hfind != INVALID_HANDLE_VALUE)
    {
        FindClose(hfind);
        if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
             (fd.nFileSizeHigh == 0) && (fd.nFileSizeLow == 0))
            DeleteFile(pszPath);
    }
}

STDAPI_(void) CleanupFileSystem()
{
    // try to fix up other variations of the windows folders that may
    // not be the current windir. this is to make dual boots and old installs
    // of windows have nicely cases file names when displayed in the explorer
    PrettyPath(TEXT("X:\\WINDOWS"));
    PrettyPath(TEXT("X:\\WINNT"));

    for (int i = 0; i < ARRAYSIZE(c_aFilesToFix); i++)
    {
        TCHAR szPath[MAX_PATH];

        lstrcpyn(szPath, c_aFilesToFix[i].pszFile, ARRAYSIZE(szPath));
        PathSetSystemDrive(szPath);

        if (c_aFilesToFix[i].bDeleteIfEmpty)
            DeleteEmptyFile(szPath);

        SetFileAttributes(szPath, c_aFilesToFix[i].dwAttributes);
    }
}

// Always frees pidlToPrepend and *ppidl on failure
STDAPI SHILPrepend(LPITEMIDLIST pidlToPrepend, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    if (!*ppidl)
    {
        *ppidl = pidlToPrepend;
        hr = S_OK;
    }
    else
    {
        LPITEMIDLIST pidlSave = *ppidl;             // append to the list
        hr = SHILCombine(pidlToPrepend, pidlSave, ppidl);
        ILFree(pidlSave);
        ILFree(pidlToPrepend);
    }
    return hr;
}

// in:
//      pidlToAppend    this item is appended to *ppidl and freed
//
// in/out:
//      *ppidl  idlist to append to, if empty gets pidlToAppend
//
STDAPI SHILAppend(LPITEMIDLIST pidlToAppend, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    if (!*ppidl)
    {
        *ppidl = pidlToAppend;
        hr = S_OK;
    }
    else
    {
        LPITEMIDLIST pidlSave = *ppidl;             // append to the list
        hr = SHILCombine(pidlSave, pidlToAppend, ppidl);
        ILFree(pidlSave);
        ILFree(pidlToAppend);
    }
    return hr;
}


STDAPI SHSimpleIDListFromFindData(LPCTSTR pszPath, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    // Office 2000 does a SHChangeNotify(SHCNE_DELETE, ""), and
    // ParseDisplayName("") returns CSIDL_DRIVES for app compat,
    // so we must catch that case here and prevent Office from
    // delete your My Computer icon (!)

    if (pszPath[0])
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            IBindCtx *pbc;
            hr = SHCreateFileSysBindCtx(pfd, &pbc);
            if (SUCCEEDED(hr))
            {
                WCHAR wszPath[MAX_PATH];

                // Must use a private buffer because ParseDisplayName takes a non-const pointer
                SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));

                hr = psfDesktop->ParseDisplayName(NULL, pbc, wszPath, NULL, ppidl, NULL);
                pbc->Release();
            }
            psfDesktop->Release();
        }
    }
    else
        hr = E_INVALIDARG;

    if (FAILED(hr))
        *ppidl = NULL;
    return hr;
}

STDAPI SHSimpleIDListFromFindData2(IShellFolder *psf, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;  // assume failure

    IBindCtx *pbc;
    HRESULT hr = SHCreateFileSysBindCtx(pfd, &pbc);
    if (SUCCEEDED(hr))
    {
        WCHAR wszPath[MAX_PATH];
        // Must use a private buffer because ParseDisplayName takes a non-const pointer
        SHTCharToUnicode(pfd->cFileName, wszPath, ARRAYSIZE(wszPath));

        hr = psf->ParseDisplayName(NULL, pbc, wszPath, NULL, ppidl, NULL);
        pbc->Release();
    }
    return hr;
}

STDAPI_(LPITEMIDLIST) SHSimpleIDListFromPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHSimpleIDListFromFindData(pszPath, NULL, &pidl);
    ASSERT(SUCCEEDED(hr) ? pidl != NULL : pidl == NULL);
    return pidl;
}

// convert a full file system IDList into one relative to the a special folder
// For example,
//      pidlFS == [my computer] [c:] [windows] [desktop] [dir] [foo.txt]
// returns:
//      [dir] [foo.txt]
//
// returns NULL if no translation was performed

STDAPI_(LPITEMIDLIST) SHLogILFromFSIL(LPCITEMIDLIST pidlFS)
{
    LPITEMIDLIST pidlOut;
    SHILAliasTranslate(pidlFS, &pidlOut, XLATEALIAS_ALL); // will set pidlOut=NULL on failure
    return pidlOut;
}

//
// Returns:
//  The resource index (of SHELL232.DLL) of the appropriate icon.
//
STDAPI_(UINT) SILGetIconIndex(LPCITEMIDLIST pidl, const ICONMAP aicmp[], UINT cmax)
{
    UINT uType = (pidl->mkid.abID[0] & SHID_TYPEMASK);
    for (UINT i = 0; i < cmax; i++)
    {
        if (aicmp[i].uType == uType)
        {
            return aicmp[i].indexResource;
        }
    }

    return II_DOCUMENT;   // default
}


BOOL IsSelf(UINT cidl, LPCITEMIDLIST *apidl)
{
    return cidl == 0 || (cidl == 1 && (apidl == NULL || apidl[0] == NULL || ILIsEmpty(apidl[0])));
}

//
// GetIconLocationFromExt
//
// Given "txt" or ".txt" return "C:\WINNT\System32\Notepad.exe" and the index into this file for the icon.
//
// if pszIconPath/cchIconPath is too small, this api will fail
//
STDAPI GetIconLocationFromExt(IN LPTSTR pszExt, OUT LPTSTR pszIconPath, UINT cchIconPath, OUT LPINT piIconIndex)
{
    IAssocStore* pas;
    IAssocInfo* pai;
    HRESULT hr;

    RIPMSG(pszIconPath && IS_VALID_STRING_PTR(pszIconPath, cchIconPath), "GetIconLocationFromExt: caller passed bad pszIconPath");

    if (!pszExt || !pszExt[0] || !pszIconPath)
        return E_INVALIDARG;

    pszIconPath[0] = 0;

    pas = new CFTAssocStore();
    if (pas)
    {
        hr = pas->GetAssocInfo(pszExt, AIINIT_EXT, &pai);
        if (SUCCEEDED(hr))
        {
            DWORD cchSize = cchIconPath;
        
            hr = pai->GetString(AISTR_ICONLOCATION, pszIconPath, &cchSize); 
        
            if (SUCCEEDED(hr))
            {
                *piIconIndex = PathParseIconLocation(pszIconPath);
            }

            pai->Release();
        }
        delete pas;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


STDAPI SHFindFirstFile(LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind)
{
    HRESULT hr;

    // instead of the ...erm HACK in the reserved word (win95), use the super new (NT only) FindFileEx instead
    // this is not guaranteed to filter, it is a "hint" according to the manual
    FINDEX_SEARCH_OPS eOps = FindExSearchNameMatch;
    if (pfd->dwReserved0 == 0x56504347)
    {
        eOps = FindExSearchLimitToDirectories;
        pfd->dwReserved0 = 0;
    }

    *phfind = FindFirstFileEx(pszPath, FindExInfoStandard, pfd, eOps, NULL, 0);
    if (*phfind == INVALID_HANDLE_VALUE)
    {
        DWORD err = GetLastError();
        if ((err == ERROR_NO_MORE_FILES ||      // what dos returns
             err == ERROR_FILE_NOT_FOUND) &&    // win32 return for dir searches
            PathIsWild(pszPath))
        {
            // convert search to empty success (probalby a root)
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(err);
        }
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


void _GoModal(HWND hwnd, IUnknown *punkModless, BOOL fModal)
{
    if (hwnd)
    {
        IUnknown_EnableModless(punkModless, !fModal);
    }
}

// in:
//      hwnd    NULL means no UI
//      pfFromWNet The caller will pass this to us with it set to TRUE because they will assume
//              that any error value returned from this function will come from a WNet API.
//              We need to change this value to FALSE if it doesn't come from WNet so
//              the string version of the error number is not generated from WNet.
HRESULT _RetryNetwork(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, IN BOOL * pfFromWNet, WIN32_FIND_DATA *pfd, HANDLE *phfind)
{
    HRESULT hr;
    TCHAR szT[MAX_PATH];
    DWORD err;

    AssertMsg((TRUE == *pfFromWNet), TEXT("We assume that *pfFromWNet comes in TRUE.  Someone changed that behavior. -BryanSt"));
    if (PathIsUNC(pszPath))
    {
        NETRESOURCE rc = { 0, RESOURCETYPE_ANY, 0, 0, NULL, szT, NULL, NULL} ;

        lstrcpy(szT, pszPath);
        PathStripToRoot(szT);

        _GoModal(hwnd, punkModless, TRUE);
        err = WNetAddConnection3(hwnd, &rc, NULL, NULL, (hwnd ? (CONNECT_TEMPORARY | CONNECT_INTERACTIVE) : CONNECT_TEMPORARY));
        if (WN_SUCCESS == err)
        {
            *pfFromWNet = FALSE;
        }

        _GoModal(hwnd, punkModless, FALSE);
    }
    else
    {
        TCHAR szDrive[4];

        szDrive[0] = pszPath[0];
        szDrive[1] = TEXT(':');
        szDrive[2] = 0;

        _GoModal(hwnd, punkModless, TRUE);

        DWORD dwFlags = 0;
        if (hwnd == NULL)
        {
            dwFlags |= WNRC_NOUI;
        }
        err = WNetRestoreConnection2(hwnd, szDrive, dwFlags, NULL);

        _GoModal(hwnd, punkModless, FALSE);
        if (err == WN_SUCCESS)
        {
            *pfFromWNet = FALSE;

            // refresh drive info... generate change notify
            szDrive[2] = TEXT('\\');
            szDrive[3] = 0;

            CMountPoint::NotifyReconnectedNetDrive(szDrive);
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_PATH, szDrive, NULL);
        }
        else if (err != ERROR_OUTOFMEMORY)
        {
            err = WN_CANCEL;    // user cancel (they saw UI) == ERROR_CANCELLED
        }
    }

    if (err == WN_SUCCESS)
        hr = SHFindFirstFile(pszPath, pfd, phfind);
    else
        hr = HRESULT_FROM_WIN32(err);

    return hr;
}


typedef struct {
    HWND hDlg;
    LPCTSTR pszPath;
    WIN32_FIND_DATA *pfd;
    HANDLE *phfind;
    HRESULT hr;
} RETRY_DATA;

STDAPI_(UINT) QueryCancelAutoPlayMsg()
{
    static UINT s_msgQueryCancelAutoPlay = 0;
    if (0 == s_msgQueryCancelAutoPlay)
        s_msgQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
    return s_msgQueryCancelAutoPlay;
}

BOOL IsQueryCancelAutoPlay(UINT uMsg)
{

    return uMsg == QueryCancelAutoPlayMsg();
}

#define IDT_RETRY    1

BOOL _IsUnformatedMediaResult(HRESULT hr)
{
    return hr == HRESULT_FROM_WIN32(ERROR_GEN_FAILURE) ||         // Win9x
           hr == HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_MEDIA) ||  // NT4
           hr == HRESULT_FROM_WIN32(ERROR_NOT_DOS_DISK) ||        // Could happen, I think.
           hr == HRESULT_FROM_WIN32(ERROR_SECTOR_NOT_FOUND) ||    // Happened on Magnatized disk
           hr == HRESULT_FROM_WIN32(ERROR_CRC) ||                 // Happened on Magnatized disk
           hr == HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_VOLUME);   // NT5
}

STDAPI_(BOOL) PathRetryRemovable(HRESULT hr, LPCTSTR pszPath)
{
    return (hr == HRESULT_FROM_WIN32(ERROR_NOT_READY) ||            // normal case
            hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)) &&   // SCSI ZIP drive does this
            PathIsRemovable(pszPath);
}


BOOL_PTR CALLBACK _OnTimeCheckDiskForInsert(HWND hDlg, RETRY_DATA *prd)
{
    BOOL_PTR fReturnValue = 0;

    prd->hr = SHFindFirstFile(prd->pszPath, prd->pfd, prd->phfind);
    // we are good or they inserted unformatted disk

    if (SUCCEEDED(prd->hr) || _IsUnformatedMediaResult(prd->hr))
    {
        EndDialog(hDlg, IDRETRY);
    }

    return fReturnValue;
}


BOOL_PTR CALLBACK RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RETRY_DATA *prd = (RETRY_DATA *)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        prd = (RETRY_DATA *)lParam;
        prd->hDlg = hDlg;
        {
            TCHAR szFormat[128], szText[MAX_PATH];
            GetDlgItemText(hDlg, IDD_TEXT, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szText, ARRAYSIZE(szText), szFormat, prd->pszPath[0]);
            SetDlgItemText(hDlg, IDD_TEXT, szText);

            lstrcpyn(szText, prd->pszPath, ARRAYSIZE(szText));
            PathStripToRoot(szText);

            // get info about the file.
            SHFILEINFO sfi = {0};
            SHGetFileInfo(szText, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                SHGFI_USEFILEATTRIBUTES |
                SHGFI_ICON | SHGFI_LARGEICON | SHGFI_ADDOVERLAYS);

            ReplaceDlgIcon(prd->hDlg, IDD_ICON, sfi.hIcon);
        }
        SetTimer(prd->hDlg, IDT_RETRY, 2000, NULL);
        break;

    case WM_DESTROY:
        ReplaceDlgIcon(prd->hDlg, IDD_ICON, NULL);
        break;

    case WM_TIMER:
        _OnTimeCheckDiskForInsert(hDlg, prd);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            prd->hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;
        }
        break;

    default:
        if (IsQueryCancelAutoPlay(uMsg))
        {
             SetWindowLongPtr(hDlg, DWLP_MSGRESULT,  1);  // cancel AutoPlay
             return TRUE;
        }
        return FALSE;
    }

    return TRUE;
}

// the removable media specific find first that does the UI prompt
// check for HRESULT_FROM_WIN32(ERROR_CANCELLED) for end user cancel

STDAPI FindFirstRetryRemovable(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind)
{
    RETRY_DATA rd = {0};
    TCHAR szPath[MAX_PATH];

    StrCpyN(szPath, pszPath, ARRAYSIZE(szPath));
    PathStripToRoot(szPath);
    PathAppend(szPath, TEXT("*.*"));

    BOOL bPathChanged = (0 != StrCmpI(szPath, pszPath));

    rd.pszPath = szPath;
    rd.pfd = pfd;
    rd.phfind = phfind;
    rd.hr = E_OUTOFMEMORY;

    _GoModal(hwnd, punkModless, TRUE);
    DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_RETRYFOLDERENUM), hwnd, RetryDlgProc, (LPARAM)&rd);
    _GoModal(hwnd, punkModless, FALSE);
    if (SUCCEEDED(rd.hr))
    {
        if (bPathChanged)
        {
            // strip produced another path, we need to retry on the requested path
            if (S_OK == rd.hr)
            {
                FindClose(*phfind);
            }
            rd.hr = SHFindFirstFile(pszPath, pfd, phfind);
        }
    }
    return rd.hr;
}


/***********************************************************************\
        If the string was formatted as a UNC or Drive path, offer to
    create the directory path if it doesn't exist.

    PARAMETER:
        RETURN: S_OK It exists.
                FAILURE(): Caller should not display error UI because either
                        error UI was displayed or the user didn't want to create
                        the directory.
\***********************************************************************/
HRESULT _OfferToCreateDir(HWND hwnd, IUnknown *punkModless, LPCTSTR pszDir, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    int nResult = IDYES;

    StrCpyN(szPath, pszDir, ARRAYSIZE(szPath));
    PathRemoveFileSpec(szPath); // wild card removed

    if (SHPPFW_ASKDIRCREATE & dwFlags)
    {
        if (hwnd)
        {
            _GoModal(hwnd, punkModless, TRUE);
            nResult = ShellMessageBox(HINST_THISDLL, hwnd,
                            MAKEINTRESOURCE(IDS_CREATEFOLDERPROMPT),
                            MAKEINTRESOURCE(IDS_FOLDERDOESNTEXIST),
                            (MB_YESNO | MB_ICONQUESTION),
                            szPath);
            _GoModal(hwnd, punkModless, FALSE);
        }
        else
            nResult = IDNO;
    }

    if (IDYES == nResult)
    {
        _GoModal(hwnd, punkModless, TRUE);
        // SHCreateDirectoryEx() will display Error UI.
        DWORD err = SHCreateDirectoryEx(hwnd, szPath, NULL);
        hr = HRESULT_FROM_WIN32(err);
        _GoModal(hwnd, punkModless, FALSE);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);    // Until we get a valid directory, we can't do the download.
    }

    return hr;
}


/***********************************************************************\
    See if the path w/o the spec exits.  Examples:
    pszPath="C:\dir1\dir2\*.*",           Test="C:\dir1\dir2\"
    pszPath="\\unc\share\dir1\dir2\*.*",  Test="\\unc\share\dir1\dir2\"
\***********************************************************************/
BOOL PathExistsWithOutSpec(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];

    StrCpyN(szPath, pszPath, ARRAYSIZE(szPath));
    PathRemoveFileSpec(szPath);

    return PathFileExists(szPath);
}


/***********************************************************************\
    See if the Drive or UNC share exists.
    Examples:
    Path="C:\dir1\dir2\*.*",        Test="C:\"
    Path="\\unc\share\dir1\*.*",    Test="\\unc\share\"
\***********************************************************************/
BOOL PathExistsRoot(LPCTSTR pszPath)
{
    TCHAR szRoot[MAX_PATH];

    StrCpyN(szRoot, pszPath, ARRAYSIZE(szRoot));
    PathStripToRoot(szRoot);

    return PathFileExists(szRoot);
}

inline DWORD _Win32FromHresult(HRESULT hr)
{
    //
    //  NOTE - we get back 0x28 on 'Lock'ed volumes
    //  however even though that is the error that FindFirstFile
    //  returns, there is no corresponding entry in
    //  winerror.h and format message doesnt yield anything useful,
    //  so we map it to ERROR_ACCESS_DENIED.
    //
    if (HRESULT_FACILITY(hr) == FACILITY_WIN32
        && (HRESULT_CODE(hr) != 0x28))
        return HRESULT_CODE(hr);
    return ERROR_ACCESS_DENIED;
}

BOOL _IsMountedFolder(LPCTSTR pszPath, LPTSTR pszMountPath, UINT cchMountPath)
{
    BOOL fMountedOnFolder = FALSE;
    // first check if it is mounted on a folder
    if (GetVolumePathName(pszPath, pszMountPath, cchMountPath))
    {
        if ((0 != pszMountPath[2]) && (0 != pszMountPath[3]))
        {
            fMountedOnFolder = TRUE;
        }
    }
    return fMountedOnFolder;
}


// like the Win32 FindFirstFile() but post UI and returns errors in HRESULT
// in:
//      hwnd    NULL -> disable UI (but do net reconnects, etc)
//              non NULL enable UI including insert disk, format disk, net logon
//
// returns:
//      S_OK    hfind and find data are filled in with result
//      S_FALSE no results, but media is present (hfind == INVALID_HANDLE_VALUE)
//              (this is the empty enum case)
//      HRESULT_FROM_WIN32(ERROR_CANCELLED) - user saw UI, thus canceled the operation
//              or confirmed the failure
//      FAILED() win32 error codes in the hresult (path not found, file not found, etc)

STDAPI SHFindFirstFileRetry(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind, DWORD dwFlags)
{
    HANDLE hfindToClose = INVALID_HANDLE_VALUE;
    if (NULL == phfind)
        phfind = &hfindToClose;

    HRESULT hr = SHFindFirstFile(pszPath, pfd, phfind);

    if (FAILED(hr))
    {
        BOOL fNet = PathIsUNC(pszPath) || IsDisconnectedNetDrive(DRIVEID(pszPath));
        if (fNet)
        {
            hr = _RetryNetwork(hwnd, punkModless, pszPath, &fNet, pfd, phfind);
        }
        else if (hwnd)
        {
            if (PathRetryRemovable(hr, pszPath))
            {
                hr = FindFirstRetryRemovable(hwnd, punkModless, pszPath, pfd, phfind);
            }

            // disk should be in now, see if it needs format
            if (_IsUnformatedMediaResult(hr))
            {
                CMountPoint* pmtpt = CMountPoint::GetMountPoint(pszPath);
                if (pmtpt)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    if (pmtpt->IsFormattable())
                    {
                        TCHAR szMountPath[MAX_PATH];
                        if (_IsMountedFolder(pszPath, szMountPath, ARRAYSIZE(szMountPath)))
                        {
                            _GoModal(hwnd, punkModless, TRUE);
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_MVUNFORMATTED), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                                (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK),
                                                szMountPath);
                            _GoModal(hwnd, punkModless, FALSE);
                        }
                        else
                        {
                            int iDrive = PathGetDriveNumber(pszPath);
                            _GoModal(hwnd, punkModless, TRUE);
                            int nResult = ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_UNFORMATTED), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                               (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_YESNO),
                                               (DWORD)(iDrive + TEXT('A')));
                            _GoModal(hwnd, punkModless, FALSE);

                            if (IDYES == nResult)
                            {
                                _GoModal(hwnd, punkModless, TRUE);
                                DWORD dwError = SHFormatDrive(hwnd, iDrive, SHFMT_ID_DEFAULT, 0);
                                _GoModal(hwnd, punkModless, FALSE);

                                switch (dwError)
                                {
                                case SHFMT_ERROR:
                                case SHFMT_NOFORMAT:
                                    _GoModal(hwnd, punkModless, TRUE);
                                    ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_NOFMT), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                            (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK), (DWORD)(iDrive + TEXT('A')));
                                    _GoModal(hwnd, punkModless, FALSE);
                                    break;

                                default:
                                    hr = SHFindFirstFile(pszPath, pfd, phfind);  // try again after format
                                }
                            }
                        }
                    }
                    else
                    {
                        _GoModal(hwnd, punkModless, TRUE);
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_UNRECOGNIZED_DISK), MAKEINTRESOURCE(IDS_FORMAT_TITLE),
                                            (MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK),
                                            NULL);
                        _GoModal(hwnd, punkModless, FALSE);
                    }

                    pmtpt->Release();
                }
            }
        }

        // If the caller wants us to create the directory (with or without asking), we
        // need to see if we can display UI and if either that root exists (D:\ or \\unc\share\)
        // Note that for PERF we want to check the full path.
        if (FAILED_AND_NOT_CANCELED(hr) &&
            ((SHPPFW_DIRCREATE | SHPPFW_ASKDIRCREATE) & dwFlags) &&
             !PathExistsWithOutSpec(pszPath) && PathExistsRoot(pszPath))
        {
            hr = _OfferToCreateDir(hwnd, punkModless, pszPath, dwFlags);
            ASSERT(INVALID_HANDLE_VALUE == *phfind);

            if (SUCCEEDED(hr))
                hr = SHFindFirstFile(pszPath, pfd, phfind);  // try again after dir create
        }

        if (FAILED_AND_NOT_CANCELED(hr) && hwnd && !(SHPPFW_MEDIACHECKONLY & dwFlags))
        {
            DWORD err = _Win32FromHresult(hr);
            TCHAR szPath[MAX_PATH];

            UINT idTemplate = PathIsUNC(pszPath) ? IDS_ENUMERR_NETTEMPLATE2 : IDS_ENUMERR_FSTEMPLATE;    // "%2 is not accessible.\n\n%1"

            if (err == ERROR_PATH_NOT_FOUND)
                idTemplate = IDS_ENUMERR_PATHNOTFOUND;    // "%2 is not accessible.\n\nThis folder was moved or removed."

            lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));
            if (PathIsWild(szPath))
                PathRemoveFileSpec(szPath); // wild card removed

            _GoModal(hwnd, punkModless, TRUE);
            SHEnumErrorMessageBox(hwnd, idTemplate, err, szPath, fNet, MB_OK | MB_ICONHAND);
            _GoModal(hwnd, punkModless, FALSE);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    if (INVALID_HANDLE_VALUE != hfindToClose)
        FindClose(hfindToClose);

    return hr;
}

// TODO: Use the code in: \\orville\razzle\src\private\sm\sfc\dll\fileio.c to register
//       for CD/DVD inserts instead of constantly pegging the CPU and drive.  Too bad
//       it doesn't work for floppies.  SfcGetPathType(), RegisterForDevChange(),
//       SfcQueueCallback(), SfcIsTargetAvailable()
STDAPI SHPathPrepareForWrite(HWND hwnd, IUnknown *punkModless, LPCTSTR pwzPath, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];

    StrCpyN(szPath, pwzPath, ARRAYSIZE(szPath));
    if (SHPPFW_IGNOREFILENAME & dwFlags)
        PathRemoveFileSpec(szPath);      // Strip file name so we just check the dir.

    // We can't do anything about just a UNC server. "\\server" (no share)
    if (!PathIsUNCServer(szPath))
    {
        HANDLE hFind;
        WIN32_FIND_DATA wfd;
        PathAppend(szPath, TEXT("*.*"));

        hr = SHFindFirstFileRetry(hwnd, punkModless, szPath, &wfd, &hFind, dwFlags);
        if (S_OK == hr)
            FindClose(hFind);
        else if (S_FALSE == hr)
        {
            // S_FALSE from SHFindFirstFileRetry() means it exists but there
            // isn't a handle.  We want to return S_OK for Yes, and E_FAIL or S_FALSE for no.
            hr = S_OK;
        }
    }
    return hr;
}


STDAPI SHPathPrepareForWriteA(HWND hwnd, IUnknown *punkModless, LPCSTR pszPath, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH];

    SHAnsiToTChar(pszPath, szPath, ARRAYSIZE(szPath));
    return SHPathPrepareForWrite(hwnd, punkModless, szPath, dwFlags);
}

//
//  public export of SHBindToIDlist() has a slightly different
//  name so that we dont get compile link problems on legacy versions
//  of the shell.  shdocvw and browseui need to call SHBindToParentIDList()
STDAPI SHBindToParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    return SHBindToIDListParent(pidl, riid, ppv, ppidlLast);
}


// helper function to extract the target of a link file

STDAPI GetPathFromLinkFile(LPCTSTR pszLinkPath, LPTSTR pszTargetPath, int cchTargetPath)
{
    IShellLink* psl;
    HRESULT hr = LoadFromFile(CLSID_ShellLink, pszLinkPath, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        IShellLinkDataList* psldl;
        hr = psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psldl));
        if (SUCCEEDED(hr))
        {
            EXP_DARWIN_LINK* pexpDarwin;

            hr = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
            if (SUCCEEDED(hr))
            {
                // woah, this is a darwin link. darwin links don't really have a path so we
                // will fail in this case
                SHUnicodeToTChar(pexpDarwin->szwDarwinID, pszTargetPath, cchTargetPath);
                LocalFree(pexpDarwin);
                hr = S_FALSE;
            }
            else
            {
                hr = psl->GetPath(pszTargetPath, cchTargetPath, NULL, NULL);

                // FEATURE: (reinerf) - we might try getting the path from the idlist if
                // pszTarget is empty (eg a link to "Control Panel" will return empyt string).

            }
            psldl->Release();
        }
        psl->Release();
    }

    return hr;
}

// a .EXE that is registered in the app paths key, this implies it is installed

STDAPI_(BOOL) PathIsRegisteredProgram(LPCTSTR pszPath)
{
    TCHAR szTemp[MAX_PATH];
    //
    //  PathIsBinaryExe() returns TRUE for .exe, .com
    //  PathIsExe()       returns TRUE for .exe, .com, .bat, .cmd, .pif
    //
    //  we dont want to treat .pif files as EXE files, because the
    //  user sees them as links.
    //
    return PathIsBinaryExe(pszPath) && PathToAppPath(pszPath, szTemp);
}

STDAPI_(void) ReplaceDlgIcon(HWND hDlg, UINT id, HICON hIcon)
{
    hIcon = (HICON)SendDlgItemMessage(hDlg, id, STM_SETICON, (WPARAM)hIcon, 0);
    if (hIcon)
        DestroyIcon(hIcon);
}

STDAPI_(LONG) GetOfflineShareStatus(LPCTSTR pcszPath)
{
    ASSERT(pcszPath);
    LONG lResult = CSC_SHARESTATUS_INACTIVE;
    HWND hwndCSCUI = FindWindow(STR_CSCHIDDENWND_CLASSNAME, NULL);
    if (hwndCSCUI)
    {
        COPYDATASTRUCT cds;
        cds.dwData = CSCWM_GETSHARESTATUS;
        cds.cbData = sizeof(WCHAR) * (lstrlenW(pcszPath) + 1);
        cds.lpData = (void *) pcszPath;
        lResult = (LONG)SendMessage(hwndCSCUI, WM_COPYDATA, 0, (LPARAM) &cds);
    }
    return lResult;
}

#define _FLAG_CSC_COPY_STATUS_LOCALLY_DIRTY         (FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED   | \
                                                     FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_DELETED         | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_CREATED)

// These are defined in shellapi.h, but require _WIN32_WINNT >= 0x0500.
// This file is currently compiled with _WIN32_WINNT = 0x0400.  Rather
// that futz with the compile settings, just #define duplicates here.
// They'd better not change (ever) since this is a documented API.
#ifndef OFFLINE_STATUS_LOCAL
#define OFFLINE_STATUS_LOCAL        0x0001
#define OFFLINE_STATUS_REMOTE       0x0002
#define OFFLINE_STATUS_INCOMPLETE   0x0004
#endif

STDAPI SHIsFileAvailableOffline(LPCWSTR pwszPath, LPDWORD pdwStatus)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szUNC[MAX_PATH];

    szUNC[0] = 0;

    if (pdwStatus)
    {
        *pdwStatus = 0;
    }

    //
    // Need full UNC path (TCHAR) for calling CSC APIs.
    // (Non-net paths are "not cached" by definition.)
    //
    if (pwszPath && pwszPath[0])
    {
        if (PathIsUNCW(pwszPath))
        {
            SHUnicodeToTChar(pwszPath, szUNC, ARRAYSIZE(szUNC));
        }
        else if (L':' == pwszPath[1] && L':' != pwszPath[0])
        {
            // Check for mapped net drive
            TCHAR szPath[MAX_PATH];
            SHUnicodeToTChar(pwszPath, szPath, ARRAYSIZE(szPath));

            DWORD dwLen = ARRAYSIZE(szUNC);
            if (S_OK == SHWNetGetConnection(szPath, szUNC, &dwLen))
            {
                // Got \\server\share, append the rest
                PathAppend(szUNC, PathSkipRoot(szPath));
            }
            // else not mapped
        }
    }

    // Do we have a UNC path?
    if (szUNC[0])
    {
        // Assume CSC not running
        hr = E_FAIL;

        if (CSCIsCSCEnabled())
        {
            DWORD dwCscStatus = 0;

            // Assume cached
            hr = S_OK;

            if (!CSCQueryFileStatus(szUNC, &dwCscStatus, NULL, NULL))
            {
                // Not cached, return failure
                DWORD dwErr = GetLastError();
                if (ERROR_SUCCESS == dwErr)
                    dwErr = ERROR_PATH_NOT_FOUND;
                hr = HRESULT_FROM_WIN32(dwErr);
            }
            else if (pdwStatus)
            {
                // File is cached, and caller wants extra status info
                DWORD dwResult = 0;
                BOOL bDirty = FALSE;

                // Is it a sparse file?
                // Note: CSC always marks directories as sparse
                if ((dwCscStatus & FLAG_CSC_COPY_STATUS_IS_FILE) &&
                    (dwCscStatus & FLAG_CSC_COPY_STATUS_SPARSE))
                {
                    dwResult |= OFFLINE_STATUS_INCOMPLETE;
                }

                // Is it dirty?
                if (dwCscStatus & _FLAG_CSC_COPY_STATUS_LOCALLY_DIRTY)
                {
                    bDirty = TRUE;
                }

                // Get share status
                PathStripToRoot(szUNC);
                dwCscStatus = 0;
                if (CSCQueryFileStatus(szUNC, &dwCscStatus, NULL, NULL))
                {
                    if (dwCscStatus & FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP)
                    {
                        // Server offline --> all opens are local (only)
                        dwResult |= OFFLINE_STATUS_LOCAL;
                    }
                    else if (bDirty)
                    {
                        // Server online, but file is dirty --> open is remote
                        dwResult |= OFFLINE_STATUS_REMOTE;
                    }
                    else
                    {
                        // Server is online and file is in sync --> open is both
                        dwResult |= OFFLINE_STATUS_LOCAL | OFFLINE_STATUS_REMOTE;

                        if ((dwCscStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_VDO)
                        {
                            // Feature: (JeffreyS) The share is VDO, but that only affects files
                            // opened for execution. Is there a way to tell whether
                            // the file is only open locally?
                        }
                    }
                }
                else
                {
                    // Very strange. CSCQueryFileStatus succeeded for the file,
                    // but failed for the share.  Assume no active connection
                    // exists and the server is online (open both).
                    dwResult |= OFFLINE_STATUS_LOCAL | OFFLINE_STATUS_REMOTE;
                }

                *pdwStatus = dwResult;
            }
        }
    }

    return hr;
}

STDAPI_(BOOL) GetShellClassInfo(LPCTSTR pszPath, LPTSTR pszKey, LPTSTR pszBuffer, DWORD cchBuffer)
{
    *pszBuffer = 0;

    TCHAR szIniFile[MAX_PATH];
    PathCombine(szIniFile, pszPath, TEXT("Desktop.ini"));

    return (SHGetIniString(TEXT(".ShellClassInfo"), pszKey, pszBuffer, cchBuffer, szIniFile) ? TRUE : FALSE);
}

STDAPI_(BOOL) GetShellClassInfoInfoTip(LPCTSTR pszPath, LPTSTR pszBuffer, DWORD cchBuffer)
{
    BOOL bRet = GetShellClassInfo(pszPath, TEXT("InfoTip"), pszBuffer, cchBuffer);
    if (bRet)    
        SHLoadIndirectString(pszBuffer, pszBuffer, cchBuffer, NULL);
    else if (cchBuffer)
        *pszBuffer = 0;
    return bRet;
}

TCHAR const c_szUserAppData[] = TEXT("%userappdata%");

void ExpandUserAppData(LPTSTR pszFile)
{
    //Check if the given string has %UserAppData%
    LPTSTR psz = StrChr(pszFile, TEXT('%'));
    if (psz)
    {
        if (!StrCmpNI(psz, c_szUserAppData, ARRAYSIZE(c_szUserAppData)-1))
        {
            TCHAR szTempBuff[MAX_PATH];
            if (SHGetSpecialFolderPath(NULL, szTempBuff, CSIDL_APPDATA, TRUE))
            {
                PathAppend(szTempBuff, psz + lstrlen(c_szUserAppData));

                //Copy back to the input buffer!
                lstrcpy(psz, szTempBuff);
            }
        }
    }
}


TCHAR const c_szWebDir[] = TEXT("%WebDir%");
void ExpandWebDir(LPTSTR pszFile, int cch)
{
    //Check if the given string has %WebDir%
    LPTSTR psz = StrChr(pszFile, TEXT('%'));
    if (psz)
    {
        if (!StrCmpNI(psz, c_szWebDir, ARRAYSIZE(c_szWebDir) - 1))
        {
            //Skip the %WebDir% string plus the following backslash.
            LPTSTR pszPathAndFileName = psz + lstrlen(c_szWebDir) + sizeof('\\');
            if (pszPathAndFileName && (pszPathAndFileName != psz))
            {
                TCHAR szTempBuff[MAX_PATH];
                StrCpyN(szTempBuff, pszPathAndFileName, ARRAYSIZE(szTempBuff));
                SHGetWebFolderFilePath(szTempBuff, pszFile, cch);
            }
        }
    }
}


void ExpandOtherVariables(LPTSTR pszFile, int cch)
{
    ExpandUserAppData(pszFile);
    ExpandWebDir(pszFile, cch);
}


void SubstituteWebDir(LPTSTR pszFile, int cch)
{
    TCHAR szWebDirPath[MAX_PATH];

    if (SUCCEEDED(SHGetWebFolderFilePath(TEXT("folder.htt"), szWebDirPath, ARRAYSIZE(szWebDirPath))))
    {
        LPTSTR pszWebDirPart;

        PathRemoveFileSpec(szWebDirPath);

        pszWebDirPart = StrStrI(pszFile, szWebDirPath);
        if (pszWebDirPart)
        {
            TCHAR szTemp[MAX_PATH];
            int cchBeforeWebDir = (int)(pszWebDirPart - pszFile);

            // copy the part after C:\WINNT\Web into szTemp
            lstrcpyn(szTemp, pszWebDirPart + lstrlen(szWebDirPath), ARRAYSIZE(szTemp));

            // replace C:\WINNT\Web with %WebDir%
            lstrcpyn(pszWebDirPart, c_szWebDir, cch - cchBeforeWebDir);

            // add back on the part that came after
            lstrcatn(pszFile, szTemp, cch);
        }
    }
}

STDAPI_(BOOL) IsExplorerBrowser(IShellBrowser *psb)
{
    HWND hwnd;
    return psb && SUCCEEDED(psb->GetControlWindow(FCW_TREE, &hwnd)) && hwnd;
}

STDAPI_(BOOL) IsExplorerModeBrowser(IUnknown *psite)
{
    BOOL bRet = FALSE;
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(psite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        bRet = IsExplorerBrowser(psb);
        psb->Release();
    }
    return bRet;
}

STDAPI InvokeFolderPidl(LPCITEMIDLIST pidl, int nCmdShow)
{
    SHELLEXECUTEINFO ei = {0};
    LPITEMIDLIST pidlFree = NULL;

    if (IS_INTRESOURCE(pidl))
    {
        pidlFree = SHCloneSpecialIDList(NULL, PtrToUlong((void *)pidl), FALSE);
        pidl = pidlFree;
    }

    ei.cbSize = sizeof(ei);
    ei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME | SEE_MASK_FLAG_DDEWAIT;
    ei.lpIDList = (void *)pidl;
    ei.nShow = nCmdShow;
    ei.lpClass = c_szFolderClass;

    HRESULT hr = ShellExecuteEx(&ei) ? S_OK : HRESULT_FROM_WIN32(GetLastError());

    ILFree(pidlFree);

    return hr;
}


HRESULT GetRGBFromBStr(BSTR bstr, COLORREF *pclr)
{
    *pclr = CLR_INVALID;

    HRESULT  hr = E_FAIL;
    if (bstr)
    {
        TCHAR szTemp[9], szColor[11] = {'0','x',0, };

        SHUnicodeToTChar(bstr, szTemp, ARRAYSIZE(szTemp));

        LPTSTR pszPound = StrChr(szTemp, TEXT('#'));
        if (pszPound)
            pszPound++; //Skip the pound sign!
        else
            pszPound = szTemp;  //Pound sign is missing. Use the whole strng
        StrCatN(szColor, pszPound, ARRAYSIZE(szColor));

        INT rgb;
        if (StrToIntEx(szColor, STIF_SUPPORT_HEX, &rgb))
        {
            *pclr = (COLORREF)(((rgb & 0x000000ff) << 16) | (rgb & 0x0000ff00) | ((rgb & 0x00ff0000) >> 16));
            hr = S_OK;
        }
    }
    return hr;
}

STDAPI IUnknown_HTMLBackgroundColor(IUnknown *punk, COLORREF *pclr)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IHTMLDocument2 *pDoc;
        hr = punk->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
        if (SUCCEEDED(hr))
        {
            VARIANT v;

            v.vt = VT_BSTR;
            v.bstrVal = NULL;

            hr = pDoc->get_bgColor(&v);
            if (SUCCEEDED(hr))
            {
                hr = GetRGBFromBStr(v.bstrVal, pclr);
                VariantClear(&v);
            }
            pDoc->Release();
        }
    }
    return hr;
}

STDAPI_(int) MapSCIDToColumn(IShellFolder2* psf2, const SHCOLUMNID* pscid)
{
    int i = 0;
    SHCOLUMNID scid;
    while (SUCCEEDED(psf2->MapColumnToSCID(i, &scid)))
    {
        if (IsEqualSCID(scid, *pscid))
            return i;
        i++;
    }
    return 0;
}

#ifdef COLUMNS_IN_DESKTOPINI
#define IsDigit(c) ((c) >= TEXT('0') && c <= TEXT('9'))

STDAPI _GetNextCol(LPTSTR* ppszText, DWORD* pnCol)
{
    HRESULT hr = S_OK;
    TCHAR *pszText;

    if (*ppszText[0])
    {
        pszText = StrChrI(*ppszText, TEXT(','));
        if (pszText)
        {
            *pszText = 0;
            *pnCol = StrToInt(*ppszText);
            *ppszText = ++pszText;
        }
        else if (IsDigit(*ppszText[0]))
        {
            *pnCol = StrToInt(*ppszText);
            *ppszText = 0;
        }
    }
    else
        hr = E_FAIL;

    return hr;
}
#endif




STDAPI_(int) DPA_ILFreeCallback(void *p, void *d)
{
    ILFree((LPITEMIDLIST)p);    // ILFree checks for NULL pointer
    return 1;
}

STDAPI_(void) DPA_FreeIDArray(HDPA hdpa)
{
    if (hdpa)
        DPA_DestroyCallback(hdpa, DPA_ILFreeCallback, 0);
}

STDAPI_(void) EnableAndShowWindow(HWND hWnd, BOOL bShow)
{
    ShowWindow(hWnd, bShow ? SW_SHOW : SW_HIDE);
    EnableWindow(hWnd, bShow);
}


//
// Helper function which returns a string value instead of the SHELLDETAILS
// object, to be used by clients which are only interested in the returned
// string value and want to avoid the hassle of doing a STRRET to STR conversion,
//
STDAPI DetailsOf(IShellFolder2 *psf2, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch)
{
    *psz = 0;
    SHELLDETAILS sd;
    HRESULT hr = psf2->GetDetailsOf(pidl, flags, &sd);
    if (SUCCEEDED(hr))
    {
        hr = StrRetToBuf(&sd.str, pidl, psz, cch);
    }
    return hr;
}

#pragma warning(push,4)

//  --------------------------------------------------------------------------
//  ::SHGetUserDisplayName
//
//  Arguments:  pszDisplayName  =   Buffer to retrieve the display name.
//              puLen           =   [in/out] Size of buffer
//
//  Purpose:    Returns the display name, or the logon name if the display name
//              is not available
//
//  Returns:    HRESULT
//
//
//
//  History:    2000-03-03  vtan        created
//              2001-03-01  fabriced    use GetUserNameEx
//  --------------------------------------------------------------------------

STDAPI  SHGetUserDisplayName (LPWSTR pszDisplayName, PULONG puLen)

{
    HRESULT     hr;

    //  Validate pszDisplayName.

    if ((pszDisplayName == NULL) || (puLen == NULL) || IsBadWritePtr(pszDisplayName, (*puLen * sizeof(TCHAR))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = S_OK;
        if (!GetUserNameEx(NameDisplay, pszDisplayName, puLen))
        {
            TCHAR szName[UNLEN+1];
            DWORD dwLen = ARRAYSIZE(szName);
            DWORD dwLastError = GetLastError();
            if (GetUserName(szName, &dwLen))
            {
                // If we are not on a domain, GetUserNameEx does not work :-(.
                if (dwLastError == ERROR_NONE_MAPPED)
                {
                    PUSER_INFO_2                pUserInfo;

                    DWORD dwErrorCode = NetUserGetInfo(NULL,  // Local account
                                                 szName,
                                                 2,
                                                 reinterpret_cast<LPBYTE*>(&pUserInfo));
                    if (ERROR_SUCCESS == dwErrorCode)
                    {
                        if (pUserInfo->usri2_full_name[0] != L'\0')
                        {
                            StrCpyN(pszDisplayName, pUserInfo->usri2_full_name, *puLen);
                            *puLen = lstrlen(pUserInfo->usri2_full_name) + 1;
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                        TW32(NetApiBufferFree(pUserInfo));
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwErrorCode);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(dwLastError);
                }

                if (FAILED(hr))
                {
                    hr = S_OK;
                    StrCpyN(pszDisplayName, szName, *puLen);
                    *puLen = dwLen;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    return hr;
}

//  --------------------------------------------------------------------------
//  ::SHIsCurrentThreadInteractive
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Determine whether the current thread is running on the
//              interactive desktop. This takes into account terminal services
//              and console disconnects as well.
//
//  History:    2000-03-23  vtan        created
//  --------------------------------------------------------------------------

STDAPI_(BOOL) SHIsCurrentThreadInteractive (void)
{
    BOOL fResult = FALSE;

    //  Open handles to the current process window station and thread
    //  desktop. These handles do NOT need to be closed.

    HWINSTA hWindowStation = GetProcessWindowStation();
    if (hWindowStation != NULL)
    {
        HDESK hDesktop = GetThreadDesktop(GetCurrentThreadId());
        if (hDesktop != NULL)
        {
            DWORD dwLengthNeeded = 0;
            (BOOL)GetUserObjectInformation(hWindowStation, UOI_NAME, NULL, 0, &dwLengthNeeded);
            if (dwLengthNeeded != 0)
            {
                TCHAR *pszWindowStationName = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwLengthNeeded));
                if (pszWindowStationName != NULL)
                {
                    if (GetUserObjectInformation(hWindowStation, UOI_NAME, pszWindowStationName, dwLengthNeeded, &dwLengthNeeded) != FALSE)
                    {
                        dwLengthNeeded = 0;
                        (BOOL)GetUserObjectInformation(hDesktop, UOI_NAME, NULL, 0, &dwLengthNeeded);
                        if (dwLengthNeeded != 0)
                        {
                            TCHAR *pszDesktopName = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwLengthNeeded));
                            if (pszDesktopName != NULL)
                            {
                                if (GetUserObjectInformation(hDesktop, UOI_NAME, pszDesktopName, dwLengthNeeded, &dwLengthNeeded) != FALSE)
                                {
                                    //  This is a hard coded string comparison. This name
                                    //  never changes WinSta0\Default

                                    if (lstrcmpi(pszWindowStationName, TEXT("WinSta0")) == 0)
                                    {
                                        fResult = (lstrcmpi(pszDesktopName, TEXT("WinLogon")) != 0 &&
                                                lstrcmpi(pszDesktopName, TEXT("Screen-Saver")) != 0);
                                    }
                                }
                                LocalFree(pszDesktopName);
                            }
                        }
                    }
                    LocalFree(pszWindowStationName);
                }
            }
        }
    }
    return fResult;
}

static  const TCHAR     s_szBaseKeyName[]           =   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\UnreadMail");
static  const TCHAR     s_szMessageCountValueName[] =   TEXT("MessageCount");
static  const TCHAR     s_szTimeStampValueName[]    =   TEXT("TimeStamp");
static  const TCHAR     s_szApplicationValueName[]  =   TEXT("Application");

//  --------------------------------------------------------------------------
//  ReadSingleUnreadMailCount
//
//  Arguments:  hKey                    =   Base HKEY to read info from.
//              pdwCount                =   Count returned.
//              pFileTime               =   FILETIME stamp returned.
//              pszShellExecuteCommand  =   Execute command returned.
//              cchShellExecuteCommand  =   Size of execute command buffer.
//
//  Returns:    LONG
//
//  Purpose:    Reads a single unread mail account information from the given
//              HKEY of the mail account.
//
//  History:    2000-06-20  vtan        created
//  --------------------------------------------------------------------------

LONG    ReadSingleUnreadMailCount (HKEY hKey, DWORD *pdwCount, FILETIME *pFileTime, LPTSTR pszShellExecuteCommand, int cchShellExecuteCommand)

{
    LONG    lError;
    DWORD   dwType, dwData, dwDataSize;

    dwDataSize = sizeof(*pdwCount);
    lError = RegQueryValueEx(hKey,
                             s_szMessageCountValueName,
                             NULL,
                             &dwType,
                             reinterpret_cast<LPBYTE>(&dwData),
                             &dwDataSize);
    if (ERROR_SUCCESS == lError)
    {
        FILETIME    fileTime;

        if ((pdwCount != NULL) && !IsBadWritePtr(pdwCount, sizeof(*pdwCount)) && (REG_DWORD == dwType))
        {
            *pdwCount = dwData;
        }
        dwDataSize = sizeof(fileTime);
        lError = RegQueryValueEx(hKey,
                                 s_szTimeStampValueName,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>(&fileTime),
                                 &dwDataSize);
        if (ERROR_SUCCESS == lError)
        {
            TCHAR   szTemp[512];

            if ((pFileTime != NULL) && !IsBadWritePtr(pFileTime, sizeof(*pFileTime)) && (REG_BINARY == dwType))
            {
                *pFileTime = fileTime;
            }
            dwDataSize = sizeof(szTemp);
            lError = SHQueryValueEx(hKey,
                                    s_szApplicationValueName,
                                    NULL,
                                    &dwType,
                                    reinterpret_cast<LPBYTE>(szTemp),
                                    &dwDataSize);
            if (ERROR_SUCCESS == lError)
            {
                if ((pszShellExecuteCommand != NULL) && !IsBadWritePtr(pszShellExecuteCommand, cchShellExecuteCommand * sizeof(TCHAR)) && (REG_SZ == dwType))
                {
                    (TCHAR*)lstrcpyn(pszShellExecuteCommand, szTemp, cchShellExecuteCommand);
                }
            }
        }
    }
    return lError;
}

//  --------------------------------------------------------------------------
//  ::SHEnumerateUnreadMailAccounts
//
//  Arguments:  hKeyUser        =   HKEY to user's hive.
//              dwIndex         =   Index of mail account.
//              pszMailAddress  =   Returned mail address for account.
//              cchMailAddress  =   Characters in mail address buffer.
//
//  Returns:    HRESULT
//
//  Purpose:    Given an index returns the actual indexed email account from
//              the given user's hive.
//
//  History:    2000-06-29  vtan        created
//  --------------------------------------------------------------------------

STDAPI  SHEnumerateUnreadMailAccounts (HKEY hKeyUser, DWORD dwIndex, LPTSTR pszMailAddress, int cchMailAddress)

{
    HRESULT     hr;
    LONG        lError;
    HKEY        hKey;

    //  Parameter validation.

    if (IsBadWritePtr(pszMailAddress, cchMailAddress * sizeof(TCHAR)))
    {
        return E_INVALIDARG;
    }

    //  Open the unread mail

    lError = RegOpenKeyEx(hKeyUser != NULL ? hKeyUser : HKEY_CURRENT_USER,
                          s_szBaseKeyName,
                          0,
                          KEY_ENUMERATE_SUB_KEYS,
                          &hKey);
    if (ERROR_SUCCESS == lError)
    {
        DWORD       dwMailAddressSize;
        FILETIME    ftLastWriteTime;

        //  Get the given index mail address.

        dwMailAddressSize = static_cast<DWORD>(cchMailAddress * sizeof(TCHAR));
        lError = RegEnumKeyEx(hKey,
                              dwIndex,
                              pszMailAddress,
                              &dwMailAddressSize,
                              NULL,
                              NULL,
                              NULL,
                              &ftLastWriteTime);
        if (ERROR_SUCCESS != lError)
        {
            pszMailAddress[0] = TEXT('\0');
        }
        TW32(RegCloseKey(hKey));
    }
    if (ERROR_SUCCESS == lError)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lError);
    }
    return hr;
}

//  --------------------------------------------------------------------------
//  ::SHGetUnreadMailCount
//
//  Arguments:  hKeyUser                =   HKEY to user's hive.
//              pszMailAddress          =   Mail address for account.
//              pdwCount                =   Number of unread messages.
//              pszShellExecuteCommand  =   Execution command for application.
//              cchShellExecuteCommand  =   Number of characters in buffer.
//
//  Returns:    HRESULT
//
//  Purpose:    Reads unread mail messages for the given user and mail
//              address. If being run in a user's environment then hKeyUser
//              should be NULL. This will use HKEY_CURRENT_USER. If being run
//              from the SYSTEM context this will be HKEY_USERS\{SID}.
//
//              Callers may pass NULL for output parameters if not required.
//
//  History:    2000-06-20  vtan        created
//  --------------------------------------------------------------------------

STDAPI  SHGetUnreadMailCount (HKEY hKeyUser, LPCTSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPTSTR pszShellExecuteCommand, int cchShellExecuteCommand)

{
    HRESULT     hr;
    LONG        lError;
    HKEY        hKey;
    TCHAR       szTemp[512];

    //  Validate parameters. Valid parameters actually depends on pszMailAddress
    //  If pszMailAddress is NULL then the total unread mail count for ALL accounts
    //  is returned and pszShellExecuteCommand is ignored and MUST be
    //  NULL. pFileTime can be null and if so it is ignored but if it is non null, it
    //  is a filter to show only unread mail entries that are newer than the specified 
    //  filetime. Otherwise only items for the specified mail account are returned.

    if (pszMailAddress == NULL)
    {
        if (IsBadWritePtr(pdwCount, sizeof(*pdwCount)) ||
            (pszShellExecuteCommand != NULL) ||
            (cchShellExecuteCommand != 0))
        {
            return E_INVALIDARG;
        }
        else
        {
            LONG    lError;

            *pdwCount = 0;
            lError = RegOpenKeyEx(hKeyUser != NULL ? hKeyUser : HKEY_CURRENT_USER,
                                  s_szBaseKeyName,
                                  0,
                                  KEY_ENUMERATE_SUB_KEYS,
                                  &hKey);
            if (ERROR_SUCCESS == lError)
            {
                DWORD       dwIndex, dwTempSize;
                FILETIME    ftLastWriteTime;

                //  Because this uses advapi32!RegEnumKeyEx and this returns items
                //  in an arbitrary order and is subject to indeterminate behavior
                //  when keys are added while the key is enumerated there exists a
                //  possible race condition / dual access problem. Deal with this
                //  if it shows up. It's possible for a mail application to write
                //  information at the exact time this loop is retrieving the
                //  information. Slim chance but still possible.

                dwIndex = 0;
                do
                {
                    dwTempSize = ARRAYSIZE(szTemp);
                    lError = RegEnumKeyEx(hKey,
                                          dwIndex++,
                                          szTemp,
                                          &dwTempSize,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &ftLastWriteTime);
                    if (ERROR_SUCCESS == lError)
                    {
                        HKEY    hKeyMailAccount;

                        lError = RegOpenKeyEx(hKey,
                                              szTemp,
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKeyMailAccount);
                        if (ERROR_SUCCESS == lError)
                        {
                            DWORD   dwCount;
                            FILETIME ft;

                            lError = ReadSingleUnreadMailCount(hKeyMailAccount, &dwCount, &ft, NULL, 0);
                            
                            if (ERROR_SUCCESS == lError)
                            {
                                BOOL ftExpired = false;
                                // If they pass in a pFileTime, use it as a filter and only
                                // count accounts that have been updated since the passed
                                // in file time
                                if (pFileTime)
                                {
                                    ftExpired = (CompareFileTime(&ft, pFileTime) < 0);
                                }

                                if (!ftExpired)
                                {
                                    *pdwCount += dwCount;
                                }
                            }
                            TW32(RegCloseKey(hKeyMailAccount));
                        }
                    }
                } while (ERROR_SUCCESS == lError);

                //  Ignore the ERROR_NO_MORE_ITEMS that is returned when the
                //  enumeration is done.

                if (ERROR_NO_MORE_ITEMS == lError)
                {
                    lError = ERROR_SUCCESS;
                }
                TW32(RegCloseKey(hKey));
            }
            if (ERROR_SUCCESS == lError)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lError);
            }
        }
    }
    else
    {
        if (IsBadStringPtr(pszMailAddress, static_cast<UINT_PTR>(-1)))
        {
            return E_INVALIDARG;
        }

        //  Calculate the length of the registry path where we will create the
        //  key that will store the values. This is:
        //
        //  HKCU\Software\Microsoft\Windows\CurrentVersion\UnreadMail\{MailAddr}
        //
        //  Note that a NULL terminator is not used in the comparison because
        //  ARRAYSIZE on the static string is used which includes '\0'.

        if ((ARRAYSIZE(s_szBaseKeyName) + sizeof('\\') + lstrlen(pszMailAddress)) < ARRAYSIZE(szTemp))
        {
            lstrcpy(szTemp, s_szBaseKeyName);
            lstrcat(szTemp, TEXT("\\"));
            lstrcat(szTemp, pszMailAddress);
            lError = RegOpenKeyEx(hKeyUser != NULL ? hKeyUser : HKEY_CURRENT_USER,
                                  szTemp,
                                  0,
                                  KEY_QUERY_VALUE,
                                  &hKey);
            if (ERROR_SUCCESS == lError)
            {
                lError = ReadSingleUnreadMailCount(hKey, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
                TW32(RegCloseKey(hKey));
            }
            if (ERROR_SUCCESS == lError)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lError);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

//  --------------------------------------------------------------------------
//  ::SHSetUnreadMailCount
//
//  Arguments:  pszMailAddress          =   Mail address for account.
//              dwCount                 =   Number of unread messages.
//              pszShellExecuteCommand  =   Execution command for application.
//
//  Returns:    HRESULT
//
//  Purpose:    Writes unread mail information to the registry for the
//              current user. Do NOT call this API from a system process
//              impersonating a user because it uses HKEY_CURRENT_USER. If
//              this is required in future a thread impersonation token
//              check will be required.
//
//  History:    2000-06-19  vtan        created
//  --------------------------------------------------------------------------

STDAPI  SHSetUnreadMailCount (LPCTSTR pszMailAddress, DWORD dwCount, LPCTSTR pszShellExecuteCommand)

{
    HRESULT     hr;
    TCHAR       szTemp[512];

    //  Validate parameters.

    if (IsBadStringPtr(pszMailAddress, static_cast<UINT_PTR>(-1)) ||
        IsBadStringPtr(pszShellExecuteCommand, static_cast<UINT_PTR>(-1)))
    {
        return E_INVALIDARG;
    }

    //  Calculate the length of the registry path where we will create the
    //  key that will store the values. This is:
    //
    //  HKCU\Software\Microsoft\Windows\CurrentVersion\UnreadMail\{MailAddr}
    //
    //  Note that a NULL terminator is not used in the comparison because
    //  ARRAYSIZE on the static string is used which includes '\0'.

    if ((ARRAYSIZE(s_szBaseKeyName) + sizeof('\\') + lstrlen(pszMailAddress)) < ARRAYSIZE(szTemp))
    {
        LONG    lError;
        DWORD   dwDisposition;
        HKEY    hKey;

        lstrcpy(szTemp, s_szBaseKeyName);
        lstrcat(szTemp, TEXT("\\"));
        lstrcat(szTemp, pszMailAddress);
        lError = RegCreateKeyEx(HKEY_CURRENT_USER,
                                szTemp,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE,
                                NULL,
                                &hKey,
                                &dwDisposition);
        if (ERROR_SUCCESS == lError)
        {
            lError = RegSetValueEx(hKey,
                                   s_szMessageCountValueName,
                                   0,
                                   REG_DWORD,
                                   reinterpret_cast<LPBYTE>(&dwCount),
                                   sizeof(dwCount));
            if (ERROR_SUCCESS == lError)
            {
                FILETIME    fileTime;

                GetSystemTimeAsFileTime(&fileTime);
                lError = RegSetValueEx(hKey,
                                       s_szTimeStampValueName,
                                       0,
                                       REG_BINARY,
                                       reinterpret_cast<LPBYTE>(&fileTime),
                                       sizeof(fileTime));
                if (ERROR_SUCCESS == lError)
                {
                    DWORD   dwType;

                    if (PathUnExpandEnvStrings(pszShellExecuteCommand, szTemp, ARRAYSIZE(szTemp)) != FALSE)
                    {
                        dwType = REG_EXPAND_SZ;
                    }
                    else
                    {
                        (TCHAR*)lstrcpy(szTemp, pszShellExecuteCommand);
                        dwType = REG_SZ;
                    }
                    lError = RegSetValueEx(hKey,
                                           s_szApplicationValueName,
                                           0,
                                           REG_SZ,      // This is HKLM so it doesn't need to be REG_EXPAND_SZ.
                                           reinterpret_cast<LPBYTE>(szTemp),
                                           (lstrlen(szTemp) + sizeof('\0')) * sizeof(TCHAR));
                }
            }
            TW32(RegCloseKey(hKey));
        }
        if (ERROR_SUCCESS == lError)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lError);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#pragma warning(pop)


// wrapper around name space stuff to parse printer names
// returns fully qualified pidl for printer
static HRESULT _ParsePrinterName(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl, IBindCtx *pbc = NULL)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;

        LPITEMIDLIST pidlFolder;
        hr = SHGetFolderLocation(NULL, CSIDL_PRINTERS, NULL, 0, &pidlFolder);

        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));

            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = psf->ParseDisplayName(NULL, pbc, (LPWSTR)pszPrinter, NULL, &pidl, NULL);

                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidlFolder, pidl, ppidl);
                    ILFree(pidl);
                }
                psf->Release();
            }
            ILFree(pidlFolder);
        }
    }

    return hr;
}

STDAPI ParsePrinterName(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl)
{
    // invoke the internal routine with no bind context
    return _ParsePrinterName(pszPrinter, ppidl, NULL);
}

STDAPI ParsePrinterNameEx(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl, BOOL bValidated, DWORD dwType, USHORT uFlags)
{
    // prepare the bind context
    IPrintersBindInfo *pbi;
    HRESULT hr = Printers_CreateBindInfo(pszPrinter, dwType, bValidated, NULL, &pbi);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = pbc->RegisterObjectParam(PRINTER_BIND_INFO, pbi);
            if (SUCCEEDED(hr))
            {
                // invoke the internal routine with a valid bind context
                hr = _ParsePrinterName(pszPrinter, ppidl, pbc);
            }
            pbc->Release();
        }
        pbi->Release();
    }

    return hr;
}

//
// A function to read a value from the registry and return it as a variant
// Currently it handles the following registry data types - 
//
// DWORD -> returns a Variant int
// REG_SZ, REG_EXPAND_SZ -> returns a Variant str
//
STDAPI GetVariantFromRegistryValue(HKEY hkey, LPCTSTR pszValueName, VARIANT *pv)
{
    HRESULT hr = E_FAIL;
    
    BYTE ab[INFOTIPSIZE * sizeof(TCHAR)]; // this is the largest string value we expect
    DWORD cb = sizeof(ab), dwType;        
    
    if (ERROR_SUCCESS == RegQueryValueEx(hkey, pszValueName, NULL, &dwType, (LPBYTE) ab, &cb))
    {
        switch (dwType)
        {
        case REG_SZ:
        case REG_EXPAND_SZ:
            hr = InitVariantFromStr(pv, (LPCTSTR) ab);
            break;
            
        case REG_DWORD:
            pv->vt = VT_I4; // 4 byte integer
            pv->lVal = *((LONG *) ab);
            hr = S_OK;
            break;
            
            // FEATURE: should add some default handling here;
        }   
    }        
    return hr;
}

STDAPI_(UINT) GetControlCharWidth(HWND hwnd)
{
    SIZE siz;

    siz.cx = 8;  // guess a size in case something goes wrong.

    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        HFONT hfOld = SelectFont(hdc, FORWARD_WM_GETFONT(hwnd, SendMessage));
    
        if (hfOld)
        {
            GetTextExtentPoint(hdc, TEXT("0"), 1, &siz);

            SelectFont(hdc, hfOld);
        }

        ReleaseDC(NULL, hdc);
    }

    return siz.cx;
}

STDAPI_(BOOL) ShowSuperHidden()
{
    BOOL bRet = FALSE;

    if (!SHRestricted(REST_DONTSHOWSUPERHIDDEN))
    {
        SHELLSTATE ss;

        SHGetSetSettings(&ss, SSF_SHOWSUPERHIDDEN, FALSE);
        bRet = ss.fShowSuperHidden;
    }
    return bRet;
}

#define FILE_ATTRIBUTE_SUPERHIDDEN (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)

STDAPI_(BOOL) IsSuperHidden(DWORD dwAttribs)
{
    BOOL bRet = FALSE;

    if (!ShowSuperHidden())
    {
        bRet = (dwAttribs & FILE_ATTRIBUTE_SUPERHIDDEN) == FILE_ATTRIBUTE_SUPERHIDDEN;
    }
    return bRet;
}

// make sure LFN paths are nicly quoted and have args at the end

STDAPI_(void) PathComposeWithArgs(LPTSTR pszPath, LPTSTR pszArgs)
{
    PathQuoteSpaces(pszPath);

    if (pszArgs[0]) 
    {
        int len = lstrlen(pszPath);

        if (len < (MAX_PATH - 3)) 
        {     // 1 for null, 1 for space, 1 for arg
            pszPath[len++] = TEXT(' ');
            lstrcpyn(pszPath + len, pszArgs, MAX_PATH - len);
        }
    }
}

// do the inverse of the above, parse pszPath into a unquoted
// path string and put the args in pszArgs
//
// returns:
//      TRUE    we verified the thing exists
//      FALSE   it may not exist

STDAPI_(BOOL) PathSeperateArgs(LPTSTR pszPath, LPTSTR pszArgs)
{
    ASSERT(pszPath);
    if (!pszPath)
        return FALSE;//invalid args
        
    PathRemoveBlanks(pszPath);

    // if the unquoted sting exists as a file just use it

    if (PathFileExistsAndAttributes(pszPath, NULL))
    {
        if (pszArgs)
            *pszArgs = 0;
        return TRUE;
    }

    LPTSTR pszT = PathGetArgs(pszPath);
    if (*pszT)
        *(pszT - 1) = 0;

    if (pszArgs)
        lstrcpy(pszArgs, pszT);

    PathUnquoteSpaces(pszPath);

    return FALSE;
}

STDAPI_(int) CompareIDsAlphabetical(IShellFolder2 *psf, UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRes = 0;

    LPITEMIDLIST pidlFirst1 = ILCloneFirst(pidl1);
    LPITEMIDLIST pidlFirst2 = ILCloneFirst(pidl2);
    if (pidlFirst1 && pidlFirst2)
    {
        TCHAR szName1[MAX_PATH], szName2[MAX_PATH];
        HRESULT hr = DetailsOf(psf, pidlFirst1, iColumn, szName1, ARRAYSIZE(szName1));
        if (SUCCEEDED(hr))
        {                  
            hr = DetailsOf(psf, pidlFirst2, iColumn, szName2, ARRAYSIZE(szName2));
            if (SUCCEEDED(hr))
                iRes = StrCmpLogicalRestricted(szName1, szName2);
        }

        if (FAILED(hr))
        {
            // revert to compare of names
            hr = DisplayNameOf(psf, pidlFirst1, SHGDN_NORMAL, szName1, ARRAYSIZE(szName1));
            if (SUCCEEDED(hr))
            {
                hr = DisplayNameOf(psf, pidlFirst2, SHGDN_NORMAL, szName2, ARRAYSIZE(szName2));
                if (SUCCEEDED(hr))
                    iRes = StrCmpLogicalRestricted(szName1, szName2);
            }
        }
    }

    ILFree(pidlFirst1);
    ILFree(pidlFirst2);

    return iRes;
}

HMONITOR GetPrimaryMonitor()
{
    POINT pt = {0,0};
    return MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY); 
}

// Gets the Monitor's bounding or work rectangle, if the hMon is bad, return
// the primary monitor's bounding rectangle. 
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork)
{
    MONITORINFO mi; 
    mi.cbSize = sizeof(mi);
    if (hMon && GetMonitorInfo(hMon, &mi))
    {
        if (!prc)
            return TRUE;
        
        else if (bWork)
            CopyRect(prc, &mi.rcWork);
        else 
            CopyRect(prc, &mi.rcMonitor);
        
        return TRUE;
    }
    
    if (prc)
        SetRect(prc, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    return FALSE;
}

STDAPI StatStgFromFindData(const WIN32_FIND_DATA * pfd, DWORD dwFlags, STATSTG * pstat)
{
    HRESULT hr = S_OK;
    if (dwFlags & STATFLAG_NONAME)
    {
        pstat->pwcsName = NULL;
    }
    else
    {
        hr = SHStrDup(pfd->cFileName, &pstat->pwcsName);
    }

    pstat->type = (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? STGTY_STORAGE : STGTY_STREAM;
    pstat->cbSize.HighPart = pfd->nFileSizeHigh;
    pstat->cbSize.LowPart = pfd->nFileSizeLow;
    pstat->mtime = pfd->ftLastWriteTime;
    pstat->ctime = pfd->ftCreationTime;
    pstat->atime = pfd->ftLastAccessTime;
    pstat->grfMode = 0;
    pstat->grfLocksSupported = 0;
    pstat->clsid = CLSID_NULL;
    pstat->grfStateBits = 0;
    pstat->reserved = pfd->dwFileAttributes;

    return hr;
}

// see if the QueryService chain will hit the desktop browser (the desktop window)
STDAPI_(BOOL) IsDesktopBrowser(IUnknown *punkSite)
{
    BOOL bRet = FALSE;
    IUnknown *punk;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_SShellDesktop, IID_PPV_ARG(IUnknown, &punk))))
    {   
        punk->Release();
        bRet = TRUE;    // It's the actual desktop!
    }
    return bRet;
}


// calculates the maximum allowable char length for a given path.
//      i.e. c:\winnt\system\bob
// this will return the maximum size the filename for bob can be changed to.

STDAPI GetCCHMaxFromPath(LPCTSTR pszFullPath, UINT *pcchMax, BOOL fShowExtension)
{
    TCHAR szPath[MAX_PATH];
    
    lstrcpy(szPath, pszFullPath);
    // Now make sure that that size is valid for the
    // type of drive that we are talking to
    PathRemoveFileSpec(szPath);

    //
    // Get the maximum file name length.
    //  MAX_PATH - ('\\' + '\0') - lstrlen(szParent)
    //
    *pcchMax = MAX_PATH - 2 - lstrlen(szPath);

    UINT cchCur = lstrlen(pszFullPath) - lstrlen(szPath) - 1;

    PathStripToRoot(szPath);
    DWORD dwMaxLength;
    if (GetVolumeInformation(szPath, NULL, 0, NULL, &dwMaxLength, NULL, NULL, 0))
    {
        if (*pcchMax > (int)dwMaxLength)
        {
            // can't be loner than the FS allows
            *pcchMax = (int)dwMaxLength;
        }
    }
    else
    {
        dwMaxLength = 255;  // Assume LFN for now...
    }

    // only do this if we're not on an 8.3 filesystem already.
    if ((dwMaxLength > 12) && (GetFileAttributes(pszFullPath) & FILE_ATTRIBUTE_DIRECTORY))
    {
        // On NT, a directory must be able to contain an
        // 8.3 name and STILL be less than MAX_PATH.  The
        // "12" below is the length of an 8.3 name (8+1+3).
        // on win9x, we make sure that there is enough room
        // to append \*.* in the directory case.
        *pcchMax -= 12;
    }

    // If our code above restricted smaller than current size reset
    // back to current size...
    if (*pcchMax < cchCur)
    {
        // NOTE: this is bogus. if we ended up with a max smaller than what
        // we currently have, the we are clearly doing something wrong!
        *pcchMax = cchCur;
    }

    //
    // Adjust the cchMax if we are hiding the extension
    //
    if (!fShowExtension)
    {
        *pcchMax -= lstrlen(PathFindExtension(pszFullPath));
        if ((dwMaxLength <= 12) && (*pcchMax > 8))
        {
            // if max filesys path is <=12, then assume we are dealing w/ 8.3 names
            // and since we are not showing the extension, cap the filename at 8.
            *pcchMax = 8;
        }
    }

    ASSERT((int)*pcchMax > 0);

    return S_OK;
}

STDAPI ViewModeFromSVID(const SHELLVIEWID *pvid, FOLDERVIEWMODE *pViewMode)
{
    HRESULT hr = S_OK;
    
    if (IsEqualIID(*pvid, VID_LargeIcons))
        *pViewMode = FVM_ICON;
    else if (IsEqualIID(*pvid, VID_SmallIcons))
        *pViewMode = FVM_SMALLICON;
    else if (IsEqualIID(*pvid, VID_Thumbnails))
        *pViewMode = FVM_THUMBNAIL;
    else if (IsEqualIID(*pvid, VID_ThumbStrip))
        *pViewMode = FVM_THUMBSTRIP;
    else if (IsEqualIID(*pvid, VID_List))
        *pViewMode = FVM_LIST;
    else if (IsEqualIID(*pvid, VID_Tile))
        *pViewMode = FVM_TILE;
    else if (IsEqualIID(*pvid, VID_Details))
        *pViewMode = FVM_DETAILS;
    else
    {
        if (IsEqualIID(*pvid, VID_WebView))
            TraceMsg(TF_WARNING, "ViewModeFromSVID received VID_WebView");
        else
            TraceMsg(TF_WARNING, "ViewModeFromSVID received unknown VID");

        *pViewMode = FVM_ICON;
        hr = E_FAIL;
    }
    return hr;
}

STDAPI SVIDFromViewMode(FOLDERVIEWMODE uViewMode, SHELLVIEWID *psvid)
{
    switch (uViewMode) 
    {
    case FVM_ICON:
        *psvid = VID_LargeIcons;
        break;

    case FVM_SMALLICON:
        *psvid = VID_SmallIcons;
        break;

    case FVM_LIST:
        *psvid = VID_List;
        break;

    case FVM_DETAILS:
        *psvid = VID_Details;
        break;

    case FVM_THUMBNAIL:
        *psvid = VID_Thumbnails;
        break;

    case FVM_TILE:
        *psvid = VID_Tile;
        break;

    case FVM_THUMBSTRIP:
        *psvid = VID_ThumbStrip;
        break;

    default:
        TraceMsg(TF_ERROR, "SVIDFromViewMode given invalid uViewMode!");
        *psvid = VID_LargeIcons;
        break;
    }
    return S_OK;
}

// modify the SLDF_ link flags via new bits + a mask, return the old flags
STDAPI_(DWORD) SetLinkFlags(IShellLink *psl, DWORD dwFlags, DWORD dwMask)
{
    DWORD dwOldFlags = 0;
    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psld))))
    {
        if (SUCCEEDED(psld->GetFlags(&dwOldFlags)))
        {
            if (dwMask)
                psld->SetFlags((dwFlags & dwMask) | (dwOldFlags & ~dwMask));
        }
        psld->Release();
    }
    return dwOldFlags;  // return the previous value
}

// Helper function to compare the 2 variants and return the standard
// C style (-1, 0, 1) value for the comparison.
STDAPI_(int) CompareVariants(VARIANT va1, VARIANT va2)
{
    int iRetVal = 0;

    if (va1.vt == VT_EMPTY)
    {
        if (va2.vt == VT_EMPTY)
            iRetVal = 0;
        else
            iRetVal = 1;
    }
    else if (va2.vt == VT_EMPTY)
    {
        if (va1.vt == VT_EMPTY)
            iRetVal = 0;
        else
            iRetVal = -1;
    }
    else
    {
        // Special case becasue VarCmp cannot handle ULONGLONG
        if (va1.vt == VT_UI8 && va2.vt == VT_UI8)
        {
            if (va1.ullVal < va2.ullVal)
                iRetVal = -1;
            else if (va1.ullVal > va2.ullVal)
                iRetVal = 1;
        }
        else if (va1.vt == VT_BSTR && va2.vt == VT_BSTR)
        {
            iRetVal = StrCmpLogicalRestricted(va1.bstrVal, va2.bstrVal);
        }
        else
        {
            HRESULT hr = VarCmp(&va1, &va2, GetUserDefaultLCID(), 0);
            if (SUCCEEDED(hr))
            {
                // Translate the result into the C convention...
                ASSERT(hr != VARCMP_NULL);
                iRetVal = hr - VARCMP_EQ;
            }
        }
    }

    return iRetVal;
}

// Check which of the pidl's passed in represent a folder.  If only one 
// is a folder, then put it first.
STDAPI_(int) CompareFolderness(IShellFolder *psf, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL bIsFolder1 = SHGetAttributes(psf, pidl1, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER;
    BOOL bIsFolder2 = SHGetAttributes(psf, pidl2, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER;

    int iRetVal;
    if (bIsFolder1 && !bIsFolder2)
    {
        iRetVal = -1;   // Don't swap
    }
    else if (!bIsFolder1 && bIsFolder2)
    {
        iRetVal = 1;    // Swap
    }
    else
    {
        iRetVal = 0;    // equal
    }

    return iRetVal;
}

// Compare the two items using GetDetailsEx, it is assumed that folderness has been established already
// Return -1 if pidl1 comes before pidl2,
//         0 if the same
//         1 if pidl2 comes before pidl1

STDAPI_(int) CompareBySCID(IShellFolder2 *psf, const SHCOLUMNID *pscid, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // ignore failures here, leaving VT_EMPTY that we compare below
    VARIANT v1 = {0}, v2 = {0};
    psf->GetDetailsEx(pidl1, pscid, &v1);
    psf->GetDetailsEx(pidl2, pscid, &v2);   

    int iRet = CompareVariants(v1, v2);

    VariantClear(&v2);
    VariantClear(&v1);
    return iRet;
}

//
// Determines if a filename is that of a regitem
//        
// a regitem's SHGDN_INFOLDER | SHGDN_FORPARSING name is always "::{someguid}"
// 
// This test can lead to false positives if you have other items which have infolder 
// parsing names beginning with "::{", but as ':' is not presently allowed in filenames 
// it should not be a problem. 
//
STDAPI_(BOOL) IsRegItemName(LPCTSTR pszName, CLSID* pclsid)
{
    BOOL fRetVal = FALSE;
    
    if (pszName && lstrlen(pszName) >= 3)
    {
        if (pszName[0] == TEXT(':') && pszName[1] == TEXT(':') && pszName[2] == TEXT('{'))
        {
            CLSID clsid;
            fRetVal = GUIDFromString(pszName + 2, &clsid); // skip the leading :: before regitem
            if (pclsid)
            {
                memcpy(pclsid, &clsid, sizeof(clsid));
            }
        }
    }

    return fRetVal;
}

STDAPI GetMyDocumentsDisplayName(LPTSTR pszPath, UINT cch)
{
    *pszPath = 0;
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidl)))
    {
        SHGetNameAndFlags(pidl, SHGDN_NORMAL, pszPath, cch, NULL);
        ILFree(pidl);
    }
    return *pszPath ? S_OK : E_FAIL;
}


STDAPI BSTRFromCLSID(REFCLSID clsid, BSTR *pbstr)
{
    WCHAR sz[GUIDSTR_MAX + 1];
    
    //  Get the File/Folders search guid in string form
    SHStringFromGUIDW(clsid, sz, ARRAYSIZE(sz));
    *pbstr = SysAllocString(sz);
    return *pbstr ? S_OK : E_OUTOFMEMORY;
}

// [in] pdo -- data object we're interested in
// [in] dwAttributeMask -- the bits we want to know about
// [out,optional] pdwAttributes -- write the bits of dwAttributeMask that we calculate
// [out,optional] pcItems -- count of pidls in pdo
//
// returns S_FALSE only if the dataobject doesn't support HIDA, used to help out defview for legacy cases.
// in general callers dont have to check for success/failure and they can use the dwAttribs, it's zero-inited.
HRESULT SHGetAttributesFromDataObject(IDataObject *pdo, DWORD dwAttributeMask, DWORD *pdwAttributes, UINT *pcItems)
{
    HRESULT hr = S_OK;

    DWORD dwAttributes = 0;
    DWORD cItems = 0;

    // These are all the bits we regularly ask for:
    #define TASK_ATTRIBUTES (SFGAO_READONLY|SFGAO_STORAGE|SFGAO_CANRENAME|SFGAO_CANMOVE|SFGAO_CANCOPY|SFGAO_CANDELETE|SFGAO_FOLDER|SFGAO_STREAM)

    if ((dwAttributeMask&TASK_ATTRIBUTES) != dwAttributeMask)
    {
        TraceMsg(TF_WARNING, "SHGetAttributesFromDataObject cache can be more efficient");
    }

    if (pdo)
    {
        // We cache the attributes on the data object back in the data object,
        // since we call for them so many times.
        //
        // To do this we need to remember:
        struct {
            DWORD dwRequested;
            DWORD dwReceived;
            UINT  cItems;
        } doAttributes = {0};
        
        static UINT s_cfDataObjectAttributes = 0;
        if (0 == s_cfDataObjectAttributes)
            s_cfDataObjectAttributes = RegisterClipboardFormat(TEXT("DataObjectAttributes"));

        if (FAILED(DataObj_GetBlob(pdo, s_cfDataObjectAttributes, &doAttributes, sizeof(doAttributes))) ||
            ((doAttributes.dwRequested & dwAttributeMask) != dwAttributeMask))
        {
            // If we fail along the way, cache that we tried to ask for these bits,
            // since we'll probably fail next time.
            //
            // Also, always ask for a superset of bits, and include the most commonly requested ones too
            //
            doAttributes.dwRequested |= (dwAttributeMask | TASK_ATTRIBUTES);

            // try to get the attributes requested
            STGMEDIUM medium = {0};
            LPIDA pida = DataObj_GetHIDA(pdo, &medium);
            if (pida)
            {
                doAttributes.cItems = pida->cidl;

                if (pida->cidl >= 1)
                {
                    IShellFolder* psf;
                    if (SUCCEEDED(SHBindToObjectEx(NULL, HIDA_GetPIDLFolder(pida), NULL, IID_PPV_ARG(IShellFolder, &psf))))
                    {
                        // who cares if we get the wrong bits when there are a bunch of items - check the first 10 or so...
                        LPCITEMIDLIST apidl[10];
                        UINT cItems = (UINT)min(pida->cidl, ARRAYSIZE(apidl));
                        for (UINT i = 0 ; i < cItems ; i++)
                        {
                            apidl[i] = HIDA_GetPIDLItem(pida, i);

                            if (ILGetNext(ILGetNext(apidl[i])))
                            {
                                // search namespace has non-flat HIDA, which is probably a bug.
                                // work around it here:
                                //   if the first item is non-flat, use that one item for attributes
                                //   otherwise use the flat items already enumerated
                                //
                                IShellFolder* psfNew;
                                if (0==i &&
                                    (SUCCEEDED(SHBindToFolderIDListParent(psf, apidl[i], IID_PPV_ARG(IShellFolder, &psfNew), &(apidl[i])))))
                                {
                                    psf->Release();
                                    psf = psfNew;

                                    cItems = 1;
                                }
                                else
                                {
                                    cItems = i;
                                }

                                break;
                            }
                        }

                        DWORD dwAttribs = doAttributes.dwRequested;
                        if (SUCCEEDED(psf->GetAttributesOf(cItems, apidl, &dwAttribs)))
                        {
                            doAttributes.dwReceived = dwAttribs;
                        }

                        psf->Release();
                    }
                }

                HIDA_ReleaseStgMedium(pida, &medium);
            }
            else
            {
                hr = S_FALSE;
            }

            DataObj_SetBlob(pdo, s_cfDataObjectAttributes, &doAttributes, sizeof(doAttributes));
        }

        dwAttributes = doAttributes.dwReceived & dwAttributeMask;
        cItems = doAttributes.cItems;
    }

    if (pdwAttributes)
        *pdwAttributes = dwAttributes;
    if (pcItems)
        *pcItems = cItems;
    
    return hr;
}

STDAPI SHSimulateDropOnClsid(REFCLSID clsidDrop, IUnknown* punkSite, IDataObject* pdo)
{
    IDropTarget* pdt;
    HRESULT hr = SHExtCoCreateInstance2(NULL, &clsidDrop, NULL, CLSCTX_ALL, IID_PPV_ARG(IDropTarget, &pdt));
    if (SUCCEEDED(hr))
    {
        hr = SHSimulateDropWithSite(pdt, pdo, 0, NULL, NULL, punkSite);
        pdt->Release();
    }
    return hr;
}

STDAPI SHPropertiesForUnk(HWND hwnd, IUnknown *punk, LPCTSTR psz)
{
    HRESULT hr;
    LPITEMIDLIST pidl;
    if (S_OK == SHGetIDListFromUnk(punk, &pidl))
    {
        hr = SHPropertiesForPidl(hwnd, pidl, psz);
        ILFree(pidl);
    }
    else
        hr = E_FAIL;
    return hr;
}

STDAPI SHFullIDListFromFolderAndItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetIDListFromUnk(psf, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        hr = SHILCombine(pidlFolder, pidl, ppidl);
        ILFree(pidlFolder);
    }
    return hr;
}

STDAPI_(BOOL) IsWindowClass(HWND hwndTest, LPCTSTR pszClass)
{
    TCHAR szClass[128];
    if (pszClass && GetClassName(hwndTest, szClass, ARRAYSIZE(szClass)))
        return 0 == lstrcmpi(pszClass, szClass);
    return FALSE;
}

STDAPI DCA_ExtCreateInstance(HDCA hdca, int iItem, REFIID riid, void **ppv)
{
    const CLSID * pclsid = DCA_GetItem(hdca, iItem);
    return pclsid ? SHExtCoCreateInstance(NULL, pclsid, NULL, riid, ppv) : E_INVALIDARG;
}

STDAPI_(HINSTANCE) SHGetShellStyleHInstance (void)
{
    TCHAR szDir[MAX_PATH];
    TCHAR szColor[100];
    HINSTANCE hInst = NULL;
    LPTSTR lpFullPath;

    //
    // First try to load shellstyle.dll from the theme (taking into account color variations)
    //
    if (SUCCEEDED(GetCurrentThemeName(szDir, ARRAYSIZE(szDir), szColor, ARRAYSIZE(szColor), NULL, NULL)))
    {
        PathRemoveFileSpec(szDir);

        lpFullPath = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szDir) + lstrlen(szColor) + 25) * sizeof(TCHAR));

        if (lpFullPath)
        {
            lstrcpy (lpFullPath, szDir);
            lstrcat (lpFullPath, TEXT("\\Shell\\"));
            lstrcat (lpFullPath, szColor);
            lstrcat (lpFullPath, TEXT("\\ShellStyle.dll"));

            hInst = LoadLibraryEx(lpFullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);

            LocalFree (lpFullPath);
        }
    }

    //
    // If shellstyle.dll couldn't be loaded from the theme, load the default (classic)
    // version from system32.
    //
    if (!hInst)
    {
        if (ExpandEnvironmentStrings (TEXT("%SystemRoot%\\System32\\ShellStyle.dll"),
                                      szDir, ARRAYSIZE(szDir)))
        {
            hInst = LoadLibraryEx(szDir, NULL, LOAD_LIBRARY_AS_DATAFILE);
        }
    }

    return hInst;
}

// adjust an infotip object in a custom way for the folder
// poke in an extra property to be displayed and wrap the object with the
// delegating outter folder if needed

STDAPI WrapInfotip(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, IUnknown *punk)
{
    HRESULT hr = S_OK;

    if (pscid)
    {
        ICustomizeInfoTip *pcit;
        hr = punk->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit));
        if (SUCCEEDED(hr))
        {
            hr = pcit->SetExtraProperties(pscid, 1);
            pcit->Release();
        }
    }

    if (psf && pidl)
    {
        IParentAndItem *ppai;
        hr = punk->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai));
        if (SUCCEEDED(hr))
        {
            ppai->SetParentAndItem(NULL, psf, pidl);
            ppai->Release();
        }
    }
    return hr;
}

STDAPI CloneIDListArray(UINT cidl, const LPCITEMIDLIST rgpidl[], UINT *pcidl, LPITEMIDLIST **papidl)
{
    HRESULT hr;
    LPITEMIDLIST *ppidl;

    if (cidl && rgpidl)
    {
        ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, cidl * sizeof(*ppidl));
        if (ppidl)
        {
            hr = S_OK;
            for (UINT i = 0; i < cidl && SUCCEEDED(hr); i++)
            {
                hr = SHILClone(rgpidl[i], &ppidl[i]);
                if (FAILED(hr))
                {
                    FreeIDListArray(ppidl, i);
                    ppidl = NULL;
                }
            }   
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        ppidl = NULL;
        hr = S_FALSE;   // success by empty
    }

    *papidl = ppidl;
    *pcidl = SUCCEEDED(hr) ? cidl : 0;
    return hr;
}

BOOL RunWindowCallback(VARIANT var, ENUMSHELLWINPROC pEnumFunc, LPARAM lParam)
{
    BOOL fKeepGoing = TRUE;
    IShellBrowser *psb;
    if (SUCCEEDED(IUnknown_QueryService(var.pdispVal, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        IShellView *psv;
        if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
        {
            HWND hwnd;
            if (SUCCEEDED(psv->GetWindow(&hwnd)))
            {
                IPersistIDList *pPI;
                if (SUCCEEDED(psv->QueryInterface(IID_PPV_ARG(IPersistIDList, &pPI))))
                {
                    LPITEMIDLIST pidl;
                    if (SUCCEEDED(pPI->GetIDList(&pidl)))
                    {
                        fKeepGoing = pEnumFunc(hwnd, pidl, lParam);
                        ILFree(pidl);
                    }
                    pPI->Release();
                }
            }
            psv->Release();
        }
        psb->Release();
    }
    return fKeepGoing;
}

// runs through all open shell browser windows and runs a caller-defined function on the hwnd and pidl.
STDAPI EnumShellWindows(ENUMSHELLWINPROC pEnumFunc, LPARAM lParam)
{
    HRESULT hr;
    IShellWindows *psw = WinList_GetShellWindows(TRUE);
    if (psw)
    {
        IUnknown *punk;
        hr = psw->_NewEnum(&punk);
        if (SUCCEEDED(hr))
        {
            IEnumVARIANT *penum;
            hr = punk->QueryInterface(IID_PPV_ARG(IEnumVARIANT, &penum));
            if (SUCCEEDED(hr))
            {
                VARIANT var;
                VariantInit(&var);
                BOOL fKeepGoing = TRUE;
                while (fKeepGoing && (S_OK == penum->Next(1, &var, NULL)))
                {
                    ASSERT(var.vt == VT_DISPATCH);
                    ASSERT(var.pdispVal);
                    fKeepGoing = RunWindowCallback(var, pEnumFunc, lParam);
                    VariantClear(&var);
                }
                penum->Release();
            }
            punk->Release();
        }
        psw->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// Determine if infotips are on or off (from the registry settings).
//
BOOL SHShowInfotips()
{
    // REVIEW (buzzr): Is it necessary to force a refresh every time?
    SHELLSTATE ss;
    SHRefreshSettings();
    SHGetSetSettings(&ss, SSF_SHOWINFOTIP, FALSE);
    return ss.fShowInfoTip;
}

HRESULT SHCreateInfotipWindow(HWND hwndParent, LPWSTR pszInfotip, HWND *phwndInfotip)
{
    HRESULT hr;

    if (hwndParent && IsWindow(hwndParent))
    {
        DWORD dwExStyle = 0;
        if (IS_WINDOW_RTL_MIRRORED(hwndParent) || IS_BIDI_LOCALIZED_SYSTEM())
        {
            dwExStyle = WS_EX_LAYOUTRTL;
        }

        *phwndInfotip = CreateWindowEx(dwExStyle,
                                       TOOLTIPS_CLASS,
                                       NULL,
                                       WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                                       CW_USEDEFAULT,
                                       CW_USEDEFAULT,
                                       CW_USEDEFAULT,
                                       CW_USEDEFAULT,
                                       hwndParent,
                                       NULL,
                                       HINST_THISDLL,
                                       NULL);
        if (*phwndInfotip)
        {
            SetWindowPos(*phwndInfotip,
                         HWND_TOPMOST,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            TOOLINFOW ti;
            ZeroMemory(&ti, sizeof(ti));
            ti.cbSize   = sizeof(ti);
            ti.uFlags   = TTF_SUBCLASS;
            ti.hwnd     = hwndParent;
            ti.hinst    = HINST_THISDLL;
            ti.lpszText = pszInfotip;
            GetClientRect(hwndParent, &ti.rect);

            if (SendMessage(*phwndInfotip, TTM_ADDTOOL, 0, (LPARAM)&ti))
            {
                static const RECT rcMargin = { 2, 2, 2, 2 };
                SendMessage(*phwndInfotip, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                //
                // Set the initial delay time to 2 times the default.
                // Set the auto-pop time to a very large value.
                // These are the same parameters used by defview for it's tooltips.
                //
                LRESULT uiShowTime = SendMessage(*phwndInfotip, TTM_GETDELAYTIME, TTDT_INITIAL, 0);
                SendMessage(*phwndInfotip, TTM_SETDELAYTIME, TTDT_INITIAL, MAKELONG(uiShowTime * 2, 0));
                SendMessage(*phwndInfotip, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);

                SendMessage(*phwndInfotip, TTM_SETMAXTIPWIDTH, 0, 300);
                hr = S_OK;
            }
            else
                hr = ResultFromLastError();
        }
        else
            hr = ResultFromLastError();
    }
    else
        hr = E_INVALIDARG;

    return THR(hr);
}

HRESULT SHShowInfotipWindow(HWND hwndInfotip, BOOL bShow)
{
    HRESULT hr;

    if (hwndInfotip && IsWindow(hwndInfotip))
    {
        SendMessage(hwndInfotip, TTM_ACTIVATE, (WPARAM)bShow, 0);
        hr = S_OK;
    }
    else
        hr = E_INVALIDARG;

    return THR(hr);
}

HRESULT SHDestroyInfotipWindow(HWND *phwndInfotip)
{
    HRESULT hr;

    if (*phwndInfotip)
    {
        if (IsWindow(*phwndInfotip))
        {
            if (DestroyWindow(*phwndInfotip))
            {
                *phwndInfotip = NULL;
                hr = S_OK;
            }
            else
                hr = ResultFromLastError();
        }
        else
            hr = S_OK;
    }
    else
        hr = E_INVALIDARG;

    return THR(hr);
}

// we hide wizards in defview iff we are in explorer and webview is on
STDAPI SHShouldShowWizards(IUnknown *punksite)
{
    HRESULT hr = S_OK;      // assume yes
    IShellBrowser* psb;
    if (SUCCEEDED(IUnknown_QueryService(punksite, SID_STopWindow, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_WEBVIEW, FALSE);
        if (ss.fWebView)
        {
            if (SHRegGetBoolUSValueW(REGSTR_EXPLORER_ADVANCED, TEXT("ShowWizardsTEST"),
                        FALSE, // Don't ignore HKCU
                        FALSE)) // By default we assume we're not using these test tools
            {
                // Test teams that have old test tools that don't know how to talk to DUI need a way
                // to force the legacy wizards back into the listview to keep their automation working
            }
            else
            {
                hr = S_FALSE;
            }
        }
        psb->Release();
    }
    return hr;
}

// split a full pidl into the "folder" part and the "item" part.
// callers need to free the folder part 
// (pay special attention to the constness of the out params)

STDAPI SplitIDList(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFolder, LPCITEMIDLIST *ppidlChild)
{
    HRESULT hr;
    *ppidlFolder = ILCloneParent(pidl);
    if (*ppidlFolder)
    {
        *ppidlChild = ILFindLastID(pidl);   // const alias result
        hr = S_OK;
    }
    else
    {
        *ppidlChild = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT GetAppNameFromCLSID(CLSID clsid, PWSTR *ppszApp)
{
    *ppszApp = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        PWSTR pszProgID;
        hr = ProgIDFromCLSID(clsid, &pszProgID);
        if (SUCCEEDED(hr))
        {
            hr = pqa->Init(NULL, pszProgID, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;

                DWORD cch = 0;
                pqa->GetString(ASSOCF_NOTRUNCATE, ASSOCSTR_FRIENDLYAPPNAME, NULL, NULL, &cch);
                if (cch)
                {
                    *ppszApp = (PWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
                    if (*ppszApp)
                    {
                        hr = pqa->GetString(0, ASSOCSTR_FRIENDLYAPPNAME, NULL, *ppszApp, &cch);

                        if (FAILED(hr))
                        {
                            Str_SetPtr(ppszApp, NULL);
                        }
                    }
                }
            }
            CoTaskMemFree(pszProgID);
        }
        pqa->Release();
    }
    return hr;
}

HRESULT GetAppNameFromMoniker(IRunningObjectTable *prot, IMoniker *pmkFile, PWSTR *ppszApp)
{
    HRESULT hr = E_FAIL;
    IUnknown *punk;
    if (prot->GetObject(pmkFile, &punk) == S_OK)
    {
        IOleObject *pole;
        hr = punk->QueryInterface(IID_PPV_ARG(IOleObject, &pole));
        if (SUCCEEDED(hr))
        {
            CLSID clsid;
            hr = pole->GetUserClassID(&clsid);
            if (SUCCEEDED(hr))
            {
                hr = GetAppNameFromCLSID(clsid, ppszApp);
            }
            pole->Release();
        }
        punk->Release();
    }
    return hr;
}

// pmkPath  c:\foo
// pmk      c:\foo\doc.txt
BOOL IsMonikerPrefix(IMoniker *pmkPath, IMoniker *pmkFile)
{
    BOOL bRet = FALSE;
    IMoniker *pmkPrefix;
    if (SUCCEEDED(pmkPath->CommonPrefixWith(pmkFile, &pmkPrefix)))
    {
        bRet = (S_OK == pmkPath->IsEqual(pmkPrefix));
        pmkPrefix->Release();
    }
    return bRet;
}

STDAPI FindAppForFileInUse(PCWSTR pszFile, PWSTR *ppszApp)
{
    IRunningObjectTable *prot;
    HRESULT hr = GetRunningObjectTable(0, &prot);
    if (SUCCEEDED(hr))
    {
        IMoniker *pmkFile;
        hr = CreateFileMoniker(pszFile, &pmkFile);
        if (SUCCEEDED(hr))
        {
            IEnumMoniker *penumMk;
            hr = prot->EnumRunning(&penumMk);
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;

                ULONG celt;
                IMoniker *pmk;
                while (FAILED(hr) && (penumMk->Next(1, &pmk, &celt) == S_OK))
                {
                    DWORD dwType;
                    if (SUCCEEDED(pmk->IsSystemMoniker(&dwType)) && (dwType == MKSYS_FILEMONIKER))
                    {
                        if (IsMonikerPrefix(pmkFile, pmk))
                        {
                            hr = GetAppNameFromMoniker(prot, pmk, ppszApp);
                        }
                    }
                    pmk->Release();
                }
                penumMk->Release();
            }
            pmkFile->Release();
        }
        prot->Release();
    }
    return hr;
}

#include <trkwks_c.c>

// DirectUI initialization helper functions

static BOOL g_DirectUIInitialized = FALSE;

HRESULT InitializeDUIViewClasses();  // duiview.cpp
HRESULT InitializeCPClasses();       // cpview.cpp

HRESULT InitializeDirectUI()
{
    HRESULT hr;

    // If we have already initialized DirectUI, exit now.
    // Multiple threads will be attempting to initialize. InitProcess
    // and class registration expects to be run on the primary thread.
    // Make sure it only happens once on a single thread

    ENTERCRITICAL;
    
    if (g_DirectUIInitialized)
    {
        hr = S_OK;
        goto Done;
    }

    // Initialize DirectUI for the process
    hr = DirectUI::InitProcess();
    if (FAILED(hr))
        goto Done;

    // Initialize the classes that DUIView uses
    hr = InitializeDUIViewClasses();
    if (FAILED(hr))
        goto Done;

    // Initialize the classes that Control Panel uses
    hr = InitializeCPClasses();
    if (FAILED(hr))
        goto Done;

    g_DirectUIInitialized = TRUE;

Done:

    if (FAILED(hr))
    {
        // Safe to call if InitProcess fails. Will unregister
        // all registered classes. All InitThread calls will fail
        DirectUI::UnInitProcess();
    }    

    LEAVECRITICAL;

    return hr;
}

void UnInitializeDirectUI(void)
{
    ENTERCRITICAL;

    if (g_DirectUIInitialized)
    {
        DirectUI::UnInitProcess();

        g_DirectUIInitialized = FALSE;
    }

    LEAVECRITICAL;
}

BOOL IsForceGuestModeOn(void)
{
    BOOL fIsForceGuestModeOn = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsForceGuestModeOn = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        DWORD dwForceGuest;
        DWORD cb = sizeof(dwForceGuest);

        // Professional, not in a domain. Check the ForceGuest value.

        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"), TEXT("ForceGuest"), NULL, &dwForceGuest, &cb)
            && 1 == dwForceGuest)
        {
            fIsForceGuestModeOn = TRUE;
        }
    }

    return fIsForceGuestModeOn;
}

BOOL IsFolderSecurityModeOn(void)
{
    DWORD dwSecurity;
    DWORD cb = sizeof(dwSecurity);
    DWORD err;

    err = SHGetValue(HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("MoveSecurityAttributes"), NULL, &dwSecurity, &cb);

    if (err == ERROR_SUCCESS)
    {
        return (dwSecurity == 0);
    }
    else
    {
        return IsForceGuestModeOn();
    }
}

STDAPI_(int) StrCmpLogicalRestricted(PCWSTR psz1, PCWSTR psz2)
{
    if (!SHRestricted(REST_NOSTRCMPLOGICAL))
        return StrCmpLogicalW(psz1, psz2);
    else
        return StrCmpIW(psz1, psz2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\util.h ===
//---------------------------------------------------------------------------
// This is a desperate attempt to try and track dependancies.

#ifndef _UTIL_H
#define _UTIL_H

#include "unicpp\utils.h"
#include <xml.h>
#include <inetutil.h>

#define SZ_REGKEY_FILEASSOCIATION TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileAssociation")

STDAPI Stream_WriteString(IStream *pstm, LPCTSTR psz, BOOL bWideInStream);
STDAPI Stream_ReadString(IStream *pstm, LPTSTR pwsz, UINT cchBuf, BOOL bWideInStream);
STDAPI Str_SetFromStream(IStream *pstm, LPTSTR *ppsz, BOOL bWideInStream);

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

// Sizes of various stringized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)
#define MAX_COMMA_AS_K_SIZE     (MAX_COMMA_NUMBER_SIZE + 10)

STDAPI_(void)   SHPlaySound(LPCTSTR pszSound);

STDAPI_(BOOL)   TouchFile(LPCTSTR pszFile);
STDAPI_(BOOL)   IsNullTime(const FILETIME *pft);
#ifdef AddCommas
#undef AddCommas
#endif
STDAPI_(LPTSTR) AddCommas(DWORD dw, LPTSTR pszOut, UINT cchOut);
STDAPI_(LPTSTR) AddCommas64(_int64 n, LPTSTR pszOut, UINT cchOut);
#ifdef ShortSizeFormat
#undef ShortSizeFormat
#endif
STDAPI_(LPTSTR) ShortSizeFormat(DWORD dw, LPTSTR szBuf, UINT cchBuf);
STDAPI_(LPTSTR) ShortSizeFormat64(__int64 qwSize, LPTSTR szBuf, UINT cchBuf);

STDAPI_(int)  GetDateString(WORD wDate, LPWSTR pszStr);
STDAPI_(WORD) ParseDateString(LPCWSTR pszStr);
STDAPI_(int)  GetTimeString(WORD wTime, LPTSTR szStr);
#define GetTopLevelAncestor(hwnd) GetAncestor(hwnd, GA_ROOT)
STDAPI_(BOOL) ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen);
STDAPI_(UINT) Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);
STDAPI_(void) SetICIKeyModifiers(DWORD* pfMask);
STDAPI_(void) GetMsgPos(POINT *ppt);

//For use with CreateDesktopComponents
#define DESKCOMP_IMAGE  0x00000001
#define DESKCOMP_URL    0x00000002
#define DESKCOMP_MULTI  0x00000004
#define DESKCOMP_CDF    0x00000008

STDAPI IsDeskCompHDrop(IDataObject * pido);
STDAPI CreateDesktopComponents(LPCSTR pszUrl, IDataObject * pido, HWND hwnd, DWORD fFlags, int x, int y);
STDAPI ExecuteDeskCompHDrop(LPTSTR pszMultipleUrls, HWND hwnd, int x, int y);

STDAPI_(LONG) RegSetString(HKEY hk, LPCTSTR pszSubKey, LPCTSTR pszValue);
STDAPI_(BOOL) RegSetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPCTSTR psz);
STDAPI_(BOOL) RegGetValueString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPTSTR psz, DWORD cb);

STDAPI_(BOOL) GetShellClassInfo(LPCTSTR pszPath, LPTSTR pszKey, LPTSTR pszBuffer, DWORD cchBuffer);
STDAPI_(BOOL) GetShellClassInfoInfoTip(LPCTSTR pszPath, LPTSTR pszBuffer, DWORD cchBuffer);

#define RGS_IGNORECLEANBOOT 0x00000001

#define TrimWhiteSpaceW(psz)        StrTrimW(psz, L" \t")
#define TrimWhiteSpaceA(psz)        StrTrimA(psz, " \t")

#ifdef UNICODE
#define TrimWhiteSpace      TrimWhiteSpaceW
#else
#define TrimWhiteSpace      TrimWhiteSpaceA
#endif

STDAPI_(LPCTSTR) SkipLeadingSlashes(LPCTSTR pszURL);

STDAPI_(LPSTR) ResourceCStrToStrA(HINSTANCE hAppInst, LPCSTR lpcText);
STDAPI_(LPWSTR) ResourceCStrToStrW(HINSTANCE hAppInst, LPCWSTR lpcText);

#ifdef UNICODE
#define ResourceCStrToStr   ResourceCStrToStrW
#else
#define ResourceCStrToStr   ResourceCStrToStrA
#endif


STDAPI_(void) SHRegCloseKeys(HKEY ahkeys[], UINT ckeys);
STDAPI_(void) HWNDWSPrintf(HWND hwnd, LPCTSTR psz);

#define ustrcmp(psz1, psz2) _ustrcmp(psz1, psz2, FALSE)
#define ustrcmpi(psz1, psz2) _ustrcmp(psz1, psz2, TRUE)
int _ustrcmp(LPCTSTR psz1, LPCTSTR psz2, BOOL fCaseInsensitive);

STDAPI StringToStrRet(LPCTSTR pszName, STRRET *pStrRet);
STDAPI ResToStrRet(UINT id, STRRET *pStrRet);

STDAPI_(LPITEMIDLIST) ILCombineParentAndFirst(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNext);
STDAPI_(LPITEMIDLIST) ILCloneUpTo(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlUpTo);
STDAPI_(LPITEMIDLIST) ILResize(LPITEMIDLIST pidl, UINT cbRequired, UINT cbExtra);

typedef struct {
    LPITEMIDLIST pidlParent;
    LPDATAOBJECT pdtobj;
    LPCTSTR pStartPage;
    IShellFolder* psf;

    // keep this last
    LPTHREAD_START_ROUTINE lpStartAddress;
}  PROPSTUFF;

// NOTE (reinerf): the alpha cpp compiler seems to mess up the type "LPITEMIDLIST",
// to work around the compiler we pass the last param as an LPVOID instead of a LPITEMIDLIST
HRESULT SHLaunchPropSheet(LPTHREAD_START_ROUTINE lpStartAddress, LPDATAOBJECT pdtobj, LPCTSTR pStartPage, IShellFolder* psf, LPVOID pidlParent);


// these don't do anything since shell32 does not support unload, but use this
// for code consistancy with dlls that do support this

#define DllAddRef()
#define DllRelease()

//
//  these are functions that moved from shlexec.c.
//  most of them have something to do with locating and identifying applications
//
HWND GetTopParentWindow(HWND hwnd);


// map the PropVariantClear function to our internal wrapper to save loading OleAut32.dll
#define PropVariantClear PropVariantClearLazy
STDAPI PropVariantClearLazy(PROPVARIANT * pvar);

STDAPI GetCurFolderImpl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);
STDAPI GetPathFromLinkFile(LPCTSTR pszLinkPath, LPTSTR pszTargetPath, int cchTargetPath);

STDAPI_(BOOL) GetFileDescription(LPCTSTR pszPath, LPTSTR pszDesc, UINT *pcchDesc);
STDAPI_(BOOL) IsPathInOpenWithKillList(LPCTSTR pszPath);

// calls ShellMessageBox if SHRestricted fails the restriction
STDAPI_(BOOL) SHIsRestricted(HWND hwnd, RESTRICTIONS rest);
STDAPI_(BOOL) SafePathListAppend(LPTSTR pszDestPath, DWORD cchDestSize, LPCTSTR pszPathToAdd);

STDAPI_(BOOL) ILGetDisplayNameExA(IShellFolder *psfRoot, LPCITEMIDLIST pidl, LPSTR pszName, DWORD cchSize, int fType);
STDAPI_(BOOL) ILGetDisplayNameExW(IShellFolder *psfRoot, LPCITEMIDLIST pidl, LPWSTR pszName, DWORD cchSize, int fType);

STDAPI_(BOOL) Priv_Str_SetPtrW(WCHAR *UNALIGNED *ppwzCurrent, LPCWSTR pwzNew);

#define SEARCHNAMESPACEID_FILE_PATH             1   // Go parse it.
#define SEARCHNAMESPACEID_DOCUMENTFOLDERS       2
#define SEARCHNAMESPACEID_LOCALHARDDRIVES       3
#define SEARCHNAMESPACEID_MYNETWORKPLACES       4

STDAPI_(LPTSTR) DumpPidl(LPCITEMIDLIST pidl);

STDAPI_(BOOL) SHTrackPopupMenu(HMENU hmenu, UINT wFlags, int x, int y, int wReserved, HWND hwnd, LPCRECT lprc);
STDAPI_(HMENU) SHLoadPopupMenu(HINSTANCE hinst, UINT id);

STDAPI_(void) PathToAppPathKey(LPCTSTR pszPath, LPTSTR pszKey, int cchKey);
STDAPI_(BOOL) PathToAppPath(LPCTSTR pszPath, LPTSTR pszResult);
STDAPI_(BOOL) PathIsRegisteredProgram(LPCTSTR pszPath);

STDAPI_(BOOL) PathRetryRemovable(HRESULT hr, LPCTSTR pszPath);

STDAPI_(HANDLE) SHGetCachedGlobalCounter(HANDLE *phCache, const GUID *pguid);
STDAPI_(void) SHDestroyCachedGlobalCounter(HANDLE *phCache);

#define GPFIDL_DEFAULT      0x0000      // normal Win32 file name, servers and drive roots included
#define GPFIDL_ALTNAME      0x0001      // short file name
#define GPFIDL_UNCPRINTER   0x0002      // include UNC printer names too (non file system item)

STDAPI_(BOOL) SHGetPathFromIDListEx(LPCITEMIDLIST pidl, LPTSTR pszPath, UINT uOpts);

STDAPI_(BOOL) DAD_DragEnterEx3(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtobj);
STDAPI_(BOOL) DAD_DragMoveEx(HWND hwndTarget, const POINTL ptStart);

STDAPI DefaultSearchGUID(GUID *pGuid);

STDAPI SavePersistHistory(IUnknown* punk, IStream* pstm);

#define TBCDIDASYNC L"DidAsyncInvoke"

STDAPI SEI2ICIX(LPSHELLEXECUTEINFO pei, LPCMINVOKECOMMANDINFOEX pici, LPVOID *ppvFree);
STDAPI ICIX2SEI(LPCMINVOKECOMMANDINFOEX pici, LPSHELLEXECUTEINFO pei);
STDAPI ICI2ICIX(LPCMINVOKECOMMANDINFO piciIn, LPCMINVOKECOMMANDINFOEX piciOut, LPVOID *ppvFree);
STDAPI_(BOOL) PathIsEqualOrSubFolderOf(LPCTSTR pszSubFolder, const UINT rgFolders[], DWORD crgFolder);
STDAPI_(BOOL) PathIsSubFolderOf(LPCTSTR pszFolder, const UINT rgFolders[], DWORD crgFolders);
STDAPI_(BOOL) PathIsOneOf(LPCTSTR pszFolder, const UINT rgFolders[], DWORD crgFolders);
STDAPI_(BOOL) PathIsDirectChildOf(LPCTSTR pszParent, LPCTSTR pszChild);


STDAPI_(LPTSTR) PathBuildSimpleRoot(int iDrive, LPTSTR pszDrive);

IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation, HINSTANCE hAnimationInst);

STDAPI_(BOOL) IsWindowInProcess(HWND hwnd);

STDAPI BindCtx_CreateWithMode(DWORD grfMode, IBindCtx **ppbc);
STDAPI_(DWORD) BindCtx_GetMode(IBindCtx *pbc, DWORD grfModeDefault);
STDAPI_(BOOL) BindCtx_ContainsObject(IBindCtx *pbc, LPOLESTR sz);

STDAPI SaveShortcutInFolder(int csidl, LPTSTR pszName, IShellLink *psl);

STDAPI SHCreateFileSysBindCtx(const WIN32_FIND_DATA *pfd, IBindCtx **ppbc);
STDAPI SHCreateFileSysBindCtxEx(const WIN32_FIND_DATA *pfd, DWORD grfMode, DWORD grfFlags, IBindCtx **ppbc);
STDAPI SHIsFileSysBindCtx(IBindCtx *pbc, WIN32_FIND_DATA **ppfd);
STDAPI SHSimpleIDListFromFindData(LPCTSTR pszPath, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl);
STDAPI SHSimpleIDListFromFindData2(IShellFolder *psf, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl);
STDAPI SHCreateFSIDList(LPCTSTR pszFolder, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl);

STDAPI SimulateDropWithPasteSucceeded(IDropTarget * pdrop, IDataObject * pdtobj, DWORD grfKeyState, const POINTL *ppt, DWORD dwEffect, IUnknown * punkSite, BOOL fClearClipboard);
STDAPI DeleteFilesInDataObject(HWND hwnd, UINT uFlags, IDataObject *pdtobj, UINT fOptions);

STDAPI GetCLSIDFromIDList(LPCITEMIDLIST pidl, CLSID *pclsid);
STDAPI GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidl, CLSID *pclsid);

#ifdef DEBUG
STDAPI_(BOOL) AssertIsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid);
#endif

STDAPI_(BOOL) IsIDListInNameSpace(LPCITEMIDLIST pidl, const CLSID *pclsid);

STDAPI_(void) CleanupFileSystem();
SHSTDAPI_(HICON) SHGetFileIcon(HINSTANCE hinst, LPCTSTR pszPath, DWORD dwFileAttribute, UINT uFlags);
STDAPI GetIconLocationFromExt(IN LPTSTR pszExt, OUT LPTSTR pszIconPath, UINT cchIconPath, OUT LPINT piIconIndex);

STDAPI_(BOOL) IsMainShellProcess(); // is this the process that owns the desktop hwnd (eg the main explorer process)
STDAPI_(BOOL) IsProcessAnExplorer();
__inline BOOL IsSecondaryExplorerProcess()
{
    return (IsProcessAnExplorer() && !IsMainShellProcess());
}

STDAPI SHILAppend(LPITEMIDLIST pidlToAppend, LPITEMIDLIST *ppidl);
STDAPI SHILPrepend(LPITEMIDLIST pidlToPrepend, LPITEMIDLIST *ppidl);

//
// IDList macros and other stuff needed by the COFSFolder project
//
typedef enum {
    ILCFP_FLAG_NORMAL           = 0x0000,
    ILCFP_FLAG_SKIPJUNCTIONS    = 0x0001,  //  implies ILCFP_FLAG_NO_MAP_ALIAS
    ILCFP_FLAG_NO_MAP_ALIAS     = 0x0002,
} ILCFP_FLAGS;

STDAPI ILCreateFromCLSID(REFCLSID clsid, LPITEMIDLIST *ppidl);
STDAPI ILCreateFromPathEx(LPCTSTR pszPath, IUnknown *punkToSkip, ILCFP_FLAGS dwFlags, LPITEMIDLIST *ppidl, DWORD *rgfInOut);
STDAPI_(BOOL) ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);

STDAPI_(BOOL) SHSkipJunctionBinding(IBindCtx *pbc, const CLSID *pclsidSkip);
STDAPI SHCreateSkipBindCtx(IUnknown *punkToSkip, IBindCtx **ppbc);

STDAPI_(void) SetUnknownOnSuccess(HRESULT hres, IUnknown *punk, IUnknown **ppunkToSet);
STDAPI SHCacheTrackingFolder(LPCITEMIDLIST pidlRoot, int csidlTarget, IShellFolder2 **ppsfCache);
#define MAKEINTIDLIST(csidl)    (LPCITEMIDLIST)MAKEINTRESOURCE(csidl)

STDAPI_(BOOL) PathIsShortcut(LPCTSTR psz, DWORD dwFileAttributes);

typedef struct _ICONMAP
{
    UINT uType;                  // SHID_ type
    UINT indexResource;          // Resource index (of SHELL232.DLL)
} ICONMAP, *LPICONMAP;

STDAPI_(UINT) SILGetIconIndex(LPCITEMIDLIST pidl, const ICONMAP aicmp[], UINT cmax);

HMONITOR GetPrimaryMonitor();
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork);
#define GetMonitorRect(hMon, prc) \
        GetMonitorRects((hMon), (prc), FALSE)
#define GetMonitorWorkArea(hMon, prc) \
        GetMonitorRects((hMon), (prc), TRUE)
#define IsMonitorValid(hMon) \
        GetMonitorRects((hMon), NULL, TRUE)
#define GetNumberOfMonitors() \
        GetSystemMetrics(SM_CMONITORS)

BOOL IsSelf(UINT cidl, LPCITEMIDLIST *apidl);

#ifdef __cplusplus
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#else
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID(&((a).fmtid),&((b).fmtid)))
#endif
//
//  Helper function for defview callbacks.
//
STDAPI SHFindFirstFile(LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind);
STDAPI SHFindFirstFileRetry(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind, DWORD dwFlags);
STDAPI FindFirstRetryRemovable(HWND hwnd, IUnknown *punkModless, LPCTSTR pszPath, WIN32_FIND_DATA *pfd, HANDLE *phfind);
STDAPI_(UINT) SHEnumErrorMessageBox(HWND hwnd, UINT idTemplate, DWORD err, LPCTSTR pszParam, BOOL fNet, UINT dwFlags);

LPSTR _ConstructMessageStringA(HINSTANCE hInst, LPCSTR pszMsg, va_list *ArgList);
LPWSTR _ConstructMessageStringW(HINSTANCE hInst, LPCWSTR pszMsg, va_list *ArgList);
#ifdef UNICODE
#define _ConstructMessageString _ConstructMessageStringW
#else
#define _ConstructMessageString _ConstructMessageStringA
#endif

// TransferDelete() fOptions flags
#define SD_USERCONFIRMATION      0x0001
#define SD_SILENT                0x0002
#define SD_NOUNDO                0x0004
#define SD_WARNONNUKE            0x0008 // we pass this for drag-drop on recycle bin in case something is really going to be deleted

STDAPI TransferDelete(HWND hwnd, HDROP hDrop, UINT fOptions);

STDAPI_(BOOL) App_IsLFNAware(LPCTSTR pszFile);

STDAPI_(void) ReplaceDlgIcon(HWND hDlg, UINT id, HICON hIcon);
STDAPI_(LONG) GetOfflineShareStatus(LPCTSTR pcszPath);

HRESULT SHGetSetFolderSetting(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
        LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize);
HRESULT SHGetSetFolderSettingPath(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
        LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize);

void ExpandOtherVariables(LPTSTR pszFile, int cch);
void SubstituteWebDir(LPTSTR pszFile, int cch);

STDAPI_(BOOL) IsExplorerBrowser(IShellBrowser *psb);
STDAPI_(BOOL) IsExplorerModeBrowser(IUnknown *psite);
STDAPI_(HWND) ShellFolderViewWindow(HWND hwnd);     // evil that should be gone
STDAPI InvokeFolderPidl(LPCITEMIDLIST pidl, int nCmdShow);
STDAPI IUnknown_HTMLBackgroundColor(IUnknown *punk, COLORREF *pclr);

STDAPI_(int) MapSCIDToColumn(IShellFolder2* psf2, const SHCOLUMNID* pscid);

#ifdef COLUMNS_IN_DESKTOPINI
STDAPI _GetNextCol(LPTSTR* ppszText, DWORD* pnCol);
#endif

STDAPI SHReadProperty(IShellFolder *psf, LPCITEMIDLIST pidl, REFFMTID fmtid, PROPID pid, VARIANT *pvar);

// IDLIST.C
STDAPI ILCompareRelIDs(IShellFolder *psfParent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPARAM lParam);
STDAPI ILGetRelDisplayName(IShellFolder *psf, STRRET *psr, LPCITEMIDLIST pidlRel, LPCTSTR pszName, LPCTSTR pszTemplate, DWORD dwFlags);

STDAPI SHGetIconFromPIDL(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, int *piImage);

STDAPI_(int) SHRenameFileEx(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszDir, LPCTSTR pszOldName, LPCTSTR pszNewName);

#define MAX_ASSOC_KEYS      7
STDAPI AssocKeyFromElement(IAssociationElement *pae, HKEY *phk);
STDAPI_(DWORD) SHGetAssocKeys(IQueryAssociations *pqa, HKEY *rgKeys, DWORD cKeys);
STDAPI_(DWORD) SHGetAssocKeysEx(IAssociationArray *paa, ASSOCELEM_MASK mask, HKEY *rgKeys, DWORD cKeys);
STDAPI_(DWORD) SHGetAssocKeysForIDList(LPCITEMIDLIST pidlFull, HKEY *rgKeys, DWORD cKeys);
STDAPI AssocElemCreateForClass(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae);
STDAPI AssocElemCreateForKey(const CLSID *pclsid, HKEY hk, IAssociationElement **ppae);
STDAPI AssocGetDetailsOfSCID(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv, BOOL *pfFoundScid);

STDAPI_(HKEY)  SHOpenShellFolderKey(const CLSID *pclsid);
STDAPI_(BOOL)  SHQueryShellFolderValue(const CLSID *pclsid, LPCTSTR pszValueName);
STDAPI_(DWORD) SHGetAttributesFromCLSID(const CLSID *pclsid, DWORD dwDefAttrs);
STDAPI_(DWORD) SHGetAttributesFromCLSID2(const CLSID *pclsid, DWORD dwDefAttrs, DWORD dwRequested);

STDAPI SHGetUIObjectOf(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv);


STDAPI_(UINT) QueryCancelAutoPlayMsg();

STDAPI_(void) EnableAndShowWindow(HWND hWnd, BOOL bShow);

STDAPI_(void) DPA_FreeIDArray(HDPA hdpa);

STDAPI DetailsOf(IShellFolder2 *psf2, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch);

// Disk Cleanup launch flags
#define DISKCLEANUP_NOFLAG          0x00000000
#define DISKCLEANUP_DEFAULT         0x00000001
#define DISKCLEANUP_LOWDISK         0x00000002
#define DISKCLEANUP_VERYLOWDISK     0x00000004
#define DISKCLEANUP_MODAL           0x00000008

STDAPI_(void) LaunchDiskCleanup(HWND hwnd, int idDrive, UINT uFlags);
STDAPI_(BOOL) GetDiskCleanupPath(LPTSTR pszBuf, UINT cbSize);

STDAPI ParsePrinterName(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl);
STDAPI ParsePrinterNameEx(LPCTSTR pszPrinter, LPITEMIDLIST *ppidl, BOOL bValidated, DWORD dwType, USHORT uFlags);
STDAPI GetVariantFromRegistryValue(HKEY hkey, LPCTSTR pszValueName, VARIANT *pv);

STDAPI_(UINT) GetControlCharWidth(HWND hwnd);

STDAPI_(BOOL) ShowSuperHidden();
STDAPI_(BOOL) IsSuperHidden(DWORD dwAttribs);

STDAPI_(void) PathComposeWithArgs(LPTSTR pszPath, LPTSTR pszArgs);
STDAPI_(BOOL) PathSeperateArgs(LPTSTR pszPath, LPTSTR pszArgs);

STDAPI_(int) CompareIDsAlphabetical(IShellFolder2 *psf, UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

// folder.cpp
enum 
{
    XLATEALIAS_MYDOCS           = 0x00000001,    
    XLATEALIAS_DESKTOP          = 0x00000002,    
    XLATEALIAS_COMMONDOCS       = 0x00000003,   // BUGBUG?: XLATEALIAS_DESKTOP & XLATEALIAS_MYDOCS
//  XLATEALIAS_MYPICS,    
//  XLATEALIAS_NETHOOD,
};
#define XLATEALIAS_ALL  ((DWORD)0x0000ffff)

STDAPI SHILAliasTranslate(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlAlias, DWORD dwXlateAliases);

STDAPI StatStgFromFindData(const WIN32_FIND_DATA * pfd, DWORD dwFlags, STATSTG * pstat);

STDAPI_(BOOL) IsDesktopBrowser(IUnknown *punkSite);

STDAPI_(void) SHChangeNotifyDeregisterWindow(HWND hwnd);

STDAPI GetCCHMaxFromPath(LPCTSTR szFullPath, UINT *pcchMax, BOOL fShowExtension);

STDAPI ViewModeFromSVID(const SHELLVIEWID *pvid, FOLDERVIEWMODE *pViewMode);
STDAPI SVIDFromViewMode(FOLDERVIEWMODE uViewMode, SHELLVIEWID *psvid);

STDAPI_(DWORD) SetLinkFlags(IShellLink *psl, DWORD dwFlags, DWORD dwMask);

STDAPI TBCGetBindCtx(BOOL fCreate, IBindCtx **ppbc);
STDAPI TBCGetObjectParam(LPCOLESTR pszKey, REFIID riid, void **ppv);
STDAPI TBCRegisterObjectParam(LPCOLESTR pszKey, IUnknown *punk, IBindCtx **ppbcLifetime);
STDAPI TBCSetEnvironmentVariable(LPCWSTR pszVar, LPCWSTR pszValue, IBindCtx **ppbcLifetime);
STDAPI TBCGetEnvironmentVariable(LPCWSTR pszVar, LPWSTR pszValue, DWORD cchValue);

STDAPI_(int) CompareVariants(VARIANT va1, VARIANT va2);
STDAPI_(int) CompareBySCID(IShellFolder2 *psf, const SHCOLUMNID *pscid, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
STDAPI_(int) CompareFolderness(IShellFolder *psf, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

STDAPI_(BOOL) IsRegItemName(LPCTSTR pszName, CLSID* pclsid);

STDAPI SHCreateShellItemFromParent(IShellItem *psiParent, LPCWSTR pszName, IShellItem **ppsi);

STDAPI GetMyDocumentsDisplayName(LPTSTR pszPath, UINT cch);

STDAPI BSTRFromCLSID(REFCLSID clsid, BSTR *pbstr);

typedef struct {
    LPCWSTR pszCmd;   // verbW
    LPCSTR  pszCmdA;  // verbA
    WPARAM  idDFMCmd; // id to map to
    UINT    idDefCmd; // extra info defcm uses
} ICIVERBTOIDMAP;
HRESULT SHMapICIVerbToCmdID(LPCMINVOKECOMMANDINFO pici, const ICIVERBTOIDMAP* pmap, UINT cmap, UINT *pid);
HRESULT SHMapCmdIDToVerb(UINT_PTR idCmd, const ICIVERBTOIDMAP* pmap, UINT cmap, LPSTR pszName, UINT cchMax, BOOL bUnicode);

STDAPI SHPropertiesForUnk(HWND hwnd, IUnknown *punk, LPCTSTR psz);
STDAPI SHFullIDListFromFolderAndItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);

STDAPI_(BOOL) IsWindowClass(HWND hwndTest, LPCTSTR pszClass);

STDAPI DCA_ExtCreateInstance(HDCA hdca, int iItem, REFIID riid, LPVOID FAR* ppv);

STDAPI WrapInfotip(IShellFolder *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, IUnknown *punk);

STDAPI CloneIDListArray(UINT cidl, const LPCITEMIDLIST rgpidl[], UINT *pcidl, LPITEMIDLIST **papidl);

typedef BOOL (CALLBACK* ENUMSHELLWINPROC)(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam);
STDAPI EnumShellWindows(ENUMSHELLWINPROC pEnumFunc, LPARAM lParam);

// Infotip Helper Functions
BOOL    SHShowInfotips();
HRESULT SHCreateInfotipWindow(HWND hwndParent, LPWSTR pszInfotip, HWND *phwndInfotip);
HRESULT SHShowInfotipWindow(HWND hwndInfotip, BOOL bShow);
HRESULT SHDestroyInfotipWindow(HWND *phwndInfotip);

BOOL PolicyNoActiveDesktop(void);

// should we should wizards as icons in defview of this object?
STDAPI SHShouldShowWizards(IUnknown *punksite);

STDAPI SplitIDList(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFolder, LPCITEMIDLIST *ppidlChild);
STDAPI SHSimulateDropWithSite(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                              const POINTL *ppt, DWORD *pdwEffect, IUnknown *punkSite);
STDAPI FindAppForFileInUse(PCWSTR pszFile, PWSTR *ppszApp);

HRESULT InitializeDirectUI();
void UnInitializeDirectUI();

BOOL IsForceGuestModeOn(void);
BOOL IsFolderSecurityModeOn(void);

STDAPI_(int) StrCmpLogicalRestricted(PCWSTR psz1, PCWSTR psz2);

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\utilnt.c ===
#include "shellprv.h"
#pragma  hdrstop

BOOL APIENTRY
IsStringInList(
   LPWSTR lpS,
   LPWSTR lpList
   )
{
   while (*lpList) {
      if (!_wcsicmp(lpS,lpList)) {
         return(TRUE);
      }
      lpList += wcslen(lpList) + 1;
   }
   return FALSE;
}

LPWSTR APIENTRY
SheRemoveQuotesW(
   LPWSTR sz)
{
   LPWSTR lpT;

   if (WCHAR_QUOTE == *sz) {
      for (lpT = sz+1; *lpT && WCHAR_QUOTE != *lpT; lpT++) {
         *(lpT-1) = *lpT;
      }
      if (WCHAR_QUOTE == *lpT) {
         *(lpT-1) = WCHAR_NULL;
      }
   }
   return(sz);
}

LPSTR APIENTRY
SheRemoveQuotesA(
   LPSTR sz)
{
   LPSTR lpT;

   if (CHAR_QUOTE == *sz) {
      for (lpT = sz+1; *lpT && CHAR_QUOTE != *lpT; lpT++) {
         *(lpT-1) = *lpT;
#if (defined(DBCS) || defined(FE_SB))
         if (IsDBCSLeadByte(*lpT)) {
         lpT++;
            *(lpT-1) = *lpT;
       }
#endif
      }
      if (CHAR_QUOTE == *lpT) {
         *(lpT-1) = CHAR_NULL;
      }
   }
   return(sz);
}


/////////////////////////////////////////////////////////////////////
//
// Name:     SheShortenPathA
//
// Synopsis: Thunk to ShortenPathW
//
/////////////////////////////////////////////////////////////////////

BOOL APIENTRY
SheShortenPathA(LPSTR pPath, BOOL bShorten)
{
   WCHAR pPathW[MAX_PATH];
   BOOL bRetVal;

   MultiByteToWideChar(CP_ACP, 0, pPath, -1, pPathW, MAX_PATH);

   bRetVal = SheShortenPathW(pPathW, bShorten);

   WideCharToMultiByte(CP_ACP, 0, pPathW, -1, pPath, MAX_PATH,
      NULL, NULL);

   return bRetVal;
}



/////////////////////////////////////////////////////////////////////
//
// Name:     SheShortenPath
//
// Synopsis: Takes a pathname and converts all dirs to shortnames/longnames
//
// INOUT:    lpszPath  -- Path to shorten/lengthen (May be in DQUOTES)
//                        Must not be a commandline!
//
//           bShorten  -- T=shorten, F=Lengthen
//
// Return:   BOOL  T=Converted,
//                 F=ran out of space, buffer left alone
//
//
// Assumes:  lpszPath takes the form {"}?:\{f\}*f{"}  or {"}\\f\f\{f\}*f{"}
//           COUNTOF pSrc buffer >= MAXPATHELN
//
// Effects:  Strips quotes out of pPath, if any
//
//
// Notes:
//
/////////////////////////////////////////////////////////////////////

BOOL APIENTRY
SheShortenPathW(LPWSTR pPath, BOOL bShorten)
{
   WCHAR szDest[MAX_PATH];
   LPWSTR pSrcNextSpec, pReplaceSpec;
   LPWSTR pDest, pNewName, p;
   LPWSTR pSrc;
   DWORD cchPathOffset;
   HANDLE hFind;
   WIN32_FIND_DATA FindData;

   UINT i;
   INT nSpaceLeft = MAX_PATH-1;

   pSrc = pPath;

   //
   // Eliminate d-quotes
   //
   for (p = pDest =  pSrc; *p; p++, pDest++) {
      if (WCHAR_QUOTE == *p)
         p++;

      *pDest = *p;
   }

   *pDest = WCHAR_NULL;

   //
   // Strip out leading spaces
   //
   while (WCHAR_SPACE == *pSrc)
      pSrc++;

   //
   // Initialize pNewName so it is calculated once.
   //
   pNewName = bShorten ?
      FindData.cAlternateFileName :
      FindData.cFileName;

   //
   // Skip past \\foo\bar or <drive>:
   //
   pDest = szDest;
   pSrcNextSpec = pSrc;

   // reuse shell32 internal api that calculates path
   // offset.  cchPathOffset will be the offset that when
   // added to the pointer will result in a pointer to the
   // backslash before the first part of the path
   cchPathOffset = SheGetPathOffsetW(pSrc);

   // Check to see if it's valid.  If pSrc is not of the \\foo\bar
   // or <drive>: form we just do nothing
   if (0xFFFFFFFF == cchPathOffset) {
      return TRUE;
   }

   // cchPathOffset will then always be atleast 1 and is the
   // number of characters - 1 that we want to copy (that is, if 0
   // was permissible, it would denote 1 character).
   do {

      *pDest++ = *pSrcNextSpec++;

      if (!--nSpaceLeft)
         return FALSE;

   } while (cchPathOffset--);

   //
   // At this point, we have just the filenames that we can shorten:
   // \\foo\bar\it\is\here ->  it\is\here
   // c:\angry\lions       ->  angry\lions
   //

   while(pSrcNextSpec) {

      //
      // pReplaceSpec holds the current spec we need to replace.
      // By default, if we can't find the altname, then just use this.
      //

      pReplaceSpec = pSrcNextSpec;

      //
      // Search for trailing "\"
      // pSrcNextSpec will point to the next spec to fix (*pSrcNextSpec=NULL if done)
      //
      for(;*pSrcNextSpec && WCHAR_BSLASH != *pSrcNextSpec; pSrcNextSpec++)
         ;


      if (*pSrcNextSpec) {

         //
         // If there is more, then pSrcNextSpec should point to it.
         // Also delimit this spec.
         //
         *pSrcNextSpec = WCHAR_NULL;

      } else {

         pSrcNextSpec = NULL;
      }

      hFind = FindFirstFile(pSrc, &FindData);

      //
      // We could exit as soon as this FindFirstFileFails,
      // but there's the special case of having execute
      // without read permission.  This would fail since the lfn
      // is valid for lfn apps.
      //


      if (INVALID_HANDLE_VALUE != hFind) {

         FindClose(hFind);

         if (pNewName[0]) {

            //
            // We have found an altname.
            // Use it instead.
            //
            pReplaceSpec = pNewName;
         }
      }

      i = wcslen(pReplaceSpec);
      nSpaceLeft -= i;

      if (nSpaceLeft <= 0)
         return FALSE;

      wcscpy(pDest, pReplaceSpec);
      pDest+=i;

      //
      // Now replace the WCHAR_NULL with a slash if necessary
      //
      if (pSrcNextSpec) {
         *pSrcNextSpec++ = WCHAR_BSLASH;

         //
         // Also add backslash to dest
         //
         *pDest++ = WCHAR_BSLASH;
         nSpaceLeft--;
      }
   }

   wcscpy(pPath, szDest);

   return TRUE;
}


/*
 * Reads the list of program strings from win.ini
 */
LPWSTR GetPrograms()
{
   static LPWSTR lpPrograms = WCHAR_NULL;
   LPWSTR lpT,lpS;

   if (lpPrograms) {
      return lpPrograms;
   }

   if (!(lpPrograms = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH+1) * sizeof(WCHAR)))) {
      return(NULL);
   } else {

      GetProfileString(L"windows",L"programs",WSTR_BLANK,lpPrograms,MAX_PATH);

      for (lpS = lpT = lpPrograms; *lpT; lpT++) {
         if (*lpT == WCHAR_SPACE) {
            while (*lpT == WCHAR_SPACE) {
               lpT++;
            }
            lpT--;
            *lpS++ = 0;
         } else {
            *lpS++ = *lpT;
         }
      }

      *lpS++ = WCHAR_NULL;
      *lpS++ = WCHAR_NULL;
      return(lpPrograms);
   }
}

/*
 * Determines if an extension is a program
 */

BOOL IsProgram(LPWSTR lpExt)
{
   LPWSTR lpPrograms = GetPrograms();
   return lpPrograms ? IsStringInList(lpExt,lpPrograms) : FALSE;
}


/* finds a file along the path. Returns the error code or 0 if success.
 */

WORD
SearchForFile(
   LPCWSTR lpDir,
   LPWSTR lpFile,
   LPWSTR lpFullPath,
   DWORD cchFullPath,
   LPWSTR lpExt)
{
   LPWSTR lpT;
   LPWSTR lpD;
   LPWSTR lpExts;
   WCHAR szFile[MAX_PATH+1];
   DWORD cchPath;

   if (*lpFile == WCHAR_QUOTE) {
      lpFile = SheRemoveQuotes(lpFile);
   }
   if (NULL != (lpT=StrRChrW(lpFile, NULL, WCHAR_BSLASH))) {
      ++lpT;
   } else if (NULL != (lpT=StrRChrW(lpFile, NULL, WCHAR_COLON))) {
      ++lpT;
   } else {
      lpT = lpFile;
   }

   if (NULL != (lpT=StrRChrW(lpT, NULL, WCHAR_DOT))) {
      int n;

      n = wcslen(lpT + 1);
      StrCpyN(lpExt, lpT+1, n < 64 ? n+1 : 65);  // max extension
   } else {
      *lpExt = WCHAR_NULL;
   }

   // If there's no extension then just use programs list don't
   // try searc   hing for the app sans extension. This fixes the bogus
   // file.run stuff.
   if (!*lpExt) {
      goto UseDefExts;
   }

   //
   // NOTE: Do NOT call CharUpper for any of the strings in this routine.
   //       It will cause problems for the Turkish locale.
   //

   cchPath = SearchPath(lpDir, lpFile, NULL, cchFullPath, lpFullPath, &lpT);

   if (!cchPath) {
      cchPath = SearchPath(NULL, lpFile, NULL, cchFullPath, lpFullPath, &lpT);
   }

   if (cchPath >= cchFullPath) {
      return(SE_ERR_OOM);
   }

   if (cchPath == 0) {
      return(SE_ERR_FNF);
   }

   CheckEscapes(lpFullPath, cchFullPath);
   return 0;

UseDefExts:
   wcscpy(szFile,lpFile);
   lpFile = szFile;

   wcscat(lpFile,WSTR_DOT);
   lpD = lpFile + wcslen(lpFile);

   if (NULL != (lpExts = GetPrograms())) {
       // We want to pass through the loop twice checking whether the
       // file is in lpDir first, and then if it's in the sysdirs, via SearchPath(NULL, ...)
       // Add some state and extend the while loop
       LPCWSTR lpTempDir = lpDir;
       LPWSTR lpTempExts = lpExts;
       BOOL bCheckedSysDirs = FALSE;

       while (*lpTempExts || !bCheckedSysDirs) {

           // After the first pass, lpTempExts will be NULL
           // Reset it and loop through again with lpTempDir = NULL so that
           // SearchPath looks at the system dirs

           if (!*lpTempExts) {
              bCheckedSysDirs = TRUE;
              lpTempExts = lpExts;
              lpTempDir = NULL;
           }

           wcscpy(lpD,lpTempExts);
           wcscpy(lpExt,lpTempExts);

           cchPath = SearchPath(lpTempDir, lpFile, NULL, cchFullPath, lpFullPath, &lpT);
           if (cchPath >= cchFullPath) {
              return(SE_ERR_OOM);
           }

           if (cchPath != 0) {
              CheckEscapes(lpFullPath, cchFullPath);
              return 0;
           }

           lpTempExts += wcslen(lpTempExts)+1;
       }
   }
   return(SE_ERR_FNF);
}


/////////////////////////////////////////////////////////////////////
//
// Name:     QualifyAppName
//
// Synopsis: Creates a fully qualified path to the app in a commandline
//
// INC       lpCmdLine     Command line to qualify
//                         (Must have DQuotes if has spaces)
// OUT       lpImage       Fully qualified result
// OUT       ppArgs        Pointer to args in lpCmdLine, _incl_ leading space
//                         OPTIONAL
//
// Return:   DWORD length of path, 0 = fail
//
//
// Assumes:  len of executable in lpCmdLine is < MAX_PATH
//           len of exts are < 64
//
// Effects:
//
//
// Notes:
//
/////////////////////////////////////////////////////////////////////

DWORD
QualifyAppName(
   IN LPCWSTR lpCmdLine,
   OUT LPWSTR lpImage,
   OPTIONAL OUT LPCWSTR* ppArgs)
{
   LPWSTR lpAppName;
   BOOL bAppNameInQuotes = FALSE;
   DWORD cch = 0;

   lpAppName = lpImage;

   // sanity check
   if (!lpCmdLine) {
      return(0);
   }

   while (*lpCmdLine &&
         (*lpCmdLine != WCHAR_SPACE || bAppNameInQuotes)) {

      if (*lpCmdLine == WCHAR_QUOTE) {
         bAppNameInQuotes = !bAppNameInQuotes;
         lpCmdLine++;
         continue;
      }

      *lpAppName++ = *lpCmdLine++;
      cch++;
   }

   *lpAppName = WCHAR_NULL;

   //
   // Save the pointer to the argument list
   //
   if (ppArgs) {
      *ppArgs = lpCmdLine;
   }

   if (SheGetPathOffsetW(lpImage) == -1) {
      WCHAR szTemp[MAX_PATH];

      lstrcpy((LPWSTR)szTemp, lpImage);

      if (StrChrW(lpImage, WCHAR_DOT)) {
          LPWSTR lpFileName;

          return(SearchPath(NULL, szTemp, NULL, MAX_PATH, lpImage, &lpFileName));
      }
      else {
         WCHAR  szExt[65];

         *lpImage = WCHAR_NULL;
         if (SearchForFile(NULL, (LPWSTR)szTemp, lpImage, MAX_PATH, szExt)) {
            return(0);
         }

         return(lstrlen(lpImage));
      }
   }

   return(cch);
}


BOOL
SheConvertPathW(
    LPWSTR lpCmdLine,
    LPWSTR lpFile,
    UINT   cchCmdBuf)
/*++

Routine Description:

   Takes a command line and file and shortens both if the app in the
   command line is dos/wow.

Returns: BOOL T=converted

Arguments:

    INOUT     lpCmdLine  Command line to test
                         exe must be in DQuotes if it has spaces,
                         on return, will have DQuotes if necessary
    INOUT     lpFile     Fully qualified file to shorten
                         May be in DQuotes, but on return will not
                         have DQuotes (since single file)

    IN        cchCmdBuf  Size of buffer in characters

Return Value:

    VOID, but lpFile shortened (in place) if lpCmdLine is dos/wow.

    There are pathalogoical "lfns" (Single unicode chars) that can
    actually get longer when they are shortened.  In this case, we
    won't AV, but we will truncate the parms!

    // Qualify path assumes that the second parm is a buffer of
    // size atleast MAX_PATH, which is nicely equivalent to MAX_PATH
    // needs cleanup!

--*/

{
    LPWSTR lpszFullPath;
    LONG lBinaryType;
    BOOL bInQuote = FALSE;
    LPWSTR lpArgs;
    UINT cchNewLen;
    BOOL bRetVal = FALSE;

    lpszFullPath = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                       cchCmdBuf*sizeof(*lpCmdLine));

    if (!lpszFullPath)
       return bRetVal;

    //
    // We must do the swap here since we need to copy the
    // parms back to lpCmdLine.
    //
    lstrcpy(lpszFullPath, lpCmdLine);

    if (QualifyAppName(lpszFullPath, lpCmdLine, &lpArgs)) {

        if (!GetBinaryType(lpCmdLine, &lBinaryType) ||
            lBinaryType == SCS_DOS_BINARY ||
            lBinaryType == SCS_WOW_BINARY) {

            SheShortenPath(lpCmdLine, TRUE);

            if (lpFile) {
                SheShortenPath(lpFile, TRUE);
            }
            bRetVal = TRUE;
        }

        //
        // Must readd quotes
        //
        CheckEscapes(lpCmdLine, cchCmdBuf);

        cchNewLen = lstrlen(lpCmdLine);
        StrNCpy(lpCmdLine+cchNewLen, lpArgs, cchCmdBuf-cchNewLen);
    } else {
        //
        // QualifyAppName failed, restore the command line back
        // to the original state.
        //

        lstrcpy(lpCmdLine, lpszFullPath);
    }

    LocalFree((HLOCAL)lpszFullPath);

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\version.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "help.h"

#define DWORDUP(x)              (((x)+3)&~3)
#define VerKeyToValue(lpKey)    (lpKey + DWORDUP(lstrlen(lpKey)+1))

#pragma warning(disable: 4200)   // zero size array in struct

// magic undoced explort from version.dll

STDAPI_(BOOL) VerQueryValueIndexW(const void *pBlock, LPTSTR lpSubBlock, DWORD dwIndex, void **ppBuffer, void **ppValue, PUINT puLen);

#ifdef UNICODE
#define VerQueryValueIndex VerQueryValueIndexW
#endif

typedef struct 
{
    WORD wTotLen;
    WORD wValLen;
    TCHAR szKey[];
} SHELLVERBLOCK, *LPSHELLVERBLOCK;

// Following code is copied from fileman\wfdlgs2.c


//    The following data structure associates a version stamp datum
//    name (which is not localized) with a string ID.  This is so we
//    can show translations of these names to the user.
struct vertbl {
    TCHAR const *pszName;
    short idString;
};

//   Note that version stamp datum names are NEVER internationalized,
//   so the following literal strings are just fine.

const struct vertbl vernames[] = {

    // For the first NUM_SPECIAL_STRINGS, the second column is the dialog ID.

    { TEXT("LegalCopyright"),   IDD_VERSION_COPYRIGHT },
    { TEXT("FileDescription"),  IDD_VERSION_DESCRIPTION },

    // For the rest, the second column is the string ID.

    { TEXT("FileVersion"),              IDS_VN_FILEVERSION },
    { TEXT("Comments"),                 IDS_VN_COMMENTS },
    { TEXT("CompanyName"),              IDS_VN_COMPANYNAME },
    { TEXT("InternalName"),             IDS_VN_INTERNALNAME },
    { TEXT("LegalTrademarks"),  IDS_VN_LEGALTRADEMARKS },
    { TEXT("OriginalFilename"), IDS_VN_ORIGINALFILENAME },
    { TEXT("PrivateBuild"),             IDS_VN_PRIVATEBUILD },
    { TEXT("ProductName"),              IDS_VN_PRODUCTNAME },
    { TEXT("ProductVersion"),           IDS_VN_PRODUCTVERSION },
    { TEXT("SpecialBuild"),             IDS_VN_SPECIALBUILD }
};

#define NUM_SPECIAL_STRINGS     2
#define VERSTR_MANDATORY        TEXT("FileVersion")


typedef struct { // vp
    PROPSHEETPAGE psp;
    HWND hDlg;
    LPTSTR pVerBuffer;          /* pointer to version data */
    TCHAR szVersionKey[60];     /* big enough for anything we need */
    struct _VERXLATE
    {
        WORD wLanguage;
        WORD wCodePage;
    } *lpXlate;                     /* ptr to translations data */
    int cXlate;                 /* count of translations */
    LPTSTR pszXlate;
    int cchXlateString;
    TCHAR szFile[MAX_PATH];
} VERPROPSHEETPAGE, * LPVERPROPSHEETPAGE;


#define VER_KEY_END     25      /* length of "\StringFileInfo\xxxxyyyy\" */
                                /* (not localized) */
#define MAXMESSAGELEN   (50 + MAX_PATH * 2)


/*
    Gets a particular datum about a file.  The file's version info
    should have already been loaded by GetVersionInfo.  If no datum
    by the specified name is available, NULL is returned.  The name
    specified should be just the name of the item itself;  it will
    be concatenated onto "\StringFileInfo\xxxxyyyy\" automatically.

    Version datum names are not localized, so it's OK to pass literals
    such as "FileVersion" to this function.

    Note that since the returned datum is in a global memory block,
    the return value of this function is LPSTR, not PSTR.
*/
LPTSTR GetVersionDatum(LPVERPROPSHEETPAGE pvp, LPCTSTR pszName)
{
    UINT cbValue = 0;
    LPTSTR lpValue;

    if (!pvp->pVerBuffer)
        return NULL;

    lstrcpy(pvp->szVersionKey + VER_KEY_END, pszName);

    VerQueryValue(pvp->pVerBuffer, pvp->szVersionKey, (void **)&lpValue, &cbValue);

    return (cbValue != 0) ? lpValue : NULL;
}

/*
    Frees global version data about a file.  After this call, all
    GetVersionDatum calls will return NULL.  To avoid memory leaks,
    always call this before the main properties dialog exits.
*/
void FreeVersionInfo(LPVERPROPSHEETPAGE pvp)
{
    if (pvp->pVerBuffer) 
    {
        GlobalFree(pvp->pVerBuffer);
        pvp->pVerBuffer = NULL;
    }
    if (pvp->pszXlate) 
    {
        LocalFree((HLOCAL)(HANDLE)pvp->pszXlate);
        pvp->pszXlate = NULL;
    }

    pvp->lpXlate = NULL;
}

/*
    Initialize version information for the properties dialog.  The
    above global variables are initialized by this function, and
    remain valid (for the specified file only) until FreeVersionInfo
    is called.

    The first language we try will be the first item in the
    "\VarFileInfo\Translations" section;  if there's nothing there,
    we try the one coded into the IDS_FILEVERSIONKEY resource string.
    If we can't even load that, we just use English (040904E4).  We
    also try English with a null codepage (04090000) since many apps
    were stamped according to an old spec which specified this as
    the required language instead of 040904E4.

    GetVersionInfo returns TRUE if the version info was read OK,
    otherwise FALSE.  If the return is FALSE, the buffer may still
    have been allocated;  always call FreeVersionInfo to be safe.

    pszPath is modified by this call (pszName is appended).
*/
BOOL GetVersionInfo(LPVERPROPSHEETPAGE pvp, LPCTSTR pszPath)
{
    UINT cbValue = 0;
    LPTSTR pszValue = NULL;
    DWORD dwHandle;             /* version subsystem handle */
    DWORD dwVersionSize;        /* size of the version data */

    FreeVersionInfo(pvp);       /* free old version buffer */

    // cast const -> non const for bad API def
    dwVersionSize = GetFileVersionInfoSize((LPTSTR)pszPath, &dwHandle);

    if (dwVersionSize == 0L)
        return FALSE;           /* no version info */

    pvp->pVerBuffer = GlobalAlloc(GPTR, dwVersionSize);
    if (pvp->pVerBuffer == NULL)
        return FALSE;

    // cast const -> non const for bad API def
    
    if (!GetFileVersionInfo((LPTSTR)pszPath, dwHandle, dwVersionSize, pvp->pVerBuffer))
    {
        return FALSE;
    }

    // Look for translations
    if (VerQueryValue(pvp->pVerBuffer, TEXT("\\VarFileInfo\\Translation"), (void **)&pvp->lpXlate, &cbValue)
                && cbValue)
    {
        pvp->cXlate = cbValue / sizeof(DWORD);
        pvp->cchXlateString = pvp->cXlate * 64;  /* figure 64 chars per lang name */
        pvp->pszXlate = (LPTSTR)(void*)LocalAlloc(LPTR, pvp->cchXlateString*sizeof(TCHAR));
        // failure of above will be handled later
    }
    else
    {
        pvp->lpXlate = NULL;
    }

    // Try same language as this program
    if (LoadString(HINST_THISDLL, IDS_VN_FILEVERSIONKEY, pvp->szVersionKey, ARRAYSIZE(pvp->szVersionKey)))
    {
        if (GetVersionDatum(pvp, VERSTR_MANDATORY))
        {
            return TRUE;
        }
    }

    // Try first language this supports
    if (pvp->lpXlate)
    {
        wsprintf(pvp->szVersionKey, TEXT("\\StringFileInfo\\%04X%04X\\"),
                pvp->lpXlate[0].wLanguage, pvp->lpXlate[0].wCodePage);
        if (GetVersionDatum(pvp, VERSTR_MANDATORY))  /* a required field */
        {
            return TRUE;
        }
    }

#ifdef UNICODE
    // try English, unicode code page
    lstrcpy(pvp->szVersionKey, TEXT("\\StringFileInfo\\040904B0\\"));
    if (GetVersionDatum(pvp, VERSTR_MANDATORY))
    {
        return TRUE;
    }
#endif

    // try English
    lstrcpy(pvp->szVersionKey, TEXT("\\StringFileInfo\\040904E4\\"));
    if (GetVersionDatum(pvp, VERSTR_MANDATORY))
    {
        return TRUE;
    }

    // try English, null codepage
    lstrcpy(pvp->szVersionKey, TEXT("\\StringFileInfo\\04090000\\"));
    if (GetVersionDatum(pvp, VERSTR_MANDATORY))
    {
        return TRUE;
    }

    // Could not find FileVersion info in a reasonable format
    return FALSE;
}


/*
    Fills the version key listbox with all available keys in the
    StringFileInfo block, and sets the version value text to the
    value of the first item.
*/
void FillVersionList(LPVERPROPSHEETPAGE pvp)
{
    LPTSTR pszName;
    LPTSTR pszValue;
    TCHAR szStringBase[VER_KEY_END+1];
    int i, j, idx;
    TCHAR szMessage[MAXMESSAGELEN+1];
    UINT uOffset, cbValue;
    
    HWND hwndLB = GetDlgItem(pvp->hDlg, IDD_VERSION_KEY);
    
    ListBox_ResetContent(hwndLB);
    for (i=0; i<NUM_SPECIAL_STRINGS; ++i)
    {
        SetDlgItemText(pvp->hDlg, vernames[i].idString, szNULL);
    }
    
    pvp->szVersionKey[VER_KEY_END] = 0;        /* don't copy too much */
    lstrcpy(szStringBase, pvp->szVersionKey);   /* copy to our buffer */
    szStringBase[VER_KEY_END - 1] = 0; /* strip the backslash */
    
    // Note: The Nt Version of version.dll has other exports.  If/When they are
    // available in Win version then we can remove this section...

    //  Get the binary file version from the VS_FIXEDFILEINFO
    {
        VS_FIXEDFILEINFO *pffi;
        if (VerQueryValue(pvp->pVerBuffer, TEXT("\\"), (void **)&pffi, &cbValue) && cbValue)
        {
            TCHAR szString[128];

            // display the binary version info, not the useless
            // string version (that can be out of sync)

            wnsprintf(szString, ARRAYSIZE(szString), TEXT("%d.%d.%d.%d"),
                HIWORD(pffi->dwFileVersionMS),
                LOWORD(pffi->dwFileVersionMS),
                HIWORD(pffi->dwFileVersionLS),
                LOWORD(pffi->dwFileVersionLS));
            SetDlgItemText(pvp->hDlg, IDD_VERSION_FILEVERSION, szString);
        }
    }

    //
    // Now iterate through all of the strings
    //
    for (j = 0; ; j++)
    {
        if (!VerQueryValueIndex(pvp->pVerBuffer, szStringBase, j, &pszName, &pszValue, &cbValue))
            break;
        
        for (i = 0; i < ARRAYSIZE(vernames); i++)
        {
            if (!lstrcmp(vernames[i].pszName, pszName))
            {
                break;
            }
        }
        
        if (i < NUM_SPECIAL_STRINGS)
        {
            SetDlgItemText(pvp->hDlg, vernames[i].idString, pszValue);
        }
        else
        {
            if (i == ARRAYSIZE(vernames) ||
                !LoadString(HINST_THISDLL, vernames[i].idString, szMessage, ARRAYSIZE(szMessage)))
            {
                lstrcpy(szMessage, pszName);
            }
            
            idx = ListBox_AddString(hwndLB, szMessage);
            if (idx != LB_ERR)
            {
                ListBox_SetItemData(hwndLB, idx, (DWORD_PTR)pszValue);
            }
        }
    }
    
    // Now look at the \VarFileInfo\Translations section and add an
    // item for the language(s) this file supports.
    
    if (pvp->lpXlate == NULL || pvp->pszXlate == NULL)
        return;
    
    if (!LoadString(HINST_THISDLL, (pvp->cXlate == 1) ? IDS_VN_LANGUAGE : IDS_VN_LANGUAGES,
        szMessage, ARRAYSIZE(szMessage)))
        return;
    
    idx = ListBox_AddString(hwndLB, szMessage);
    if (idx == LB_ERR)
        return;
    
    pvp->pszXlate[0] = 0;
    uOffset = 0;
    for (i = 0; i < pvp->cXlate; i++) {
        if (uOffset + 2 > (UINT)pvp->cchXlateString)
            break;
        if (i != 0) {
            lstrcat(pvp->pszXlate, TEXT(", "));
            uOffset += 2;       // skip over ", "
        }
        if (VerLanguageName(pvp->lpXlate[i].wLanguage, pvp->pszXlate + uOffset, pvp->cchXlateString - uOffset) >
            (DWORD)(pvp->cchXlateString - uOffset))
            break;
        uOffset += lstrlen(pvp->pszXlate + uOffset);
    }
    pvp->pszXlate[pvp->cchXlateString - 1] = 0;
    ListBox_SetItemData(hwndLB, idx, (LPARAM)(LPTSTR)pvp->pszXlate);
    ListBox_SetCurSel(hwndLB, 0);
    
    FORWARD_WM_COMMAND(pvp->hDlg, IDD_VERSION_KEY, hwndLB, LBN_SELCHANGE, PostMessage);
}


//
// Function:    _UpdateVersionPrsht, private
//
// Descriptions:
//   This function fills fields of the "version" dialog box (a page of
//  a property sheet) with attributes of the associated file.
//
// Returns:
//  TRUE, if successfully done; FALSE, otherwise.
//
// History:
//  01-06-93 Shrikant   Created
//
BOOL _UpdateVersionPrsht(LPVERPROPSHEETPAGE pvp)
{
    if (GetVersionInfo(pvp, pvp->szFile))           /* changes szPath */
        FillVersionList(pvp);

    return TRUE;
}


void _VersionPrshtCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    LPTSTR pszValue;
    int idx;
    
    switch (id)
    {
    case IDD_VERSION_KEY:
        if (codeNotify != LBN_SELCHANGE)
        {
            break;
        }
        
        idx = ListBox_GetCurSel(hwndCtl);
        pszValue = (LPTSTR)ListBox_GetItemData(hwndCtl, idx);
        if (pszValue)
        {
            SetDlgItemText(hwnd, IDD_VERSION_VALUE, pszValue);
        }
        break;
    }
}

// Array for context help:
static const DWORD aVersionHelpIds[] = {
    IDD_VERSION_FILEVERSION, IDH_FPROP_VER_ABOUT,
    IDD_VERSION_DESCRIPTION, IDH_FPROP_VER_ABOUT,
    IDD_VERSION_COPYRIGHT,   IDH_FPROP_VER_ABOUT,
    IDD_VERSION_FRAME,       IDH_FPROP_VER_INFO,
    IDD_VERSION_KEY,         IDH_FPROP_VER_INFO,
    IDD_VERSION_VALUE,       IDH_FPROP_VER_INFO,

    0, 0
};

BOOL_PTR CALLBACK _VersionPrshtDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LPVERPROPSHEETPAGE pvp = (LPVERPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pvp = (LPVERPROPSHEETPAGE)lParam;
        pvp->hDlg = hDlg;
        break;

    case WM_DESTROY:
        FreeVersionInfo(pvp);   // free anything we created
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP,
            (ULONG_PTR) (LPTSTR) aVersionHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPTSTR) aVersionHelpIds);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            _UpdateVersionPrsht(pvp);
            break;
        }
        break;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, _VersionPrshtCommand);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//
// creates a property sheet for the "version" page which shows version information.
//
STDAPI_(void) AddVersionPage(LPCTSTR pszFile, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    DWORD dwAttr = GetFileAttributes(pszFile);
    if (0xFFFFFFFF != dwAttr && 0 == (dwAttr & FILE_ATTRIBUTE_OFFLINE) /*avoid HSM recall*/)
    {
        DWORD dwVerLen, dwVerHandle;
        VERPROPSHEETPAGE vp = {0};

        lstrcpyn(vp.szFile, pszFile, ARRAYSIZE(vp.szFile));

        dwVerLen = GetFileVersionInfoSize(vp.szFile, &dwVerHandle);
        if (dwVerLen) 
        {
            HPROPSHEETPAGE hpage;

            vp.psp.dwSize = sizeof(VERPROPSHEETPAGE);     // extra data
            vp.psp.dwFlags = PSP_DEFAULT;
            vp.psp.hInstance = HINST_THISDLL;
            vp.psp.pszTemplate = MAKEINTRESOURCE(DLG_VERSION);
            vp.psp.pfnDlgProc = _VersionPrshtDlgProc;

            hpage = CreatePropertySheetPage(&vp.psp);
            if (hpage)
                if (!pfnAddPage(hpage, lParam))
                    DestroyPropertySheetPage(hpage);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\viewstate.cpp ===
#include "shellprv.h"
#include "defviewp.h"
#include "ViewState.h"


CViewState::CViewState()
{
    ASSERT(_lParamSort == NULL);
    ASSERT(_iDirection == 0);
    ASSERT(_iLastColumnClick == 0);
    ASSERT(_ViewMode == 0);
    ASSERT(_ptScroll.x == 0 && _ptScroll.y == 0);
    ASSERT(_guidGroupID == GUID_NULL);
    ASSERT(_scidDetails.fmtid == GUID_NULL);
    ASSERT(_scidDetails.pid == 0);
    ASSERT(_hdsaColumnOrder == NULL);
    ASSERT(_hdsaColumnWidths == NULL);
    ASSERT(_hdsaColumnStates == NULL);
    ASSERT(_hdpaItemPos == NULL);
    ASSERT(_pbPositionData == NULL);

    _iDirection = 1;

    _fFirstViewed = TRUE;       // Assume this is the first time we are looking at a folder.
}

CViewState::~CViewState()
{
    if (_hdsaColumnOrder)
        DSA_Destroy(_hdsaColumnOrder);

    if (_hdsaColumnWidths)
        DSA_Destroy(_hdsaColumnWidths);

    if (_hdsaColumnStates)
        DSA_Destroy(_hdsaColumnStates);

    if (_hdsaColumns)
        DSA_Destroy(_hdsaColumns);

    ClearPositionData();

    LocalFree(_pbPositionData); // accepts NULL
}



// When initializing a new DefView, see if we can 
// propogate information from the previous one.
void CViewState::InitFromPreviousView(IUnknown* pPrevView)
{
    CDefView *pdsvPrev;
    if (SUCCEEDED(pPrevView->QueryInterface(IID_PPV_ARG(CDefView, &pdsvPrev))))
    {
        // preserve stuff like sort order
        _lParamSort = pdsvPrev->_vs._lParamSort;
        _iDirection = pdsvPrev->_vs._iDirection;
        _iLastColumnClick = pdsvPrev->_vs._iLastColumnClick;
        pdsvPrev->Release();
    }
}

void CViewState::InitFromHeader(DVSAVEHEADER_COMBO* pdv)
{
    _lParamSort = pdv->dvSaveHeader.dvState.lParamSort;
    _iDirection = pdv->dvSaveHeader.dvState.iDirection;
    // Patch this up. I guess at one time we persisted this wrong.
    if (_iDirection == 0)
        _iDirection = 1;
    _iLastColumnClick = pdv->dvSaveHeader.dvState.iLastColumnClick;
    _ViewMode = pdv->dvSaveHeader.ViewMode;
    _ptScroll = pdv->dvSaveHeader.ptScroll;
}

void CViewState::GetDefaults(CDefView* pdv, LPARAM* plParamSort, int* piDirection, int* piLastColumnClick)
{
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SORTCOLUMNS, FALSE);
    if (plParamSort)
        *plParamSort = ss.lParamSort;

    if (piDirection)
        *piDirection = ss.iSortDirection ? ss.iSortDirection : 1;
    if (piLastColumnClick)
        *piLastColumnClick = -1;
    pdv->CallCB(SFVM_GETSORTDEFAULTS, (LPARAM)piDirection, (WPARAM)plParamSort);
}

void CViewState::InitWithDefaults(CDefView* pdv)
{
    GetDefaults(pdv, &_lParamSort, &_iDirection, &_iLastColumnClick);
}

int CALLBACK CViewState::_SavedItemCompare(void *p1, void *p2, LPARAM lParam)
{
    CDefView *pdv = reinterpret_cast<CDefView*>(lParam);

    UNALIGNED VIEWSTATE_POSITION *pdvi1 = (UNALIGNED VIEWSTATE_POSITION *)p1;
    UNALIGNED VIEWSTATE_POSITION *pdvi2 = (UNALIGNED VIEWSTATE_POSITION *)p2;

    // manually terminate these pidls because they are packed together
    // in the save buffer

    LPITEMIDLIST pFakeEnd1 = _ILNext(&pdvi1->idl);
    USHORT uSave1 = pFakeEnd1->mkid.cb;
    pFakeEnd1->mkid.cb = 0;

    LPITEMIDLIST pFakeEnd2 = _ILNext(&pdvi2->idl);
    USHORT uSave2 = pFakeEnd2->mkid.cb;
    pFakeEnd2->mkid.cb = 0;

    int nCmp = pdv->_Compare(&pdvi1->idl, &pdvi2->idl, reinterpret_cast<LPARAM>(pdv));

    pFakeEnd2->mkid.cb = uSave2;
    pFakeEnd1->mkid.cb = uSave1;

    return nCmp;
}

BOOL CViewState::SyncPositions(CDefView* pdv)
{
    if (_ViewMode != pdv->_fs.ViewMode)
    {
        return FALSE;
    }

    if (_hdpaItemPos == NULL || DPA_GetPtrCount(_hdpaItemPos) == 0)
    {
        return FALSE;
    }

    if (DPA_Sort(_hdpaItemPos, _SavedItemCompare, (LPARAM)pdv))
    {
        UNALIGNED VIEWSTATE_POSITION * UNALIGNED * ppDVItem = (UNALIGNED VIEWSTATE_POSITION * UNALIGNED *)DPA_GetPtrPtr(_hdpaItemPos);
        UNALIGNED VIEWSTATE_POSITION * UNALIGNED *ppEndDVItems = ppDVItem + DPA_GetPtrCount(_hdpaItemPos);

        // Turn off auto-arrange and snap-to-grid if it's on at the mo.
        DWORD dwStyle = GetWindowStyle(pdv->_hwndListview);
        if (dwStyle & LVS_AUTOARRANGE)
            SetWindowLong(pdv->_hwndListview, GWL_STYLE, dwStyle & ~LVS_AUTOARRANGE);
            
        DWORD dwLVExStyle = ListView_GetExtendedListViewStyle(pdv->_hwndListview);
        if (dwLVExStyle & LVS_EX_SNAPTOGRID)
            ListView_SetExtendedListViewStyle(pdv->_hwndListview, dwLVExStyle & ~LVS_EX_SNAPTOGRID);

        HDSA hdsaPositionlessItems = NULL;
        int iCount = ListView_GetItemCount(pdv->_hwndListview);
        for (int i = 0; i < iCount; i++)
        {
            LPCITEMIDLIST pidl = pdv->_GetPIDL(i);

            // need to check for pidl because this could be on a background
            // thread and an fsnotify could be coming through to blow it away
            for ( ; pidl ; )
            {
                int nCmp;

                if (ppDVItem < ppEndDVItems)
                {
                    // We terminate the IDList manually after saving
                    // the needed information.  Note we will not GP fault
                    // since we added sizeof(ITEMIDLIST) onto the Alloc
                    LPITEMIDLIST pFakeEnd = _ILNext(&(*ppDVItem)->idl);
                    USHORT uSave = pFakeEnd->mkid.cb;
                    pFakeEnd->mkid.cb = 0;

                    nCmp = pdv->_Compare(&((*ppDVItem)->idl), (void *)pidl, (LPARAM)pdv);

                    pFakeEnd->mkid.cb = uSave;
                }
                else
                {
                    // do this by default.  this prevents overlap of icons
                    //
                    // i.e.  if we've run out of saved positions information,
                    // we need to just loop through and set all remaining items
                    // to position 0x7FFFFFFFF so that when it's really shown,
                    // the listview will pick a new (unoccupied) spot.
                    // breaking out now would leave it were the _Sort
                    // put it, but another item with saved state info could
                    // have come and be placed on top of it.
                    nCmp = 1;
                }

                if (nCmp > 0)
                {
                    // We did not find the item
                    // reset it's position to be recomputed

                    if (NULL == hdsaPositionlessItems)
                        hdsaPositionlessItems = DSA_Create(sizeof(int), 16);

                    if (hdsaPositionlessItems)
                        DSA_AppendItem(hdsaPositionlessItems, (void*)&i);

                    break;
                }
                else if (nCmp == 0) // They are equal
                {
                    UNALIGNED VIEWSTATE_POSITION * pDVItem = *ppDVItem;
                    
                    pdv->_SetItemPosition(i, pDVItem->pt.x, pDVItem->pt.y);

                    ppDVItem++; // move on to the next
                    break;
                }

                ppDVItem++; // move to the next
            }
        }

        if (hdsaPositionlessItems)
        {
            for (i = 0; i < DSA_GetItemCount(hdsaPositionlessItems); i++)
            {
                int* pIndex = (int*)DSA_GetItemPtr(hdsaPositionlessItems, i);
                pdv->_SetItemPosition(*pIndex, 0x7FFFFFFF, 0x7FFFFFFF);
            }

            DSA_Destroy(hdsaPositionlessItems);
        }

        // Turn auto-arrange and snap to grid back on if needed...
        if (dwLVExStyle & LVS_EX_SNAPTOGRID)
            ListView_SetExtendedListViewStyle(pdv->_hwndListview, dwLVExStyle);

        if (dwStyle & LVS_AUTOARRANGE)
            SetWindowLong(pdv->_hwndListview, GWL_STYLE, dwStyle);
    }
    return TRUE;
}

void CViewState::LoadPositionBlob(CDefView* pdv, DWORD cbSizeofStream, IStream* pstm)
{
    // Allocate a blob of memory to hold the position info.
    if (_pbPositionData) 
        LocalFree(_pbPositionData);

    _pbPositionData = (BYTE*)LocalAlloc(LPTR, cbSizeofStream);
    if (_pbPositionData == NULL)
        return;

    // Read into that blob.
    if (SUCCEEDED(pstm->Read(_pbPositionData, cbSizeofStream, NULL)))
    {
        // Walk the blob, and append to the DPA.
        UNALIGNED VIEWSTATE_POSITION *pDVItem = (UNALIGNED VIEWSTATE_POSITION *)(_pbPositionData);
        UNALIGNED VIEWSTATE_POSITION *pDVEnd = (UNALIGNED VIEWSTATE_POSITION *)(_pbPositionData + cbSizeofStream - sizeof(VIEWSTATE_POSITION));

        ClearPositionData();  // destroy _hdpaItemPos

        // Grow every 16 items
        _hdpaItemPos = DPA_Create(16);
        if (_hdpaItemPos)
        {
            for ( ; ; pDVItem = (UNALIGNED VIEWSTATE_POSITION *)_ILNext(&pDVItem->idl))
            {
                if (pDVItem > pDVEnd)
                {
                    break;  // Invalid list
                }

                // End normally when we reach a NULL IDList
                if (pDVItem->idl.mkid.cb == 0)
                {
                    break;
                }

                if (DPA_AppendPtr(_hdpaItemPos, pDVItem) < 0)
                {
                    break;
                }
            }
        }
    }
}

HRESULT CViewState::SavePositionBlob(CDefView* pdv, IStream* pstm)
{
    HRESULT hr = S_FALSE;   // success, but did nothing

    if (pdv->_fUserPositionedItems && pdv->_IsPositionedView())
    {
        VIEWSTATE_POSITION dvitem = {0};
        int iCount = ListView_GetItemCount(pdv->_hwndListview);
        for (int i = 0; SUCCEEDED(hr) && (i < iCount); i++)
        {
            ListView_GetItemPosition(pdv->_hwndListview, i, &dvitem.pt);

            hr = pstm->Write(&dvitem.pt, sizeof(dvitem.pt), NULL);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidl = pdv->_GetPIDL(i);
                if (pidl)
                    hr = pstm->Write(pidl, pidl->mkid.cb, NULL);
                else
                    hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Terminate the list with a NULL IDList
            dvitem.idl.mkid.cb = 0;
            hr = pstm->Write(&dvitem, sizeof(dvitem), NULL);
        }
    }
    return hr;
}

void CViewState::ClearPositionData()
{
    if (_hdpaItemPos)
    {
        DPA_Destroy(_hdpaItemPos);
        _hdpaItemPos = NULL;
    }
}

UINT CViewState::GetColumnCount()       
{ 
    if (!_hdsaColumns) 
        return 0; 

    return DSA_GetItemCount(_hdsaColumns);    
}

DWORD CViewState::GetColumnState(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->csFlags;
    }

    return 0;
}

DWORD CViewState::GetTransientColumnState(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->tsFlags;
    }

    return 0;
}

void CViewState::SetColumnState(UINT uCol, DWORD dwMask, DWORD dwNewBits)
{
    if (_hdsaColumns && uCol < GetColumnCount())
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        pci->csFlags = (pci->csFlags & ~dwMask) | (dwNewBits & dwMask);
    }
}

void CViewState::SetTransientColumnState(UINT uCol, DWORD dwMask, DWORD dwNewBits)
{
    if (_hdsaColumns && uCol < GetColumnCount())
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        pci->tsFlags = (pci->tsFlags & ~dwMask) | (dwNewBits & dwMask);
    }
}

LPTSTR CViewState::GetColumnName(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->szName;
    }

    return NULL;
}

UINT CViewState::GetColumnCharCount(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->cChars;
    }

    return 0;
}

int CViewState::GetColumnFormat(UINT uCol)
{
    if (_hdsaColumns && (uCol < GetColumnCount()))
    {
        COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, uCol);
        return pci->fmt;
    }

    return 0;
}


HRESULT CViewState::InitializeColumns(CDefView* pdv)
{
    if (_hdsaColumns != NULL)
        return S_OK;

    _hdsaColumns = DSA_Create(sizeof(COL_INFO), 6);

    if (!_hdsaColumns)
        return E_OUTOFMEMORY;

    for (UINT iReal = 0; ; iReal++)
    {
        DETAILSINFO di = {0};
        di.fmt  = LVCFMT_LEFT;
        di.cxChar = 20;
        di.str.uType = (UINT)-1;

        if (SUCCEEDED(pdv->_GetDetailsHelper(iReal, &di)))
        {
            COL_INFO ci = {0};

            StrRetToBuf(&di.str, NULL, ci.szName, ARRAYSIZE(ci.szName));
            ci.cChars = di.cxChar;
            ci.csFlags = pdv->_DefaultColumnState(iReal);
            ci.fmt = di.fmt;

            DSA_AppendItem(_hdsaColumns, &ci);
        }
        else
            break;
    }

    // Set up saved column state only if the saved state
    // contains information other than "nothing".

    if (_hdsaColumnStates)
    {
        UINT cStates = DSA_GetItemCount(_hdsaColumnStates);
        if (cStates > 0)
        {
            // 99/02/05 vtan: If there is a saved column state then
            // clear all the column "on" states to "off" and only
            // display what columns are specified. Start at 1 so
            // that name is always on.

            for (iReal = 1; iReal < GetColumnCount(); iReal++)
            {
                COL_INFO* pci = (COL_INFO*)DSA_GetItemPtr(_hdsaColumns, iReal);
                pci->csFlags &= ~SHCOLSTATE_ONBYDEFAULT;
            }

            for (UINT i = 0; i < cStates; i++)
            {
                DWORD dw;
                DSA_GetItem(_hdsaColumnStates, i, &dw);
                SetColumnState(dw, SHCOLSTATE_ONBYDEFAULT, SHCOLSTATE_ONBYDEFAULT);
            }
        }
    }

    return S_OK;
}

// When Loading or Saving from the View State Stream

HRESULT CViewState::LoadFromStream(CDefView* pdv, IStream* pstm)
{
    ULONG cbRead;
    DVSAVEHEADER_COMBO dv;
    ULARGE_INTEGER libStartPos;
    LARGE_INTEGER dlibMove  = {0};

    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libStartPos);

    // See what format the persisted view is in:
    HRESULT hr = pstm->Read(&dv, sizeof(dv), &cbRead);

    if (SUCCEEDED(hr) &&
        sizeof(DVSAVEHEADER_COMBO) == cbRead &&
        dv.dvSaveHeader.cbSize == sizeof(WIN95HEADER) &&
        dv.dvSaveHeader.cbColOffset == 0 &&
        dv.dvSaveHeaderEx.dwSignature == IE4HEADER_SIGNATURE &&
        dv.dvSaveHeaderEx.cbSize >= sizeof(IE4HEADER))
    {
        InitFromHeader(&dv);

        if (dv.dvSaveHeaderEx.wVersion < IE4HEADER_VERSION)
        {
            // We used to store szExtended in here -- not any more
            dv.dvSaveHeaderEx.dwUnused = 0;
        }

        if (dv.dvSaveHeaderEx.cbColOffset >= sizeof(dv))
        {
            dlibMove.QuadPart = libStartPos.QuadPart + dv.dvSaveHeaderEx.cbColOffset;
            hr = pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hr))
            {
                hr = LoadColumns(pdv, pstm);
            }
        }

        if (SUCCEEDED(hr))
        {
            dlibMove.QuadPart = libStartPos.QuadPart + dv.dvSaveHeader.cbPosOffset;
            hr = pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

            if (SUCCEEDED(hr))
            {
                LoadPositionBlob(pdv, dv.dvSaveHeaderEx.cbStreamSize, pstm);
            }
        }
    }

    return S_OK;
}

void SetSize(ULARGE_INTEGER libCurPosition, IStream* pstm)
{
    LARGE_INTEGER dlibMove;
    
    dlibMove.QuadPart = libCurPosition.QuadPart;
    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    pstm->SetSize(libCurPosition);
}

DWORD CViewState::_GetStreamSize(IStream* pstm)
{
    DWORD dwRet = 0;

    ULARGE_INTEGER uli;
    if (SUCCEEDED(IStream_Size(pstm, &uli)))
    {
        if (0 == uli.HighPart)
        {
            dwRet = uli.LowPart;
        }
    }

    return dwRet;
}

HRESULT CViewState::SaveToStream(CDefView* pdv, IStream* pstm)
{
    ULONG ulWrite;
    DVSAVEHEADER_COMBO dv = {0};
    LARGE_INTEGER dlibMove = {0};
    ULARGE_INTEGER libCurPosition;

    // Get the current info.
    Sync(pdv, FALSE);

    // Position the stream right after the headers, and save the starting
    // position at the same time
    dlibMove.QuadPart = sizeof(dv);
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPosition);

    // Avoid 2 calls to seek by just subtracting
    libCurPosition.QuadPart -= sizeof(dv);

    // Save column order and size info
    HRESULT hr = SaveColumns(pdv, pstm);
    if (SUCCEEDED(hr))
    {
        dv.dvSaveHeader.cbSize = sizeof(dv.dvSaveHeader);

        // We save the view mode to determine if the scroll positions are
        // still valid on restore
        dv.dvSaveHeader.ViewMode = _ViewMode;
        dv.dvSaveHeader.ptScroll.x = _ptScroll.x;
        dv.dvSaveHeader.ptScroll.y = _ptScroll.y;
        dv.dvSaveHeader.dvState.lParamSort = (LONG)_lParamSort;
        dv.dvSaveHeader.dvState.iDirection = _iDirection;
        dv.dvSaveHeader.dvState.iLastColumnClick = _iLastColumnClick;

        // dvSaveHeaderEx.cbColOffset holds the true offset.
        // Win95 gets confused when cbColOffset points to the new
        // format. Zeroing this out tells Win95 to use default widths
        // (after uninstall of ie40).
        //
        // dv.dvSaveHeader.cbColOffset = 0;

        dv.dvSaveHeaderEx.dwSignature = IE4HEADER_SIGNATURE;
        dv.dvSaveHeaderEx.cbSize = sizeof(dv.dvSaveHeaderEx);
        dv.dvSaveHeaderEx.wVersion = IE4HEADER_VERSION;

        ULARGE_INTEGER libPosPosition;

        // Save the Position Information
        dlibMove.QuadPart = 0;
        pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libPosPosition);
        dv.dvSaveHeaderEx.cbColOffset = sizeof(dv);
        dv.dvSaveHeader.cbPosOffset = (USHORT)(libPosPosition.QuadPart - libCurPosition.QuadPart);

        // Save potision info, currently stream is positioned immediately after column info
        hr = SavePositionBlob(pdv, pstm);
        if (SUCCEEDED(hr))
        {
            ULARGE_INTEGER libEndPosition;
            // Win95 expects cbPosOffset to be at the end of the stream --
            // don't change it's value and never store anything after
            // the position information.

            // Calculate size of total information saved.
            // This is needed when we read the stream.
            dlibMove.QuadPart = 0;
            if (SUCCEEDED(pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libEndPosition)))
            {
                dv.dvSaveHeaderEx.cbStreamSize = (DWORD)(libEndPosition.QuadPart - libCurPosition.QuadPart);
            }

            // Now save the header information
            dlibMove.QuadPart = libCurPosition.QuadPart;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
            hr = pstm->Write(&dv, sizeof(dv), &ulWrite);

            if (FAILED(hr) || ulWrite != sizeof(dv))
            {
                SetSize(libCurPosition, pstm);
                hr = S_OK;
            }

            // Make sure we save all information written so far
            libCurPosition.QuadPart += dv.dvSaveHeaderEx.cbStreamSize;
        }
    }

    return hr;
}

HRESULT CViewState::SaveToPropertyBag(CDefView* pdv, IPropertyBag* ppb)
{
    // Get the current info.
    Sync(pdv, FALSE);

    SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_MODE, _ViewMode);
    SHPropertyBag_WritePOINTSScreenRes(ppb, VS_PROPSTR_SCROLL, &_ptScroll);
    SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_SORT, static_cast<DWORD>(_lParamSort)); 
    SHPropertyBag_WriteInt(ppb, VS_PROPSTR_SORTDIR, _iDirection); 
    SHPropertyBag_WriteInt(ppb, VS_PROPSTR_COL, _iLastColumnClick);
    
    IStream* pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        if (S_OK == SaveColumns(pdv, pstm))
        {
            SHPropertyBag_WriteStream(ppb, VS_PROPSTR_COLINFO, pstm);
        }
        else
        {
            SHPropertyBag_Delete(ppb, VS_PROPSTR_COLINFO);
        }
        pstm->Release();
    }

    pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        if (S_OK == SavePositionBlob(pdv, pstm))
        {
            SHPropertyBag_WriteStreamScreenRes(ppb, VS_PROPSTR_ITEMPOS, pstm);
        }
        else
        {
            SHPropertyBag_DeleteScreenRes(ppb, VS_PROPSTR_ITEMPOS);
        }
        pstm->Release();
    }

    return S_OK;
}

HRESULT CViewState::LoadFromPropertyBag(CDefView* pdv, IPropertyBag* ppb)
{
    SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_MODE, &_ViewMode, FVM_ICON);
    SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_SORT, reinterpret_cast<DWORD*>(&_lParamSort), 0);
    SHPropertyBag_ReadIntDef(ppb, VS_PROPSTR_SORTDIR, &_iDirection, 1); 
    SHPropertyBag_ReadIntDef(ppb, VS_PROPSTR_COL, &_iLastColumnClick, -1); 

    if (FAILED(SHPropertyBag_ReadPOINTSScreenRes(ppb, VS_PROPSTR_SCROLL, &_ptScroll)))
    {
        _ptScroll.x = _ptScroll.y = 0;
    }

    IStream* pstm;
    if (SUCCEEDED(SHPropertyBag_ReadStream(ppb, VS_PROPSTR_COLINFO, &pstm)))
    {
        LoadColumns(pdv, pstm);
        pstm->Release();
    }

    if (SUCCEEDED(SHPropertyBag_ReadStreamScreenRes(ppb, VS_PROPSTR_ITEMPOS, &pstm)))
    {
        LoadPositionBlob(pdv, _GetStreamSize(pstm), pstm);
        pstm->Release();
    }

    return S_OK;
}

HDSA DSA_CreateFromStream(DWORD cbSize, int cItems, IStream* pstm)
{
    HDSA hdsa = DSA_Create(cbSize, cItems);
    if (hdsa)
    {
        BYTE* pb = (BYTE*)LocalAlloc(LPTR, cbSize);
        if (pb)
        {
            BOOL fFailedToRead = FALSE;
            ULONG cbRead;
            while (cItems--)
            {
                if (SUCCEEDED(pstm->Read(pb, cbSize, &cbRead) && cbRead == cbSize))
                {
                    DSA_AppendItem(hdsa, pb);
                }
                else
                {
                    fFailedToRead = TRUE;
                }
            }
            LocalFree(pb);

            if (fFailedToRead)
            {
                // The stream is probrably corrupt.
                DSA_Destroy(hdsa);
                hdsa = NULL;
            }
        }
    }

    return hdsa;
}

// When Loading from a View Callback provided stream.
HRESULT CViewState::LoadColumns(CDefView* pdv, IStream* pstm)
{
    // Read the extended View state header
    HRESULT hr;
    ULONG cbRead;
    VIEWSTATEHEADER vsh;
    ULARGE_INTEGER libStartPos;
    LARGE_INTEGER dlibMove  = {0};

    // Store off the current stream pointer. If we are called directly, this is probrably Zero,
    // However this method gets called from ::Load, so this it definitly not zero in that case.
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libStartPos);

    // The VSH struct has many "Substructs" indicating the version of ths struct we are reading.
    // There is probrably a more efficient mechanism of version discovery, but this is easiest to read and understand.
    hr = pstm->Read(&vsh.Version1, sizeof(vsh.Version1), &cbRead);
    
    if (SUCCEEDED(hr) &&
        sizeof(vsh.Version1) == cbRead &&                       // Fail if we didn't read enough
        VIEWSTATEHEADER_SIGNATURE == vsh.Version1.dwSignature)  // Fail if the signature is bogus
    {
        if (vsh.Version1.uVersion >= VIEWSTATEHEADER_VERSION_1)
        {
            if (vsh.Version1.uCols > 0)
            {
                // Load the Column Ordering
                dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version1.uOffsetColOrder;
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                if (_hdsaColumnOrder)   
                    DSA_Destroy(_hdsaColumnOrder);
                _hdsaColumnOrder = DSA_CreateFromStream(sizeof(int), vsh.Version1.uCols, pstm);
                // Load the Column Widths
                dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version1.uOffsetWidths;
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                if (_hdsaColumnWidths) 
                    DSA_Destroy(_hdsaColumnWidths);
                _hdsaColumnWidths = DSA_CreateFromStream(sizeof(USHORT), vsh.Version1.uCols, pstm);
            }


            if (vsh.Version1.uVersion >= VIEWSTATEHEADER_VERSION_2 &&
                vsh.Version1.uCols > 0)
            {
                DWORD dwRead;

                // Seek to read the rest of the header
                dlibMove.QuadPart = libStartPos.QuadPart + sizeof(vsh.Version1);
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                hr = pstm->Read(&vsh.Version2, sizeof(vsh.Version2), &cbRead);
                
                if (SUCCEEDED(hr) &&
                    sizeof(vsh.Version2) == cbRead &&
                    vsh.Version2.uOffsetColStates)
                {
                    // Load the Column States
                    dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version2.uOffsetColStates;
                    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                    // This one is funky: There is a terminating sentinal....
                    if (_hdsaColumnStates) 
                        DSA_Destroy(_hdsaColumnStates);

                    _hdsaColumnStates = DSA_Create(sizeof(DWORD), 5);
                    if (_hdsaColumnStates)
                    {
                        do
                        {
                            if (SUCCEEDED(pstm->Read(&dwRead, sizeof(DWORD), &cbRead)) && 
                                cbRead == sizeof(DWORD) &&
                                dwRead != 0xFFFFFFFF)
                            {
                                DSA_AppendItem(_hdsaColumnStates, &dwRead);
                            }
                            else
                            {
                                break;
                            }
                        }
                        while (dwRead != 0xFFFFFFFF);
                    }
                }
            }

            if (vsh.Version1.uVersion >= VIEWSTATEHEADER_VERSION_3)
            {
                // Seek to read the rest of the header
                dlibMove.QuadPart = libStartPos.QuadPart + sizeof(vsh.Version1) + sizeof(vsh.Version2);
                pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                hr = pstm->Read(&vsh.Version3, sizeof(vsh.Version3), &cbRead);
                if (SUCCEEDED(hr) &&
                    sizeof(vsh.Version3) == cbRead &&
                    vsh.Version3.uOffsetGroup)
                {
                    GROUP_PERSIST gp;
                    dlibMove.QuadPart = libStartPos.QuadPart + vsh.Version3.uOffsetGroup;
                    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

                    hr = pstm->Read(&gp, sizeof(gp), &cbRead);
                    if (SUCCEEDED(hr) &&
                        sizeof(gp) == cbRead)
                    {
                        _guidGroupID = gp.guidGroupID;
                        _scidDetails = gp.scidDetails;
                    }
                }
                
                _fFirstViewed = FALSE;
            }

            /////////////////////////////////////////////////////////////////////////////////////
            //                    *****             NEW Data             *****
            // 1) Add a version to the VIEWSTATEHEADER
            // 2) Add a version to VIEWSTATEHEADER_VERSION_*
            // 3) Check that version here
            /////////////////////////////////////////////////////////////////////////////////////
        }
    }

    return hr;
}

HRESULT CViewState::SaveColumns(CDefView* pdv, IStream* pstm)
{
    HRESULT hr;
    USHORT uOffset;
    VIEWSTATEHEADER vsh = {0};
    ULARGE_INTEGER libStartPos = {0};
    LARGE_INTEGER dlibMove  = {0};

    // No point in persisting, if there aren't any columns around.
    // this is true for folders that are just opened and closed
    if (!pdv->_psd && !pdv->_pshf2 && !pdv->HasCB())
    {
        return S_FALSE;
    }

    // First, we persist a known bad quantity, just in case we wax the stream
    pstm->Seek(g_li0, STREAM_SEEK_CUR, &libStartPos);
    hr = pstm->Write(&vsh, sizeof(vsh), NULL);

    if (SUCCEEDED(hr))
    {
        vsh.Version1.dwSignature = VIEWSTATEHEADER_SIGNATURE;
        vsh.Version1.uVersion = VIEWSTATEHEADER_VERSION_CURRENT;
        vsh.Version1.uCols = _hdsaColumnOrder? (UINT) DSA_GetItemCount(_hdsaColumnOrder) : 0;

        uOffset = sizeof(VIEWSTATEHEADER);

        // No point in persisting if we don't have any columns
        if (vsh.Version1.uCols)
        {

            // Note- dependent on DSA storing data internally as byte-packed.
            if (_hdsaColumnOrder)
            {
                vsh.Version1.uOffsetColOrder = uOffset;
                uOffset += (USHORT)(sizeof(UINT) * DSA_GetItemCount(_hdsaColumnOrder));
                hr = pstm->Write(DSA_GetItemPtr(_hdsaColumnOrder, 0),  sizeof(UINT)   * DSA_GetItemCount(_hdsaColumnOrder), NULL);
            }

            if (_hdsaColumnWidths && SUCCEEDED(hr))
            {
                vsh.Version1.uOffsetWidths = uOffset;
                uOffset += (USHORT)(sizeof(USHORT) * DSA_GetItemCount(_hdsaColumnWidths));
                hr = pstm->Write(DSA_GetItemPtr(_hdsaColumnWidths, 0), sizeof(USHORT) * DSA_GetItemCount(_hdsaColumnWidths), NULL);
            }

            if (_hdsaColumnStates && SUCCEEDED(hr))
            {
                vsh.Version2.uOffsetColStates = uOffset; 
                uOffset += (USHORT)(sizeof(DWORD) *  DSA_GetItemCount(_hdsaColumnStates));
                pstm->Write(DSA_GetItemPtr(_hdsaColumnStates, 0), sizeof(DWORD)  * DSA_GetItemCount(_hdsaColumnStates), NULL);
            }
        }

        if (SUCCEEDED(hr))
        {
            GROUP_PERSIST gp = {0};
            vsh.Version3.uOffsetGroup = uOffset;
            uOffset += sizeof(GROUP_PERSIST);

            if (pdv->_fGroupView)
            {
                gp.guidGroupID = _guidGroupID;
                gp.scidDetails = _scidDetails;
            }

            hr = pstm->Write(&gp, sizeof(gp), NULL);
        }
    
        /////////////////////////////////////////////////////////////////////////////////////
        //                    *****             NEW Data             *****
        // 1) Add a version to the VIEWSTATEHEADER
        // 2) Add a version to VIEWSTATEHEADER_VERSION_*
        // 3) Add a "Loader" for your value
        // 4) Set the offset to uOffset.
        // 5) Write your data.
        // 6) Update the running total of dwOffset.
        /////////////////////////////////////////////////////////////////////////////////////

        dlibMove.QuadPart = libStartPos.QuadPart;

        // Store off the current position
        pstm->Seek(g_li0, STREAM_SEEK_CUR, &libStartPos);

        // Move to the beginning
        pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

        // Write out the correct header
        hr = pstm->Write(&vsh, sizeof(vsh), NULL);
        if (SUCCEEDED(hr))
        {
            // Reset the current pos
            dlibMove.QuadPart = libStartPos.QuadPart;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL); 
        }
    }

    return hr;
}

BOOL CViewState::AppendColumn(UINT uCol, USHORT uWidth, INT uOrder)
{
    if (_hdsaColumnOrder == NULL || 
        _hdsaColumnWidths == NULL)
    {
        return FALSE;
    }

    // Slide every index above this one up
    for (INT u = 0; u < DSA_GetItemCount(_hdsaColumnOrder); u++)
    {
        UINT *p = (UINT *) DSA_GetItemPtr(_hdsaColumnOrder, u);
        if (!p)
            break; // safety...
        if (*p >= uCol)
            (*p)++;
    }

    DSA_AppendItem(_hdsaColumnWidths, &uWidth);
    DSA_AppendItem(_hdsaColumnOrder, &uOrder);
    // maybe we should store column ordering as absolute numbers
    return TRUE;
}

BOOL CViewState::RemoveColumn(UINT uCol)
{
    if (_hdsaColumnWidths == NULL || 
        _hdsaColumnWidths == NULL)
    {
        return FALSE;
    }

    if ((int)uCol >= DSA_GetItemCount(_hdsaColumnWidths))
        return FALSE;
    // Slide every index above this one down
    for (INT u = 0; u < DSA_GetItemCount(_hdsaColumnOrder); u++)
    {
        UINT *p = (UINT *) DSA_GetItemPtr(_hdsaColumnOrder, u);
        if (!p)
            break; // safety...
        if (*p > uCol)
            (*p)--;
    }

    DSA_DeleteItem(_hdsaColumnWidths, uCol);
    DSA_DeleteItem(_hdsaColumnOrder, uCol);
    return TRUE;
}

UINT CViewState::GetColumnWidth(UINT uCol, UINT uDefWid)
{
    if (!_hdsaColumnWidths)
        return uDefWid;

    USHORT uWidth = 0;
    if (uCol < (UINT) DSA_GetItemCount(_hdsaColumnWidths))
    {
        DSA_GetItem(_hdsaColumnWidths, uCol, &uWidth);
    }
    return uWidth ? uWidth : uDefWid;        // disallow zero width columns
}

BOOL CViewState::SyncColumnOrder(CDefView* pdv, BOOL fSetListViewState)
{
    UINT cCols = pdv->_GetHeaderCount();
    if (fSetListViewState)
    {
        if (!_hdsaColumnOrder)
            return FALSE;

        if (cCols != (UINT) DSA_GetItemCount(_hdsaColumnOrder))
        {
            // this is a normal case if a folder is opened and there is no saved state. no need to spew.
            return TRUE;
        }

        UINT *pCols = (UINT *)LocalAlloc(LPTR, cCols * sizeof(*pCols));
        if (pCols)
        {
            for (UINT u = 0; u < cCols; u++)
            {
                DSA_GetItem(_hdsaColumnOrder, u, pCols + u);
            }

            ListView_SetColumnOrderArray(pdv->_hwndListview, cCols, pCols);
            LocalFree(pCols);
        }
    }
    else
    {
        BOOL bDefaultOrder = TRUE;
        if (cCols)
        {
            if (!_hdsaColumnOrder)
                _hdsaColumnOrder = DSA_Create(sizeof(UINT), 6);

            if (_hdsaColumnOrder)
            {
                UINT *pCols = (UINT *)LocalAlloc(LPTR, cCols * sizeof(*pCols));
                if (pCols)
                {
                    ListView_GetColumnOrderArray(pdv->_hwndListview, cCols, pCols);

                    DSA_DeleteAllItems(_hdsaColumnOrder);
                    for (UINT u = 0; u < cCols; u++)
                    {
                        DSA_AppendItem(_hdsaColumnOrder, &pCols[u]);
                        if (pCols[u] != u)
                        {
                            bDefaultOrder = FALSE;
                        }
                    }

                    LocalFree(pCols);
                }
            }
        }
        return bDefaultOrder;
    }

    return TRUE;
}

BOOL CViewState::SyncColumnWidths(CDefView* pdv, BOOL fSetListViewState)
{
    UINT cCols = pdv->_GetHeaderCount();
    if (fSetListViewState)
    {
        return FALSE;
    }
    else
    {
        USHORT us;
        LV_COLUMN lvc;
        BOOL bOk = TRUE;
    
        if (!cCols)
            return TRUE;

        HDSA dsaNewWidths = DSA_Create(sizeof(USHORT), cCols);
        if (!dsaNewWidths)
            return TRUE;

        for (UINT u = 0; u < cCols && bOk; ++u)
        {
            lvc.mask = LVCF_WIDTH;
            bOk = ListView_GetColumn(pdv->_hwndListview, u, &lvc);
            us = (USHORT) lvc.cx;    // make sure its a short
            DSA_AppendItem(dsaNewWidths, &us);
            // TraceMsg(TF_DEFVIEW, "  saving col %d width of %d", u, us);
        }

        if (bOk)
        {
            if (_hdsaColumnWidths)
                DSA_Destroy(_hdsaColumnWidths);
            _hdsaColumnWidths = dsaNewWidths;
        }
        else
            DSA_Destroy(dsaNewWidths);
        return !bOk;
    }
}

BOOL CViewState::SyncColumnStates(CDefView* pdv, BOOL fSetListViewstate)
{
    if (fSetListViewstate)
    {
        return FALSE;
    }
    else
    {
        // Save off Column States
        if (_hdsaColumnStates)
        {
            DSA_Destroy(_hdsaColumnStates);
            _hdsaColumnStates = NULL;
        }

        UINT cCol = GetColumnCount();

        if (cCol)
        {
            DWORD i;
            _hdsaColumnStates = DSA_Create(sizeof(DWORD), 5);
            if (_hdsaColumnStates)
            {
                for (i = 0; i < cCol; i++)
                {
                    if (pdv->_IsDetailsColumn(i))
                        DSA_AppendItem(_hdsaColumnStates, &i);
                }
                i = 0xFFFFFFFF;     // Terminating Sentinal
                DSA_AppendItem(_hdsaColumnStates,&i);
            }
        }
    }

    return TRUE;
}

// Syncronizes ListView with the current View State. 
// TRUE means take the view state object and set it into the listview.
HRESULT CViewState::Sync(CDefView* pdv, BOOL fSetListViewState)
{
    SyncColumnWidths(pdv, fSetListViewState);
    SyncColumnOrder(pdv, fSetListViewState);
    SyncColumnStates(pdv, fSetListViewState);

    if (fSetListViewState)
    {
        // Only do this the first time.
        if (pdv->_pcat == NULL)
        {
            if (_fFirstViewed)
            {
                // See if the desktop.ini specifies one
                pdv->_LoadCategory(&_guidGroupID);

                if (IsEqualGUID(_guidGroupID, GUID_NULL))
                {
                    ICategoryProvider* pcp;
                    if (SUCCEEDED(pdv->_pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp))))
                    {
                        pcp->GetDefaultCategory(&_guidGroupID, &_scidDetails);
                        pcp->Release();
                    }
                }
            }

            if (!IsEqualGUID(_guidGroupID, GUID_NULL) || !IsEqualGUID(_scidDetails.fmtid, GUID_NULL))
                pdv->_CategorizeOnGUID(&_guidGroupID, &_scidDetails);
        }

        // this is only needed to sort the items who's positions are not known
        // it would be nice to optimize this case and only sort then
        pdv->_Sort();

        SyncPositions(pdv);
    }
    else
    {
        // Take what Listview has, and save it to me.

        _ViewMode = pdv->_fs.ViewMode;
        _ptScroll.x = (SHORT) GetScrollPos(pdv->_hwndListview, SB_HORZ);
        _ptScroll.y = (SHORT) GetScrollPos(pdv->_hwndListview, SB_VERT);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\viewstate.h ===
#ifndef _DVViewState_h
#define _DVViewState_h

// Forwards
class CDefView;

typedef struct
{
    POINT pt;
    ITEMIDLIST idl;
} VIEWSTATE_POSITION;

typedef struct
{
    // NOTE: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG lParamSort;

    int iDirection;
    int iLastColumnClick;
} WIN95SAVESTATE;

typedef struct 
{
    WORD          cbSize;
    WORD          wUnused; // junk on stack at this location has been saved in the registry since Win95... bummer
    DWORD         ViewMode;
    POINTS        ptScroll;
    WORD          cbColOffset;
    WORD          cbPosOffset;
    WIN95SAVESTATE   dvState;

} WIN95HEADER;

// Even though we don't currently store anything we care
// about in this structure relating to the view state,
// the cbStreamSize value fixes a bug in Win95 where we
// read to the end of the stream instead of just reading
// in the same number of bytes we wrote out.
//
typedef struct
{
    DWORD       dwSignature;    // DVSAVEHEADEREX_SIGNATURE
    WORD        cbSize;         // size of this structure, in bytes
    WORD        wVersion;       // DVSAVEHEADEREX_VERSION
    DWORD       cbStreamSize;   // size of all info saved, in bytes
    DWORD       dwUnused;       // used to be SIZE szExtended (ie4 beta1)
    WORD        cbColOffset;    // overrides DVSAVEHEADER.cbColOffset
    WORD        wAlign;
} IE4HEADER;

typedef struct 
{
    WIN95HEADER    dvSaveHeader;
    IE4HEADER  dvSaveHeaderEx;
} DVSAVEHEADER_COMBO;

#define IE4HEADER_SIGNATURE 0xf0f0f0f0 // don't conflict with CCOLSHEADER_SIGNATURE
#define IE4HEADER_VERSION 3 // for easy versioning

#define VIEWSTATEHEADER_SIGNATURE 0xfddfdffd
#define VIEWSTATEHEADER_VERSION_1 0x0C
#define VIEWSTATEHEADER_VERSION_2 0x0E
#define VIEWSTATEHEADER_VERSION_3 0x0f
#define VIEWSTATEHEADER_VERSION_CURRENT VIEWSTATEHEADER_VERSION_3

typedef struct
{
    GUID guidGroupID;
    SHCOLUMNID scidDetails; 
} GROUP_PERSIST;

typedef struct
{
    struct
    {
        DWORD  dwSignature;
        USHORT uVersion; // 0x0c == IE4, 0x0e == IE5
        USHORT uCols;
        USHORT uOffsetWidths;
        USHORT uOffsetColOrder;
    } Version1;

    struct
    {
        USHORT uOffsetColStates;
    } Version2;

    struct
    {
        USHORT uOffsetGroup;
    } Version3;
} VIEWSTATEHEADER;


class CViewState
{
    void InitFromHeader(DVSAVEHEADER_COMBO* pdv);
    void LoadPositionBlob(CDefView* pdv, DWORD cbSizeofStream, IStream* pstm);
    HRESULT SavePositionBlob(CDefView* pdv, IStream* pstm);
    BOOL SyncColumnWidths(CDefView* pdv, BOOL fSetListViewState);
    BOOL SyncColumnStates(CDefView* pdv, BOOL fSetListViewstate);
    BOOL SyncPositions(CDefView* pdv);
    static int CALLBACK _SavedItemCompare(void *p1, void *p2, LPARAM lParam);
    DWORD _GetStreamSize(IStream* pstm);
public:
    // Save State
    LPARAM  _lParamSort;
    int     _iDirection;
    int     _iLastColumnClick;
    DWORD   _ViewMode;
    POINTS  _ptScroll;

    HDSA    _hdsaColumnOrder;
    HDSA    _hdsaColumnWidths;
    HDSA    _hdsaColumnStates;
    HDSA    _hdsaColumns;
    HDPA    _hdpaItemPos;
    BYTE*   _pbPositionData;
    GUID    _guidGroupID;
    SHCOLUMNID _scidDetails; 

    BOOL    _fFirstViewed;

    CViewState();
    ~CViewState();

    // When initializing a new DefView, see if we can 
    // propogate information from the previous one.
    void InitFromPreviousView(IUnknown* pPrevView);
    void InitWithDefaults(CDefView* pdv);
    void GetDefaults(CDefView* pdv, LPARAM* plParamSort, int* piDirection, int* piLastColumnClick);
    HRESULT InitializeColumns(CDefView* pdv);

    BOOL AppendColumn(UINT uCol, USHORT uWidth, INT uOrder);
    BOOL RemoveColumn(UINT uCol);
    UINT GetColumnWidth(UINT uCol, UINT uDefaultWidth);
    UINT GetColumnCount();

    // Column Helpers.
    DWORD GetColumnState(UINT uCol);
    DWORD GetTransientColumnState(UINT uCol);
    void SetColumnState(UINT uCol, DWORD dwMask, DWORD dwState);
    void SetTransientColumnState(UINT uCol, DWORD dwMask, DWORD dwState);
    LPTSTR GetColumnName(UINT uCol);
    int GetColumnFormat(UINT uCol);
    UINT GetColumnCharCount(UINT uCol);

    // When Loading or Saving from the View State Stream
    HRESULT SaveToStream(CDefView* pdv, IStream* pstm);
    HRESULT LoadFromStream(CDefView* pdv, IStream* pstm);
    
    HRESULT SaveToPropertyBag(CDefView* pdv, IPropertyBag* ppb);
    HRESULT LoadFromPropertyBag(CDefView* pdv, IPropertyBag* ppb);

    // When Loading from a View Callback provided stream.
    HRESULT LoadColumns(CDefView* pdv, IStream* pstm);
    HRESULT SaveColumns(CDefView* pdv, IStream* pstm);

    // Syncronizes ListView with the current View State. 
    // TRUE means take the view state object and set it into the listview.
    HRESULT Sync(CDefView* pdv, BOOL fSetListViewState);
    void ClearPositionData();
    
    // Needs to be called at the time of CDefView::AddColumns
    BOOL SyncColumnOrder(CDefView* pdv, BOOL fSetListViewState);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\viewcomm.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "fstreex.h"
#include "idlcomm.h"

// returns SHAlloc() (COM Task Allocator) memory

LPTSTR SHGetCaption(HIDA hida)
{
    UINT idFormat;
    LPTSTR pszCaption = NULL;
    LPITEMIDLIST pidl;
    
    switch (HIDA_GetCount(hida))
    {
    case 0:
        return NULL;
        
    case 1:
        idFormat = IDS_ONEFILEPROP;
        break;
        
    default:
        idFormat = IDS_MANYFILEPROP;
        break;
    }
    
    pidl = HIDA_ILClone(hida, 0);
    if (pidl)
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName), NULL)))
        {
            TCHAR szTemplate[40];
            UINT uLen = LoadString(HINST_THISDLL, idFormat, szTemplate, ARRAYSIZE(szTemplate)) + lstrlen(szName) + 1;
            
            pszCaption = SHAlloc(uLen * SIZEOF(TCHAR));
            if (pszCaption)
            {
                wsprintf(pszCaption, szTemplate, (LPTSTR)szName);
            }
        }
        ILFree(pidl);
    }
    return pszCaption;
}

// This is not folder specific, and could be used for other background
// properties handlers, since all it does is bind to the parent of a full pidl
// and ask for properties
STDAPI SHPropertiesForPidl(HWND hwndOwner, LPCITEMIDLIST pidlFull, LPCTSTR pszParams)
{
    if (!SHRestricted(REST_NOVIEWCONTEXTMENU)) 
    {
        IContextMenu *pcm;
        HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFull, hwndOwner, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            CHAR szParameters[MAX_PATH];
            CMINVOKECOMMANDINFOEX ici = {
                SIZEOF(CMINVOKECOMMANDINFOEX),
                0L,
                hwndOwner,
                "properties",
                szParameters,
                NULL, SW_SHOWNORMAL
            };

            if (pszParams)
                SHUnicodeToAnsi(pszParams, szParameters, ARRAYSIZE(szParameters));
            else
                ici.lpParameters = NULL;

            ici.fMask |= CMIC_MASK_UNICODE;
            ici.lpVerbW = c_szProperties;
            ici.lpParametersW = pszParams;

            // record if shift or control was being held down
            SetICIKeyModifiers(&ici.fMask);

            hr = pcm->lpVtbl->InvokeCommand(pcm, (LPCMINVOKECOMMANDINFO)&ici);
            pcm->lpVtbl->Release(pcm);
        }

        return hr;
    }
    else 
        return E_ACCESSDENIED;
}

BOOL _LoadErrMsg(UINT idErrMsg, LPTSTR pszErrMsg, DWORD err)
{
    TCHAR szTemplate[256];
    if (LoadString(HINST_THISDLL, idErrMsg, szTemplate, ARRAYSIZE(szTemplate)))
    {
        wsprintf(pszErrMsg, szTemplate, err);
        return TRUE;
    }
    return FALSE;
}

BOOL _VarArgsFormatMessage( LPTSTR lpBuffer, UINT cchBuffer, DWORD err, ... )
{
    BOOL fSuccess;

    va_list ArgList;

    va_start(ArgList, err);
    fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                NULL, err, 0, lpBuffer, cchBuffer, &ArgList);
    va_end(ArgList);
    return fSuccess;
}

//
// Paremeters:
//  hwndOwner  -- owner window
//  idTemplate -- specifies template (e.g., "Can't open %2%s\n\n%1%s")
//  err        -- specifies the WIN32 error code
//  pszParam   -- specifies the 2nd parameter to idTemplate
//  dwFlags    -- flags for MessageBox
//

STDAPI_(UINT) SHSysErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate,
                                   DWORD err, LPCTSTR pszParam, UINT dwFlags)
{
    BOOL fSuccess;
    UINT idRet = IDCANCEL;
    TCHAR szErrMsg[MAX_PATH * 2];

    //
    // FormatMessage is bogus, we don't know what to pass to it for %1,%2,%3,...
    // For most messages, lets pass the path as %1 and "" as everything else
    // For ERROR_MR_MID_NOT_FOUND (something nobody is ever supposed to see)
    // we will pass the path as %2 and everything else as "".
    //
    if (err == ERROR_MR_MID_NOT_FOUND)
    {
        fSuccess = _VarArgsFormatMessage(szErrMsg,ARRAYSIZE(szErrMsg),
                       err,c_szNULL,pszParam,c_szNULL,c_szNULL,c_szNULL);
    } 
    else 
    {
        fSuccess = _VarArgsFormatMessage(szErrMsg,ARRAYSIZE(szErrMsg),
                       err,pszParam,c_szNULL,c_szNULL,c_szNULL,c_szNULL);
    }

    if (fSuccess || _LoadErrMsg(IDS_ENUMERR_FSGENERIC, szErrMsg, err))
    {
        if (idTemplate==IDS_SHLEXEC_ERROR && (pszParam == NULL || StrStr(szErrMsg, pszParam)))
        {
            idTemplate = IDS_SHLEXEC_ERROR2;
        }

        idRet = ShellMessageBox(HINST_THISDLL, hwndOwner,
                MAKEINTRESOURCE(idTemplate),
                pszTitle, dwFlags, szErrMsg, pszParam);
    }

    return idRet;
}


STDAPI_(UINT) SHEnumErrorMessageBox(HWND hwnd, UINT idTemplate, DWORD err, LPCTSTR pszParam, BOOL fNet, UINT dwFlags)
{
    UINT idRet = IDCANCEL;
    TCHAR szErrMsg[MAX_PATH * 3];

    if (hwnd == NULL)
        return idRet;

    switch(err)
    {
    case WN_SUCCESS:
    case WN_CANCEL:
        return IDCANCEL;        // Don't retry

    case ERROR_OUTOFMEMORY:
        return IDABORT;         // Out of memory!
    }

    if (fNet)
    {
        TCHAR* pszMessageString;
        TCHAR szTitle[80];
        TCHAR szProvider[256];  // We don't use it.
        DWORD dwErrSize = ARRAYSIZE(szErrMsg);       // (DavePl) I expect a cch here, but no docs, could be cb
        DWORD dwProvSize = ARRAYSIZE(szProvider);

        szErrMsg[0] = 0;
        MultinetGetErrorText(szErrMsg, &dwErrSize, szProvider, &dwProvSize);

        if (szErrMsg[0] == 0)
            _LoadErrMsg(IDS_ENUMERR_NETGENERIC, szErrMsg, err);

        if (GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)))
        {
            pszMessageString = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(idTemplate), szErrMsg, pszParam);

            if (pszMessageString)
            {
                idRet = SHMessageBoxHelp(hwnd, pszMessageString, szTitle, dwFlags, HRESULT_FROM_WIN32(err), NULL, 0);
                LocalFree(pszMessageString);
            }
            else
            {
                // Out of memory!
                return IDABORT;
            }
        }
    }
    else
    {
        idRet = SHSysErrorMessageBox(hwnd, NULL, idTemplate, err, pszParam, dwFlags);
    }
    return idRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\views.h ===
#ifndef SHELL32_VIEWS_INC
#define SHELL32_VIEWS_INC

#include "idlcomm.h"
#include "pidl.h"


// Some constants for folder callbacks
#define DEFVIEW_FVM_MANY_CUTOFF 50
#define DEFVIEW_FVM_FEW_CUTOFF  25

// VIEWCOMM.C
STDAPI_(LPTSTR) SHGetCaption(HIDA hida);
STDAPI SHPropertiesForPidl(HWND hwnd, LPCITEMIDLIST pidlFull, LPCTSTR lpParameters);

// RUNDLL32.C
STDAPI_(BOOL) SHRunDLLProcess(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow, UINT idStr, BOOL fRunAsNewUser);
STDAPI_(BOOL) SHRunDLLThread(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow);

// CPLOBJ.C
STDAPI_(BOOL) SHRunControlPanelEx(LPCTSTR pszOrigCmdLine, HWND hwnd, BOOL fRunAsNewUser);


// REGITMS.C

typedef struct
{
    const CLSID * pclsid;
    UINT    uNameID;
    LPCTSTR pszIconFile;
    int     iDefIcon;
    BYTE    bOrder;
    DWORD   dwAttributes;
    LPCTSTR pszCPL;
} REQREGITEM;

#define RIISA_ORIGINAL              0x00000001  // regitems first then rest (desktop)
#define RIISA_FOLDERFIRST           0x00000002  // folders first then the rest (regitems or not)
#define RIISA_ALPHABETICAL          0x00000004  // alphabetical (doesn't care about folder, regitems, ...)

typedef struct
{
    LPCTSTR pszAllow;
    RESTRICTIONS restAllow;
    LPCTSTR pszDisallow;
    RESTRICTIONS restDisallow;
} REGITEMSPOLICY;

typedef struct
{
    LPCTSTR             pszRegKey;      // registry location for this name space
    REGITEMSPOLICY*     pPolicy;        // registry location to look for Restrict and Disallow info
    TCHAR               cRegItem;       // parsing prefix, must be TEXT(':')
    BYTE                bFlags;         // flags field for PIDL construction
    int                 iCmp;           // compare multiplier used to revers the sort order
    DWORD               rgfRegItems;    // default attributes for items
    int                 iReqItems;      // # of required items
    REQREGITEM const *  pReqItems;      // require items array
    DWORD               dwSortAttrib;   // sorting attributes
    LPCTSTR             pszMachine;     // optional remote machine to init items from (\\server)
    DWORD               cbPadding;      // Number of bytes of padding to put between IDREGITEMEX.bOrder and IDREGITEMEX.clsid
    BYTE                bFlagsLegacy;   // legacy "bFlags", so that we can handle previous bFlags (equiv of cbPadding = 0)
                                        // CANNOT be 0, 0 means no bFlagsLegacy
} REGITEMSINFO;

// class factory like entry to create the regitems folder. it only supports the agregatied case

STDAPI CRegFolder_CreateInstance(REGITEMSINFO *pri, IUnknown *punkOutter, REFIID riid, void **ppv);
STDAPI_(BOOL) RegGetsFirstShot(REFIID riid);

// this should be private
#pragma pack(1)
typedef struct
{
    IDREGITEM       idri;
    USHORT          cbNext;
} IDLREGITEM;           // "RegItem" IDList
typedef UNALIGNED IDLREGITEM *LPIDLREGITEM;
typedef const UNALIGNED IDLREGITEM *LPCIDLREGITEM;
#pragma pack()

EXTERN_C const IDLREGITEM c_idlNet;
EXTERN_C const IDLREGITEM c_idlDrives;
EXTERN_C const IDLREGITEM c_idlInetRoot;
EXTERN_C const IDLREGITEM c_idlMyDocs;

#define MAX_REGITEMCCH  128     // for rename in place operations

//--------------------------------------------------------------------------
// Menu offset-IDs for object context menu (CFSMenu)
//  They must be 0-based and not too big (<0x3ff)
//  We are lumping all of the DefView clients in here so that we are
//  sure the ID ranges are separate (making MenuHelp easier)
//---------------------------------------------------------------------------
#define FSIDM_OBJPROPS_FIRST    0x0000
#define FSIDM_PROPERTIESBG      (FSIDM_OBJPROPS_FIRST + 0x0000)

// find extension commands
#define FSIDM_FINDFILES         0x0004
#define FSIDM_FINDCOMPUTER      0x0005
#define FSIDM_SAVESEARCH        0x0006
#define FSIDM_OPENCONTAININGFOLDER 0x0007

#define FSIDM_DRIVES_FIRST      0x0008
#define FSIDM_FORMAT            (FSIDM_DRIVES_FIRST + 0x0000)
#define FSIDM_DISCONNECT        (FSIDM_DRIVES_FIRST + 0x0001)
#define FSIDM_EJECT             (FSIDM_DRIVES_FIRST + 0x0002)
#define FSIDM_DISKCOPY          (FSIDM_DRIVES_FIRST + 0x0003)
#define FSIDM_DRIVES_LAST       (FSIDM_DRIVES_FIRST + 0x0004)

#define FSIDM_NETWORK_FIRST     (FSIDM_DRIVES_LAST + 0x0000)
#define FSIDM_CONNECT           (FSIDM_NETWORK_FIRST + 0x0001)
#define FSIDM_NETPRN_INSTALL    (FSIDM_NETWORK_FIRST + 0x0002)
#define FSIDM_CONNECT_PRN       (FSIDM_NETWORK_FIRST + 0x0003)
#define FSIDM_DISCONNECT_PRN    (FSIDM_NETWORK_FIRST + 0x0004)
#define FSIDM_NETWORK_LAST      (FSIDM_NETWORK_FIRST + 0x0005)

// Command offsets for context menu (verb ids must be mutually exclusive
// from non-verb ids.  Non-verb ids are first for easier menu merging.)
// non-verb ids:
#define FSIDM_CPLPRN_FIRST      (FSIDM_NETWORK_LAST + 0x0000)
#define FSIDM_SETDEFAULTPRN     (FSIDM_CPLPRN_FIRST + 0x0001)
#define FSIDM_SHARING           (FSIDM_CPLPRN_FIRST + 0x0002)
#define FSIDM_DOCUMENTDEFAULTS  (FSIDM_CPLPRN_FIRST + 0x0003)
#define FSIDM_SERVERPROPERTIES  (FSIDM_CPLPRN_FIRST + 0x0004)
#define FSIDM_ADDPRINTERWIZARD  (FSIDM_CPLPRN_FIRST + 0x0005)
#define FSIDM_SENDFAXWIZARD     (FSIDM_CPLPRN_FIRST + 0x0006)
#define FSIDM_SETUPFAXING       (FSIDM_CPLPRN_FIRST + 0x0007)

// verb ids:
#define FSIDM_OPENPRN           (FSIDM_CPLPRN_FIRST + 0x0008)
#define FSIDM_RESUMEPRN         (FSIDM_CPLPRN_FIRST + 0x0009)
#define FSIDM_PAUSEPRN          (FSIDM_CPLPRN_FIRST + 0x000a)
#define FSIDM_WORKONLINE        (FSIDM_CPLPRN_FIRST + 0x000b)
#define FSIDM_WORKOFFLINE       (FSIDM_CPLPRN_FIRST + 0x000c)
#define FSIDM_PURGEPRN          (FSIDM_CPLPRN_FIRST + 0x000d)
#define FSIDM_CREATELOCALFAX    (FSIDM_CPLPRN_FIRST + 0x000e)
#define FSIDM_CPLPRN_LAST       (FSIDM_CPLPRN_FIRST + 0x000e)

#define FSIDM_RUNAS_FIRST       (FSIDM_CPLPRN_LAST + 0x0000)
#define FSIDM_RUNAS             (FSIDM_RUNAS_FIRST + 0x0001)
#define FSIDM_RUNAS_SHARING     (FSIDM_RUNAS_FIRST + 0x0002)
#define FSIDM_RUNAS_ADDPRN      (FSIDM_RUNAS_FIRST + 0x0003)
#define FSIDM_RUNAS_SVRPROP     (FSIDM_RUNAS_FIRST + 0x0004)
#define FSIDM_RUNAS_OPENPRN     (FSIDM_RUNAS_FIRST + 0x0005)
#define FSIDM_RUNAS_RESUMEPRN   (FSIDM_RUNAS_FIRST + 0x0006)
#define FSIDM_RUNAS_PAUSEPRN    (FSIDM_RUNAS_FIRST + 0x0007)
#define FSIDM_RUNAS_WORKONLINE  (FSIDM_RUNAS_FIRST + 0x0008)
#define FSIDM_RUNAS_WORKOFFLINE (FSIDM_RUNAS_FIRST + 0x0009)
#define FSIDM_RUNAS_PURGEPRN    (FSIDM_RUNAS_FIRST + 0x0010)
#define FSIDM_RUNAS_DELETE      (FSIDM_RUNAS_FIRST + 0x0011)
#define FSIDM_RUNAS_PROPERTIES  (FSIDM_RUNAS_FIRST + 0x0012)
#define FSIDM_RUNAS_LAST        (FSIDM_RUNAS_FIRST + 0x001f)


// these need to be in the same order as the ICOL in fstreex.c (chee)
#define FSIDM_SORT_FIRST        (FSIDM_RUNAS_LAST + 0x0000)
#define FSIDM_SORT_LAST         (FSIDM_SORT_FIRST + 0x0010)

#define FSIDM_MENUSENDTO_FIRST  (FSIDM_SORT_LAST + 0x0000)
#define FSIDM_MENU_SENDTO       (FSIDM_MENUSENDTO_FIRST + 0x0001)
#define FSIDM_SENDTOFIRST       (FSIDM_MENUSENDTO_FIRST + 0x0002)
#define FSIDM_SENDTOLAST        (FSIDM_MENUSENDTO_FIRST + 0x0013)
#define FSIDM_MENUSENDTO_LAST   (FSIDM_MENUSENDTO_FIRST + 0x0014)

#define FSIDM_MENUNEW_FIRST     (FSIDM_MENUSENDTO_LAST + 0x0000)
#define FSIDM_MENU_NEW          (FSIDM_MENUNEW_FIRST + 0x0001)
#define FSIDM_NEWFOLDER         (FSIDM_MENUNEW_FIRST + 0x0002)
#define FSIDM_NEWLINK           (FSIDM_MENUNEW_FIRST + 0x0003)
#define FSIDM_NEWOTHER          (FSIDM_MENUNEW_FIRST + 0x0004)
#define FSIDM_NEWLAST           (FSIDM_MENUNEW_FIRST + 0x0027)
#define FSIDM_MENUNEW_LAST      (FSIDM_MENUNEW_FIRST + 0x0028)

// BITBUCKET ids.
#define FSIDM_BITBUCKET_FIRST   (FSIDM_MENUNEW_LAST + 0x0000)
#define FSIDM_RESTORE           (FSIDM_BITBUCKET_FIRST + 0x0001)
#define FSIDM_PURGE             (FSIDM_BITBUCKET_FIRST + 0x0002)
#define FSIDM_PURGEALL          (FSIDM_BITBUCKET_FIRST + 0x0003)
#define FSIDM_BITBUCKET_LAST    (FSIDM_BITBUCKET_FIRST + 0x0004)

// cd burn ids.
#define FSIDM_BURN_FIRST        (FSIDM_BITBUCKET_LAST + 0x0000)
#define FSIDM_BURN              (FSIDM_BURN_FIRST + 0x0001)
#define FSIDM_CLEANUP           (FSIDM_BURN_FIRST + 0x0002)
#define FSIDM_ERASE             (FSIDM_BURN_FIRST + 0x0003)
#define FSIDM_BURN_LAST         (FSIDM_BURN_FIRST + 0x0004)

//---------------------------------------------------------------------------
// Briefcase view specific command IDs
//
#define FSIDM_BRIEFCASE_FIRST   (FSIDM_BURN_LAST + 0x0000)
#define FSIDM_MENU_BRIEFCASE    (FSIDM_BRIEFCASE_FIRST + 0x0001)
#define FSIDM_UPDATEALL         (FSIDM_BRIEFCASE_FIRST + 0x0002)
#define FSIDM_UPDATESELECTION   (FSIDM_BRIEFCASE_FIRST + 0x0003)
#define FSIDM_SPLIT             (FSIDM_BRIEFCASE_FIRST + 0x0004)
#define FSIDM_BRIEFCASE_LAST    (FSIDM_BRIEFCASE_FIRST + 0x00b0)


//---------------------------------------------------------------------------
// Items added by DefCM
//
// HACK: Put these at the same offsets from each other as the SFVIDM
// commands so that we can easily reuse the help strings and the menu
// initialization code
//
#define DCMIDM_LINK             SHARED_FILE_LINK
#define DCMIDM_DELETE           SHARED_FILE_DELETE
#define DCMIDM_RENAME           SHARED_FILE_RENAME
#define DCMIDM_PROPERTIES       SHARED_FILE_PROPERTIES

#define DCMIDM_CUT              SHARED_EDIT_CUT
#define DCMIDM_COPY             SHARED_EDIT_COPY
#define DCMIDM_PASTE            SHARED_EDIT_PASTE

//
// Now for the MenuHelp ID's for the defview client menu commands
//
#define IDS_MH_PROPERTIESBG     (IDS_MH_FSIDM_FIRST + FSIDM_PROPERTIESBG)

#define IDS_MH_FORMAT           (IDS_MH_FSIDM_FIRST + FSIDM_FORMAT)
#define IDS_MH_DISCONNECT       (IDS_MH_FSIDM_FIRST + FSIDM_DISCONNECT)
#define IDS_MH_EJECT            (IDS_MH_FSIDM_FIRST + FSIDM_EJECT)
#define IDS_MH_DISKCOPY         (IDS_MH_FSIDM_FIRST + FSIDM_DISKCOPY)

#define IDS_MH_CONNECT          (IDS_MH_FSIDM_FIRST + FSIDM_CONNECT)

#define IDS_MH_NETPRN_INSTALL   (IDS_MH_FSIDM_FIRST + FSIDM_NETPRN_INSTALL)
#define IDS_MH_CONNECT_PRN      (IDS_MH_FSIDM_FIRST + FSIDM_CONNECT_PRN)
#define IDS_MH_DISCONNECT_PRN   (IDS_MH_FSIDM_FIRST + FSIDM_DISCONNECT_PRN)

#define IDS_MH_SETDEFAULTPRN    (IDS_MH_FSIDM_FIRST + FSIDM_SETDEFAULTPRN)

#define IDS_MH_SERVERPROPERTIES (IDS_MH_FSIDM_FIRST + FSIDM_SERVERPROPERTIES)
#define IDS_MH_ADDPRINTERWIZARD (IDS_MH_FSIDM_FIRST + FSIDM_ADDPRINTERWIZARD)
#define IDS_MH_SENDFAXWIZARD    (IDS_MH_FSIDM_FIRST + FSIDM_SENDFAXWIZARD)
#define IDS_MH_SHARING          (IDS_MH_FSIDM_FIRST + FSIDM_SHARING)
#define IDS_MH_DOCUMENTDEFAULTS (IDS_MH_FSIDM_FIRST + FSIDM_DOCUMENTDEFAULTS )

#define IDS_MH_OPENPRN          (IDS_MH_FSIDM_FIRST + FSIDM_OPENPRN)
#define IDS_MH_RESUMEPRN        (IDS_MH_FSIDM_FIRST + FSIDM_RESUMEPRN)
#define IDS_MH_PAUSEPRN         (IDS_MH_FSIDM_FIRST + FSIDM_PAUSEPRN)
#define IDS_MH_WORKONLINE       (IDS_MH_FSIDM_FIRST + FSIDM_WORKONLINE)
#define IDS_MH_WORKOFFLINE      (IDS_MH_FSIDM_FIRST + FSIDM_WORKOFFLINE)
#define IDS_MH_PURGEPRN         (IDS_MH_FSIDM_FIRST + FSIDM_PURGEPRN)
#define IDS_MH_SETUPFAXING      (IDS_MH_FSIDM_FIRST + FSIDM_SETUPFAXING)
#define IDS_MH_CREATELOCALFAX   (IDS_MH_FSIDM_FIRST + FSIDM_CREATELOCALFAX)

#define IDS_MH_RUNAS            (IDS_MH_FSIDM_FIRST + FSIDM_RUNAS)

#define IDS_MH_MENU_SENDTO      (IDS_MH_FSIDM_FIRST + FSIDM_MENU_SENDTO)
#define IDS_MH_SENDTOFIRST      (IDS_MH_FSIDM_FIRST + FSIDM_SENDTOFIRST)
#define IDS_MH_SENDTOLAST       (IDS_MH_FSIDM_FIRST + FSIDM_SENDTOLAST)

#define IDS_MH_MENU_NEW         (IDS_MH_FSIDM_FIRST + FSIDM_MENU_NEW)
#define IDS_MH_NEWFOLDER        (IDS_MH_FSIDM_FIRST + FSIDM_NEWFOLDER)
#define IDS_MH_NEWLINK          (IDS_MH_FSIDM_FIRST + FSIDM_NEWLINK)
#define IDS_MH_NEWOTHER         (IDS_MH_FSIDM_FIRST + FSIDM_NEWOTHER)

#define IDS_MH_MENU_BRIEFCASE   (IDS_MH_FSIDM_FIRST + FSIDM_MENU_BRIEFCASE)
#define IDS_MH_UPDATEALL        (IDS_MH_FSIDM_FIRST + FSIDM_UPDATEALL)
#define IDS_MH_UPDATESELECTION  (IDS_MH_FSIDM_FIRST + FSIDM_UPDATESELECTION)
#define IDS_MH_SPLIT            (IDS_MH_FSIDM_FIRST + FSIDM_SPLIT)

// bitbucket menu help strings
#define IDS_MH_RESTORE          (IDS_MH_FSIDM_FIRST + FSIDM_RESTORE)
#define IDS_MH_PURGE            (IDS_MH_FSIDM_FIRST + FSIDM_PURGE)
#define IDS_MH_PURGEALL         (IDS_MH_FSIDM_FIRST + FSIDM_PURGEALL)

// find extensions
#define IDS_MH_FINDFILES        (IDS_MH_FSIDM_FIRST + FSIDM_FINDFILES)
#define IDS_MH_FINDCOMPUTER     (IDS_MH_FSIDM_FIRST + FSIDM_FINDCOMPUTER)

#define IDS_TT_UPDATEALL        (IDS_TT_FSIDM_FIRST + FSIDM_UPDATEALL)
#define IDS_TT_UPDATESELECTION  (IDS_TT_FSIDM_FIRST + FSIDM_UPDATESELECTION)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\w32utils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       w32utils.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: Win32 templates & utilities (ported from printscan\ui\printui)
 *
 *****************************************************************************/

#ifndef _W32UTILS_H
#define _W32UTILS_H

////////////////////////////////////////////////
//
// template class CScopeLocker<TLOCK>
//
template <class TLOCK>
class CScopeLocker
{
public:
    CScopeLocker(TLOCK &lock): 
        m_Lock(lock), m_bLocked(false) 
    { m_bLocked = (m_Lock && m_Lock.Lock()); }

    ~CScopeLocker() 
    { if (m_bLocked) m_Lock.Unlock(); }

    operator bool () const 
    { return m_bLocked; }

private:
    bool m_bLocked;
    TLOCK &m_Lock;
};

////////////////////////////////////////////////
//
// class CCSLock - win32 critical section lock.
//
class CCSLock
{
public:
    // CCSLock::Locker should be used as locker class.
    typedef CScopeLocker<CCSLock> Locker;
   
    CCSLock(): m_bInitialized(false)
    { 
        __try 
        { 
            // InitializeCriticalSection may rise STATUS_NO_MEMORY exception 
            // in low memory conditions (according the SDK)
            InitializeCriticalSection(&m_CS); 
            m_bInitialized = true; 
            return;
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {}
        // if we end up here m_bInitialized will remain false 
        // (i.e. out of memory exception was thrown)
    }

    ~CCSLock()    
    { 
        if (m_bInitialized) 
        {
            // delete the critical section only if initialized successfully
            DeleteCriticalSection(&m_CS); 
        }
    }

    operator bool () const
    { 
        return m_bInitialized; 
    }

    bool Lock()
    { 
        __try 
        { 
            // EnterCriticalSection may rise STATUS_NO_MEMORY exception 
            // in low memory conditions (this may happen if there is contention
            // and ntdll can't allocate the wait semaphore)
            EnterCriticalSection(&m_CS); 
            return true; 
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {}

        // out of memory or invalid handle exception was thrown.
        return false;
    }

    void Unlock() 
    {
        // Unlock() should be called *ONLY* if the corresponding 
        // Lock() call has succeeded.
        LeaveCriticalSection(&m_CS); 
    }

private:
    bool m_bInitialized;
    CRITICAL_SECTION m_CS;
};

#endif // endif _W32UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\websvc.cpp ===
#include "shellprv.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "mshtmdid.h"
#include "htiframe.h"
#include "exdisp.h"
#include "exdispid.h"
#include "dspsprt.h"
#include "cowsite.h"
#include "ids.h"
#include "inetsmgr.h"
#pragma hdrstop


// helper functions

typedef BOOL (*pfnDllRegisterWindowClasses)(const SHDRC * pshdrc);

BOOL SHDOCVW_DllRegisterWindowClasses(const SHDRC * pshdrc)
{
    static HINSTANCE _hinstShdocvw = NULL;
    static pfnDllRegisterWindowClasses _regfunc = NULL;

    BOOL fSuccess = FALSE;

    if (!_hinstShdocvw)
    {
        _hinstShdocvw = LoadLibrary(TEXT("shdocvw.dll"));
        _regfunc = (pfnDllRegisterWindowClasses) GetProcAddress(_hinstShdocvw, "DllRegisterWindowClasses");
    }

    if (_regfunc)
        fSuccess = _regfunc(pshdrc);

    return fSuccess;
}


// Advise point for DIID_DWebBrowserEvents2
// Just an IDispatch implementation that delegates back to the main class. Allows us to have a separate "Invoke".

class CWebWizardPage;

class CWebEventHandler : public IServiceProvider, DWebBrowserEvents2
{
public:
    CWebEventHandler(CWebWizardPage *pswp); 
    ~CWebEventHandler();					// TODO: Make this virtual or it will never execute.

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef() {return 2;}
    STDMETHODIMP_(ULONG) Release() {return 1;}

    // (DwebBrowserEvents)IDispatch
    STDMETHODIMP GetTypeInfoCount(/* [out] */ UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(
        /* [in] */ UINT iTInfo,
        /* [in] */ LCID lcid,
        /* [out] */ ITypeInfo **ppTInfo)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId)
        { return E_NOTIMPL; }
    
    /* [local] */ STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS *pDispParams,
        /* [out] */ VARIANT *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

    HRESULT _Advise(BOOL fConnect);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    CWebWizardPage* _pwizPage;
    DWORD _dwCPCookie;
    IConnectionPoint* _pcpCurrentConnection;
};

#define SHOW_PROGRESS_TIMER     1
#define SHOW_PROGRESS_TIMEOUT   1000 // Start showing the progress indicator after 1 second of dead time.

class CWebWizardPage : public CImpIDispatch, 
                              CObjectWithSite, 
                              IDocHostUIHandler,
                              IServiceProvider, 
                              IWebWizardExtension, 
                              INewWDEvents
{
public:
    CWebWizardPage();
    ~CWebWizardPage();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDocHostUIHandler
    STDMETHODIMP ShowContextMenu(
        /* [in] */ DWORD dwID,
        /* [in] */ POINT *ppt,
        /* [in] */ IUnknown *pcmdtReserved,
        /* [in] */ IDispatch *pdispReserved)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetHostInfo(
        /* [out][in] */ DOCHOSTUIINFO *pInfo);
    
    STDMETHODIMP ShowUI(
        /* [in] */ DWORD dwID,
        /* [in] */ IOleInPlaceActiveObject *pActiveObject,
        /* [in] */ IOleCommandTarget *pCommandTarget,
        /* [in] */ IOleInPlaceFrame *pFrame,
        /* [in] */ IOleInPlaceUIWindow *pDoc)
        { return E_NOTIMPL; }

    STDMETHODIMP HideUI(void)
        { return E_NOTIMPL; }
    
    STDMETHODIMP UpdateUI(void)
        { return E_NOTIMPL; }
    
    STDMETHODIMP EnableModeless(
        /* [in] */ BOOL fEnable)
        { return E_NOTIMPL; }
    
    STDMETHODIMP OnDocWindowActivate(
        /* [in] */ BOOL fActivate)
        { return E_NOTIMPL; }
    
    STDMETHODIMP OnFrameWindowActivate(
        /* [in] */ BOOL fActivate)
        { return E_NOTIMPL; }
    
    STDMETHODIMP ResizeBorder(
        /* [in] */ LPCRECT prcBorder,
        /* [in] */ IOleInPlaceUIWindow *pUIWindow,
        /* [in] */ BOOL fRameWindow)
        { return E_NOTIMPL; }
    
    STDMETHODIMP TranslateAccelerator(
        /* [in] */ LPMSG lpMsg,
        /* [in] */ const GUID *pguidCmdGroup,
        /* [in] */ DWORD nCmdID)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetOptionKeyPath(
        /* [out] */ LPOLESTR *pchKey,
        /* [in] */ DWORD dw)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetDropTarget(
        /* [in] */ IDropTarget *pDropTarget,
        /* [out] */ IDropTarget **ppDropTarget)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetExternal(
        /* [out] */ IDispatch **ppDispatch);
    
    STDMETHODIMP TranslateUrl(
        /* [in] */ DWORD dwTranslate,
        /* [in] */ OLECHAR *pchURLIn,
        /* [out] */ OLECHAR **ppchURLOut)
        { return E_NOTIMPL; }
    
    STDMETHODIMP FilterDataObject(
        /* [in] */ IDataObject *pDO,
        /* [out] */ IDataObject **ppDORet)
        { return E_NOTIMPL; }

    // IServiceProvider
    STDMETHODIMP QueryService(
        /*[in]*/ REFGUID guidService,
        /*[in]*/ REFIID riid,
        /*[out]*/ void **ppv);

    // INewWDEvents

    // (IDispatch)
    STDMETHODIMP GetTypeInfoCount(
        /* [out] */ UINT *pctinfo)
        { return E_NOTIMPL; }
    
    STDMETHODIMP GetTypeInfo(
        /* [in] */ UINT iTInfo,
        /* [in] */ LCID lcid,
        /* [out] */ ITypeInfo **ppTInfo)
    {
        return CImpIDispatch::GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId)
    {
        return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS *pDispParams,
        /* [out] */ VARIANT *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr)
    {
        return CImpIDispatch::Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }

    STDMETHODIMP FinalBack(void);
    STDMETHODIMP FinalNext(void);
    STDMETHODIMP Cancel(void);

    STDMETHODIMP put_Caption(
        /* [in] */ BSTR bstrCaption);
    
    STDMETHODIMP get_Caption(
        /* [retval][out] */ BSTR *pbstrCaption);
    
    STDMETHODIMP put_Property(
        /* [in] */ BSTR bstrPropertyName,
        /* [in] */ VARIANT *pvProperty);
    
    STDMETHODIMP get_Property(
        /* [in] */ BSTR bstrPropertyName,
        /* [retval][out] */ VARIANT *pvProperty);
    
    STDMETHODIMP SetWizardButtons(
        /* [in] */ VARIANT_BOOL vfEnableBack,
        /* [in] */ VARIANT_BOOL vfEnableNext,
        /* [in] */ VARIANT_BOOL vfLastPage);

    STDMETHODIMP SetHeaderText(
        /* [in] */ BSTR bstrHeaderTitle,
        /* [in] */ BSTR bstrHeaderSubtitle);
    
    STDMETHODIMP PassportAuthenticate(
        /* [in] */ BSTR bstrSignInUrl,
        /* [retval][out] */ VARIANT_BOOL * pvfAuthenticated);

    // IWizardExtension
    STDMETHODIMP AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages);
    STDMETHODIMP GetFirstPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetLastPage(HPROPSHEETPAGE *phPage)
        { return GetFirstPage(phPage); }

    // IWebWizardExtension
    STDMETHODIMP SetInitialURL(LPCWSTR pszDefaultURL);
    STDMETHODIMP SetErrorURL(LPCWSTR pszErrorURL);

protected:
    friend class CWebEventHandler;
    void _OnDownloadBegin();
    void _OnDocumentComplete();

private:
    void _InitBrowser();
    HRESULT _NavigateBrowser(LPCWSTR pszUrl);
    HRESULT _CallScript(IWebBrowser2* pbrowser, LPCWSTR pszFunction);
    BOOL _IsScriptFunctionOnPage(IWebBrowser2* pbrowser, LPCWSTR pszFunction);
    BOOL _IsBrowserVisible();
    void _ShowBrowser(BOOL fShow);
    void _SizeProgress();
    void _ShowProgress(BOOL fShow);
    void _StartShowProgressTimer();
    void _SetHeaderText(LPCWSTR pszHeader, LPCWSTR pszSubHeader);

    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT PropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnDestroy(HWND hwnd);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnTimer(HWND hwnd, UINT nIDEvent);

    LONG _cRef;
    CWebEventHandler *_pwebEventHandler;
    IWebBrowser2 *_pwebbrowser;
    IOleInPlaceActiveObject *_poipao;
    HWND _hwndOCHost; // Web browser control window
    HWND _hwndFrame;  // Wizard frame window
    HWND _hwnd;       // Dialog window
    HPROPSHEETPAGE _hPage;

    LPWSTR _pszInitialURL;
    LPWSTR _pszErrorURL;
};


INT_PTR CWebWizardPage::StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWebWizardPage* pthis = (CWebWizardPage*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    PROPSHEETPAGE* ppage;
    INT_PTR fProcessed;

    if (uMsg == WM_INITDIALOG)
    {
        ppage = (PROPSHEETPAGE*) lParam;
        pthis = (CWebWizardPage*) ppage->lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
    }

    if (pthis != NULL)
    {
        fProcessed = pthis->DialogProc(hwndDlg, uMsg, wParam, lParam);
    }
    else
    {
        fProcessed = FALSE;
    }

    return fProcessed;
}


// construction and IUnknown

CWebEventHandler::CWebEventHandler(CWebWizardPage *pwswp) :
    _pcpCurrentConnection(NULL),
    _pwizPage(pwswp)
{
}

CWebEventHandler::~CWebEventHandler()
{
    _Advise(FALSE);
}

HRESULT CWebEventHandler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CWebEventHandler, IDispatch, DWebBrowserEvents2),
        QITABENTMULTI2(CWebEventHandler, DIID_DWebBrowserEvents2, DWebBrowserEvents2),
        // QITABENTMULTI2(CWebEventHandler, DIID_DWebBrowserEvents, DWebBrowserEvents),
        QITABENT(CWebEventHandler, IServiceProvider),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CWebEventHandler::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;                // no result yet

    // we are a site for the OleControlSite interfaces only    
    if (guidService == SID_OleControlSite)
    {
        if (riid == IID_IDispatch)
        {
            hr = this->QueryInterface(riid, ppv);
        }
    }
    return hr;
}

HRESULT CWebEventHandler_CreateInstance(CWebWizardPage *pwswp, CWebEventHandler **ppweh)
{
    *ppweh = new CWebEventHandler(pwswp);
    if (!*ppweh)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT CWebEventHandler::_Advise(BOOL fConnect)
{
    HRESULT hr = S_OK;

    // If we're already connected, disconnect, since we either want to disconnect or reconnect to
    // a different webbrowser.
    if (_pcpCurrentConnection)
    {
        hr = _pcpCurrentConnection->Unadvise(_dwCPCookie);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(_pcpCurrentConnection);
        }
    }
    else
    {
        // We expect that if _pcpCurrentConnection is NULL, no code earlier would have changed hr, and that it is still S_OK
        // The code below expects that if !SUCCEEDED(hr), Unadvise failed above.
        ASSERT(SUCCEEDED(hr));
    }

    if (_pwizPage && _pwizPage->_pwebbrowser)
    {
        if (SUCCEEDED(hr) && fConnect)
        {
            IConnectionPointContainer* pcontainer;
            hr = _pwizPage->_pwebbrowser->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcontainer));
            if (SUCCEEDED(hr))
            {
                IConnectionPoint* pconnpoint;
                hr = pcontainer->FindConnectionPoint(DIID_DWebBrowserEvents2, &pconnpoint);
                if (SUCCEEDED(hr))
                {
                    IDispatch* pDisp;
                    hr = QueryInterface(IID_PPV_ARG(IDispatch, &pDisp));
                    if (SUCCEEDED(hr))
                    {
                        hr = pconnpoint->Advise(pDisp, &_dwCPCookie);
                        pDisp->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
						// TODO: Enable ATOMICRELEASE() to verify we won't leak anything
			            // ATOMICRELEASE(_pcpCurrentConnection);
                        _pcpCurrentConnection = pconnpoint;
                    }
                    else
                    {
                        pconnpoint->Release();
                    }
                }
                pcontainer->Release();
            }
        }
    }

    return hr;
}

HRESULT CWebEventHandler::Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS *pDispParams,
        /* [out] */ VARIANT *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr)
{
    HRESULT hr = S_OK;
    switch (dispIdMember)
    {
        case DISPID_BEFORENAVIGATE2:
            _pwizPage->_OnDownloadBegin();
            break;

        case DISPID_DOCUMENTCOMPLETE:
            _pwizPage->_OnDocumentComplete();
            break;

        default:
            hr = DISP_E_MEMBERNOTFOUND;
            break;
    }
    return hr;
}

// Object for hosting HTML wizard pages

CWebWizardPage::CWebWizardPage() : 
    CImpIDispatch(LIBID_Shell32, 0, 0, IID_INewWDEvents),
    _cRef(1)
{
    // Ensure zero-init happened
    ASSERT(NULL == _pwebbrowser);
    ASSERT(NULL == _pwebEventHandler);
    ASSERT(NULL == _pszInitialURL);
    ASSERT(NULL == _pszErrorURL);
}

CWebWizardPage::~CWebWizardPage()
{
    ATOMICRELEASE(_pwebbrowser);
    ATOMICRELEASE(_pwebEventHandler);
    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_poipao);

    Str_SetPtr(&_pszInitialURL, NULL);
    Str_SetPtr(&_pszErrorURL, NULL);
}

HRESULT CWebWizardPage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENTMULTI(CWebWizardPage, IWizardExtension, IWebWizardExtension),
        QITABENT(CWebWizardPage, IWebWizardExtension),
        QITABENT(CWebWizardPage, IDocHostUIHandler),
        QITABENT(CWebWizardPage, IServiceProvider),
        QITABENT(CWebWizardPage, INewWDEvents),
        QITABENT(CWebWizardPage, IDispatch),
        QITABENT(CWebWizardPage, IWebWizardExtension),
        QITABENT(CWebWizardPage, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CWebWizardPage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CWebWizardPage::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    
    delete this;
    return 0;
}


HRESULT CWebWizardPage::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (_punkSite)
        hr = IUnknown_QueryService(_punkSite, guidService, riid, ppv);

    return hr;
}


void CWebWizardPage::_OnDownloadBegin()
{
    _ShowBrowser(FALSE);
    _StartShowProgressTimer();

    SetWizardButtons(VARIANT_FALSE, VARIANT_FALSE, VARIANT_FALSE);
}

void CWebWizardPage::_OnDocumentComplete()
{
    if (!_IsScriptFunctionOnPage(_pwebbrowser, L"OnBack"))
    {
        // This is an invalid page; navigate to our private error page
        BSTR bstrOldUrl;
        if (_pwebbrowser && SUCCEEDED(_pwebbrowser->get_LocationURL(&bstrOldUrl)))
        {
#ifdef DEBUG
            if (IDYES == ::MessageBox(_hwnd, L"A Web Service Error has occured.\n\nDo you want to load the HTML page anyway so you can debug it?\n\n(This only appears in debug builds)", bstrOldUrl, MB_ICONERROR | MB_YESNO))
            {
                _ShowBrowser(TRUE);
                SysFreeString(bstrOldUrl);
                return;
            }
#endif
            BSTR bstrUrl = NULL;
            BOOL fUsingCustomError = FALSE;

            // If we have a custom error URL and we haven't already failed trying
            // to navigate to this custom URL...
            if ((NULL != _pszErrorURL) && 
                (0 != StrCmpI(_pszErrorURL, bstrOldUrl)))
            {
                // then use the custom URL.
                bstrUrl = SysAllocString(_pszErrorURL);
                fUsingCustomError = TRUE;
            }
            else
            {
                bstrUrl = SysAllocString(L"res://shell32.dll/WebServiceError.htm");
            }

            if (bstrUrl)
            {
                _pwebbrowser->Navigate(bstrUrl, NULL, NULL, NULL, NULL);
                SysFreeString(bstrUrl);

                // Custom error URL will provide its own header and subheader
                if (!fUsingCustomError)
                {
                    WCHAR szTitle[256];
                    LoadString(g_hinst, IDS_WEBDLG_ERRTITLE, szTitle, ARRAYSIZE(szTitle));
#ifdef DEBUG
                    _SetHeaderText(szTitle, bstrOldUrl);
#else
                    _SetHeaderText(szTitle, L"");
#endif
                }
            }
            SysFreeString(bstrOldUrl);
        }
        // else out of memory - oops.
    }
    else
    {
        _ShowBrowser(TRUE);
    }
}

HRESULT CWebWizardPage::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(*pInfo));
    pInfo->cbSize = sizeof(*pInfo);
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_NO3DBORDER | 
                     DOCHOSTUIFLAG_ENABLE_FORMS_AUTOCOMPLETE | DOCHOSTUIFLAG_THEME | 
                     DOCHOSTUIFLAG_FLAT_SCROLLBAR;
    return S_OK;
}

HRESULT CWebWizardPage::GetExternal(IDispatch** ppDispatch)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDispatch));
}

INT_PTR CWebWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_DESTROY, OnDestroy);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_TIMER, OnTimer);
    }
    return FALSE;
}

HRESULT CWebWizardPage::_CallScript(IWebBrowser2* pbrowser, LPCWSTR pszFunction)
{
    HRESULT hr = E_INVALIDARG;

    if (pbrowser)
    {
        IDispatch* pdocDispatch;

        hr = pbrowser->get_Document(&pdocDispatch);
        if ((S_OK == hr) && pdocDispatch)
        {
            IHTMLDocument* pdoc;
            hr = pdocDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument, &pdoc));
            if (SUCCEEDED(hr))
            {
                IDispatch* pdispScript;
                hr = pdoc->get_Script(&pdispScript);
                if (S_OK == hr)
                {
                    DISPID dispid;
                    hr = pdispScript->GetIDsOfNames(IID_NULL, const_cast<LPWSTR*>(&pszFunction), 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                    if (SUCCEEDED(hr))
                    {
                        unsigned int uArgErr;
                        DISPPARAMS dispparams = {0};
                        hr = pdispScript->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &dispparams, NULL, NULL, &uArgErr);
                    }
                    pdispScript->Release();
                }
                else
                {
                    hr = E_FAIL;
                }
                pdoc->Release();
            }
            else
            {
                hr = E_FAIL;
            }
            pdocDispatch->Release();
        }
    }

    return hr;
}

BOOL CWebWizardPage::_IsScriptFunctionOnPage(IWebBrowser2* pbrowser, LPCWSTR pszFunction)
{
    HRESULT hr = E_INVALIDARG;

    if (pbrowser)
    {
        IDispatch* pdocDispatch;

        hr = pbrowser->get_Document(&pdocDispatch);
        if (S_OK == hr && pdocDispatch)
        {
            IHTMLDocument* pdoc;
            hr = pdocDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument, &pdoc));
            if (SUCCEEDED(hr))
            {
                IDispatch* pdispScript;
                hr = pdoc->get_Script(&pdispScript);
                if (S_OK == hr)
                {
                    DISPID dispid;
                    hr = pdispScript->GetIDsOfNames(IID_NULL, const_cast<LPWSTR*>(&pszFunction), 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                    pdispScript->Release();
                }
                else
                {
                    hr = E_FAIL;
                }
                pdoc->Release();
            }
            else
            {
                hr = E_FAIL;
            }
            pdocDispatch->Release();
        }
    }

    return (S_OK == hr) ? TRUE : FALSE;
}


// Uncomment this to NOT pass the LCID on the URL query string - for testing only. 

BOOL CWebWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
            {
                _SizeProgress();
                _ShowProgress(FALSE);
                _ShowBrowser(FALSE);

                // fetch the high contrast flag, and set accordingly for the HTML to read
                // its OK for us to fail setting this into the property bag.

                HIGHCONTRAST hc = {sizeof(hc)};
                if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
                {
                    VARIANT var = {VT_BOOL};
                    var.boolVal = (hc.dwFlags & HCF_HIGHCONTRASTON) ? VARIANT_TRUE:VARIANT_FALSE;
                    put_Property(L"HighContrast", &var);
                }

                // Position the OCHost window

                RECT rectClient;
                GetClientRect(hwnd, &rectClient);
                SetWindowPos(_hwndOCHost, NULL, 0, 0, rectClient.right, rectClient.bottom, SWP_NOMOVE | SWP_NOOWNERZORDER);

                // set the initial URL         

                if (_pszInitialURL)
                {
                    WCHAR szURLWithLCID[INTERNET_MAX_URL_LENGTH];
                    LPCWSTR pszFormat = StrChr(_pszInitialURL, L'?') ? L"%s&lcid=%d&langid=%d":L"%s?lcid=%d&langid=%d";
                    if (wnsprintf(szURLWithLCID, ARRAYSIZE(szURLWithLCID), pszFormat, _pszInitialURL, GetUserDefaultLCID(), GetUserDefaultUILanguage()) > 0)
                    {
                        _NavigateBrowser(szURLWithLCID);
                    }
                }
            }
            break;

        // WIZNEXT and WIZBACK don't actually cause a navigation to occur - they instead forward on the message to the
        // hosted web page. Real wizard navigations occur when the hosted web page calls our FinalBack() and FinalNext() methods.

        case PSN_WIZNEXT:
            _CallScript(_pwebbrowser, L"OnNext");
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
            return TRUE;

        case PSN_WIZBACK:
            _CallScript(_pwebbrowser, L"OnBack");
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
            return TRUE;

        // query cancel results in a call to the site to determine if we are going
        // to cancel out and if the site wants to provide a page for us to navigate
        // to - in some cases, eg. the web publishing wizard this is important
        // so that we can cancel the order being processed etc.

        case PSN_QUERYCANCEL:
            if (_punkSite)
            {
                IWizardSite *pws;
                if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                {
                    HPROPSHEETPAGE hpage;
                    if (S_OK == pws->GetCancelledPage(&hpage))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)TRUE);
                    }
                    pws->Release();
                }
            }
            return TRUE;

        case PSN_TRANSLATEACCELERATOR:
            {
                LPPSHNOTIFY ppsn = (LPPSHNOTIFY)pnmh;
                MSG *pmsg = (MSG *)ppsn->lParam;
                LONG_PTR lres = PSNRET_NOERROR;
                
                if (_poipao && S_OK == _poipao->TranslateAccelerator(pmsg))
                {
                    lres = PSNRET_MESSAGEHANDLED;
                }

                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, lres);
            }
            break;
                
    }

    return TRUE;
}

BOOL CWebWizardPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    _hwnd = hwnd;
    _hwndFrame = GetParent(hwnd);

    // lets remap some of the text in the dialog if we need to

    IResourceMap *prm;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_ResourceMap, IID_PPV_ARG(IResourceMap, &prm));
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdn;
        hr = prm->SelectResourceScope(TEXT("dialog"), TEXT("ws:downloading"), &pdn);
        if (SUCCEEDED(hr))
        {
            TCHAR szBuffer[512];
            if (SUCCEEDED(prm->LoadString(pdn, TEXT("header"), szBuffer, ARRAYSIZE(szBuffer))))
            {
                SetDlgItemText(hwnd, IDC_PROGTEXT1, szBuffer);
            }
            if (SUCCEEDED(prm->LoadString(pdn, TEXT("footer"), szBuffer, ARRAYSIZE(szBuffer))))
            {
                SetDlgItemText(hwnd, IDC_PROGTEXT2, szBuffer);
            }
            pdn->Release();
        }
        prm->Release();
    }

    // create the web view browser that we will show the providers HTML in

    SHDRC shdrc = {0};
    shdrc.cbSize = sizeof(shdrc);
    shdrc.dwFlags = SHDRCF_OCHOST;

    if (SHDOCVW_DllRegisterWindowClasses(&shdrc))
    {
        RECT rectClient;
        GetClientRect(hwnd, &rectClient);

        _hwndOCHost = CreateWindow(OCHOST_CLASS, NULL,
                                   WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_TABSTOP,
                                   0, 0, rectClient.right, rectClient.bottom,
                                   hwnd, NULL, g_hinst, NULL);
        if (_hwndOCHost)
        {
            OCHINITSTRUCT ocs = {0};
            ocs.cbSize = sizeof(ocs);   
            ocs.clsidOC  = CLSID_WebBrowser;
            ocs.punkOwner = SAFECAST(this, IDocHostUIHandler*);

            hr = OCHost_InitOC(_hwndOCHost, (LPARAM)&ocs);        
            if (SUCCEEDED(hr))
            {
                _InitBrowser();

                OCHost_DoVerb(_hwndOCHost, OLEIVERB_INPLACEACTIVATE, TRUE);
                ShowWindow(_hwndOCHost, TRUE);

                IServiceProvider* pSP;
                hr = _pwebEventHandler->QueryInterface(IID_PPV_ARG(IServiceProvider, &pSP));
                if (SUCCEEDED(hr))
                {
                    OCHost_SetServiceProvider(_hwndOCHost, pSP);
                    pSP->Release();
                }
            }
        }
    }

    if (FAILED(hr))
        EndDialog(hwnd, IDCANCEL);

    return TRUE;
}

BOOL CWebWizardPage::OnTimer(HWND hwnd, UINT nIDEvent)
{
    if (nIDEvent == SHOW_PROGRESS_TIMER)
    {
        _ShowProgress(TRUE);
    }
    return TRUE;
}

BOOL CWebWizardPage::OnDestroy(HWND hwnd)
{
    ATOMICRELEASE(_pwebbrowser);
    return TRUE;
}

void CWebWizardPage::_InitBrowser(void)
{
    ASSERT(IsWindow(_hwndOCHost));
    ASSERT(!_pwebbrowser);

    HRESULT hr = OCHost_QueryInterface(_hwndOCHost, IID_PPV_ARG(IWebBrowser2, &_pwebbrowser));
    if (SUCCEEDED(hr) && _pwebbrowser)
    {
        ITargetFrame2* ptgf;
        if (SUCCEEDED(_pwebbrowser->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            DWORD dwOptions;
            if (SUCCEEDED(ptgf->GetFrameOptions(&dwOptions)))
            {
                dwOptions |= FRAMEOPTIONS_BROWSERBAND | FRAMEOPTIONS_SCROLL_AUTO;
                ptgf->SetFrameOptions(dwOptions);
            }
            ptgf->Release();
        }

        _pwebbrowser->put_RegisterAsDropTarget(VARIANT_FALSE);

        // Set up the connection point (including creating the object

        if (!_pwebEventHandler)
            CWebEventHandler_CreateInstance(this, &_pwebEventHandler);

        if (_pwebEventHandler)
            _pwebEventHandler->_Advise(TRUE);

        OCHost_QueryInterface(_hwndOCHost, IID_PPV_ARG(IOleInPlaceActiveObject, &_poipao));
    }
}

HRESULT CWebWizardPage::_NavigateBrowser(LPCWSTR pszUrl)
{
    HRESULT hr = E_FAIL;

    if (_hwndOCHost && _pwebbrowser)
    {
        BSTR bstrUrl = SysAllocString(pszUrl);
        if (bstrUrl)
        {
            hr = _pwebbrowser->Navigate(bstrUrl, NULL, NULL, NULL, NULL);
            SysFreeString(bstrUrl);
        }
    }

    return hr;
}

HRESULT CWebWizardPage::FinalBack(void)
{
    if (_punkSite)
    {
        IWizardSite *pws;
        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
        {
            HPROPSHEETPAGE hpage;
            HRESULT hr = pws->GetPreviousPage(&hpage);
            if (SUCCEEDED(hr))
            {
                PropSheet_SetCurSel(_hwndFrame, hpage, -1);
            }
            pws->Release();
        }
    }
    return S_OK;
}

HRESULT CWebWizardPage::FinalNext(void)
{
    if (_punkSite)
    {
        IWizardSite *pws;
        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
        {
            HPROPSHEETPAGE hpage;
            HRESULT hr = pws->GetNextPage(&hpage);
            if (SUCCEEDED(hr))
            {
                PropSheet_SetCurSel(_hwndFrame, hpage, -1);
            }
            pws->Release();
        }
    }
    return S_OK;
}

HRESULT CWebWizardPage::Cancel(void)
{
    PropSheet_PressButton(_hwndFrame, PSBTN_CANCEL);      // simulate cancel...
    return S_OK;
}

HRESULT CWebWizardPage::put_Caption(
    /* [in] */ BSTR bstrCaption)
{
    return S_OK;
}

HRESULT CWebWizardPage::get_Caption(
    /* [retval][out] */ BSTR *pbstrCaption)
{
    WCHAR szCaption[MAX_PATH];

    GetWindowText(_hwndFrame, szCaption, ARRAYSIZE(szCaption));
    *pbstrCaption = SysAllocString(szCaption);

    return S_OK;
}


// fetch and put properties into the frames property bag.  this we do
// by a QueryService call and then we can modify the properties accordingly.

HRESULT CWebWizardPage::put_Property(
    /* [in] */ BSTR bstrPropertyName,
    /* [in] */ VARIANT *pvProperty)
{
    IPropertyBag *ppb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_WebWizardHost, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        hr = ppb->Write(bstrPropertyName, pvProperty);
        ppb->Release();
    }
    return hr;
}

HRESULT CWebWizardPage::get_Property(
    /* [in] */ BSTR bstrPropertyName,
    /* [retval][out] */ VARIANT *pvProperty)
{
    IPropertyBag *ppb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_WebWizardHost, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        hr = ppb->Read(bstrPropertyName, pvProperty, NULL);

        if (FAILED(hr))
        {
            // Return a NULL-variant
            VariantInit(pvProperty);
            pvProperty->vt = VT_NULL;
            hr = S_FALSE;
        }
        
        ppb->Release();
    }
    return hr;
}

HRESULT CWebWizardPage::SetWizardButtons(
    /* [in] */ VARIANT_BOOL vfEnableBack,
    /* [in] */ VARIANT_BOOL vfEnableNext,
    /* [in] */ VARIANT_BOOL vfLastPage)
{
    // We ignore vfLastPage because it isn't the last page for us!
    DWORD dwButtons = 0;

    if (vfEnableBack)
        dwButtons |= PSWIZB_BACK;

    if (vfEnableNext)
        dwButtons |= PSWIZB_NEXT;

    PropSheet_SetWizButtons(_hwndFrame, dwButtons);
    return S_OK;
}

void CWebWizardPage::_SetHeaderText(LPCWSTR pszHeader, LPCWSTR pszSubHeader)
{
    int iPageNumber = PropSheet_HwndToIndex(_hwndFrame, _hwnd);
    if (-1 != iPageNumber)
    {
        PropSheet_SetHeaderTitle(_hwndFrame, iPageNumber, pszHeader);
        PropSheet_SetHeaderSubTitle(_hwndFrame, iPageNumber, pszSubHeader);
    }
}

HRESULT CWebWizardPage::SetHeaderText(
    /* [in] */ BSTR bstrHeaderTitle,
    /* [in] */ BSTR bstrHeaderSubtitle)
{
    _SetHeaderText(bstrHeaderTitle, bstrHeaderSubtitle);
    return S_OK;
}

HRESULT CWebWizardPage::PassportAuthenticate(
        /* [in] */ BSTR bstrURL,
        /* [retval][out] */ VARIANT_BOOL * pfAuthenticated)
{
    *pfAuthenticated = VARIANT_FALSE;                 // the user isn't authenticated.

    IXMLHttpRequest *preq;
    HRESULT hr = CoCreateInstance(CLSID_XMLHTTPRequest, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLHttpRequest, &preq));
    if (SUCCEEDED(hr))
    {
        VARIANT varNULL = {0};
        VARIANT varAsync = {VT_BOOL};
        varAsync.boolVal = VARIANT_FALSE;

        // open a post request to the destination that we have
        hr = preq->open(L"GET", bstrURL, varAsync, varNULL, varNULL);
        if (SUCCEEDED(hr))
        {
            VARIANT varBody = {0};
            hr = preq->send(varBody);
            if (SUCCEEDED(hr))
            {
                long lStatus;
                hr = preq->get_status(&lStatus);
                if (SUCCEEDED(hr) && (lStatus == HTTP_STATUS_OK))
                {
                    *pfAuthenticated = VARIANT_TRUE;
                }
            }
        }
    }

    return S_OK;
}

BOOL CWebWizardPage::_IsBrowserVisible()
{
    return IsWindowVisible(_hwndOCHost);
}
 
void CWebWizardPage::_ShowBrowser(BOOL fShow)
{
    ShowWindow(_hwndOCHost, fShow ? SW_SHOW : SW_HIDE);

    if (fShow)
    {
        // Can't have these windows overlapping.
        _ShowProgress(FALSE);
    }
}

void CWebWizardPage::_StartShowProgressTimer()
{
    _ShowProgress(FALSE);

    if (!SetTimer(_hwnd, SHOW_PROGRESS_TIMER, SHOW_PROGRESS_TIMEOUT, NULL))
    {
        // Timer failed to set; show progress now;
        _ShowProgress(TRUE);
    }
}

// Size the progress bar to fit the client area it is in.
void CWebWizardPage::_SizeProgress()
{
    HWND hwndProgress = GetDlgItem(_hwnd, IDC_PROGRESS);

    RECT rcPage;
    GetClientRect(_hwnd, &rcPage);
    RECT rcProgress;
    GetClientRect(hwndProgress, &rcProgress);
    MapWindowPoints(hwndProgress, _hwnd, (LPPOINT) &rcProgress, 2);

    rcProgress.right = rcPage.right - rcProgress.left;

    SetWindowPos(hwndProgress, NULL, 0, 0, rcProgress.right - rcProgress.left, rcProgress.bottom - rcProgress.top, SWP_NOMOVE | SWP_NOZORDER | SWP_NOREPOSITION);
}

void CWebWizardPage::_ShowProgress(BOOL fShow)
{
    HWND hwndProgress = GetDlgItem(_hwnd, IDC_PROGRESS);
    ShowWindow(hwndProgress, fShow ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(_hwnd, IDC_PROGTEXT1), fShow ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(_hwnd, IDC_PROGTEXT2), fShow ? SW_SHOW : SW_HIDE);

    KillTimer(_hwnd, SHOW_PROGRESS_TIMER);

    if (fShow)
    {
        SendMessage(hwndProgress, PBM_SETMARQUEE, (WPARAM) TRUE, 0);

        // Set the header/subheader to a "Connecting to Internet" message.
        WCHAR szTitle[256];
        WCHAR szSubtitle[256];
        LoadString(g_hinst, IDS_WEBDLG_TITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(g_hinst, IDS_WEBDLG_SUBTITLE, szSubtitle, ARRAYSIZE(szSubtitle));
        _SetHeaderText(szTitle, szSubtitle);
    }
    else
    {
        SendMessage(hwndProgress, PBM_SETMARQUEE, (WPARAM) FALSE, 0);
    }
}


// IWizardExtn

UINT CWebWizardPage::PropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp)
{
    CWebWizardPage *pwwp = (CWebWizardPage*)ppsp->lParam;
    switch (uMsg)
    {
        case PSPCB_CREATE:
            return TRUE;

        // we need to release our site in this scenario, we know that we won't be using it
        // anymore, and to ensure that clients down have a circular refernce to us we
        // release it before they call us for our final destruction.

        case PSPCB_RELEASE:
            ATOMICRELEASE(pwwp->_punkSite);
            break;
    }
    return FALSE;
}

HRESULT CWebWizardPage::AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages)
{
    PROPSHEETPAGE psp = { 0 };
    psp.dwSize = sizeof(psp);
    psp.hInstance = g_hinst;
    psp.dwFlags = PSP_DEFAULT|PSP_USECALLBACK ;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_WEBWIZARD);
    psp.lParam = (LPARAM) this;
    psp.pfnDlgProc = CWebWizardPage::StaticProc;
    psp.pfnCallback = PropPageProc;

    _hPage = CreatePropertySheetPage(&psp);
    if (!_hPage)
        return E_FAIL;

    // return the page we created.

    *aPages = _hPage;
    *pnPages = 1;

    return S_OK;
}

STDMETHODIMP CWebWizardPage::GetFirstPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hPage;
    return S_OK;
}

STDMETHODIMP CWebWizardPage::SetInitialURL(LPCWSTR pszDefaultURL)
{
    HRESULT hr = E_INVALIDARG;
    if (pszDefaultURL)
    {
        hr = Str_SetPtr(&_pszInitialURL, pszDefaultURL) ? S_OK:E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CWebWizardPage::SetErrorURL(LPCWSTR pszErrorURL)
{
    HRESULT hr = E_INVALIDARG;
    if (pszErrorURL)
    {
        hr = Str_SetPtr(&_pszErrorURL, pszErrorURL) ? S_OK:E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI CWebWizardPage_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    if (NULL != pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CWebWizardPage *pwwp = new CWebWizardPage();
    if (!pwwp)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pwwp->QueryInterface(riid, ppv);
    pwwp->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\wirelessfldr.cpp ===
#include "shellprv.h"
#pragma hdrstop
#include "idldata.h"
#include "datautil.h"
#include "ids.h"
#include <obex.h>

#pragma pack(1)
typedef struct              // typedef struct
{                           // {
// these need to line up -----------------------
    WORD cbSize;            //     WORD cbSize;                // Size of entire item ID
    WORD wOuter;            //     WORD wOuter;                // Private data owned by the outer folder
    WORD cbInner;           //     WORD cbInner;               // Size of delegate's data
// ---------------------------------------------
    DWORD dwMagic;          //     BYTE rgb[1];                // Inner folder's data,
    DWORD dwType;           // } DELEGATEITEMID;
    DWORD dwAttributes;
    ULARGE_INTEGER cbTotal;
    ULARGE_INTEGER cbFree;
    union 
    {
        FILETIME ftModified;
        ULARGE_INTEGER ulModified;
    };
    WCHAR szName[1]; // variable size
} WIRELESSITEM;
#pragma pack()

typedef UNALIGNED WIRELESSITEM * LPWIRELESSITEM;
typedef const UNALIGNED WIRELESSITEM * LPCWIRELESSITEM;

#define WIRELESSITEM_MAGIC 0x98765432

class CWirelessDeviceFolder;
class CWirelessDeviceEnum;
class CWirelessDeviceDropTarget;

class CWirelessDeviceFolder : public IShellFolder2, IPersistFolder2, IShellFolderViewCB, IDelegateFolder
{
public:
    CWirelessDeviceFolder();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHOD(GetCurFolder)(LPITEMIDLIST *ppidl);

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
            { return BindToObject(pidl, pbc, riid, ppv); };
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppvOut);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHOD(GetDefaultSearchGUID)(GUID *pGuid)
            { return E_NOTIMPL; };
    STDMETHOD(EnumSearches)(IEnumExtraSearch **ppenum)
            { return E_NOTIMPL; };
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
            { return E_NOTIMPL; };
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState)
            { return E_NOTIMPL; }
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
            { return E_NOTIMPL; };
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHOD(MapColumnToSCID)(UINT iColumn, SHCOLUMNID *pscid)
            { return E_NOTIMPL; };

    // IShellFolderViewCB
    STDMETHOD(MessageSFVCB)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IDelegateFolder
    STDMETHODIMP SetItemAlloc(IMalloc *pmalloc);

private:
    ~CWirelessDeviceFolder();

    HRESULT _CreateIDList(LPCTSTR pszName, LPCTSTR pszAddress, LPCTSTR pszTransport, WIRELESSITEM **ppmditem);
    HRESULT _IDListForDevice(IObexDevice *pdev, LPITEMIDLIST *ppidl);
    HRESULT _GetTypeOf(LPCWIRELESSITEM pmdi, LPTSTR pszBuffer, INT cchBuffer);
    ULONG _GetAttributesOf(LPCWIRELESSITEM pmdi, ULONG rgfIn);
    HRESULT _CreateExtractIcon(LPCWIRELESSITEM pmdi, REFIID riid, void **ppv);
    HRESULT _Device(LPCWIRELESSITEM pmdi, REFIID riid, void **ppv);
    static HRESULT CALLBACK _ItemsMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // folder view callback handlers
    HRESULT _OnBackgroundEnum(DWORD pv) { return S_OK; };
    HRESULT _OnGetNotify(DWORD pv, LPITEMIDLIST *ppidl, LONG *plEvents);

    LPCWIRELESSITEM _IsValid(LPCITEMIDLIST pidl);
    DWORD _IsFolder(LPCWIRELESSITEM pmditem);
    HRESULT _GetObex(REFIID riid, void **ppv);
    HRESULT _GetName(LPCWIRELESSITEM pmdi, LPTSTR pszName, LPTSTR pszAddress, LPTSTR pszTransport);
    HRESULT _CreateStgFolder(LPCITEMIDLIST pidl, IStorage *pstg, REFIID riid, void **ppv);
    void *_Alloc(SIZE_T cb);

    friend CWirelessDeviceEnum;
    friend CWirelessDeviceDropTarget;

    LONG _cRef;
    IMalloc *_pmalloc;
    LPITEMIDLIST _pidl;
    IObex *_pObex;
};
    
class CWirelessDeviceEnum : public IEnumIDList
{
public:
    CWirelessDeviceEnum(CWirelessDeviceFolder* prf, DWORD grfFlags);
    ~CWirelessDeviceEnum();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; };
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum) { return E_NOTIMPL; };

private:
    HRESULT _InitEnum();
    void _UnMarshall();

    LONG _cRef;
    CWirelessDeviceFolder* _pwdf;
    DWORD _grfFlags;
    IDeviceEnum *_pDeviceEnum;
    IObex *_pobex;
    IStream *_pstmDevice;
};

class CWirelessDeviceDropTarget : public IDropTarget
{
public:
    CWirelessDeviceDropTarget(CWirelessDeviceFolder *pFolder, HWND hwnd);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    ~CWirelessDeviceDropTarget();
    DWORD _GetDropEffect(DWORD *pdwEffect, DWORD grfKeyState);
    HRESULT _Transfer(IDataObject *pdtobj, UINT uiCmd);

    LONG _cRef;

    CWirelessDeviceFolder *_pwdf;
    HWND _hwnd;                     // EVIL: used as a site and UI host
    IDataObject *_pdtobj;           // used durring DragOver() and DoDrop(), don't use on background thread

    UINT _idCmd;
    DWORD _grfKeyStateLast;         // for previous DragOver/Enter
    DWORD _dwEffectLastReturned;    // stashed effect that's returned by base class's dragover
    DWORD _dwEffectPreferred;       // if dwData & DTID_PREFERREDEFFECT

};

CWirelessDeviceFolder::CWirelessDeviceFolder() : _cRef(1)
{
    ASSERT(NULL == _pidl);
    ASSERT(NULL == _pmalloc);
    DllAddRef();
}

CWirelessDeviceFolder::~CWirelessDeviceFolder()
{
    ILFree(_pidl);
    ATOMICRELEASE(_pmalloc);

    if (_pObex)
    {
        _pObex->Shutdown();
        _pObex->Release();
    }
    DllRelease();
}

HRESULT CWirelessDeviceFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENTMULTI(CWirelessDeviceFolder, IShellFolder,      IShellFolder2),
        QITABENT     (CWirelessDeviceFolder, IShellFolder2),
        QITABENTMULTI(CWirelessDeviceFolder, IPersist,          IPersistFolder2),
        QITABENTMULTI(CWirelessDeviceFolder, IPersistFolder,    IPersistFolder2),
        QITABENT     (CWirelessDeviceFolder, IPersistFolder2),
        QITABENT     (CWirelessDeviceFolder, IShellFolderViewCB),
        QITABENT     (CWirelessDeviceFolder, IDelegateFolder),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CWirelessDeviceFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CWirelessDeviceFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDAPI CWirelessDevices_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    CWirelessDeviceFolder *pwdf = new CWirelessDeviceFolder();
    if (!pwdf)
        return E_OUTOFMEMORY;

    HRESULT hr = pwdf->QueryInterface(riid, ppv);
    pwdf->Release();
    return hr;
}

const GUID CLSID_Obex = {0x30a7bc00, 0x59b6, 0x40bb, 0xaa, 0x2b, 0x89, 0xeb, 0x49, 0xef, 0x27, 0x4e};
const IID IID_IObex   = {0x0C5A5B12, 0x2979, 0x42D1, 0x9E, 0x15, 0xA6, 0x3E, 0x34, 0x38, 0x3B, 0x58};

HRESULT CWirelessDeviceFolder::_GetObex(REFIID riid, void **ppv)
{
    HRESULT hr;
    if (_pObex)
    {
        hr = _pObex->QueryInterface(riid, ppv);
    }
    else
    {
        hr = CoCreateInstance(CLSID_Obex, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IObex, &_pObex));
        if (SUCCEEDED(hr))
        {
            hr = _pObex->Initialize();
            if (SUCCEEDED(hr))
            {
                hr = _pObex->QueryInterface(riid, ppv);
            }
            else
            {
                _pObex->Release();
                _pObex = NULL;
            }
        }
    }
    return hr;
}

LPCWIRELESSITEM CWirelessDeviceFolder::_IsValid(LPCITEMIDLIST pidl)
{
    if (pidl && ((LPCWIRELESSITEM)pidl)->dwMagic == WIRELESSITEM_MAGIC)
        return (LPCWIRELESSITEM)pidl;
    return NULL;
}

DWORD CWirelessDeviceFolder::_IsFolder(LPCWIRELESSITEM pmditem) 
{ 
    return FILE_ATTRIBUTE_DIRECTORY;
}

// helper to support being run as a delegate or a stand alone folder
//
// the cbInner is the size of the data needed by the delegate. we need to compute
// the full size of the pidl for the allocation and init that we the outer folder data
void *CWirelessDeviceFolder::_Alloc(SIZE_T cbInner)
{
    DELEGATEITEMID *pidl;
    if (_pmalloc)
    {
        pidl = (DELEGATEITEMID *)_pmalloc->Alloc(cbInner);
    }
    else
    {
        SIZE_T cbAlloc = 
            sizeof(DELEGATEITEMID) - sizeof(pidl->rgb[0]) + // header
            cbInner +                                       // inner
            sizeof(WORD);                                   // trailing null (pidl terminator)

        pidl = (DELEGATEITEMID *)SHAlloc(cbAlloc);
        if (pidl)
        {
            ZeroMemory(pidl, cbAlloc);              // make it all empty
            pidl->cbSize = (WORD)cbAlloc - sizeof(WORD);
            pidl->cbInner = (WORD)cbInner;
        }
    }
    return (void *)pidl;
}

HRESULT CWirelessDeviceFolder::_CreateIDList(LPCTSTR pszName, LPCTSTR pszAddress, LPCTSTR pszTransport, WIRELESSITEM **ppmditem)
{
    HRESULT hr;
    UINT cbName = lstrlen(pszName) + 1;
    UINT cbAddress = lstrlen(pszAddress) + 1;
    UINT cbTransport = lstrlen(pszTransport);
    UINT cbInner = sizeof(WIRELESSITEM) - (sizeof(DELEGATEITEMID) - 1) + 
                   (sizeof(WCHAR) * (cbName + cbAddress + cbTransport));
    *ppmditem = (WIRELESSITEM *)_Alloc(cbInner);
    if (*ppmditem)
    {
        (*ppmditem)->dwMagic = WIRELESSITEM_MAGIC;
        (*ppmditem)->dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
        StrCpyW((*ppmditem)->szName, pszName);   
        StrCpyW((*ppmditem)->szName + cbName, pszAddress);   
        StrCpyW((*ppmditem)->szName + cbName + cbAddress, pszTransport);   
        hr = S_OK;
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

// Creates an item identifier list for the objects in the namespace

HRESULT CWirelessDeviceFolder::_IDListForDevice(IObexDevice *pdev, LPITEMIDLIST *ppidl)
{
    IPropertyBag *ppb;
    HRESULT hr = pdev->EnumProperties(IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH], szAddress[64], szTransport[64];
        SHPropertyBag_ReadStr(ppb, L"Name", szName, ARRAYSIZE(szName));
        SHPropertyBag_ReadStr(ppb, L"Address", szAddress, ARRAYSIZE(szAddress));
        SHPropertyBag_ReadStr(ppb, L"Transport", szTransport, ARRAYSIZE(szTransport));

        WIRELESSITEM *pmditem;
        hr = _CreateIDList(szName, szAddress, szTransport, &pmditem);
        if (SUCCEEDED(hr))
        {
            *ppidl = (LPITEMIDLIST)pmditem;
        }
        ppb->Release();
    }
    return hr;
}

HRESULT CWirelessDeviceFolder::_GetTypeOf(LPCWIRELESSITEM pmdi, LPTSTR pszBuffer, INT cchBuffer)
{
    *pszBuffer = 0;                // null out the return buffer

    LPCWSTR pwszName;
    WSTR_ALIGNED_STACK_COPY(&pwszName, pmdi->szName);

    LPTSTR pszExt = PathFindExtension(pwszName);
    if (pszExt)
    {
        StrCpyN(pszBuffer, pszExt, cchBuffer);
    }

    return S_OK;
}

// IPersist

STDMETHODIMP CWirelessDeviceFolder::GetClassID(CLSID *pClassID) 
{ 
    *pClassID = CLSID_WirelessDevices; 
    return S_OK; 
}

// IPersistFolder

STDMETHODIMP CWirelessDeviceFolder::Initialize(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    return SHILClone(pidl, &_pidl); 
}

// IPersistFolder2

HRESULT CWirelessDeviceFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);

    *ppidl = NULL;
    return S_FALSE;
}


// IShellFolder(2)

HRESULT CWirelessDeviceFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr;

    if (!pszName || !ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;

#if 1
    hr = E_NOTIMPL;
#else
    TCHAR szName[MAX_PATH];
    hr = _NextSegment((LPCWSTR*)&pszName, szName, ARRAYSIZE(szName), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = _IDListForDevice(szName, ppidl);
        if (SUCCEEDED(hr) && pszName)
        {
            IShellFolder *psf;
            hr = BindToObject(*ppidl, pbc, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                ULONG chEaten;
                LPITEMIDLIST pidlNext;
                hr = psf->ParseDisplayName(hwnd, pbc, pszName, &chEaten, &pidlNext, pdwAttributes);
                if (SUCCEEDED(hr))
                    hr = SHILAppend(pidlNext, ppidl);
                psf->Release();
            }
        }
        else if (SUCCEEDED(hr) && pdwAttributes && *pdwAttributes)
        {
            GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
        }
    }
#endif

    // clean up if the parse failed.

    if (FAILED(hr))
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    return hr;
}

HRESULT CWirelessDeviceFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    HRESULT hr;
    CWirelessDeviceEnum *penum = new CWirelessDeviceEnum(this, grfFlags);
    if (penum)
    {
        hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        penum->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppenum = NULL;
    }
    return hr;
}

HRESULT CWirelessDeviceFolder::_GetName(LPCWIRELESSITEM pmdi, LPTSTR pszName, LPTSTR pszAddress, LPTSTR pszTransport)
{
    LPCWSTR psz = pmdi->szName;
    UINT cch = lstrlen(psz) + 1;
    if (pszName)
        StrCpy(pszName, psz);

    psz += cch;
    cch = lstrlen(psz) + 1;
    if (pszAddress)
        StrCpy(pszAddress, psz);

    psz += cch;
    cch = lstrlen(psz) + 1;
    if (pszTransport)
        StrCpy(pszTransport, psz);

    return S_OK;
}

HRESULT CWirelessDeviceFolder::_Device(LPCWIRELESSITEM pmdi, REFIID riid, void **ppv)
{
    TCHAR szName[MAX_PATH], szAddress[64], szTransport[64];
    HRESULT hr = _GetName(pmdi, szName, szAddress, szTransport);
    if (SUCCEEDED(hr))
    {
        IPropertyBag *ppb;
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            // store the class ID for the CD mastering folder
            SHPropertyBag_WriteStr(ppb, L"Name", szName);
            SHPropertyBag_WriteStr(ppb, L"Address", szAddress);
            SHPropertyBag_WriteStr(ppb, L"Transport", szTransport);

            IObex *pobex;
            hr = _GetObex(IID_PPV_ARG(IObex, &pobex));
            if (SUCCEEDED(hr))
            {
                IObexDevice *pdev;
                hr = pobex->BindToDevice(ppb, &pdev);
                if (SUCCEEDED(hr))
                {
                    if (riid == IID_IStorage)
                        hr = pdev->BindToStorage(OBEX_DEVICE_CAP_PUSH, (IStorage **)ppv);
                    else
                        hr = pdev->QueryInterface(riid, ppv);
                    pdev->Release();
                }
                pobex->Release();
            }
            ppb->Release();
        }
    }
    return hr;
}

HRESULT CWirelessDeviceFolder::_CreateStgFolder(LPCITEMIDLIST pidl, IStorage *pstg, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IPersistStorage *ppstg;
    HRESULT hr = CoCreateInstance(CLSID_StgFolder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistStorage, &ppstg));
    if (SUCCEEDED(hr))
    {
        hr = ppstg->Load(pstg);
        if (SUCCEEDED(hr))
        {
            IPersistFolder *ppf;
            hr = ppstg->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Initialize(pidl);
                if (SUCCEEDED(hr))
                    hr = ppf->QueryInterface(riid, ppv);
                ppf->Release();
            }
        }
        ppstg->Release();
    }
    return hr;
}


HRESULT CWirelessDeviceFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_NOINTERFACE;
    LPCWIRELESSITEM pmdi = _IsValid(pidl);
    if (pmdi && _IsFolder(pmdi))
    {
        if (IID_IShellFolder == riid ||
            IID_IShellFolder2 == riid)
        {
            IStorage *pstg;
            hr = _Device(pmdi, IID_PPV_ARG(IStorage, &pstg));
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlNext = _ILNext(pidl);
                LPITEMIDLIST pidlSubFolder = ILCombineParentAndFirst(_pidl, pidl, pidlNext);
                if (pidlSubFolder)
                {
                    IShellFolder *psf;
                    hr = _CreateStgFolder(pidlSubFolder, pstg, IID_PPV_ARG(IShellFolder, &psf));
                    if (SUCCEEDED(hr))
                    {
                        // if there's nothing left in the pidl, get the interface on this one.
                        if (ILIsEmpty(pidlNext))
                            hr = psf->QueryInterface(riid, ppv);
                        else
                        {
                            // otherwise, hand the rest of it off to the new shellfolder.
                            hr = psf->BindToObject(pidlNext, pbc, riid, ppv);
                        }
                        psf->Release();
                    }
                    ILFree(pidlSubFolder);
                }
                else
                    hr = E_OUTOFMEMORY;

                pstg->Release();
            }
        }
    }
    else
        hr = E_FAIL;

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && (NULL == *ppv)));   // Assert hr is consistent w/out param.
    return hr;
}

enum
{
    DEV_COL_NAME = 0,
    DEV_COL_SIZE,
    DEV_COL_TYPE,
    DEV_COL_MODIFIED,
};

HRESULT CWirelessDeviceFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCWIRELESSITEM pmdi1 = _IsValid(pidl1);
    LPCWIRELESSITEM pmdi2 = _IsValid(pidl2);
    int nCmp = 0;

    if (!pmdi1 || !pmdi2)
        return E_INVALIDARG;

    // folders always sort to the top of the list, if either of these items
    // are folders then compare on the folderness
    
    if (_IsFolder(pmdi1) || _IsFolder(pmdi2))
    {
        if (_IsFolder(pmdi1) && !_IsFolder(pmdi2))
            nCmp = -1;
        else if (!_IsFolder(pmdi1) && _IsFolder(pmdi2))
            nCmp = 1;
    }

    // if they match (or are not folders, then lets compare based on the column ID.

    if (nCmp == 0)
    {
        switch (lParam & SHCIDS_COLUMNMASK)
        {
            case DEV_COL_NAME:          // caught later on
                break;

            case DEV_COL_SIZE:
            {
                if (pmdi1->cbTotal.QuadPart < pmdi2->cbTotal.QuadPart)
                    nCmp = -1;
                else if (pmdi1->cbTotal.QuadPart > pmdi2->cbTotal.QuadPart)
                    nCmp = 1;
                break;
            }

            case DEV_COL_TYPE:
            {
                TCHAR szType1[MAX_PATH], szType2[MAX_PATH];
                _GetTypeOf(pmdi1, szType1, ARRAYSIZE(szType1));
                _GetTypeOf(pmdi2, szType2, ARRAYSIZE(szType2));
                nCmp = StrCmpI(szType1, szType2);
                break;
            }

            case DEV_COL_MODIFIED:
            {
                if (pmdi1->ulModified.QuadPart < pmdi2->ulModified.QuadPart)
                    nCmp = -1;
                else if (pmdi1->ulModified.QuadPart > pmdi2->ulModified.QuadPart)
                    nCmp = 1;
                break;
            }
        }

        if (nCmp == 0)
        {
            nCmp = ualstrcmpi(pmdi1->szName, pmdi2->szName);
        }
    }
    
    return ResultFromShort(nCmp);
}


HRESULT CWirelessDeviceFolder::_OnGetNotify(DWORD pv, LPITEMIDLIST *ppidl, LONG *plEvents)
{
    *ppidl = _pidl;
    *plEvents = SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER | \
                SHCNE_CREATE | SHCNE_DELETE | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | \
                SHCNE_MKDIR | SHCNE_RMDIR;
    return S_OK;
}


STDMETHODIMP CWirelessDeviceFolder::MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    switch (uMsg)
    {
        HANDLE_MSG(0, SFVM_BACKGROUNDENUM, _OnBackgroundEnum);
        HANDLE_MSG(0, SFVM_GETNOTIFY, _OnGetNotify);
    }
    return hr;
}

HRESULT CWirelessDeviceFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV = { 0 };
        sSFV.cbSize = sizeof(sSFV);
        sSFV.psfvcb = this;
        sSFV.pshf = this;
        hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        HKEY hkNoFiles = NULL;
        
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory\\Background"), &hkNoFiles);

        hr = CDefFolderMenu_Create2(_pidl, hwnd, 0, NULL, this, NULL,
                                    1, &hkNoFiles,  (IContextMenu **)ppv);
        if (hkNoFiles)
            RegCloseKey(hkNoFiles);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        CWirelessDeviceDropTarget *psdt = new CWirelessDeviceDropTarget(this, hwnd);
        if (psdt)
        {
            hr = psdt->QueryInterface(riid, ppv);
            psdt->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

ULONG CWirelessDeviceFolder::_GetAttributesOf(LPCWIRELESSITEM pmdi, ULONG rgfIn)
{
    return rgfIn & (SFGAO_FOLDER | SFGAO_CANLINK | SFGAO_CANCOPY | SFGAO_HASSUBFOLDER | SFGAO_HASPROPSHEET | SFGAO_DROPTARGET);
}

HRESULT CWirelessDeviceFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    UINT rgfOut = *prgfInOut;

    // return attributes of the namespace root?

    if (!cidl || !apidl)
    {
        rgfOut &= SFGAO_FOLDER | 
                  SFGAO_LINK | SFGAO_DROPTARGET |
                  SFGAO_CANRENAME | SFGAO_CANDELETE |
                  SFGAO_CANLINK | SFGAO_CANCOPY | 
                  SFGAO_CANMOVE | SFGAO_HASSUBFOLDER;
    }
    else
    {
        for (UINT i = 0; i < cidl; i++)
            rgfOut &= _GetAttributesOf(_IsValid(apidl[i]), *prgfInOut);
    }

    *prgfInOut = rgfOut;
    return S_OK;
}

HRESULT CALLBACK CWirelessDeviceFolder::_ItemsMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU:
        break;

    case DFM_INVOKECOMMANDEX:
    {
        DFMICS *pdfmics = (DFMICS *)lParam;
        switch (wParam)
        {
        case DFM_CMD_DELETE:
            // hr = StgDeleteUsingDataObject(hwnd, pdfmics->fMask, pdtobj);
            break;

        case DFM_CMD_PROPERTIES:
            break;

        default:
            // This is common menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;
    }

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

HRESULT CWirelessDeviceFolder::_CreateExtractIcon(LPCWIRELESSITEM pmdi, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (_IsFolder(pmdi))
    {
        UINT iIcon = II_FOLDER;
        UINT iIconOpen = II_FOLDEROPEN;

        TCHAR szModule[MAX_PATH];
        GetModuleFileName(g_hinst, szModule, ARRAYSIZE(szModule));

        hr = SHCreateDefExtIcon(szModule, iIcon, iIconOpen, GIL_PERCLASS, -1, riid, ppv);
    }
    return hr;
}

HRESULT CWirelessDeviceFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, 
                                  REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCWIRELESSITEM pmdi = cidl ? _IsValid(apidl[0]) : NULL;

    if (pmdi &&
        (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)))
    {
        WCHAR szName[MAX_PATH];
        _GetName(pmdi, szName, NULL, NULL);

        hr = SHCreateFileExtractIconW(szName, _IsFolder(pmdi), riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IDataObject) && cidl)
    {
        hr = CIDLData_CreateInstance(_pidl, cidl, apidl, NULL, (IDataObject **)ppv);
    }
#if 0    
    else if (IsEqualIID(riid, IID_IContextMenu) && pmdi)
    {
        // get the association for these files and lets attempt to 
        // build the context menu for the selection.   

        IQueryAssociations *pqa;
        hr = GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pmdi, IID_PPV_ARG_NULL(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            HKEY ahk[3];
            // this is broken for docfiles (shell\ext\stgfldr's keys work though)
            // maybe because GetClassFile punts when it's not fs?
            DWORD cKeys = SHGetAssocKeys(pqa, ahk, ARRAYSIZE(ahk));
            hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, 
                                        this, _ItemsMenuCB, cKeys, ahk, 
                                        (IContextMenu **)ppv);
            
            SHRegCloseKeys(ahk, cKeys);
            pqa->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations) && pmdi)
    {
        //  need to create a valid Assoc obj here
    }
#endif    
    else if (IsEqualIID(riid, IID_IDropTarget) && pmdi)
    {
        // If a directory is selected in the view, the drop is going to a folder,
        // so we need to bind to that folder and ask it to create a drop target

        if (_IsFolder(pmdi))
        {
            IShellFolder *psf;
            hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->CreateViewObject(hwnd, IID_IDropTarget, ppv);
                psf->Release();
            }
        }
        else
        {
            hr = CreateViewObject(hwnd, IID_IDropTarget, ppv);
        }
    }

    return hr;
}

HRESULT CWirelessDeviceFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *pStrRet)
{
    HRESULT hr;
    LPCWIRELESSITEM pmdi = _IsValid(pidl);
    if (pmdi)
    {
        WCHAR szName[MAX_PATH];
        _GetName(pmdi, szName, NULL, NULL);

        if (dwFlags & SHGDN_FORPARSING)
        {
            if (dwFlags & SHGDN_INFOLDER)
            {
                hr = StringToStrRetW(szName, pStrRet);          // relative name
            }
            else
            {
                TCHAR szTemp[MAX_PATH];
                SHGetNameAndFlags(_pidl, dwFlags, szTemp, ARRAYSIZE(szTemp), NULL);
                PathAppend(szTemp, szName);
                hr = StringToStrRetW(szTemp, pStrRet);
            }
        }
        else
        {
            hr = StringToStrRetW(szName, pStrRet);
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

HRESULT CWirelessDeviceFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD dwFlags, LPITEMIDLIST *ppidlOut)
{
    return E_NOTIMPL;
}

static const struct
{
    UINT iTitle;
    UINT cchCol;
    UINT iFmt;
} 
g_aMediaDeviceColumns[] = 
{
    {IDS_NAME_COL,     20, LVCFMT_LEFT},
    {IDS_SIZE_COL,     10, LVCFMT_RIGHT},
    {IDS_TYPE_COL,     20, LVCFMT_LEFT},
    {IDS_MODIFIED_COL, 20, LVCFMT_LEFT},
};

HRESULT CWirelessDeviceFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetail)
{
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];

    // is this a valid column?

    if (iColumn >= ARRAYSIZE(g_aMediaDeviceColumns))
        return E_NOTIMPL;
   
    pDetail->str.uType = STRRET_CSTR;
    pDetail->str.cStr[0] = 0;
    
    if (NULL == pidl)
    {
        pDetail->fmt = g_aMediaDeviceColumns[iColumn].iFmt;
        pDetail->cxChar = g_aMediaDeviceColumns[iColumn].cchCol;
        LoadString(g_hinst, g_aMediaDeviceColumns[iColumn].iTitle, szTemp, ARRAYSIZE(szTemp));
        hr = StringToStrRetW(szTemp, &(pDetail->str));
    }
    else
    {
        LPCWIRELESSITEM pmdi = _IsValid(pidl);
        if (pmdi)
        {
            // return the property to the caller that is being requested, this is based on the
            // list of columns we gave out when the view was created.
            WCHAR szName[MAX_PATH];
            _GetName(pmdi, szName, NULL, NULL);

            switch (iColumn)
            {
                case DEV_COL_NAME:
                    hr = StringToStrRetW(szName, &(pDetail->str));
                    break;
        
                case DEV_COL_SIZE:
                    if (!_IsFolder(pmdi))
                    {
                        ULARGE_INTEGER ullSize = pmdi->cbTotal;
                        StrFormatKBSize(ullSize.QuadPart, szTemp, ARRAYSIZE(szTemp));
                        hr = StringToStrRetW(szTemp, &(pDetail->str));
                    }
                    break;
        
                case DEV_COL_TYPE:
                {
                    SHFILEINFO sfi = { 0 };
                    if (SHGetFileInfo(szName, _IsFolder(pmdi), &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES|SHGFI_TYPENAME))
                        hr = StringToStrRetW(sfi.szTypeName, &(pDetail->str));
                    break;
                }

                case DEV_COL_MODIFIED:
                    SHFormatDateTime(&pmdi->ftModified, NULL, szTemp, ARRAYSIZE(szTemp));
                    hr = StringToStrRetW(szTemp, &(pDetail->str));
                    break;
            }             
        }
    }    
    return hr;
}

// IDelegateFolder
HRESULT CWirelessDeviceFolder::SetItemAlloc(IMalloc *pmalloc)
{
    IUnknown_Set((IUnknown**)&_pmalloc, pmalloc);
    return S_OK;
}

CWirelessDeviceEnum::CWirelessDeviceEnum(CWirelessDeviceFolder *pmdf, DWORD grfFlags) : _cRef(1), _grfFlags(grfFlags)
{
    _pwdf = pmdf;
    _pwdf->AddRef();

    IObex *pobex;
    if (SUCCEEDED(_pwdf->_GetObex(IID_PPV_ARG(IObex, &pobex))))
    {
        CoMarshalInterThreadInterfaceInStream(IID_IObex, pobex, &_pstmDevice);
        pobex->Release();
    }

    DllAddRef();
}

CWirelessDeviceEnum::~CWirelessDeviceEnum()
{
    ATOMICRELEASE(_pobex);
    ATOMICRELEASE(_pDeviceEnum);
    ATOMICRELEASE(_pstmDevice);

    _pwdf->Release();
    DllRelease();
}

STDMETHODIMP_(ULONG) CWirelessDeviceEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CWirelessDeviceEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CWirelessDeviceEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CWirelessDeviceEnum, IEnumIDList),                    // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

void CWirelessDeviceEnum::_UnMarshall()
{
    if (_pstmDevice)
        CoGetInterfaceAndReleaseStream(_pstmDevice, IID_PPV_ARG(IObex, &_pobex));
    _pstmDevice = NULL;
}

HRESULT CWirelessDeviceEnum::_InitEnum()
{
    HRESULT hr = S_OK;

    _UnMarshall();

    if (NULL == _pDeviceEnum)
    {
        hr = _pobex ? _pobex->EnumDevices(&_pDeviceEnum, CLSID_NULL) : E_FAIL;
    }
    return hr;
}

HRESULT CWirelessDeviceEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = _InitEnum();
    if (SUCCEEDED(hr))
    {
        for (UINT cItems = 0; (cItems != celt) && (S_OK == hr); )
        {
            LPITEMIDLIST pidl;

            ULONG ulFetched;
            IObexDevice *pdev;
            hr = _pDeviceEnum->Next(1, &pdev, &ulFetched);
            if (S_OK == hr && ulFetched)
            {
                hr = _pwdf->_IDListForDevice(pdev, &pidl);
                pdev->Release();
            }
            else
                hr = S_FALSE;

            if (S_OK == hr)
            {
                if (!(_grfFlags & SHCONTF_FOLDERS))
                {
                    ILFree(pidl);
                    pidl = NULL;
                    continue;
                }
                rgelt[cItems++] = pidl;         // return the idlist
            }
        }
        if (pceltFetched)
            *pceltFetched = cItems;
    }
    return hr;
}

STDMETHODIMP CWirelessDeviceEnum::Reset() 
{ 
    ATOMICRELEASE(_pDeviceEnum); 
    return S_OK; 
}


CWirelessDeviceDropTarget::CWirelessDeviceDropTarget(CWirelessDeviceFolder *pmdf, HWND hwnd) :
    _cRef(1), _pwdf(pmdf), _hwnd(hwnd), _grfKeyStateLast(-1)
{
    _pwdf->AddRef();
    DllAddRef();
}

CWirelessDeviceDropTarget::~CWirelessDeviceDropTarget()
{
    DragLeave();
    ATOMICRELEASE(_pwdf);
    DllRelease();
}

STDMETHODIMP_(ULONG) CWirelessDeviceDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CWirelessDeviceDropTarget::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CWirelessDeviceDropTarget::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CWirelessDeviceDropTarget, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CWirelessDeviceDropTarget::_Transfer(IDataObject *pdtobj, UINT uiCmd)
{
    return E_FAIL;
}


DWORD CWirelessDeviceDropTarget::_GetDropEffect(DWORD *pdwEffect, DWORD grfKeyState)
{
    DWORD dwEffectReturned = DROPEFFECT_NONE;
    switch (grfKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT))
    {
    case MK_CONTROL:            dwEffectReturned = DROPEFFECT_COPY; break;
    case MK_SHIFT:              dwEffectReturned = DROPEFFECT_MOVE; break;
    case MK_SHIFT | MK_CONTROL: dwEffectReturned = DROPEFFECT_LINK; break;
    case MK_ALT:                dwEffectReturned = DROPEFFECT_LINK; break;
    
    default:
        {
            // no modifier keys:
            // if the data object contains a preferred drop effect, try to use it
            DWORD dwPreferred = DataObj_GetDWORD(_pdtobj, g_cfPreferredDropEffect, DROPEFFECT_NONE) & *pdwEffect;
            if (dwPreferred)
            {
                if (dwPreferred & DROPEFFECT_MOVE)
                {
                    dwEffectReturned = DROPEFFECT_MOVE;
                }
                else if (dwPreferred & DROPEFFECT_COPY)
                {
                    dwEffectReturned = DROPEFFECT_COPY;
                }
                else if (dwPreferred & DROPEFFECT_LINK)
                {
                    dwEffectReturned = DROPEFFECT_LINK;
                }
            }
            else
            {
                dwEffectReturned = DROPEFFECT_COPY;
            }
        }
        break;
    }
    return dwEffectReturned;
}

STDMETHODIMP CWirelessDeviceDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    _grfKeyStateLast = grfKeyState;

    if (pdwEffect)
        *pdwEffect = _dwEffectLastReturned = _GetDropEffect(pdwEffect, grfKeyState);

    return S_OK;
}

STDMETHODIMP CWirelessDeviceDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // has the key state changed?  if not then lets return the previously cached 
    // version, otherwise recompute.

    if (_grfKeyStateLast == grfKeyState)
    {
        if (*pdwEffect)
            *pdwEffect = _dwEffectLastReturned;
    }
    else if (*pdwEffect)
    {
        *pdwEffect = _GetDropEffect(pdwEffect, grfKeyState);
    }

    _dwEffectLastReturned = *pdwEffect;
    _grfKeyStateLast = grfKeyState;

    return S_OK;
}
 
STDMETHODIMP CWirelessDeviceDropTarget::DragLeave()
{
    ATOMICRELEASE(_pdtobj);
    return S_OK;
}

STDMETHODIMP CWirelessDeviceDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_NONE;           // incase of failure

    // determine the type of operation to performed, if the right button is down
    // then lets display the menu, otherwise base it on the drop effect

    UINT idCmd = 0;                             // Choice from drop popup menu
    if (!(_grfKeyStateLast & MK_LBUTTON))
    {
        HMENU hMenu = SHLoadPopupMenu(g_hinst, POPUP_NONDEFAULTDD);
        if (!hMenu)
        {
            DragLeave();
            return E_FAIL;
        }
        
        SetMenuDefaultItem(hMenu, POPUP_NONDEFAULTDD, FALSE);
        idCmd = TrackPopupMenu(hMenu, 
                               TPM_RETURNCMD|TPM_RIGHTBUTTON|TPM_LEFTALIGN,
                               pt.x, pt.y, 0, _hwnd, NULL);
        DestroyMenu(hMenu);
    }
    else
    {
        switch (_GetDropEffect(pdwEffect, grfKeyState))
        {
        case DROPEFFECT_COPY:   idCmd = DDIDM_COPY; break;
        case DROPEFFECT_MOVE:   idCmd = DDIDM_MOVE; break;
        case DROPEFFECT_LINK:   idCmd = DDIDM_LINK; break;
        }
    }

    // now perform the operation, based on the command ID we have.

    HRESULT hr = E_FAIL;
    switch (idCmd)
    {
    case DDIDM_COPY:
    case DDIDM_MOVE:
        hr = _Transfer(pdtobj, idCmd);
        if (SUCCEEDED(hr))
            *pdwEffect = (idCmd == DDIDM_COPY) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;
        else
            *pdwEffect = 0;
        break;

    case DDIDM_LINK:
    {
        WCHAR wzPath[MAX_PATH];
        SHGetNameAndFlags(_pwdf->_pidl, SHGDN_FORPARSING, wzPath, ARRAYSIZE(wzPath), NULL);

        hr = SHCreateLinks(_hwnd, wzPath, pdtobj, 0, NULL);
        break;
    }
    }
    
    // success so lets populate the new changes to the effect

    if (SUCCEEDED(hr) && *pdwEffect)
    {
        DataObj_SetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, *pdwEffect);
        DataObj_SetDWORD(pdtobj, g_cfPerformedDropEffect, *pdwEffect);
    }

    DragLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ynlist.h ===
#ifndef _YNLIST_H
#define _YNLIST_H


typedef struct {

    LPTSTR pszzList;            // Double NULL terminated list of directories
    UINT  cbAlloc;              // Space allocated to list, in BYTEs
    UINT  cchUsed;              // Space used in list, in CHARacters
    BOOL  fEverythingInList;    // TRUE if everything is considered on the list

} DIRLIST, *PDIRLIST;

typedef struct {

    DIRLIST dlYes;              // List of YES directories
    DIRLIST dlNo;               // List of NO directories

} YNLIST, *PYNLIST;

STDAPI_(void) CreateYesNoList(PYNLIST pynl);
STDAPI_(void) DestroyYesNoList(PYNLIST pynl);
STDAPI_(BOOL) IsInYesList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(BOOL) IsInNoList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(void) AddToYesList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(void) AddToNoList(PYNLIST pynl, LPCTSTR szItem);
STDAPI_(void) SetYesToAll(PYNLIST pynl);

#endif  // _YNLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ynlist.c ===
#include "shellprv.h"
#include "ynlist.h"

#define YNLIST_ALLOC    (2 * MAX_PATH * sizeof(TCHAR))

//
// Constructor - creates a YesNoList
//
void CreateYesNoList(PYNLIST pynl)
{
    ZeroMemory(pynl, sizeof(*pynl));
}

//
// Destructor - frees and destroys a YesNoList
//
void DestroyYesNoList(PYNLIST pynl)
{
    if (pynl->dlYes.pszzList)
        GlobalFree(pynl->dlYes.pszzList);
    if (pynl->dlNo.pszzList)
        GlobalFree(pynl->dlNo.pszzList);
    ZeroMemory(pynl, sizeof(*pynl));
}

//
// IsPathOfItem - determine if pszPath is on the path to pszItem
//
BOOL IsPathOfItem(LPCTSTR pszPath, LPCTSTR pszItem)
{
    //
    // Validate pszPath is the first
    // substring of pszItem.
    //
    while (*pszPath)
    {
        if (*pszPath != *pszItem)
        {
            return FALSE;
        }

        pszPath++;
        pszItem++;
    }

    //
    // pszPath is the path if pszItem is empty (exact match),
    // or pszItem is a directory separator.
    //
    return (*pszItem == TEXT('\\')) || (*pszItem == TEXT('\0'));
}

//
// IsInDirList - determines if DIRLIST contains
// the path to pszItem.
//
BOOL IsInDirList(PDIRLIST pdl, LPCTSTR pszItem)
{
    LPTSTR pszzList;

    //
    // Quick check for everything flag.
    //
    if (pdl->fEverythingInList)
        return TRUE;

    //
    // Quick check for empty list.
    //
    if (pdl->pszzList == NULL)
    {
        return FALSE;
    }

    //
    // Compare against each string in the szz list.
    //
    pszzList = pdl->pszzList;
    while (*pszzList)
    {
        //
        // If pszList is the beginning of the path to pszItem,
        // the item is in the list.
        //
        if (IsPathOfItem(pszzList, pszItem))
        {
            return TRUE;
        }

        pszzList += lstrlen(pszzList) + 1;
    }

    //
    // Couldn't find it.
    //
    return FALSE;
}

//
// IsInYesList - determine if an item is in the
// yes list of a YesNoList.
//
BOOL IsInYesList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    return IsInDirList(&pynl->dlYes, pszItem);
}

//
// IsInNoList - determine if an item is in the
// no list of a YesNoList.
//
BOOL IsInNoList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    return IsInDirList(&pynl->dlNo, pszItem);
}

//
// AddToDirList - adds an item to a dir list if necessary.
//
void AddToDirList(PDIRLIST pdl, LPCTSTR pszItem)
{
    UINT cchItem;

    //
    // Is the item already in the list?
    //
    if (IsInDirList(pdl, pszItem))
    {
        return;
    }

    //
    // Is the list empty?
    //
    if (pdl->pszzList == NULL)
    {
        pdl->pszzList = (LPTSTR)GlobalAlloc(GPTR, YNLIST_ALLOC);

        if (pdl->pszzList == NULL)
        {
            return;
        }

        pdl->cbAlloc = YNLIST_ALLOC;
        pdl->cchUsed = 1;
        ASSERT(pdl->pszzList[0] == TEXT('\0'));
    }

    //
    // Get the string length,
    // verify it can be added with
    // at most one additional alloc.
    //
    cchItem = lstrlen(pszItem) + 1;
    if (CbFromCch(cchItem) >= YNLIST_ALLOC)
    {
        return;
    }

    //
    // Do we need to allocate more space?
    //
    if (CbFromCch(cchItem) > pdl->cbAlloc - CbFromCch(pdl->cchUsed))
    {
        LPTSTR pszzNew;

        pszzNew = (LPTSTR)GlobalReAlloc(pdl->pszzList, pdl->cbAlloc + YNLIST_ALLOC, GMEM_MOVEABLE|GMEM_ZEROINIT);

        if (pszzNew == NULL)
        {
            return;
        }
        pdl->pszzList = pszzNew;

        pdl->cbAlloc += YNLIST_ALLOC;
    }

    //
    // Add the item.
    //
    lstrcpy(&(pdl->pszzList[pdl->cchUsed - 1]), pszItem);
    pdl->cchUsed += cchItem;

    //
    // Add the second NULL terminator
    // (GlobalReAlloc can't guarantee zeromeminit)
    //
    pdl->pszzList[pdl->cchUsed - 1] = TEXT('\0');
}

//
// Adds an item to the Yes list.
//
void AddToYesList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    AddToDirList(&pynl->dlYes, pszItem);
}

//
// Adds an item to the No list.
//
void AddToNoList(PYNLIST pynl, LPCTSTR pszItem)
{
    //
    // Call helper function.
    //
    AddToDirList(&pynl->dlNo, pszItem);
}

//
// SetYesToAll - puts everything in the yes list.
//
void SetYesToAll(PYNLIST pynl)
{
    pynl->dlYes.fEverythingInList = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\xiconwrap.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "xiconwrap.h"

// IUnknown
STDMETHODIMP CExtractIconBase::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CExtractIconBase, IExtractIconA),
        QITABENT(CExtractIconBase, IExtractIconW),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CExtractIconBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CExtractIconBase::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

CExtractIconBase::CExtractIconBase() : _cRef(1)
{
    DllAddRef();
}

CExtractIconBase::~CExtractIconBase()
{
    DllRelease();
}

// IExtractIconA
STDMETHODIMP CExtractIconBase::GetIconLocation(UINT uFlags,
    LPSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags)
{
    WCHAR sz[MAX_PATH];
    HRESULT hr = _GetIconLocationW(uFlags, sz, ARRAYSIZE(sz), piIndex, pwFlags);
    if (S_OK == hr)
    {
        // We don't want to copy the icon file name on the S_FALSE case
        SHUnicodeToAnsi(sz, pszIconFile, cchMax);
    }

    return hr;
}

STDMETHODIMP CExtractIconBase::Extract(LPCSTR pszFile, UINT nIconIndex,
    HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize)
{
    WCHAR sz[MAX_PATH];

    SHAnsiToUnicode(pszFile, sz, ARRAYSIZE(sz));
    return _ExtractW(sz, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}

// IExtractIconW
STDMETHODIMP CExtractIconBase::GetIconLocation(UINT uFlags,
    LPWSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags)
{
    return _GetIconLocationW(uFlags, pszIconFile, cchMax, piIndex, pwFlags);
}

STDMETHODIMP CExtractIconBase::Extract(LPCWSTR pszFile, UINT nIconIndex,
    HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize)
{
    return _ExtractW(pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\xiconwrap.h ===
// Helper to create a IExtractIcon handler.
//
// Usage:
//      (1) Derive from CExtractIconBase to implement your business logic by
//          overloading CExtractIconBase two virtual member fcts
//              ex: class CEIBMyDerivedClass : public CExtractIconBase
//
//      (2) Add a few Initalization member fcts
//              ex: HRESULT CEIBMyDerivedClass::MyInit(MyData1* p1, MyData2* p2);
//
//      (3) Create your derived object using the new operator, 
//              ex: CEIBMyDerivedClass* peibmdc = new ...
//
//      (4) Initialize it (using (2)),
//              ex: hr = peibmdc->MyInit(p1, p2);
//

class CExtractIconBase : public IExtractIconA, public IExtractIconW
{
public:
    // IExtractIconA
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize);

    // IExtractIconW
    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCWSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize);

    // IUnknown helpers
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // derived class implements these
    virtual HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile,
        UINT cchMax, int *piIndex, UINT *pwFlags) PURE;
    virtual HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex,
        HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize) PURE;

    CExtractIconBase();

protected:
    virtual ~CExtractIconBase();

private:
    LONG _cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\downlevel\dl_thunks.c ===
#define _SHELL32_ 1 // we implement shell32 fn's

#include <windows.h>
#include <winnt.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>

// The following functions do NOT exist in NT4sp6's non-integrate shell32, so we implement them 
// here so that browseui and shdocvw can link to shell32.nt4 and this code lib (downlevel_shell32.lib)

HMODULE DL_GetSHELL32()
{
    static HMODULE hmod = (HMODULE)-1;

    if (hmod == (HMODULE)-1)
    {
        hmod = LoadLibraryA("shell32.dll");
    }

    return hmod;
}


typedef HRESULT (* PFNSHDefExtractIconA) (LPCSTR, int, UINT, HICON*, HICON*, UINT);
STDAPI DL_SHDefExtractIconA(
    LPCSTR pszIconFile,
    int iIndex,
    UINT uFlags,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHDefExtractIconA pfn = (PFNSHDefExtractIconA)-1;

        if (pfn == (PFNSHDefExtractIconA)-1)
        {
            pfn = (PFNSHDefExtractIconA)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(3));
        }
        
        if (pfn)
        {
            return pfn(pszIconFile, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
        }
    }

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}
PFNSHDefExtractIconA g_pfnDL_SHDefExtractIconA = &DL_SHDefExtractIconA;


typedef HRESULT (* PFNSHStartNetConnectionDialogW) (HWND, LPCWSTR, DWORD);
STDAPI DL_SHStartNetConnectionDialogW(
    HWND hwnd,
    LPCWSTR pszRemoteName,
    DWORD dwType
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHStartNetConnectionDialogW pfn = (PFNSHStartNetConnectionDialogW)-1;

        if (pfn == (PFNSHStartNetConnectionDialogW)-1)
        {
            pfn = (PFNSHStartNetConnectionDialogW)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(14));
        }
        
        if (pfn)
        {
            return pfn(hwnd, pszRemoteName, dwType);
        }
    }

    return S_OK;
}
PFNSHStartNetConnectionDialogW g_pfnDL_SHStartNetConnectionDialogW = &DL_SHStartNetConnectionDialogW;


typedef BOOL (* PFNDAD_DragEnterEx2) (HWND, const POINT, IDataObject*);
STDAPI_(BOOL) DL_DAD_DragEnterEx2(
    HWND hwndTarget,
    const POINT ptStart,
    IDataObject* pdtObject
    )
{
    // DAD_DragEnterEx2 only exists on v5 shell32 and higher
    if (GetUIVersion() >= 5)
    {
        static PFNDAD_DragEnterEx2 pfn = (PFNDAD_DragEnterEx2)-1;

        if (pfn == (PFNDAD_DragEnterEx2)-1)
        {
            pfn = (PFNDAD_DragEnterEx2)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(22));
        }
        
        if (pfn)
        {
            return pfn(hwndTarget, ptStart, pdtObject);
        }
    }

    // this exists on downlevel shell32, so we fall back to calling the older api
    return DAD_DragEnterEx(hwndTarget, ptStart);
}
PFNDAD_DragEnterEx2 g_pfnDL_DAD_DragEnterEx2 = &DL_DAD_DragEnterEx2;


typedef void (* PFNSHUpdateImageW) (LPCWSTR, int, UINT, int);
STDAPI_(void) DL_SHUpdateImageW(
    LPCWSTR pszHashItem,
    int iIndex,
    UINT uFlags,
    int iImageIndex
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHUpdateImageW pfn = (PFNSHUpdateImageW)-1;

        if (pfn == (PFNSHUpdateImageW)-1)
        {
            pfn = (PFNSHUpdateImageW)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(192));
        }
        
        if (pfn)
        {
            pfn(pszHashItem, iIndex, uFlags, iImageIndex);
            return;
        }
    }
}
PFNSHUpdateImageW g_pfnDL_SHUpdateImageW = &DL_SHUpdateImageW;


typedef int (* PFNSHHandleUpdateImage) (LPCITEMIDLIST);
STDAPI_(int) DL_SHHandleUpdateImage(
    LPCITEMIDLIST pidlExtra
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHHandleUpdateImage pfn = (PFNSHHandleUpdateImage)-1;

        if (pfn == (PFNSHHandleUpdateImage)-1)
        {
            pfn = (PFNSHHandleUpdateImage)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(193));
        }
        
        if (pfn)
        {
            return pfn(pidlExtra);
        }
    }

    return -1;
}
PFNSHHandleUpdateImage g_pfnDL_SHHandleUpdateImage = &DL_SHHandleUpdateImage;


typedef HRESULT (* PFNSHLimitInputEdit) (HWND, IShellFolder*);
STDAPI DL_SHLimitInputEdit(
    HWND hwndEdit,
    IShellFolder *psf
    )
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        static PFNSHLimitInputEdit pfn = (PFNSHLimitInputEdit)-1;

        if (pfn == (PFNSHLimitInputEdit)-1)
        {
            pfn = (PFNSHLimitInputEdit)GetProcAddress(DL_GetSHELL32(), MAKEINTRESOURCEA(747));
        }
        
        if (pfn)
        {
            return pfn(hwndEdit, psf);
        }
    }

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}
PFNSHLimitInputEdit g_pfnDL_SHLimitInputEdit = DL_SHLimitInputEdit;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\downlevel\makefile.inc ===
$(O)\dl_thunk.lst : dl_thunks.lst
    mkalias.cmd $** $(O)
    copy $** $@

$(O)\alias.lib : $(O)\dl_thunk.lst
    link -lib -out:$@ $(O)\alias_*.obj

$(PROJECT_ROOT)\lib\$(O)\downlevel_shell32.lib : $(O)\downlevel_shell32.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\_security.h ===
/**************************************************************\
    FILE: _security.h

    DESCRIPTION:
        This file will contain helper functions and objects that
    help deal with security.  This mainly means Zones Security, but
    can include other types.

    We can't call this file "security.h" because there's already
    a file with that name in sdk\inc.
\**************************************************************/

#ifndef __SECURITY_H
#define __SECURITY_H

#include <urlmon.h>

SHSTDAPI ZoneCheckPidl(LPCITEMIDLIST pidl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);

#endif // __SECURITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\bands.cpp ===
#include "shellprv.h"
#include "bands.h"
#include "util.h"

#include "..\inc\bands.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__

#include "clsobj.h"

// For use with VC6
#pragma warning(4:4242)  //'initializing' : conversion from 'unsigned int' to 'unsigned short', possible loss of data


#define NO_CFVTBL
#include <cfdefs.h>
#include <exdispid.h>
#include <htiframe.h>
#include <mshtmhst.h>
#include <brutil.h>

#include "ids.h"

#define EnterModeless() AddRef()       // Used for selfref'ing
#define ExitModeless() Release()

#define SID_SDropBlocker CLSID_SearchBand
#define DLL_IS_UNICODE         (sizeof(TCHAR) == sizeof(WCHAR))
#define LoadMenuPopup(id) SHLoadMenuPopup(MLGetHinst(), id)   

#define MAX_TOOLTIP_STRING 80
#define REG_SUBKEY_FAVORITESA            "\\MenuOrder\\Favorites"
#define REG_SUBKEY_FAVORITES             TEXT(REG_SUBKEY_FAVORITESA)

// Command group for private communication with CITBar
// 67077B95-4F9D-11D0-B884-00AA00B60104
const GUID CGID_PrivCITCommands = { 0x67077B95L, 0x4F9D, 0x11D0, 0xB8, 0x84, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };


// IBandNavigate
//  band needs to navigate its UI to a specific pidl.
#undef  INTERFACE
#define INTERFACE  IBandNavigate
DECLARE_INTERFACE_(IBandNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBandNavigate methods ***
    STDMETHOD(Select)(THIS_ LPCITEMIDLIST pidl) PURE;

} ;

#define TF_SHDREF           TF_MENUBAND
#define TF_BAND             TF_MENUBAND      // Bands (ISF Band, etc)

#define DF_GETMSGHOOK       0x00001000      // GetMessageFilter 
#define DF_TRANSACCELIO     0x00002000      // GetMessageFilter 
#define THID_TOOLBARACTIVATED       6

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\bands.h ===
#include "../inc/bands.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\basebar.cpp ===
#include "shellprv.h"
#include "apithk.h"
#include "basebar.h"

#define DBM_ONPOSRECTCHANGE  (WM_USER)


//*** CBaseBar::IDeskBar::* {
//


/*----------------------------------------------------------
Purpose: IDeskBar::SetClient

         Usually the function that composes a bar/bandsite/band
         union is responsible for calling this method to inform
         the bar what the client (bandsite) is.

*/
HRESULT CBaseBar::SetClient(IUnknown *punkChild)
{
    if (_punkChild != NULL)
    {
        // 4, 3, 2, 1 Release
        _hwndChild = NULL;

        if (_pDBC)
        {
            // This must happen first, before _pWEH becomes NULL so cleanup
            // notifications can still go thru
            _pDBC->SetDeskBarSite(NULL);
        }

        ATOMICRELEASE(_pDBC);

        ATOMICRELEASE(_pWEH);

        ATOMICRELEASE(_punkChild);
    }

    _punkChild = punkChild;

    HRESULT hr = S_OK;
    if (_punkChild != NULL)
    {
        // 1, 2, 3, 4 QI/AddRef/etc.
        _punkChild->AddRef();
        if (!_hwnd)
        {
            _RegisterDeskBarClass();
            _CreateDeskBarWindow();
            if (!_hwnd)
            {
                return E_OUTOFMEMORY;
            }

            // can't do CBaseBar::_Initialize yet (haven't done SetSite yet)
        }

        hr = _punkChild->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pWEH));
        if (SUCCEEDED(hr))
        {
            hr = _punkChild->QueryInterface(IID_PPV_ARG(IDeskBarClient, &_pDBC));
            if (SUCCEEDED(hr))
            {
                // nothing to cache yet due to lazy CreateWindow
                hr = _pDBC->SetDeskBarSite(SAFECAST(this, IDeskBar*));

                IUnknown_GetWindow(_punkChild, &_hwndChild);
            }
        }
    }

    return hr;
}

HRESULT CBaseBar::GetClient(IUnknown **ppunk)
{
    *ppunk = _punkChild;
    if (_punkChild)
        _punkChild->AddRef();
    return _punkChild ? S_OK : E_FAIL;
}

HRESULT CBaseBar::OnPosRectChangeDB(LPRECT prc)
{
    _szChild.cx = RECTWIDTH(*prc);
    _szChild.cy = RECTHEIGHT(*prc);

    // We can't change our size right away because we haven't returned from processing
    // this WM_SIZE message. If we resize right now, USER gets confused...
    //
    // We cannot use PeekMessage to determine if there is already a pending
    // DBM_ONPOSRECTCHANGE because that allows incoming SendMessage's to
    // arrive, and then we can get into a bad recursive situation when there
    // are a lot of SHChangeNotify's arriving in rapid succession.
    //
    if (!_fPosRectChangePending)
    {
        _fPosRectChangePending = TRUE;
        PostMessage(_hwnd, DBM_ONPOSRECTCHANGE, 0, 0);
    }

    return S_OK;
}

//  Derived classes are expected to implement this method and do something
//  interesting...
void CBaseBar::_OnPostedPosRectChange()
{
}

// }

HRESULT CBaseBar::ShowDW(BOOL fShow)
{
    fShow = BOOLIFY(fShow);

    if (BOOLIFY(_fShow) == fShow)
        return S_OK;

    _fShow = fShow;

    if (_pDBC)
        return _pDBC->UIActivateDBC(fShow ? DBC_SHOW : DBC_HIDE);
    else
        return E_UNEXPECTED;
}

void CBaseBar::_OnCreate()
{
    SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
}

LRESULT CBaseBar::_OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}


/***
 */
LRESULT CBaseBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch (uMsg) {
    case WM_CREATE:
        _OnCreate();
        break;

    case WM_COMMAND:
        return _OnCommand(uMsg, wParam, lParam);
        

    case WM_SIZE:     
        _OnSize();    
        break;

    case WM_NOTIFY:
        return _OnNotify(uMsg, wParam, lParam);

    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
    case WM_PALETTECHANGED:
        _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);
        break;

    case DBM_ONPOSRECTCHANGE:
        _fPosRectChangePending = FALSE;
        _OnPostedPosRectChange();
        break;

    default:
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

/***
 */
CBaseBar::CBaseBar() : _cRef(1)
{
    DllAddRef();
}

/***
 */
CBaseBar::~CBaseBar()
{
    // see Release, where we call virtuals (which can't be called from dtor)
    DllRelease();
}

/***
 */
void CBaseBar::_RegisterDeskBarClass()
{
    WNDCLASS  wc = {0};
    wc.style            = _GetClassStyle();
    wc.lpfnWndProc      = s_WndProc;
    //wc.cbClsExtra       = 0;
    wc.cbWndExtra       = SIZEOF(CBaseBar*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE+1);
    //wc.lpszMenuName     =  NULL;
    wc.lpszClassName    = TEXT("BaseBar");
    //wc.hIcon            = NULL;

    SHRegisterClass(&wc);
}

DWORD CBaseBar::_GetExStyle()
{
    return WS_EX_TOOLWINDOW;
}

DWORD CBaseBar::_GetClassStyle()
{
    return 0;
}

void CBaseBar::_CreateDeskBarWindow()
{
    // _hwnd is set in s_WndProc
    DWORD dwExStyle = _GetExStyle();    
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;
    HWND hwndDummy = CreateWindowEx(
                                    dwExStyle,
                                    TEXT("BaseBar"), NULL,
                                    _hwndSite ? WS_CHILD | WS_CLIPCHILDREN : WS_POPUP | WS_CLIPCHILDREN,
                                    0,0,100,100,
                                    _hwndSite, NULL, HINST_THISDLL,
                                    (LPVOID)SAFECAST(this, CImpWndProc*));
}


void CBaseBar::_OnSize(void)
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);
    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER);
}

void CBaseBar::_NotifyModeChange(DWORD dwMode)
{
    if (_pDBC) {
        _dwMode = dwMode;
        // FEATURE: should we add an STBBIF_VIEWMODE_FLOAT?
        _pDBC->SetModeDBC(_dwMode);
    }
}

BOOL CBaseBar::_CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwnd = NULL;

    *plres = 0;
    switch (uMsg)
    {
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        hwnd = _hwndChild;
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        hwnd = _hwndChild;
        break;
    }
    
    if (hwnd && _pWEH && _pWEH->IsWindowOwner(hwnd) == S_OK)
    {
        _pWEH->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
        return TRUE;
    }
    return FALSE;
}

/***
 */
LRESULT CBaseBar::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}

HRESULT CBaseBar::CloseDW(DWORD dwReserved)
{
    SetClient(NULL);
    if (_hwnd) {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    return S_OK;
}


HRESULT CBaseBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBaseBar, IOleWindow),
        QITABENT(CBaseBar, IDeskBar),
        QITABENT(CBaseBar, IInputObject),
        QITABENT(CBaseBar, IInputObjectSite),
        QITABENT(CBaseBar, IServiceProvider),
        QITABENT(CBaseBar, IOleCommandTarget),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}


ULONG CBaseBar::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBaseBar::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    // 'virtual dtor'
    // gotta do virtual stuff here (not in dtor) because can't call
    // any virtuals in the dtor
    // CBaseBar::Destroy() {
    CloseDW(0);
    // }

    delete this;
    return 0;
}

//*** CBaseBar::IOleWindow::* {
//

HRESULT CBaseBar::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return (_hwnd) ? S_OK : E_FAIL;
}

HRESULT CBaseBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    // FEATURE: Visit here later.
    return E_NOTIMPL;
}
// }


// }
// some helpers... {

// What's the point of having
// these empty implementations in the base class?
//

//*** CBaseBar::IServiceProvider::*
//
HRESULT CBaseBar::QueryService(REFGUID guidService,
                                REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;

    return hres;
}

//*** CBaseBar::IOleCommandTarget::*
//
HRESULT CBaseBar::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return MayQSForward(_pDBC, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CBaseBar::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return MayExecForward(_pDBC, OCTD_DOWN, pguidCmdGroup, nCmdID, nCmdexecopt,
        pvarargIn, pvarargOut);
}

// }


//*** CDeskBar::IInputObject::* {

HRESULT CBaseBar::HasFocusIO()
{
    HRESULT hres;

    hres = IUnknown_HasFocusIO(_pDBC);
    return hres;
}

HRESULT CBaseBar::TranslateAcceleratorIO(LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_TranslateAcceleratorIO(_pDBC, lpMsg);
    return hres;
}

HRESULT CBaseBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_UIActivateIO(_pDBC, fActivate, lpMsg);
    return hres;
}

// }

//***   CDeskBar::IInputObjectSite::* {

HRESULT CBaseBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\cwndproc.h ===
#include "..\inc\cwndproc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\cwndproc.cpp ===
#include "shellprv.h"
#include "util.h"

#define g_fNewNotify TRUE
#define _SHChangeNotification_Lock SHChangeNotification_Lock
#define _SHChangeNotification_Unlock SHChangeNotification_Unlock

#include "..\inc\cwndproc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\basebar.h ===
#ifndef BaseBar_H_
#define BaseBar_H_
#include "cwndproc.h"

#ifdef __cplusplus

//========================================================================
// class CBaseBar (CBaseBar* pwbar)
//========================================================================
class CBaseBar : public IOleCommandTarget
               , public IServiceProvider
               , public IDeskBar
                ,public IInputObjectSite
                ,public IInputObject
               , public CImpWndProc
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk);
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient);
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

protected:
    // Constructor & Destructor
    CBaseBar();
    virtual ~CBaseBar();
   
    BOOL _CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);    

    virtual void _NotifyModeChange(DWORD dwMode); // NOTE: we may be abhe to get rid of this virtual...
    void _GetBorderRect(RECT* prc);

    virtual STDMETHODIMP ShowDW(BOOL fShow); // match IDockingWindow::ShowDW
    virtual STDMETHODIMP CloseDW(DWORD dwReserved); // match IDockingWindow::CloseDW
    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual LRESULT _OnNotify(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual void _OnSize(void);
    virtual void _OnCreate();
    virtual void _OnPostedPosRectChange();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();

    // Window procedure
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    

    // Member variables
    UINT            _cRef;                  // reference count
    IUnknown*       _punkChild;             // ptr to IUnknown  for client area
    IDeskBarClient*     _pDBC;              // cached BaseBarClient for _punkChild
    IWinEventHandler*   _pWEH;              // cached IWenEventHandler for _punkChild
    HWND            _hwndChild;             // cached HWND      for _punkChild
    HWND            _hwndSite;              // hwnd of the site

    BOOL            _fShow :1;
    BOOL            _fPosRectChangePending;

    DWORD           _dwMode;

    SIZE            _szChild;               // last requested size from child

private:
    // Private members
    void _RegisterDeskBarClass();
    void _CreateDeskBarWindow();

};

#endif // __cplusplus
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\dpastuff.cpp ===
#include "shellprv.h"
#include "util.h"
#include "common.h"

#define _WorA_Shell_GetCachedImageIndex Shell_GetCachedImageIndex
#define IEILCreate _ILCreate

#include "..\inc\dpastuff.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\fadetsk.h ===
#ifndef _FADETSK_H
#define _FADETSK_H

class CFadeTask : public IFadeTask
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IFadeTask ***
    STDMETHODIMP FadeRect(LPCRECT prc);

private:
    friend HRESULT CFadeTask_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    CFadeTask();
    ~CFadeTask();

    void _DoPreFade();
    void _DoFade();
    void _StopFade();

    static DWORD WINAPI s_FadeThreadProc(LPVOID lpThreadParameter);
    static DWORD WINAPI s_FadeSyncProc(LPVOID lpThreadParameter);

    LONG        _cRef;
    HWND        _hwndFader;
    RECT        _rect;
    HDC         _hdcFade;
    HBITMAP     _hbm;
    HBITMAP     _hbmOld;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\droptgt.cpp ===
#include "shellprv.h"

#define TF_SHDLIFE          TF_MENUBAND
#define TF_BAND             TF_MENUBAND      // Bands (ISF Band, etc)


void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject);
void _DragMove(HWND hwndTarget, const POINTL ptStart);


#include "..\inc\droptgt.h"
#include "..\inc\droptgt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\droptgt.h ===
#include "../inc/droptgt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\icotask.cpp ===
#include "shellprv.h"
#include "brutil.h"
#include "icotask.h"

// {EB30900C-1AC4-11d2-8383-00C04FD918D0}
static const GUID TASKID_IconExtraction = 
{ 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

CIconTask::CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId):
    _pidl(pidl), _pfn(pfn), _pvData(pvData), _uId(uId), CRunnableTask(RTF_DEFAULT)
   
{ 
    
}

CIconTask::~CIconTask()
{
    if (_pidl)
        ILFree(_pidl);
}

// IRunnableTask methods (override)
STDMETHODIMP CIconTask::RunInitRT(void)
{
    int iIndex = -1;
    IShellFolder* psf;
    LPCITEMIDLIST pidlItem;

    // We need to rebind because shell folders may not be thread safe.
    HRESULT hr = IEBindToParentFolder(_pidl, &psf, &pidlItem);

    if (SUCCEEDED(hr))
    {
        iIndex = SHMapPIDLToSystemImageListIndex(psf, pidlItem, NULL);
        psf->Release();
    }

    _pfn(_pvData, _uId, iIndex);
    return S_OK;        // return S_OK even if we don't get an icon.
}


// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98

HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder, 
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, 
                    UINT uId, int* piTempIcon)
{
    if (!pts)
        return E_INVALIDARG;


    HRESULT hr = E_PENDING;
    TCHAR szIconFile[MAX_PATH];


    // The shell has a concept of GIL_ASYNC which means that an extension called with this flag
    // should not really load the target file, it should "Fake" it, returning an icon for the type.
    // Later, on a background thread, we're going to call it again without the GIL_ASYNC, and at
    // that time, it should really extract the icon.

    // This is an optimiation for slow icon extraction, such as network shares

    // NOTE: There is significant overhead to actually loading the shell extension. If you know the
    // type of the item, pass NULL to piTempIcopn


    if (piTempIcon)
    {
        *piTempIcon = -1;

        UINT uFlags;
        IExtractIconA* pixa;
        IExtractIconW* pix;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidl, IID_X_PPV_ARG(IExtractIconW, NULL, &pix))))
        {
            hr = pix->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFile, ARRAYSIZE(szIconFile), piTempIcon, &uFlags);
            pix->Release();
        }
        else if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1,(LPCITEMIDLIST*)&pidl, IID_X_PPV_ARG(IExtractIconA, NULL, &pixa))))
        {
            char szIconFileA[MAX_PATH];
            hr = pixa->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFileA, ARRAYSIZE(szIconFileA), piTempIcon, &uFlags);
            SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
            pixa->Release();
        }
    }

    if (hr == E_PENDING)
    {
        if (piTempIcon)
            *piTempIcon = Shell_GetCachedImageIndex(szIconFile, *piTempIcon, 0);

        LPITEMIDLIST pidlFull;
        if (psf)
            pidlFull = ILCombine(pidlFolder, pidl);
        else
            pidlFull = (LPITEMIDLIST)pidl;

        hr = E_OUTOFMEMORY;
        CIconTask* pit = new CIconTask(pidlFull, pfn, pvData, uId);
        // Don't ILFree(pidlFull) because CIconTask takes ownership.
        // FEATURE (lamadio) Remove this from the memory list. Ask Saml how to do this
        // for the IMallocSpy stuff.

        if (pit)
        {
            hr = pts->AddTask(SAFECAST(pit, IRunnableTask*), TASKID_IconExtraction, 
                ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);

            pit->Release();
        }
    }
    else
    {
        *piTempIcon = SHMapPIDLToSystemImageListIndex(psf, pidl, NULL);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\icotask.h ===
#ifndef CIconTask_h
#define CIconTask_h

#include <runtask.h>

typedef void (*PFNICONTASKBALLBACK)(LPVOID pvData, UINT uId, UINT iIconIndex);

class CIconTask : public CRunnableTask
{
public:
#if 0   // Needed if we implement multiple interfaces
    // IUnknown methods
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CRunnableTask::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) 
        { return CRunnableTask::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
        { return CRunnableTask::QueryInterface(riid, ppvObj); };
#endif

    // IRunnableTask methods (override)
    virtual STDMETHODIMP RunInitRT(void);

    CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId);
private:
    virtual ~CIconTask();


    LPITEMIDLIST        _pidl;
    PFNICONTASKBALLBACK _pfn;
    LPVOID              _pvData;
    UINT                _uId;
};

// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98
HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder,
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId, 
                    int* piTempIcon);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\fadetsk.cpp ===
#include "shellprv.h"
#include "common.h"
#include "fadetsk.h"

BOOL BlendLayeredWindow(HWND hwnd, HDC hdcDest, POINT* ppt, SIZE* psize, HDC hdc, POINT* pptSrc, BYTE bBlendConst)
{
    BLENDFUNCTION blend;
    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bBlendConst;

    return UpdateLayeredWindow(hwnd, hdcDest, ppt, psize, hdc, pptSrc, 0, &blend, ULW_ALPHA);
}

/// Fade Rect Support

CFadeTask::CFadeTask()
{
    _cRef = 1;

    WNDCLASSEX wc = {0};
    if (!GetClassInfoEx(g_hinst, TEXT("SysFader"), &wc)) 
    {
        wc.cbSize          = sizeof(wc);
        wc.lpfnWndProc     = DefWindowProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hInstance       = g_hinst;
        wc.lpszClassName   = TEXT("SysFader");
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;

        // If this fails we just wind up with a NULL _hwndFader
        RegisterClassEx(&wc);
    }
    _hwndFader = CreateWindowEx(WS_EX_LAYERED | WS_EX_TRANSPARENT | 
                            WS_EX_TOPMOST | WS_EX_TOOLWINDOW, 
                            TEXT("SysFader"), TEXT("SysFader"),
                            WS_POPUP,
                            0, 0, 0, 0, NULL, (HMENU) 0, 
                            g_hinst, NULL);
}

STDAPI CFadeTask_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    *ppv = NULL;

    ASSERT(!punkOuter); // clsobj.c should've filtered this out already
    CFadeTask *ptFader = new CFadeTask();
    if (ptFader)
    {
        hr = ptFader->QueryInterface(riid, ppv);
        ptFader->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


CFadeTask::~CFadeTask()
{
    // Must use WM_CLOSE instead of DestroyWindow to ensure proper
    // destruction in case the final release occurs from the background
    // thread.  (Threads are not allowed to DestroyWindow windows that
    // are owned by other threads.)

    if (_hwndFader)
        SendNotifyMessage(_hwndFader, WM_CLOSE, 0, 0);
}

HRESULT CFadeTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFadeTask, IFadeTask),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}


ULONG CFadeTask::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFadeTask::Release(void)
{
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (cRef)
        return cRef;

    delete this;
    return 0;
}


#define ALPHASTART (200)

HRESULT CFadeTask::FadeRect(LPCRECT prc)
{
    BOOL fThreadStarted = FALSE;

    if (_hwndFader)
    {
        _rect = *prc;

        POINT   pt;
        POINT   ptSrc = {0, 0};
        SIZE    size;

        // prc and pt are in screen coordinates.
        pt.x = _rect.left;
        pt.y = _rect.top;

        // Get the size of the rectangle for the blits.
        size.cx = RECTWIDTH(_rect);
        size.cy = RECTHEIGHT(_rect);

        // Get the DC for the screen and window.
        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            HDC hdcWin = GetDC(_hwndFader);
            if (hdcWin)
            {
                // If we don't have a HDC for the fade, then create one.
                if (!_hdcFade)
                {
                    _hdcFade = CreateCompatibleDC(hdcScreen);
                    if (!_hdcFade)
                        goto Stop;

                    // Create a bitmap that covers the fade region, instead of the whole screen.
                    _hbm = CreateCompatibleBitmap(hdcScreen, size.cx, size.cy);
                    if (!_hbm)
                        goto Stop;

                    // select it in, saving the old bitmap's handle
                    _hbmOld = (HBITMAP)SelectBitmap(_hdcFade, _hbm);
                }

                // Get the stuff from the screen and squirt it into the fade dc.
                BitBlt(_hdcFade, 0, 0, size.cx, size.cy, hdcScreen, pt.x, pt.y, SRCCOPY);

                // Now let user do it's magic. We're going to mimic user and start with a slightly
                // faded, instead of opaque, rendering (Looks smoother and cleaner.
                BlendLayeredWindow(_hwndFader, hdcWin, &pt, &size, _hdcFade, &ptSrc, ALPHASTART);

                fThreadStarted = SHCreateThread(s_FadeThreadProc, this, 0, s_FadeSyncProc);
        Stop:
                ReleaseDC(_hwndFader, hdcWin);
            }

            ReleaseDC(NULL, hdcScreen);
        }

        if (!fThreadStarted)
        {
            // clean up member variables on failure
            _StopFade();
        }
    }

    return fThreadStarted ? S_OK : E_FAIL;
}



#define FADE_TIMER_ID 10
#define FADE_TIMER_TIMEOUT 10 // milliseconds
#define FADE_TIMEOUT 350 // milliseconds
#define FADE_ITERATIONS 35
#define QUAD_PART(a) ((a)##.QuadPart)

void CFadeTask::_StopFade()
{
    if (_hdcFade)
    {
        if (_hbmOld)
        {
            SelectBitmap(_hdcFade, _hbmOld);
        }
        DeleteDC(_hdcFade);
        _hdcFade = NULL;
    }
    
    if (_hbm)
    {
        DeleteObject(_hbm);
        _hbm = NULL;
    }
}

DWORD CFadeTask::s_FadeSyncProc(LPVOID lpThreadParameter)
{
    CFadeTask* pThis = (CFadeTask*)lpThreadParameter;
    pThis->AddRef();
    pThis->_DoPreFade();
    return 0;
}

DWORD CFadeTask::s_FadeThreadProc(LPVOID lpThreadParameter)
{
    CFadeTask* pThis = (CFadeTask*)lpThreadParameter;
    pThis->_DoFade();
    pThis->Release();
    return 0;
}

void CFadeTask::_DoPreFade()
{
    // Now that we have it all build up, display it on screen.
    SetWindowPos(_hwndFader, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
}

void CFadeTask::_DoFade()
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;
    LARGE_INTEGER liStart;
    DWORD dwElapsed;
    BYTE bBlendConst;

    // Start the fade timer and the count-down for the fade.
    QueryPerformanceFrequency(&liFreq);
    QueryPerformanceCounter(&liStart);

    // Do this until the conditions specified in the loop.
    while ( TRUE )
    {
        // Calculate the elapsed time in milliseconds.
        QueryPerformanceCounter(&liDiff);
        QUAD_PART(liDiff) -= QUAD_PART(liStart);
        dwElapsed = (DWORD)((QUAD_PART(liDiff) * 1000) / QUAD_PART(liFreq));

        if (dwElapsed >= FADE_TIMEOUT) 
        {
            goto Stop;
        }

        bBlendConst = (BYTE)(ALPHASTART * (FADE_TIMEOUT - 
                dwElapsed) / FADE_TIMEOUT);

        if (bBlendConst <= 1) 
        {
            goto Stop;
        }

        // Since only the alpha is updated, there is no need to pass
        // anything but the new alpha function. This saves a source copy.
        if (!BlendLayeredWindow(_hwndFader, NULL, NULL, NULL, NULL, NULL, bBlendConst))
        {
            // The app we just launched probably switched the screen into
            // a video mode that doesn't support layered windows, so just bail.
            goto Stop;
        }
        Sleep(FADE_TIMER_TIMEOUT);
    }

Stop:
    SetWindowPos(_hwndFader, HWND_BOTTOM, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);

    _StopFade();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\isfmenu.h ===
// CISFMenuCallback implementation

#ifndef _ISFMENU_H
#define _ISFMENU_H

#include "cowsite.h"

class CISFMenuCallback : public IShellMenuCallback,
                           public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);

    CISFMenuCallback();
    HRESULT Initialize(IUnknown* punk);

private:
    virtual ~CISFMenuCallback();

    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    BOOL _IsVisible(LPITEMIDLIST pidl);
    HRESULT _GetSFInfo(LPSMDATA psmd, PSMINFO psminfo);

    int _cRef;
    IOleCommandTarget* _poct;    // our isfband subject
    IUnknown* _punkSite;
    LPITEMIDLIST _pidl;
};

#endif // _ISFMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\iaccess.cpp ===
#include "shellprv.h"
// APPCOMPAT (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "apithk.h"
#include "mnbandid.h"
#include "initguid.h"
#include "iaccess.h"

#include "mluisupp.h"

CAccessible::CAccessible(HMENU hmenu, WORD wID):
    _hMenu(hmenu), _wID(wID), _cRef(1)
{
    _fState = MB_STATE_TRACK;
}

CAccessible::CAccessible(IMenuBand* pmb): _cRef(1)
{
    _fState = MB_STATE_MENU;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::CAccessible(IMenuBand* pmb, int iIndex): _cRef(1)
{
    _fState = MB_STATE_ITEM;
    _iAccIndex = iIndex;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::~CAccessible()
{
    ATOMICRELEASE(_pTypeInfo);
    ATOMICRELEASE(_pInnerAcc);
    switch (_fState)
    {
    case MB_STATE_TRACK:
        ASSERT(!_hwndMenuWindow || IsWindow(_hwndMenuWindow));
        if (_hwndMenuWindow)
        {
            // Don't Destroy hmenu. It's part of a larger one...
            SetMenu(_hwndMenuWindow, NULL);
            DestroyWindow(_hwndMenuWindow);
            _hwndMenuWindow = NULL;
        }
        break;

    case MB_STATE_ITEM:
        ATOMICRELEASE(_pmtbItem);
        // Fall Through

    case MB_STATE_MENU:
        ATOMICRELEASE(_pmtbTop);
        ATOMICRELEASE(_pmtbBottom);
        ATOMICRELEASE(_psma);
        ATOMICRELEASE(_pmb);
        break;
    }
}

HRESULT CAccessible::InitAcc()
{
    HRESULT hr = E_FAIL;
    if (_fInitialized)
        return NOERROR;

    _fInitialized = TRUE;   // We're initialized if we fail or not...

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (EVAL(_hMenu))
        {
            _hwndMenuWindow = CreateWindow(TEXT("static"),
                TEXT("MenuWindow"), WS_POPUP, 0, 0, 0, 0, NULL,
                _hMenu, g_hinst, NULL);
            if (EVAL(_hwndMenuWindow))
            {
                IAccessible* paccChild1;
                hr = CreateStdAccessibleObject(_hwndMenuWindow, OBJID_MENU, IID_PPV_ARG(IAccessible, &paccChild1));
                if (SUCCEEDED(hr))
                {
                    VARIANT varChild;
                    varChild.vt = VT_I4;
                    varChild.lVal = _wID + 1;        //Accesibility is 1 based

                    // In order to get "On par" with the OleAcc's implementation of the HMENU wrapper,
                    // we need to do this twice. Once gets us the IAccessible for the "MenuItem" on the 
                    // "Menubar". The second gets us the "Menuitem's" child. This is what we need to emulate
                    // their heirarchy.
                    IDispatch* pdispChild1;
                    hr = paccChild1->get_accChild(varChild, &pdispChild1);

                    // OLEAcc returns a Success code (S_FALSE) while initializing the out param to zero.
                    // Explicitly test this situation.

                    // Does this have a Child?
                    if (hr == S_OK)
                    {
                        // Yes. Look for that child
                        IAccessible* paccChild2;
                        hr = pdispChild1->QueryInterface(IID_PPV_ARG(IAccessible, &paccChild2));

                        // Does this have a child?
                        if (hr == S_OK)
                        {
                            // Yep, then we store this guy's child...
                            IDispatch* pdispChild2;
                            varChild.lVal = 1;        //Get the first child
                            hr = paccChild2->get_accChild(varChild, &pdispChild2);
                            if (hr == S_OK)
                            {
                                hr = pdispChild2->QueryInterface(IID_PPV_ARG(IAccessible, &_pInnerAcc));
                                pdispChild2->Release();
                            }
                            paccChild2->Release();
                        }
                        pdispChild1->Release();
                    }
                    paccChild1->Release();
                }
            }
        }
        break;


    case MB_STATE_ITEM:
    case MB_STATE_MENU:
        hr = _pmb->QueryInterface(IID_PPV_ARG(IShellMenuAcc, &_psma));
        if (SUCCEEDED(hr))
        {
            _psma->GetTop(&_pmtbTop);
            _psma->GetBottom(&_pmtbBottom);
            if (!_pmtbTop || !_pmtbBottom)
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr) && (_fState == MB_STATE_ITEM))
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            if (SUCCEEDED(_GetChildFromVariant(&varChild, &_pmtbItem, &_iIndex)))
                _idCmd = GetButtonCmd(_pmtbItem->_hwndMB, _iIndex);
        }

        break;
    }

    return hr;
}



/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CAccessible::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = 
    {
        QITABENT(CAccessible, IDispatch),
        QITABENT(CAccessible, IAccessible),
        QITABENT(CAccessible, IEnumVARIANT),
        QITABENT(CAccessible, IOleWindow),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);

    return hres;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfoCount method

*/
STDMETHODIMP CAccessible::GetTypeInfoCount(UINT * pctinfo)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfoCount(pctinfo);
    *pctinfo = 1;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfo method

*/
STDMETHODIMP CAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    *pptinfo = NULL;
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfo(itinfo, lcid, pptinfo);

    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (EVAL(_LoadTypeLib()))
    {
        *pptinfo = _pTypeInfo;
        _pTypeInfo->AddRef();
        return NOERROR;
    }
    else
        return E_FAIL;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetIDsOfNames method

*/
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
        LCID lcid, DISPID * rgdispid)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }
    else
        return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDispatch::Invoke method

*/
STDMETHODIMP CAccessible::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,
    UINT * puArgErr)

{
    if (_pInnerAcc)
        return _pInnerAcc->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, 
            pexcepinfo, puArgErr);
    
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->Invoke(static_cast<IDispatch*>(this),
            dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
        return E_FAIL;
}

BOOL CAccessible::_LoadTypeLib()
{
    ITypeLib* pTypeLib;
    if (_pTypeInfo)
        return TRUE;

    if (SUCCEEDED(LoadTypeLib(L"oleacc.dll", &pTypeLib)))
    {
        pTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &_pTypeInfo);
        ATOMICRELEASE(pTypeLib);
        return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accParent method

*/
STDMETHODIMP CAccessible::get_accParent(IDispatch ** ppdispParent)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accParent(ppdispParent);
        break;

    case MB_STATE_MENU:
        {
            IUnknown* punk;
            if (SUCCEEDED(_psma->GetParentSite(IID_PPV_ARG(IUnknown, &punk))))
            {
                IAccessible* pacc;
                if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                    IID_PPV_ARG(IAccessible, &pacc))))
                {
                    VARIANT varChild = {VT_I4, CHILDID_SELF};     // Init
                    hres = pacc->get_accFocus(&varChild);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->get_accChild(varChild, ppdispParent);
                    }
                    VariantClear(&varChild);
                    pacc->Release();
                }
                else
                {
                    // Another implementation headache: Accessibility requires
                    // us to return S_FALSE when there is no parent.

                    *ppdispParent = NULL;
                    hres = S_FALSE;
                }

                punk->Release();
            }

            return hres;
        }
    case MB_STATE_ITEM:
        // The parent of an item is the menuband itself
        return IUnknown_QueryService(_psma, SID_SMenuPopup, IID_PPV_ARG(IDispatch, ppdispParent));
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChildCount method

*/
STDMETHODIMP CAccessible::get_accChildCount(long * pChildCount)
{   
    *pChildCount = 0;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChildCount(pChildCount);
        break;

    case MB_STATE_MENU:
        {
            int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
            int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
            *pChildCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;
        }
        break;
    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            *pChildCount = 1;
        break;

    }
    
    return NOERROR;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChild method

*/
STDMETHODIMP CAccessible::get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChild(varChildIndex, ppdispChild);
        break;

    case MB_STATE_MENU:
        {
            if (varChildIndex.vt == VT_I4 && varChildIndex.lVal == CHILDID_SELF)
            {
                // So this is the ONLY menthod that is allowed to fail when something is
                // unavailable.
                *ppdispChild = NULL;
                hres = E_INVALIDARG;
            }
            else
            {
                int iIndex;
                // Since it's returing an index, we don't need to test the success case
                _GetChildFromVariant(&varChildIndex, NULL, &iIndex);
                hres = _GetAccessibleItem(iIndex, ppdispChild);
            }
        }
        break;

    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
        {
            VARIANT varChild;
            hres = _GetVariantFromChildIndex(_pmtbItem->_hwndMB, _iIndex, &varChild);
            if (SUCCEEDED(hres))
            {
                hres = _psma->GetSubMenu(&varChild, IID_PPV_ARG(IDispatch, ppdispChild));
                if (FAILED(hres))
                {
                    hres = S_FALSE;
                }
            }
        }
        else
            hres = E_NOINTERFACE;
        break;
    }
    
    return hres;   
}

HRESULT CAccessible::_GetAccName(BSTR* pbstr)
{
    IDispatch* pdisp;
    HRESULT hres = get_accParent(&pdisp);
    // Get parent can return a success code, but still fail to return a parent.
    // 
    if (hres == S_OK)
    {
        IAccessible* pacc;
        hres = pdisp->QueryInterface(IID_PPV_ARG(IAccessible, &pacc));
        if (SUCCEEDED(hres))
        {
            VARIANT varChild;
            hres = pacc->get_accFocus(&varChild);
            if (SUCCEEDED(hres))
                hres = pacc->get_accName(varChild, pbstr);
        }
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accName method

*/
STDMETHODIMP CAccessible::get_accName(VARIANT varChild, BSTR* pszName)
{   
    CMenuToolbarBase* pmtb = _pmtbItem;
    int idCmd = _idCmd;
    int iIndex = _iIndex;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accName(varChild, pszName);
        break;

    case MB_STATE_MENU:
        if (varChild.lVal == CHILDID_SELF)
        {
            if (_GetAccName(pszName) == S_FALSE)
            {
                TCHAR sz[100];
                LoadString(HINST_THISDLL, IDS_ACC_APP, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
                if (!*pszName)
                    return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
        else
        {
            if (FAILED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                return DISP_E_MEMBERNOTFOUND;

            idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
        }

        // Fall Through

    case MB_STATE_ITEM:
        {
            TCHAR sz[MAX_PATH];
            int idString = 0;
            TBBUTTON tbb;
            if (ToolBar_GetButton(pmtb->_hwndMB, iIndex, &tbb) && 
                tbb.fsStyle & BTNS_SEP)
            {
                idString = IDS_ACC_SEP;
            }
            else if (pmtb->GetChevronID() == _idCmd)
            {
                idString = IDS_ACC_CHEVRON;
            }

            if (idString != 0)
            {
                LoadString(HINST_THISDLL, idString, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
            }
            else if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
            {
                SHStripMneumonic(sz);
                *pszName = SysAllocString(sz);
            }

            if (_fState == MB_STATE_MENU)
                pmtb->Release();

            if (!*pszName)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accValue method

*/
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR* pszValue)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accValue(varChild, pszValue);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        *pszValue = NULL;
        return S_FALSE;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDescription method

*/
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR * pszDescription)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDescription(varChild, pszDescription);
        break;

    case MB_STATE_MENU:
        if (FAILED(_GetAccName(pszDescription)))
        {
            TCHAR sz[100];
            LoadString(HINST_THISDLL, IDS_ACC_APPMB, sz, ARRAYSIZE(sz));
            *pszDescription = SysAllocStringT(sz);
            if (!*pszDescription)
                return E_OUTOFMEMORY;
        }
        break;
    case MB_STATE_ITEM:
        return get_accName(varChild, pszDescription);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accRole method

*/
STDMETHODIMP CAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{   
    pvarRole->vt = VT_I4;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accRole(varChild, pvarRole);
        break;

    case MB_STATE_MENU:
        {
            BOOL fVertical, fOpen;
            _psma->GetState(&fVertical, &fOpen);
            pvarRole->lVal = fVertical ? ROLE_SYSTEM_MENUPOPUP : ROLE_SYSTEM_MENUBAR;
            return NOERROR;
        }

    case MB_STATE_ITEM:
        pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accState method

*/
STDMETHODIMP CAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accState(varChild, pvarState);
        break;

    case MB_STATE_MENU:
        {
            // All menus can be selected, and given focus. Most will be visible.
            DWORD dwState = STATE_SYSTEM_FOCUSABLE;

            BOOL fOpen, fVertical;
            _psma->GetState(&fVertical, &fOpen);

            // Do we have a menu popped up?
            if (fOpen)
            {
                // Yes, then we have focus
                dwState |= STATE_SYSTEM_FOCUSED;
            }
            else if (fVertical)
            {
                // If we're a vertical menu without being popped up, then we're invisible.
                dwState |= STATE_SYSTEM_INVISIBLE;
            }


            pvarState->vt = VT_I4;
            pvarState->lVal = dwState;
        }
        return NOERROR;

    case MB_STATE_ITEM:
        {
            DWORD dwState = 0;

            TBBUTTON tbb;
            if (-1 != ToolBar_GetButton(_pmtbItem->_hwndMB, _iIndex, &tbb))
            {
                dwState = tbb.fsState; // ToolBar_GetState returns -1 for some menus, need to use ToolBar_GetButton
            }

            int idHotTracked = ToolBar_GetHotItem(_pmtbItem->_hwndMB);
            
            DWORD dwAccState;            
            if (dwState & TBSTATE_ENABLED)
            {
                dwAccState = STATE_SYSTEM_FOCUSABLE;
            }
            else
            {
                dwAccState = STATE_SYSTEM_UNAVAILABLE;
            }

            if (dwState & (TBSTATE_PRESSED | TBSTATE_ENABLED))
            {
                dwAccState |= STATE_SYSTEM_SELECTABLE | STATE_SYSTEM_FOCUSED;
            }

            if ((-1 != idHotTracked) && (idHotTracked == _iIndex))
            {
                dwAccState |= STATE_SYSTEM_HOTTRACKED;
            }

            if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            {
                dwAccState |= STATE_SYSTEM_HASPOPUP;
            }

            pvarState->vt = VT_I4;
            pvarState->lVal = dwAccState;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelp method

*/
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelp(varChild, pszHelp);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelpTopic method

*/
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

#define CH_PREFIX TEXT('&')

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault)
{
    TCHAR ch = (TCHAR)-1;
    LPCTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = CharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = CharNext(pszAccel);
        }
    } while (pszAccel && (ch == (TCHAR)-1));

    if ((ch == (TCHAR)-1) && bUseDefault)
    {
        // Since we're unicocde, we don't need to mess with MBCS
        ch = *psz;
    }

    return ch;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accKeyboardShortcut method

*/
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    *pszKeyboardShortcut = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        goto labelGetaccel;

    case MB_STATE_MENU:
        {
            if (varChild.lVal != CHILDID_SELF)
            {
                if (SUCCEEDED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                {
labelGetaccel:
                    TCHAR sz[MAX_PATH];
                    TCHAR szAccel[100] = TEXT("");
                    int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                    if (S_FALSE == _psma->IsEmpty())
                    {
                        if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                        {
                            BOOL fVertical, fOpen;
                            _psma->GetState(&fVertical, &fOpen);
                            if (!fVertical)
                            {
                                LoadString(HINST_THISDLL, IDS_ACC_ALT, szAccel, ARRAYSIZE(szAccel));
                            }
                            szAccel[lstrlen(szAccel)] = GetAccelerator(sz, TRUE);
                            szAccel[lstrlen(szAccel)] = TEXT('\0');
                            hres = S_OK;
                        }
                    }

                    if (SUCCEEDED(hres))
                    {
                        *pszKeyboardShortcut = SysAllocStringT(szAccel);
                        if (!*pszKeyboardShortcut)
                            hres = E_OUTOFMEMORY;
                    }
                    pmtb->Release();
                }
            }
        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accFocus method

*/
STDMETHODIMP CAccessible::get_accFocus(VARIANT * pvarFocusChild)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accFocus(pvarFocusChild);
        break;

    case MB_STATE_MENU:
        {
            pvarFocusChild->vt = VT_I4;
            pvarFocusChild->lVal = CHILDID_SELF;

            CMenuToolbarBase* pmtbTracked;
            _psma->GetTracked(&pmtbTracked);
            if (pmtbTracked)
            {
                int iIndex = ToolBar_GetHotItem(pmtbTracked->_hwndMB);
                hres = _GetVariantFromChildIndex(pmtbTracked->_hwndMB, 
                    iIndex, pvarFocusChild);
                pmtbTracked->Release();
            }
        }
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accSelection method

*/
STDMETHODIMP CAccessible::get_accSelection(VARIANT * pvarSelectedChildren)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accSelection(pvarSelectedChildren);
        break;

    case MB_STATE_MENU:
        return get_accFocus(pvarSelectedChildren);
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDefaultAction method

*/
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{   
    TCHAR sz[MAX_PATH];

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDefaultAction(varChild, pszDefaultAction);
        break;

    case MB_STATE_MENU:
        {
            LoadString(HINST_THISDLL, IDS_ACC_CLOSE, sz, ARRAYSIZE(sz));
            *pszDefaultAction = SysAllocStringT(sz);

            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }

    case MB_STATE_ITEM:
        {
            if (S_OK == _psma->IsEmpty())
            {
                sz[0] = TEXT('\0');
            }
            else
            {
                int iId = (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU) ? IDS_ACC_OPEN: IDS_ACC_EXEC;
                LoadString(HINST_THISDLL, iId, sz, ARRAYSIZE(sz));
            }

            *pszDefaultAction = SysAllocStringT(sz);
            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accSelect method

*/
STDMETHODIMP CAccessible::accSelect(long flagsSelect, VARIANT varChild)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accSelect(flagsSelect, varChild);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accLocation method

*/
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        hres = NOERROR;
        goto labelGetRect;

    case MB_STATE_MENU:
        {
            RECT rc;
            if (varChild.vt == VT_I4)
            {
                if (varChild.lVal == CHILDID_SELF)
                {
                    IUnknown* punk;
                    hres = _psma->GetParentSite(IID_PPV_ARG(IUnknown, &punk));
                    if (SUCCEEDED(hres))
                    {
                        IOleWindow* poct;
                        hres = IUnknown_QueryService(punk, SID_SMenuPopup, IID_PPV_ARG(IOleWindow, &poct));
                        if (SUCCEEDED(hres))
                        {
                            HWND hwnd;
                            hres = poct->GetWindow(&hwnd);
                            if (SUCCEEDED(hres))
                            {
                                // Return the window rect of the menubar.
                                GetWindowRect(hwnd, &rc);
                            }

                            poct->Release();
                        }

                        punk->Release();
                    }
                }
                else
                {
                    hres = _GetChildFromVariant(&varChild, &pmtb, &iIndex);
                    if (SUCCEEDED(hres))
                    {
labelGetRect:           int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                        if (!ToolBar_GetRect(pmtb->_hwndMB, idCmd, &rc))  //1 based index
                            hres = E_INVALIDARG;
                        MapWindowPoints(pmtb->_hwndMB, NULL, (LPPOINT)&rc, 2);
                        pmtb->Release();
                    }
                }

                if (SUCCEEDED(hres))
                {
                    *pxLeft = rc.left;
                    *pyTop = rc.top;
                    *pcxWidth = rc.right - rc.left;
                    *pcyHeight = rc.bottom - rc.top;
                }
            }
        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accNavigate method

*/
STDMETHODIMP CAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accNavigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_MENU:
        return _Navigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_ITEM:
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            return _Navigate(navDir, varChild, pvarEndUpAt);
        }
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accHitTest method

*/
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    POINT pt = {xLeft, yTop};
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
        break;

    case MB_STATE_MENU:
        {
            if (_psma)
            {
                int iIndex;
                HWND hwnd = WindowFromPoint(pt);

                if (hwnd == _pmtbTop->_hwndMB || hwnd == _pmtbBottom->_hwndMB)
                {
                    ScreenToClient(hwnd, &pt);
                    iIndex = ToolBar_HitTest(hwnd, &pt);
                    if (iIndex >= 0)
                    {
                        pvarChildAtPoint->vt = VT_DISPATCH;
                        // This call expects the index to be an "Accessible" index which is one based
                        VARIANT varChild;
                        _GetVariantFromChildIndex(hwnd, iIndex, &varChild);

                        //Since this is just returining an index, we don't need to test success
                        _GetChildFromVariant(&varChild, NULL, &iIndex);
                        return _GetAccessibleItem(iIndex, &pvarChildAtPoint->pdispVal);
                    }
                }

                // Hmm, must be self
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;

                return S_OK;
            }
        }
        break;

    case MB_STATE_ITEM:
        {
            RECT rc;
            MapWindowPoints(NULL, _pmtbItem->_hwndMB, &pt, 1);

            if (ToolBar_GetRect(_pmtbItem->_hwndMB, _idCmd, &rc) &&
                PtInRect(&rc, pt))
            {
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;
            }
            else
            {
                pvarChildAtPoint->vt = VT_EMPTY;
                pvarChildAtPoint->lVal = (DWORD)(-1);
            }
            return NOERROR;
        }
        break;

    }
    
    return DISP_E_MEMBERNOTFOUND;
}

/*----------------------------------------------------------
Purpose: IAccessible::accDoDefaultAction method

*/
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accDoDefaultAction(varChild);
        break;

    case MB_STATE_MENU:
        if (_psma)
            return _psma->DoDefaultAction(&varChild);
        break;

    case MB_STATE_ITEM:
        if (SendMessage(_pmtbItem->_hwndMB, TB_SETHOTITEM2, _iIndex, 
            HICF_OTHER | HICF_RESELECT | HICF_TOGGLEDROPDOWN))
            return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accName method

*/
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->put_accName(varChild, szName);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accValue method

*/
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR pszValue)  
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
       if (_pInnerAcc)
            return _pInnerAcc->put_accValue(varChild, pszValue);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}


HRESULT CAccessible::_Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    ASSERT(pvarEndUpAt);
    int iIndex = 0;         // 1 based index
    int iTBIndex;
    HRESULT hres = S_FALSE;
    TBBUTTONINFO tbInfo;
    int idCmd;
    VARIANT varTemp;
    CMenuToolbarBase* pmtb;
    BOOL fVertical;
    BOOL fOpen;


    tbInfo.cbSize = sizeof(TBBUTTONINFO);

    pvarEndUpAt->vt = VT_DISPATCH;
    pvarEndUpAt->pdispVal = NULL;

    _GetChildFromVariant(&varStart, NULL, &iIndex);

    _psma->GetState(&fVertical, &fOpen);
    if (!fVertical)
    {
        static const long navMap[] = 
        {
            NAVDIR_LEFT,    // Map to Up
            NAVDIR_RIGHT,   // Map to Down
            NAVDIR_UP,      // Map to Left
            NAVDIR_DOWN,    // Map to Right
        };
        if (IsInRange(navDir, NAVDIR_UP, NAVDIR_RIGHT))
            navDir = navMap[navDir - NAVDIR_UP];
    }

    switch (navDir)
    {
    case NAVDIR_NEXT:
        {
            VARIANT varVert = {0};
            // For the Vertical case, Next should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                ASSERT(VT_BOOL == varVert.vt);
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_DOWN:
        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex++;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    case NAVDIR_FIRSTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }

        iIndex = 0;
        hres = NOERROR;
        break;

    case NAVDIR_LASTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }
        iIndex = -1;
        hres = NOERROR;
        break;

    case NAVDIR_LEFT:
        pvarEndUpAt->vt = VT_DISPATCH;
        return get_accParent(&pvarEndUpAt->pdispVal);
        break;

    case NAVDIR_RIGHT:
        {
            CMenuToolbarBase* pmtb = (varStart.lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
            int idCmd = GetButtonCmd(pmtb->_hwndMB, (varStart.lVal & ~TOOLBAR_MASK) - 1);
            if (pmtb->v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                IMenuPopup* pmp;
                hres = _psma->GetSubMenu(&varStart, IID_PPV_ARG(IMenuPopup, &pmp));
                if (SUCCEEDED(hres))
                {
                    IAccessible* pacc;
                    hres = IUnknown_QueryService(pmp, SID_SMenuBandChild, IID_PPV_ARG(IAccessible, &pacc));
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->accNavigate(NAVDIR_FIRSTCHILD, varStart, pvarEndUpAt);
                        pacc->Release();
                    }
                    pmp->Release();
                }
            }

                return hres;
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            VARIANT varVert = {0};
            // For the Vertical case, Pervious should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                ASSERT(VT_BOOL == varVert.vt);
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_UP:
        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex--;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    if (iTBIndex == 0)    
                    {   
                        hres = S_FALSE;
                        //Don't navigate to self, allow the top bar to get a whack.
                        IUnknown* punk;
                        if (SUCCEEDED(_psma->GetParentSite(IID_PPV_ARG(IUnknown, &punk))))
                        {
                            IOleCommandTarget* poct;
                            if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                IID_PPV_ARG(IOleCommandTarget, &poct))))
                            {
                                VARIANT varVert = {0};

                                if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                                    varVert.boolVal == VARIANT_FALSE)
                                {
                                    ASSERT(VT_BOOL == varVert.vt);

                                    IAccessible* pacc;
                                    if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                        IID_PPV_ARG(IAccessible, &pacc))))
                                    {
                                        VARIANT varChild = {VT_I4, CHILDID_SELF};
                                        hres = pacc->get_accFocus(&varChild);
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pacc->get_accChild(varChild, &pvarEndUpAt->pdispVal);
                                        }

                                        VariantClear(&varChild);
                                        pacc->Release();
                                    }
                                }
                                poct->Release();
                            }
                            punk->Release();
                        }
                    }   // iTBIndex == 0

                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    default:
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres) && S_FALSE != hres)
        hres = _GetAccessibleItem(iIndex, &pvarEndUpAt->pdispVal);

    return hres;
}

HRESULT CAccessible::_GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild)
{
    // First bit: Top 1, bottom 0
    // Rest is index into that toolbar.
    pvarChild->vt = VT_I4;
    pvarChild->lVal = iIndex + 1;

    if (hwnd)
    {
        if (hwnd == _pmtbTop->_hwndMB)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
    }
    else
    {
        // Caller wants us to figure out based on index from top.
        int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
        int iTotalCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;

        if (iIndex < iTopCount)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
        else
        {
            pvarChild->lVal -= iTopCount;
        }

        // This works because:
        // If there are 2 toolbars, the bottom one is represented by top bit clear.
        // If there is only one, then it doesn't matter if it's top or bottom.

        // lVal is not zero based....
        if (iIndex == -1)
            pvarChild->lVal = iTotalCount;

        if (iIndex >= iTotalCount)
            return E_FAIL;
    }

    return NOERROR;
}

HRESULT CAccessible::_GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* piIndex)
{
    ASSERT(_pmtbTop && _pmtbBottom);
    ASSERT(piIndex);

    if (ppmtb)
        *ppmtb = NULL;

    *piIndex = -1;

    // Passing a NULL for an HWND returns the index from the beginning of the set.
    int iAdd = 0;
    if (pvarChild->vt != VT_I4)
        return E_FAIL;

    if (pvarChild->lVal & TOOLBAR_MASK)
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbTop;
        }
    }
    else
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbBottom;
        }
        else
        {
            iAdd = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        }
    }

    if (ppmtb && *ppmtb)
        (*ppmtb)->AddRef();

    *piIndex = (pvarChild->lVal & ~TOOLBAR_MASK) + iAdd - 1;

    return (ppmtb && !*ppmtb) ? E_FAIL : S_OK;
}


HRESULT CAccessible::_GetAccessibleItem(int iIndex, IDispatch** ppdisp)
{
    HRESULT hres = E_OUTOFMEMORY;
    CAccessible* pacc = new CAccessible(_pmb, iIndex);

    if (pacc)
    {
        if (SUCCEEDED(pacc->InitAcc()))
        {
            hres = pacc->QueryInterface(IID_PPV_ARG(IDispatch, ppdisp));
        }
        pacc->Release();
    }
    return hres;
}

// *** IEnumVARIANT methods ***
STDMETHODIMP CAccessible::Next(unsigned long celt, 
                        VARIANT * rgvar, 
                        unsigned long * pceltFetched)
{

    // Picky customer complaint. Check for NULL...
    if (pceltFetched)
        *pceltFetched = 1;
    return _GetVariantFromChildIndex(NULL, _iEnumIndex++, rgvar);
}

STDMETHODIMP CAccessible::Skip(unsigned long celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAccessible::Reset()
{
    _iEnumIndex = 0;
    return NOERROR;
}

STDMETHODIMP CAccessible::Clone(IEnumVARIANT ** ppenum)
{
    return E_NOTIMPL;
}

// *** IOleWindow methods ***
STDMETHODIMP CAccessible::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        *lphwnd = _hwndMenuWindow;
        break;

    case MB_STATE_ITEM:
        *lphwnd = _pmtbItem->_hwndMB;
        break;

    case MB_STATE_MENU:
        *lphwnd = _pmtbTop->_hwndMB;
        break;
    }

    if (*lphwnd)
        return NOERROR;

    return E_FAIL;
}

STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\iaccess.h ===
#ifndef _IAccessible_h
#define _IAccessible_h

// (DavidJen) might be paranoic but these two function were previously defined extern "C" in this header
// just to be sure I pull in the thunked definitions; these definitions are used within browseUI
#if !defined(NotifyWinEvent) || !defined(LresultFromObject)
#include "apithk.h"
#endif

#include "oleacc.h"
#include "mnbase.h"
#include "menuband.h"

#define CHILDID_SELF 0

// NOTE (lamadio): The designers of the Accessibility interface did not know
// the rule about COM identity. They allow a QI for the external object IEnumVariant

class CAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
    int             _cRef;
    // IDispatch Support
    ITypeInfo*      _pTypeInfo;
    BOOL            _LoadTypeLib();


    // Track menu popup Support
    IAccessible*    _pInnerAcc;
    HWND            _hwndMenuWindow;
    HMENU           _hMenu;
    WORD            _wID;

    // Menuband Support
    CMenuToolbarBase* _pmtbBottom;
    CMenuToolbarBase* _pmtbTop;
    IShellMenuAcc*    _psma;
    IMenuBand*        _pmb;

    // Menuband Item Support
    CMenuToolbarBase*  _pmtbItem;

    int               _iAccIndex;
    int               _iIndex;  
    int               _iEnumIndex;
    int               _idCmd;


    // Object info
    BITBOOL         _fInitialized: 1;
    BITBOOL         _fState: 3;

    HRESULT _GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild);
    HRESULT _GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* iIndex);
    HRESULT _GetAccessibleItem(int iIndex, IDispatch** ppdisp);
    HRESULT _GetAccName(BSTR* pbstr);
    HRESULT _Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);


public:
    CAccessible(HMENU, WORD);
    CAccessible(IMenuBand*);
    CAccessible(IMenuBand*, int iIndex);
    virtual ~CAccessible();

    HRESULT InitAcc();

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr);


    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // *** IAccessible methods ***
    virtual STDMETHODIMP get_accParent(IDispatch * FAR* ppdispParent);
    virtual STDMETHODIMP get_accChildCount(long FAR* pChildCount);
    virtual STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild);

    virtual STDMETHODIMP get_accName(VARIANT varChild, BSTR* pszName);
    virtual STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
    virtual STDMETHODIMP get_accDescription(VARIANT varChild, BSTR FAR* pszDescription);
    virtual STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    virtual STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);

    
    virtual STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pszHelp);
    virtual STDMETHODIMP get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
    virtual STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);

    virtual STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);

    virtual STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    
    virtual STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

    virtual STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);

    virtual STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);

    virtual STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    virtual STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

    virtual STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    virtual STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    virtual STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);


    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(unsigned long celt, 
                            VARIANT FAR* rgvar, 
                            unsigned long FAR* pceltFetched); 
    virtual STDMETHODIMP Skip(unsigned long celt); 
    virtual STDMETHODIMP Reset(); 
    virtual STDMETHODIMP Clone(IEnumVARIANT FAR* FAR* ppenum); 

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\isfmenu.cpp ===
//
// isfmenu.cpp
//
// callback for chevron drop-down menu for isfbands
//

#include "shellprv.h"
#include "isfmenu.h"
#include "legacy.h"
#include "util.h"

// *** IUnknown methods ***
STDMETHODIMP CISFMenuCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CISFMenuCallback, IShellMenuCallback),
        QITABENT(CISFMenuCallback, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CISFMenuCallback::AddRef ()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CISFMenuCallback::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

BOOL CISFMenuCallback::_IsVisible(LPITEMIDLIST pidl)
{
    if (_poct) {
        VARIANTARG v;

        v.vt = VT_INT_PTR;
        v.byref = pidl;

        HRESULT hr = _poct->Exec(&CGID_ISFBand, ISFBID_ISITEMVISIBLE, 0, &v, NULL);
        return (hr == S_OK);
    }

    return FALSE;
}


HRESULT IUnknown_SeekToZero(IUnknown* punk)
{
    HRESULT hres = E_FAIL;
    IStream* pstm;
    if (punk && SUCCEEDED(punk->QueryInterface(IID_IStream, (void**)&pstm)))
    {
        // We need to seek to the beginning of the stream here. We don't do this in
        // the menubands because it's rude: They should not seek to the beginning
        // because there may be information that needs to be saved after them.
        //Set the seek pointer at the beginning.
        const LARGE_INTEGER li0 = {0};
        hres = pstm->Seek(li0, STREAM_SEEK_SET, NULL);
        pstm->Release();
    }

    return hres;
}

HRESULT CISFMenuCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = S_FALSE;
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    VARIANTARG v = {0};

                    v.vt = VT_UNKNOWN;
                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_GETORDERSTREAM, 0, NULL, &v);

                    if (SUCCEEDED(hres))
                    {
                        IUnknown_SeekToZero(v.punkVal);

                        hres = v.punkVal->QueryInterface(riid, ppvObj);
                        v.punkVal->Release();
                    }
                }
                ILFree(pidlFull);
            }
        }
    }
    return hres;
}

HRESULT CISFMenuCallback::_SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;

    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    ASSERT(ppvObj);

                    VARIANTARG v;

                    v.vt = VT_UNKNOWN;
                    v.punkVal = *(IUnknown**)ppvObj;

                    IUnknown_SeekToZero(*(IUnknown**)ppvObj);

                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_SETORDERSTREAM, 0, &v, NULL);
                }
                ILFree(pidlFull);
            }
        }
    }

    return hres;
}


HRESULT CISFMenuCallback::_GetSFInfo(LPSMDATA psmd, PSMINFO psminfo)
{
    // We only want to filter pidls if:
    //  1) It's at the root of the links chevron menu
    //  2) It's _IS_ visible in the links bar. We don't want to show links
    //     in this menu that are visible.
    if (psmd->uIdAncestor == ANCESTORDEFAULT &&
        (psminfo->dwMask & SMIM_FLAGS)       && 
        _IsVisible(psmd->pidlItem))
    {
        // not obscured on the subject isfband; exclude from menu
        psminfo->dwFlags |= SMIF_HIDDEN;
    }

    return S_OK;
}

// *** IShellMenuCallback methods ***
STDMETHODIMP CISFMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uMsg) 
    {
    case SMC_SFEXEC:
        hr = SHNavigateToFavorite(psmd->psf, psmd->pidlItem, _punkSite, SBSP_DEFBROWSER | SBSP_DEFMODE);
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (PSMINFO)lParam);
        break;

    case SMC_GETSFOBJECT:
        hr = _GetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    case SMC_SETSFOBJECT:
        hr = _SetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    }

    return hr;
}

// *** IObjectWithSite methods ***
STDMETHODIMP CISFMenuCallback::SetSite(IUnknown* punkSite)
{
    if (punkSite != _punkSite)
        IUnknown_Set(&_punkSite, punkSite);

    return S_OK;
}


HRESULT CISFMenuCallback::Initialize(IUnknown* punk)
{
    HRESULT hr = E_FAIL;

    if (punk)
        hr = punk->QueryInterface(IID_IOleCommandTarget, (PVOID*)&_poct);

    IShellFolderBand* psfb;
    hr = punk->QueryInterface(IID_IShellFolderBand, (PVOID*)&psfb);

    if (SUCCEEDED(hr)) 
    {
        BANDINFOSFB bi;
        bi.dwMask = ISFB_MASK_IDLIST | ISFB_MASK_SHELLFOLDER;

        hr = psfb->GetBandInfoSFB(&bi);
        _pidl = bi.pidl;
        if (bi.psf)
            bi.psf->Release();
        psfb->Release();
    }

    return hr;
}

CISFMenuCallback::CISFMenuCallback() : _cRef(1)
{
}

CISFMenuCallback::~CISFMenuCallback()
{
    ASSERT(_cRef == 0);

    ILFree(_pidl);

    ATOMICRELEASE(_poct);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\isfband.h ===
#ifndef BANDISF
#define BANDISF

#include "bands.h"
#include "logo.h"
#include "sftbar.h"

class CISFBand : public CToolbarBand,
                 public CSFToolbar,
                 public CLogoBase,
                 public IFolderBandPriv
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods (CToolBand PURE) ***
    virtual STDMETHODIMP GetClassID(LPCLSID lpClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IContextMenu methods (override) ***
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    
    // *** IOleCommandTarget ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // *** IShellFolderBand methods ***
    virtual STDMETHODIMP InitializeSFB(LPSHELLFOLDER psf, LPCITEMIDLIST pidl);
    virtual STDMETHODIMP SetBandInfoSFB(BANDINFOSFB * pbi);
    virtual STDMETHODIMP GetBandInfoSFB(BANDINFOSFB * pbi);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IFolderBandPriv
    // for internal guys so that we don't have to use a prop page
    virtual STDMETHODIMP SetCascade(BOOL f) { _fCascadeFolder = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetAccelerators(BOOL f) { _fAccelerators = BOOLIFY(f); return S_OK; }; 
    virtual STDMETHODIMP SetNoIcons(BOOL f)   { _fNoIcons = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetNoText(BOOL f)  { _fNoShowText = BOOLIFY(f); return S_OK; };

protected:

    friend HRESULT    CISFBand_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);
    friend HRESULT    CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

    CISFBand();
    virtual ~CISFBand();

    void    _ReleaseMenu();
    void    _SetDirty(BOOL fDirty);
    virtual HRESULT _SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMDBPU);
    virtual void _SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl);
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon);
    virtual HMENU   _GetContextMenu();

    void    _ReleaseMenuPopup(IMenuPopup** ppmp);
    void    _SetCacheMenuPopup(IMenuPopup* pmp);
    HRESULT _DropdownItem(LPCITEMIDLIST pidl, UINT idCmd);

    LRESULT _TryChannelSurfing(LPCITEMIDLIST pidl);
    HRESULT _GetChannelBrowser(IWebBrowser2 **ppwb);
    HRESULT _IStreamFromOrderList(VARIANT* pvarargOut);
    HRESULT _OrderListFromIStream(VARIANT* pvarargIn);

    IMenuPopup *_pmpCache;
    IMenuPopup *    _pmp;               // Submenu popup

    const GUID*     _pguidUEMGroup;


    BITBOOL         _fCascadeFolder :1;
    BITBOOL         _fNoRecalcDefaults :1;// Don't recalc defaults during GetBandInfo
    BITBOOL         _fInitialized :1;   // have we initialized the toolbar
    BITBOOL         _fDebossed :1;      // TRUE to enable debossed rebar style
    BITBOOL         _fLinksMode :1;     // TRUE: do not allow drag & drop onto content items.
    BITBOOL         _fHaveBkColor :1;    // TRUE if _crBkgnd is valid
    BITBOOL         _fHaveColors :1;    // TRUE if _crBtnXX are valid
    BITBOOL         _fFullOpen :1;      // TRUE if band should maximize when opened
    BITBOOL         _fClosing : 1;      // TRUE if we are shutting down....
    BITBOOL         _fDesktop :1;       // 1:desktop 0:browser(or non-ActDesk)
    BITBOOL         _fBtnMinSize :1;    // TRUE if band should report min thickness of button
    BITBOOL         _fDelayPainting :1;
    BITBOOL         _fChannels :1;      // TRUE if we want "Navigate Target" sup
    BITBOOL         _fCreatedBandProxy :1; // TRUE if we created a BandProxy ourself and hence need to call SetOwner on it
    BITBOOL         _fAllowDropdown: 1;
    BITBOOL         _fDelayInit :1;
    BOOL            _fIgnoreAddToFront;
    
    int             _eUemLog :2;        // UEMIND_* (NIL:off, o.w.:group)
    int             _iIdealLength;      // our ideal height/width last time bandsite asked
    
    COLORREF        _crBkgnd;           // Background color (must set _fHaveBkColor)
    COLORREF        _crBtnLt;           // Button hilite color (must set _fHaveColors)
    COLORREF        _crBtnDk;           // Button lolite color (must set _fHaveColors)

    DWORD _dwPriv; // private for bsmenu
    IBandProxy      * _pbp;

    HPALETTE _hpalOld;          // the old palette saved while we do a draw.....

    int _GetIdealSize(PSIZE psize);

    HRESULT _IsPidlVisible(LPITEMIDLIST pidl);

    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferredEffect);
    
    virtual HRESULT _CreateToolbar(HWND hwndParent);
    virtual HWND _CreatePager(HWND hwndParent);

    virtual int _GetBitmap(int iCommandID, PIBDATA pibData, BOOL fUseCache);
    virtual void _ToolbarChanged() { _BandInfoChanged(); };

    BOOL _IsChildID(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlChild);

    BOOL _UpdateIconSize(UINT fIconSize, BOOL fUpdateButtons);
    void _UpdateVerticalMode(BOOL fVertical);

    LRESULT _TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd);
    LRESULT _TrySimpleInvoke(LPCITEMIDLIST pidl);

    HRESULT _SiteOnSelect(DWORD dwType);
    
    virtual HRESULT _GetTitleW(LPWSTR pwzTitle, DWORD cchSize);

    virtual void _Initialize();

    friend class CExtractImageTask;
    friend HRESULT CALLBACK UpdateBandLogo( LPVOID pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );


    // stuff for CLogoBase
    virtual IShellFolder * GetSF();
    virtual HWND GetHWND();
    virtual REFTASKOWNERID GetTOID();
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );
    
    void _StopDelayPainting();
    void _FixupAppDataDirectory();
};

HRESULT CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\isfband.cpp ===
#include "shellprv.h"
#include "common.h"
#include <varutil.h>

#include "bands.h"
#include "isfband.h"
#include "resource.h"
#include "dpastuff.h"
#include "shlwapi.h"
#include "cobjsafe.h"
#include "uemapp.h"
#include "mnfolder.h"
#include "legacy.h"
#include "util.h"
#include "isfmenu.h"

#define DM_VERBOSE      0       // misc verbose traces
#define DM_PERSIST      0
#define TF_BANDDD   TF_BAND
#define DM_RENAME       0
#define DM_MISC         0       // miscellany

#define SZ_PROPERTIESA     "properties"
#define SZ_PROPERTIES      TEXT(SZ_PROPERTIESA)
#define SZ_REGKEY_ADVFOLDER        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")

// {F47162A0-C18F-11d0-A3A5-00C04FD706EC}
static const GUID TOID_ExtractImage = { 0xf47162a0, 0xc18f, 0x11d0, { 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec } };


#define SUPERCLASS CToolBand

extern UINT g_idFSNotify;

HRESULT CLogoExtractImageTask_Create(CLogoBase *plb,
                                  IExtractImage *pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  IRunnableTask ** ppTask);

class CLogoExtractImageTask : public IRunnableTask
{
    public:
        STDMETHOD (QueryInterface) (REFIID riid, void **ppvObj);
        STDMETHOD_(ULONG, AddRef) ();
        STDMETHOD_(ULONG, Release) ();

        STDMETHOD (Run)(void);
        STDMETHOD (Kill)(BOOL fWait);
        STDMETHOD (Suspend)();
        STDMETHOD (Resume)();
        STDMETHOD_(ULONG, IsRunning)(void);

    protected:

        CLogoExtractImageTask(HRESULT * pHr,
                           CLogoBase *plb,
                           IExtractImage * pImage,
                           LPCWSTR pszCache,
                           DWORD dwItem,
                           int iIcon,
                           DWORD dwFlags);
        ~CLogoExtractImageTask();
        HRESULT InternalResume();

        friend HRESULT CLogoExtractImageTask_Create(CLogoBase* plb,
                                                 IExtractImage *pExtract,
                                                 LPCWSTR pszCache,
                                                 DWORD dwItem,
                                                 int iIcon,
                                                 DWORD dwFlags,
                                                 IRunnableTask ** ppTask);

        LONG            m_cRef;
        LONG            m_lState;
        IExtractImage * m_pExtract;
        IRunnableTask * m_pTask;
        WCHAR           m_szPath[MAX_PATH];
        DWORD           m_dwFlags;
        DWORD           m_dwItem;
        CLogoBase*      m_plb;
        HBITMAP         m_hBmp;
        int             m_iIcon;
};
//=================================================================
// Implementation of CISFBand
//=================================================================


CISFBand::CISFBand() : CToolbarBand()
{
    _fCanFocus = TRUE;
    _eUemLog = UEMIND_NIL;
    _dwPriv = -1;

    _fHasOrder = TRUE;  // ISFBand always has an order...
    _fAllowDropdown = BOOLIFY(SHRegGetBoolUSValue(SZ_REGKEY_ADVFOLDER, TEXT("CascadeFolderBands"),
                    FALSE,
                    FALSE)); 

    // Should we enable logging of arbirary events?
//    _pguidUEMGroup = &UEMIID_SHELL;
    ASSERT(_pguidUEMGroup == NULL);


    // Assert that this class is ZERO INITed.
    ASSERT(!_pbp);
    ASSERT(FALSE == _fCreatedBandProxy);
}


CISFBand::~CISFBand()
{
    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
}

// aggregation checking is handled in class factory

HRESULT CISFBand_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory

    HRESULT hr = E_OUTOFMEMORY;
    CISFBand *pObj = new CISFBand();
    if (pObj) 
    {
        hr = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: See CISFBand::Init for an explanation on the parameters.

*/
HRESULT CISFBand_CreateEx(IShellFolder* psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_FAIL;

    if (psf || pidl)
    {
        IShellFolderBand *psfb;
        hr = CoCreateInstance(CLSID_ISFBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolderBand, &psfb));
        if (SUCCEEDED(hr))
        {
            hr = psfb->InitializeSFB(psf, pidl);
            if (SUCCEEDED(hr))
            {
                hr = psfb->QueryInterface(riid, ppv);
            }
            psfb->Release();
        }
    }
    return hr;
}

#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_SHDREF, "CDocObjectView(%x)::QI(%s) is AddRefing _cRef=%d", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif

HRESULT CISFBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CISFBand, IShellFolderBand),
        QITABENT(CISFBand, IFolderBandPriv),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hr))
        hr = CToolBand::QueryInterface(riid, ppvObj);

    if (FAILED(hr))
        hr = CSFToolbar::QueryInterface(riid, ppvObj);


    if (S_OK != hr)
    {
        // HACKHACK: this is yucko!
        if (IsEqualIID(riid, CLSID_ISFBand))
        {
            *ppvObj = (void*)this;
            _AddRef(TEXT("CLSID_ISFBand"));
            return S_OK;
        }
    }

    return hr;
}

//***   ILIsParentCSIDL -- like ILIsParent, but accepts a CSIDL_* for pidl1
// NOTES
//  TODO move to shlwapi (if/when idlist.c moves there)?
STDAPI_(BOOL) ILIsParentCSIDL(int csidl1, LPCITEMIDLIST pidl2, BOOL fImmediate)
{
    LPITEMIDLIST pidlSpec;
    BOOL fRet = FALSE;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl1, &pidlSpec)))
    {
        fRet = ILIsParent(pidlSpec, pidl2, fImmediate);
        ILFree(pidlSpec);
    }

    return fRet;
}

/*----------------------------------------------------------
Purpose: IShellFolderBand::InitializeSFB

         - supply IShellFolder with no PIDL if you want to view some
           ISF (either already instantiated from the filesystem or
           some non-filesystem ISF) that you do NOT want to receive
           notifies from (either from SHChangeNotify nor from
           IShellChangeNotify)

         - supply a PIDL with no IShellFolder for a full-blown band
           looking at a shell namespace (rooted on desktop) item.

*/
HRESULT CISFBand::InitializeSFB(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    // Did they try to add the Recycle Bin? If so we need to reject it
    // for consistance reasons.  We also reject the Temp. Internet Files
    // for security reasons.
    if (pidl && (ILIsParentCSIDL(CSIDL_BITBUCKET, pidl, FALSE) ||
                ILIsParentCSIDL(CSIDL_INTERNET_CACHE, pidl, FALSE)))
    {
        // this will eventually show up as IDS_CANTISFBAND
        TraceMsg(DM_TRACE, "cib.isfb: recycle => E_INVALIDARG");
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
        hr = CSFToolbar::SetShellFolder(psf, pidl);
    if (SUCCEEDED(hr))
        hr = _AfterLoad();

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::SetBandInfoSFB

*/
HRESULT CISFBand::SetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if ((pbi->dwMask & ISFB_MASK_INVALID) ||
        (pbi->dwMask & ISFB_MASK_VIEWMODE) && (pbi->wViewMode & ~3))
        return E_INVALIDARG;

    // We don't handle ISFB_MASK_SHELLFOLDER and ISFB_MASK_IDLIST
    // in Set because there's a lot of work to resync pidl, psf, and
    // notifcations in the toolbar.  If somebody wants to do it,
    // more power to ya.  :)
    if (pbi->dwMask & (ISFB_MASK_SHELLFOLDER | ISFB_MASK_IDLIST))
        return E_INVALIDARG;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        if (pbi->dwStateMask & ISFB_STATE_DEBOSSED)
            _fDebossed = BOOLIFY(pbi->dwState & ISFB_STATE_DEBOSSED);
        if (pbi->dwStateMask & ISFB_STATE_ALLOWRENAME)
            _fAllowRename = BOOLIFY(pbi->dwState & ISFB_STATE_ALLOWRENAME);
        if (pbi->dwStateMask & ISFB_STATE_NOSHOWTEXT)
            _fNoShowText = BOOLIFY(pbi->dwState & ISFB_STATE_NOSHOWTEXT);
        if (pbi->dwStateMask & ISFB_STATE_CHANNELBAR)
            _fChannels = BOOLIFY(pbi->dwState & ISFB_STATE_CHANNELBAR);
        /* ISFB_STATE_NOTITLE: removed 970619, use cbs::SetBandState */
        if (pbi->dwStateMask & ISFB_STATE_QLINKSMODE)
            _fLinksMode = BOOLIFY(pbi->dwState & ISFB_STATE_QLINKSMODE);
        if (pbi->dwStateMask & ISFB_STATE_FULLOPEN)
            _fFullOpen = BOOLIFY(pbi->dwState & ISFB_STATE_FULLOPEN);
        if (pbi->dwStateMask & ISFB_STATE_NONAMESORT)
            _fNoNameSort = BOOLIFY(pbi->dwState & ISFB_STATE_NONAMESORT);
        if (pbi->dwStateMask & ISFB_STATE_BTNMINSIZE)
            _fBtnMinSize = BOOLIFY(pbi->dwState & ISFB_STATE_BTNMINSIZE);
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        _crBkgnd = pbi->crBkgnd;
        _fHaveBkColor = TRUE;
        if (EVAL(_hwndTB))
            SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_CUSTOMERASE, TBSTYLE_CUSTOMERASE);

        ASSERT(_hwnd);

        if (_hwndPager)
        {
            TraceMsg(TF_BAND, "cib.sbisfb: Pager_SetBkColor(_hwnd=%x crBkgnd=%x)", _hwnd, _crBkgnd);
            Pager_SetBkColor(_hwnd, _crBkgnd);
        }
    }

    // We don't support changing these once TB is created, So?
    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        _crBtnLt = pbi->crBtnLt;
        _crBtnDk = pbi->crBtnDk;
        _fHaveColors = TRUE;
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        _uIconSize = (pbi->wViewMode & 3); // stored in a 2-bit field currently...

        // only force no recalc if one of the recalcable fields was set
        _fNoRecalcDefaults = TRUE;
    }


    // If the bandsite queried us before, let it know the info may have changed
    if (_fInitialized)
        _BandInfoChanged();

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::GetBandInfoSFB

*/
HRESULT CISFBand::GetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        pbi->dwState = 0;
        pbi->dwStateMask = ISFB_STATE_ALL;

        if (_fDebossed)
            pbi->dwState |= ISFB_STATE_DEBOSSED;
        if (_fAllowRename)
            pbi->dwState |= ISFB_STATE_ALLOWRENAME;
        if (_fNoShowText)
            pbi->dwState |= ISFB_STATE_NOSHOWTEXT;
        if (_fLinksMode)
            pbi->dwState |= ISFB_STATE_QLINKSMODE;
        if (_fFullOpen)
            pbi->dwState |= ISFB_STATE_FULLOPEN;
        if (_fNoNameSort)
            pbi->dwState |= ISFB_STATE_NONAMESORT;
        if (_fBtnMinSize)
            pbi->dwState |= ISFB_STATE_BTNMINSIZE;
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        pbi->crBkgnd = (_fHaveBkColor) ? _crBkgnd : CLR_DEFAULT;
    }

    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        if (_fHaveColors)
        {
            pbi->crBtnLt = _crBtnLt;
            pbi->crBtnDk = _crBtnDk;
        }
        else
        {
            pbi->crBtnLt = CLR_DEFAULT;
            pbi->crBtnDk = CLR_DEFAULT;
        }
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        pbi->wViewMode = _uIconSize;
    }

    if (pbi->dwMask & ISFB_MASK_SHELLFOLDER)
    {
        pbi->psf = _psf;
        if (pbi->psf)
            pbi->psf->AddRef();
    }

    if (pbi->dwMask & ISFB_MASK_IDLIST)
    {
        if (_pidl)
            pbi->pidl = ILClone(_pidl);
        else
            pbi->pidl = NULL;
    }
    return S_OK;
}

// *** IInputObject methods ***
HRESULT CISFBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    return SUPERCLASS::TranslateAcceleratorIO(lpMsg);
}

void CISFBand::_SetCacheMenuPopup(IMenuPopup* pmp)
{
    if (!SHIsSameObject(pmp, _pmpCache))
    {
        _ReleaseMenuPopup(&_pmpCache);
        _pmpCache = pmp;
        if (_pmpCache)
            _pmpCache->AddRef();
    }
}


void CISFBand::_ReleaseMenuPopup(IMenuPopup** ppmp)
{
    IUnknown_SetSite(*ppmp, NULL);
    ATOMICRELEASE(*ppmp);
}

/*----------------------------------------------------------
Purpose: Releases the held menu popup.

*/
void CISFBand::_ReleaseMenu()
{
    if (!SHIsSameObject(_pmp, _pmpCache))
    {
        TraceMsg(TF_MENUBAND, "Releasing pmp %#lx", _pmp);
        _ReleaseMenuPopup(&_pmp);
    } else
        ATOMICRELEASE(_pmp);
}

//***
// ENTRY/EXIT
//  S_OK        desktop browser
//  S_FALSE     other browser (explorer, OC, etc.)
//  E_xxx       not a browser at all (e.g. band asking tray)
HRESULT MBIsDesktopBrowser(IUnknown *punkSite)
{
    HRESULT hr;
    IServiceProvider *psp;
    IUnknown *punk;

    hr = E_FAIL;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &psp))))
    {
        hr = S_FALSE;
        if (SUCCEEDED(psp->QueryInterface(SID_SShellDesktop, (void**)&punk)))
        {
            hr = S_OK;
            punk->Release();
        }
        psp->Release();
    }

    TraceMsg(DM_VERBOSE, "idb: ret hrDesk=%x (0=dt 1=sh e=!brow)", hr);
    return hr;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::SetSite method.

*/
HRESULT CISFBand::SetSite(IUnknown* punkSite)
{
    _ReleaseMenu();

    SUPERCLASS::SetSite(punkSite);

    if (_punkSite)
    {
        if (!_hwndTB)
            _CreateToolbar(_hwndParent);

        IUnknown_SetOwner(_psf, SAFECAST(this, IDeskBand*));

        _Initialize();
    }
    else
        IUnknown_SetOwner(_psf, NULL);


    // First destroy the band proxy

    // Call SetSite(NULL) only if you own
    // if not, it's the parent from whom you got it via QS who will call SetSite(NULL)

    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
    _fCreatedBandProxy = FALSE;
    // Need a bandproxy
    QueryService_SID_IBandProxy(punkSite, IID_IBandProxy, &_pbp, NULL);
    if (!_pbp)
    {
        // We need to create it ourselves since our parent couldn't help
        ASSERT(FALSE == _fCreatedBandProxy);
        HRESULT hr = CreateIBandProxyAndSetSite(punkSite, IID_IBandProxy, &_pbp, NULL);
        if (_pbp)
        {
            ASSERT(S_OK == hr);
            _fCreatedBandProxy = TRUE;
        }
    }

    return S_OK;
}

void CISFBand::_Initialize()
{
    _fDesktop = (MBIsDesktopBrowser(_punkSite) == S_OK);

    return;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
HRESULT CISFBand::CloseDW(DWORD dw)
{
    _fClosing = TRUE;

    // close down the task scheduler ...
    if (_pTaskScheduler)
        ATOMICRELEASE(_pTaskScheduler);

    _UnregisterToolbar();
    EmptyToolbar();

    IUnknown_SetOwner(_psf, NULL);
    _SetCacheMenuPopup(NULL);

    // should get freed in EmptyToolbar();
    ASSERT(!_hdpa);

    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

*/
HRESULT CISFBand::ShowDW(BOOL fShow)
{
    HRESULT hr = S_OK;

    SUPERCLASS::ShowDW(fShow);

    if (fShow)
    {
        _fShow = TRUE;

        if (_fDirty)
        {
            _FillToolbar();
        }

        if (!_fDelayInit)
        {
            _RegisterToolbar();
        }
    }
    else
    {
        _fShow = FALSE;
    }

    return hr;
}

void CISFBand::_StopDelayPainting()
{
    if (_fDelayPainting)
    {
        _fDelayPainting = FALSE;
        // May be called by background thread
        // Use PostMessage instead of SendMessage to avoid deadlock
        PostMessage(_hwndTB, WM_SETREDRAW, TRUE, 0);
        if (_hwndPager)
            PostMessage(_hwnd, PGM_RECALCSIZE, 0L, 0L);
    }
}

HWND CISFBand::_CreatePager(HWND hwndParent)
{
    // don't create a pager for isfbands
    return hwndParent;
}

HRESULT CISFBand::_CreateToolbar(HWND hwndParent)
{
    if (_fHaveBkColor)
        _dwStyle |= TBSTYLE_CUSTOMERASE;
    
    HRESULT hr = CSFToolbar::_CreateToolbar(hwndParent);

    if (SUCCEEDED(hr))
    {
        ASSERT(_hwndTB);

        if (_fHaveBkColor)
            ToolBar_SetInsertMarkColor(_hwndTB, GetSysColor(COLOR_BTNFACE));

        SendMessage(_hwndTB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

        if (_fChannels)
        {
            SHSetWindowBits(_hwndTB, GWL_EXSTYLE, dwExStyleRTLMirrorWnd, 0);        
        }    

        _hwnd = _hwndPager ? _hwndPager : _hwndTB;

        if (_fHaveColors)
        {
            COLORSCHEME cs;

            cs.dwSize = sizeof(cs);
            cs.clrBtnHighlight  = _crBtnLt;
            cs.clrBtnShadow     = _crBtnDk;
            SendMessage(_hwndTB, TB_SETCOLORSCHEME, 0, (LPARAM) &cs);
        }
    }
    return hr;
}

int CISFBand::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iBitmap;
    if (_uIconSize == ISFBVIEWMODE_LOGOS)
    {
        IRunnableTask *pTask = NULL;
        DWORD dwPriority = 0;
        // fetch the logo instead...
        ASSERT(!_fDelayPainting);
       // Warning - cannot hold ptask in a member variable - it will be a circular reference
        iBitmap = GetLogoIndex(iCommandID, pibdata->GetPidl(), &pTask, &dwPriority, NULL);
        if (pTask)
        {
            AddTaskToQueue(pTask, dwPriority, (DWORD)iCommandID);
            ATOMICRELEASE(pTask);
        }
    }
    else
        iBitmap = CSFToolbar::_GetBitmap(iCommandID, pibdata, fUseCache);

    return iBitmap;
}

void CISFBand::_SetDirty(BOOL fDirty)
{
    CSFToolbar::_SetDirty(fDirty);

    if (fDirty)
        IUnknown_Exec(_punkSite, &CGID_PrivCITCommands, CITIDM_SET_DIRTYBIT, TRUE, NULL, NULL);
}

BOOL CISFBand::_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    BOOL fChanged = (_uIconSize != uIconSize);

    _uIconSize = uIconSize;
    HIMAGELIST himl = NULL;

    if (uIconSize == ISFBVIEWMODE_LOGOS)
    {
        if (SUCCEEDED(InitLogoView()))
        {
            himl = GetLogoHIML();
        }
        if (himl)
        {
            SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

            _UpdateButtons();
        }
    }

    if (!himl)
        fChanged |= CSFToolbar::_UpdateIconSize(uIconSize,fUpdateButtons);
    return fChanged;
}

void CISFBand::_UpdateVerticalMode(BOOL fVertical)
{
    _fVertical = (fVertical != 0);

    TraceMsg(TF_BAND, "ISFBand::_UpdateVerticalMode going %hs", _fVertical ? "VERTICAL" : "HORIZONTAL");

    ASSERT(_hwnd);

    if (_hwndPager)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, PGS_HORZ|PGS_VERT,
            _fVertical ? PGS_VERT : PGS_HORZ);
    }

    if (_hwndTB)
    {
        SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_WRAPABLE | CCS_VERT,
            TBSTYLE_WRAPABLE | (_fVertical ? CCS_VERT : 0));
    }
}

HRESULT IUnknown_QueryBand(IUnknown *punk, DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hr;
    IBandSite *pbs;

    hr = punk->QueryInterface(IID_PPV_ARG(IBandSite, &pbs));
    if (SUCCEEDED(hr))
    {
        hr = pbs->QueryBand(dwBandID, ppstb, pdwState, pszName, cchName);
        pbs->Release();
    }
    return hr;
}

#define CISFBAND_GETBUTTONSIZE()  (_hwndTB ?  (LONG)SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L) : MAKELONG(16, 16))

// _GetIdealSize
// calculates ideal height and width for band and passes back in
// psize, if psize isn't NULL; return value is band's 'ideal length'
// (ideal height if vertical, else ideal width)
int CISFBand::_GetIdealSize(PSIZE psize)
{
    SIZE size;
    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();
    RECT rc = {0};
    if (psize)
    {
        rc.right = psize->cx;
        rc.bottom = psize->cy;
    }
    else if (_hwndTB)
    {
        GetClientRect(_hwndTB, &rc);
    }

    if (_fVertical)
    {
        // set width to be max of toolbar width and toolbar button width
        size.cx = max(RECTWIDTH(rc), LOWORD(lButtonSize));
        // have toolbar calculate height given that width
        SendMessage(_hwndTB, TB_GETIDEALSIZE, TRUE, (LPARAM)&size);
    }
    else
    {
        // set height to be max of toolbar width and toolbar button width
        size.cy = max(RECTHEIGHT(rc), HIWORD(lButtonSize));
        // have toolbar calculate width given that height
        SendMessage(_hwndTB, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);
    }

    if (psize)
    {
        *psize = size;
    }

    return _fVertical ? size.cy : size.cx;
}

/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/

HRESULT CISFBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode,
                              DESKBANDINFO* pdbi)
{
    HRESULT hr = S_OK;
    WCHAR szQLPath[MAX_PATH] = L"";

    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szQLPath)))
    {
        WCHAR szSubDir[MAX_PATH];
        LoadString(g_hinst, IDS_QLAUNCHAPPDATAPATH, szSubDir, ARRAYSIZE(szSubDir));
        PathCombine(szQLPath, szQLPath, szSubDir);
    }


    _dwBandID = dwBandID;
    // We don't know the default icon size until GetBandInfo is called.
    // After we set the default, we pay attention to the context menu.
    if (!_fNoRecalcDefaults)
    {
        _uIconSize = (fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL)) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        _fNoRecalcDefaults = TRUE;
    }

    if (!_fInitialized)
    {
        _fInitialized = TRUE;
        _UpdateIconSize(_uIconSize, FALSE);
        _UpdateShowText(_fNoShowText);
    }

    // we treat floating the same as vertical
    _UpdateVerticalMode(fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL));

    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();

    pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT | DBIMF_USECHEVRON;
    if (_fDebossed)
        pdbi->dwModeFlags |= DBIMF_DEBOSSED;

    pdbi->ptMinSize.x = 0;
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptIntegral.y = (fViewMode & DBIF_VIEWMODE_VERTICAL) ? 1 : HIWORD(lButtonSize);
    pdbi->ptIntegral.x = 1;

    if (!_fFullOpen)
        _iIdealLength = _GetIdealSize((PSIZE)&pdbi->ptActual);

    // CalcMinWidthHeight {
    #define g_cxScrollbar   (GetSystemMetrics(SM_CXVSCROLL) * 3 / 4)
    #define g_cyScrollbar   (GetSystemMetrics(SM_CYVSCROLL) * 3 / 4)
    #define CX_TBBUTTON_MAX (16 + CX_FILENAME_AVG)  // button + name
    #define CY_TBBUTTON_MAX (16)                    // button

    int csBut, csButMin, clBut, clButMin, clScroll;

    // set up short/long aliases
    if (_fVertical)
    {
        csBut = LOWORD(lButtonSize);
        if (_fBtnMinSize)
            csButMin = min(csBut, CX_TBBUTTON_MAX);
        else
            csButMin = 0;   // people like to shrink things way down, so let 'em

        clBut = HIWORD(lButtonSize);
        clButMin = clBut;
        //ASSERT(min(clBut, CY_TBBUTTON_MAX) == clButMin);  // fails!

        clScroll = g_cyScrollbar;
    }
    else
    {
        csBut = HIWORD(lButtonSize);
        csButMin = csBut;
        //ASSERT(min(csBut, CY_TBBUTTON_MAX) == csButMin);  // fails!

        clBut = LOWORD(lButtonSize);
        clButMin = min(clBut, CX_TBBUTTON_MAX);

        clScroll = g_cxScrollbar;

        // nt5:176448: integral for horz
        //pdbi->ptIntegral.y = csBut;   this is the cause for 287082 and 341592
    }

    // n.b. virt pdbi->pt.x,y is really phys y,x (i.e. phys long,short)
    pdbi->ptMinSize.x = 0;
    pdbi->ptMinSize.y = csButMin;

    DWORD dwState = BSSF_NOTITLE;

    BANDINFOSFB bi;
    TCHAR szBandPath[MAX_PATH];
    bi.dwMask = ISFB_MASK_IDLIST;
    GetBandInfoSFB(&bi);
    SHGetPathFromIDList(bi.pidl, szBandPath);
    if ((lstrcmp(szBandPath, szQLPath) == 0) && (!_fIgnoreAddToFront))
    {
        pdbi->dwModeFlags |= DBIMF_ADDTOFRONT;
    }
    ILFree(bi.pidl);

    IUnknown_QueryBand(_punkSite, dwBandID, NULL, &dwState, NULL, 0);
    if (dwState & BSSF_NOTITLE) // _fNoTitle
    {
        int i, cBut, clTmp;

        // cbut=    text    notext
        // horz     1       4
        // vert     1       1
        cBut = 1;
        if (!_fVertical && _fNoShowText)
        {
            // special-case for QLaunch so see several buttons
            cBut = 3;   // for both QLaunch and arbitrary ISF band
        }

        pdbi->ptMinSize.x = cBut * clButMin;

        if (_hwndPager)
        {
            // tack on extra space for pager arrows
            pdbi->ptMinSize.x += 2 * clScroll;
        }

        i = (int)SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
        if (i <= cBut)
        {
            clTmp = i * clBut;
            if (clTmp < pdbi->ptMinSize.x)
            {
                // scrollbars take as much space as button would
                // so just do the button
                pdbi->ptMinSize.x = clTmp;
            }
        }
    }
    // }

    hr = _GetTitleW(pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    if (SUCCEEDED(hr))
    {
        // set window text to give accessibility apps something to read
        SetWindowText(_hwndTB, pdbi->wszTitle);
    }
    else
    {
        // we don't support title
#ifdef DEBUG
        if (pdbi->dwMask & DBIM_TITLE)
            TraceMsg(DM_VERBOSE, "cisfb.gbi: patch ~DBIM_TITLE");
#endif
        pdbi->dwMask &= ~DBIM_TITLE;
    }

    return hr;
}

LRESULT CISFBand::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    LRESULT lres = CDRF_DODEFAULT;

    switch (pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if (_hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS)
        {
            ASSERT(pnmcd->hdc);
            _hpalOld = SelectPalette(pnmcd->hdc, _hpalHalftone, TRUE);
            // LINTASSERT(_hpalOld || !_hpalOld);   // 0 semi-ok for SelectPalette
            RealizePalette(pnmcd->hdc);
        }

        // make sure we get the postpaint as well so we can de-select the palette...
        lres = CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_POSTPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if (_hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS)
        {
            ASSERT(pnmcd->hdc);
            (void) SelectPalette(pnmcd->hdc, _hpalOld, TRUE);
            // we don't need a realize here, we can keep the other palette realzied, we
            // re select the old palette above, otherwise we bleed the resource....
            // RealizePalette(pnmcd->hdc);
        }
        break;

    case CDDS_PREERASE:
        if (_fHaveBkColor)
        {
            RECT rcClient;
            GetClientRect(_hwndTB, &rcClient);
            SHFillRectClr(pnmcd->hdc, &rcClient, _crBkgnd);
            lres = CDRF_SKIPDEFAULT;
        }
        break;
    }

    return lres;
}

void CISFBand::_OnDragBegin(int iItem, DWORD dwPreferredEffect)
{
    LPCITEMIDLIST pidl = _IDToPidl(iItem, &_iDragSource);
    ToolBar_MarkButton(_hwndTB, iItem, TRUE);

    if (pidl)
        DragDrop(_hwnd, _psf, pidl, dwPreferredEffect, NULL);

    ToolBar_MarkButton(_hwndTB, iItem, FALSE);
    _iDragSource = -1;
}

LRESULT CISFBand::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;
    LRESULT lres = 0;

    if (_hwndPager && (lpnmhi->dwFlags & HICF_ARROWKEYS))
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;

        int iSelected = lpnmhi->idNew;
        iOldPos = (int)SendMessage(_hwnd, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndTB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);

        if (rc.top < iOldPos)
        {
             iNewPos =rc.top;
        }

        GetClientRect(_hwnd, &rcPager);
        heightPager = RECTHEIGHT(rcPager);

        if (rc.top >= iOldPos + heightPager)
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }

        if (iNewPos != iOldPos)
            SendMessage(_hwnd, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }
    else
    {
        lres = CToolbarBand::_OnHotItemChange(pnm);
    }

    return lres;
}

LRESULT CISFBand::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;
    switch (pnm->code)
    {
    case TBN_DROPDOWN:
        {
            LPNMTOOLBAR pnmtb = (LPNMTOOLBAR)pnm;
            lres = TBDDRET_DEFAULT;
            _DropdownItem(_IDToPidl(pnmtb->iItem), pnmtb->iItem);
        }
        break;

    case NM_THEMECHANGED:
        {
            SendMessage(_hwndTB, TB_SETBUTTONSIZE, 0, 0);
            SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(0, 0));
            _fInitialized = FALSE;
            _BandInfoChanged();
        }
        break;

    default:
        lres = CSFToolbar::_OnNotify(pnm);
    }

    return lres;
}


HRESULT CISFBand::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                               DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon)
{
    HRESULT hr = CSFToolbar::_TBStyleForPidl(pidl, pdwTBStyle, pdwTBState, pdwMIFFlags, piIcon);

    if (_fAllowDropdown &&
        !_fCascadeFolder && 
        ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
         IsBrowsableShellExt(pidl)))
    {
        *pdwTBStyle &= ~BTNS_BUTTON;
        *pdwTBStyle |= BTNS_DROPDOWN;
    }
    return hr;
}

HMENU CISFBand::_GetContextMenu()
{
    HMENU hmenu = CSFToolbar::_GetContextMenu();
    if (hmenu)
    {
        //
        // nuke the menu items which might resize us (show text,
        // view menu) if bandsite is in locked mode
        //
        IBandSite* pbs;
        if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IBandSite, &pbs))))
        {
            BANDSITEINFO bsi = {0};
            bsi.dwMask = BSIM_STYLE;
            pbs->GetBandSiteInfo(&bsi);
            if (bsi.dwStyle & BSIS_LOCKED)
            {
                DeleteMenu(hmenu, 0, MF_BYPOSITION);                 // View menu
                DeleteMenu(hmenu, ISFBIDM_SHOWTEXT, MF_BYCOMMAND);   // show text
            }
            pbs->Release();
        }
    }
    return hmenu;
}

LRESULT CISFBand::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    lres = CSFToolbar::_OnContextMenu(wParam, lParam);

    // todo: csidl?
    TraceMsg(DM_MISC, "cib._ocm: _dwPriv=%d", _dwPriv);
    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, (_dwPriv == CSIDL_APPDATA || _dwPriv == CSIDL_FAVORITES) ? UIBL_CTXTQCUTITEM : UIBL_CTXTISFITEM);

    return lres;
}

LRESULT CISFBand::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SIZE:
        // forward to toolbar
        SendMessage(_hwndTB, TB_AUTOSIZE, wParam, lParam);

        if (_GetIdealSize(NULL) != _iIdealLength)
        {
            // our ideal size has changed since the last time bandsite
            // asked; so tell bandsite ask us for our bandinfo again
            _BandInfoChanged();
        }
        return 0;
    }
    return CSFToolbar::_DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*----------------------------------------------------------
Purpose: Set the given IMenuPopup as the submenu to expand.  Returns
         S_FALSE if the menu was modal, S_OK if it was modeless, or
         failure.

*/
HRESULT CISFBand::_SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMPPF)
{
    HRESULT hr = E_FAIL;

    _ReleaseMenu();

    _pmp = pmp;

    if (pmp)
    {
        pmp->AddRef();

        RECT rc;
        POINT pt;

        SendMessage(_hwndTB, TB_GETRECT, uiCmd, (LPARAM)&rc);
        MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

        // Align the sub menu appropriately
        if (_fVertical)
        {
            pt.x = rc.right;
            pt.y = rc.top;
        }
        else
        {
            pt.x = rc.left;
            pt.y = rc.bottom;
        }

        // Use a reflect point for the sub-menu to start
        // if the window is RTL mirrored. [samera]
        if (IS_WINDOW_RTL_MIRRORED(_hwndTB))
        {
            pt.x = (_fVertical) ? rc.left : rc.right;
        }

        // Tell the sub menu deskbar who we are, so it can
        // inform us later when the user navigates out of
        // its scope.
        IUnknown_SetSite(_pmp, SAFECAST(this, IDeskBand*));

        // This must be called after SetSite is done above
        _SendInitMenuPopup(pmp, pidl);

        // Show the menubar
        hr = _pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlagsMPPF);
    }
    return hr;
}

void CISFBand::_SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl)
{
}

HRESULT CISFBand::_DropdownItem(LPCITEMIDLIST pidl, UINT idCmd)
{
    HRESULT hr = E_FAIL;
    if (_pidl && _psf)
    {
        LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);

        if (pidlFull)
        {
            IShellFolder* psf;

            if (SUCCEEDED(_psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                RECT rc;
                SendMessage(_hwndTB, TB_GETRECT, idCmd, (LPARAM)&rc);
                MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

                ITrackShellMenu* ptsm;
                if (SUCCEEDED(CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(ITrackShellMenu, &ptsm))))
                {
                    CISFMenuCallback *pISFMcb = new CISFMenuCallback();

                    if(pISFMcb)
                    {
                        ptsm->Initialize(pISFMcb, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL | SMINIT_NOSETSITE );
                        pISFMcb->SetSite(_punkSite);
                    }
                    else
                        ptsm->Initialize(NULL, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL);

                    if (SUCCEEDED(ptsm->SetShellFolder(psf, pidlFull, NULL, SMSET_TOP | SMSET_USEBKICONEXTRACTION)))
                    {
                        POINTL pt = {rc.left, rc.right};
                        hr = ptsm->Popup(_hwndTB, &pt, (RECTL*)&rc, MPPF_BOTTOM);
                    }
                    if(pISFMcb)
                        pISFMcb->Release();
                    ptsm->Release();
                }
                psf->Release();
            }

            ILFree(pidlFull);
        }
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Try treating the pidl as a cascading menu item.

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd)
{
    LRESULT lRet = 0;

    // Do we cascade to another submenu?
    if ((GetKeyState(VK_CONTROL) < 0) || _fCascadeFolder)
    {
        // Is the item a browsable folder?
        if ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
            IsBrowsableShellExt(pidl))
        {
            // Yes; cascade the browsable folder as a submenu
            lRet = (S_OK == _DropdownItem(pidl, uiCmd));
        }
    }

    return lRet;
}

/*----------------------------------------------------------
Purpose: Try just invoking the pidl

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TrySimpleInvoke(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    if (S_OK == _pbp->IsConnected())    // Force IE
    {
        LPITEMIDLIST pidlDest;

        if (SUCCEEDED(SHGetNavigateTarget(_psf, pidl, &pidlDest, NULL)) && pidlDest &&
            ILIsWeb(pidlDest))
        {

            TCHAR szPath[MAX_PATH];

            // We want to ensure that we first give NavFrameWithFile a chance
            // since this will do the right thing if the PIDL points to a
            // shortcut.
            // If the PIDL is a shortcut, NavFrameWithFile will restore any
            // persistence information stored in the shortcut
            // if that fails - we take the default code path that simply
            // uses the PIDL
            lRet = SUCCEEDED(GetPathForItem(_psf, pidl, szPath, NULL)) &&
                   SUCCEEDED(NavFrameWithFile(szPath, (IServiceProvider *)this));

            if (!lRet)
            {
                if (EVAL(_pbp) && (SUCCEEDED(_pbp->NavigateToPIDL(pidlDest))))
                    lRet = 1;
            }
            ILFree(pidlDest);
        }
    }

    if (!lRet)
    {
        IContextMenu *pcm = (LPCONTEXTMENU)_GetUIObjectOfPidl(pidl, IID_IContextMenu);
        if (pcm)
        {
            LPCSTR pVerb = NULL;
            UINT fFlags = 0;

            // If ALT double click, accelerator for "Properties..."
            if (GetKeyState(VK_MENU) < 0)
            {
                pVerb = SZ_PROPERTIESA;
            }

            //  SHIFT+dblclick does a Explore by default
            if (GetKeyState(VK_SHIFT) < 0)
            {
                fFlags |= CMF_EXPLORE;
            }

            IContextMenu_Invoke(pcm, _hwndTB, pVerb, fFlags);

            pcm->Release();
        }
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Helper function to call the menubar site's IMenuPopup::OnSelect
         method.

*/
HRESULT CISFBand::_SiteOnSelect(DWORD dwType)
{
    IMenuPopup * pmp;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp));
    if (SUCCEEDED(hr))
    {
        pmp->OnSelect(dwType);
        pmp->Release();
    }
    return hr;
}

LRESULT CISFBand::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uiCmd = GET_WM_COMMAND_ID(wParam, lParam);
    LRESULT lres = 0;

    TraceMsg(TF_BAND, "_OnCommand 0x%x", uiCmd);

    LPCITEMIDLIST pidl = _IDToPidl(uiCmd);

    if (pidl)
    {
        if (_eUemLog != UEMIND_NIL) 
        {
            // FEATURE_UASSIST should be grp,uiCmd
            UEMFireEvent(&UEMIID_SHELL, UEME_UIQCUT, UEMF_XEVENT, -1, (LPARAM)-1);
        }

        // Only do this if we are the quick links in the browser. The derived class will set this
        if (_pguidUEMGroup)
        {
            LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
            if (pidlFull)
            {
                UEMFireEvent(_pguidUEMGroup, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)_psf, (LPARAM)pidl);
                SHSendChangeMenuNotify(NULL, SHCNEE_PROMOTEDITEM, 0, pidlFull);
                ILFree(pidlFull);
            }
        }

        lres = _TryCascadingItem(pidl, uiCmd);

        if (!lres && _fChannels)
            lres = _TryChannelSurfing(pidl);

        if (!lres)
            lres = _TrySimpleInvoke(pidl);
    }
    else
    {
        MessageBeep(MB_OK);
    }

    return(lres);
}

// *** IPersistStream
HRESULT CISFBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ISFBand;
    return S_OK;
}

//  This might be a directory inside CSIDL_APPDATA that was created on
//  a Win9x machine.  Win9x doesn't do the special folder signature info,
//  so when it shows up on NT, it's just a boring directory that now points
//  to the wrong place.
//  So if we get a bad directory, see if it's one of these corrupted
//  Win9x pidls and if so, try to reconstitute the original CSIDL_APPDATA
//  by searching for "Application Data".

void CISFBand::_FixupAppDataDirectory()
{
    TCHAR szDirPath[MAX_PATH];

    //  We use PathFileExists to check for existence because it turns off
    //  hard error boxes if the target is not available (e.g., floppy not
    //  in drive)

    if (SHGetPathFromIDList(_pidl, szDirPath) &&
        !PathFileExists(szDirPath))
    {
        static TCHAR szBSAppData[] = TEXT("\\Application Data");
        LPTSTR pszAppData;

        // For every instance of "Application Data", try to graft it
        // into the real CSIDL_APPDATA. If it works, run with it.

        for (pszAppData = szDirPath;
             pszAppData = StrStrI(pszAppData, szBSAppData);
             pszAppData++)
        {
            // Found a candidate.  The thing after "\\Application Data"
            // had better be another backslash (in which case we step
            // over it) or the end of the string (in which case we don't).

            TCHAR szPathBuffer[MAX_PATH];
            LPTSTR pszTail = pszAppData + ARRAYSIZE(szBSAppData) - 1;

            // If we did our math right, we should be right after the
            // "a" at the end of "Application Data".
            ASSERT(pszTail[-1] == TEXT('a'));

            if (pszTail[0] == TEXT('\\'))
                pszTail++;              // Step over separator
            else if (pszTail[0] == TEXT('\0'))
                { }                     // at end of string; stay there
            else
                continue;               // we were faked out; keep looking

            if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szPathBuffer)))
            {
                PathCombine(szPathBuffer, szPathBuffer, pszTail);
                if (PathFileExists(szPathBuffer))
                {
                    LPITEMIDLIST    pidlReal;
                    pidlReal = ILCreateFromPath(szPathBuffer);
                    if (pidlReal)
                    {
                        ILFree(_pidl);
                        _pidl = pidlReal;
                    }
                    ASSERT(_pidl);
                    break;              // found it; stop looking
                }
            }
        }
    }
}

typedef struct tagBANDISFSTREAM {
    WORD        wVersion;   // version of this structure
    WORD        cbSize;     // size of this structure
    DWORD       dwFlags;    // BANDISF_ flags
    DWORD       dwPriv;     // special folder identifier
    WORD        wViewMode;  // small/large/logo
    WORD        wUnused;    // For DWORD alignment
    COLORREF    crBkgnd;    // band background color
    COLORREF    crBtnLt;    // band button hilite color
    COLORREF    crBtnDk;    // band button lolite color
} BANDISFSTREAM, * PBANDISFSTREAM;

#define BANDISF_VERSION 0x22

#define BANDISF_MASK_PSF         0x00000001 // TRUE if _psf is saved
#define BANDISF_BOOL_NOSHOWTEXT  0x00000002 // TRUE if _fNoShowText
#define BANDISF_BOOL_LARGEICON   0x00000004 // last used in version 0x20
#define BANDISF_MASK_PIDLASLINK  0x00000008 // TRUE if _pidl is saved as a link
#define BANDISF_UNUSED10         0x00000010 // (obsolete) was BOOL_NOTITLE
#define BANDISF_BOOL_CHANNELS    0x00000020 // TRUE if in channel mode
#define BANDISF_BOOL_ALLOWRENAME 0x00000040 // TRUE if _psf context menu should be enabled
#define BANDISF_BOOL_DEBOSSED    0x00000080 // TRUE if band should have embossed background
#define BANDISF_MASK_ORDERLIST   0x00000100 // TRUE if an order list is saved
#define BANDISF_BOOL_BKCOLOR     0x00000200 // TRUE if bk color is persisted
#define BANDISF_BOOL_FULLOPEN    0x00000400 // TRUE if band should maximize when opened
#define BANDISF_BOOL_NONAMESORT  0x00000800 // TRUE if band should _not_ sort icons by name
#define BANDISF_BOOL_BTNMINSIZE  0x00001000 // TRUE if band should report min thickness of button
#define BANDISF_BOOL_COLORS      0x00002000 // TRUE if colors are persisted
#define BANDISF_VALIDBITS        0x00003FFF

HRESULT CISFBand::Load(IStream *pstm)
{
    HRESULT hr;
    DWORD cbRead;
    BANDISFSTREAM bisfs = {0};

    // figure out what we need to load
    // read first DWORD only (old stream format started with ONE dword)
    hr = pstm->Read(&bisfs, sizeof(DWORD), &cbRead);
    _fIgnoreAddToFront = TRUE;

    if (SUCCEEDED(hr))
    {
        if (bisfs.cbSize == 0)
        {
            // upgrade case, IE4 beta1 shipped this way
            bisfs.dwFlags = *((LPDWORD)&bisfs);
            bisfs.cbSize = sizeof(bisfs);
            bisfs.wVersion = BANDISF_VERSION;
            bisfs.dwPriv = -1;
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        }
        else
        {
            // read rest of stream
            DWORD dw = (DWORD)bisfs.cbSize;
            if (dw > sizeof(bisfs))
                dw = sizeof(bisfs);
            dw -= sizeof(DWORD);
            hr = pstm->Read(&(bisfs.dwFlags), dw, &cbRead);
            if (FAILED(hr))
                return(hr);
        }

        // HEY, DON'T BE LAME ANY MORE.  When you next touch this code,
        // I suggest you figure out what sizes of this structure have
        // been actually shipped and only upgrade those.  Also use
        // the offsetof macro so you don't have to keep calculating these
        // things...

        // old upgrade, I don't know what state is persisted at setup time!
        if (bisfs.cbSize == sizeof(bisfs) - 3*sizeof(COLORREF) - sizeof(DWORD) - sizeof(DWORD))
        {
            bisfs.dwPriv = -1;
            bisfs.cbSize += sizeof(DWORD);
        }
        // most recent upgrade, this is NOT persisted in registry at setup time!!!
        if (bisfs.cbSize == sizeof(bisfs) - 3*sizeof(COLORREF) - sizeof(DWORD))
        {
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
            bisfs.cbSize = sizeof(bisfs);
        }
        // upgrade from version 0x21 + crBkgnd only to 0x22
        if (bisfs.cbSize == sizeof(bisfs) - 2*sizeof(COLORREF))
        {
            bisfs.cbSize = sizeof(bisfs);
        }
        // upgrade from version 0x21 to 0x22
        if (bisfs.cbSize == sizeof(bisfs) - 3*sizeof(COLORREF))
        {
            bisfs.cbSize = sizeof(bisfs);
        }

        if (!EVAL(bisfs.cbSize >= sizeof(bisfs)))
        {
            return(E_FAIL);
        }
        ASSERT(!(bisfs.dwFlags & ~BANDISF_VALIDBITS));

        if (bisfs.dwFlags & BANDISF_BOOL_NOSHOWTEXT)
            _fNoShowText = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_ALLOWRENAME)
            _fAllowRename = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_DEBOSSED)
            _fDebossed = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_FULLOPEN)
            _fFullOpen = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_NONAMESORT)
            _fNoNameSort = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BTNMINSIZE)
            _fBtnMinSize = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BKCOLOR)
        {
            _crBkgnd = bisfs.crBkgnd;
            _fHaveBkColor = TRUE;
        }
        if (bisfs.dwFlags & BANDISF_BOOL_COLORS)
        {
            _crBtnLt = bisfs.crBtnLt;
            _crBtnDk = bisfs.crBtnDk;
            _fHaveColors = TRUE;
        }

        _dwPriv = bisfs.dwPriv;
        if (_dwPriv == CSIDL_APPDATA) 
        {
            _eUemLog = UEMIND_SHELL;
        }

        _uIconSize = bisfs.wViewMode;
        _fNoRecalcDefaults = TRUE;

        if (bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
        {
            ASSERT(NULL==_pidl);
            hr = LoadPidlAsLink(_punkSite, pstm, &_pidl);
            // If we hit hits, LoadPidlAsLink() read a chuck of our data. - BryanSt
            ASSERT(SUCCEEDED(hr));

//            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
//            TraceMsg(TF_BAND|TF_GENERAL, "CISFBand::Load() _pidl=>%s<", Dbg_PidlStr(_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

            _FixupAppDataDirectory();

        }
                
        if (SUCCEEDED(hr) && (bisfs.dwFlags & BANDISF_MASK_PSF))
        {
            ASSERT(NULL == _psf);
            hr = OleLoadFromStream(pstm, IID_PPV_ARG(IShellFolder, &_psf));
        }

        // map this to working info
        if (SUCCEEDED(hr))
            hr = _AfterLoad();

        // we need _psf before we can read the order list.
        if (SUCCEEDED(hr) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
        {
            hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);

            if (SUCCEEDED(hr))
            {
                // _fDropped "persists" along with the orderlist - if this flag
                // is set, we assume we have a non-default ordering
                _fDropped = TRUE;
            }
        }
    }

    return hr;
}

HRESULT SaveIsfToStream(IShellFolder *psf, IStream *pstm)
{
    IPersistStream* pps;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = OleSaveToStream(pps, pstm);
        pps->Release();
    }
    return hr;
}

HRESULT CISFBand::Save(IStream *pstm, BOOL fClearDirty)
{
    IPersistStream* pps = NULL;
    BANDISFSTREAM bisfs = {0};

    // figure out what we will save
    if (_pidl)
        bisfs.dwFlags |= BANDISF_MASK_PIDLASLINK;

    if (_psf && !_fPSFBandDesktop)
        bisfs.dwFlags |= BANDISF_MASK_PSF;
    if (_fDropped && (_hdpa || _hdpaOrder)) // only if a drop occurred do we have non-default ordering
        bisfs.dwFlags |= BANDISF_MASK_ORDERLIST;

    if (_fNoShowText)
        bisfs.dwFlags |= BANDISF_BOOL_NOSHOWTEXT;
    if (_fAllowRename)
        bisfs.dwFlags |= BANDISF_BOOL_ALLOWRENAME;
    if (_fDebossed)
        bisfs.dwFlags |= BANDISF_BOOL_DEBOSSED;
    if (_fFullOpen)
        bisfs.dwFlags |= BANDISF_BOOL_FULLOPEN;
    if (_fNoNameSort)
        bisfs.dwFlags |= BANDISF_BOOL_NONAMESORT;
    if (_fBtnMinSize)
        bisfs.dwFlags |= BANDISF_BOOL_BTNMINSIZE;
    if (_fHaveBkColor)
    {
        bisfs.dwFlags |= BANDISF_BOOL_BKCOLOR;
        bisfs.crBkgnd = _crBkgnd;
    }
    if (_fHaveColors)
    {
        bisfs.dwFlags |= BANDISF_BOOL_COLORS;
        bisfs.crBtnLt = _crBtnLt;
        bisfs.crBtnDk = _crBtnDk;
    }

    bisfs.cbSize = sizeof(bisfs);
    bisfs.wVersion = BANDISF_VERSION;
    bisfs.dwPriv = _dwPriv;
    bisfs.wViewMode = _uIconSize;

    // now save it
    HRESULT hr = pstm->Write(&bisfs, sizeof(bisfs), NULL);

    if (SUCCEEDED(hr) && bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
    {
        hr = SavePidlAsLink(_punkSite, pstm, _pidl);
    }

    if (SUCCEEDED(hr) && bisfs.dwFlags & BANDISF_MASK_PSF)
    {
        hr = SaveIsfToStream(_psf, pstm);
    }

    if (SUCCEEDED(hr) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
    {
        hr = OrderList_SaveToStream(pstm, (_hdpa ? _hdpa : _hdpaOrder), _psf);
    }


    return hr;
}

// IContextMenu implementation
HRESULT CISFBand::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fChanged = FALSE;
    int idCmd = -1;

    UINT uNewMode = 0;
    if (!HIWORD(lpici->lpVerb))
        idCmd = LOWORD(lpici->lpVerb);
    switch (idCmd)
    {
    case ISFBIDM_LARGE:
        uNewMode = ISFBVIEWMODE_LARGEICONS;
        goto newViewMode;

    case ISFBIDM_SMALL:
        uNewMode = ISFBVIEWMODE_SMALLICONS;
newViewMode:
        if (uNewMode != _uIconSize)
        {
            BOOL fRefresh = FALSE;

            if (uNewMode == ISFBVIEWMODE_LOGOS || _uIconSize == ISFBVIEWMODE_LOGOS)
            {
                // invalidate all before switching the imagelist...
                _RememberOrder();

                EmptyToolbar();
                fRefresh = TRUE;
            }

            // we Logo view has now left the building...
            if (uNewMode != ISFBVIEWMODE_LOGOS && _uIconSize == ISFBVIEWMODE_LOGOS)
            {
                ExitLogoView();
            }

            fChanged = _UpdateIconSize(uNewMode, TRUE);

            if (fRefresh)
            {
                _FillToolbar();
            }
            if (fChanged)
                _BandInfoChanged();
        }
        // fall thru
    default:
        return CSFToolbar::InvokeCommand(lpici);
    }

    return(S_OK);
}

// *** IOleCommandTarget methods ***

STDMETHODIMP CISFBand::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case ISFBID_CACHEPOPUP:
            case ISFBID_ISITEMVISIBLE:
            case ISFBID_PRIVATEID:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SHDVID_UEMLOG:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }

    return hr;
}

HRESULT CISFBand::_IsPidlVisible(LPITEMIDLIST pidl)
{
    int i;
    HRESULT hr = _GetButtonFromPidl(pidl, NULL, &i, NULL);

    if (SUCCEEDED(hr))
    {
        RECT rc;
        GetClientRect(_hwndTB, &rc);

        if (SHIsButtonObscured(_hwndTB, &rc, i))
            hr = S_FALSE;
        else
            hr = S_OK;
    }

    return hr;
}

HRESULT CISFBand::_OrderListFromIStream(VARIANT* pvarargIn)
{
    HRESULT hr = E_FAIL;
    if (pvarargIn->vt == VT_UNKNOWN)
    {
        IStream* pstm;
        if (SUCCEEDED(pvarargIn->punkVal->QueryInterface(IID_PPV_ARG(IStream, &pstm))))
        {
            OrderList_Destroy(&_hdpaOrder);
            hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);
            if (SUCCEEDED(hr))
            {
                _SetDirty(TRUE);
                // flush out since our orderlist changed -- filltoolbar will just
                // do a diff and that won't do anything on a simple reordering.
                EmptyToolbar();
                if (_fShow)
                {
                    _FillToolbar();
                }
            }
            pstm->Release();
        }
    }

    return hr;
}

HRESULT CISFBand::_IStreamFromOrderList(VARIANT* pvarargOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    ASSERT(pvarargOut != NULL);

    IStream* pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        hr = OrderList_SaveToStream(pstm, _hdpa, _psf);
        if (SUCCEEDED(hr))
        {
            pvarargOut->vt = VT_UNKNOWN;
            pvarargOut->punkVal = pstm;
            pvarargOut->punkVal->AddRef();
        }
        pstm->Release();
    }

    return hr;
}

STDMETHODIMP CISFBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case ISFBID_CACHEPOPUP:
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN)
            {
                IMenuPopup* pmp = NULL;
                if (pvarargIn->punkVal)
                    pvarargIn->punkVal->QueryInterface(IID_PPV_ARG(IMenuPopup, &pmp));

                _SetCacheMenuPopup(pmp);

                ATOMICRELEASE(pmp);
            }

            if (pvarargOut)
            {
                pvarargOut->vt = VT_UNKNOWN;
                pvarargOut->punkVal = _pmpCache;
                if (_pmpCache)
                    _pmpCache->AddRef();
            }
            return S_OK;

        case ISFBID_ISITEMVISIBLE:
            {
                HRESULT hr = E_INVALIDARG;

                if (pvarargIn && pvarargIn->vt == VT_INT_PTR)
                    hr = _IsPidlVisible((LPITEMIDLIST)pvarargIn->byref);

                return hr;
            }

        case ISFBID_PRIVATEID:
            // hack hack for BSMenu to differentiate between specially created
            // isfbands. see bsmenu's _FindBand
            // if pvarargOut is set, we give back the id we have stored.
            if (pvarargOut)
            {
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _dwPriv;
            }
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _dwPriv = pvarargIn->lVal;

            return S_OK;

        case ISFBID_GETORDERSTREAM:
            return _IStreamFromOrderList(pvarargOut);

        case ISFBID_SETORDERSTREAM:
            return _OrderListFromIStream(pvarargIn);
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_UEMLOG:
            ASSERT(pvarargOut == NULL);
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _eUemLog = pvarargIn->lVal;
                ASSERT(_eUemLog == UEMIND_SHELL || _eUemLog == UEMIND_BROWSER);
            }

            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_DeskBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBID_DELAYINIT:
            _fDelayInit = TRUE;
            break;

        case DBID_FINISHINIT:
            _fDelayInit = FALSE;
            _RegisterToolbar();
            break;

        case DBID_SETWINDOWTHEME:
            if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                if (_hwndTB)
                {
                    SendMessage(_hwndTB, TB_SETWINDOWTHEME, 0, (LPARAM)pvarargIn->bstrVal);
                    _BandInfoChanged();
                }
            }
        }
        return S_OK;
    }
    
    return OLECMDERR_E_NOTSUPPORTED;
}

IShellFolder * CISFBand::GetSF()
{
    ASSERT(_psf);
    return _psf;
}

HWND CISFBand::GetHWND()
{
    return _hwndTB;
}

REFTASKOWNERID CISFBand::GetTOID()
{
    return TOID_ExtractImage;
}

HRESULT CISFBand::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (lEvent == SHCNE_RMDIR && _IsEqualID(pidl1))
    {
        HRESULT hr = E_FAIL;
        IBandSite *pbandSite;
        if (_punkSite)
        {
            hr = _punkSite->QueryInterface(IID_PPV_ARG(IBandSite, &pbandSite));
            if (EVAL(SUCCEEDED(hr))) 
            {
                pbandSite->RemoveBand(_dwBandID);
                pbandSite->Release();
            }
        }
        return hr;
    }
    else
    {
        return CSFToolbar::OnTranslatedChange(lEvent, pidl1, pidl2);
    }
}

HRESULT CISFBand::UpdateLogoCallback(DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache)
{
    int iItem = (int)dwItem;
    HRESULT hr;
    UINT uImage;

    // catch if we are closing...
    if (_fClosing)
        return S_OK;

    IMAGECACHEINFO rgInfo;
    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
    rgInfo.cbSize = sizeof(rgInfo);
    rgInfo.pszName = pszCache;

    rgInfo.hBitmapLarge = hImage;

    ASSERT(_pLogoCache);
    if (_pLogoCache)
        hr = _pLogoCache->AddImage(&rgInfo, &uImage);
    else
        hr = E_FAIL;

    // catch if we are closing...
    if (_fClosing)
        return S_OK;

    if (SUCCEEDED(hr))
    {
        // remember the icon to logo mapping....
        AddIndicesToLogoList(iIcon, uImage);

        // catch we are closing before we try and doa bloc
        PostMessage(_hwndTB, TB_CHANGEBITMAP, iItem, uImage);
    }

    // stop delay painting when the last extract image task calls back
    if (_fDelayPainting)
    {
        if (_pTaskScheduler && _pTaskScheduler->CountTasks(TOID_NULL) == 1)
        {
            _StopDelayPainting();
        }
    }

    return hr;
}

// }


HRESULT CISFBand::_GetTitleW(LPWSTR pwszTitle, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    TraceMsg(TF_BAND, "Calling baseclass CISFBand::_GetTitleW");

    if (!EVAL(pwszTitle))
        return E_INVALIDARG;

    *pwszTitle = 0;
    if (_pidl)
    {
        hr = SHGetNameAndFlagsW(_pidl, SHGDN_NORMAL, pwszTitle, cchSize, NULL);
    }

    return hr;
}

STDAPI NavigateToPIDL(IWebBrowser2* pwb, LPCITEMIDLIST pidl);

LRESULT CISFBand::_TryChannelSurfing(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    ASSERT(_fChannels);

    LPITEMIDLIST pidlTarget;

    HRESULT hr = SHGetNavigateTarget(_psf, pidl, &pidlTarget, NULL);
    if (SUCCEEDED(hr))
    {
        IWebBrowser2* pwb;

        // n.b. careful! only one of GCB and C_OB up the refcnt
        _GetChannelBrowser(&pwb);
        if (SUCCEEDED(Channels_OpenBrowser(&pwb, pwb != NULL)))
        {
            lRet = 1;   // success at this point

            if (SUCCEEDED(NavigateToPIDL(pwb, pidlTarget)))
            {
                LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
                if (pidlFull)
                {
                    VARIANT varURLpidl, flags;
                    flags.vt = VT_I4;
                    flags.lVal = navBrowserBar;
                    if (SUCCEEDED(InitVariantFromIDList(&varURLpidl, pidlFull)))
                    {
                        pwb->Navigate2(&varURLpidl, &flags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                        VariantClear(&varURLpidl);
                    }
                    ILFree(pidlFull);
                }
            }
        }
        if (pwb)
            pwb->Release();

        ILFree(pidlTarget);
    }

    return lRet;
}

//***   _GetChannelBrowser -- find appropriate browser for surfing
// DESCRIPTION
//  for the DTBrowser case, we fail (pwb=NULL, hr=S_FALSE) so that our
// caller will create a new SHBrowser (which can be put into theater mode).
// for the SHBrowser case, we find the top-level browser (so we'll navigate
// in-place).
HRESULT CISFBand::_GetChannelBrowser(IWebBrowser2 **ppwb)
{
    HRESULT hr;

    *ppwb = NULL;   // assume failure
    if (_fDesktop) 
    {
        ASSERT(*ppwb == NULL);
        hr = S_FALSE;
    }
    else 
    {
        hr = IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IWebBrowser2, ppwb));
    }

    return hr;
}

HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi)
{
    HRESULT hr = E_FAIL;

    if (punkBand) 
    {
        IShellFolderBand *pisfBand;
        hr = punkBand->QueryInterface(IID_PPV_ARG(IShellFolderBand, &pisfBand));
        if (EVAL(SUCCEEDED(hr))) 
        {
            hr = pisfBand->SetBandInfoSFB(pbi);
            pisfBand->Release();
        }
    }
    return hr;
}


///////////////////////////CLogoExtractImageTask///////////////////////////////////////////////

// Warning
// The CLogoBase class cannot have a ref on the returned task
// since that would be a circular reference
// Warning

HRESULT CLogoExtractImageTask_Create(CLogoBase *plb,
                                  IExtractImage *pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  IRunnableTask ** ppTask)
{
    if (!ppTask || !plb || !pExtract)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    CLogoExtractImageTask * pNewTask = new CLogoExtractImageTask(&hr, plb, pExtract, pszCache, dwItem, iIcon, dwFlags);
    if (pNewTask)
    {
        *ppTask = SAFECAST(pNewTask, IRunnableTask *);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


CLogoExtractImageTask::CLogoExtractImageTask(HRESULT * pHr, CLogoBase *plb, IExtractImage * pImage,
    LPCWSTR pszCache, DWORD dwItem, int iIcon, DWORD dwFlags)
{
    m_lState = IRTIR_TASK_NOT_RUNNING;

    m_plb = plb;
    m_plb->AddRef();

    // cannot assume the band will kill us before it dies....
    // hence we hold a reference

    StrCpyW(m_szPath, pszCache);

    m_pExtract = pImage;
    pImage->AddRef();

    m_cRef = 1;

    // use the upper bit of the flags to determine if we should always call....
    m_dwFlags = dwFlags;
    m_dwItem = dwItem;
    m_iIcon = iIcon;

    // Since the task moves from thread to thread,
    // don't charge this thread for the objects we're using
}

CLogoExtractImageTask::~CLogoExtractImageTask()
{
    ATOMICRELEASE(m_pExtract);
    ATOMICRELEASE(m_pTask);

    if (m_hBmp && !(m_dwFlags & EITF_SAVEBITMAP))
    {
        DeleteObject(m_hBmp);
    }

    if (m_plb)
        m_plb->Release();
}

STDMETHODIMP CLogoExtractImageTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CLogoExtractImageTask, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CLogoExtractImageTask::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_ (ULONG) CLogoExtractImageTask::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP CLogoExtractImageTask::Run(void)
{
    HRESULT hr = E_FAIL;
    if (m_lState == IRTIR_TASK_RUNNING)
    {
        hr = S_FALSE;
    }
    else if (m_lState == IRTIR_TASK_PENDING)
    {
        hr = E_FAIL;
    }
    else if (m_lState == IRTIR_TASK_NOT_RUNNING)
    {
        LONG lRes = InterlockedExchange(& m_lState, IRTIR_TASK_RUNNING);
        if (lRes == IRTIR_TASK_PENDING)
        {
            m_lState = IRTIR_TASK_FINISHED;
            return S_OK;
        }

        // see if it supports IRunnableTask
        m_pExtract->QueryInterface(IID_PPV_ARG(IRunnableTask, &m_pTask));

        // IE4.01 has an error - it returns the wrong VTABLE
        // when this QI is done.

        if ((void *)m_pTask == (void *)m_pExtract)
        {
            m_pTask = m_pTask + 2; // This vtable is two ptrs away and is in fstree.cpp in shell32 in IE4.01
        }

        if (m_lState == IRTIR_TASK_RUNNING)
        {
            // start the extractor....
            hr = m_pExtract->Extract(&m_hBmp);
        }

        if ((SUCCEEDED(hr) || (hr != E_PENDING && (m_dwFlags & EITF_ALWAYSCALL))) && m_lState == IRTIR_TASK_RUNNING)
        {
            hr = InternalResume();
        }

        if (m_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING)
        {
            m_lState = IRTIR_TASK_FINISHED;
        }
    }

    return hr;
}

STDMETHODIMP CLogoExtractImageTask::Kill(BOOL fWait)
{
    if (m_lState != IRTIR_TASK_RUNNING)
    {
        return S_FALSE;
    }

    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_PENDING);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        m_lState = lRes;
        return S_OK;
    }

    // does it support IRunnableTask ? Can we kill it ?
    HRESULT hr = E_NOTIMPL;
    if (m_pTask != NULL)
    {
        hr = m_pTask->Kill(FALSE);
    }

    return hr;
}

STDMETHODIMP CLogoExtractImageTask::Suspend(void)
{
    if (!m_pTask)
    {
        return E_NOTIMPL;
    }

    if (m_lState != IRTIR_TASK_RUNNING)
    {
        return E_FAIL;
    }


    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_SUSPENDED);
    HRESULT hr = m_pTask->Suspend();
    if (SUCCEEDED(hr))
    {
        lRes = (LONG) m_pTask->IsRunning();
        if (lRes == IRTIR_TASK_SUSPENDED)
        {
            m_lState = lRes;
        }
    }
    else
    {
        m_lState = lRes;
    }

    return hr;
}

STDMETHODIMP CLogoExtractImageTask::Resume(void)
{
    if (!m_pTask)
    {
        return E_NOTIMPL;
    }

    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        return E_FAIL;
    }

    m_lState = IRTIR_TASK_RUNNING;

    HRESULT hr = m_pTask->Resume();
    if (SUCCEEDED(hr) || (hr != E_PENDING && (m_dwFlags & EITF_ALWAYSCALL)))
    {
        hr = InternalResume();
    }

    return hr;
}

HRESULT CLogoExtractImageTask::InternalResume()
{
    HRESULT hr = S_OK;
    if (m_dwFlags & EITF_ALWAYSCALL || m_hBmp)
    {
        // call the update function
        hr = m_plb->UpdateLogoCallback(m_dwItem, m_iIcon, m_hBmp, m_szPath, TRUE);
    }

    m_lState = IRTIR_TASK_FINISHED;

    return hr;
}

STDMETHODIMP_(ULONG) CLogoExtractImageTask:: IsRunning(void)
{
    return m_lState;
}


// static data...
IImageCache * CLogoBase::s_pSharedWideLogoCache = NULL;
long CLogoBase::s_lSharedWideLogosRef = 0;
HDSA CLogoBase::s_hdsaWideLogoIndices = NULL;
CRITICAL_SECTION CLogoBase::s_csSharedLogos = {0};

extern "C" void CLogoBase_Initialize(void)
{
    CLogoBase::_Initialize();
}

extern "C" void CLogoBase_Cleanup(void)
{
    CLogoBase::_Cleanup();
}

void CLogoBase::_Initialize(void)
{
    InitializeCriticalSection(&s_csSharedLogos);
}

void CLogoBase::_Cleanup(void)
{
    DeleteCriticalSection(& s_csSharedLogos);
}


CLogoBase::CLogoBase(BOOL fWide)
{
    // are we paletized, then use the global halftone palette ....
    HDC hdcTmp = GetDC(NULL);
    if (hdcTmp)
    {
        if (GetDeviceCaps(hdcTmp, RASTERCAPS) & RC_PALETTE)
        {
            // we're allocating in the constructor, but so what
            // nobody calls this code anyway, i was going to delete it all but that bug got punted
            _hpalHalftone = SHCreateShellPalette(NULL);
        }
        ReleaseDC(NULL, hdcTmp);
    }

    _fWide = fWide;
}

CLogoBase::~CLogoBase()
{
    if (_pLogoCache || _pTaskScheduler)
    {
        ExitLogoView();
    }

    if (_hpalHalftone)
    {
        DeletePalette(_hpalHalftone);
    }
}

HRESULT CLogoBase::AddRefLogoCache(void)
{
    if (_fWide)
    {
        EnterCriticalSection(&s_csSharedLogos);

        if (!s_lSharedWideLogosRef)
        {
            if (!s_hdsaWideLogoIndices)
            {
                s_hdsaWideLogoIndices = DSA_Create(sizeof(LogoIndex), 5);
                if (!s_hdsaWideLogoIndices)
                {
                    LeaveCriticalSection(&s_csSharedLogos);
                    return E_OUTOFMEMORY;
                }
            }

            ASSERT(s_hdsaWideLogoIndices);
            ASSERT(!s_pSharedWideLogoCache);

            HRESULT hr = CoCreateInstance(CLSID_ImageListCache, NULL, CLSCTX_INPROC,
                                           IID_PPV_ARG(IImageCache, &s_pSharedWideLogoCache));
            if (FAILED(hr))
            {
                LeaveCriticalSection(&s_csSharedLogos);
                return hr;
            }
        }

        ASSERT(s_pSharedWideLogoCache);

        // bump up the ref and get a pointer to it...
        s_lSharedWideLogosRef ++;
        _pLogoCache = s_pSharedWideLogoCache;
        _pLogoCache->AddRef();
        _hdsaLogoIndices = s_hdsaWideLogoIndices;
        LeaveCriticalSection(&s_csSharedLogos);

        return S_OK;
    }
    else
    {
        // non wide logo version we don't share because w eonly expect there ever to be one...
        _hdsaLogoIndices = DSA_Create(sizeof(LogoIndex), 5);
        if (!_hdsaLogoIndices)
        {
            return E_OUTOFMEMORY;
        }

        return CoCreateInstance(CLSID_ImageListCache, NULL, CLSCTX_INPROC, IID_PPV_ARG(IImageCache, &_pLogoCache));
    }
}

HRESULT CLogoBase::ReleaseLogoCache(void)
{
    if (!_pLogoCache)
    {
        return S_FALSE;
    }

    ATOMICRELEASE(_pLogoCache);

    if (_fWide)
    {
        EnterCriticalSection(&s_csSharedLogos);

        ASSERT(s_lSharedWideLogosRef > 0);

        s_lSharedWideLogosRef --;
        if (! s_lSharedWideLogosRef)
        {
            // let go of the final ref.....
            ATOMICRELEASE(s_pSharedWideLogoCache);

            ASSERT(s_hdsaWideLogoIndices);
            DSA_Destroy(s_hdsaWideLogoIndices);
            s_hdsaWideLogoIndices = NULL;
        }

        LeaveCriticalSection(&s_csSharedLogos);
    }
    else
    {
        // free the HDSA
        DSA_Destroy(_hdsaLogoIndices);
    }

    return S_OK;
}

HRESULT CLogoBase::InitLogoView(void)
{
    HRESULT hr = AddRefLogoCache();
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                              IID_PPV_ARG(IShellTaskScheduler, &_pTaskScheduler));
        if (FAILED(hr))
        {
            ATOMICRELEASE(_pLogoCache);
        }
        else
        {
            _rgLogoSize.cx = (_fWide) ? LOGO_WIDE_WIDTH : LOGO_WIDTH ;
            _rgLogoSize.cy = LOGO_HEIGHT;

            IMAGECACHEINITINFO rgInfo;
            rgInfo.cbSize = sizeof(rgInfo);
            rgInfo.dwMask = ICIIFLAG_LARGE;
            rgInfo.iStart = 0;
            rgInfo.iGrow = 5;

            // the color depth is currently the screen resolution...
            int iColorRes = SHGetCurColorRes();

            _dwClrDepth = (DWORD) iColorRes;
            switch (iColorRes)
            {
                case 16 :   rgInfo.dwFlags = ILC_COLOR16;
                            break;
                case 24 :
                case 32 :   rgInfo.dwFlags = ILC_COLOR24;
                            break;
                default :   rgInfo.dwFlags = ILC_COLOR8;
            }

            rgInfo.rgSizeLarge = _rgLogoSize;
            if (_pLogoCache)
                hr = _pLogoCache->GetImageList(&rgInfo);
            else
                hr = E_UNEXPECTED;

            if (FAILED(hr))
            {
                ATOMICRELEASE(_pLogoCache);
                ATOMICRELEASE(_pTaskScheduler);
            }
            else
            {
                _himlLogos = rgInfo.himlLarge;

                // GetImageList() will return S_FALSE if it was already created...
                if ((hr == S_OK) && (iColorRes <= 8))
                {
                    // init the color table so that it matches The "special halftone palette"
                    HPALETTE hpal = SHCreateShellPalette(NULL);
                    PALETTEENTRY rgColours[256];
                    RGBQUAD rgDIBColours[256];

                    ASSERT(hpal);
                    int nColours = GetPaletteEntries(hpal, 0, ARRAYSIZE(rgColours), rgColours);

                    // SHGetShellPalette should always return a 256 colour palette
                    ASSERT(nColours == ARRAYSIZE(rgColours));

                    // translate from the LOGPALETTE structure to the RGBQUAD structure ...
                    for (int iColour = 0; iColour < nColours; iColour ++)
                    {
                        rgDIBColours[iColour].rgbRed = rgColours[iColour].peRed;
                        rgDIBColours[iColour].rgbBlue = rgColours[iColour].peBlue;
                        rgDIBColours[iColour].rgbGreen = rgColours[iColour].peGreen;
                        rgDIBColours[iColour].rgbReserved = 0;
                    }

                    DeletePalette(hpal);

                    ImageList_SetColorTable(_himlLogos, 0, 256, rgDIBColours);
                }
            }
        }
    }

    return hr;
}

HRESULT CLogoBase::ExitLogoView(void)
{
    ATOMICRELEASE(_pTaskScheduler);

    // the task scheduler callbacks can reference
    // the logocache, so make sure you free the
    // logo cache AFTER the task scheduler!
    ReleaseLogoCache();

    return S_OK;
}

int CLogoBase::GetCachedLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD *pdwFlags)
{
    DWORD dwPassedFlags = 0;

    if (pdwFlags)
    {
        dwPassedFlags = *pdwFlags;
        *pdwFlags = 0;
    }

    // No logo cache?
    if (!_pLogoCache)
        return 0;

    ASSERT(pidl);
    // HACK: this is used on browser only mode to tell what sort of logos we need...
    IExtractImage *pImage = NULL;
    int iImage = -1;
    HRESULT hr = E_FAIL;

    // IID_IEXtractLogo and IID_IExtractImage are the same interface, by using a new guid
    // it means we can selectively decided what can logo in logo view...
    hr = GetSF()->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractImage, NULL, &pImage));
    if (SUCCEEDED(hr))
    {
        // extract ....
        HBITMAP hImage;
        WCHAR szPath[MAX_PATH];
        DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_ASPECT | dwPassedFlags;
        IMAGECACHEINFO rgInfo;
        UINT uIndex;
        BOOL fAsync;
        DWORD dwPriority;

        rgInfo.cbSize = sizeof(rgInfo);

        hr = pImage->GetLocation(szPath, MAX_PATH, &dwPriority, &_rgLogoSize, _dwClrDepth, &dwFlags);
        fAsync = (hr == E_PENDING);
        if (SUCCEEDED(hr) || fAsync)
        {
            // mask off the flags passed to use by the flags returned from the extractor...
            if (pdwFlags)
                *pdwFlags = dwPassedFlags & dwFlags;

            rgInfo.dwMask = ICIFLAG_NAME;
            rgInfo.pszName = szPath;

            hr = _pLogoCache->FindImage(&rgInfo, &uIndex);
            if (hr == S_OK)
            {
                ATOMICRELEASE(pImage);
                return (int) uIndex;
            }

            if (fAsync)
            {
                IRunnableTask *pTaskTmp = NULL;

                ASSERT(_pTaskScheduler);

                // pass the icon index so we can find the right logo later...
                int iIcon = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
                hr = CLogoExtractImageTask_Create(this,
                                               pImage,
                                               szPath,
                                               dwItem,
                                               iIcon,
                                               0,
                                               &pTaskTmp);
                if (SUCCEEDED(hr))
                {
                    if (!ppTask)
                    {
                        hr = AddTaskToQueue(pTaskTmp, dwPriority, dwItem);
                        pTaskTmp->Release();
                    }
                    else
                    {
                        * ppTask = pTaskTmp;

                        ASSERT(pdwPriority);
                        *pdwPriority = dwPriority;
                    }
                }
                else if (ppTask)
                {
                    *ppTask = NULL;
                }

                // if all this failed, then we will just end up with a default
                // logo. This is only likely to fail in low memory conditions,
                // so that will be fine.

                // if this SUCCEEDED we will drop through to pick up a defualt piccy for now.
            }
            else
            {
                // otherwise extract synchronously.......
                hr = pImage->Extract(&hImage);
                if (SUCCEEDED(hr))
                {
                    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
                    rgInfo.hBitmapLarge = hImage;

                    hr = _pLogoCache->AddImage(&rgInfo, &uIndex);
                    DeleteObject(hImage);
                }
                if (SUCCEEDED(hr))
                {
                    iImage = (int) uIndex;
                }
            }
        }
    }

    ATOMICRELEASE(pImage);

    return iImage;
}

int CLogoBase::GetLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD *pdwFlags)
{
    int iImage = GetCachedLogoIndex(dwItem, pidl, ppTask, pdwPriority, pdwFlags);

    if (iImage == -1)
    {
        // always pass FALSE, we want the proper ICON, cdfview no longer hits the
        // wire for the icon so we can safely ask for the correct icon.
        iImage = GetDefaultLogo(pidl, FALSE);

    }
    return iImage;
}

HRESULT CLogoBase::AddTaskToQueue(IRunnableTask *pTask, DWORD dwPriority, DWORD dwItem)
{
    ASSERT(_pTaskScheduler);
    return _pTaskScheduler->AddTask(pTask, GetTOID(), dwItem, dwPriority);
}

int CLogoBase::GetDefaultLogo(LPCITEMIDLIST pidl, BOOL fQuick)
{
    USES_CONVERSION;

    // Get icon to draw from
    int iIndex = -1;
    if (!fQuick)
    {
        iIndex = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
    }
    if (iIndex < 0)
    {
        iIndex = II_DOCNOASSOC;
    }

    WCHAR wszText[MAX_PATH];

    wszText[0] = 0;

    STRRET strret;
    HRESULT hr = GetSF()->GetDisplayNameOf(pidl, SHGDN_NORMAL, &strret);
    if (SUCCEEDED(hr))
    {
        StrRetToBufW(&strret, pidl, wszText, ARRAYSIZE(wszText));
    }

    UINT uCacheIndex = (UINT) -1;

    if (_pLogoCache)    // We didn't have one in stress.
    {
        IMAGECACHEINFO rgInfo;
        rgInfo.cbSize = sizeof(rgInfo);
        rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX;
        rgInfo.pszName = wszText;
        rgInfo.iIndex = iIndex;

        hr = _pLogoCache->FindImage(&rgInfo, &uCacheIndex);
        if (hr == S_OK)
        {
            return uCacheIndex;
        }

        HBITMAP hDef;
        hr = CreateDefaultLogo(iIndex, _rgLogoSize.cx, _rgLogoSize.cy, W2T(wszText), &hDef);
        if (SUCCEEDED(hr))
        {
            rgInfo.hBitmapLarge = hDef;
            rgInfo.hMaskLarge = NULL;
            rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX | ICIFLAG_BITMAP | ICIFLAG_LARGE;

            hr = _pLogoCache->AddImage(&rgInfo, &uCacheIndex);
            if (FAILED(hr))
            {
                uCacheIndex = (UINT) -1;
            }
            else
            {
                // remember the index of the logo
                AddIndicesToLogoList(iIndex, uCacheIndex);
            }
            DeleteObject(hDef);
        }
    }

    return (int) uCacheIndex;
}

#define DXFUDGE     4
#define COLORTEXT   RGB(255,255,255)
#define COLORBK     RGB(0,0,0)
HRESULT CLogoBase::CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo)
{
    HRESULT hr = E_OUTOFMEMORY;
    HBITMAP hbmp = NULL;

    HIMAGELIST himl;
    int cxIcon, cyIcon;
   int x, y, dx, dy;

    // get the small icons....
    Shell_GetImageLists(NULL, &himl);
    ImageList_GetIconSize(himl, &cxIcon, &cyIcon);

    // Calculate position info. We assume logos are wider than they are tall.
    ASSERT(cxLogo >= cyLogo);

    // Put the icon on the left
    x = 2;

    // Center the icon vertically
    if (cyIcon <= cyLogo)
    {
        y = (cyLogo - cyIcon) / 2;
        dy = cyIcon;
        dx = cxIcon;
    }
    else
    {
        y = 0;
        dy = cyLogo;

        // keep shrinkage proportional
        dx = MulDiv(cxIcon, cyIcon, cyLogo);
    }

    // get ready to draw
    HDC hTBDC = GetDC(GetHWND());
    if (!hTBDC)
    {
        return E_FAIL;
    }
    HDC hdc = CreateCompatibleDC(hTBDC);
    if (hdc)
    {
        RECT    rc;
        int     dx, dy, x, y;
        SIZE    size;
        hbmp = CreateCompatibleBitmap(hTBDC, cxLogo, cyLogo);
        if (hbmp)
        {
            HGDIOBJ hTmp = SelectObject(hdc, hbmp);
            HPALETTE hpalOld;
            HFONT hfont, hfontOld;

            if (_hpalHalftone)
            {
                hpalOld = SelectPalette(hdc, _hpalHalftone, TRUE);
                // LINTASSERT(hpalOld || !hpalOld);     // 0 semi-ok for SelectPalette
                RealizePalette(hdc);
            }

            SetMapMode(hdc, MM_TEXT);
            rc.left = rc.top = 0;
            rc.bottom = cyLogo;
            rc.right = cxLogo;
            SHFillRectClr(hdc, &rc, COLORBK);
            // draw the icon into the memory DC.
            ImageList_GetIconSize(himl, &dx, &dy);
            x = DXFUDGE;
            y = ((cyLogo- dy) >> 1);
            ImageList_Draw(himl, iIcon, hdc, x, y, ILD_TRANSPARENT);
            hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            hfontOld = hfont ? (HFONT)SelectObject(hdc, hfont) : NULL;
            GetTextExtentPoint32(hdc, pszText, lstrlen(pszText), &size);
            x += (dx + DXFUDGE);
            y = ((cyLogo- size.cy) >> 1);
            rc.left = x;
            UINT eto = ETO_CLIPPED;
            SetTextColor(hdc, COLORTEXT);
            SetBkMode(hdc, TRANSPARENT);
            ExtTextOut(hdc, x, y, eto, &rc
                                        , pszText, lstrlen(pszText), NULL);
            if (hfontOld)
                SelectObject(hdc, hfontOld);

            if (hfont)
                DeleteObject(hfont);

            if (_hpalHalftone)
            {
                (void) SelectPalette(hdc, hpalOld, TRUE);
                RealizePalette(hdc);
            }

            // remove the final bitmap
            SelectObject(hdc, hTmp);
            hr = S_OK;

            if (FAILED(hr))
            {
                DeleteObject(hbmp);
                hbmp = NULL;
            }
        }

        DeleteDC(hdc);
    }
    ReleaseDC(GetHWND(), hTBDC);

    *phBmpLogo = hbmp;

    return hr;
}

HRESULT CLogoBase::FlushLogoCache()
{
    HRESULT hr = E_UNEXPECTED;

    if (_pLogoCache)
    {
        // forcibly clear out the logo cache so the items get refetched ...
        _pLogoCache->Flush(TRUE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CLogoBase::DitherBitmap(HBITMAP hBmp, HBITMAP * phBmpNew)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}

int CLogoBase::AddIndicesToLogoList(int iIcon, UINT uIndex)
{
    int iRet = -1;

    LogoIndex * pIndex;
    LogoIndex rgNew;

    rgNew.iIcon = iIcon;
    rgNew.iLogo = (int) uIndex;

    if (_fWide)
    {
        EnterCriticalSection(&s_csSharedLogos);
    }

    // scan to see if we have an extact match already in there...
    for (int n = 0; n < DSA_GetItemCount(_hdsaLogoIndices); n ++)
    {
        pIndex = (LogoIndex *) DSA_GetItemPtr(_hdsaLogoIndices, n);
        ASSERT(pIndex);
        if (pIndex->iLogo == (int) uIndex)
        {
            // set the icon just incase it changed...
            pIndex->iIcon = iIcon;
            iRet = n;
            break;
        }
    }

    if (iRet == -1)
    {
        iRet = DSA_AppendItem(_hdsaLogoIndices, &rgNew);
    }

    if (_fWide)
    {
        LeaveCriticalSection(&s_csSharedLogos);
    }

    return iRet;
}

int CLogoBase::FindLogoFromIcon(int iIcon, int * piLastLogo)
{
    int iRet = -1;

    if (!piLastLogo)
    {
        return -1;
    }

    LogoIndex * pIndex;

    if (_fWide)
    {
        EnterCriticalSection(&s_csSharedLogos);
    }

    for (int n = *piLastLogo + 1; n < DSA_GetItemCount(_hdsaLogoIndices); n ++)
    {
        pIndex = (LogoIndex *) DSA_GetItemPtr(_hdsaLogoIndices, n);
        ASSERT(pIndex);

        if (pIndex->iIcon == iIcon)
        {
            *piLastLogo = n;
            iRet = pIndex->iLogo;
            break;
        }
    }

    if (_fWide)
    {
        LeaveCriticalSection(&s_csSharedLogos);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\logo.h ===
#ifndef _LOGO_H
#define _LOGO_H

typedef HRESULT (* LPUPDATEFN)( void *pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );

#define LOGO_HEIGHT 32
#define LOGO_WIDE_WIDTH 194
#define LOGO_WIDTH  80

class CLogoBase
{
public:
    CLogoBase( BOOL fWide = FALSE );
    ~CLogoBase();

    virtual STDMETHODIMP_(ULONG) AddRef(void)  PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    static void _Initialize( void );
    static void _Cleanup( void );
    
    virtual IShellFolder * GetSF() PURE;
    virtual HWND GetHWND() PURE;

    inline HIMAGELIST GetLogoHIML( void );
    
    // intialisation functions
    HRESULT InitLogoView( void );
    HRESULT ExitLogoView( void );

    int GetLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    int GetDefaultLogo( LPCITEMIDLIST pidl, BOOL fQuick );

    HRESULT AddTaskToQueue( IRunnableTask *pTask, DWORD dwPriority, DWORD lParam );
    
    // create the default logo for an item....
    HRESULT CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo);

    HRESULT FlushLogoCache( void );

    HRESULT AddRefLogoCache( void );
    HRESULT ReleaseLogoCache( void );

    // get the task ID used with the task scheduler
    virtual REFTASKOWNERID GetTOID( void ) PURE;

    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache ) PURE;

    HRESULT DitherBitmap( HBITMAP hBmp, HBITMAP * phBmpNew );

    int AddIndicesToLogoList( int iIcon, UINT uIndex );

    int FindLogoFromIcon( int iIcon, int * piLastLogo );
    
protected:
    
    int GetCachedLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    
    IImageCache * _pLogoCache;              // My be NULL in low memory conditions.
    IShellTaskScheduler * _pTaskScheduler;
    HIMAGELIST _himlLogos;
    SIZEL _rgLogoSize;
    DWORD _dwClrDepth;
    HDSA  _hdsaLogoIndices;

    static CRITICAL_SECTION s_csSharedLogos;
    static long             s_lSharedWideLogosRef;
    static IImageCache *    s_pSharedWideLogoCache;
    static HDSA             s_hdsaWideLogoIndices;

    HPALETTE _hpalHalftone;
    BOOL     _fWide;
};

inline HIMAGELIST CLogoBase::GetLogoHIML( )
{
    return _himlLogos;
}

struct LogoIndex
{
    int iIcon;
    int iLogo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menuband.cpp ===
#include "shellprv.h"
#define WANT_SHLWAPI_POSTSPLIT
#include <shlwapi.h>

#include "common.h"
#include "initguid.h"
#include "menuband.h"
#include "bands.h"
#include "isfband.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "oleacc.h"
#include "apithk.h"
#include "uemapp.h"
#include "mnbase.h"
#include "mnfolder.h"
#include "mnstatic.h"
#include "iaccess.h"
#include "util.h"
#include "tbmenu.h"

// NOTE: Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

#define DM_MISC     0               // miscellany

#define PF_USINGNTSD    0x00000400      // set this if you're debugging on ntsd

// This must be reset to -1 on any WM_WININICHANGE.  We do it in
// shbrows2.cpp, but if there are no browser windows open when the
// metric changes, we end up running around with a stale value.  Oh well.
long g_lMenuPopupTimeout = -1;

// {AD35F50A-0CC0-11d3-AE2D-00C04F8EEA99}
static const CLSID CLSID_MenuBandMetrics =
{ 0xad35f50a, 0xcc0, 0x11d3, { 0xae, 0x2d, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99
} };

// Registered window messages for the menuband
UINT    g_nMBPopupOpen = 0;
UINT    g_nMBFullCancel = 0;
UINT    g_nMBDragCancel = 0;
UINT    g_nMBAutomation = 0;
UINT    g_nMBExecute = 0;
UINT    g_nMBOpenChevronMenu = 0;
HCURSOR g_hCursorArrow = NULL;
//UINT    g_nMBIgnoreNextDeselect = 0;  // Dealt with in menuisf.cpp

BOOL IsAncestor(HWND hwndChild, HWND hwndAncestor)
{
    HWND hwnd = hwndChild;
    while (hwnd != hwndAncestor && hwnd != NULL)
    {
        hwnd = GetParent(hwnd);
    } 

    return hwndAncestor == hwnd;
}

//=================================================================
// Implementation of menuband message filter
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);


// Just one of these, b/c we only need one message filter
CMBMsgFilter g_msgfilter = { 0 };     

static DWORD g_tlsMessageFilter = -1;

CMBMsgFilter* GetMessageFilter()
{
    CMBMsgFilter* pmf = NULL;

    if (g_tlsMessageFilter == -1)
    {
        DWORD tls = TlsAlloc();
        if (tls != -1)
        {
            InterlockedExchange((LONG*)&g_tlsMessageFilter, tls);
            if (tls != g_tlsMessageFilter)
            {
                TlsFree(tls);
            }
        }
    }

    if (g_tlsMessageFilter != -1)
    {
        pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == NULL)
        {
            pmf = new CMBMsgFilter;
            if (pmf)
            {
                pmf->_fAllocated = TRUE;
                TlsSetValue(g_tlsMessageFilter, pmf);
            }
        }
    }

    if (pmf == NULL)
        pmf = &g_msgfilter;

    return pmf;
}

void FreeMessageFilter(CMBMsgFilter* that)
{
    if (g_tlsMessageFilter != -1)
    {
        CMBMsgFilter* pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == that)
        {
            TlsSetValue(g_tlsMessageFilter, NULL);
        }
    }
}

void CMBMsgFilter::AddRef()
{
    _cRef++;

}

void CMBMsgFilter::Release()
{
    _cRef--;
    if (_cRef <= 0 && _fAllocated)
    {
        FreeMessageFilter(this);
        delete this;
    }
}

void CMBMsgFilter::SetModal(BOOL fModal)
{
    // There was an interesting problem:
    //   Click on the Chevron menu. Right click Delete. 
    //   The menus were hosed
    // Why?
    //   Well, I'll tell you:
    //   We got a deactivate on the subclassed window. We have
    //   2 menus subclassing it: The Main menu, and the modal
    //   chevron menu. Problem is, the main menu snagged the WM_ACTIVATE
    //   and does a set context. This causes a Pop and releases the Message hook.
    //   Since I still had a menu up, this caused havoc.
    //   So I introduced a concept of a "Modal" menuband. 
    //   This says: "Ignore any request to change contexts until I'm done". When
    //   that modal band is done, it sets the old context back in.
    //   Seems like a hack, but we need a better underlying archtecture for
    //   the message passing.
    _fModal = fModal;
}

void CMBMsgFilter::ReEngage(void* pvContext)      
{ 
    // We need to make sure that we don't dis/reengage when 
    // switching contexts
    if (pvContext == _pvContext)
        _fEngaged = TRUE; 
}

void CMBMsgFilter::DisEngage(void* pvContext)     
{ 
    if (pvContext == _pvContext)
        _fEngaged = FALSE;
}

int CMBMsgFilter::GetCount()
{
    return FDSA_GetItemCount(&_fdsa);
}

int MsgFilter_GetCount()
{
    return GetMessageFilter()->GetCount();
}

CMenuBand * CMBMsgFilter::_GetTopPtr(void)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, cItems-1, MBELEM); 
        pmb = pmbelem->pmb;
    }
    return pmb;
}

CMenuBand * CMBMsgFilter::_GetBottomMostSelected(void)
{
    // Ick, I can't believe I just did this. Mix COM and C++ identities... Yuck.
    CMenuBand* pmb = NULL;
    if (_pmb)
    {
        IUnknown_QueryService(SAFECAST(_pmb, IMenuBand*), SID_SMenuBandBottomSelected, CLSID_MenuBand, (void**)&pmb);

        // Since we have the C++ identity, release the COM identity.
        if (pmb)
            pmb->Release();
    }

    return pmb;
}


CMenuBand * CMBMsgFilter::_GetWindowOwnerPtr(HWND hwnd)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.
        int i;

        for (i = 0; i < cItems; i++)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 
            if (pmbelem->pmb && S_OK == pmbelem->pmb->IsWindowOwner(hwnd))
            {
                pmb = pmbelem->pmb;
                break;
            }
        }
    }
    return pmb;
}


/*----------------------------------------------------------
Purpose: Return menuband or NULL based upon hittest.  pt must be 
         in screen coords
*/
CMenuBand * CMBMsgFilter::_HitTest(POINT pt, HWND * phwnd)
{ 
    CMenuBand * pmb = NULL;
    HWND hwnd = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.  Work backwards since the
        // later bands are on top (z-order), if the menus ever overlap.
        int i = cItems - 1;

        while (0 <= i)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 

            RECT rc;

            // Do this dynamically because the hwndBar hasn't been positioned
            // until after this mbelem has been pushed onto the msg filter stack.
            GetWindowRect(pmbelem->hwndBar, &rc);
            
            if (PtInRect(&rc, pt))
            {
                pmb = pmbelem->pmb;
                hwnd = pmbelem->hwndTB;
                break;
            }
            i--;
        }
    }

    if (phwnd)
        *phwnd = hwnd;

    return pmb;
}


void CMBMsgFilter::RetakeCapture(void)
{
    // The TrackPopupMenu submenus can steal the capture.  Take
    // it back.  Don't take it back if the we're in edit mode,
    // because the modal drag/drop loop has the capture at that
    // point.
    // We do not want to take capture unless we are engaged. 
    // We need to do this because we are not handling mouse messages lower down
    // in the code. When we set the capture, the messages that we do not handle
    // trickle up to the top level menu, and can cause weird problems (Such
    // as signaling a "click out of bounds" or a context menu of the ITBar)
    if (_hwndCapture && !_fPreventCapture && _fEngaged)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Setting capture to %#lx", _hwndCapture);
        SetCapture(_hwndCapture);
    }
}    

void CMBMsgFilter::SetHook(BOOL fSet, BOOL fDontIgnoreSysChar)
{
    if (fDontIgnoreSysChar)
        _iSysCharStack += fSet? 1: -1;

    if (NULL == _hhookMsg && fSet)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Initialize");
        _hhookMsg = SetWindowsHookEx(WH_GETMESSAGE, GetMsgHook, HINST_THISDLL, GetCurrentThreadId());
        _fDontIgnoreSysChar = fDontIgnoreSysChar;
    }
    else if (!fSet && _iSysCharStack == 0)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Hook removed");
        if (_hhookMsg)
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
        }
    }
}

// 1) Set Deskbars on Both Monitors and set to chevron
// 2) On Monitor #2 open a chevron
// 3) On Monitor #1 open a chevron then open the Start Menu
// Result: Start Menu does not work.

// The reason is, we set the _fModal of the global message filter. This prevents context switches. Why? 
// The modal flag was invented to solve context switching problems with the browser frame. So what causes this?
// Well, when switching from #2 to #3, we have not switched contexts. But since we got a click out of bounds, we collapse
// the previous menu. When switching from #3 to #4, neither have the context, so things get messy.

void CMBMsgFilter::ForceModalCollapse()
{
    if (_fModal)
    {
        _fModal = FALSE;
        SetContext(NULL, TRUE);
    }
}

void CMBMsgFilter::SetContext(void* pvContext, BOOL fSet)
{
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::SetContext from 0x%x to 0x%x", _pvContext, pvContext);
    // When changing a menuband context, we need to pop all of the items
    // in the stack. This is to prevent a race condition that can occur.

    // We do not want to pop all of the items off the stack if we're setting the same context.
    // We do a set context on Activation, Both when we switch from one Browser frame to another
    // but also when right clicking or causing the Rename dialog to be displayed.

    BOOL fPop = FALSE;

    if (_fModal)
        return;

    // Are we setting a new context?
    if (fSet)
    {
        // Is this different than the one we've got?
        if (pvContext != _pvContext)
        {
            // Yes, then we need to pop off all of the old items.
            fPop = TRUE;
        }

        _pvContext = pvContext;
    }
    else
    {
        // Then we are trying to unset the message hook. Make sure it still belongs to
        // this context
        if (pvContext == _pvContext)
        {
            // This context is trying to unset itself, and no other context owns it.
            // remove all the old items.
            fPop = TRUE;
        }
    }

    if (fPop)
    {
        CMenuBand* pcmb = _GetTopPtr();
        if (pcmb)
        {
            PostMessage(pcmb->_pmbState->GetSubclassedHWND(), g_nMBFullCancel, 0, 0);
            // No release.

            if (FDSA_GetItemCount(&_fdsa) != 0)
            {
                CMBMsgFilter* pmf = GetMessageFilter();
                while (pmf->Pop(pvContext))
                    ;
            }
        }
    }
}




/*----------------------------------------------------------
Purpose: Push another menuband onto the message filter's stack

*/
void CMBMsgFilter::Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite)
{
    ASSERT(IS_VALID_CODE_PTR(pmb, CMenuBand));
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::Push called from context 0x%x", pvContext);

    if (pmb && pvContext == _pvContext)
    {
        BOOL bRet = TRUE;
        HWND hwndBand;

        pmb->GetWindow(&hwndBand);

        // If the bar isn't available use the band window
        HWND hwndBar = hwndBand;
        IOleWindow * pow;

        IUnknown_QueryService(punkSite, SID_SMenuPopup, IID_PPV_ARG(IOleWindow, &pow));
        if (pow)
        {
            pow->GetWindow(&hwndBar);
            pow->Release();
        }

        if (NULL == _hhookMsg)
        {
            // We want to ignore the WM_SYSCHAR message in the message filter because
            // we are using the IsMenuMessage call instead of the global message hook.
            SetHook(TRUE, FALSE);
            TraceMsg(TF_MENUBAND, "CMBMsgFilter::push Setting hook from context 0x%x", pvContext);
            _fSetAtPush = TRUE;
        }

        if (!_fInitialized)
        {
            ASSERT(NULL == _hwndCapture);
            _hwndCapture = hwndBar;

            _fInitialized = TRUE;

            bRet = FDSA_Initialize(sizeof(MBELEM), CMBELEM_GROW, &_fdsa, _rgmbelem, CMBELEM_INIT);

            // We need to initialize this for the top level guy so that we have the correct positioning
            // from the start of this new set of bands. This is used to eliminate spurious WM_MOUSEMOVE
            // messages which cause problems. See _HandleMouseMessages for more information
            AcquireMouseLocation();
        }

        if (EVAL(bRet))
        {
            MBELEM mbelem = {0};
            
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Push (pmp:%#08lx) onto stack", SAFECAST(pmb, IMenuPopup *));
            pmb->AddRef();

            mbelem.pmb = pmb;
            mbelem.hwndTB = hwndBand;
            mbelem.hwndBar = hwndBar;

            FDSA_AppendItem(&_fdsa, &mbelem);

            CMenuBand* pmbTop = _GetTopPtr();

            if ((pmbTop && (pmbTop->GetFlags() & SMINIT_LEGACYMENU)) || NULL == GetCapture())
                RetakeCapture();
        }
        else
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
            _hwndCapture = NULL;
        }
    }
}    


/*----------------------------------------------------------
Purpose: Pop a menuband off the message filter stack

         Returns the number of bands left on the stack
*/
int CMBMsgFilter::Pop(void* pvContext)
{
    int nRet = 0;

    TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop called from context 0x%x", pvContext);

    // This can be called from a context switch or when we're exiting menu mode,
    // so we'll switch off the fact that we clear _hhookMsg when we pop the top twice.
    if (pvContext == _pvContext && _hhookMsg)
    {
        int iItem = FDSA_GetItemCount(&_fdsa) - 1;
        MBELEM * pmbelem;

        ASSERT(0 <= iItem);

        pmbelem = FDSA_GetItemPtr(&_fdsa, iItem, MBELEM);
        if (EVAL(pmbelem->pmb))
        {
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Pop (pmb=%#08lx) off stack", SAFECAST(pmbelem->pmb, IMenuPopup *));
            pmbelem->pmb->Release();
            pmbelem->pmb = NULL;
        }
        FDSA_DeleteItem(&_fdsa, iItem);

        if (0 == iItem)
        {

            TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop removing hook from context 0x%x", pvContext);
            if (_fSetAtPush)
                SetHook(FALSE, FALSE);

            PreventCapture(FALSE);
            _fInitialized = FALSE;

            if (_hwndCapture && GetCapture() == _hwndCapture)
            {
                TraceMsg(TF_MENUBAND, "CMBMsgFilter: Releasing capture");
                ReleaseCapture();
            }
            _hwndCapture = NULL;
        }
        nRet = iItem;
  
        
    }
    return nRet;
}    


LRESULT CMBMsgFilter::_HandleMouseMsgs(MSG * pmsg, BOOL bRemove)
{
    LRESULT lRet = 0;
    CMenuBand * pmb;
    HWND hwnd = GetCapture();

    // Do we still have the capture?
    if (hwnd != _hwndCapture)
    {
        // No; is it b/c a CTrackPopupBar has it?

#if 0 // Nuke this trace because I was getting annoyed.
        //def DEBUG
        pmb = _GetTopPtr();
        if (!EVAL(pmb) || !pmb->IsInSubMenu())
        {
            // No
            TraceMsg(TF_WARNING, "CMBMsgFilter: someone else has the capture (%#lx)", hwnd);
        }
#endif
        if (NULL == hwnd)
        {
            // There are times that we must retake the capture because
            // TrackPopupMenuEx has taken it, or some context menu
            // might have taken it, so take it back.
            RetakeCapture();
            TraceMsg(TF_WARNING, "CMBMsgFilter: taking the capture back");
        }
    }
    else
    {
        // Yes; decide what to do with it
        POINT pt;
        HWND hwndPt;
        MSG msgT;

        pt.x = GET_X_LPARAM(pmsg->lParam);
        pt.y = GET_Y_LPARAM(pmsg->lParam);
        ClientToScreen(pmsg->hwnd, &pt);

        if (WM_MOUSEMOVE == pmsg->message)
        {
            // The mouse cursor can send repeated WM_MOUSEMOVE messages
            // with the same coordinates.  When the user tries to navigate
            // thru the menus with the keyboard, and the mouse cursor
            // happens to be over a menu item, these spurious mouse 
            // messages cause us to think the menu has been invoked under
            // the mouse cursor.  
            //
            // To avoid this unpleasant rudeness, we eat any gratuitous
            // WM_MOUSEMOVE messages.
            if (_ptLastMove.x == pt.x && _ptLastMove.y == pt.y)
            {
                pmsg->message = WM_NULL;
                goto Bail;
            }

            // Since this is not a duplicate point, we need to keep it around. 
            // We will use this stored point for the above comparison

            // msadek; W2k bug# 426005
            // On a mirrored system, we got a system bug as mouse coordinates has an off-by-one
            // This makes comparing the value with what we got from GetCursorPos() always fail.
            // Do not use AcquireMouseLocation().

            if(!IS_WINDOW_RTL_MIRRORED(pmsg->hwnd))
            {
                AcquireMouseLocation();
            }
            else
            {
                _ptLastMove.x = pt.x;
                _ptLastMove.y = pt.y;                
            }
            

            if (_hcurArrow == NULL)
                _hcurArrow = LoadCursor(NULL, IDC_ARROW);

            if (GetCursor() != _hcurArrow)
                SetCursor(_hcurArrow);

        }

        // Use a stack variable b/c we don't want to confuse USER32
        // by changing the coords of the real message.
        msgT = *pmsg;
        msgT.lParam = MAKELPARAM(pt.x, pt.y);

        pmb = _HitTest(pt, &hwndPt);

        if (_TopFilterMouseMessage(&msgT, bRemove, pmb) == S_OK)
        {
            // Remember the changed message (if there was one)
            pmsg->message = msgT.message;   
        }
        else if (pmb)
        {
            // Forward mouse message onto appropriate menuband.  Note
            // the appropriate menuband's GetMsgFilterCB (below) will call
            // ScreenToClient to convert the coords correctly.

            lRet = pmb->GetMsgFilterCB(&msgT, bRemove);

            // Remember the changed message (if there was one)
            pmsg->message = msgT.message;   
        }
        // Debug note: to debug menubands on ntsd, set the prototype
        // flag accordingly.  This will keep menubands from going
        // away the moment the focus changes to the NTSD window.

        else if ((WM_LBUTTONDOWN == pmsg->message || WM_RBUTTONDOWN == pmsg->message) &&
            !(g_dwPrototype & PF_USINGNTSD))
        {
            // Mouse down happened outside the menu.  Bail.
            pmb = _GetTopPtr();
            if (EVAL(pmb))
            {
                msgT.hwnd = pmsg->hwnd;
                msgT.message = g_nMBFullCancel;
                msgT.wParam = 0;
                msgT.lParam = 0;

                TraceMsg(TF_MENUBAND, "CMBMsgFilter (pmb=%#08lx): hittest outside, bailing", SAFECAST(pmb, IMenuPopup *));
                pmb->GetMsgFilterCB(&msgT, bRemove);
            }
#if 0
            // Now send the message to the originally intended window
            SendMessage(pmsg->hwnd, pmsg->message, pmsg->wParam, pmsg->lParam);
#endif
        }
        else
        {
            pmb = _GetTopPtr();
            if (pmb)
            {
                IUnknown_QueryServiceExec(SAFECAST(pmb, IOleCommandTarget*), SID_SMenuBandBottom, 
                    &CGID_MenuBand, MBANDCID_SELECTITEM, MBSI_NONE, NULL, NULL);
            }
        }
    }

Bail:
    return lRet;    
}    

HRESULT CMBMsgFilter::_TopFilterMouseMessage(MSG *pmsg, BOOL bRemove, CMenuBand *pmbTarget)
{
    CMenuBand *pmb = _GetTopPtr();
    if (pmb && pmb->_psmcb)
    {
        // This is a high-frequency message so we handle the callback
        // ourselves.  (_CallCB will allocate memory.)
        SMDATA smd = {0};
        if (pmbTarget)
        {
            smd.punk = SAFECAST(pmbTarget, IShellMenu*);
            smd.uIdParent = pmbTarget->_uId;
            smd.uIdAncestor = pmbTarget->_uIdAncestor;
            smd.hwnd = pmbTarget->_hwnd;
            smd.hmenu = pmbTarget->_hmenu;
            smd.pvUserData = pmbTarget->_pvUserData;
        }
        return pmb->_psmcb->CallbackSM(&smd, SMC_MOUSEFILTER, bRemove, (LPARAM)pmsg);
    }
    return S_FALSE; // not handled
}

/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while the menuband is "active".  
         
         The menuband can't steal the focus away -- we use this
         hook to catch messages.

*/
LRESULT CMBMsgFilter::GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;
    BOOL bRemove = (PM_REMOVE == wParam);
    CMBMsgFilter* pmf = GetMessageFilter();


    // The global message filter may be in a state when we are not processing messages,
    // but the menubands are still displayed. A situation where this will occur is when
    // a dialog box is displayed because of an interaction with the menus.

    // Are we engaged? (Are we allowed to process messages?)
    if (pmf->_fEngaged)
    {
        if (WM_SYSCHAR == pmsg->message)
        {
            // _fDontIgnoreSysChar is set when the Menubands ONLY want to know about
            // WM_SYSCHAR and nothing else.
            if (pmf->_fDontIgnoreSysChar)
            {
                CMenuBand * pmb = pmf->GetTopMostPtr();
                if (pmb)
                    lRet =  pmb->GetMsgFilterCB(pmsg, bRemove);
            }
        }
        else if (pmf->_fInitialized) // Only filter if we are initalized (have items on the stack)
        {
            switch (nCode)
            {
            case HC_ACTION:
#ifdef DEBUG
                if (g_dwDumpFlags & DF_GETMSGHOOK)
                    DumpMsg(TEXT("GetMsg"), pmsg);
#endif

                // A lesson about GetMsgHook: it gets the same message
                // multiple times for as long as someone calls PeekMessage
                // with the PM_NOREMOVE flag.  So we want to take action 
                // only when PM_REMOVE is set (so we don't handle more than
                // once).  If we modify any messages to redirect them (on a
                // regular basis), we must modify all the time so we don't 
                // confuse the app.

                // Messages get redirected to different bands in the stack
                // in this way:
                //
                //  1) Keyboard messages go to the currently open submenu 
                //     (topmost on the stack).  
                //
                //  2) The PopupOpen message goes to the hwnd that belongs 
                //     to the menu band (via IsWindowOwner).
                //

                switch (pmsg->message)
                {
                case WM_SYSKEYDOWN:
                case WM_KEYDOWN:
                case WM_CHAR:
                case WM_KEYUP:
                case WM_CLOSE:          // only this message filter gets WM_CLOSE
                    {
                        // There is a situation that can occur when the last selected
                        // menu pane is NOT the bottom most pane.
                        // We need to see if that last selected guy is tracking a context
                        // menu so that we forward the messages correctly.
                        CMenuBand * pmb = pmf->_GetBottomMostSelected();
                        if (pmb)
                        {
                            // Is it tracking a context menu?
                            if (S_OK == IUnknown_Exec(SAFECAST(pmb, IMenuBand*), &CGID_MenuBand, 
                                MBANDCID_ISTRACKING, 0, NULL, NULL))
                            {
                                // Yes, forward for proper handling.
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                            }
                            else
                            {
                                // No; Then do the default processing. This can happen if there is no
                                // context menu, but there is a selected parent and not a selected child.
                                goto TopHandler;
                            }
                        }
                        else
                        {
                    TopHandler:
                            pmb = pmf->_GetTopPtr();
                            if (pmb)
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                        }
                    }
                    break;

                case WM_NULL:
                    // Handle this here (we do nothing) to avoid mistaking this for
                    // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
                    // RegisterWindowMessage fails.
                    break;

                default:
                    if (bRemove && IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
                    {
                        lRet = pmf->_HandleMouseMsgs(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBPopupOpen)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                            lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBExecute)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                        {
                            VARIANT var;
                            var.vt = VT_UINT_PTR;
                            var.ullVal = (UINT_PTR)pmsg->hwnd;
                            pmb->Exec(&CGID_MenuBand, MBANDCID_EXECUTE, (DWORD)pmsg->wParam, &var, NULL);
                        }
                    }

                    break;
                }
                break;

            default:
                if (0 > nCode)
                    return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);
                break;
            }
        }
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);

    return 0;       // Always return 0
}    

//=================================================================
// Implementation of CMenuBand
//=================================================================

// Struct used by EXEC with a MBANDCID_GETFONTS to return fonts
typedef struct tagMBANDFONTS
{
    HFONT hFontMenu;    // [out]    TopLevelMenuBand's menu font
    HFONT hFontArrow;   // [out]    TopLevelMenuBand's font for drawing the cascade arrow
    int   cyArrow;      // [out]    Height of TopLevelMenuBand's cascade arrow
    int   cxArrow;      // [out]    Width of TopLevelMenuBand's cascade arrow
    int   cxMargin;     // [out]    Margin b/t text and arrow
} MBANDFONTS;

#define THISCLASS CMenuBand
#define SUPERCLASS CToolBand

#ifdef DEBUG
int g_nMenuLevel = 0;

#define DBG_THIS    _nMenuLevel, SAFECAST(this, IMenuPopup *)
#else
#define DBG_THIS    0, 0
#endif


CMenuBand::CMenuBand() :
    SUPERCLASS()
{
    GetMessageFilter()->AddRef();
    _fCanFocus = TRUE;

    _fAppActive = TRUE;

    _nItemNew = -1;
    _nItemCur = -1;
    _nItemTimer = -1;
    _uIconSize = ISFBVIEWMODE_SMALLICONS;
    _uIdAncestor = ANCESTORDEFAULT;
    _nItemSubMenu = -1;
}


// The purpose of this method is to finish initializing Menubands, 
// since it can be initialized in many ways. 

HRESULT CMenuBand::_Initialize(DWORD dwFlags)
{
    _fVertical = !BOOLIFY(dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(dwFlags & SMINIT_TOPLEVEL);

    _dwFlags = dwFlags;

    // We cannot have a horizontal menu if it is not the toplevel menu
    ASSERT(!_fVertical && _fTopLevel || _fVertical);

    HRESULT hr = S_OK;

    if (_fTopLevel)
    {
        if (!g_nMBPopupOpen) 
        {
            g_nMBPopupOpen  = RegisterWindowMessage(TEXT("CMBPopupOpen"));
            g_nMBFullCancel = RegisterWindowMessage(TEXT("CMBFullCancel"));
            g_nMBDragCancel = RegisterWindowMessage(TEXT("CMBDragCancel"));
            g_nMBAutomation = RegisterWindowMessage(TEXT("CMBAutomation"));
            g_nMBExecute    = RegisterWindowMessage(TEXT("CMBExecute"));
            g_nMBOpenChevronMenu = RegisterWindowMessage(TEXT("CMBOpenChevronMenu"));

            g_hCursorArrow = LoadCursor(NULL, IDC_ARROW);
            TraceMsg(TF_MENUBAND, "CMBPopupOpen message = %#lx", g_nMBPopupOpen);
            TraceMsg(TF_MENUBAND, "CMBFullCancel message = %#lx", g_nMBFullCancel);
        }

        if (!_pmbState)
            _pmbState = new CMenuBandState;

        if (!_pmbm)
            _pmbm = new CMenuBandMetrics();

        if (!_pmbState || !_pmbm)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    DEBUG_CODE( _nMenuLevel = -1; )

    return hr;
}


CMenuBand::~CMenuBand()
{
    CMBMsgFilter* pmf = GetMessageFilter();
    // the message filter does not have a ref'd pointer to us!!!
    if (pmf->GetTopMostPtr() == this)
        pmf->SetTopMost(NULL);

    _CallCB(SMC_DESTROY);
    ATOMICRELEASE(_psmcb);

    // Cleanup
    CloseDW(0);

    if (_pmtbMenu)
        delete _pmtbMenu;

    if (_pmtbShellFolder)
        delete _pmtbShellFolder;

    Str_SetPtr(&_pszTheme, NULL);
   
    ASSERT(_punkSite == NULL);
    ATOMICRELEASE(_pmpTrackPopup);

    ATOMICRELEASE(_pmbm);

    if (_fTopLevel)
    {
        if (_pmbState)
            delete _pmbState;
    }

    GetMessageFilter()->Release();
}


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
HRESULT CMenuBand_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory

    HRESULT hr = E_OUTOFMEMORY;
    CMenuBand *pObj = new CMenuBand();
    if (pObj) 
    {
        hr = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }

    return hr;
}

CMenuBand * CMenuBand_Create(IShellFolder* psf, LPCITEMIDLIST pidl,
                             BOOL bHorizontal)
{
    CMenuBand * pmb = NULL;

    if (psf || pidl)
    {
        DWORD dwFlags = bHorizontal ? (SMINIT_HORIZONTAL | SMINIT_TOPLEVEL) : 0;

        pmb = new CMenuBand();
        if (pmb)
        {
            pmb->_Initialize(dwFlags);
            pmb->SetShellFolder(psf, pidl, NULL, 0);
        }
    }
    return pmb;
}


void CMenuBand::_UpdateButtons()
{
    if (_pmtbMenu) 
        _pmtbMenu->v_UpdateButtons(FALSE);
    if (_pmtbShellFolder)
        _pmtbShellFolder->v_UpdateButtons(FALSE);

    _fForceButtonUpdate = FALSE;
}

HRESULT CMenuBand::ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Given a change notify from the ShellFolder child, we will forward that notify to each of our
    // sub menus, but only if they have a shell folder child.

    HRESULT hres = E_FAIL;
    BOOL fDone = FALSE;
    CMenuToolbarBase* pmtb = _pmtbBottom;   // Start With the bottom toolbar. This is
                                            // is an optimization because typically
                                            // menus that have both a Shell Folder portion
                                            // and a static portion have the majority
                                            // of the change activity in the bottom portion.

    // This can be NULL on a shutdown, when we're deregistering change notifies
    if (pmtb && pmtb->_hwndMB)
    {
        HWND hwnd = pmtb->_hwndMB;


        for (int iButton = 0; !fDone; iButton++)
        {
            IShellChangeNotify* ptscn;

            int idCmd = GetButtonCmd(hwnd, iButton);

#ifdef DEBUG
                TCHAR szSubmenuName[MAX_PATH];
                SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, (LPARAM)szSubmenuName);
                TraceMsg(TF_MENUBAND, "CMenuBand: Forwarding Change notify to %s", szSubmenuName);
#endif

            // If it's not a seperator, see if there is a sub menu with a shell folder child.
            if (idCmd != -1 &&
                SUCCEEDED(pmtb->v_GetSubMenu(idCmd, &SID_MenuShellFolder, IID_PPV_ARG(IShellChangeNotify, &ptscn))))
            {
                IShellMenu* psm;
                // Don't forward this notify if the sub menu has specifically registered for change notify (By not passing
                // DontRegisterChangeNotify.
                if (SUCCEEDED(ptscn->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
                {
                    UINT uIdParent = 0;
                    DWORD dwFlags = 0;
                    // Get the flags
                    psm->GetShellFolder(&dwFlags, NULL, IID_NULL, NULL);
                    psm->GetMenuInfo(NULL, &uIdParent, NULL, NULL);

                    // If this menupane is an "Optimized" pane, (meaning that we don't register for change notify
                    // and forward from a top level menu down) then we want to forward. We also
                    // forward if this is a child of Menu Folder. If it is a child,
                    // then it also does not register for change notify, but does not explicitly set it in it's flags
                    // (review: Should we set it in it's flags?)
                    // If it is not an optimized pane, then don't forward.
                    if ((dwFlags & SMSET_DONTREGISTERCHANGENOTIFY) ||
                        uIdParent == MNFOLDER_IS_PARENT)
                    {
                        // There is!, then pass to the child the change.
                        hres = ptscn->OnChange(lEvent, pidl1, pidl2);

                        // Update Dir on a Recursive change notify forces us to update everyone... Good thing
                        // this does not happen alot and is caused by user interaction most of the time.
                    }
                    psm->Release();
                }

                ptscn->Release();
            }

            // Did we go through all of the buttons on this toolbar?
            if (iButton >= ToolBar_ButtonCount(hwnd) - 1)
            {
                // Yes, then we need to switch to the next toolbar.
                if (_pmtbTop != _pmtbBottom && pmtb != _pmtbTop)
                {
                    pmtb = _pmtbTop;
                    hwnd = pmtb->_hwndMB;
                    iButton = -1;       // -1 because at the end of the loop the for loop will increment.
                }
                else
                {
                    // No; Then we must be done.
                    fDone = TRUE;
                }
            }
        }
    }
    else
        hres = S_OK;        // Return success because we're shutting down.

    return hres;
}

// Resize the parent menubar
VOID CMenuBand::ResizeMenuBar()
{
    // If we're not shown, then we do not need to do any kind of resize.
    // NOTE: Horizontal menubands are always shown. Don't do any of the 
    // vertical stuff if we're horizontal.
    if (!_fShow)
        return;

    // If we're horizontal, don't do any Vertical sizing stuff.
    if (!_fVertical)
    {
        // BandInfoChanged is only for Horizontal Menubands.
        _BandInfoChanged();
        return;
    }

    // We need to update the buttons before a resize so that the band is the right size.
    _UpdateButtons();

    // Have the menubar think about changing its height
    IUnknown_QueryServiceExec(_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
        MBCID_RESIZE, 0, NULL, NULL);
}


STDMETHODIMP CMenuBand::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        // Do not need IOleWindow (base class for IDeskBar)
        // because CToolBand::IDeskBand::IDockingWindow::IOleWindow
        // handles it.
        QITABENT(CMenuBand, IDeskBar),      // Base class for IMenuPopup
        QITABENT(CMenuBand, IMenuPopup),
        QITABENT(CMenuBand, IMenuBand),
        QITABENT(CMenuBand, IShellMenu),
        QITABENT(CMenuBand, IShellMenu2),
        QITABENT(CMenuBand, IWinEventHandler),
        QITABENT(CMenuBand, IShellMenuAcc),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    if (FAILED(hres) && IsEqualGUID(riid, CLSID_MenuBand)) 
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        hres = S_OK;
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuBand::QueryService(REFGUID guidService,
                                     REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;
    *ppvObj = NULL; // assume error

    if (IsEqualIID(guidService, SID_SMenuPopup) || 
        IsEqualIID(guidService, SID_SMenuBandChild) || 
        IsEqualIID(guidService, SID_SMenuBandParent) || 
        (_fTopLevel && IsEqualIID(guidService, SID_SMenuBandTop)))
    {
        if (IsEqualIID(riid, IID_IAccessible) || IsEqualIID(riid, IID_IDispatch))
        {
            hr = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(SAFECAST(this, IMenuBand*));

            if (pacc)
            {
                hr = pacc->InitAcc();
                if (SUCCEEDED(hr))
                {
                    hr = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }
        }
        else
            hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected))
    {
        // SID_SMenuBandBottom queries down
        BOOL fLookingForSelected = IsEqualIID(SID_SMenuBandBottomSelected, guidService);

        // Are we the leaf node?
        if (!_fInSubMenu)
        {
            if ( fLookingForSelected && 
                (_pmtbTracked == NULL ||
                 ToolBar_GetHotItem(_pmtbTracked->_hwndMB) == -1))
            {
                hr = E_FAIL;
            }
            else
            {
                hr = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
        else 
        {
            // No; QS down...

            IMenuPopup* pmp = _pmpSubMenu;
            if (_pmpTrackPopup)
                pmp = _pmpTrackPopup;
            
            ASSERT(pmp);
            hr = IUnknown_QueryService(pmp, guidService, riid, ppvObj);
            if (FAILED(hr) && fLookingForSelected && _pmtbTracked != NULL)
            {
                hr = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
    }
    else if (IsEqualIID(guidService, SID_MenuShellFolder))
    {
        // This is a method of some other menu in the scheme to get to specifically the MenuShellfolder,
        // This is for the COM Identity property.
        if (_pmtbShellFolder)
            hr = _pmtbShellFolder->QueryInterface(riid, ppvObj);
    }
    else
        hr = SUPERCLASS::QueryService(guidService, riid, ppvObj);

    return hr;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method

*/
STDMETHODIMP CMenuBand::IsWindowOwner(HWND hwnd)
{
    if (( _pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) ) ||
        (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK)))
        return S_OK;
    return S_FALSE;
}

#define MB_EICH_FLAGS (EICH_SSAVETASKBAR | EICH_SWINDOWMETRICS | EICH_SPOLICY | EICH_SSHELLMENU | EICH_KWINPOLICY)

/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the bandsite.
*/
STDMETHODIMP  CMenuBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hres = NOERROR;

    EnterModeless();

    // Could our metrics be changing?  (We keep track of this only for the 
    // toplevel menu)
    BOOL fProcessSettingChange = FALSE;

    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        fProcessSettingChange = !lParam || 
                                (SHIsExplorerIniChange(wParam, lParam) & MB_EICH_FLAGS) ||
                                wParam == SPI_SETDROPSHADOW ||
                                wParam == SPI_SETFLATMENU;
        break;

    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        fProcessSettingChange = TRUE;
        break;
    }

    if (_fTopLevel && 
        fProcessSettingChange && 
        _pmbState && !_pmbState->IsProcessingChangeNotify())
    {

        // There is a race condition that can occur during a refresh 
        // that's really nasty. It causes another one to get pumped in the
        // middle of processing this one, Yuck!
        _pmbState->PushChangeNotify();
        // There is a race condiction that can occur when the menuband is created,
        // but not yet initialized. This has been hit by the IEAK group....
        if (_pmtbTop)
        {
            // Yes; create a new metrics object and tell the submenus
            // about it.

            CMenuBandMetrics* pmbm = new CMenuBandMetrics();

            if (pmbm)
            {
                ATOMICRELEASE(_pmbm);
                _pmbm = pmbm;
                _pmbm->Init(_pmtbTop->_hwndMB);
                
                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);

                _CallCB(SMC_REFRESH, wParam, lParam);

                // We need to force a button update at some point so that the new sizes are calculated
                // Setting this flag will cause the buttons to be updatted before the next time it 
                // is shown. If, however, the menu is currently displayed, then the ResizeMenuBar will
                // recalculate immediatly.
                
                _fForceButtonUpdate = TRUE;
                RECT rcOld;
                RECT rcNew;

                // Resize the MenuBar
                GetClientRect(_hwndParent, &rcOld);
                ResizeMenuBar();
                GetClientRect(_hwndParent, &rcNew);

                // If the rect sizes haven't changed, then we need to re-layout the
                // band because the button widths may have changed.
                if (EqualRect(&rcOld, &rcNew) && _fVertical)
                    _pmtbTop->NegotiateSize();
            }
        }

        if (_pmtbMenu)
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder)
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        _pmbState->PopChangeNotify();
    }
    else
    {
        if (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    }

    ExitModeless();

    return hres;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow method

*/
STDMETHODIMP CMenuBand::GetWindow(HWND * phwnd)
{
    if (_pmtbMenu)
    {
        *phwnd = _pmtbMenu->_hwndMB;
        return NOERROR;
    }
    else if (_pmtbShellFolder)
    {
        *phwnd = _pmtbShellFolder->_hwndMB;
        return NOERROR;
    }
    else
    {
        *phwnd = NULL;
        return E_FAIL;
    }
}    


/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp method

*/
STDMETHODIMP CMenuBand::ContextSensitiveHelp(BOOL bEnterMode)
{
    return SUPERCLASS::ContextSensitiveHelp(bEnterMode);
}    


/*----------------------------------------------------------
Purpose: Handle WM_CHAR for accelerators

         This is handled for any vertical menu.  Since we have
         two toolbars (potentially), this function determines
         which toolbar gets the message depending on the 
         accelerator.

*/
HRESULT CMenuBand::_HandleAccelerators(MSG * pmsg)
{
    TCHAR ch = (TCHAR)pmsg->wParam;
    HWND hwndTop = _pmtbTop->_hwndMB;
    HWND hwndBottom = _pmtbBottom->_hwndMB;

    // Here's how this works: the menu can have one or two toolbars.
    // 
    // One toolbar: we simply forward the message onto the toolbar 
    // and let it handle any potential accelerators.
    //
    // Two toolbars: get the count of accelerators that match the
    // given char for each toolbar.  If only one toolbar has at
    // least one match, forward the message onto that toolbar.
    // Otherwise, forward the message onto the currently tracked
    // toolbar and let it negotiate which accelerator button to
    // choose (we might get a TBN_WRAPHOTITEM).
    //
    // If no match occurs, we beep.  Beep beep.
    //

    if (!_pmtbTracked)
        SetTracked(_pmtbTop);

    ASSERT(_pmtbTracked);

    if (_pmtbTop != _pmtbBottom)
    {
        int iNumBottomAccel;
        int iNumTopAccel;

        // Tell the dup handler not to handle this one....
        _fProcessingDup = TRUE;

        ToolBar_HasAccelerator(hwndTop, ch, &iNumTopAccel);
        ToolBar_HasAccelerator(hwndBottom, ch, &iNumBottomAccel);

        BOOL bBottom = (0 < iNumBottomAccel);
        BOOL bTop = (0 < iNumTopAccel);

        // Does one or the other (but not both) have an accelerator?
        if (bBottom ^ bTop)
        {
            // Yes; do the work here for that specific toolbar
            HWND hwnd = bBottom ? hwndBottom : hwndTop;
            int cAccel = bBottom ? iNumBottomAccel : iNumTopAccel;
            int idCmd;

            pmsg->message = WM_NULL;    // no need to forward the message

            // This should never really fail since we just checked
            EVAL( ToolBar_MapAccelerator(hwnd, ch, &idCmd) );

            DWORD dwFlags = HICF_ACCELERATOR | HICF_RESELECT;

            if (cAccel == 1)
                dwFlags |= HICF_TOGGLEDROPDOWN;

            int iPos = ToolBar_CommandToIndex(hwnd, idCmd);
            ToolBar_SetHotItem2(hwnd, iPos, dwFlags);
        }
        // No; were there no accelerators?
        else if ( !bTop )
        {
            // Yes
            if (_fVertical)
            {
                MessageBeep(MB_OK);
            }
            else
            {
                _CancelMode(MPOS_FULLCANCEL);
            }
        }
        // Else allow the message to go to the top toolbar

        _fProcessingDup = FALSE;
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: Callback for the get message filter.  We handle the
         keyboard messages here (rather than IInputObject::
         TranslateAcceleratorIO) so that we can redirect the
         message *and* have the message pump still call
         TranslateMessage to generate WM_CHAR and WM_SYSCHAR
         messages.

*/
LRESULT CMenuBand::GetMsgFilterCB(MSG * pmsg, BOOL bRemove)
{
    // (See the note in CMBMsgFilter::GetMsgHook about bRemove.)

    if (bRemove && !_fVertical && (pmsg->message == g_nMBPopupOpen) && _pmtbTracked)
    {
        // Menu is being popped open, send a WM_MENUSELECT equivalent.
        _pmtbTracked->v_SendMenuNotification((UINT)pmsg->wParam, FALSE);
    }

    if (_fTopLevel &&                           // Only do this for the top level
        _dwFlags & SMINIT_USEMESSAGEFILTER &&   // They want to use the message filter 
                                                // instead of IsMenuMessage
        bRemove &&                              // Only do this if we're removing it.
        WM_SYSCHAR == pmsg->message)            // We only care about WM_SYSCHAR
    {
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //
        if (_OnSysChar(pmsg, TRUE) == S_OK)
        {
            pmsg->message = WM_NULL;
        }
    }

    // If a user menu is up, then we do not want to intercept those messages. Intercepting
    // messages intended for the poped up user menu causes havoc with keyboard accessibility.
    // We also don't want to process messages if we're displaying a sub menu (It should be
    // handling them).

    BOOL fTracking = FALSE;
    if (_pmtbMenu)
        fTracking = _pmtbMenu->v_TrackingSubContextMenu();

    if (_pmtbShellFolder && !fTracking)
        fTracking = _pmtbShellFolder->v_TrackingSubContextMenu();


    if (!_fInSubMenu && !fTracking)    
    {
        // We don't process these messages when we're in a (modal) submenu

        switch (pmsg->message)
        {
        case WM_SYSKEYDOWN:
        case WM_KEYDOWN:
            if (bRemove && 
                (VK_ESCAPE == pmsg->wParam || VK_MENU == pmsg->wParam))
            {
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received Esc in msg filter", DBG_THIS);

                DWORD dwSelect = (VK_ESCAPE == pmsg->wParam) ? MPOS_CANCELLEVEL : MPOS_FULLCANCEL;

                _CancelMode(dwSelect);

                pmsg->message = WM_NULL;
                return 1;
            }
            // Fall thru

        case WM_CHAR:
            // Hitting the spacebar should invoke the system menu
            if (!_fVertical && 
                WM_CHAR == pmsg->message && TEXT(' ') == (TCHAR)pmsg->wParam)
            {
                // We need to leave this modal loop before bringing
                // up the system menu (otherwise the user would need to 
                // hit Alt twice to get out.)  Post the message.
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Leaving menu mode for system menu", DBG_THIS);

                UIActivateIO(FALSE, NULL);

                // Say the Alt-key is down to catch DefWindowProc's attention
                pmsg->lParam |= 0x20000000;   
                pmsg->message = WM_SYSCHAR;

                // Use the parent of the toolbar, because toolbar does not
                // forward WM_SYSCHAR onto DefWindowProc.
                pmsg->hwnd = GetParent(_pmtbTop->_hwndMB);
                return 1;
            }
            else if (_fVertical && WM_CHAR == pmsg->message &&
                pmsg->wParam != VK_RETURN)
            {
                // We do not want to pass VK_RETURN to _HandleAccelerators
                // because it will try to do a character match. When it fails
                // it will beep. Then we pass the VK_RETURN to the tracked toolbar
                // and it executes the command.

                // Handle accelerators here
                _HandleAccelerators(pmsg);
            }
            // Fall thru

        case WM_KEYUP:
            // Collection point for most key messages...

            if (NULL == _pmtbTracked)
            {
                // Normally we default to the top toolbar, unless that toolbar
                // cannot receive the selection (As is the case on the top level
                // start menu where the fast items are (Empty).                

                // Can the top toolbar be cycled into?
                if (_pmtbTop && !_pmtbTop->DontShowEmpty())
                {
                    // Yes;
                    SetTracked(_pmtbTop);      // default to the top toolbar
                }
                else
                {
                    // No; Set the tracked to the bottom, and hope that he can....
                    SetTracked(_pmtbBottom);
                }
            }

            // F10 has special meaning for menus. 
            //  - F10 alone, should toggle the selection of the first item 
            //      in a horizontal menu
            //  - Shift-F10 should display a context menu.

            if (VK_F10 == pmsg->wParam)
            {
                // Is this the Shift-F10 Case?
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    // Yes. We need to force this message into a context menu
                    // message.
                    pmsg->message = WM_CONTEXTMENU;
                    pmsg->lParam = -1;
                    pmsg->wParam = (WPARAM)_pmtbTracked->_hwndMB;
                    return 0;
                }
                else if (!_fVertical)   //No; Then we need to toggle in the horizontal case
                {
                    if (_pmtbMenu)
                    {
                        // Set the hot item to the first one.
                        int iHot = 0;
                        if (ToolBar_GetHotItem(_pmtbMenu->_hwndMB) != -1)
                            iHot = -1;  // We're toggling the selection off.
                        ToolBar_SetHotItem(_pmtbMenu->_hwndMB, iHot);
                    }
                    return 0;
                }
            }
                
            // Redirect to the toolbar
            if (_pmtbTracked)
                pmsg->hwnd = _pmtbTracked->_hwndMB;
            return 0;

        case WM_NULL:
            // Handle this here (we do nothing) to avoid mistaking this for
            // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
            // RegisterWindowMessage fails.
            return 0;

        default:
            // We used to handle g_nMBPopupOpen here.  But we can't because calling TrackPopupMenu
            // (via CTrackPopupBar::Popup) w/in a GetMessageFilter is very bad.
            break;
        }
    }

    if (bRemove)
    {
        // These messages must be processed even when no submenu is open
        switch (pmsg->message)
        {
        case WM_CLOSE:
            // Being deactivated.  Bail out of menus.
            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): sending MPOS_FULLCANCEL", DBG_THIS);

            _CancelMode(MPOS_FULLCANCEL);
            break;

        default:
            if (IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
            {
                // If we move the mouse, collapse the tip. Careful not to blow away a balloon tip...
                if (_pmbState)
                    _pmbState->HideTooltip(FALSE);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                if (_pmtbMenu)
                    _pmtbMenu->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                // Don't let the message be dispatched now that we've
                // forwarded it.
                pmsg->message = WM_NULL;
            }
            else if (pmsg->message == g_nMBFullCancel)
            {
                // Popup 
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private full cancel message", DBG_THIS);

                _SubMenuOnSelect(MPOS_CANCELLEVEL);
                _CancelMode(MPOS_FULLCANCEL);
                return 1;
            }
            break;
        }
    }
    
    return 0;    
}    


/*----------------------------------------------------------
Purpose: Handle WM_SYSCHAR

         This is handled for the toplevel menu only.

*/
HRESULT CMenuBand::_OnSysChar(MSG * pmsg, BOOL bFirstDibs)
{
    TCHAR ch = (TCHAR)pmsg->wParam;

    // HACKHACK (scotth): I'm only doing all this checking because I don't
    // understand why the doc-obj case sometimes (and sometimes doesn't) 
    // intercept this in its message filter.
    
    if (!bFirstDibs && _fSysCharHandled)
    {
        _fSysCharHandled = FALSE;
        return S_FALSE;
    }
    
    if (TEXT(' ') == (TCHAR)pmsg->wParam)
    {
        _fAltSpace = TRUE;  // In the words of Spock..."Remember"
        // start menu alt+space
        TraceMsg(DM_MISC, "cmb._osc: alt+space _fTopLevel(1)");
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
    }
    else if (!_fInSubMenu)
    {
        int idBtn;

        ASSERT(_fTopLevel);

        // There is a brief instant when we're merging a menu and pumping messages
        // This results in a null _pmtbMenu.
        if (_pmtbMenu)
        {
            // Only a toplevel menubar follows this codepath.  This means only
            // the static menu toolbar will exist (and not the shellfolder toolbar).
            _pmtbTracked = _pmtbMenu;

            HWND hwnd = _pmtbTracked->_hwndMB;
            if (ToolBar_MapAccelerator(hwnd, ch, &idBtn))
            {
                // Post a message since we're already in a menu loop
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): WM_SYSCHAR: Posting CMBPopup message", DBG_THIS);
                UIActivateIO(TRUE, NULL);
                _pmtbTracked->PostPopup(idBtn, TRUE, TRUE);
                // browser menu alt+key, start menu alt+key
                TraceMsg(DM_MISC, "cmb._osc: alt+key _fTopLevel(1)");
                UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
                return S_OK;
            }
        }
    }

    // Set or reset
    _fSysCharHandled = bFirstDibs ? TRUE : FALSE;
    
    return S_FALSE;
}

HRESULT CMenuBand::_ProcessMenuPaneMessages(MSG* pmsg)
{
    if (pmsg->message == g_nMBPopupOpen)
    {
        // Popup the submenu.  Since the top-level menuband receives this first, the
        // command must be piped down the chain to the bottom-most menuband.
        IOleCommandTarget * poct;
    
        QueryService(SID_SMenuBandBottom, IID_PPV_ARG(IOleCommandTarget, &poct));

        if (poct)
        {
            BOOL bSetItem = LOWORD(pmsg->lParam);
            BOOL bInitialSelect = HIWORD(pmsg->lParam);
            VARIANTARG vargIn;

            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private popup menu message", DBG_THIS);

            DWORD dwOpt = 0;

            vargIn.vt = VT_I4;
            vargIn.lVal = (LONG)pmsg->wParam;
        
            if (bSetItem)
                dwOpt |= MBPUI_SETITEM;

            if (bInitialSelect)
                dwOpt |= MBPUI_INITIALSELECT;
            
            poct->Exec(&CGID_MenuBand, MBANDCID_POPUPITEM, dwOpt, &vargIn, NULL);
            poct->Release();
            return S_OK;
        }
    }
    else if (pmsg->message == g_nMBDragCancel)
    {
        // If we got a drag cancel, make sure that the bottom most
        // menu does not have the drag enter.
        IUnknown_QueryServiceExec(SAFECAST(this, IOleCommandTarget*), 
            SID_SMenuBandBottom, &CGID_MenuBand, MBANDCID_DRAGCANCEL, 0, NULL, NULL);
        return S_OK;
    }
    else if (pmsg->message == g_nMBOpenChevronMenu)
    {

        VARIANTARG v;
        v.vt = VT_I4;
        v.lVal = (LONG)pmsg->wParam;

        IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_PUSHCHEVRON, _dwBandID, &v, NULL);
    }
    else if (pmsg->message == g_nMBFullCancel)
    {
        _SubMenuOnSelect(MPOS_CANCELLEVEL);
        _CancelMode(MPOS_FULLCANCEL);
        return S_OK;
    }

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::IsMenuMessage method

         The thread's message pump calls this function to see if any
         messages need to be redirected to the menu band.

         This returns S_OK if the message is handled.  The
         message pump should not pass it onto TranslateMessage
         or DispatchMessage if it does.

*/
STDMETHODIMP CMenuBand::IsMenuMessage(MSG * pmsg)
{
    HRESULT hres = S_FALSE;

    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::IsMM"), pmsg);
#endif
    if (!_fShow)
        goto Return;

    switch (pmsg->message)
    {
    case WM_SYSKEYDOWN:
        // blow this off if it's a repeated keystroke
        if (!(pmsg->lParam & 0x40000000))
        {
            SendMessage(_hwndParent, WM_CHANGEUISTATE ,MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL), 0);

            // Are we pressing the Alt key to activate the menu?
            if (!_fMenuMode && pmsg->wParam == VK_MENU && _pmbState)
            {
                // Yes; The the menu was activated because of a keyboard,
                // Set the global state to show the keyboard cues.
                _pmbState->SetKeyboardCue(TRUE);

                // Since this only happens on the top level menu,
                // We only have to tell the "Top" menu to update it's state.
                _pmtbTop->SetKeyboardCue();
            }
        }
        break;

    case WM_SYSKEYUP:
        // If we're in menu mode, ignore this message. 
        // 
        if (_fMenuMode)
            hres = S_OK;
        break;

    case WM_SYSCHAR:
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //

        // Outlook Express needs a message hook in order to filter this 
        // message for perf we do not use that method.

        // Athena fix 222185 (lamadio) We also don't want to do this if we are not active! 
        // otherwise when WAB is on top of OE, we'll steal it's messages

        // (lamadio): If the Message filter is "engaged", then we can process accelerators.
        // Engaged does not mean that the filter is running.
        if (GetMessageFilter()->IsEngaged())
        {
            hres = (_OnSysChar(pmsg, TRUE) == S_OK) ? S_OK : S_FALSE;
        }
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_KEYUP:
        if (_fMenuMode)
        {
            // All keystrokes should be handled or eaten by menubands
            // if we're engaged.  We must do this, otherwise hosted 
            // components like mshtml or word will try to handle the 
            // keystroke in CBaseBrowser.

            // Also, don't bother forwarding tabs
            if (VK_TAB != pmsg->wParam)
            {
                // Since we're answer S_OK, dispatch it ourselves.
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
            }

            hres = S_OK;
        }
        break;

    case WM_CONTEXTMENU:
        // Since the start button has the keyboard focus,
        // the start button will handle this. We need to forward this off to the 
        // currently tracked item at the bottom of the chain
        LRESULT lres;
        IWinEventHandler* pweh;

        if (_fMenuMode &&
            SUCCEEDED(QueryService(SID_SMenuBandBottomSelected, IID_PPV_ARG(IWinEventHandler, &pweh))))
        {
            pweh->OnWinEvent(HWND_BROADCAST, pmsg->message, 
                pmsg->wParam, pmsg->lParam, &lres);
            pweh->Release();
            hres = S_OK;
        }
        break;

    default:

        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point

        if (_pmbState->GetSubclassedHWND() == NULL)
            hres = _ProcessMenuPaneMessages(pmsg);
        break;
    }

Return:
    if (!_fMenuMode && hres != S_OK)
        hres = E_FAIL;


    return hres;
}

BOOL HasWindowTopmostOwner(HWND hwnd)
{
    HWND hwndOwner = hwnd;
    while (hwndOwner = GetWindowOwner(hwndOwner))
    {
        if (GetWindowLong(hwndOwner, GWL_EXSTYLE) & WS_EX_TOPMOST)
            return TRUE;
    }

    return FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::TranslateMenuMessage method

         The main app's window proc calls this so the menuband
         catches messages that are dispatched from a different
         message pump (than the thread's main pump).
         
         Translates messages specially for menubands.  Some messages
         are processed while the menuband is active.  Others are only
         processed when it is not.  Messages that are not b/t
         WM_KEYFIRST and WM_KEYLAST are handled here (the browser
         does not send these messages to IInputObject::
         TranslateAcceleratorIO).


Returns: S_OK if message is processed

*/
STDMETHODIMP CMenuBand::TranslateMenuMessage(MSG * pmsg, LRESULT * plRet)
{
    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::TMM"), pmsg);
#endif

    switch (pmsg->message)
    {
    case WM_SYSCHAR:
        // In certain doc-obj situations, the OLE message filter (??)
        // grabs this before the main thread's message pump gets a 
        // whack at it.  So we handle it here too, in case we're in
        // this scenario.
        //
        // See the comments in IsMenuMessage regarding this message.
        return _OnSysChar(pmsg, FALSE);

    case WM_INITMENUPOPUP:
        // Normally the LOWORD(lParam) is the index of the menu that 
        // is being popped up.  TrackPopupMenu (which CMenuISF uses) 
        // always sends this message with an index of 0.  This breaks 
        // clients (like DefView) who check this value.  We need to
        // massage this value if we find we're the source of the 
        // WM_INITMENUPOPUP.
        //
        // (This is not in TranslateAcceleratorIO b/c TrackPopupMenu's
        // message pump does not call it.  The wndproc must forward
        // the message to this function for us to get it.)

        if (_fInSubMenu && _pmtbTracked)
        {
            // Massage lParam to use the right index
            int iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, _nItemCur);
            pmsg->lParam = MAKELPARAM(iPos, HIWORD(pmsg->lParam));

            // Return S_FALSE so this message will still be handled
        }
        break;

    case WM_UPDATEUISTATE:
        if (_pmbState)
        {
            // we don't care about UISF_HIDEFOCUS
            if (UISF_HIDEACCEL == HIWORD(pmsg->wParam))
                _pmbState->SetKeyboardCue(UIS_CLEAR == LOWORD(pmsg->wParam) ? TRUE : FALSE);
        }
        break;


    case WM_ACTIVATE:
        {
            CMBMsgFilter* pmf = GetMessageFilter();
            // Debug note: to debug menubands on ntsd, set the prototype
            // flag accordingly.  This will keep menubands from going
            // away the moment the focus changes.

            // Becomming inactive?
            if (WA_INACTIVE == LOWORD(pmsg->wParam))
            {
                // Yes; Free up the global object
                // Athena fix (lamadio) 08.02.1998: Athena uses menubands. Since they
                // have a band per window in one thread, we needed a mechanism to switch
                // between them. So we used the Msgfilter to forward messages. Since there 
                // are multiple windows, we need to set correct one.
                // But, On a deactivate, we need to NULL it out incase a window,
                // running in the same thread, has normal USER menu. We don't want to steal
                // their messages.
                if (pmf->GetTopMostPtr() == this)
                    pmf->SetTopMost(NULL);

                pmf->DisEngage(_pmbState->GetContext());

                HWND hwndLostTo = (HWND)(pmsg->lParam);

                // We won't bail on the menus if we're loosing activation to a child.
                if (!IsAncestor(hwndLostTo, _pmbState->GetWorkerWindow(NULL)))
                {
                    if (_fMenuMode &&
                        !(g_dwPrototype & PF_USINGNTSD) && 
                        !_fDragEntered)
                    {
                        // Being deactivated.  Bail out of menus.  
                        // (Only the toplevel band gets this message.)
                        if (_fInSubMenu)
                        {
                            IMenuPopup* pmp = _pmpSubMenu;
                            if (_pmpTrackPopup)
                                pmp = _pmpTrackPopup;
                            ASSERT(pmp);    // This should be valid. If not, someone messed up.
                            pmp->OnSelect(MPOS_FULLCANCEL);
                        }

                        _CancelMode(MPOS_FULLCANCEL);
                    }
                }
            }
            else if (WA_ACTIVE == LOWORD(pmsg->wParam) || 
                     WA_CLICKACTIVE == LOWORD(pmsg->wParam))
            {
                // If I have activation, the Worker Window needs to be bottom...
                //
                // NOTE: Don't do this if the worker window has a topmost owner
                // (such as the tray).  Setting a window to HWND_NOTOPMOST moves
                // its owner windows to HWND_NOTOPMOST as well, which in this case
                // was breaking the tray's "always on top" feature.
                //
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker) && !_fDragEntered)
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);

                // Set the context because when a menu heirarchy becomes active because the
                // subclassed HWND becomes active, we need to reenable the message hook.
                pmf->SetContext(this, TRUE);

                // When we get reactivated, we need to position ourself above the start bar.
                Exec(&CGID_MenuBand, MBANDCID_REPOSITION, TRUE, NULL, NULL);
            
                // Becomming activated. We need to reengage the message hook so that
                // we get the correct messages.
                pmf->ReEngage(_pmbState->GetContext());

                // Are we in menu mode?
                if (_fMenuMode)
                {
                    // Need to reengage some things.
                    // Take the capture back because we have lost it to context menus or dialogs.
                    pmf->RetakeCapture();

                }
                pmf->SetTopMost(this);
            }

            //
            // Memphis and NT5 grey their horizontal menus when the windows is inactive.
            //
            if (!_fVertical && _pmtbMenu)
            {
                // This needs to stay here because of the above check...
                if (WA_INACTIVE == LOWORD(pmsg->wParam))
                {
                    _fAppActive = FALSE;
                }
                else
                {
                    _fAppActive = TRUE;
                }
                // Reduces flicker by using this instead of an InvalidateWindow/UpdateWindow Pair
                RedrawWindow(_pmtbMenu->_hwndMB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }
        break;

    case WM_SYSCOMMAND:
        if ( !_fMenuMode )
        {
            switch (pmsg->wParam & 0xFFF0)
            {
            case SC_KEYMENU:
                // The user either hit the Alt key by itself or Alt-space.
                // If it was Alt-space, let DefWindowProc handle it so the
                // system menu comes up.  Otherwise, we'll handle it to
                // toggle the menuband.

                // Was it Alt-space?
                if (_fAltSpace)
                {
                    // Yes; let it go
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the Alt-space", DBG_THIS);
                    _fAltSpace = FALSE;
                }
                else if (_fShow)
                {
                    // No; activate the menu
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the WM_SYSCOMMAND, SC_KEYMENU", DBG_THIS);

                    UIActivateIO(TRUE, NULL);

                    // We sit in a modal loop here because typically
                    // WM_SYSCOMMAND doesn't return until the menu is finished.
                    //
                    while (_fMenuMode) 
                    {
                        MSG msg;
                        if (GetMessage(&msg, NULL, 0, 0)) 
                        {
                            if ( S_OK != IsMenuMessage(&msg) )
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                    }

                    *plRet = 0;
                    return S_OK;        // Caller shouldn't handle this
                }
                break;
            }
        }
        break;

    default:
        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point
        if (_pmbState->GetSubclassedHWND() != NULL)
            return _ProcessMenuPaneMessages(pmsg);
        break;


    }
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

         Called by the menusite to host this band.  Since the
         menuband contains two toolbars, we set their parent
         window to be the site's hwnd.

*/
STDMETHODIMP CMenuBand::SetSite(IUnknown* punkSite)
{
    // Do this first because SetParent needs to query to the top level browser for
    // sftbar who queries to the top level browser to get the drag and drop window.
    HRESULT hres = SUPERCLASS::SetSite(punkSite);

    if (_psmcb && _fTopLevel && !(_dwFlags & SMINIT_NOSETSITE))
        IUnknown_SetSite(_psmcb, punkSite);

    IUnknown_GetWindow(punkSite, &_hwndParent);

    // Need this for Closing an expanded vertical menu. Start Menu knows to do this when it's top level,
    // but the Favorites needs to know when it's parent is the horizontal menu.
    VARIANT var = {0};
    if (SUCCEEDED(IUnknown_QueryServiceExec(punkSite, SID_SMenuBandParent, &CGID_MenuBand,
                                       MBANDCID_ISVERTICAL, 0, NULL, &var)) && 
        var.boolVal == VARIANT_FALSE)
    {
        ASSERT(VT_BOOL == var.vt);

        _fParentIsHorizontal = TRUE;
    }

    if (_fNoBorder)
    {
        IUnknown_QueryServiceExec(punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, MBCID_NOBORDER, _fNoBorder, NULL, NULL);
    }


    // Tell the toolbars who their new parent is
    if (_pmtbMenu)
        _pmtbMenu->SetParent(_hwndParent);
    if (_pmtbShellFolder)
        _pmtbShellFolder->SetParent(_hwndParent);

    return hres;
}

/*----------------------------------------------------------
Purpose: IShellMenu::Initialize method

*/
STDMETHODIMP CMenuBand::Initialize(IShellMenuCallback* psmcb, UINT uId, UINT uIdAncestor, DWORD dwFlags)
{
    // Initalized can be called with NULL values to only set some of them.

    // Default to Vertical
    if (!(dwFlags & SMINIT_HORIZONTAL) && !(dwFlags & SMINIT_VERTICAL) && !(dwFlags & SMINIT_MULTICOLUMN))
        dwFlags |= SMINIT_VERTICAL;

    HRESULT hr = _Initialize(dwFlags);
    if (SUCCEEDED(hr))
    {
        DEBUG_CODE( _fInitialized = TRUE; );

        if (uIdAncestor != ANCESTORDEFAULT)
            _uIdAncestor = uIdAncestor;

        if (_uId != -1)
            _uId = uId;

        if (psmcb)
        {
            if (!SHIsSameObject(psmcb, _psmcb))
            {
                if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                    IUnknown_SetSite(_psmcb, NULL);

                ATOMICRELEASE(_psmcb);
                _psmcb = psmcb;
                _psmcb->AddRef();

                // We do not set the site in case this callback is shared between 2 bands (Menubar/Chevron menu)
                if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                    IUnknown_SetSite(_psmcb, _punkSite);

                // Only call this if we're setting a new one. Pass the address of the user associated
                // data section. This is so that the callback can associate data with this pane only
                _CallCB(SMC_CREATE, 0, (LPARAM)&_pvUserData);
            }
        }
    }
    return hr;
}

/*----------------------------------------------------------
Purpose: IShellMenu::GetMenuInfo method

*/
STDMETHODIMP CMenuBand::GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags)
{
    if (ppsmc)
    {
        *ppsmc = _psmcb;
        if (_psmcb)
            ((IShellMenuCallback*)*ppsmc)->AddRef();
    }

    if (puId)
        *puId = _uId;

    if (puIdAncestor)
        *puIdAncestor = _uIdAncestor;

    if (pdwFlags)
        *pdwFlags = _dwFlags;

    return NOERROR;
}


HRESULT CMenuBand::_AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags)
{
    if (_pszTheme)
    {
        pmtb->SetTheme(_pszTheme);
    }

    if (_fNoBorder)
    {
        pmtb->SetNoBorder(_fNoBorder);
    }

    pmtb->SetSite(SAFECAST(this, IMenuBand*));
    HRESULT hr = S_OK;
    if (_hwndParent)
        hr = pmtb->CreateToolbar(_hwndParent);
    
    if (SUCCEEDED(hr))
    {
        // Treat this like a two-element stack, where this function
        // behaves like a "push".  The one additional trick is we 
        // could be pushing onto the top or the bottom of the "stack".

        if (dwFlags & SMSET_BOTTOM)
        {
            if (_pmtbBottom)
            {
                // I don't need to release, because _pmtbTop and _pmtbBottom are aliases for
                // _pmtbShellFolder and _pmtbMenu
                _pmtbTop = _pmtbBottom;
                _pmtbTop->SetToTop(TRUE);
            }

            _pmtbBottom = pmtb;
            _pmtbBottom->SetToTop(FALSE);
        }
        else    // Default to Top...
        {
            if (_pmtbTop)
            {
                _pmtbBottom = _pmtbTop;
                _pmtbBottom->SetToTop(FALSE);
            }

            _pmtbTop = pmtb;
            _pmtbTop->SetToTop(TRUE);
        }

        // _pmtbBottom should never be the only toolbar that exists in the menuband.
        if (!_pmtbTop)
            _pmtbTop = _pmtbBottom;

        // The menuband determines there is a single toolbar by comparing
        // the bottom with the top.  So make the bottom the same if necessary.
        if (!_pmtbBottom)
            _pmtbBottom = _pmtbTop;
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetShellFolder method

*/
STDMETHODIMP CMenuBand::GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl,
                                       REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    if (_pmtbShellFolder)
    {
        *pdwFlags = _pmtbShellFolder->GetFlags();

        hres = S_OK;

        if (ppvObj)
        {
            // HACK HACK.  this should QI for a mnfolder specific interface to do this.
            hres = _pmtbShellFolder->GetShellFolder(ppidl, riid, ppvObj);
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetShellFolder method

*/
STDMETHODIMP CMenuBand::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags)
{
    ASSERT(_fInitialized);
    HRESULT hr = E_OUTOFMEMORY;

    // If we're processing a change notify, we cannot do anything that will modify state.
    // NOTE: if we don't have a state, we can't possibly processing a change notify
    if (_pmbState && _pmbState->IsProcessingChangeNotify())
        return E_PENDING;

    // Only one shellfolder menu can exist per menuband.  Additionally,
    // a shellfolder menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a static menu).

    // Is there already a shellfolder menu?
    if (_pmtbShellFolder)
    {
        IShellFolderBand* psfb;
        _pmtbShellFolder->QueryInterface(IID_PPV_ARG(IShellFolderBand, &psfb));
        ASSERTMSG(psfb != NULL, "CMenuBand::SetShellFolder should have gotten interface");
        hr = psfb->InitializeSFB(psf, pidlFolder);
        psfb->Release();
        
    }
    else
    {
        _pmtbShellFolder = new CMenuSFToolbar(this, psf, pidlFolder, hKey, dwFlags);
        if (_pmtbShellFolder)
        {
            hr = _AddToolbar(_pmtbShellFolder, dwFlags);
        }
    }
    return hr;
}


/*----------------------------------------------------------
Purpose: IMenuBand::GetMenu method

*/
STDMETHODIMP CMenuBand::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{
    HRESULT hres = E_FAIL;

    // HACK HACK.  this should QI for a menustatic specific interface to do this.
    if (_pmtbMenu)
        hres = _pmtbMenu->GetMenu(phmenu, phwnd, pdwFlags);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuBand::SetMenu method

*/
STDMETHODIMP CMenuBand::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{
    // Passing a NULL hmenu is valid. It means destroy our menu object.
    ASSERT(_fInitialized);
    HRESULT hr = E_FAIL;

    // Only one static menu can exist per menuband.  Additionally,
    // a static menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a shellfolder menu).

    // Is there already a static menu?
    if (_pmtbMenu)
    {
        // Since we're merging in a new menu, make sure to update the cache...
        _hmenu = hmenu;
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        return _pmtbMenu->SetMenu(hmenu, hwnd, dwFlags);
    }
    else
    {
        // This is to work around a problem in the interface definintion: We have
        // no method of setting the Subclassed HWND outside of a SetMenu. So I'm just piggybacking
        // off of this. A better fix would be to introduce IMenuBand2::SetSubclass(HWND). IMenuBand
        // actually implements the "Subclassing", so extending this interface would be worthwhile.
        _hwndMenuOwner = hwnd;

        if (_fTopLevel)
        {
            _pmbState->SetSubclassedHWND(hwnd);
        }

        if (hmenu)
        {
            _hmenu = hmenu;
            _pmtbMenu = new CMenuStaticToolbar(this, hmenu, hwnd, _uId, dwFlags);
            if (_pmtbMenu)
            {
                hr = _AddToolbar(_pmtbMenu, dwFlags);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetMenuToolbar method

*/
STDMETHODIMP CMenuBand::SetMenuToolbar(IUnknown* punk, DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    CMenuToolbarBase* pmtb;
    if (punk && SUCCEEDED(punk->QueryInterface(CLSID_MenuToolbarBase, (void**)&pmtb)))
    {
        ASSERT(_pmtbShellFolder == NULL);
        _pmtbShellFolder = pmtb;
        hr = _AddToolbar(pmtb, dwFlags);
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellMenu::InvalidateItem method

*/
STDMETHODIMP CMenuBand::InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    // If psmd is NULL, we need to just dump the toolbars and do a full reset.
    if (psmd == NULL)
    {
        // If we're processing a change notify, we cannot do anything that will modify state.
        if (_pmbState && _pmbState->IsProcessingChangeNotify())
            return E_PENDING;

        if (_pmbState)
            _pmbState->PushChangeNotify();

        // Tell the callback we're refreshing so that it can
        // reset any cached state
        _CallCB(SMC_REFRESH);

        // Reinitialize the callback if requested
        if (dwFlags & SMINV_INITMENU)
        {
            _CallCB(SMC_INITMENU);
        }

        _fExpanded = FALSE;

        // We don't need to refill if the caller only wanted to 
        // refresh the sub menus.

        // Refresh the Shell Folder first because
        // It may have no items after it's done, and the
        // menuband may rely on this to add a seperator
        if (_pmtbShellFolder)
            _pmtbShellFolder->v_Refresh();

        // Refresh the Static menu
        if (_pmtbMenu)
            _pmtbMenu->v_Refresh();

        if (_pmpSubMenu)
        {
            _fInSubMenu = FALSE;
            IUnknown_SetSite(_pmpSubMenu, NULL);
            ATOMICRELEASE(_pmpSubMenu);
        }

        if (_pmbState)
            _pmbState->PopChangeNotify();

    }
    else
    {
        if (_pmtbTop)
            hres = _pmtbTop->v_InvalidateItem(psmd, dwFlags);

        // We refresh everything at this level if the psmd is null
        if (_pmtbBottom && hres != S_OK)
            hres = _pmtbBottom->v_InvalidateItem(psmd, dwFlags);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetState method

*/
STDMETHODIMP CMenuBand::GetState(LPSMDATA psmd)
{
    if (_pmtbTracked)
        return _pmtbTracked->v_GetState(-1, psmd);
    // todo: might want to put stuff from _CallCB (below) in here
    return E_FAIL;
}


HRESULT CMenuBand::_CallCB(DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_psmcb)
        return S_FALSE;

    // We don't need to check callback mask here because these are not maskable events.

    SMDATA smd = {0};
    smd.punk = SAFECAST(this, IShellMenu*);
    smd.uIdParent = _uId;
    smd.uIdAncestor = _uIdAncestor;
    smd.hwnd = _hwnd;
    smd.hmenu = _hmenu;
    smd.pvUserData = _pvUserData;
    if (_pmtbShellFolder)
        _pmtbShellFolder->GetShellFolder(&smd.pidlFolder, IID_PPV_ARG(IShellFolder, &smd.psf));
    HRESULT hres = _psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    ILFree(smd.pidlFolder);
    if (smd.psf)
        smd.psf->Release();

    return hres;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         This is called by the base browser only when the menuband
         "has the focus", and only for messages b/t WM_KEYFIRST
         and WM_KEYLAST.  This isn't very useful for menubands.
         See the explanations in GetMsgFilterCB, IsMenuMessage
         and TranslateMenuMessage.

         In addition, menubands cannot ever have the activation,
         so this method should never be called.

         Returns S_OK if handled.
*/
STDMETHODIMP CMenuBand::TranslateAcceleratorIO(LPMSG pmsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

*/
STDMETHODIMP CMenuBand::HasFocusIO()
{
    // We consider a menuband has the focus even if it has submenus
    // that are currently cascaded out.  All menubands in the chain
    // have the focus.
    return _fMenuMode ? S_OK : S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

         The child menubar calls us with its IMenuPopup pointer.
*/
STDMETHODIMP CMenuBand::SetSubMenu(IMenuPopup * pmp, BOOL fSet)
{
    ASSERT(IS_VALID_CODE_PTR(pmp, IMenuPopup));

    if (fSet)
    {
        _fInSubMenu = TRUE;
    }
    else 
    {
        if (_pmtbTracked)
        {
            _pmtbTracked->PopupClose();
        }

        _fInSubMenu = FALSE;
        _nItemSubMenu = -1;
    }

    return S_OK;
}    

HRESULT CMenuBand::_SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    HRESULT hres;
    IMenuPopup * pmpSite;

    hres = IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmpSite));
    if (SUCCEEDED(hres))
    {
        hres = pmpSite->SetSubMenu(pmp, bSet);
        pmpSite->Release();
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Tell the GetMsg filter that this menuband is ready to
         listen to messages.

*/
HRESULT CMenuBand::_EnterMenuMode(void)
{
    ASSERT(!_fMenuMode);        // Must not push onto stack more than once

    if (g_dwProfileCAP & 0x00002000) 
        StartCAP();

    DEBUG_CODE( _nMenuLevel = g_nMenuLevel++; )

    _fMenuMode = TRUE;
    _fInSubMenu = FALSE;
    _nItemMove = -1;
    _fCascadeAnimate = TRUE;

    _hwndFocusPrev = NULL;

    if (_fTopLevel)
    {
        // REVIEW (scotth): some embedded controls (like the surround
        // video ctl on the carpoint website) have another thread that
        // eats all the messages when the control has the focus.
        // This prevents us from getting any messages once we're in
        // menu mode.  I don't understand why USER menus work yet.
        // One way to work around this bug is to detect this case and
        // set the focus to our main window for the duration.
        
        if (GetWindowThreadProcessId(GetFocus(), NULL) != GetCurrentThreadId())
        {
            IShellBrowser* psb;
            
            if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
            {
                HWND hwndT;
                
                psb->GetWindow(&hwndT);
                _hwndFocusPrev = SetFocus(hwndT);
                psb->Release();
            }
        }
    
        _hCursorOld = GetCursor();
        SetCursor(g_hCursorArrow);
        HideCaret(NULL);
    }

    _SiteSetSubMenu(this, TRUE);

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        if (!_fVertical && -1 == _nItemNew)
        {
            // The Alt key always highlights the first menu item initially
            SetTracked(_pmtbTop);
            ToolBar_SetHotItem(hwnd, 0);
            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTop->_hwndMB, OBJID_CLIENT, 
                GetIndexFromChild(TRUE, 0));
        }

        _pmtbTop->Activate(TRUE);

        // The toolbar usually tracks mouse events.  However, as the mouse
        // moves over submenus, we still want the parent menubar to
        // behave as if it has retained the focus (that is, keep the
        // last selected item highlighted). This also prevents the toolbar
        // from handling WM_MOUSELEAVE messages unnecessarily.
        ToolBar_SetAnchorHighlight(hwnd, TRUE);

        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Entering menu mode", DBG_THIS);
        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPSTART: EVENT_SYSTEM_MENUSTART, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(TRUE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, TRUE); // Turn off anchoring
    }

    GetMessageFilter()->Push(_pmbState->GetContext(), this, _punkSite);

    return S_OK;
}    


void CMenuBand::_ExitMenuMode(void)
{
    _fMenuMode = FALSE;
    _nItemCur = -1;
    _fPopupNewMenu = FALSE;
    _fInitialSelect = FALSE;
    CMBMsgFilter* pmf = GetMessageFilter();

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        ToolBar_SetAnchorHighlight(hwnd, FALSE); // Turn off anchoring
        if (!_fVertical)
        {
            // Use the first item, since we're assuming every menu must have
            // at least one item
            _pmtbTop->v_SendMenuNotification(0, TRUE);
        
            // The user may have clicked outside the menu, which would have
            // cancelled it.  But since we set the ANCHORHIGHLIGHT attribute,
            // the toolbar won't receive a message to cause it to
            // remove the highlight.  So do it explicitly now.
            SetTracked(NULL);
            UpdateWindow(hwnd);
        }

        _pmtbTop->Activate(FALSE);

        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPEND: EVENT_SYSTEM_MENUEND, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(FALSE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, FALSE); // Turn off anchoring
    }

    pmf->Pop(_pmbState->GetContext());

    _SiteSetSubMenu(this, FALSE);

    if (_fTopLevel)
    {
        SetCursor(_hCursorOld);
        ShowCaret(NULL);
        
        pmf->SetContext(this, FALSE);

        // We do this here, because ShowDW(FALSE) does not get called on the
        // top level menu band. This resets the state, so that the accelerators 
        // are not shown.
        if (_pmbState)
            _pmbState->SetKeyboardCue(FALSE);

        // Tell the menus to update their state to the current global cue state.
        if (_pmtbTop)
            _pmtbTop->SetKeyboardCue();

        if (_pmtbTop != _pmtbBottom && _pmtbBottom)
            _pmtbBottom->SetKeyboardCue();

    }

    if (_hwndFocusPrev)
        SetFocus(_hwndFocusPrev);

    if (_fTopLevel)
    {
        //
        // The top-level menu has gone away.  Win32 focus and ui-activation don't
        // actually change when this happens, so the browser and focused dude have
        // no idea that something happened and won't generate any AA event.  So, we
        // do it here for them.  Note that if there was a selection inside the focused
        // dude, we'll lose it.  This is the best we can do for now, as we don't
        // currently have a way to tell the focused/ui-active guy (who knows about the
        // current selection) to reannounce focus.
        //
        HWND hwndFocus = GetFocus();
        NotifyWinEvent(EVENT_OBJECT_FOCUS, hwndFocus, OBJID_CLIENT, CHILDID_SELF);
    }
        
    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Exited menu mode", DBG_THIS);
    DEBUG_CODE( g_nMenuLevel--; )
    DEBUG_CODE( _nMenuLevel = -1; )
    if (g_dwProfileCAP & 0x00002000) 
        StopCAP();
}    


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO

         Menubands CANNOT take the activation.  Normally
         a band would return S_OK and call the site's 
         OnFocusChangeIS method, so that its TranslateAcceleratorIO
         method would receive keyboard messages.

         However, menus are different.  The window/toolbar that
         currently has the activation must retain that activation
         when the menu pops down.  Because of this, menubands use 
         a GetMessage filter to intercept messages.

*/
STDMETHODIMP CMenuBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (lpMsg != NULL)
    {
        // don't allow TAB to band (or any other 'non-explicit' activation).
        // (if we just cared about TAB we'd check IsVK_TABCycler).
        // all kinds of badness would result if we did.
        // the band can't take focus (see above), so it can't obey the
        // UIAct/OnFocChg rules (e.g. can't call OnFocusChangeIS), so
        // our basic activation-tracking assumptions would be broken.
        return S_FALSE;
    }

    if (fActivate)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);
        
        if (!_fMenuMode)
        {
            _EnterMenuMode();

            // The toplevel menuband does not set the real activation.  
            // But the children do, so activation can be communicated
            // with the parent menuband.
            if (_fVertical)
            {
                IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
            }
            else
            {
                IUnknown_Exec(_punkSite, &CGID_Theater, THID_TOOLBARACTIVATED, 0, NULL, NULL);
            }
        }

        if (_fPopupNewMenu)
        {
            _nItemCur = _nItemNew;
            ASSERT(-1 != _nItemCur);
            ASSERT(_pmtbTracked);

            _fPopupNewMenu = FALSE;
            _nItemNew = -1;

            // Popup a menu
            hres = _pmtbTracked->PopupOpen(_nItemCur);
            if (FAILED(hres))
            {
                // Don't fail the activation
                TraceMsg(TF_ERROR, "%d (pmb=%#08lx): PopupOpen failed", DBG_THIS);
                MessageBeep(MB_OK);
            }
            else if (S_FALSE == hres)
            {
                // The submenu was modal and is finished now
                _ExitMenuMode();
            }
        }
    }
    else if (_fMenuMode)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);

        ASSERT( !_fInSubMenu );

        if (!_fTopLevel)
            IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), FALSE);

        _ExitMenuMode();
    }

    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/
HRESULT CMenuBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    HRESULT hres = NOERROR;

    _dwBandID = dwBandID;           // critical for perf! (BandInfoChanged)

    pdbi->dwMask &= ~DBIM_TITLE;    // no title (ever, for now)

    // We expect that _pmtbBottom should never be the only toolbar
    // that exists in the menuband.
    ASSERT(NULL == _pmtbBottom || _pmtbTop);

    pdbi->dwModeFlags = DBIMF_USECHEVRON;

    if (_pmtbTop)
    {
        // If the buttons need to be updated in the toolbars, the we should 
        // do this before we start asking them about their sizes....
        if (_fForceButtonUpdate)
        {
            _UpdateButtons();
        }

        if (_fVertical) 
        {
            pdbi->ptMaxSize.y = 0;
            pdbi->ptMaxSize.x = 0;

            SIZE size = {0};
        
            if (_pmtbMenu)
            {
                // size param zero here => it's just an out param
                _pmtbMenu->GetSize(&size);

                // HACKHACK (lamadio): On downlevel, LARGE metrics mode causes 
                // Start menu to push the programs menu item off screen.
                if (size.cy > (3 * GetSystemMetrics(SM_CYSCREEN) / 4))
                {
                    Exec(&CGID_MenuBand, MBANDCID_SETICONSIZE, ISFBVIEWMODE_SMALLICONS, NULL, NULL);
                    size.cx = 0;
                    size.cy = 0;
                    _pmtbMenu->GetSize(&size);
                }

                pdbi->ptMaxSize.y = size.cy;
                pdbi->ptMaxSize.x = size.cx;
            }
            if (_pmtbShellFolder)
            {
                // size param should be non-zero here => it's an in/out param
                _pmtbShellFolder->GetSize(&size);
                pdbi->ptMaxSize.y += size.cy + ((_pmtbMenu && !_fExpanded)? 1 : 0);   // Minor sizing problem
                pdbi->ptMaxSize.x = max(size.cx, pdbi->ptMaxSize.x);
            }

            pdbi->ptMinSize = pdbi->ptMaxSize;

        }
        else
        {
            HWND hwnd = _pmtbTop->_hwndMB;
            ShowDW(TRUE);

            SIZE rgSize;
            if ( SendMessage( hwnd, TB_GETMAXSIZE, 0, (LPARAM) &rgSize ))
            {
                pdbi->ptActual.y = rgSize.cy;
                SendMessage(hwnd, TB_GETIDEALSIZE, FALSE, (LPARAM)&pdbi->ptActual);
            }

            // make our min size identical to the size of the first button
            // (we're assuming that the toolbar has at least one button)
            RECT rc;
            SendMessage(hwnd, TB_GETITEMRECT, 0, (WPARAM)&rc);
            pdbi->ptMinSize.x = RECTWIDTH(rc);
            pdbi->ptMinSize.y = RECTHEIGHT(rc);
        }
    }
    return hres;
}

/*----------------------------------------------------------
Purpose: IOleService::Exec method

*/
STDMETHODIMP CMenuBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdExecOpt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{

    // Don't do anything if we're closing.
    if (_fClosing)
        return E_FAIL;

    if (pguidCmdGroup == NULL) 
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case MBCID_GETSIDE:
            if (pvarargOut) 
            {
                BOOL fOurChoice = FALSE;
                pvarargOut->vt = VT_I4;
                
                if (!_fTopLevel) 
                {
                    // if we are not the top level menu, we 
                    // must continue with the direction our parent was in
                    IMenuPopup* pmpParent;
                    IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmpParent));
                    if (pmpParent) 
                    {
                        if (FAILED(IUnknown_Exec(pmpParent, pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut)))
                            fOurChoice = TRUE;
                        pmpParent->Release();
                    }
                } else 
                    fOurChoice = TRUE;

                if (!fOurChoice)
                {
                    // only use the parent's side hint if it is in the same orientation (ie, horizontal menubar to vertical popup 
                    // means we need to make a new choice)
                    BOOL fParentVertical = (pvarargOut->lVal == MENUBAR_RIGHT || pvarargOut->lVal == MENUBAR_LEFT);
                    if (BOOLIFY(_fVertical) != BOOLIFY(fParentVertical))
                        fOurChoice = TRUE;
                }

                if (fOurChoice) 
                {
                    if (_fVertical)
                    {
                        HWND hWndMenuBand;

                        //
                        // The MenuBand is Mirrored , then start the first Menu Window
                        // as Mirrored. [samera]
                        //
                        if ((SUCCEEDED(GetWindow(&hWndMenuBand))) &&
                            (IS_WINDOW_RTL_MIRRORED(hWndMenuBand)) ) 
                            pvarargOut->lVal = MENUBAR_LEFT;
                        else
                            pvarargOut->lVal = MENUBAR_RIGHT;
                    }
                    else
                        pvarargOut->lVal = MENUBAR_BOTTOM;
                }

            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_MenuBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBANDCID_GETFONTS:
            if (pvarargOut)
            {
                if (EVAL(_pmbm))
                {
                    // this is not marshal-safe, but we're inproc
                    pvarargOut->vt = VT_UNKNOWN;
                    _pmbm->QueryInterface(IID_PPV_ARG(IUnknown, &pvarargOut->punkVal));
                    return S_OK;
                }
                else
                    return E_FAIL;
            }
            else
                return E_INVALIDARG;
            break;

        case MBANDCID_SETFONTS:
            if (pvarargIn && VT_UNKNOWN == pvarargIn->vt && pvarargIn->punkVal)
            {
                // this is not marshal-safe, but we're inproc
                ATOMICRELEASE(_pmbm);
                pvarargIn->punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);

                _fForceButtonUpdate = TRUE;
                // Force Update of Toolbars:
                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);
            }
            else
                return E_INVALIDARG;
            break;


        case MBANDCID_RECAPTURE:
            GetMessageFilter()->RetakeCapture();
            break;

        case MBANDCID_NOTAREALSITE:
            _fParentIsNotASite = BOOLIFY(nCmdExecOpt);
            break;

        case MBANDCID_ITEMDROPPED:
            {
                _fDragEntered = FALSE;
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker))
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
            }
            break;

        case MBANDCID_DRAGENTER:
            _fDragEntered = TRUE;
            break;

        case MBANDCID_DRAGLEAVE:
            _fDragEntered = FALSE;
            break;

            
        case MBANDCID_SELECTITEM:
            {
                int iPos = nCmdExecOpt;

                // If they are passing vararg in, then this is an ID, not a position
                if (pvarargIn && pvarargIn->vt == VT_I4)
                {
                    _nItemNew = pvarargIn->lVal;
                    _fPopupNewItemOnShow = TRUE;
                }

                // This can be called outside of a created band.
                if (_pmtbTop)
                {
                    if (iPos == MBSI_NONE)
                    {
                        SetTracked(NULL);
                    }
                    else
                    {
                        CMenuToolbarBase* pmtb = (iPos == MBSI_LASTITEM) ? _pmtbBottom : _pmtbTop;
                        ASSERT(pmtb);

                        SetTracked(pmtb);
                        _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                        // If the new hot item is in the obscured part of the menu, then the
                        // above call will have reentered & nulled out _pmtbTracked (since we
                        // drop down the chevron menu if the new hot item is obscured).  So we
                        // need to revalidate _pmtbTracked.
                        if (!_pmtbTracked)
                            break;

                        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                            GetIndexFromChild(TRUE, iPos));
                    }
                }
            }
            break;

        case MBANDCID_KEYBOARD:
            // If we've been executed because of a keyboard, then set the global
            // state to reflect that. This is sent by MenuBar when it's ::Popup
            // member is called with the flag MPPF_KEYBOARD. This is for start menu.
            if (_pmbState)
                _pmbState->SetKeyboardCue(TRUE);
            break;

        case MBANDCID_POPUPITEM:
            if (pvarargIn && VT_I4 == pvarargIn->vt)
            {
                // we don't want to popup a sub menu if we're tracking a context menu...
                if ( !((_pmtbBottom && _pmtbBottom->v_TrackingSubContextMenu()) || 
                       (_pmtbTop && _pmtbTop->v_TrackingSubContextMenu())))
                {
                    // No tracked item? Well default to the top (For the chevron menu)
                    if (!_pmtbTracked)
                    {
                        SetTracked(_pmtbTop);
                    }

                    // We don't want to display the sub menu if we're not shown.
                    // We do this because we could have been dismissed before the message
                    // was routed.
                    if (_fShow && _pmtbTracked)
                    {
                        int iItem;
                        int iPos;

                        if (nCmdExecOpt & MBPUI_ITEMBYPOS)
                        {
                            iPos = pvarargIn->lVal;
                            iItem = GetButtonCmd(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                        }
                        else
                        {
                            iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                            iItem = pvarargIn->lVal;
                        }


                        if (nCmdExecOpt & MBPUI_SETITEM)
                        {
                            // Set the hot item explicitly since this can be
                            // invoked by the keyboard and the mouse could be 
                            // anywhere.
                            _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                            // If the new hot item is in the obscured part of the menu, then the
                            // above call will have reentered & nulled out _pmtbTracked (since we
                            // drop down the chevron menu if the new hot item is obscured).  So we
                            // need to revalidate _pmtbTracked.
                            if (!_pmtbTracked)
                                break;

                            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                                GetIndexFromChild(TRUE, iPos) );
                        }

                        _pmtbTracked->PopupHelper(iItem, nCmdExecOpt & MBPUI_INITIALSELECT);
                    }
                }
            }
            break;

        case MBANDCID_ISVERTICAL:
            if (pvarargOut)
            {
                pvarargOut->vt = VT_BOOL;
                pvarargOut->boolVal = (_fVertical)? VARIANT_TRUE: VARIANT_FALSE;
            }
            break;
            
        case MBANDCID_SETICONSIZE:
            ASSERT(nCmdExecOpt == ISFBVIEWMODE_SMALLICONS || 
                nCmdExecOpt == ISFBVIEWMODE_LARGEICONS);

            _uIconSize = nCmdExecOpt;

            if (_pmtbTop)
                _pmtbTop->v_UpdateIconSize(nCmdExecOpt, TRUE);

            if (_pmtbBottom)
                _pmtbBottom->v_UpdateIconSize(nCmdExecOpt, TRUE);
            break;

        case MBANDCID_SETSTATEOBJECT:
            if (pvarargIn && VT_INT_PTR == pvarargIn->vt)
            {
                _pmbState = (CMenuBandState*)pvarargIn->byref;
            }
            break;

        case MBANDCID_ISINSUBMENU:
            if (_fInSubMenu || (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu()))
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_ISTRACKING:
            if (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu())
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_REPOSITION:

            // Don't reposition unless we're shown (Avoids artifacts onscreen of a bad positioning)
            if (_fShow)
            {
                // Don't forget to reposition US!!!
                IMenuPopup* pmdb;
                DWORD dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;

                // If we should force a reposition. This is so that we get
                // the trickle down reposition so things overlap correctly
                if (nCmdExecOpt)
                    dwFlags |= MPPF_FORCEZORDER;

                if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmdb))))
                {
                    pmdb->Popup(NULL, NULL, dwFlags);
                    pmdb->Release();
                }

                // Reposition the Tracked sub menu based on the current popped up item 
                // since this pane has now moved
                // If they have a sub menu, tell them to reposition as well.
                if (_fInSubMenu && _pmtbTracked)
                {
                    IUnknown_QueryServiceExec(_pmpSubMenu, SID_SMenuBandChild,
                    &CGID_MenuBand, MBANDCID_REPOSITION, nCmdExecOpt, NULL, NULL);
                }
                _pmbState->PutTipOnTop();
            }
            break;

        case MBANDCID_REFRESH:
            InvalidateItem(NULL, SMINV_REFRESH);
            break;
            
        case MBANDCID_EXPAND:
            if (_pmtbShellFolder)
                _pmtbShellFolder->Expand(TRUE);

            if (_pmtbMenu)
                _pmtbMenu->Expand(TRUE);
            break;

        case MBANDCID_DRAGCANCEL:
            // If one of the Sub bands in the menu heirarchy has the drag 
            // (Either because of Drag enter or because of the drop) then 
            // we do not want to cancel. 
            if (!_pmbState->HasDrag())
                _CancelMode(MPOS_FULLCANCEL);
            break;

        case MBANDCID_EXECUTE:
            ASSERT(pvarargIn != NULL);
            if (_pmtbTop && _pmtbTop->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbTop->v_ExecItem((int)nCmdExecOpt);
            else if (_pmtbBottom && _pmtbBottom->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbBottom->v_ExecItem((int)nCmdExecOpt);
            _SiteOnSelect(MPOS_EXECUTE);
            break;
        }

        // Don't bother passing CGID_MenuBand commands to CToolBand
        return S_OK;
    }     
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut);    
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
STDMETHODIMP CMenuBand::CloseDW(DWORD dw)
{
    // We don't want to destroy the band if it's cached. 
    // That means it's the caller's respocibility to Unset this bit and call CloseDW explicitly
    if (_dwFlags & SMINIT_CACHED)
        return S_OK;

    if (_pmtbMenu)
    {
        _pmtbMenu->v_Close();
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->v_Close();
    }

    if (_pmpSubMenu)
    {
        _fInSubMenu = FALSE;
        IUnknown_SetSite(_pmpSubMenu, NULL);
        ATOMICRELEASE(_pmpSubMenu);
    }

    // Since we're blowing away all of the menus,
    // Top and bottom are invalid
    _pmtbTracked = _pmtbTop = _pmtbBottom = NULL;

    // We don't want our base class to blow this window away. It belongs to someone else.
    _hwnd = NULL;
    _fClosing = TRUE;
    
    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

Notes:
    for the start menu (non-browser) case, we bracket* the top-level popup
    operation w/ a LockSetForegroundWindow so that another app can't steal
    the foreground and collapse our menu.  (nt5:172813: don't do it for
    the browser case since a) we don't want to and b) ShowDW(FALSE) isn't
    called until exit the browser so we'd be permanently locked!)
*/
STDMETHODIMP CMenuBand::ShowDW(BOOL fShow)
{   
    CMBMsgFilter* pmf = GetMessageFilter();
    // Prevent rentrancy when we're already shown.
    ASSERT((int)_fShow == BOOLIFY(_fShow));
    if ((int)_fShow == BOOLIFY(fShow))
        return NOERROR;

    HRESULT hr = SUPERCLASS::ShowDW(fShow);

    if (SUCCEEDED(hr))
    {
        if (!fShow)
        {
            _fShow = FALSE;
            if (_fTopLevel)
            {
                if (_fVertical) 
                {
                    // (_fTopLevel && _fVertical) => start menu
                    LockSetForegroundWindow(LSFW_UNLOCK);
                }
                else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
                {
                    pmf->SetHook(FALSE, TRUE);
                    pmf->SetTopMost(this);
                }

            }

            if ((_fTopLevel || _fParentIsHorizontal) && _pmbState)
            {
                // Reset to not have the drag when we collapse.
                _pmbState->HasDrag(FALSE);
                _pmbState->SetExpand(FALSE);
                _pmbState->SetUEMState(0);
            }

            hr = _CallCB(SMC_EXITMENU);
        }
        else
        {
            hr = _CallCB(SMC_INITMENU);

            _fClosing = FALSE;
            _fShow = TRUE;
            _GetFontMetrics();

            if (_fTopLevel)
            {
                // We set the context here so that the ReEngage causes the message filter
                // to start taking messages on a TopLevel::Show. This prevents a problem
                // where tracking doesn't work when switching between Favorites and Start Menu
                _pmbState->SetContext(this);
                pmf->SetContext(this, TRUE);

                pmf->ReEngage(_pmbState->GetContext());
                if (_hwndMenuOwner && _fVertical)
                    SetForegroundWindow(_hwndMenuOwner);

                if (_fVertical) 
                {
                    // (_fTopLevel && _fVertical) => start menu
                    LockSetForegroundWindow(LSFW_LOCK);
                }
                else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
                {
                    pmf->SetHook(TRUE, TRUE);
                    pmf->SetTopMost(this);
                }

                _pmbState->CreateFader();
            }
        }

        if (_pmtbShellFolder)
            _pmtbShellFolder->v_Show(_fShow, _fForceButtonUpdate);

        // Menu needs to be last so that it can update the seperator.
        if (_pmtbMenu)
            _pmtbMenu->v_Show(_fShow, _fForceButtonUpdate);

        if (_fPopupNewItemOnShow)
        {
            HWND hwnd = _pmbState ? _pmbState->GetSubclassedHWND() : NULL;

            if (hwnd || _pmtbMenu)
            {
                PostMessage(hwnd ? hwnd : _pmtbMenu->_hwndMB, g_nMBPopupOpen, 
                    _nItemNew, MAKELPARAM(TRUE, TRUE));
            }
            _fPopupNewItemOnShow = FALSE;
        }

        _fForceButtonUpdate = FALSE;
    }
    return hr;
}

void CMenuBand::_GetFontMetrics()
{
    if (_fTopLevel)
    {
        if (!_pmbm)
            _pmbm = new CMenuBandMetrics();

        if (_pmbm && _pmtbTop)
        {
            // We need only 1 HWND
            _pmbm->Init(_pmtbTop->_hwndMB);
        }
    }
    else if (!_pmbm)
    {
        AssertMsg(0, TEXT("When this menuband was created, someone forgot to set the metrics"));

        VARIANTARG vargOut;
        HRESULT hres = IUnknown_QueryServiceExec(_punkSite, SID_SMenuBandTop, &CGID_MenuBand, MBANDCID_GETFONTS, 0, NULL, &vargOut);
        if (SUCCEEDED(hres))
        {
            if (vargOut.vt == VT_UNKNOWN && vargOut.punkVal)
            {
                vargOut.punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);
            }
            VariantClear(&vargOut);
        }
    }
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the child menubar to tell us when and how
         to bail out of the menu.
*/
STDMETHODIMP CMenuBand::OnSelect(DWORD dwType)
{
    int iIndex;

    switch (dwType)
    {
    case MPOS_CHILDTRACKING:
        // this means that our child did get tracked over it, so we should abort any timeout to destroy it

        if (_pmtbTracked)
        {
            HWND hwnd = _pmtbTracked->_hwndMB;
            if (_nItemTimer) 
            {
                _pmtbTracked->KillPopupTimer();
        
                // Use the command id of the SubMenu that we actually have cascaded out.
                iIndex = ToolBar_CommandToIndex(hwnd, _nItemSubMenu);
                ToolBar_SetHotItem(hwnd, iIndex);
            }
            KillTimer(hwnd, MBTIMER_DRAGOVER);
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_SELECTLEFT:
        if (!_fVertical)
            _OnSelectArrow(-1);
        else
        {
            // Cancel the child submenu.  Hitting left arrow is like
            // hitting escape.
            _SubMenuOnSelect(MPOS_CANCELLEVEL);
        }
        break;

    case MPOS_SELECTRIGHT:
        if (!_fVertical)
            _OnSelectArrow(1);
        else
        {
            // The right arrow gets propagated up to the top, so
            // a fully cascaded menu will be cancelled and the
            // top level menuband will move to the next menu to the
            // right.
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_CANCELLEVEL:
        // Forward onto submenu
        _SubMenuOnSelect(dwType);
        break;

    case MPOS_FULLCANCEL:
    case MPOS_EXECUTE:
        DEBUG_CODE( TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): CMenuToolbarBase received %s", 
                    DBG_THIS, MPOS_FULLCANCEL == dwType ? TEXT("MPOS_FULLCANCEL") : TEXT("MPOS_EXECUTE")); )

        _CancelMode(dwType);
        break;
    }
    return S_OK;    
}    

void CMenuBand::SetTrackMenuPopup(IUnknown* punk)
{ 
    ATOMICRELEASE(_pmpTrackPopup);
    if (punk)
    {
        punk->QueryInterface(IID_PPV_ARG(IMenuPopup, &_pmpTrackPopup));
    }
}


/*----------------------------------------------------------
Purpose: Set the currently tracked toolbar.  Only one
         of the toolbars can have the "activation" at one time.
*/
BOOL CMenuBand::SetTracked(CMenuToolbarBase* pmtb)
{
    if (pmtb == _pmtbTracked)
        return FALSE;

    if (_pmtbTracked)
    {
        // Tell the existing toolbar we're leaving him
        SendMessage(_pmtbTracked->_hwndMB, TB_SETHOTITEM2, -1, HICF_LEAVING);
    }

    _pmtbTracked = pmtb;

    if (_pmtbTracked)
    {
        // This is for accessibility.
        HWND hwnd = _pmtbTracked->_hwndMB;
        int iHotItem = ToolBar_GetHotItem(hwnd);

        if (iHotItem >= 0)
        {
            // Toolbar Items are 0 based, Accessibility apps require 1 based
            NotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, 
                GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iHotItem)); 
        }
    }

    return TRUE;
}


void CMenuBand::_OnSelectArrow(int iDir)
{
    _fKeyboardSelected = TRUE;
    int iIndex;

    if (!_pmtbTracked)
    {
        if (iDir < 0)
        {
            SetTracked(_pmtbBottom);
            iIndex = ToolBar_ButtonCount(_pmtbTracked->_hwndMB) - 1;
        }
        else
        {
            SetTracked(_pmtbTop);
            iIndex = 0;
        }

        // This can happen when going to the chevron.
        if (_pmtbTracked)
            _pmtbTracked->SetHotItem(iDir, iIndex, -1, HICF_ARROWKEYS);
    }
    else
    {
        HWND hwnd = _pmtbTracked->_hwndMB;
        iIndex = ToolBar_GetHotItem(hwnd);
        int iCount = ToolBar_ButtonCount(hwnd);
    
        // Set the hot item explicitly since this is invoked by the 
        // keyboard and the mouse could be anywhere.

        // cycle iIndex by iDir (add extra iCount to avoid negative number problems
        iIndex = (iIndex + iCount + iDir) % iCount; 

        ToolBar_SetHotItem(hwnd, iIndex);
    }

    if (_pmtbTracked)
    {
        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
            GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iIndex));
    }
    _fKeyboardSelected = FALSE;
}

void CMenuBand::_CancelMode(DWORD dwType)
{
    // Tell the hosting site to cancel this level
    if (_fParentIsNotASite)
        UIActivateIO(FALSE, NULL);
    else
        _SiteOnSelect(dwType);
}    

HRESULT CMenuBand::OnPosRectChangeDB (LPRECT prc)
{
    // We want the HMENU portion to ALWAYS have the maximum allowed.
    RECT rcMenu = {0};
    SIZE sizeMenu = {0};
    SIZE sizeSF = {0};
    SIZE sizeMax;

    if (_pmtbMenu)
        _pmtbMenu->GetSize(&sizeMenu);

    if (_pmtbShellFolder)
        _pmtbShellFolder->GetSize(&sizeSF);

    if (sizeSF.cx > sizeMenu.cx)
        sizeMax = sizeSF;
    else
        sizeMax = sizeMenu;

    if (_pmtbMenu)
    {
        if (_pmtbMenu->GetFlags() & SMSET_TOP)
        {

            rcMenu.bottom = sizeMenu.cy;
            rcMenu.right = prc->right;
        }
        else
        {
            rcMenu.bottom = prc->bottom;
            rcMenu.right = prc->right;

            rcMenu.top = prc->bottom - sizeMenu.cy;
            rcMenu.left = 0;
        }

        if (RECTHEIGHT(rcMenu) > RECTHEIGHT(*prc))
        {
            rcMenu.bottom -= RECTHEIGHT(rcMenu) - RECTHEIGHT(*prc);
        }

        _pmtbMenu->SetWindowPos(&sizeMax, &rcMenu, 0);
    }

    if (_pmtbShellFolder)
    {
        RECT rc = *prc;

        if (_pmtbShellFolder->GetFlags() & SMSET_TOP)
        {
            rc.bottom = prc->bottom - RECTHEIGHT(rcMenu);
        }
        else
        {
            rc.top = prc->top + RECTHEIGHT(rcMenu);
        }

        _pmtbShellFolder->SetWindowPos(&sizeMax, &rc, 0);
    }

    return NOERROR;
}


HRESULT IUnknown_OnSelect(IUnknown* punk, DWORD dwType, REFGUID guid)
{
    HRESULT hres;
    IMenuPopup * pmp;

    hres = IUnknown_QueryService(punk, guid, IID_PPV_ARG(IMenuPopup, &pmp));
    if (SUCCEEDED(hres))
    {
        pmp->OnSelect(dwType);
        pmp->Release();
    }

    return hres;
}

HRESULT CMenuBand::_SiteOnSelect(DWORD dwType)
{
    return IUnknown_OnSelect(_punkSite, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::_SubMenuOnSelect(DWORD dwType)
{
    IMenuPopup* pmp = _pmpSubMenu;
    if (_pmpTrackPopup)
        pmp = _pmpTrackPopup;

    return IUnknown_OnSelect(pmp, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::GetTop(CMenuToolbarBase** ppmtbTop)
{
    *ppmtbTop = _pmtbTop;

    if (*ppmtbTop)
    {
        (*ppmtbTop)->AddRef();
        return NOERROR;
    }

    return E_FAIL;
}

HRESULT CMenuBand::GetBottom(CMenuToolbarBase** ppmtbBottom)
{
    *ppmtbBottom = _pmtbBottom;

    if (*ppmtbBottom)
    {
        (*ppmtbBottom)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetTracked(CMenuToolbarBase** ppmtbTracked)
{
    *ppmtbTracked = _pmtbTracked;

    if (*ppmtbTracked)
    {
        (*ppmtbTracked)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetParentSite(REFIID riid, void** ppvObj)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvObj);

    return E_FAIL;
}

HRESULT CMenuBand::GetState(BOOL* pfVertical, BOOL* pfOpen)
{
    *pfVertical = _fVertical;
    *pfOpen = _fMenuMode;
    return NOERROR;
}

HRESULT CMenuBand::DoDefaultAction(VARIANT* pvarChild)
{
    if (pvarChild->lVal != CHILDID_SELF)
    {
        CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
        int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

        SendMessage(pmtb->_hwndMB, TB_SETHOTITEM2, idCmd, HICF_OTHER | HICF_TOGGLEDROPDOWN);
    }
    else
    {
        _CancelMode(MPOS_CANCELLEVEL);
    }

    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IShellMenuAcc::GetSubMenu method
*/

HRESULT CMenuBand::GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
    int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

    *ppvObj = NULL;

    if (idCmd != -1 && pmtb)
    {
        hres = pmtb->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IShellMenu2::GetSubMenu method
*/

HRESULT CMenuBand::GetSubMenu(UINT idCmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

    if (_pmtbMenu)
    {
        hres = _pmtbMenu->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }

    if (hres == HRESULT_FROM_WIN32(ERROR_NOT_FOUND) && _pmtbShellFolder)
    {
        hres = _pmtbShellFolder->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }
    return hres;
}

HRESULT CMenuBand::SetToolbar(HWND hwnd, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMenuToolbarBase *pmtb = ToolbarMenu_Create(hwnd);
    if (pmtb)
    {
        hr = SetMenuToolbar(SAFECAST(pmtb, IWinEventHandler*), dwFlags);
        // DONT release! The menus break com identity rules because of a foobar when they were
        // initially designed.
    }
    return hr;
}

HRESULT CMenuBand::SetMinWidth(int cxMenu)
{
    if (_pmtbMenu)
    {
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        return _pmtbMenu->SetMinWidth(cxMenu);
    }
    else
        return E_FAIL;
}

HRESULT CMenuBand::SetNoBorder(BOOL fNoBorder)
{
    HRESULT hr = S_OK;

    _fNoBorder = fNoBorder;

    if (_pmtbMenu)
    {
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        hr = _pmtbMenu->SetNoBorder(fNoBorder);
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->SetNoBorder(fNoBorder);
    }

    if (_punkSite)
    {
        hr = IUnknown_QueryServiceExec(_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, MBCID_NOBORDER, fNoBorder, NULL, NULL);
    }

    return hr;
}

HRESULT CMenuBand::SetTheme(LPCWSTR pszTheme)
{
    HRESULT hr = S_OK;

    Str_SetPtr(&_pszTheme, pszTheme);

    if (_pmtbMenu)
    {
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        hr = _pmtbMenu->SetTheme(_pszTheme);
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->SetTheme(_pszTheme);
    }

    return hr;
}

HRESULT CMenuBand::IsEmpty()
{
    BOOL fReturn = TRUE;
    if (_pmtbShellFolder)
        fReturn = _pmtbShellFolder->IsEmpty();

    if (fReturn && _pmtbMenu)
        fReturn = _pmtbMenu->IsEmpty();

    return fReturn? S_OK : S_FALSE;
}


//----------------------------------------------------------------------------
// CMenuBandMetrics
//
//----------------------------------------------------------------------------


COLORREF GetLumColor(int isys, int iLumAdjust)
{
    WORD iHue;
    WORD iLum;
    WORD iSat;
    COLORREF clr = (COLORREF)GetSysColor(isys);
    HDC hdc = GetDC(NULL);

    // Office CommandBars use this same algorithm for their "intellimenus"
    // colors.  We prefer to call them "expando menus"...

    if (hdc)
    {
        int cColors = GetDeviceCaps(hdc, BITSPIXEL);
        
        ReleaseDC(NULL, hdc);
        
        switch (cColors)
        {
        case 4:     // 16 Colors
        case 8:     // 256 Colors
            // Default to using Button Face
            break;
            
        default:    // 256+ colors
            
            ColorRGBToHLS(clr, &iHue, &iLum, &iSat);
            
            if (iLum > 220)
                iLum -= iLumAdjust;
            else if (iLum <= 20)
                iLum += 2 * iLumAdjust;
            else
                iLum += iLumAdjust;
            
            clr = ColorHLSToRGB(iHue, iLum, iSat);
            break;
        }
    }
    
    return  clr;
}


ULONG CMenuBandMetrics::AddRef()
{
    return ++_cRef;
}

ULONG CMenuBandMetrics::Release()
{
    ASSERT(_cRef > 0);
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CMenuBandMetrics::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else if (IsEqualIID(riid, CLSID_MenuBandMetrics))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_FAIL;
    }

    AddRef();
    return S_OK;
}

CMenuBandMetrics::CMenuBandMetrics()
                : _cRef(1)
{
}

void CMenuBandMetrics::Init(HWND hwnd)
{
    if (_fInit)
        return;

    _SetMenuFont();
    _SetColors();

    HIGHCONTRAST hc = {sizeof(HIGHCONTRAST)};

    if (SystemParametersInfoA(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
    {
        _fHighContrastMode = (HCF_HIGHCONTRASTON & hc.dwFlags);
    }

    if (g_dwPrototype & 0x00000100)
    {
        SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(TRUE), SPIF_SENDCHANGE);
        SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(TRUE), SPIF_SENDCHANGE);
    }
    
    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&_fFlatMenuMode, 0);

    _SetArrowFont(hwnd);
    _SetChevronFont(hwnd);
#ifndef DRAWEDGE
    _SetPaintMetrics(hwnd);
#endif
    _SetTextBrush(hwnd);

    _fInit = TRUE;
}


CMenuBandMetrics::~CMenuBandMetrics()
{
    if (_hFontMenu)
        DeleteObject(_hFontMenu);

    if (_hFontArrow)
        DeleteObject(_hFontArrow);

    if (_hFontChevron)
        DeleteObject(_hFontChevron);

    if (_hbrText)
        DeleteObject(_hbrText);

#ifndef DRAWEDGE
    if (_hPenHighlight)
        DeleteObject(_hPenHighlight);

    if (_hPenShadow)
        DeleteObject(_hPenShadow);
#endif
}

HFONT CMenuBandMetrics::_CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
                                  int* pcy, int* pcxMargin, int iOrientation, int iWeight)
{
    ASSERT(hwnd);

    HFONT hFontOld, hFontRet = NULL;
    TEXTMETRIC tm;
    RECT rect={0};

    int cx = 0, cy = 0, cxM = 0;

    HDC hdc = GetDC(hwnd);

    if (hdc)
    {
        hFontOld = (HFONT)SelectObject(hdc, _hFontMenu);
        GetTextMetrics(hdc, &tm);

        // Set the font height (based on original USER code)
        cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

        // Use the menu font's avg character width as the margin.
        cxM = tm.tmAveCharWidth; // Not exactly how USER does it, but close

        // Shlwapi wraps the ansi/unicode behavior.
        hFontRet = CreateFontWrap(cy, 0, iOrientation, 0, iWeight, 0, 0, 0, dwCharSet, 0, 0, 0, 0, pszFont);
        if (TPTR(hFontRet))
        {
            // Calc width of arrow using this new font
            SelectObject(hdc, hFontRet);
            if (DrawText(hdc, &ch, 1, &rect, DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_VCENTER))
                cx = rect.right;
            else
                cx = tm.tmMaxCharWidth;
        }
        else
        {
            cx = tm.tmMaxCharWidth;
        }
    
        SelectObject(hdc, hFontOld);   
        ReleaseDC(hwnd, hdc);
    }

    *pcx = cx;
    *pcy = cy;
    *pcxMargin = cxM;
    
    return hFontRet;

}


/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetChevronFont(HWND hwnd)
{
    ASSERT(!_hFontChevron);
    TCHAR szPath[MAX_PATH];

    NONCLIENTMETRICSA ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    EVAL(SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
   
    // Obtain the font's metrics
    SHAnsiToTChar(ncm.lfMenuFont.lfFaceName, szPath, ARRAYSIZE(szPath));
    _hFontChevron = _CalcFont(hwnd, szPath, DEFAULT_CHARSET, CH_MENUARROW, &_cxChevron, &_cyChevron, 
        &_cxChevron, -900, FW_NORMAL);
}

/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetArrowFont(HWND hwnd)
{
    ASSERT(!_hFontArrow);
    ASSERT(_hFontMenu);
   
    // Obtain the font's metrics
    if (_hFontMenu)
    {
        _hFontArrow = _CalcFont(hwnd, szfnMarlett, SYMBOL_CHARSET, CH_MENUARROW, &_cxArrow, &_cyArrow, 
            &_cxMargin, 0, FW_NORMAL);
    }
    else
    {
        _cxArrow = _cyArrow = _cxMargin = 0;
    }
}

void CMenuBandMetrics::_SetMenuFont()
{
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);
    _hFontMenu = CreateFontIndirect(&ncm.lfMenuFont);
}

void CMenuBandMetrics::_SetColors()
{
    _clrBackground = GetSysColor(COLOR_MENU);
    _clrMenuText = GetSysColor(COLOR_MENUTEXT);
    _clrDemoted = GetLumColor(COLOR_MENU, 20);
    _clrMenuGrad = GetLumColor(COLOR_MENU, -20);
}


#ifndef DRAWEDGE
// Office "IntelliMenu" style
void CMenuBandMetrics::_SetPaintMetrics(HWND hwnd)
{
    DWORD dwSysHighlight = GetSysColor(COLOR_3DHIGHLIGHT);
    DWORD dwSysShadow = GetSysColor(COLOR_3DSHADOW);

    _hPenHighlight = CreatePen(PS_SOLID, 1, dwSysHighlight);
    _hPenShadow = CreatePen(PS_SOLID, 1, dwSysShadow);
}
#endif

void CMenuBandMetrics::_SetTextBrush(HWND hwnd)
{
    _hbrText = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));
}


CMenuBandState::CMenuBandState()                
{ 
    // We will default to NOT show the keyboard cues. This
    // is overridden based on the User Settings.
    _fKeyboardCue = FALSE;
}

CMenuBandState::~CMenuBandState()
{
    ATOMICRELEASE(_ptFader);

    ATOMICRELEASE(_pScheduler);

    if (IsWindow(_hwndToolTip))
        DestroyWindow(_hwndToolTip);

    if (IsWindow(_hwndWorker)) // JANK : Fix for bug #101302
        DestroyWindow(_hwndWorker);
}

int CMenuBandState::GetKeyboardCue()
{
    return _fKeyboardCue;
}

void CMenuBandState::SetKeyboardCue(BOOL fKC)
{
    _fKeyboardCue = fKC;
}

IShellTaskScheduler* CMenuBandState::GetScheduler()
{
    HRESULT hr = S_OK;
    if (!_pScheduler)
    {
        hr = CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                              IID_PPV_ARG(IShellTaskScheduler, &_pScheduler));
    }

    ASSERT((SUCCEEDED(hr) && _pScheduler) || (FAILED(hr) && !_pScheduler));

    if (SUCCEEDED(hr))
        _pScheduler->AddRef();


    return _pScheduler;
}

HRESULT CMenuBandState::FadeRect(LPCRECT prc)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    BOOL fFade = FALSE;
    SystemParametersInfo(SPI_GETSELECTIONFADE, 0, &fFade, 0);
    if (_ptFader && fFade)
    {
        hr = _ptFader->FadeRect(prc);
    }

    return hr;
}

void CMenuBandState::CreateFader()
{
    // We do this on first show, because in the Constuctor of CMenuBandState,
    // the Window classes might not be registered yet (As is the case with start menu).
    if (!_ptFader)
    {
        CoCreateInstance(CLSID_FadeTask, NULL, CLSCTX_INPROC, IID_PPV_ARG(IFadeTask, &_ptFader));
    }
}


void CMenuBandState::CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR pszTip)
{
    // Balloon style holds presidence over info tips
    if (_fTipShown && _fBalloonStyle)
        return;

    if (!_hwndToolTip)
    {
        _hwndToolTip = CreateWindow(TOOLTIPS_CLASS, NULL,
                                         WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         NULL, NULL, g_hinst,
                                         NULL);

        if (_hwndToolTip) 
        {
            // set the version so we can have non buggy mouse event forwarding
            SendMessage(_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
            SendMessage(_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)300);
        }
    }

    if (_hwndToolTip)
    {
        // Collapse the previous tip because we're going to be doing some stuff to it before displaying again.
        SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);

        // Balloon tips don't have a border, but regular tips do. Swap now...
        SHSetWindowBits(_hwndToolTip, GWL_STYLE, TTS_BALLOON | WS_BORDER, (fBalloon) ? TTS_BALLOON : WS_BORDER);

        if (pszTip && pszTip[0])
        {
            POINT   ptCursor;
            RECT    rcItemScreen, rcItemTB;
            TOOLINFO ti = {0};
            ti.cbSize = sizeof(ti);

            // This was pretty bad: I kept adding tools, but never deleteing them. Now we get rid of the current
            // one then add the new one.
            if (SendMessage(_hwndToolTip, TTM_ENUMTOOLS, 0, (LPARAM)&ti))
            {
                SendMessage(_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&ti);   // Delete the current tool.
            }

            SendMessage(hwndTB, TB_GETRECT, idCmd, (LPARAM)&rcItemScreen);
            rcItemTB = rcItemScreen;
            MapWindowPoints(hwndTB, HWND_DESKTOP, (POINT*)&rcItemScreen, 2);

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_TRANSPARENT | (fBalloon? TTF_TRACK : 0);
            
            // Check if the cursor is within the bounds of the hot item.
            // If it is, then proceed as usual.
            // If it isn't, then the hot item was activated via the keyboard, so the tooltip
            // shouldn't be hung from the cursor.  Stick it on the hot item instead.
            
            // Set the vertical offset to use later.
            // Notice the correction for the bottom: gsierra wanted it up a couple of pixels.
            int nOffset = -3;
            
            GetCursorPos(&ptCursor);
            if (!PtInRect(&rcItemScreen, ptCursor))
            {
                ti.uFlags |= TTF_TRACK;

                // Force the tool tip to track along the bottom.
                nOffset = 1;
            }

            // The tooltip won't pick up the hot item's rect right, so
            // do it manually.
            ti.rect = rcItemTB;

            SendMessage(_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG((rcItemScreen.left + rcItemScreen.right)/2, rcItemScreen.bottom + nOffset));

            ti.hwnd = hwndTB;
            ti.uId = (UINT_PTR)hwndTB;
            SendMessage(_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);

            ti.lpszText = pszTip;
            SendMessage(_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

            SendMessage(_hwndToolTip, TTM_SETTITLE, TTI_INFO, (LPARAM)pszTitle);

            SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                         0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
            _fTipShown = TRUE;
            _fBalloonStyle = fBalloon;
        }
    }

}

void CMenuBandState::HideTooltip(BOOL fAllowBalloonCollapse)
{
    if (_hwndToolTip && _fTipShown)
    {
        // Now we're going to latch the Balloon style. The rest of menuband blindly
        // collapses the tooltip when selection changes. Here's where we say "Don't collapse
        // the chevron balloon tip because of a selection change."
        if ((_fBalloonStyle && fAllowBalloonCollapse) || !_fBalloonStyle)
        {
            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);
            _fTipShown = FALSE;
        }
    }
}

void CMenuBandState::PutTipOnTop()
{
    // Force the tooltip to the topmost.
    if (_hwndToolTip)
    {
        SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    }
}

HWND CMenuBandState::GetWorkerWindow(HWND hwndParent)
{
    if (!_hwndSubclassed)
        return NULL;

    if (!_hwndWorker)
    {
        // We need a worker window, so that dialogs show up on top of our menus.
        // HiddenWndProc is included from sftbar.h
        _hwndWorker = SHCreateWorkerWindow(HiddenWndProc, _hwndSubclassed, 
            WS_EX_TOOLWINDOW, WS_POPUP, 0, (void*)_hwndSubclassed);
    }

    //hwndParent is unused at this time. I plan on using it to prevent the parenting to the subclassed window.

    return _hwndWorker;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menuband.h ===
#ifndef _MENUBAND_H_
#define _MENUBAND_H_

#include "bands.h"
#include "mnbase.h"

#include "legacy.h"

// Flags for MBANDCID_POPUPITEM

#define MBPUI_SETITEM           0x00001
#define MBPUI_INITIALSELECT     0x00002
#define MBPUI_ITEMBYPOS      0x00004

#ifdef STARTMENUSPLIT
// Flags for constructor
#define MENUBAND_HORIZ      0x00000001
#define MENUBAND_TOPLEVEL   0x00000002
#endif

// Special indices for MBANDCID_SELECTITEM
#define MBSI_FIRSTITEM       0
#define MBSI_NONE           -1
#define MBSI_LASTITEM       -2

// This arrow is used when we are in Right-To-Left Mirror mode
#define CH_MENUARROWRTLA '3'

// Forward declare
struct CMBMsgFilter;

// Define this to get Shell Expando menu style
// Undefine to get "Office IntelliMenu" style
//#define DRAWEDGE

// The CMenuBand class handles all menu behavior for bands.  

class CMenuBandMetrics : public IUnknown
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HFONT   _CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
        int* pcy, int* pcxMargin, int iOrientation, int iWeight);
    void    _SetMenuFont();         // (Called for TopLevMBand only) Sets: _hFontMenu
    void    _SetArrowFont(HWND hwnd);        // (Called for TopLevMBand only) Sets: _hFontArrow, _cyArrow
    void    _SetChevronFont(HWND hwnd);
    void    _SetTextBrush(HWND hwnd);

#ifndef DRAWEDGE
    void    _SetPaintMetrics(HWND hwnd);
#endif
    void    _SetColors();
    int     _cyArrow;               // Height of cascade arrow
    int     _cxArrow;               // Width of cascade arrow
    int     _cxMargin;              // Margin b/t text and arrow
    int     _cyChevron;
    int     _cxChevron;
    int     _cxChevronMargin;
    HCURSOR _hCursorOld;            // Cursor that was in use prior to entering menu mode
    HFONT   _hFontMenu;             // Font for menu text
    HFONT   _hFontArrow;            // Correct sized Marlett font for cascade arrow
    HFONT   _hFontChevron;
    HBRUSH  _hbrText;
#ifndef DRAWEDGE
    HPEN    _hPenHighlight;            // Pen for BTNHIGHLIGHT
    HPEN    _hPenShadow;               // Pen for BTNSHADOW
#endif

    COLORREF _clrBackground;
    COLORREF _clrDemoted;
    COLORREF _clrMenuText;
    COLORREF _clrMenuGrad;

    BOOL  _fHighContrastMode;        // Accessibility
    BOOL  _fFlatMenuMode;
    BOOL  _fInit;

    CMenuBandMetrics();
    void Init(HWND hwnd);

private:
    ~CMenuBandMetrics();

    ULONG _cRef;
};


class CMenuBandState
{

    // Global State Variables
    BYTE    _fsUEMState;
    BOOL    _fKeyboardCue;
    IFadeTask* _ptFader;
    IShellTaskScheduler* _pScheduler;
    HWND    _hwndSubclassed;
    HWND    _hwndToolTip;
    HWND    _hwndWorker;
    void*   _pvContext;

    // Bits
    BITBOOL _fExpand: 1;
    BITBOOL _fContainsDrag: 1;
    BITBOOL _fTipShown: 1;
    BITBOOL _fBalloonStyle: 1;

    int     _cChangeNotify;

    // This will, in the future, contain the menuband stack
public:
    CMenuBandState();
    virtual ~CMenuBandState();

    // Set/Get the expand state for new popups.
    BOOL GetExpand()                { return (BOOL)_fExpand;      };
    void SetExpand(BOOL fExpand)    { _fExpand = BOOLIFY(fExpand);};
    BYTE GetUEMState()              { return _fsUEMState;         };
    void SetUEMState(BYTE bState)   { _fsUEMState = bState;       };
    BOOL GetKeyboardCue();
    void SetKeyboardCue(int iKC);
    BOOL HasDrag()                  { return _fContainsDrag;      };
    void HasDrag(BOOL fHasDrag)     { _fContainsDrag = BOOLIFY(fHasDrag); };
    void SetSubclassedHWND(HWND hwndSubclassed)   
                                    { _hwndSubclassed = hwndSubclassed; };
    HWND GetSubclassedHWND()        { return _hwndSubclassed; };
    HWND GetWorkerWindow(HWND hwndParent);
    void PushChangeNotify()         { ++_cChangeNotify; };
    void PopChangeNotify()          { --_cChangeNotify; };
    BOOL IsProcessingChangeNotify() { return _cChangeNotify != 0;   };

    // Context Stuff
    // a menuband context is used for the global message filter. Since we may have
    // more than one menu present in the system, there is a race condition that can occur
    // where the menu in one thread tries to pop off it's menus, when a menuband in another thread
    // tries to push them on. Through the use of a context, we can know when this is happening and
    // make sure that we pop all of the menus of one context before pushing from another.
    // - lamadio 9.15.98
    void SetContext(void* pvContext)    {_pvContext = pvContext;};
    void* GetContext()                  { return _pvContext;};

    // Fade Stuff
    HRESULT FadeRect(LPCRECT prc);
    void CreateFader();
    IShellTaskScheduler* GetScheduler();

    // Chevron Tip Stuff
    void CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR szTip);
    void HideTooltip(BOOL fAllowBalloonCollapse);
    void PutTipOnTop();
};



interface IShellMenuAcc: public IUnknown
{
    // *** IShellMenuAcc methods ***
    STDMETHOD(GetTop)(THIS_ CMenuToolbarBase** ppmtbTop) PURE;
    STDMETHOD(GetBottom)(THIS_ CMenuToolbarBase** ppmtbBottom) PURE;
    STDMETHOD(GetTracked)(THIS_ CMenuToolbarBase** ppmtbTracked) PURE;
    STDMETHOD(GetParentSite)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD(GetState)(THIS_ BOOL* pfVertical, BOOL* pfOpen) PURE;
    STDMETHOD(DoDefaultAction)(THIS_ VARIANT* pvarChild) PURE;
    STDMETHOD(GetSubMenu)(THIS_ VARIANT* pvarChild, REFIID riid, void** ppvObj) PURE;
    STDMETHOD(IsEmpty)() PURE;
};

// {FAF6FE96-CE5E-11d1-8371-00C04FD918D0}
DEFINE_GUID(IID_IShellMenuAcc,              0xfaf6fe96, 0xce5e, 0x11d1, 0x83, 0x71, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);



class CMenuBand : public CToolBand,
                  public IMenuPopup,
                  public IMenuBand,
                  public IShellMenu2,
                  public IWinEventHandler,
                  public IShellMenuAcc
{
    // REVIEW (lamadio): I don't like this. Should I make these nested classes?
    friend class CMenuToolbarBase;
    friend class CMenuSFToolbar;
    friend class CMenuStaticToolbar;
    friend class CToolbarMenu;
    friend struct CMBMsgFilter;

public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);
    
    // *** IInputObject methods (override) ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient) { return E_NOTIMPL; };
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) { return E_NOTIMPL; };

    // *** IMenuBand methods ***
    virtual STDMETHODIMP IsMenuMessage(MSG * pmsg);
    virtual STDMETHODIMP TranslateMenuMessage(MSG * pmsg, LRESULT * plRet);

    // *** IShellMenu methods ***
    virtual STDMETHODIMP Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    virtual STDMETHODIMP GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags);
    virtual STDMETHODIMP SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags);
    virtual STDMETHODIMP GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual STDMETHODIMP InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual STDMETHODIMP GetState(LPSMDATA psmd);
    virtual STDMETHODIMP SetMenuToolbar(IUnknown* punk, DWORD dwFlags);

    // *** IShellMenu2 methods ***
    virtual STDMETHODIMP GetSubMenu(UINT idCmd, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetToolbar(HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP SetMinWidth(int cxMenu);
    virtual STDMETHODIMP SetNoBorder(BOOL fNoBorder);
    virtual STDMETHODIMP SetTheme(LPCWSTR pszTheme);

    // ** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Load(IStream*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Save(IStream*, BOOL) { return E_NOTIMPL; };

    // ** IWinEventHandler ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);


    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // *** IShellMenuAcc ***
    virtual STDMETHODIMP GetTop(CMenuToolbarBase** ppmtbTop);
    virtual STDMETHODIMP GetBottom(CMenuToolbarBase** ppmtbBottom);
    virtual STDMETHODIMP GetTracked(CMenuToolbarBase** ppmtbTracked);
    virtual STDMETHODIMP GetParentSite(REFIID riid, void** ppvObj);
    virtual STDMETHODIMP GetState(BOOL* pfVertical, BOOL* pfOpen);
    virtual STDMETHODIMP DoDefaultAction(VARIANT* pvarChild);
    virtual STDMETHODIMP GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP IsEmpty();
    
    // Other methods
    LRESULT GetMsgFilterCB(MSG * pmsg, BOOL bRemove);
    inline BOOL IsInSubMenu(void)       { return _fInSubMenu; };
    inline DWORD GetFlags()   {return _dwFlags; };
    
    // Other public methods
    void    ResizeMenuBar();        // Make our parent menubar resize
    void    SetTrackMenuPopup(IUnknown* punk);
    HRESULT ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);   // Change notify Forwarder.

    CMenuBand();


    BOOL    SetTracked(CMenuToolbarBase* pmtb);

private:

    friend HRESULT CMenuBand_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);
    friend VOID CALLBACK CMenuBand_TimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );
    friend CMenuBand * CMenuBand_Create(IShellFolder* psf, LPCITEMIDLIST pidl,
                             BOOL bHorizontal);


    virtual ~CMenuBand();

    HRESULT _Initialize(DWORD dwFlags);// Flags are MENUBAND_*

    HRESULT _EnterMenuMode(void);
    void    _ExitMenuMode(void);
    void    _GetFontMetrics();      // (Called for non-TopLevelMBands) Uses IUnk_QS to set
                                    //  _hFontMenu, _hFontArrow, _cyArrow based on TopLevel's values
    void    _CancelMode(DWORD dwType);
    HRESULT _AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags);
    HRESULT _SiteOnSelect(DWORD dwType);
    HRESULT _SubMenuOnSelect(DWORD dwType);

    HRESULT _OnSysChar(MSG * pmsg, BOOL bFirstDibs);
    HRESULT _HandleAccelerators(MSG * pmsg);

    HRESULT _SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet);

    void    _OnSelectArrow(int iDir);
    void    _UpdateButtons();

    HRESULT _CallCB(DWORD dwMsg, WPARAM wParam = 0, LPARAM lParam = 0);
    HRESULT _ProcessMenuPaneMessages(MSG* pmsg);

    
    // Member variables
    int     _nItemCur;              // Current item selected
    int     _nItemNew;              // New item to be selected/expanded
    int     _nItemTimer;            // the timer id for popping up cascading menus
    int     _nItemMove;             // Current item being moved
    int     _nItemSubMenu;          // item that's cascaded
    HWND    _hwndFocusPrev;
    HWND    _hwndParent;
    BOOL    _fNoBorder;
    WCHAR*  _pszTheme;

    CMenuToolbarBase*   _pmtbMenu;          // The static menu toolbar 
                                            //  (may be pmtbTop or pmtbBottom)
    CMenuToolbarBase*   _pmtbShellFolder;   // Non-menu toolbar (shellfolder or other)
                                            //  (may be pmtbTop or pmtbBottom)
    
    CMenuToolbarBase*   _pmtbTop;           // The top toolbar
    CMenuToolbarBase*   _pmtbBottom;        // The bottom toolbar (may be == pmtbTop)
    CMenuToolbarBase*   _pmtbTracked;       // This is transient, may be pmtbTop or pmtbBottom

    IAugmentedShellFolder2* _pasf2;

    UINT    _uId;       // Id of this band (Derived from the item that poped it up)
    UINT    _uIdAncestor;   // Id of the top most menu item.
    HMENU   _hmenu;
    HWND    _hwndMenuOwner;
    DWORD   _dwMenuFlags;


    CMenuBandState*     _pmbState;              // Menu Band global state
    CMenuBandMetrics*   _pmbm;
    IShellMenuCallback* _psmcb;             // Callback Mechanism
    HCURSOR             _hCursorOld;
    DWORD               _dwFlags;
    UINT                _uIconSize;

    IMenuPopup*         _pmpSubMenu;        // Cached submenu
    IMenuPopup*         _pmpTrackPopup;     // Find a way to use only menubands.

    void*               _pvUserData;        // User associated data.


    BITBOOL _fTopLevel: 1;          // TRUE: this is the toplevel parent menu
                                    //       (may be vertical for context menus)
    BITBOOL _fMenuMode: 1;          // TRUE: we are in menu mode
    BITBOOL _fPopupNewMenu: 1;      // TRUE: popup a new menu (_nItemNew) 
                                    //    once done with current menu
    BITBOOL _fInitialSelect: 1;     // TRUE: select first item when popping up submenu
    BITBOOL _fInSubMenu: 1;         // TRUE: currently in a submenu
    BITBOOL _fAltSpace: 1;          // TRUE: Alt-space was hit
    BITBOOL _fMenuFontCreated: 1;   // TRUE: This instance created the font and should delete it
    BITBOOL _fArrowFontCreated: 1;  // TRUE: This instance created the font and should delete it
    BITBOOL _fEmpty: 1;             // TRUE: Menu is empty
    BITBOOL _fParentIsNotASite: 1;  
    BITBOOL _fKeyboardSelected: 1;  
    BITBOOL _fInvokedByDrag: 1;     // TRUE: the menu cascaded open b/c of drag/drop
    BITBOOL _fDragEntered : 1;
    BITBOOL _fSysCharHandled: 1;    // TRUE: WM_SYSCHAR was already handled
    BITBOOL _fHasSubMenu:1;
    BITBOOL _fAppActive:1;       // TRUE: The Menus should be drawn using Memphis' grey menu.
    BITBOOL _fVertical: 1;
    BITBOOL _fShow : 1;
    BITBOOL _fClosing: 1;           // TRUE: When CloseDW is called.
    BITBOOL _fForceButtonUpdate: 1; // TRUE: Force a v_UpdateButtons.
    BITBOOL _fProcessingDup: 1;     // TRUE: when the contained classes are processing Dup chars.
    BITBOOL _fExpanded: 1;          // TRUE: This band is expanded
    BITBOOL _fCascadeAnimate: 1;
    BITBOOL _fPopupNewItemOnShow: 1;    // Causes _nItemNew to be displayed at ShowDW time.
    BITBOOL _fParentIsHorizontal: 1;

#ifdef DEBUG
    BITBOOL _fInitialized: 1;
#endif
    

    DEBUG_CODE( int _nMenuLevel; )
};

int MsgFilter_GetCount();
HRESULT IUnknown_BandChildSetKey(IUnknown* punk, HKEY hKey);

// The message filter redirects messages to the menuband
// that is at the top of the stack.  Each additional cascade
// pushes the new menuband onto the stack, and a cancel-level
// pops one off.
typedef struct tagMBELEM
{
    CMenuBand * pmb;
    HWND        hwndTB;
    HWND        hwndBar;
    RECT        rc;             // rect of hwndBar
    BITBOOL     bInitRect: 1;   // TRUE: rc is initialized
} MBELEM;

#define CMBELEM_INIT    10
#define CMBELEM_GROW    10

struct CMBMsgFilter
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndCapture;
    FDSA        _fdsa;              // Stack
    MBELEM      _rgmbelem[CMBELEM_INIT];
    BITBOOL     _fPreventCapture : 1;
    BITBOOL     _fInitialized: 1;
    BITBOOL     _fSetAtPush: 1;
    BITBOOL     _fDontIgnoreSysChar: 1;
    BITBOOL     _fEngaged: 1;
    BITBOOL     _fModal: 1;
    BITBOOL     _fAllocated: 1;
    POINT       _ptLastMove;
    CMenuBand*  _pmb;
    int         _iSysCharStack;
    void*       _pvContext;
    HCURSOR     _hcurArrow;
    int         _cRef;

    DEBUG_CODE( int _nMenuLevel; )
    void    AddRef();
    void    Release();


    void    ForceModalCollapse();
    void    SetModal(BOOL fModal);      // This is so that
                                        // a modal message band (Links)
                                        // sets activation correctly.
    void*   GetContext()    {   return _pvContext;  };
    void    SetContext(void* pvContext, BOOL fSet);
    void    Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite);
    int     Pop(void* pvContext);
    void    RetakeCapture(void);
    void    AcquireMouseLocation()   { GetCursorPos(&_ptLastMove); };


    void    ReEngage(void* pvContext);
    void    DisEngage(void* pvContext);
    BOOL    IsEngaged()  { return _fEngaged;};

    CMenuBand * _GetBottomMostSelected(void);
    CMenuBand * _GetTopPtr(void);
    CMenuBand * _GetWindowOwnerPtr(HWND hwnd);
    CMenuBand * _HitTest(POINT pt, HWND * phwnd = NULL);
    LRESULT     _HandleMouseMsgs(MSG * pmsg, BOOL bRemove);
    HRESULT     _TopFilterMouseMessage(MSG *pmsg, BOOL bRemove, CMenuBand *pmbTarget);
    int         GetCount();
    void        PreventCapture(BOOL bSet) { _fPreventCapture = BOOLIFY(bSet); }
    CMenuBand * GetTopMostPtr(void)         { return _pmb; };
    void        SetTopMost(CMenuBand* pmb)  {_pmb = pmb; };
    void        SetHook(BOOL fSet, BOOL fIgnoreSysChar); 

    static LRESULT CALLBACK GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
};

CMBMsgFilter* GetMessageFilter();


extern CMBMsgFilter g_msgfilter;
extern UINT    g_nMBPopupOpen;
extern UINT    g_nMBFullCancel;
extern UINT    g_nMBDragCancel;
extern UINT    g_nMBAutomation;
extern UINT    g_nMBExecute;
extern UINT    g_nMBOpenChevronMenu;


#define MBTIMER_POPOUT      0x00008001         // event ID for popout menu timer
#define MBTIMER_DRAGOVER    0x00008002         // event ID for popout menu timer
#define MBTIMER_EXPAND      0x00008003
#define MBTIMER_TIMEOUT     (GetDoubleClickTime() * 4 / 5) // same formula that USER uses

#define MBTIMER_ENDEDIT     0x00008004
#define MBTIMER_ENDEDITTIME 1000

#define MBTIMER_CLOSE       0x00008005
#define MBTIMER_CLOSETIME   2000

#define MBTIMER_CLICKUNHANDLE 0x00008006

// Flashing Support
#define MBTIMER_FLASH       0x00008007
#define MBTIMER_FLASHTIME   100
#define COUNT_ENDFLASH      8

// UEM Profiling.
#define MBTIMER_UEMTIMEOUT  0x00008008

#define MBTIMER_DRAGPOPDOWN 0x00008009
#define MBTIMER_DRAGPOPDOWNTIMEOUT     (2 * GetDoubleClickTime()) //ASSERT(MBTIMER_DRAGPOPDOWNTIMEOUT > 
                                                        // MBTIMER_TIMEOUR)

#define MBTIMER_CHEVRONTIP  0x0000800A

#define MBTIMER_INFOTIP     0x0000800B
#define CH_RETURN       0xd

#define szfnMarlett     TEXT("MARLETT")

#endif  // _MENUBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\legacy.h ===
#ifndef __LEGACY_H__
#define __LEGACY_H__

#include "logo.h"

#define CGID_MenuBand CLSID_MenuBand
#define CGID_ISFBand  CLSID_ISFBand
#define SID_SDropBlocker CLSID_SearchBand


// REARCHITECT: An exercise for the reader, how many of these are unused now?
#define MBANDCID_GETFONTS       1       // Command Id for getting font info
#define MBANDCID_RECAPTURE      2       // Take the mouse capture back
#define MBANDCID_NOTAREALSITE   3       // This is not a real site
#define MBANDCID_SELECTITEM     5       // Select an item
#define MBANDCID_POPUPITEM      6       // Popup an item
#define MBANDCID_ITEMDROPPED    7       // Item was dropped into a menu
#define MBANDCID_DRAGENTER      8       // Entering a drag operation
#define MBANDCID_DRAGLEAVE      9       // Leaving a Drag operation
#define MBANDCID_ISVERTICAL     10      // Is this a vertical band
#define MBANDCID_RESTRICT_CM    11      // Disallow ContextMenu
#define MBANDCID_RESTRICT_DND   12      // Disallow Drag And Drop
#define MBANDCID_EXITMENU       13      // Nofity: Exiting Menu
#define MBANDCID_ENTERMENU      14      // Notify: Entering Menu
#define MBANDCID_SETACCTITLE    15      // Sets the title of the band
#define MBANDCID_SETICONSIZE    16
#define MBANDCID_SETFONTS       17
#define MBANDCID_SETSTATEOBJECT 18      // Sets the global state
#define MBANDCID_ISINSUBMENU    19      // Returns S_OK if in submenu, S_FALSE if not.
#define MBANDCID_EXPAND         20      // Cause this band to expand
#define MBANDCID_KEYBOARD       21      // Popuped up because of a keyboard action
#define MBANDCID_DRAGCANCEL     22      // Close menus because of drag
#define MBANDCID_REPOSITION     23      // 
#define MBANDCID_EXECUTE        24      // sent to the site when somethis is executed.
#define MBANDCID_ISTRACKING     25      // Tracking a Context Menu

HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags);

class CISFBand;
HRESULT CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

typedef enum {
    ISFBID_PRIVATEID        = 1,
    ISFBID_ISITEMVISIBLE    = 2,
    ISFBID_CACHEPOPUP       = 3,
    ISFBID_GETORDERSTREAM   = 4,
    ISFBID_SETORDERSTREAM   = 5,
} ISFBID_FLAGS;

HRESULT CLogoExtractImageTask_Create( CLogoBase* plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

#define EITF_SAVEBITMAP     0x00000001  // do not delete bitmap on destructor
#define EITF_ALWAYSCALL     0x00000002  // always call the update whether extract succeded or not

extern long g_lMenuPopupTimeout;

#define QLCMD_SINGLELINE 1

#define CITIDM_VIEWTOOLS     4      // This toggles on/off
#define CITIDM_VIEWADDRESS   5      // This toggles on/off
#define CITIDM_VIEWLINKS     6      // This toggles on/off
#define CITIDM_SHOWTOOLS     7      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWADDRESS   8      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWLINKS     9      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_EDITPAGE      10
#define CITIDM_BRANDSIZE     11     // brand at minimum always or not
#define CITIDM_VIEWMENU      12      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_VIEWAUTOHIDE  13      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_GETMINROWHEIGHT 14    // gets the minimum height of row 0... for branding
#define CITIDM_SHOWMENU      15
#define CITIDM_STATUSCHANGED 16
#define CITIDM_GETDEFAULTBRANDCOLOR 17
#define CITIDM_DISABLESHOWMENU      18
#define CITIDM_SET_DIRTYBIT         19  // nCmdexecopt equals TRUE or FALSE which will overwrite _fDirty.
#define CITIDM_VIEWTOOLBARCUSTOMIZE       20
#define CITIDM_VIEWEXTERNALBAND_BYCLASSID 21
#define CITIDM_DISABLEVISIBILITYSAVE 22 // bands can choose not to persist their visibility state
#define CITIDM_GETFOLDERSEARCHES        26


#define TOOLBAR_MASK 0x80000000

#endif // __LEGACY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menubar.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "basebar.h"
#include "bands.h"
#include "menubar.h"
#include "menuband.h"
#include "isfband.h"
#include "util.h"
#include "apithk.h"

#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "oleacc.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#define THISCLASS CMenuDeskBar
#define SUPERCLASS CBaseBar


// Don't fade the menu if it's larger than this magical number. Based on experiments
// on a Pentium II - 233
#define MAGICAL_NO_FADE_HEIGHT  600

// For TraceMsg
#define DM_POPUP   DM_TRACE

#define UP    0
#define DOWN  1
#define LEFT  2
#define RIGHT 3

#ifdef ENABLE_CHANNELS
IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidl);
#endif  // ENABLE_CHANNELS

STDAPI CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv)
{
    // aggregation checking is handled in class factory
    HRESULT hr = E_OUTOFMEMORY;

    CMenuDeskBar *pwbar = new CMenuDeskBar();
    if (pwbar)
    {
        hr = pwbar->QueryInterface(riid, ppv);
        pwbar->Release();
    }

    return hr;
}


CMenuDeskBar::CMenuDeskBar() : SUPERCLASS()
{
    _dwMode = DBIF_VIEWMODE_VERTICAL; 
    
    _iIconSize = BMICON_SMALL;
}

CMenuDeskBar::~CMenuDeskBar()
{
    SetSite(NULL);
}


STDMETHODIMP CMenuDeskBar::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IMenuPopup),
        QITABENT(THISCLASS, IObjectWithSite),
        QITABENT(THISCLASS, IBanneredBar),
        QITABENT(THISCLASS, IInitializeObject),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubmenu method

*/
STDMETHODIMP CMenuDeskBar::SetSubMenu(IMenuPopup* pmp, BOOL fSet)
{
    if (fSet)
    {
        if (_pmpChild)
            _pmpChild->Release();
        
        _pmpChild = pmp;
        _pmpChild->AddRef();    
    }
    else
    {
        if (_pmpChild && SHIsSameObject(pmp, _pmpChild))
        {
            _pmpChild->Release();
            _pmpChild = NULL;
        }
    }
    return S_OK;
}


void CMenuDeskBar::_PopDown()
{
    DAD_ShowDragImage(FALSE);
    if (_pmpChild)
        _pmpChild->OnSelect(MPOS_CANCELLEVEL);
    
//    ShowWindow(_hwnd, SW_HIDE);
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);
    ShowDW(FALSE);
    if (_pmpParent)
    {
        _pmpParent->SetSubMenu(this, FALSE);
    }
    UIActivateIO(FALSE, NULL);
    _fActive = FALSE;
    DAD_ShowDragImage(TRUE);
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

*/
STDMETHODIMP CMenuDeskBar::OnSelect(DWORD dwSelectType)
{
    switch (dwSelectType)
    {
    case MPOS_CHILDTRACKING:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;
        
    case MPOS_SELECTRIGHT:
    case MPOS_SELECTLEFT:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_EXECUTE:
    case MPOS_FULLCANCEL:
        _PopDown();
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_CANCELLEVEL:
        _PopDown();
        break;
        
    }
    
    return S_OK;
} 

void SetExpandedBorder(HWND hwnd, BOOL fExpanded)
{
#ifdef MAINWIN
    // IEUNIX : WS_DLGFRAME implementaion looks ugly on UNIX.
    fExpanded = TRUE;
#endif

    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

    if (fExpanded)
    {
        dwStyle |= WS_BORDER;
        dwStyle &= ~WS_DLGFRAME;
    }
    else
    {
        dwStyle &= ~WS_BORDER;
        dwStyle |= WS_DLGFRAME;
    }

    SetWindowLong(hwnd, GWL_STYLE, dwStyle);
    SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);

    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
        SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
    UpdateWindow(hwnd);
}

void CMenuDeskBar::_OnCreate()
{
    if (!_fFlatMenuMode)
        SetExpandedBorder(_hwnd, _fExpanded);
}


DWORD CMenuDeskBar::_GetClassStyle()
{
    DWORD dwStyle = CS_SAVEBITS; // Faster repaint for menus when they go away
    
    if (IsOS(OS_WHISTLERORGREATER))
    {
        dwStyle |= CS_DROPSHADOW;   // Cool dropshadow effect on whistler....
    }

    return dwStyle;
}

DWORD CMenuDeskBar::_GetExStyle()
{
#ifndef MAINWIN
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
#else
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_MW_UNMANAGED_WINDOW;
#endif
}

// We use the following structure to pass a whole bunch of information from 
// the GetPopupWindowPosition to WillFit function. We have WillFit function 
// to cut the amount of duplicate code in getpopup window position. The order 
// in which different the sides are checked is the only difference for popping 
// up a window on a particular side.
//
// Having this function helps us to do that check by means of a parameter instead 
// of repeating portions of code again and again.

typedef struct  {
    RECT rcAvail;           // Available dimensions b/t monitor edge and exclude edge
    SIZE sizeAdjust;          // Size of menu edge
    int  cyMonitor;         // Size of monitor 
    int  cxMonitor;
    int  cx;                // Size of menu
    int  cy;
    int  cyExtendDiff;      // Difference b/t calc'd size and available size
    RECT *prcResult;
    RECT *prcExclude;       // Exclude rect
    RECT *prcMonitor;
} PopupInfo;

#define TOP     0
#define BOTTOM  1
#define LEFT    2
#define RIGHT   3 

/*----------------------------------------------------------
Purpose: Attempt to fit and position a menu in the given direction
         relative to an exclude rect.

         Setting fForce to TRUE will cause the menu size to be adjusted
         to fit, if necessary.

         This function only sets the top and left coords, not the bottom
         and right coords.
         
         Returns TRUE if the desired direction can be accomplished.

*/
BOOL WillFit(PopupInfo * pinfo, int side, BOOL fForce)
{
    BOOL bRet = FALSE;
    LPRECT prcResult = pinfo->prcResult;
    
    pinfo->cyExtendDiff = 0;
    
    switch(side)
    {
    case TOP:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.top;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    

            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;    
        }

        // Can the menu be positioned above?
        if (pinfo->cy <= pinfo->rcAvail.top)
        {
            // Yes
            prcResult->top  = pinfo->prcExclude->top - pinfo->cy;
            
            goto AdjustHorzPos;
        }
        break;
        
    case BOTTOM:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.bottom;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    
            
            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;
        }

        // Can the menu be positioned below?
        if (pinfo->cy <= pinfo->rcAvail.bottom)
        {
            // Yes
            prcResult->top = pinfo->prcExclude->bottom;

AdjustHorzPos:            
            prcResult->left = max(pinfo->prcExclude->left, pinfo->prcMonitor->left);

            // Can the menu be positioned relative to its left edge (hanging right)?
            if (prcResult->left + pinfo->cx >= pinfo->prcMonitor->right)
            {
                // No; move it in so it is on the screen
                //  (cx has already been adjusted to fit inside the monitor dimensions)
                prcResult->left = pinfo->prcMonitor->right - pinfo->cx - 1;
            }
            bRet = TRUE;
        }
        break;
        
    case LEFT:
        // Can the menu be positioned to the left?
        if (pinfo->cx <= pinfo->rcAvail.left || fForce)
        {
            // Yes
            
            // When cascading left, the menu does not overlap.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->left - pinfo->cx - 1;

            goto AdjustVerticalPos;
        }
        break;

    case RIGHT:
        // Can the menu be positioned to the right?
        if (pinfo->cx  <=  pinfo->rcAvail.right || fForce)
        {
            // Yes
            
            // Adjust the menu to slightly overlap the parent menu.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->right - pinfo->sizeAdjust.cx;

AdjustVerticalPos:            
            prcResult->top = pinfo->prcExclude->top - pinfo->sizeAdjust.cy;

            // Can the menu be positioned relative to its top edge (hanging down)?
            if (prcResult->top + pinfo->cy >= pinfo->prcMonitor->bottom)
            {
                // No; can it be positioned relative to its bottom edge (hanging up)?
                prcResult->top = pinfo->prcExclude->bottom + pinfo->sizeAdjust.cy - pinfo->cy;
                
                if (prcResult->top < pinfo->prcMonitor->top)
                {
                    // No; move the menu so it fits, but isn't vertically snapped.
                    //  (cy has already been adjusted to fit inside the monitor
                    //  dimensions)
                    prcResult->top = pinfo->prcMonitor->bottom - pinfo->cy - 1;
                }
            }
            
            bRet = TRUE;

        }
        break;
    }
    return bRet;

}


void CMenuDeskBar::_GetPopupWindowPosition(RECT* prcDesired, RECT* prcExclude, 
                                           RECT *prcResult, SIZE * psizeAdjust, UINT uSide) 
{
    PopupInfo info;
    MONITORINFO mi;
    HMONITOR hMonitor;
    RECT rcMonitor;
    int cyExtendDiff = 0;

    // Is this going to display the banner bitmap?
    if (_iIconSize == BMICON_LARGE)
    {
        // Yes; add that to the dimensions
        prcDesired->right += _sizeBmp.cx;
    }

    // First get the monitor information
    hMonitor = MonitorFromRect(prcExclude, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    if (GetMonitorInfo(hMonitor, &mi))
    {
        rcMonitor = mi.rcMonitor;

        // Set the result rectangle same as the desired window
        prcResult->left = prcDesired->left;
        prcResult->top  = prcDesired->top;

        // Calculate some sizes needed for calculation
        info.rcAvail.left   = prcExclude->left - rcMonitor.left;
        info.rcAvail.right  = rcMonitor.right - prcExclude->right;
        info.rcAvail.top    = prcExclude->top - rcMonitor.top;
        info.rcAvail.bottom = rcMonitor.bottom - prcExclude->bottom;

        info.sizeAdjust = *psizeAdjust;
    
        info.cyMonitor = RECTHEIGHT(rcMonitor); 
        info.cxMonitor = RECTWIDTH(rcMonitor);

        info.cx  = RECTWIDTH(*prcDesired);
        info.cy = RECTHEIGHT(*prcDesired);

        // If the desired rect is bigger than monitor then clip it to the monitor size
        if (info.cy > info.cyMonitor)
            info.cy = info.cyMonitor;

        if (info.cx > info.cxMonitor)
            info.cx = info.cxMonitor;

        info.prcResult = prcResult;
        info.prcExclude = prcExclude;
        info.prcMonitor = &rcMonitor;

        //Now Adjust the rectangle for the correct position
        switch(uSide)
        {
        int iSide;

        case MENUBAR_TOP:
    
            if (WillFit(&info, TOP, FALSE))
            {
                _uSide = MENUBAR_TOP;
            }
            else 
            {
                // We couldn't fit it above, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, BOTTOM, FALSE))
                    _uSide = MENUBAR_BOTTOM;
                // We can't fit it below either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
            }
            break;

        case MENUBAR_BOTTOM:
    
            if (WillFit(&info, BOTTOM, FALSE))
            {
                _uSide = MENUBAR_BOTTOM;
            }
            else
            {   
                // We couldn't fit it below, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, TOP, FALSE))
                    _uSide = MENUBAR_TOP;

                // We can't fit it above either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
            }
            break;

        case MENUBAR_LEFT:

            if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) > (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;

        case MENUBAR_RIGHT:

            if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) >= (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;
        }
    
        // Finally set the bottom and right

        if (prcResult->top < rcMonitor.top)
            prcResult->top = rcMonitor.top;
        if (prcResult->left < rcMonitor.left)
            prcResult->left = rcMonitor.left;

        prcResult->bottom = prcResult->top  + info.cy;
        prcResult->right  = prcResult->left + info.cx;

        if (prcResult->bottom > rcMonitor.bottom)
        {
            // -2 for some breathing room at the edge of the screen
            prcResult->bottom = rcMonitor.bottom - 2;
            prcResult->top = prcResult->bottom - info.cy;
        }
    }
}


void SlideAnimate(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide)
{
    DWORD dwAnimateFlags = AW_CENTER;
    switch(uSide) 
    {
    case MENUBAR_LEFT:      dwAnimateFlags = AW_HOR_NEGATIVE;
        break;
    case MENUBAR_RIGHT:     dwAnimateFlags = AW_HOR_POSITIVE;
        break;
    case MENUBAR_TOP:       dwAnimateFlags = AW_VER_NEGATIVE;
        break;
    case MENUBAR_BOTTOM:    dwAnimateFlags = AW_VER_POSITIVE;
        break;
    }
    AnimateWindow(hwnd, 120, dwAnimateFlags | AW_SLIDE);
}

void AnimateSetMenuPos(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide, BOOL fNoAnimate)
{
    // simple check to see if we're too big for animatewindow, based on menu area.
    // this is because it has to read from video mem to do the alpha and thats slow, maybe
    // let it back if we get hardware acceleration in a future release.
    BOOL fPerfBad = (RECTWIDTH(*prc) * RECTHEIGHT(*prc) > 600 * 200);
    if (!fNoAnimate && !fPerfBad)
    {
        BOOL fAnimate = FALSE;
        SystemParametersInfo(SPI_GETMENUANIMATION, 0, &fAnimate, 0);
        if (fAnimate)
        {
            SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top,
                    RECTWIDTH(*prc), RECTHEIGHT(*prc), uFlags);
        
            fAnimate = FALSE;
            SystemParametersInfo(SPI_GETMENUFADE, 0, &fAnimate, 0);
            if (fAnimate)
            {
                AnimateWindow(hwnd, 175, AW_BLEND);
            }
            else
            {
                SlideAnimate(hwnd, prc, uFlags, uSide);
            }
        }
        else
            goto UseSetWindowPos;
    }
    else
    {
UseSetWindowPos:
        // Enable the show window so that it gets displayed.
        uFlags |= SWP_SHOWWINDOW;

        SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), 
                     uFlags);
    }
}



HRESULT CMenuDeskBar::_PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));

    BOOL bSetFocus = (dwFlags & MPPF_SETFOCUS);
    RECT rcDesired;
    RECT rcExclude;
    RECT rc;
    SIZE sizeAdjust;
    UINT uAnimateSide;

    BOOL bMirroredWindow=IS_WINDOW_RTL_MIRRORED(_hwnd);

    static const iPosition[] = {MENUBAR_TOP, MENUBAR_LEFT, MENUBAR_RIGHT, MENUBAR_BOTTOM};

    if (dwFlags & MPPF_POS_MASK)
    {
        UINT uPosIndex = ((dwFlags & MPPF_POS_MASK) >> 29) - 1;
        ASSERT(uPosIndex < 4);
        _uSide = iPosition[uPosIndex];
    }

    if (bSetFocus)
        SetForegroundWindow(_hwnd);
    
    _pt = *(POINT*)ppt;

    // Get the size of the ideal client rect of the child
    RECT rcChild = {0};

    // (scotth): This only sets the bottom and the right values
    _pDBC->GetSize(DBC_GS_IDEAL, &rcChild);

    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);

    // Adjust for the window border style
    rcDesired = rcChild;        // use rcDesired as a temp variable
    if (!_fNoBorder)
    {
        AdjustWindowRectEx(&rcChild, dwStyle, FALSE, dwExStyle);
    }

    // Calculate the edge of the menu border, and add a fudge factor so
    // left/right-cascaded menus overlap the parent menu a bit and are
    // correctly aligned vertically.

    sizeAdjust.cx = (RECTWIDTH(rcChild) - RECTWIDTH(rcDesired)) / 2;
    sizeAdjust.cy = (RECTHEIGHT(rcChild) - RECTHEIGHT(rcDesired)) / 2;

    if (prcExclude)
    {
        CopyRect(&rcExclude, (RECT*)prcExclude);

        //
        // If mirroring is enabled, let's mirror this guy
        // by simulating a different mirrored rect. This is
        // only for dropdown menus. [samera]
        //  
        if (bMirroredWindow)           
        {
            if ((_uSide != MENUBAR_LEFT)    &&
                (_uSide != MENUBAR_RIGHT) )
            {  
                int x;
                int iW  = rcExclude.right-rcExclude.left;
                int icW = (rcChild.right-rcChild.left);


                if( icW > iW )
                {
                    x = icW - iW;
                    rcExclude.left  -= x ;
                    rcExclude.right -= x ;
                }
                else
                {
                    x = iW - icW;
                    rcExclude.left  += x;
                    rcExclude.right += x;
                }

                ppt->x = rcExclude.left;
            }

        }

        TraceMsg(DM_POPUP, "Parent Side is %d ", _uSide);
        switch(_uSide) 
        {
        case MENUBAR_LEFT :
            rcDesired.left = rcExclude.left - rcChild.right;  // right is width
            rcDesired.top  = rcExclude.top;
            break;

        case MENUBAR_RIGHT :
            rcDesired.left = rcExclude.right;
            rcDesired.top  = rcExclude.top;
            break;
            
        case MENUBAR_TOP:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.top - rcChild.bottom;  // bottom is height
            break;

        case MENUBAR_BOTTOM:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.bottom;
            break;

        default:
            rcDesired.left   = _pt.x;
            rcDesired.top    = _pt.y;
        }
    }
    else
    {
        SetRectEmpty(&rcExclude);

        rcDesired.left   = _pt.x;
        rcDesired.top    = _pt.y;
    }

    rcDesired.right  =  rcDesired.left + RECTWIDTH(rcChild);
    rcDesired.bottom =  rcDesired.top + RECTHEIGHT(rcChild);

    _GetPopupWindowPosition(&rcDesired, &rcExclude, &rc, &sizeAdjust, _uSide);

    UINT uFlags = SWP_NOOWNERZORDER;
    if (!bSetFocus)
        uFlags |= SWP_NOACTIVATE;

    //
    // Open the menus properly. In case of a RTL mirrored window,
    // flip the animation side. [samera]
    //
    if( bMirroredWindow )
    {
        switch( _uSide )
        {
        case MENUBAR_LEFT:
            uAnimateSide = MENUBAR_RIGHT;
        break;
        case MENUBAR_RIGHT:
            uAnimateSide = MENUBAR_LEFT;
        break;
        default:
            uAnimateSide = _uSide;
        }
    }
    else
    {
        uAnimateSide = _uSide;
    }

    TraceMsg(TF_MENUBAND, "CMenuBar::_PositionWindow (%d,%d,%d,%d)",
        rc.left, rc.top, rc.right, rc.bottom);

    // Last minuite tweak. Since we're in large icon, we need to add this
    // so that the bitmap is painted correctly.
    if(_iIconSize == BMICON_LARGE && _fExpanded)
        rc.right += 1;

    // We _DO_ want to do a Z-Order position when this flag is specified. This is
    // for full repositioning where we need to preserve the overlap state of all bands.
    // Otherwize we just want to size the bar without changing it's z-order.
    if (!(dwFlags & MPPF_FORCEZORDER) && 
        (S_OK == IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild,
         &CGID_MenuBand, MBANDCID_ISINSUBMENU, 0, NULL, NULL)))
    {
        uFlags |= SWP_NOZORDER;
    }

    // If it's bigger than this magical number, then we don't animate. change to taste
  
    if (RECTHEIGHT(rc) > MAGICAL_NO_FADE_HEIGHT)
        dwFlags |= MPPF_NOANIMATE;

    AnimateSetMenuPos(_hwnd, &rc, uFlags, uAnimateSide, dwFlags & MPPF_NOANIMATE);

    // Save information so we can later resize this window
    // We already have: _pt, _uSide
    if (prcExclude)
    {
        _fExcludeRect = TRUE;
        CopyRect(&_rcExclude, (RECT*)prcExclude);
    }
    else
        _fExcludeRect = FALSE;
    return S_OK;
} 

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

*/
STDMETHODIMP CMenuDeskBar::Popup(POINTL* ppt, RECTL* prcExclude, DWORD dwFlags)
{
    HRESULT hr;

    // Is the caller telling us to reposition?
    if (dwFlags & MPPF_REPOSITION)
    {
        if (ppt == NULL)
            ppt = (POINTL*)&_pt;

        if (prcExclude == NULL)
            prcExclude = (RECTL*)&_rcExclude;

        // Yes; Then we don't need to do any First show stuff.
        _PositionWindow(ppt, prcExclude, dwFlags);
        return S_OK;
    }

    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));

    if (_pmpParent) 
    {
        _pmpParent->SetSubMenu(this, TRUE);
    }

    IOleCommandTarget* poct;
    hr = IUnknown_QueryService(_punkChild, SID_SMenuBandChild, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (SUCCEEDED(hr))
    {
        // We need to do this before the ShowDW. This saves us from doing the setting twice
        // Because in the ShowDW of MenuBand, we actually go an initialize the toolbar with
        // the current default setting which should be "No Keyboard Cues." If we set the state
        // here, then the state will be "Show keyboard cues." Then we will update the toolbar. 
        if (dwFlags & MPPF_KEYBOARD)
            poct->Exec(&CGID_MenuBand, MBANDCID_KEYBOARD, 0, NULL, NULL);
    }
    else
    {
        ASSERT(poct == NULL);
    }
    
    _NotifyModeChange(_dwMode);
    hr = ShowDW(TRUE);

    if (SUCCEEDED(hr) && _pmpParent)
    {
        VARIANT varg;
        // If this Exec fails, don't panic; it just means we use the default side
        if (SUCCEEDED(IUnknown_Exec(_pmpParent, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &varg)))
        {
            if (varg.vt == VT_I4)
            {
                _uSide = (UINT) varg.lVal;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        SHPlaySound(TEXT("MenuPopup"));

        _PositionWindow(ppt, prcExclude, dwFlags);

        // Set focus
        UIActivateIO(TRUE, NULL);
    
        _fActive = TRUE;

        // Select the first/last item?
        if ((dwFlags & (MPPF_INITIALSELECT | MPPF_FINALSELECT)) && poct)
        {
            DWORD nCmd = (dwFlags & MPPF_INITIALSELECT) ? MBSI_FIRSTITEM : MBSI_LASTITEM;
            poct->Exec(&CGID_MenuBand, MBANDCID_SELECTITEM, nCmd, NULL, NULL);
        }
    }

    ATOMICRELEASE(poct);
    
    return hr;
} 


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

Returns: 
Cond:    --
*/
HRESULT CMenuDeskBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

*/
STDMETHODIMP CMenuDeskBar::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    if (_fShow)
        _PopDown();

    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_pmpParent);
    
    _punkSite = punkSite;
    
    if (_punkSite)
    {    
        _punkSite->AddRef();
        IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &_pmpParent));
    }
    else
    {
        CloseDW(0);
    }
        
    return S_OK;
} 


/*----------------------------------------------------------
Purpose: IObjectWithSite::GetSite method

*/
STDMETHODIMP CMenuDeskBar::GetSite(REFIID riid, LPVOID* ppvSite)
{
    if (_punkSite)
    {
        return _punkSite->QueryInterface(riid, ppvSite);
    }

    *ppvSite = NULL;
    return E_FAIL;
} 

void CMenuDeskBar::AdjustForTheme()
{
    if (_fFlatMenuMode)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_BORDER);
    }
    else if (!_fExpanded)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_CLIPCHILDREN | WS_DLGFRAME);
    }
}


/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec method

*/
STDMETHODIMP CMenuDeskBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBCID_EMPTY:
            // if we have no bands left, close
            OnSelect(MPOS_FULLCANCEL);
            return S_OK;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
            case MBCID_GETSIDE :
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _GetSide();
                return S_OK;

            case MBCID_RESIZE:
                if (_fActive)
                {
                    if (_fExcludeRect)
                        _PositionWindow((POINTL *)&_pt, (RECTL *)&_rcExclude, 0);
                    else
                        _PositionWindow((POINTL *)&_pt, NULL, 0);
                }
                return S_OK;

            case MBCID_SETEXPAND:
                if ((BOOL)_fExpanded != (BOOL)nCmdexecopt && !_fFlatMenuMode)
                {
                    _fExpanded = nCmdexecopt;

                    SetExpandedBorder(_hwnd, _fExpanded);
                }
                return S_OK;

            case MBCID_SETFLAT:
                {
                    _fFlatMenuMode = BOOLIFY(nCmdexecopt);
                    AdjustForTheme();
                }
                break;

            case MBCID_NOBORDER:
                {
                    _fNoBorder = BOOLIFY(nCmdexecopt);
                    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
                }
                break;

            default : 
                return OLECMDERR_E_NOTSUPPORTED;

        }   
    }
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}    

    
/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuPopup)) 
    {
        return QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
             IsEqualIID(guidService, SID_SMenuBandChild))
    {
        // SID_SMenuBandBottom queries down
        return IUnknown_QueryService(_punkChild, guidService, riid, ppvObj);
    }
    else
    {
        HRESULT hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);
        
        if (FAILED(hres))
        {
            hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
        }
        
        return hres;
    }
        
} 

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetIconSize(DWORD iIcon)
{
    HRESULT hres;

    _iIconSize = iIcon;

    hres = IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild, &CGID_MenuBand, 
        MBANDCID_SETICONSIZE, iIcon == BMICON_SMALL? ISFBVIEWMODE_SMALLICONS: ISFBVIEWMODE_LARGEICONS, NULL, NULL);


    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetBitmap(HBITMAP hBitmap)
{
    ASSERT(hBitmap);
    BITMAP bm;
    _hbmp = hBitmap;

    if (_hbmp)
    {
        if(!GetObject(_hbmp, sizeof(bm), &bm))
            return E_FAIL;
        _sizeBmp.cx = bm.bmWidth;
        _sizeBmp.cy = bm.bmHeight;

        // Hack to get color
        HDC hdc = GetDC(_hwnd);
        if (hdc)
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, _hbmp);
                _rgb = GetPixel(hdcMem, 0, 0);
                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
            }
            ReleaseDC(_hwnd, hdc);
        }
    }

    return NOERROR;
}

void CMenuDeskBar::_OnSize()
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);

    if(_iIconSize == BMICON_LARGE)
    {
        rc.left += _sizeBmp.cx;
        if (_fExpanded)
            rc.left++;
    }

    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER|SWP_FRAMECHANGED);

    rc.right = rc.left;
    rc.left -= _sizeBmp.cx;
    if (_fShow)
        InvalidateRect(_hwnd, &rc, TRUE);
}

LRESULT CMenuDeskBar::_DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags)
{
    HDC hdcmem;
    HBITMAP hbmpOld;
    RECT rc;
    HBRUSH   hbrush;
    int iDC = SaveDC(hdc);

    GetClientRect(hwnd, &rc);

    //Create a compatable DC
    hdcmem = CreateCompatibleDC(hdc);
    if(hdcmem)
    {
        // Offset the stuff we're paining if we're expanded
        BYTE bOffset = 0;
        // Store this for the Bar fill cycle
        int cyBitmap = 0;

        if (!_fFlatMenuMode)
        {
            bOffset = _fExpanded? 1 : 0;
        }

        if (_sizeBmp.cy <= RECTHEIGHT(rc) + 1)
        {
            //Select the bitmap into the memory DC
            hbmpOld = (HBITMAP)SelectObject(hdcmem, _hbmp);

            //Blit to the window
            BitBlt(hdc, bOffset, rc.bottom - _sizeBmp.cy - bOffset, _sizeBmp.cx, _sizeBmp.cy, hdcmem, 0, 0, SRCCOPY);

            // Ok, We need to subtract this value to see how much we need to paint for the banner.
            cyBitmap = _sizeBmp.cy;

            //Restore the DC
            SelectObject(hdcmem, hbmpOld);
        }

        rc.right = _sizeBmp.cx + bOffset;

        if (_fExpanded && !_fFlatMenuMode && !_fNoBorder)
            DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_LEFT | BF_TOP | BF_BOTTOM);

        //Paint the rest
        hbrush = CreateSolidBrush(_rgb);
        if(hbrush)
        {
            rc.bottom -= cyBitmap + bOffset;

            if (_fExpanded)
            {
                rc.left += bOffset;
                rc.top += bOffset;
            }

            FillRect(hdc, &rc, hbrush);
            DeleteObject(hbrush);
        }


        //Delete the DC.
        DeleteDC(hdcmem);
    }

    RestoreDC(hdc, iDC);
    return 0;
}

void CMenuDeskBar::_DoNCPaint(HWND hwnd, HDC hdc)
{
    if (!_fNoBorder)
    {
        RECT rc;

        // Since we need to paint the border, we get the window rect
        GetWindowRect(hwnd, &rc);
        // then change the rect so that it represents values relative to 
        // the origin.
        OffsetRect(&rc, -rc.left, -rc.top);

        if (hdc)
        {
            if (_fFlatMenuMode)
            {
                SHOutlineRect(hdc, &rc, GetSysColor(COLOR_3DSHADOW));
            }
            else 
                DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_RECT);
        }
    }
}


LRESULT CMenuDeskBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    
    LRESULT lres;

    switch (uMsg) 
    {
#ifdef MAINWIN
    case WM_NCPAINTSPECIALFRAME:
        // In  case  of  motif look  the  MwPaintBorder paints a Etched In
        // border if WM_NCPAINTSPECIALFRAME returns FALSE. We are handling
        // this message here and drawing the Etched Out frame explicitly.
        // wParam - HDC
        if (MwCurrentLook() == LOOK_MOTIF)
        {
            MwPaintSpecialEOBorder( hwnd, (HDC)wParam );
            return TRUE;
        }
        break;
#endif

    case WM_GETOBJECT:
        if (lParam == OBJID_MENU)
        {
            IAccessible* pacc;
            if (SUCCEEDED(QueryService(SID_SMenuBandChild, IID_PPV_ARG(IAccessible, &pacc))))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));
                pacc->Release();

                return lres;
            }
        }
        break;


    case WM_NCCREATE:
        //
        // Since this is a mirrored menu, then open it
        // on the left (mirrored) edge if possible. WillFit(...) will
        // ensure this for us [samera]
        //
        // Mirror the menu initially if its window is mirrored
        //
        ASSERT(_uSide == 0);
        if (IS_WINDOW_RTL_MIRRORED(_hwnd))
            _uSide = MENUBAR_LEFT;
        else
            _uSide = MENUBAR_RIGHT;
        break;

    case WM_ACTIVATE:
        if (LOWORD(wParam) == WA_INACTIVE) 
        {
            if (_fActive && !_pmpChild) 
            {
                
                // if we were active, and the thing going active now
                // is not one of our parent menubars, then cancel everything.
                
                // if it's a parent of ours going active, assume that
                // they will tell us to die when they want us to...
                if (!_IsMyParent((HWND)lParam))
                    OnSelect(MPOS_FULLCANCEL);
            }
        } 
        else 
        {
            if (_pmpChild) 
            {
                // if we're becoming active, and we have a child, that child should go away
                _pmpChild->OnSelect(MPOS_CANCELLEVEL);
            }
        }
        break;

    case WM_PRINTCLIENT:
        if (_iIconSize == BMICON_LARGE)
        {
            _DoPaint(hwnd, (HDC)wParam, (DWORD)lParam);
            return 0;
        }
        break;

    case WM_PAINT:
        // Paint the banner if we're in showing large icons
        if (_iIconSize == BMICON_LARGE)
        {
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            _DoPaint(hwnd, ps.hdc, 0);
            EndPaint(hwnd, &ps);
            return 0;
        }
        break;

   case WM_PRINT:
        if ((_fFlatMenuMode || _fExpanded) && PRF_NONCLIENT & lParam)
        {
            HDC hdc = (HDC)wParam;

            DefWindowProcWrap(hwnd, WM_PRINT, wParam, lParam);

            // Do this after so that we look right...
            _DoNCPaint(hwnd, hdc);

            return 1;
        }
        break;

    case WM_NCCALCSIZE:
        if (_fNoBorder)
        {
            return 0;
        }
        else
        {
            return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        break;

    case WM_NCPAINT:
        if (_fNoBorder)
        {
            return 0;
        }
        else if (_fExpanded || _fFlatMenuMode)
        {    
            HDC hdc;    
            hdc = GetWindowDC(hwnd);
            if (hdc)
            {
                _DoNCPaint(hwnd, hdc);
                ReleaseDC(hwnd, hdc);
            }
            return 1;
        } 
        break;

    case WM_NCHITTEST:
        lres = SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);

        switch (lres)
        {
        case HTBOTTOM:
        case HTBOTTOMLEFT:
        case HTBOTTOMRIGHT:
        case HTLEFT:
        case HTRIGHT:
        case HTTOP:
        case HTTOPLEFT:
        case HTTOPRIGHT:
            // Don't allow the window to be resized
            lres = HTBORDER;
            break;

        case HTTRANSPARENT:
            // Don't let a click go thru to the window underneath
            lres = HTCLIENT;
            break;

        }
        return lres;

        // HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
        // (lamadio) 1.25.99
        // This hack is here to fix a problem on down level Windows with Integrated
        // IE4.01, IE5 and Office 2000.
        // The bug revolves around Start Menu not being destroyed when Explorer.exe shuts
        // down. Start Menu unregisters itself at CloseDW, but since the menubar never gets
        // destroyed, Start Menu never deregisters itself.
        // When an System service, such as MSTASK.dll keeps shell32 alive in the background,
        // it leaves an outstanding reference to a change notify. When a new user logs in,
        // O2k and IE5 fire up group conv, generating more than 10 change notify events in the
        // start menu. This causes the batching code to be fired up: Which does not really
        // work without the shell started. GroupConv also adds these events using memory 
        // alloced from it's process heap. Since there is an outstanding change notify handler
        // these pidls get forced to be handled. Shell32 then faults derefing a bad pidl.
        // By detecting an Endsession, we can eliminate this problem. Doing a SetClient(NULL)
        // cause Menubar to free it's references to MenuSite. Menusite, calls CloseDW on menuband
        // menuband then causes MNFolder to unregister itself. Since no one is listening any more
        // the crash is avoided.

    case WM_ENDSESSION:
        if (wParam != 0)
        {
            SetClient(NULL);
        }
        break;

    }
    
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
} 

IMenuPopup* CMenuDeskBar::_GetMenuBarParent(IUnknown* punk)
{
    IMenuPopup *pmp = NULL;
    IObjectWithSite* pows;
    punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));

    if (pows)
    {    
        IServiceProvider* psp;
        pows->GetSite(IID_PPV_ARG(IServiceProvider, &psp));
        
        if (psp)
        {    
            psp->QueryService(SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp));
            psp->Release();
        }
        
        pows->Release();
    }
    
    return pmp;
}


// this assumes that hwnd is a toplevel window and that the menudeskbars are also 
// the only hosts and are themselves toplevel
BOOL CMenuDeskBar::_IsMyParent(HWND hwnd)
{
    BOOL fRet = FALSE;
    if (hwnd)
    {
        HWND hwndMenu;
        
        IMenuPopup *pmpParent = _pmpParent;
        if (pmpParent)
            pmpParent->AddRef();
        
        while (pmpParent && !fRet &&
               SUCCEEDED(IUnknown_GetWindow(pmpParent, &hwndMenu)))
        {
            if (hwndMenu == hwnd)
            {
                fRet = TRUE;
            }
            
            IMenuPopup* pmpNext = _GetMenuBarParent(pmpParent);
            pmpParent->Release();
            pmpParent = pmpNext;
        }
    }

    return fRet;
}

IMenuPopup* CreateMenuPopup(IMenuPopup* pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    return CreateMenuPopup2(pmpParent, NULL, psf, pidl, pbi, bMenuBand);
}

IMenuPopup* CreateMenuPopup2(IMenuPopup* pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    
    ASSERT(pmb == NULL || IS_VALID_CODE_PTR(pmb, IMenuBand));
    ASSERT(psf == NULL || IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(pmpParent == NULL || IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(pidl && IS_VALID_PIDL(pidl));
    ASSERT(pbi == NULL || IS_VALID_READ_PTR(pbi, BANDINFOSFB));

    IMenuPopup* pmp = NULL;
    IDeskBand *pdb = NULL;
    IBandSite *pbs = NULL;
    HRESULT hres = E_FAIL;

    if (!pdb) 
    {
        TraceMsg(TF_MENUBAND, "CreateMenuPopup2 : Did not find a this (0x%x) band.", pidl);

        if (bMenuBand)
        {
            pdb = CMenuBand_Create(psf, pidl, FALSE);
        }
        else
        {
            CISFBand_CreateEx(psf, pidl, IID_PPV_ARG(IDeskBand, &pdb));
        }

        if (pdb) 
        {
            if (pbi) 
            {
                IShellFolderBand *pisfBand;
                if (SUCCEEDED(pdb->QueryInterface(IID_IShellFolderBand, (LPVOID*)&pisfBand))) 
                {
                    pisfBand->SetBandInfoSFB(pbi);
                    pisfBand->Release();
                }
            }

            if (!pmpParent) 
            {
                const CLSID * pclsid;

                if (bMenuBand)
                    pclsid = &CLSID_MenuBandSite;
                else
                    pclsid = &CLSID_RebarBandSite;

                CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER, IID_IBandSite, (LPVOID*)&pbs);

                if (pbs) 
                {

                    if (bMenuBand)
                    {
                        BANDSITEINFO bsinfo;

                        // Don't show the gripper for vertical menubands
                        bsinfo.dwMask = BSIM_STYLE;
                        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_NODROPTARGET;
                        pbs->SetBandSiteInfo(&bsinfo);
                    }

                    CMenuDeskBar *pcmdb = new CMenuDeskBar();
                    if (pcmdb)
                    {
                        if (SUCCEEDED(pcmdb->SetClient(pbs))) 
                            pcmdb->QueryInterface(IID_IMenuPopup, (LPVOID *)&pmp);

                        pcmdb->Release();
                    }
                }
            }

            if (pbs) 
            {
                pbs->AddBand(pdb);
            }
        }
    }
    
    ATOMICRELEASE(pdb);
    ATOMICRELEASE(pbs);
    if (!pmp)
        IUnknown_Set((IUnknown**) &pmp, pmpParent);
    

    return pmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menubar.h ===
#ifndef _menubar_h
#define _menubar_h


#ifdef __cplusplus

#include "basebar.h"

IMenuPopup* CreateMenuPopup(IMenuPopup *pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
IMenuPopup* CreateMenuPopup2(IMenuPopup *pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
HRESULT FindBandInBandSite(IMenuPopup* pmpParent, IBandSite** ppbs, LPCITEMIDLIST pidl, REFIID riid, void** ppvOut);
HRESULT ShowBandInBandSite(IUnknown* punkBS, IUnknown* punkDB);


class CMenuDeskBar : 
        public CBaseBar
        ,public IMenuPopup
        ,public IObjectWithSite
        ,public IBanneredBar
        ,public IInitializeObject
{
public:    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CBaseBar::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CBaseBar::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) { return CBaseBar::GetWindow(lphwnd); };
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return CBaseBar::ContextSensitiveHelp(fEnterMode); };

    // *** IDeskBar methods ***
    STDMETHODIMP SetClient(IUnknown* punk) { return CBaseBar::SetClient(punk); };
    STDMETHODIMP GetClient(IUnknown** ppunkClient) { return CBaseBar::GetClient(ppunkClient); };
    STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return CBaseBar::OnPosRectChangeDB(prc); };

    // *** IInputObjectSite methods (override) ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown * pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    // *** IBanneredBar methods ***
    virtual STDMETHODIMP SetIconSize(DWORD iIcon);
    virtual STDMETHODIMP GetIconSize(DWORD* piIcon)
        { ASSERT(piIcon); *piIcon = _iIconSize; return NOERROR;};
    virtual STDMETHODIMP SetBitmap(HBITMAP hBitmap);
    virtual STDMETHODIMP GetBitmap(HBITMAP* phBitmap)
        { ASSERT(phBitmap); *phBitmap = _hbmp; return NOERROR;};

    // *** IInitializeObject methods ***
    // This is for Backwards compatility with Start Menu.
    STDMETHODIMP Initialize() { return NOERROR; }


    CMenuDeskBar();

    
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void _OnCreate();
    virtual void _OnSize();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();
 
    void    _AllowMessageThrough(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void    _GetPopupWindowPosition(RECT* rcDesired, RECT* rcExclude, RECT *prcResult, SIZE * psizeEdge, UINT uside); 
    void    _PopDown();
    BOOL    _IsMyParent(HWND hwnd);  
    IMenuPopup* _GetMenuBarParent(IUnknown* punk);
    UINT    _GetSide() { return _uSide;};
    HRESULT _PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags);
    LRESULT _DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags);
    void _DoNCPaint(HWND hwnd, HDC hdc);
    void _SelectItem(BOOL bFirst);
    void AdjustForTheme();

    virtual ~CMenuDeskBar();
            
    POINT   _pt;
    IMenuPopup* _pmpParent;
    IMenuPopup* _pmpChild;
    IUnknown* _punkSite;
    UINT    _uSide;


    HBITMAP _hbmp;
    DWORD   _iIconSize;
    SIZE    _sizeBmp;
    COLORREF    _rgb;

    BITBOOL _fActive: 1;

    RECT    _rcExclude;
    BITBOOL _fExcludeRect: 1;  // TRUE: _rcExclude contains valid 
    BITBOOL _fExpanded: 1;
    BITBOOL _fFlatMenuMode: 1;
    BOOL    _fNoBorder;
};

HRESULT TrackShellMenu(HWND hwnd, LPRECT prc, IShellMenu* psm, DWORD dwFlags);

#endif // __cplusplus
#endif // _menubar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menuisf.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "resource.h"
#include "caggunk.h"
#include "menuisf.h"
#include "menubar.h"
#include "menuband.h"
#include "iaccess.h"
#include "apithk.h"

//=================================================================
// Implementation of CMenuAgent
//
//  The single global object of this class (g_menuagent) is the
//  manager of the message filter proc used to track mouse and
//  keyboard messages on behalf of CTrackPopupBar while a menu is
//  in a modal menu loop in TrackPopupMenu.
//
//  We track these messages so we can pop out of the menu, behaving
//  as if the visual menu bar consisted of a homogeneous menu
//  object.
//
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);

struct CMenuAgent
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndSite;          // hwnd to receive forwarded messages
    HWND        _hwndParent;
    CTrackPopupBar * _ptpbar;
    IMenuPopup * _pmpParent;
    void*       _pvContext;

    BITBOOL     _fEscHit: 1;

    // we need to keep track of whether the last selected
    // menu item was on a popup or not.  we can do this by storing the 
    // last WM_MENUSELECT flags
    UINT        _uFlagsLastSelected; 
    HMENU       _hmenuLastSelected;
    POINT       _ptLastMove;

    void    Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, HWND hwndParent, HWND hwndSite);
    void    Reset(void* pvContext);
    void    CancelMenu(void* pvContext);

    static LRESULT CALLBACK MsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
    void _OnMenuSelect(HMENU hmenu, int i, UINT uFlags);
    BOOL _OnKey(WPARAM vkey);
};

// Just one of these, b/c we only need one message filter
CMenuAgent g_menuagent = { 0 };     


/*----------------------------------------------------------
Purpose: Initialize the message filter hook

*/
void CMenuAgent::Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, 
                      HWND hwndParent, HWND hwndSite)
{
    TraceMsg(TF_MENUBAND, "Initialize CMenuAgent");

    ASSERT(IS_VALID_READ_PTR(ptpbar, CTrackPopupBar));
    ASSERT(IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(IS_VALID_HANDLE(hwndSite, WND));

    if (_pvContext != pvContext)
    {
        // When switching contexts, we need to collapse the old menu. This keeps us from
        // hosing the menubands when switching from one browser to another.
        CancelMenu(_pvContext);
        ATOMICRELEASE(_ptpbar);
        ATOMICRELEASE(_pmpParent);
        _pvContext = pvContext;
    }

    pmpParent->SetSubMenu(ptpbar, TRUE);

    _hwndSite = hwndSite;
    _hwndParent = hwndParent;

    // Since the message hook wants to forward messages to the toolbar,
    // we need to ask the pager control to do this
    Pager_ForwardMouse(_hwndSite, TRUE);

    _pmpParent = pmpParent;
    _pmpParent->AddRef();

    _ptpbar = ptpbar;
    _ptpbar->AddRef();

    if (NULL == _hhookMsg)
    {
        _hhookMsg = SetWindowsHookEx(WH_MSGFILTER, MsgHook, HINST_THISDLL, 0);
    }

    _fEscHit = FALSE;

    GetCursorPos(&_ptLastMove);
}


/*----------------------------------------------------------
Purpose: Reset the menu agent; no longer track mouse and keyboard
         messages.  The menuband calls this when it exits menu mode.

*/
void CMenuAgent::Reset(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        _pmpParent->SetSubMenu(_ptpbar, FALSE);

        // The only time to not send MPOS_FULLCANCEL is if the escape
        // key caused the menu to terminate.

        if ( !_fEscHit )
            _pmpParent->OnSelect(MPOS_FULLCANCEL);

        // Eat any mouse-down/up sequence left in the queue.  This is how 
        // we keep the toolbar from getting a mouse-down if the user 
        // clicks on the same menuitem as what is currently popped down.
        // (E.g., click File, then click File again.  W/o this, the menu
        // would never toggle up.)

        MSG msg;

        while (PeekMessage(&msg, _hwndSite, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
            ;   // Do nothing

        Pager_ForwardMouse(_hwndSite, FALSE);

        _hwndSite = NULL;
        _hwndParent = NULL;

        ATOMICRELEASE(_pmpParent);
        ATOMICRELEASE(_ptpbar);

        if (_hhookMsg)
        {
            TraceMsg(TF_MENUBAND, "CMenuAgent: Hook removed");

            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
        }

        _pvContext = NULL;
    }
}    


/*----------------------------------------------------------
Purpose: Make the menu go away

*/
void CMenuAgent::CancelMenu(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        if (_hwndParent)
        {
            ASSERT(IS_VALID_HANDLE(_hwndParent, WND));

            TraceMsg(TF_MENUBAND, "Sending cancel mode to menu");

            // Use PostMessage so USER32 doesn't RIP on us in 
            // MsgHook when it returns from the WM_MOUSEMOVE
            // that triggered this code path in the first place.

            PostMessage(_hwndParent, WM_CANCELMODE, 0, 0);

            // Disguise this as if the escape key was hit,
            // since this is called when the mouse hovers over
            // another menu sibling.
            _fEscHit = TRUE;

            // this can be called before a context is set up, so guard for NULL.
            if (_pmpParent)
            {
                _pmpParent->SetSubMenu(_ptpbar, FALSE);
            }
        }
    }
}    

// store away the identity of the selected menu item.
// if uFlags & MF_POPUP then i is the index.
// otherwise it's the command and we need to convert it to the index.
// we store index always because some popups don't have ids

void CMenuAgent::_OnMenuSelect(HMENU hmenu, int i, UINT uFlags)
{
    _uFlagsLastSelected = uFlags;
    _hmenuLastSelected = hmenu;
}

BOOL CMenuAgent::_OnKey(WPARAM vkey)
{
    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(_hwndSite))
    {
        switch (vkey)
        {
        case VK_LEFT:
          vkey = VK_RIGHT;
          break;

        case VK_RIGHT:
          vkey = VK_LEFT;
          break;
        }
    }

    switch (vkey)
    {
    case VK_RIGHT:
        if (!_hmenuLastSelected || !(_uFlagsLastSelected & MF_POPUP) || (_uFlagsLastSelected & MF_DISABLED) ) 
        {
            // if the currently selected item does not have a cascade, then 
            // we need to cancel out of all of this and tell the top menu bar to go right
            _pmpParent->OnSelect(MPOS_SELECTRIGHT);
        }
        break;
        
    case VK_LEFT:
        if (!_hmenuLastSelected || _hmenuLastSelected == _ptpbar->GetPopupMenu()) {
            // if the currently selected menu item is in our top level menu,
            // then we need to cancel out of all this menu loop and tell the top menu bar
            // to go left 
            _pmpParent->OnSelect(MPOS_SELECTLEFT);
        }
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while in a TrackPopupMenu modal loop.

*/
LRESULT CMenuAgent::MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    switch (nCode)
    {
    case MSGF_MENU:
        switch (pmsg->message)
        {
        case WM_MENUSELECT:
            // keep track of the items as the are selected.
            g_menuagent._OnMenuSelect(GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam));
            break;
            
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            // Since we've received this msg, any previous escapes
            // (like escaping out of a cascaded menu) should be cleared
            // to prevent a false reason for termination.
            g_menuagent._fEscHit = FALSE;
            break;

        case WM_KEYDOWN:
            if (g_menuagent._OnKey(pmsg->wParam))
                break;
            
        case WM_SYSKEYDOWN:
            g_menuagent._fEscHit = (VK_ESCAPE == pmsg->wParam);
            break;

        case WM_MOUSEMOVE:
            // HACKHACK (isn't all of this a hack?): ignore zero-move
            // mouse moves, so the mouse does not contend with the keyboard.

            POINT pt;
            
            // In screen coords....
            pt.x = GET_X_LPARAM(pmsg->lParam);
            pt.y = GET_Y_LPARAM(pmsg->lParam);

            if (g_menuagent._ptLastMove.x == pt.x && 
                g_menuagent._ptLastMove.y == pt.y)
            {
                TraceMsg(TF_MENUBAND, "CMenuAgent: skipping dup mousemove");
                break;
            }
            g_menuagent._ptLastMove = pt;

            // Since we got a WM_MOUSEMOVE, we need to tell the Menuband global message hook.
            // We need to do this because this message hook steels all of the messages, and
            // the Menuband message hook never updates it's internal cache for removing duplicate
            // WM_MOUSEMOVE messages which cause problems as outlined in CMsgFilter::_HandleMouseMessages
            GetMessageFilter()->AcquireMouseLocation();

            // Forward the mouse moves to the toolbar so the toolbar still
            // has a chance to hot track.  Must convert the points to the 
            // toolbar's client space.
            
            ScreenToClient(g_menuagent._hwndSite, &pt);

            SendMessage(g_menuagent._hwndSite, pmsg->message, pmsg->wParam, 
                        MAKELPARAM(pt.x, pt.y));
            break;
        }
        break;

    default:
        if (0 > nCode)
            return CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);
        break;
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);

    return lRet;
}    



//=================================================================
// Implementation of a menu deskbar object that uses TrackPopupMenu.
//
// This object uses traditional USER32 menus (via TrackPopupMenu)
// to implement menu behavior.  It uses the CMenuAgent object to 
// help get its work done.  Since the menu deskbar site (_punkSite) 
// sits in a modal loop while any menu is up, it needs to know when
// to quit its loop.  The child object accomplishes this by sending
// an OnSelect(MPOS_FULLCANCEL).
//
// The only time that TrackPopupMenu returns (but we don't want to
// send an MPOS_FULLCANCEL) is if it's b/c the Escape key was hit.
// This just means cancel the current level.  Returning from Popup
// is sufficient for this case.  Otherwise, all other cases of
// returning from TrackPopupMenu means we send a MPOS_FULLCANCEL.
//
// Summary:
//
//  1) User clicked outside the menu.  This is a full cancel.
//  2) User hit the Alt key.  This is a full cancel.
//  3) User hit the Esc key.  This just cancels the current level.
//     (TrackPopupMenu handles this fine.  No notification needs
//     to be sent b/c we want the top-level menu to stay in its
//     modal loop.)
//  4) User selected a menu item.  This is a full cancel.
//
//=================================================================


#undef THISCLASS
#undef SUPERCLASS
#define SUPERCLASS  CMenuDeskBar

// Constructor
CTrackPopupBar::CTrackPopupBar(void *pvContext, int id, HMENU hmenu, HWND hwnd)
{
    _hmenu = hmenu;
    _hwndParent = hwnd;
    _id = id;
    _pvContext = pvContext;
    _nMBIgnoreNextDeselect = RegisterWindowMessage(TEXT("CMBIgnoreNextDeselect"));
}

// Destructor
CTrackPopupBar::~CTrackPopupBar()
{
    SetSite(NULL);
}


STDMETHODIMP_(ULONG) CTrackPopupBar::AddRef()
{
    return SUPERCLASS::AddRef();
}

STDMETHODIMP_(ULONG) CTrackPopupBar::Release()
{
    return SUPERCLASS::Release();
}

STDMETHODIMP CTrackPopupBar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTrackPopupBar, IMenuPopup),
        QITABENT(CTrackPopupBar, IObjectWithSite),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CTrackPopupBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuBandChild)) 
    {
        if (IsEqualIID(riid, IID_IAccessible))
        {
            HRESULT hres = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(_hmenu, (WORD)_id);

            if (pacc)
            {
                hres = pacc->InitAcc();
                if (SUCCEEDED(hres))
                {
                    hres = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }

            return hres;
        }
        else
            return QueryInterface(riid, ppvObj);
    }
    else
        return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the parent menubar to tell us when to
         bail out of the TrackPopupMenu
*/
STDMETHODIMP CTrackPopupBar::OnSelect(DWORD dwType)
{
    switch (dwType)
    {
    case MPOS_CANCELLEVEL:
    case MPOS_FULLCANCEL:
        g_menuagent.CancelMenu(_pvContext);
        break;

    default:
        TraceMsg(TF_WARNING, "CTrackPopupBar doesn't handle this MPOS_ value: %d", dwType);
        break;
    }
    return S_OK;    
}    


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

*/
STDMETHODIMP CTrackPopupBar::SetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    return E_NOTIMPL;
}    

// HACKHACK: DO NOT TOUCH! This is the only way to select
// the first item for a user menu. TrackMenuPopup by default does
// not select the first item. We pump these messages to our window. 
// User snags these messages, and thinks the user pressed the down button
// and selects the first item for us. The lParam is needed because Win95 gold
// validated this message before using it. Another solution would be to listen
// to WM_INITMENUPOPUP and look for the HWND of the menu. Then send that 
// window the private message MN_SELECTFIRSTVALIDITEM. But thats nasty compared 
// to this. - lamadio 1.5.99
void CTrackPopupBar::SelectFirstItem()
{
    HWND hwndFocus = GetFocus();
    // pulled the funny lparam numbers out of spy's butt.
    if (hwndFocus) {
        PostMessage(hwndFocus, WM_KEYDOWN, VK_DOWN, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_DOWN, 0xD1500001);
#ifdef UNIX
        /* HACK HACK
         * The above PostMessages were causing the second menu item
         * to be selected if you access the menu from the keyboard.
         * The following PostMessages will nullify the above effect.
         * This is to make sure that menus in shdocvw work properly
         * with user32 menus.
         */
        PostMessage(hwndFocus, WM_KEYDOWN, VK_UP, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_UP, 0xD1500001);
#endif /* UNIX */
    }
}
           
/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

         Invoke the menu.
*/
STDMETHODIMP CTrackPopupBar::Popup(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));
    ASSERT(IS_VALID_CODE_PTR(_pmpParent, IMenuPopup));

    // We must be able to talk to the parent menu bar 
    if (NULL == _pmpParent)
        return E_FAIL;

    ASSERT(IS_VALID_HANDLE(_hmenu, MENU));
    ASSERT(IS_VALID_CODE_PTR(_punkSite, IUnknown));
    
    HMENU hmenu = GetSubMenu(_hmenu, _id);
    HWND hwnd;
    TPMPARAMS tpm;
    TPMPARAMS * ptpm = NULL;

    // User32 does not want to fix this for compatibility reasons,
    // but TrackPopupMenu does not snap to the nearest monitor on Single and Multi-Mon
    // systems. This has the side effect that if we pass a non-visible coordinate, then
    // User places menu at a random location on screen. So instead, we're going to bias
    // the point to the monitor.

    MONITORINFO mi = {0};
    mi.cbSize = sizeof(mi);

    HMONITOR hMonitor = MonitorFromPoint(*((POINT*)ppt), MONITOR_DEFAULTTONEAREST);
    GetMonitorInfo(hMonitor, &mi);

    if (ppt->x >= mi.rcMonitor.right)
        ppt->x = mi.rcMonitor.right;

    if (ppt->y >= mi.rcMonitor.bottom)
        ppt->y = mi.rcMonitor.bottom;

    if (ppt->x <= mi.rcMonitor.left)
        ppt->x = mi.rcMonitor.left;

    if (ppt->y <= mi.rcMonitor.top)
        ppt->y = mi.rcMonitor.top;


    if (prcExclude)
    {
        tpm.cbSize = SIZEOF(tpm);
        tpm.rcExclude = *((LPRECT)prcExclude);
        ptpm = &tpm;
    }

    // The forwarding code in CShellBrowser::_ShouldForwardMenu
    // and CDocObjectHost::_ShouldForwardMenu expects the first
    // WM_MENUSELECT to be sent for the top-level menu item.
    // 
    // We need to fake an initial menu select on the top menu band
    // to mimic USER and satisfy this expectation.
    //
    UINT uMSFlags = MF_POPUP;
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(_id, uMSFlags), (LPARAM)_hmenu);
    
    SendMessage(_hwndParent, _nMBIgnoreNextDeselect, NULL, NULL);

    // Initialize the menu agent
    IUnknown_GetWindow(_punkSite, &hwnd);
    
    VARIANTARG v = {0};
    UINT uFlags = TPM_VERTICAL | TPM_TOPALIGN;
    UINT uAnimateFlags = 0;
    if (SUCCEEDED(IUnknown_Exec(_punkSite, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &v))) {
        if (v.vt == VT_I4 && 
            (v.lVal == MENUBAR_RIGHT ||
             v.lVal == MENUBAR_LEFT))
        {
            uFlags = TPM_TOPALIGN;
        }

        switch (v.lVal)
        {
        case MENUBAR_LEFT:      uAnimateFlags = TPM_HORNEGANIMATION;
            break;
        case MENUBAR_RIGHT:     uAnimateFlags = TPM_HORPOSANIMATION;
            break;
        case MENUBAR_TOP:       uAnimateFlags = TPM_VERNEGANIMATION;
            break;
        case MENUBAR_BOTTOM:    uAnimateFlags = TPM_VERPOSANIMATION;
            break;
        }
    }

    g_menuagent.Init(_pvContext, this, _pmpParent, _hwndParent, hwnd);

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));
    if (dwFlags & MPPF_INITIALSELECT)
        SelectFirstItem();

    uFlags |= uAnimateFlags;

    TrackPopupMenuEx(hmenu, uFlags,
                   ppt->x, ppt->y, _hwndParent, ptpm);

    // Tell the parent that the menu is now gone
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);

    g_menuagent.Reset(_pvContext);
    _pmpParent->SetSubMenu(this, FALSE);

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menusite.cpp ===
#include "shellprv.h"
#include "menusite.h"

CMenuSite::CMenuSite() : _cRef(1)
{
}


CMenuSite::~CMenuSite()
{
    // Make sure that SetDeskBarSite(NULL) was called
    ASSERT(_punkSite == NULL);
    ASSERT(_punkSubActive == NULL);
    ASSERT(_pweh == NULL);
    ASSERT(_pdb == NULL);
    ASSERT(_hwnd == NULL);
}


STDAPI CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    CMenuSite *pbs = new CMenuSite();
    if (pbs)
    {
        hr = pbs->QueryInterface(riid, ppv);
        pbs->Release();
    }
    return hr;
}


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CMenuSite::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMenuSite, IBandSite),
        QITABENT(CMenuSite, IDeskBarClient),
        QITABENT(CMenuSite, IOleCommandTarget),
        QITABENT(CMenuSite, IInputObject),
        QITABENT(CMenuSite, IInputObjectSite),
        QITABENT(CMenuSite, IWinEventHandler),
        QITABENT(CMenuSite, IServiceProvider),
        QITABENT(CMenuSite, IOleWindow),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CMenuSite::AddRef(void)
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CMenuSite::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;

    *ppvObj = NULL;     // assume error

    if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
        IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
        IsEqualIID(guidService, SID_SMenuBandChild))
    {
        if (_punkSubActive)
            hres = IUnknown_QueryService(_punkSubActive, guidService, riid, ppvObj);
    }
    else
    {
        ASSERT(_punkSite);
        hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IOleCommandTarget::QueryStatus

*/
STDMETHODIMP CMenuSite::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    ASSERT(_punkSite);

    return IUnknown_QueryStatus(_punkSite, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec

*/
STDMETHODIMP CMenuSite::Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    ASSERT(_punkSite);

    return IUnknown_Exec(_punkSite, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

         This function is called by the client band to negotiate
         which band in this bandsite gets the focus.  Typically
         this function will then change its focus to the given
         client band.

         CMenuSite only maintains one and only one band, which
         is set at AddBand time, so this function is a nop.

*/
STDMETHODIMP CMenuSite::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    // Return S_OK since the menu site only ever has one band.
    // No need to negotiate which other band in this bandsite 
    // might have the "activation".
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO method

*/
STDMETHODIMP CMenuSite::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    // Forward onto the client band
    return IUnknown_UIActivateIO(_punkSubActive, fActivate, lpMsg);
}


/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

         Since the menuband can never have true activation (from
         the browser's perspective) this always returns S_FALSE.

         See comments in CMenuBand::UIActivateIO for more details
         about this.

*/
STDMETHODIMP CMenuSite::HasFocusIO()
{
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         Menubands cannot ever have the activation, so this method 
         should never be called.
*/
STDMETHODIMP CMenuSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}


// Utility Functions

void CMenuSite::_CacheSubActiveBand(IUnknown * punk)
{
    if (SHIsSameObject(punk, _punkSubActive))
        return;
    
    IUnknown_SetSite(_punkSubActive, NULL);

    ATOMICRELEASE(_punkSubActive);
    ATOMICRELEASE(_pdb);
    ATOMICRELEASE(_pweh);
    _hwndChild = NULL;

    if (punk != NULL) 
    {
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDeskBand, &_pdb))));
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pweh))));

        IUnknown_SetSite(punk, SAFECAST(this, IOleWindow*));
        IUnknown_GetWindow(punk, &_hwndChild);

        _punkSubActive = punk;
        _punkSubActive->AddRef();
    }
}


/*----------------------------------------------------------
Purpose: IBandSite::AddBand

*/
STDMETHODIMP CMenuSite::AddBand(IUnknown* punk)
{
    _CacheSubActiveBand(punk);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IBandSite::EnumBands

*/
STDMETHODIMP CMenuSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    HRESULT hres = NOERROR;

    // The menusite only holds one band ever
    if (0 == uBand)
        *pdwBandID = 0;
    else
        hres = E_FAIL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::QueryBand

*/
HRESULT CMenuSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hres = E_NOINTERFACE;

    ASSERT(dwBandID == 0);
    ASSERT(IS_VALID_WRITE_PTR(ppstb, IDeskBand *));

    if (_punkSubActive && 0 == dwBandID)
    {
        hres = _punkSubActive->QueryInterface(IID_PPV_ARG(IDeskBand, ppstb));
        *pdwState = BSSF_VISIBLE; // Only band....

        if (cchName > 0)
            *pszName = L'\0';
    }
    else
        *ppstb = NULL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandState

*/
HRESULT CMenuSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::RemoveBand

*/
HRESULT CMenuSite::RemoveBand(DWORD dwBandID)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandObject

*/
HRESULT CMenuSite::GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    ASSERT(dwBandID == 0);

    if (_punkSubActive && 0 == dwBandID)
        hres = _punkSubActive->QueryInterface(riid, ppvObj);
    else
    {
        *ppvObj = NULL;
        hres = E_NOINTERFACE;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandSiteInfo

*/
HRESULT CMenuSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandSiteInfo

*/
HRESULT CMenuSite::GetBandSiteInfo(BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow

*/
HRESULT CMenuSite::GetWindow(HWND * lphwnd)
{
    ASSERT(IS_VALID_HANDLE(_hwnd, WND));

    *lphwnd = _hwnd;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp

*/
HRESULT CMenuSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetDeskBarSite

*/
HRESULT CMenuSite::SetDeskBarSite(IUnknown* punkSite)
{
    if (punkSite)
    {
        ATOMICRELEASE(_punkSite);

        HWND hwnd;
        IUnknown_GetWindow(punkSite, &hwnd);

        if (hwnd)
        {
            _CreateSite(hwnd);

            _punkSite = punkSite;
            _punkSite->AddRef();
        }
    }
    else
    {
        if (_pdb)
        {
            _pdb->CloseDW(0);
        }
        _CacheSubActiveBand(NULL);      // This is asymetric by design

        if (_hwnd)
        {
            DestroyWindow(_hwnd);
            _hwnd = NULL;
        }

        ATOMICRELEASE(_punkSite);
    }

    return _hwnd ? NOERROR : E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetModeDBC

*/
HRESULT CMenuSite::SetModeDBC(DWORD dwMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::UIActivateDBC

*/
HRESULT CMenuSite::UIActivateDBC(DWORD dwState)
{
    HRESULT hr = S_OK;

    ASSERT(_pdb);
    if (_pdb)
        hr = _pdb->ShowDW(0 != dwState);

    return hr;
}

/*----------------------------------------------------------
Purpose: IDeskBarClient::GetSize

*/
HRESULT CMenuSite::GetSize(DWORD dwWhich, LPRECT prc)
{
    if (dwWhich == DBC_GS_IDEAL)
    {
        if (_pdb)
        {
            DESKBANDINFO dbi = {0};
            _pdb->GetBandInfo(0, 0, &dbi);
            prc->right = dbi.ptMaxSize.x;
            prc->bottom = dbi.ptMaxSize.y;
        }
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent

*/
HRESULT CMenuSite::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (_pweh)
        return _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner

*/
HRESULT CMenuSite::IsWindowOwner(HWND hwnd)
{
    if (_hwnd == hwnd || (_pweh && _pweh->IsWindowOwner(hwnd) != S_FALSE))
        return S_OK;
    else
        return S_FALSE;
}


LRESULT CMenuSite::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    AddRef();

    switch(uMsg)
    {
    case WM_SIZE:
        {
            IMenuPopup* pmp;

            if (_punkSubActive && SUCCEEDED(_punkSubActive->QueryInterface(IID_PPV_ARG(IMenuPopup, &pmp))))
            {
                RECT rc = {0};

                GetClientRect(_hwnd, &rc);

                pmp->OnPosRectChangeDB(&rc);
                pmp->Release();
            }
            lres = 1;
        }
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    default:
        Release();
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
        break;
    }

    if (hwnd && _pweh && _pweh->IsWindowOwner(hwnd) == S_OK) 
    {
        _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lres);
    }

    Release();
    return lres;
}


void CMenuSite::_CreateSite(HWND hwndParent)
{
    if (_hwnd)
    {
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));    // just to be safe...
        return;
    }

    WNDCLASS wc = {0};
    wc.style            = 0;
    wc.lpfnWndProc      = s_WndProc;
    wc.cbWndExtra       = SIZEOF(CMenuSite*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_MENU+1);
    wc.lpszClassName    = TEXT("MenuSite");

    SHRegisterClass(&wc);

    _hwnd = CreateWindow(TEXT("MenuSite"), NULL, WS_VISIBLE | WS_CHILD, 0, 0, 0, 0, 
        hwndParent, NULL, HINST_THISDLL, (LPVOID)SAFECAST(this, CImpWndProc*));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menusite.h ===
#ifndef _MENUSITE_H_
#define _MENUSITE_H_

//#define WANT_CBANDSITE_CLASS

//#include "bandsite.h"
#include "cwndproc.h"

// MenuSite will never have more than one client.


class CMenuSite : public IBandSite,
                  public IDeskBarClient,
                  public IOleCommandTarget,
                  public IInputObject,
                  public IInputObjectSite,
                  public IWinEventHandler,
                  public IServiceProvider,
                  public CImpWndProc
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBarClient methods ***
    virtual STDMETHODIMP SetDeskBarSite(IUnknown* punkSite);
    virtual STDMETHODIMP SetModeDBC(DWORD dwMode);
    virtual STDMETHODIMP UIActivateDBC(DWORD dwState);
    virtual STDMETHODIMP GetSize(DWORD dwWhich, LPRECT prc);

    // *** IWinEventHandler Methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IBandSite ***
    virtual STDMETHODIMP AddBand(IUnknown* punk);
    virtual STDMETHODIMP EnumBands(UINT uBand, DWORD* pdwBandID);
    virtual STDMETHODIMP QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName);
    virtual STDMETHODIMP SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual STDMETHODIMP RemoveBand(DWORD dwBandID);
    virtual STDMETHODIMP GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);
    virtual STDMETHODIMP GetBandSiteInfo(BANDSITEINFO * pbsinfo);


    CMenuSite();
    
protected:
    virtual ~CMenuSite();
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _CreateSite(HWND hwndParent);
    void _CacheSubActiveBand(IUnknown * punk);


    IUnknown*   _punkSite;
    IUnknown*   _punkSubActive;
    IDeskBand*  _pdb;
    IWinEventHandler*   _pweh;
    HWND        _hwndChild;

    int         _cRef;    
};

#endif  // _MENUSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\menuisf.h ===
#ifndef _MENUISF_H
#define _MENUISF_H

#include "caggunk.h"
#include "menubar.h"


//  Object that uses TrackPopupMenu as its implementation for IMenuPopup.
//

class CTrackPopupBar : public CMenuDeskBar
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) () ;
    STDMETHOD_(ULONG,Release) ();

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd) { return E_NOTIMPL; }
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode) { return E_NOTIMPL; }

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    
    CTrackPopupBar(void *pvContext, int id, HMENU hmenu, HWND hwnd);
    ~CTrackPopupBar();
    
    HMENU GetPopupMenu() { return GetSubMenu(_hmenu, _id); };
    void SelectFirstItem();
    
protected:
    int     _id;
    HMENU   _hmenu;
    HWND    _hwndParent;
    void*   _pvContext;
    
    // Popup message to indicate - "Ignore next MENUSELECT clear msg"
    UINT _nMBIgnoreNextDeselect;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\menuband\mnbase.cpp ===
#include "shellprv.h"
#include "common.h"
#include "menuband.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "iaccess.h"
#include "uemapp.h"
#include "util.h"

#ifdef UXCTRL_VERSION
#include <uxtheme.h>
#include <tmschema.h>
#endif

// Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

const TCHAR c_wzMenuBandTheme[] = TEXT("MenuBand");

#define DM_MISC     0               // miscellany

#define MAXUEMTIMEOUT 2000

/*----------------------------------------------------------
Purpose: Return the button command given the position.

*/
int GetButtonCmd(HWND hwnd, int iPos)
{
    ASSERT(IsWindow(hwnd));
    int nRet = -1;          // Punt on failure

    TBBUTTON tbb;
    if (ToolBar_GetButton(hwnd, iPos, &tbb))
    {
        nRet = tbb.idCommand;
    }
    return nRet;
}    



void* ItemDataFromPos(HWND hwndTB, int iPos)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
    if (ToolBar_GetButtonInfo(hwndTB, iPos, &tbbi) >= 0)
    {
        return (void*)tbbi.lParam;
    }

    return NULL;
}

long GetIndexFromChild(BOOL fTop, int iIndex)
{
    return  (fTop? TOOLBAR_MASK: 0) | iIndex + 1;
}

//--------------------------------------------------------------------------------
//
// CMenuToolbarBase
//
//--------------------------------------------------------------------------------

CMenuToolbarBase::~CMenuToolbarBase()
{
    Str_SetPtr(&_pszTheme, NULL);
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
    }
}

CMenuToolbarBase::CMenuToolbarBase(CMenuBand* pmb, DWORD dwFlags) : _pcmb(pmb)
{
#ifdef DEBUG
    _cRef = 1;
#endif
    _dwFlags = dwFlags;
    _nItemTimer = -1;
    _idCmdChevron = -1;
    _fFirstTime = TRUE;
}

// *** IObjectWithSite methods ***

HRESULT CMenuToolbarBase::SetSite(IUnknown *punkSite)
{
    ASSERT(punkSite && IS_VALID_READ_PTR(punkSite, CMenuBand*));

    // We are guaranteed the lifetime of this object is contained within
    // the menuband, so we don't addref pcmb.
    if (SUCCEEDED(punkSite->QueryInterface(CLSID_MenuBand, (void**)&_pcmb))) 
    {
        punkSite->Release();
    } 
    else 
    {
        ASSERT(0);
    }

    _fVerticalMB = !BOOLIFY(_pcmb->_dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(_pcmb->_dwFlags & SMINIT_TOPLEVEL);
    
    return S_OK;
}

HRESULT CMenuToolbarBase::GetSite(REFIID riid, void ** ppvSite)
{
    if (!_pcmb)
        return E_FAIL;

    return _pcmb->QueryInterface(riid, ppvSite);
}

// *** IUnknown methods ***

STDMETHODIMP_(ULONG) CMenuToolbarBase::AddRef()
{
    DEBUG_CODE(_cRef++);
    if (_pcmb)
    {
        return _pcmb->AddRef();
    }

    return 0;
}


STDMETHODIMP_(ULONG) CMenuToolbarBase::Release()
{
    ASSERT(_cRef > 0);
    DEBUG_CODE(_cRef--);

    if (_pcmb)
    {
        return _pcmb->Release();
    }

    return 0;
}

HRESULT CMenuToolbarBase::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hres;
    if (IsEqualGUID(riid, CLSID_MenuToolbarBase) && ppvObj) 
    {
        AddRef();
        *ppvObj = (void*)this;
        hres = S_OK;
    }
    else
        hres = _pcmb->QueryInterface(riid, ppvObj);

    return hres;
}

void CMenuToolbarBase::SetToTop(BOOL bToTop)
{
    // A menu toolbar can be at the top or the bottom of the menu.
    // This is an exclusive attribute.
    if (bToTop)
    {
        _dwFlags |= SMSET_TOP;
        _dwFlags &= ~SMSET_BOTTOM;
    }
    else
    {
        _dwFlags |= SMSET_BOTTOM;
        _dwFlags &= ~SMSET_TOP;
    }
}


void CMenuToolbarBase::KillPopupTimer()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Killing Popout Timer...", this);
    KillTimer(_hwndMB, MBTIMER_POPOUT);
    _nItemTimer = -1;
}


void CMenuToolbarBase::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (_hwndMB)
    {
        ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
        DWORD rectWidth = RECTWIDTH(*prc);
        TraceMsg(TF_MENUBAND, "CMTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
            prc->left, prc->top, prc->right, prc->bottom);
        ::SetWindowPos(_hwndMB, NULL, prc->left, prc->top, 
            rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
        // hackhack:  we only do this when multicolumn.  this call is to facilitate the size negotiation between 
        // static menu and folder menu.  Set the width of the toolbar to the width of the button in case 
        // of non-multicolumn.
        if (!(_fMulticolumnMB) && psize)
        {
            int cx = psize->cx;
            ToolBar_SetButtonWidth(_hwndMB, cx, cx);
        }

        // Force this to redraw. I put this here because the HMenu portion was painting after the shell
        // folder portion was done enumerating the folder, which is pretty slow. I wanted the HMENU portion
        // to paint right away...
        RedrawWindow(_hwndMB, NULL, NULL, RDW_UPDATENOW);
    }
}

// NOTE: if psize is (0,0) we use tb button size as param in figuring out ideal tb size
//   else we use max of psize length and tb button length as our metric
void CMenuToolbarBase::GetSize(SIZE* psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (_hwndMB)
    {
        LRESULT lButtonSize;

        lButtonSize = TB_GetButtonSizeWithoutThemeBorder(_hwndMB, _hTheme);

        if (psize->cx || psize->cy)
        {
            int cx = max(psize->cx, LOWORD(lButtonSize));
            int cy = max(psize->cy, HIWORD(lButtonSize));
            lButtonSize = MAKELONG(cx, cy);
        }

        if (_fVerticalMB)
        {
            psize->cx = LOWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, TRUE, (LPARAM)psize);
        }
        else
        {
            psize->cy = HIWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, FALSE, (LPARAM)psize);
        }

        TraceMsg(TF_MENUBAND, "CMTB::GetSize (%d, %d)", psize->cx, psize->cy);
    }
}


/*----------------------------------------------------------
Purpose: Timer handler.  Used to pop open/close cascaded submenus.

*/
LRESULT CMenuToolbarBase::_OnTimer(WPARAM wParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    switch (wParam) 
    {

    case MBTIMER_INFOTIP:
        {
            // Do we have a hot item to display the tooltip for?
            int iHotItem = ToolBar_GetHotItem(_hwndMB);
            KillTimer(_hwndMB, wParam);
            if (iHotItem >= 0)
            {
                // Yep.
                TCHAR szTip[MAX_PATH];
                int idCmd = GetButtonCmd(_hwndMB, iHotItem);

                // Ask the superclass for the tip
                if (S_OK == v_GetInfoTip(idCmd, szTip, ARRAYSIZE(szTip)))
                {
                    // Now display it. Yawn.
                    _pcmb->_pmbState->CenterOnButton(_hwndMB, FALSE, idCmd, NULL, szTip);
                }
            }
        }
        break;

    case MBTIMER_CHEVRONTIP:
        KillTimer(_hwndMB, wParam);
       _pcmb->_pmbState->HideTooltip(TRUE);
       break;
 
    case MBTIMER_FLASH:
        {
            _cFlashCount++;
            if (_cFlashCount == COUNT_ENDFLASH)
            {
                _cFlashCount = 0;
                KillTimer(_hwndMB, wParam);
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, FALSE);
                _SetTimer(MBTIMER_UEMTIMEOUT);

                // Now that we've flashed, let's show the Chevron tip.
                // This is for a confused user: If they've hovered over an item for too long,
                // or this is the first time they've seen intellimenus, then we flash and display
                // the tooltip. We only want to display this if we are shown: We would end up with
                // and dangling tooltip if you happen to move to another menu while it was flashing.
                // Ummm, is the Chevron still visible?
                if (_fShowMB && _idCmdChevron != -1)
                {
                    TCHAR szTip[MAX_PATH];
                    TCHAR szTitle[MAX_PATH];
                    if (S_OK == v_CallCBItem(_idCmdChevron, SMC_CHEVRONGETTIP, (WPARAM)szTitle, (LPARAM)szTip))
                    {
                        _pcmb->_pmbState->CenterOnButton(_hwndMB, TRUE, _idCmdChevron, szTitle, szTip);
                        _SetTimer(MBTIMER_CHEVRONTIP);
                    }
                }
            }
            else
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, (_cFlashCount % 2) == 0);
        }
        break;

    case MBTIMER_UEMTIMEOUT:
        {
            POINT pt;
            RECT rect;

            // Don't fire timeouts when we're in edit mode.
            if (_fEditMode)
            {
                KillTimer(_hwndMB, wParam);
                break;
            }

            GetWindowRect(_hwndMB, &rect);
            GetCursorPos(&pt);
            if (PtInRect(&rect, pt))
            {
                TraceMsg(TF_MENUBAND, "*** UEM TimeOut. At Tick Count (%d) ***", GetTickCount());
                _FireEvent(UEM_TIMEOUT);
            }
            else
            {
                TraceMsg(TF_MENUBAND, " *** UEM TimeOut. At Tick Count (%d)."
                    " Mouse outside menu. Killing *** ", GetTickCount());
                KillTimer(_hwndMB, wParam);
            }
        }
        break;


    case MBTIMER_EXPAND:
        KillTimer(_hwndMB, wParam);
        if (_fShowMB)
        {
            v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
            Expand(TRUE);
            _fClickHandled = TRUE;
            _SetTimer(MBTIMER_CLICKUNHANDLE); 
        }
        break;

    case MBTIMER_DRAGPOPDOWN:
        // There has not been a drag enter in this band for a while, 
        // so we'll try to cancel the menus.
        KillTimer(_hwndMB, wParam);
        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBDragCancel, 0, 0);
        break;

    case MBTIMER_DRAGOVER:
        {
            TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG)");
            KillTimer(_hwndMB, wParam);
            DAD_ShowDragImage(FALSE);
            // Does this item cascade?
            int idBtn = GetButtonCmd(_hwndMB, v_GetDragOverButton());
            DWORD dwFlags = v_GetFlags(idBtn);
            if (dwFlags & SMIF_SUBMENU)
            {
                TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG): Is a submenu");
                // Yes; pop it open
                if (!_fVerticalMB)
                    _pcmb->_fInvokedByDrag = TRUE;
                _DoPopup(idBtn, FALSE);
            }
            else if (dwFlags & SMIF_DRAGNDROP)
            {
                v_CallCBItem(idBtn, SMC_EXEC, 0, 1);
            }
            else if (idBtn == _idCmdChevron)
            {
                Expand(TRUE);

            }
            else
            {
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }

        }
        break;

    case MBTIMER_POPOUT:
        {
            int nItemTimer = _nItemTimer;
            KillPopupTimer();

            // Popup a new submenu?
            if (-1 != nItemTimer)
            {
                if (nItemTimer != _pcmb->_nItemCur)
                {
                    // Yes;  post message since the currently expanded submenu
                    // may be a CTrackPopup object, which posts its cancel mode.

                    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Timer went off.  Expanding...", this);
                    PostPopup(nItemTimer, FALSE, FALSE);
                }
            }
            else 
            {
                // No; just collapse the currently open submenu
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_CANCELLEVEL to submenu popup", this);
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }
            break;
        }
    
    case MBTIMER_CLOSE:
        KillTimer(_hwndMB, wParam);

        TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_FULLCANCEL", this);

        if (_fVerticalMB)
            _pcmb->_SiteOnSelect(MPOS_FULLCANCEL);
        else
        {
            _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
        }
        break;
    }
        
    return 1;
}


void CMenuToolbarBase::_DrawMenuArrowGlyph( HDC hdc, RECT * prc, COLORREF rgbText )
{
    SIZE size = {_pcmb->_pmbm->_cxArrow, _pcmb->_pmbm->_cyArrow};

    //
    // If the DC is mirrred, then the Arrow should be mirrored
    // since it is done thru TextOut, NOT the 2D graphics APIs [samera]
    //

    _DrawMenuGlyph(hdc, 
                   _pcmb->_pmbm->_hFontArrow,
                   prc, 
                   (IS_DC_RTL_MIRRORED(hdc)) ? CH_MENUARROWRTLA :
                   CH_MENUARROWA, 
                   rgbText, 
                   &size);
}


void CMenuToolbarBase::_DrawMenuGlyph( HDC hdc, HFONT hFont, RECT * prc, 
                               CHAR ch, COLORREF rgbText,
                               LPSIZE psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_pcmb->_pmbm->_hFontArrow)
    {
        SIZE    size;
        int cx, cy, y, x;
        HFONT hFontOld;
        int iOldBk = SetBkMode(hdc, TRANSPARENT);
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        if (psize == NULL)
        {
            GetTextExtentPoint32A( hdc, &ch, 1, &size);
            psize = &size;
        }

        cy = prc->bottom - prc->top;
        y = prc->top  + ((cy - psize->cy) / 2);

        cx = prc->right - prc->left;
        x = prc->left + ((cx - psize->cx) /2);
    
        COLORREF rgbOld = SetTextColor(hdc, rgbText);

        TextOutA(hdc, x, y, &ch, 1);
    
        SetTextColor(hdc, rgbOld);
        SetBkMode(hdc, iOldBk);
        SelectObject(hdc, hFontOld);
    }
}

void CMenuToolbarBase::SetMenuBandMetrics(CMenuBandMetrics* pmbm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // This can be called before the toolbar is created. 
    // So we'll check this condition. When the toolbar is created, then
    // the toolbar will get the metrics at that point.
    if (!_hwndMB)
        return;

    //Loop through toolbar.
    for (int iButton = ToolBar_ButtonCount(_hwndMB)-1; iButton >= 0; iButton--)
    {
        IOleCommandTarget* poct;

        int idCmd = GetButtonCmd(_hwndMB, iButton);

        // If it's not a seperator, see if there is a sub menu.
        if (idCmd != -1 &&
            SUCCEEDED(v_GetSubMenu(idCmd, NULL, IID_PPV_ARG(IOleCommandTarget, &poct))))
        {
            VARIANT Var;
            Var.vt = VT_UNKNOWN;
            Var.punkVal = SAFECAST(pmbm, IUnknown*);

            // Exec to set new Metrics.
            poct->Exec(&CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);
            poct->Release();
        }
    }

    _SetFontMetrics();
    // return
}

void CMenuToolbarBase::_SetFontMetrics()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_hwndMB && _pcmb->_pmbm)
    {
        SendMessage(_hwndMB, WM_SETFONT, (WPARAM)_pcmb->_pmbm->_hFontMenu, FALSE);

        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETFLAT, _pcmb->_pmbm->_fFlatMenuMode, NULL, NULL);
    }
}


HRESULT CMenuToolbarBase::CreateToolbar(HWND hwndParent)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT( _hwndMB != NULL );
    DWORD dwToolBarStyle = TBSTYLE_TRANSPARENT;

    // if we're set up as a popup, don't do any transparent stuff
    if (_fVerticalMB) 
    {
        dwToolBarStyle  = TBSTYLE_CUSTOMERASE;    // Vertical Toolbars don't get Transparent
        DWORD dwExtendedStyle = 0;

        // This is for TBMenu which actually has a Horizontal menubar within the 
        // Vertical menuband.
        if (!_fHorizInVerticalMB)
            dwExtendedStyle |= TBSTYLE_EX_VERTICAL;

        if (_fMulticolumnMB)
            dwExtendedStyle |= TBSTYLE_EX_MULTICOLUMN;

        ToolBar_SetExtendedStyle(_hwndMB, 
            dwExtendedStyle, TBSTYLE_EX_VERTICAL | TBSTYLE_EX_MULTICOLUMN);

        ToolBar_SetListGap(_hwndMB, LIST_GAP);
    }

    ToolBar_SetExtendedStyle(_hwndMB, TBSTYLE_EX_DOUBLEBUFFER, TBSTYLE_EX_DOUBLEBUFFER);

    SHSetWindowBits(_hwndMB, GWL_STYLE, 
        TBSTYLE_TRANSPARENT | TBSTYLE_CUSTOMERASE, dwToolBarStyle );

    ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));

    v_UpdateIconSize(_pcmb->_uIconSize, FALSE);

    _SetFontMetrics();

    if (_pszTheme)
    {
        SendMessage(_hwndMB, TB_SETWINDOWTHEME, 0, (LPARAM)_pszTheme);
        _RefreshTheme();
    }

    return S_OK;
}


HRESULT CMenuToolbarBase::_SetMenuBand(IShellMenu* psm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;
    IBandSite* pmbs = NULL;
    if (!_pcmb->_pmpSubMenu)
    {
        hres = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &_pcmb->_pmpSubMenu));
        if (SUCCEEDED(hres))
        {
            IUnknown_SetSite(_pcmb->_pmpSubMenu, SAFECAST(_pcmb, IOleCommandTarget*));
            hres = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pmbs));
            if (SUCCEEDED(hres))
            {
                hres = _pcmb->_pmpSubMenu->SetClient(pmbs);
                // Don't release pmbs here. We are using below
            }
            // Menu band will Release _pmpSubMenu.
        }
    }
    else
    {
        IUnknown* punk;
        _pcmb->_pmpSubMenu->GetClient(&punk);
        if (punk)
        {
            hres = punk->QueryInterface(IID_PPV_ARG(IBandSite, &pmbs));
            punk->Release();
        }
    }

    if (pmbs)
    {
        if (SUCCEEDED(hres))
            hres = pmbs->AddBand(psm);

        pmbs->Release();
    }
 
    return hres;
}

HRESULT CMenuToolbarBase::GetSubMenu(int idCmd, GUID* pguidService, REFIID riid, void** ppvObj)
{
    // pguidService is for asking a for specifically the Shell Folder portion or the Static portion
    HRESULT hres = E_FAIL;
    if (v_GetFlags(idCmd) & SMIF_TRACKPOPUP ||
        _pcmb->_dwFlags & SMINIT_DEFAULTTOTRACKPOPUP)
    {
        hres = v_CreateTrackPopup(idCmd, riid, (void**)ppvObj);
        if (SUCCEEDED(hres))
        {
            _pcmb->SetTrackMenuPopup((IUnknown*)*ppvObj);
        }
    }
    else
    {
        IShellMenu* psm;
        hres = v_GetSubMenu(idCmd, pguidService, IID_PPV_ARG(IShellMenu, &psm));
        if (SUCCEEDED(hres)) 
        {
            if (_pszTheme)
            {
                IShellMenu2* psm2;
                if (SUCCEEDED(psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2))))
                {
                    if (_fNoBorder)
                    {
                        psm2->SetNoBorder(_fNoBorder);
                    }

                    psm2->SetTheme(_pszTheme);
                    psm2->Release();
                }
            }

            TraceMsg(TF_MENUBAND, "GetUIObject psm %#lx", psm);
            _pcmb->SetTracked(this);

            hres = _SetMenuBand(psm);
            psm->Release();

            // Did we succeed in getting a menupopup?
            if (SUCCEEDED(hres))
            {
                // Yep; Sweet!
                _pcmb->_pmpSubMenu->QueryInterface(riid, ppvObj);

                HWND hwnd;
                IUnknown_GetWindow(_pcmb->_pmpSubMenu, &hwnd);
                PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBAutomation, (WPARAM)hwnd, (LPARAM)-1);
            }
        }
    }

    return hres;
}

HRESULT CMenuToolbarBase::PositionSubmenu(int idCmd)
{
    IMenuPopup* pmp = NULL;
    HRESULT hres = E_FAIL;
    DWORD dwFlags = 0;

    if (_pcmb->_fInSubMenu)
    {
        // Since the selection has probrably changed, we use the cached item id
        // to calculate the postion rect
        idCmd = _pcmb->_nItemSubMenu;
        dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;
        pmp = _pcmb->_pmpSubMenu;
        pmp->AddRef();

        ASSERT(pmp);    // If _fInSubmenu is set, then this must be valid
        hres = S_OK;
    }
    else
    {
        // Only do these when we're not repositioning.
        if (_pcmb->_fInitialSelect)
            dwFlags |= MPPF_INITIALSELECT;

        if (!_pcmb->_fCascadeAnimate)
            dwFlags |= MPPF_NOANIMATE;

        _pcmb->_nItemSubMenu = idCmd;

        hres = GetSubMenu(idCmd, NULL, IID_PPV_ARG(IMenuPopup, &pmp));
    }

    ASSERT(idCmd != -1);    // Make sure at this point we have an item.


    if (SUCCEEDED(hres))
    {
        ASSERT(pmp);

        // Make sure the menuitem is pressed
        _PressBtn(idCmd, TRUE);

        RECT rc;
        RECT rcTB;
        RECT rcTemp;
        POINT pt;

        if (!SendMessage(_hwndMB, TB_GETRECT, idCmd, (LPARAM)&rc))
        {
            // Under weird conditions, idCmd can be invalid.
            // (See bug 403077.)  So just blow off the reposition
            // and keep using the old position.
            hres = E_FAIL;
        }
        else
        {
            GetClientRect(_hwndMB, &rcTB);

            if (rc.right > rcTB.right)
            {
                rc.right = rcTB.right;
            }

            // Is the button rect within the boundries of the
            // visible toolbar?
            if (!IntersectRect(&rcTemp, &rcTB, &rc))
            {
                // No; Then we need to bias that rect into
                // the visible region of the toolbar.
                // We only want to bias one side
                if (rc.left > rcTB.right)
                {
                    rc.left = rcTB.right - (rc.right - rc.left);
                    rc.right = rcTB.right;
                }
            }

            MapWindowPoints(_hwndMB, HWND_DESKTOP, (POINT*)&rc, 2);

            if (_fVerticalMB)
            {
                pt.x = rc.right;
                pt.y = rc.top;
            }
            else
            {
                //
                // If the shell dropdown (toolbar button) menus are mirrored,
                // then take the right edge as the anchor point
                //
                if (IS_WINDOW_RTL_MIRRORED(_hwndMB))
                    pt.x = rc.right;
                else
                    pt.x = rc.left;
                pt.y = rc.bottom;
            }

            // Since toolbar buttons expand almost to the end of the basebar,
            // shrink the exclude rect so if overlaps.
            // NOTE: the items are GetSystemMetrics(SM_CXEDGE) larger than before. So adjust to that.

            if (_pcmb->_fExpanded)
                InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), 0);

            // We want to stop showing the chevron tip when we cascade into another menu
            _pcmb->_pmbState->HideTooltip(TRUE);

            // Only animate the first show at this level.
            _pcmb->_fCascadeAnimate = FALSE;

            hres = pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlags);
        }
        pmp->Release();

    }
    return hres;
}
/*----------------------------------------------------------
Purpose: Cascade to the _nItemCur item's menu popup.

         If the popup call was modal, S_FALSE is returned; otherwise
         it is S_OK, or error.

*/
HRESULT CMenuToolbarBase::PopupOpen(int idBtn)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;


    // Tell the current submenu popup to cancel.  This must be done 
    // before the PostMessage b/c CTrackPopupBar itself posts a message
    // which it must receive before we receive our post.
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): PostPop